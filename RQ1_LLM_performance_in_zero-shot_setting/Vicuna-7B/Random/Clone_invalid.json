[
    {
        "ID": 388,
        "prompt": "A chat between a curious user and an artificial intelligence assistant. \n### User: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String downloadToSdCard(String localFileName, String suffixFromHeader, String extension) { InputStream in = null; FileOutputStream fos = null; String absolutePath = null; try { Log.i(TAG, \"Opening URL: \" + url); StreamAndHeader inAndHeader = HTTPUtils.openWithHeader(url, suffixFromHeader); if (inAndHeader == null || inAndHeader.mStream == null) { return null; } in = inAndHeader.mStream; String sdcardpath = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); String headerValue = suffixFromHeader == null || inAndHeader.mHeaderValue == null ? \"\" : inAndHeader.mHeaderValue; headerValue = headerValue.replaceAll(\"[-:]*\\\\s*\", \"\"); String filename = sdcardpath + \"/\" + localFileName + headerValue + (extension == null ? \"\" : extension); mSize = in.available(); Log.i(TAG, \"Downloading \" + filename + \", size: \" + mSize); fos = new FileOutputStream(new File(filename)); int buffersize = 1024; byte[] buffer = new byte[buffersize]; int readsize = buffersize; mCount = 0; while (readsize != -1) { readsize = in.read(buffer, 0, buffersize); if (readsize > 0) { Log.i(TAG, \"Read \" + readsize + \" bytes...\"); fos.write(buffer, 0, readsize); mCount += readsize; } } fos.flush(); fos.close(); FileInputStream controlIn = new FileInputStream(filename); mSavedSize = controlIn.available(); Log.v(TAG, \"saved size: \" + mSavedSize); mAbsolutePath = filename; done(); } catch (Exception e) { Log.e(TAG, \"LoadingWorker.run\", e); } finally { HTTPUtils.close(in); } return mAbsolutePath; }. \nCode2: public void writeData(String name, int items, int mznum, int mzscale, long tstart, long tdelta, int[] peaks) { PrintWriter file = getWriter(name + \".txt\"); file.println(\"999 9999\"); file.println(\"Doe, John\"); file.println(\"TEST Lab\"); if (mzscale == 1) file.println(\"PALMS Positive Ion Data\"); else if (mzscale == -1) file.println(\"PALMS Negative Ion Data\"); else file.println(\"PALMS GJIFJIGJ Ion Data\"); file.println(\"TEST Mission\"); file.println(\"1 1\"); file.println(\"1970 01 01 2008 07 09\"); file.println(\"0\"); file.println(\"TIME (UT SECONDS)\"); file.println(mznum + 4); for (int i = 0; i < mznum + 4; i++) file.println(\"1.0\"); for (int i = 0; i < mznum + 4; i++) file.println(\"9.9E29\"); file.println(\"TOTION total MCP signal (electron units)\"); file.println(\"HMASS high mass integral (fraction)\"); file.println(\"UNLIST (unlisted low mass peaks (fraction)\"); file.println(\"UFO unidentified peaks (fraction)\"); for (int i = 1; i <= mznum; i++) file.println(\"MS\" + i + \" (fraction)\"); int header2length = 13; file.println(header2length); for (int i = 0; i < header2length; i++) file.println(\"1.0\"); for (int i = 0; i < header2length; i++) file.println(\"9.9E29\"); file.println(\"AirCraftTime aircraft time (s)\"); file.println(\"INDEX index ()\"); file.println(\"SCAT scatter (V)\"); file.println(\"JMETER joule meter ()\"); file.println(\"ND neutral density (fraction)\"); file.println(\"SCALEA Mass scale intercept (us)\"); file.println(\"SCALEB mass scale slope (us)\"); file.println(\"NUMPKS number of peaks ()\"); file.println(\"CONF confidence (coded)\"); file.println(\"CAT preliminary category ()\"); file.println(\"AeroDiam aerodynamic diameter (um)\"); file.println(\"AeroDiam1p7 aero diam if density=1.7 (um)\"); file.println(\"TOTBACK total background subtracted (electron units)\"); file.println(\"0\"); file.println(\"0\"); String nothing = \"0.000000\"; for (int i = 0; i < items; i++) { file.println(tstart + (tdelta * i)); file.println(tstart + (tdelta * i) - 3); file.println(i + 1); for (int j = 0; j < 15; j++) file.println(Math.random()); boolean peaked = false; for (int k = 1; k <= mznum; k++) { for (int j = 0; j < peaks.length && !peaked; j++) if (k == peaks[j]) { double randData = (int) (1000000 * (j + 1)); file.println(randData / 1000000); peaked = true; } if (!peaked) file.println(nothing); peaked = false; } } try { Scanner test = new Scanner(f); while (test.hasNext()) { System.out.println(test.nextLine()); } System.out.println(\"test\"); } catch (Exception e) { } file.close(); }. \n### Assistant: YES. \n\n### User: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void forBundle(BundleManipulator manip) { ByteArrayOutputStream bout = null; try { bout = new ByteArrayOutputStream(); ZipOutputStream zout = new ZipOutputStream(bout); Bundle bundle = getBundle(); Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false); if (files != null) { while (files.hasMoreElements()) { URL url = files.nextElement(); String name = url.getFile(); if (name.startsWith(\"/\")) { name = name.substring(1); } if (manip.includeEntry(name)) { zout.putNextEntry(new ZipEntry(name)); IOUtils.copy(url.openStream(), zout); } } } manip.finish(bundle, zout); Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream()); zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\")); mf.write(zout); zout.close(); File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\"); FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray()); if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) { pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME)); } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) { pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY)); } pluginController.installPlugin(new JarPluginArtifact(tmpFile)); ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName()); ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null); tmpFile.delete(); } catch (IOException e) { e.printStackTrace(); } finally { IOUtils.closeQuietly(bout); } }. \nCode2: public static void copyFile(File in, File out) throws IOException { if (in.getCanonicalPath().equals(out.getCanonicalPath())) { return; } FileChannel inChannel = new FileInputStream(in).getChannel(); FileChannel outChannel = new FileOutputStream(out).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } catch (IOException e) { throw e; } finally { if (inChannel != null) { inChannel.close(); } if (outChannel != null) { outChannel.close(); } } }. \n### Assistant:",
        "ground_truth": 1,
        "predict": "There is a close relationship between the two codes, as they both perform file operations on a local file and a SD card. Code1 downloads a file from the URL to the SD card and saves it to the SD card, while Code2 copies a file from one local file to another local file. Both codes use file input and output streams to perform the operations."
    },
    {
        "ID": 526,
        "prompt": "A chat between a curious user and an artificial intelligence assistant. \n### User: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private boolean subtitleDownload(Movie movie, File movieFile, File subtitleFile) { try { String ret; String xml; String moviehash = getHash(movieFile); String moviebytesize = String.valueOf(movieFile.length()); xml = generateXMLRPCSS(moviehash, moviebytesize); ret = sendRPC(xml); String subDownloadLink = getValue(\"SubDownloadLink\", ret); if (subDownloadLink.equals(\"\")) { String moviefilename = movieFile.getName(); if (!(moviefilename.toUpperCase().endsWith(\".M2TS\") && moviefilename.startsWith(\"0\"))) { String subfilename = subtitleFile.getName(); int index = subfilename.lastIndexOf(\".\"); String query = subfilename.substring(0, index); xml = generateXMLRPCSS(query); ret = sendRPC(xml); subDownloadLink = getValue(\"SubDownloadLink\", ret); } } if (subDownloadLink.equals(\"\")) { logger.finer(\"OpenSubtitles Plugin: Subtitle not found for \" + movie.getBaseName()); return false; } logger.finer(\"OpenSubtitles Plugin: Download subtitle for \" + movie.getBaseName()); URL url = new URL(subDownloadLink); HttpURLConnection connection = (HttpURLConnection) (url.openConnection()); connection.setRequestProperty(\"Connection\", \"Close\"); InputStream inputStream = connection.getInputStream(); int code = connection.getResponseCode(); if (code != HttpURLConnection.HTTP_OK) { logger.severe(\"OpenSubtitles Plugin: Download Failed\"); return false; } GZIPInputStream a = new GZIPInputStream(inputStream); OutputStream out = new FileOutputStream(subtitleFile); byte buf[] = new byte[1024]; int len; while ((len = a.read(buf)) > 0) { out.write(buf, 0, len); } out.close(); movie.setSubtitles(true); return true; } catch (Exception e) { logger.severe(\"OpenSubtitles Plugin: Download Exception (Movie Not Found)\"); return false; } }. \nCode2: public long copyFileWithPaths(String userBaseDir, String sourcePath, String destinPath) throws Exception { if (userBaseDir.endsWith(sep)) { userBaseDir = userBaseDir.substring(0, userBaseDir.length() - sep.length()); } String file1FullPath = new String(); if (sourcePath.startsWith(sep)) { file1FullPath = new String(userBaseDir + sourcePath); } else { file1FullPath = new String(userBaseDir + sep + sourcePath); } String file2FullPath = new String(); if (destinPath.startsWith(sep)) { file2FullPath = new String(userBaseDir + destinPath); } else { file2FullPath = new String(userBaseDir + sep + destinPath); } long plussQuotaSize = 0; BufferedInputStream in = null; BufferedOutputStream out = null; byte dataBuff[] = new byte[bufferSize]; File fileordir = new File(file1FullPath); if (fileordir.exists()) { if (fileordir.isFile()) { File file2 = new File(file2FullPath); if (file2.exists()) { plussQuotaSize -= file2.length(); file2.delete(); } FileUtils.getInstance().createDirectory(file2.getParent()); in = new BufferedInputStream(new FileInputStream(file1FullPath), bufferSize); out = new BufferedOutputStream(new FileOutputStream(file2FullPath), bufferSize); int readLen; while ((readLen = in.read(dataBuff)) > 0) { out.write(dataBuff, 0, readLen); plussQuotaSize += readLen; } out.flush(); in.close(); out.close(); } if (fileordir.isDirectory()) { String[] entryList = fileordir.list(); if (entryList.length > 0) { for (int pos = 0; pos < entryList.length; pos++) { String entryName = entryList[pos]; String file1FullPathEntry = new String(file1FullPath.concat(entryList[pos])); String file2FullPathEntry = new String(file2FullPath.concat(entryList[pos])); File file2 = new File(file2FullPathEntry); if (file2.exists()) { plussQuotaSize -= file2.length(); file2.delete(); } FileUtils.getInstance().createDirectory(file2.getParent()); in = new BufferedInputStream(new FileInputStream(file1FullPathEntry), bufferSize); out = new BufferedOutputStream(new FileOutputStream(file2FullPathEntry), bufferSize); int readLen; while ((readLen = in.read(dataBuff)) > 0) { out.write(dataBuff, 0, readLen); plussQuotaSize += readLen; } out.flush(); in.close(); out.close(); } } } } else { throw new Exception(\"Source file or dir not exist ! file1FullPath = (\" + file1FullPath + \")\"); } return plussQuotaSize; }. \n### Assistant: YES. \n\n### User: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL().toString()); } else if (item.getType() == Type.ANY_URI) { LOG.debug(\"Streaming xs:anyURI\"); String url = item.getStringValue(); if (url.startsWith(\"/\")) { url = \"xmldb:exist://\" + url; } InputStream is = new URL(url).openStream(); streamSource.setInputStream(is); streamSource.setSystemId(url); } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) { LOG.debug(\"Streaming element or document node\"); if (item instanceof NodeProxy) { NodeProxy np = (NodeProxy) item; String url = \"xmldb:exist://\" + np.getDocument().getBaseURI(); LOG.debug(\"Document detected, adding URL \" + url); streamSource.setSystemId(url); } Serializer serializer = context.getBroker().newSerializer(); NodeValue node = (NodeValue) item; InputStream is = new NodeInputStream(serializer, node); streamSource.setInputStream(is); } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) { LOG.debug(\"Streaming base64 binary\"); BinaryValue binary = (BinaryValue) item; byte[] data = (byte[]) binary.toJavaObject(byte[].class); InputStream is = new ByteArrayInputStream(data); streamSource.setInputStream(is); if (item instanceof Base64BinaryDocument) { Base64BinaryDocument b64doc = (Base64BinaryDocument) item; String url = \"xmldb:exist://\" + b64doc.getUrl(); LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url); streamSource.setSystemId(url); } } else { LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType())); throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType())); } return streamSource; }. \nCode2: private String retrieveTemplate() throws Exception { if (cachedTemplate == null) { final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl()); final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); final StringBuilder result = new StringBuilder(); String line; while ((line = in.readLine()) != null) { result.append(line); } in.close(); cachedTemplate = result.toString(); } return cachedTemplate; }. \n### Assistant:",
        "ground_truth": 0,
        "predict": "There is a close relationship between the two codes as they both involve working with files and URLs to retrieve or download data. Code1 is used to download a file from a URL and store it in a specified directory, while Code2 is used to retrieve a template from a URL and cache it for future use. Both codes use similar techniques such as reading input streams and writing to output streams, and both involve checking for the existence of the file or URL before proceeding with the download or retrieval process."
    }
]