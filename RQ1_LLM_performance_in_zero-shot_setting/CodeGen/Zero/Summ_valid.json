[{"ID": 1, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = downstream; final SimplePlainQueue<U> q = queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); } \nResponse:", "ground_truth": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "predict": "\npublic final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = this.downstream; final SimplePlainQueue<U> q = this.queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); } \n */\n"}, {"ID": 2, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public static <T> Observable<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); } \nResponse:", "ground_truth": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n\nScheduler:\n{@code wrap} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "predict": " Response<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); } \n\n*/\n"}, {"ID": 3, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Observable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\"); return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "predict": " @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody) { return toObservable().map(responseBody::toResponse); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer) { return toObservable().map(responseBody::toResponse).transform(transformer); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer, ErrorHandler errorHandler) { return toObservable().map(responseBody::toResponse).transform(transformer, errorHandler); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer"}, {"ID": 4, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); } \nResponse:", "ground_truth": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "\n\npublic static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Function;\nimport io.reactivex.internal.functions.ObjectHelper;\nimport io.reactivex.internal.subscriptions.SubscriptionHelper;\nimport io.reactivex.plugins.RxJavaPlugins;\n\npublic final class Replay<T> extends"}, {"ID": 5, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "predict": " @NonNull UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\n                \"/*\\n\" +\n                \" * Copyright (c) 2017-present, Facebook, Inc.\\n\" +\n                \" * All rights reserved.\\n\" +\n                \" *\\n\" +\n                \" * This source code is licensed under the BSD-style license found in the\\n\" +\n                \" * LICENSE file in the root directory of this source tree. An additional grant\\n\" +\n                \" * of patent rights can be found in the PATENTS file in the same directory.\\n\" +\n                \" *\\n\" +\n                \" */\\n\" +\n                \"\\n\" +\n                \"package com.facebook.fresco.sample"}, {"ID": 6, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) { ObjectHelper.requireNonNull(onCancelled, \"onTerminate\"); return new UnicastProcessor<T>(capacityHint, onCancelled); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "predict": " @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \nResp @NonNull public static <T> UnicastProcessor<T> create() { return new UnicastProcessor<T>(); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier) { return new UnicastProcessor<T>(supplier); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier, @NonNull Consumer<? super T> onSuccess) { return new UnicastProcessor<T>(supplier, onSuccess); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier, @NonNull Consumer<? super T>"}, {"ID": 7, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (u == null) { EmptySubscription.complete(subscriber); return true; } subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u)); } else { r.subscribe(subscriber); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param  the input value type\n@param  the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "predict": "\n\n@SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u;"}, {"ID": 8, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into a Publisher and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "predict": "\n\nimport static org.reactivestreams.Publisher.*;\n\nimport java.util.concurrent.Flowable;\n\nimport org.reactivestreams.Publisher;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Function;\n\npublic final class ScalarXMapFlowable<T, U> extends Flowable<U> {\n    final T value;\n    final Function<? super T, ? extends Publisher<? extends U>> mapper;\n\n    public ScalarXMapFlowable(T value, Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        this.value = value;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public void subscribeActual(Subscriber<? super U> s) {\n        Publisher<? extends U> p;\n        try {\n            p = ObjectHelper.requireNonNull(mapper.apply(value),"}, {"ID": 9, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { setErrorHandler(null); setScheduleHandler(null); setComputationSchedulerHandler(null); setInitComputationSchedulerHandler(null); setIoSchedulerHandler(null); setInitIoSchedulerHandler(null); setSingleSchedulerHandler(null); setInitSingleSchedulerHandler(null); setNewThreadSchedulerHandler(null); setInitNewThreadSchedulerHandler(null); setOnFlowableAssembly(null); setOnFlowableSubscribe(null); setOnObservableAssembly(null); setOnObservableSubscribe(null); setOnSingleAssembly(null); setOnSingleSubscribe(null); setOnCompletableAssembly(null); setOnCompletableSubscribe(null); setOnConnectableFlowableAssembly(null); setOnConnectableObservableAssembly(null); setOnMaybeAssembly(null); setOnMaybeSubscribe(null); setOnParallelAssembly(null); setFailOnNonBlockingScheduler(false); setOnBeforeBlocking(null); } \nResponse:", "ground_truth": "Removes all handlers and resets to default behavior.", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n"}, {"ID": 10, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); } \nResponse:", "ground_truth": "Wraps a CompletableSource into a Maybe.\n\n\nScheduler:\n{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "predict": " Response<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); } \n\n*/\n\nimport io.reactivex.annotations.CheckReturnValue;\nimport io.reactivex.annotations.NonNull;\nimport io.reactivex.functions.Function;\nimport java.util.concurrent.Callable;\n\npublic final class MaybeFromCompletable<T> extends Single<T> {\n\n    final CompletableSource source;\n\n    public MaybeFromCompletable(CompletableSource source) {\n        this.source = source;\n    }\n\n    @Override\n    @CheckReturnValue\n    @NonNull\n    protected SingleSource<T> apply(@NonNull SingleSource<T> t) {\n        return t"}, {"ID": 11, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) { ObjectHelper.requireNonNull(singleSource, \"singleSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource)); } \nResponse:", "ground_truth": "Wraps a SingleSource into a Maybe.\n\n\nScheduler:\n{@code fromSingle} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "predict": " Response<T> fromSingle(SingleSource<T> singleSource) { return RxJavaPlugins.onAssembly(new SingleToResponse<T>(singleSource)); } \n\n*/\n\n/**\n * Generated from RxJava2Plugins-3.x.x/RxJava/Single/toMaybe.java.\n */\npublic class MaybeToMaybe<T> extends SingleToMaybe<T> {\n    public MaybeToMaybe(SingleSource<T> source) {\n        super(source);\n    }\n}\n"}, {"ID": 12, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); } \nResponse:", "ground_truth": "Retries at most times or until the predicate returns false, whichever happens first.\n\n\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "predict": " @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(long times) { return toFlowable().retry(times).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry() { return toFlowable().retry().singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(Predicate<? super Throwable> predicate) { return toFlowable().retry(predicate).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public"}, {"ID": 13, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T requireNonNull(T object, String message) { if (object == null) { throw new NullPointerException(message); } return object; } \nResponse:", "ground_truth": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param  the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "predict": "\n\npublic static <T> T requireNonNull(T object, String message) {\n    if (object == null) {\n        throw new NullPointerException(message);\n    }\n    return object;\n}\n\n*/\n\nimport java.util.Objects;\n\npublic class JavaCodeGenerator {\n\n    public static void main(String[] args) {\n        JavaCodeGenerator generator = new JavaCodeGenerator();\n        generator.generateJavaCode();\n    }\n\n    public void generateJavaCode() {\n        String className = \"JavaCodeGenerator\";\n        String packageName = \"com.example.java.generator\";\n        String classNameWithPackage = packageName + \".\" + className;\n        String classNameWithPackageLowerCase = packageName + \".\" + className.toLowerCase();\n        String classNameWithPackageUpperCase = packageName + \".\" + className.toUpperCase();\n        String class"}, {"ID": 14, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; } \nResponse:", "ground_truth": "Returns an identity function that simply returns its argument.\n@param  the input and output value type\n@return the identity function", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 15, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); } \nResponse:", "ground_truth": "Returns a Callable that returns the given value.\n@param  the value type\n@param value the value to return\n@return the new Callable instance", "predict": "\n\npublic static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); }\n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Callable<String> callable = new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"Hello World\";\n            }\n        };\n        Future<String> future = executor.submit(call"}, {"ID": 16, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); } \nResponse:", "ground_truth": "Returns a Function that ignores its parameter and returns the given value.\n@param  the function's input type\n@param  the value and return type of the function\n@param value the value to return\n@return the new Function instance", "predict": "\n\npublic static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); }\n\n*/\n\npublic class JustValue<T, U> implements Function<T, U> {\n    private final U value;\n\n    public JustValue(U value) {\n        this.value = value;\n    }\n\n    @Override\n    public U apply(T t) {\n        return value;\n    }\n}\n"}, {"ID": 17, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); } \nResponse:", "ground_truth": "Returns a function that cast the incoming values via a Class object.\n@param  the input value type\n@param  the output and target type\n@param target the target class\n@return the new Function instance", "predict": "\n\npublic static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); }\n\n*/\n\npublic class CastToClass<T, U> implements Function<T, U> {\n    private Class<U> target;\n\n    public CastToClass(Class<U> target) {\n        this.target = target;\n    }\n\n    @Override\n    public U apply(T t) {\n        return (U) t;\n    }\n}\n"}, {"ID": 18, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param  the value type\n@return an UnicastSubject instance", "predict": " @NonNull UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); } \n\n*/\n\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int bufferSize, boolean delayError) {\n        super(bufferSize, delayError);\n    }\n\n    @Override\n    public void onNext(T t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onError(Throwable t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onComplete() {\n        if (compareAndSet(null, null)) {\n            drain();\n        }\n    }\n\n    @Override\n    public boolean hasObservers() {\n        return s.get()"}, {"ID": 19, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "predict": " @NonNull UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); } \n */\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int capacityHint, boolean delayError) {\n        super(new UnicastSubjectInner<T>(capacityHint, delayError));\n    }\n}\n"}, {"ID": 20, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "predict": " @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); } \n */\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    final int capacityHint;\n    final Runnable onTerminate;\n    final boolean hasSubscribers;\n\n    public UnicastSubject(int capacityHint, Runnable onTerminate, boolean hasSubscribers) {\n        super(new UnicastSubjectInner<T>(capacityHint, onTerminate, hasSubscribers));\n        this.capacityHint = capacityHint;\n        this.onTerminate = onTerminate;\n        this.hasSubscribers = hasSubscribers;\n    }\n\n    @Override\n    public int getBufferSize() {\n        return capacityHint;\n    }\n\n    @Override\n"}, {"ID": 21, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\nHistory: 2.0.8 - experimental\n@param  the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "predict": " @NonNull UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); } \n\n*/\n\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int bufferSize, boolean delayError) {\n        super(bufferSize, delayError);\n    }\n\n    @Override\n    public void onNext(T t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onError(Throwable t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onComplete() {\n        if (compareAndSet(null, null)) {\n            drain();\n        }\n    }\n\n    @Override\n    public boolean hasObservers() {\n"}, {"ID": 22, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError() { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); await(); } catch (InterruptedException ex) { dispose(); return ex; } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "predict": " public void setError(Throwable error) { this.error = error; } \nResp public void setCount(int count) { this.count = count; } \nResp public int getCount() { return count; } \nResp public void setBlockingHelper(BlockingHelper helper) { this.helper = helper; } \nResp public BlockingHelper getBlockingHelper() { return helper; } \nResp public void setError(String error) { this.error = error; } \nResp public String getError() { return error; } \nResp public void setCount(String count) { this.count = count; } \nResp public String getCount() { return count; } \nResp public void setBlockingHelper(String helper) { this.helper = helper; } \nResp public String getBlockingHelper() { return helper; } \nResp public void setError(String error, Throwable t"}, {"ID": 23, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "predict": " public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; } \n\n}\n"}, {"ID": 24, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; } \nResponse:", "ground_truth": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "predict": " public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; } \n\n}\n"}, {"ID": 25, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\")); return; } } missed = qd.leave(-missed); if (missed == 0) { break; } } } \nResponse:", "ground_truth": "Drain the queue but give up with an error if there aren't enough requests.\n@param  the queue value type\n@param  the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "predict": "\npublic static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException"}, {"ID": 26, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void request(Subscription s, int prefetch) { s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch); } \nResponse:", "ground_truth": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 27, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } } \nResponse:", "ground_truth": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n\nDon't modify the queue after calling this method!\n\n\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param  the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "predict": " public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } } \nResp public static <T> void postComplete(Subscriber<? super T> actual,"}, {"ID": 28, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } } \nResponse:", "ground_truth": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "predict": " public final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } } \nResp public final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazy"}, {"ID": 29, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; } \nResponse:", "ground_truth": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "predict": " @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceArrayFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerArrayFieldUpdater;\nimport java.util.concurrent.atomic"}, {"ID": 30, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; } \nResponse:", "ground_truth": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "predict": " @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; } \n\n*/\n\npublic class GenerateNotificationLite {\n\n    public static void main(String[] args) {\n        String className = \"Test\";\n        String packageName = \"com.example\";\n        String classNameWithPackage = packageName + \".\" + className;\n        String classNameWithPackageLower = packageName.toLowerCase() + \".\" + className;\n        String classNameWithPackageUpper = packageName.toUpperCase() + \".\" + className;\n        String classNameWithPackageLowerUpper = packageName.toUpperCase() + \".\" + className.toUpperCase();\n        String classNameWithPackageLowerLower = packageName.toLowerCase() + \".\" + className.toLowerCase();\n        "}, {"ID": 31, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "predict": " public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \n\n*/\n\npublic class ObservableDisposableTest {\n\n    @Test\n    public void testObservable() {\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        \n        Observable.just(1, 2, 3)\n        .subscribe(ts);\n        \n        ts.assertValues(1, 2, 3)\n        .assertNoErrors()\n        .assertComplete();\n    }\n    \n    @Test\n    public void testObservableJust() {\n        TestSubscriber<Integer> ts = new TestSub"}, {"ID": 32, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \n\n*/\n\npublic class ObservableSetOnce<T> extends Observable<T> {\n\n    private final SetOnce<T> setOnce;\n\n    public ObservableSetOnce(SetOnce<T> setOnce) {\n        this.setOnce = setOnce;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super T> observer) {\n        SetOnceObserver<T> parent = new SetOnceObserver<T>(observer);\n        observer.onSubscribe(parent);\n        parent"}, {"ID": 33, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "predict": " public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.reactivestreams.Subscription;\n\npublic class SubscriptionHelper {\n    public static final Subscription CANCELLED = new Subscription() {\n        @Override\n        public void request(long n) {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n\n        @Override\n        public void cancel() {\n            throw new UnsupportedOperation"}, {"ID": 34, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceSubscription {\n\n    public static void main(String[] args) {\n        AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();\n        Subscription next = new Subscription() {\n            @Override\n            public void request(long n) {\n                System.out.println(\"request \" + n);\n            }\n\n            @Override\n            public void cancel() {\n                System.out.println(\"c"}, {"ID": 35, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; } \nResponse:", "ground_truth": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "predict": "\n\npublic static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; }\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++){\n            arr[i] = in.nextLong();\n        }\n        long sum = 0;\n        for(int i=0;i<n;i++){\n            sum += arr[i];\n        }\n        System.out.println(sum);\n    }\n}\n"}, {"ID": 36, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; } \nResponse:", "ground_truth": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "predict": "\n\npublic static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; } \n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long u = a * b;\n        if (((a | b) >>> 31) != 0) {\n            if (u / a != b) {\n                System.out.println(Long.MAX_VALUE);\n            } else {\n                System.out.println(u);\n            }\n        } else {\n            System.out.println(u"}, {"ID": 37, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long add(AtomicLong requested, long n) { for (;;) { long r = requested.get(); if (r == Long.MAX_VALUE) { return Long.MAX_VALUE; } long u = addCap(r, n); if (requested.compareAndSet(r, u)) { return r; } } } \nResponse:", "ground_truth": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class Solution {\n    public static void main(String[] args) {\n        AtomicLong requested = new AtomicLong(0);\n        long n = 1;\n        long r = addCap(requested, n);\n        System.out.println(r);\n    }\n\n    public static long addCap(AtomicLong requested, long n) {\n        for (;;) {\n            long r = requested.get();\n            if (r == Long.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            long u = addCap(r, n);\n            if (requested.compareAndSet(r, u)) {\n                return r;\n            }\n        }\n    }\n}\n"}, {"ID": 38, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static NullPointerException toNpe(Throwable ex) { NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\"); npe.initCause(ex); return npe; } \nResponse:", "ground_truth": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "predict": "\n\npublic static NullPointerException toNpe(Throwable ex) {\n\tNullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n\tnpe.initCause(ex);\n\treturn npe;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        System.out.println(toNpe(new Exception()));\n    }\n    \n    public static NullPointerException toNpe(Throwable ex) {\n        NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n        npe.initCause(ex);\n        return npe;\n    }\n}\n"}, {"ID": 39, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } } \nResponse:", "ground_truth": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9,10};\n        int n = nums.length;\n        int[] result = new int[n];\n        int[] temp = new int[n];\n        int[] temp2 = new int[n];\n        int[] temp3 = new int[n];\n        int[] temp4 = new int[n];\n        int[] temp5 = new int[n];\n        int[] temp6 = new int[n];\n        int[] temp7 = new int[n];\n        int[] temp8 = new int[n];\n        int[] temp9 = new int[n];\n        int[] temp10 = new int[n];"}, {"ID": 40, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void shutdown() { ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null); if (exec != null) { exec.shutdownNow(); } POOLS.clear(); } \nResponse:", "ground_truth": "Stops the purge thread.", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class Shutdown {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newSingleThreadScheduledExecutor();\n        ScheduledExecutorService exec2 = Executors.newSingleThreadScheduledExecutor();\n        exec.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"ExecutorService shutdown\");\n                exec.shutdown();\n            }\n        }, 10, TimeUnit.SECONDS);\n        exec2.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"ScheduledExec"}, {"ID": 41, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; } \nResponse:", "ground_truth": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "predict": " public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; } \n\n*/\n\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScheduledExecutorServiceTest {\n    public static void main(String[] args) {\n        ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread t = new Thread(r);\n                t.setDaemon(true);\n                return t;\n            }\n"}, {"ID": 42, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); } \nResponse:", "ground_truth": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "predict": " public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); } \n */\n\npublic class SingleProducerConsumerTest {\n\n    @Test\n    public void testSingleProducerConsumer() throws InterruptedException {\n        final AtomicLong counter = new AtomicLong();\n        final AtomicReference<Subscription> ref = new AtomicReference"}, {"ID": 43, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } } \nResponse:", "ground_truth": "Loops until all notifications in the queue has been processed.", "predict": " void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.emitLoop();\n    }\n    \n    public void emitLoop() {\n        emit(\"void emitLoop() {\");\n        emit(\"    for (;;) {\");\n        emit(\"        AppendOnlyLinkedArrayList<Object> q;\");\n        emit(\"        synchronized (this) {\");\n        emit(\"            q = queue;\");\n        emit(\"            if (q == null) {\");\n        emit(\"                emitting = false;\");\n        emit(\"                return;\");\n        emit"}, {"ID": 44, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RuntimeException wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (RuntimeException)error; } return new RuntimeException(error); } \nResponse:", "ground_truth": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "predict": " Response<T> wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (Response<T>)error; } if (error instanceof IOException) { throw (IOException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error instanceof TimeoutException) { throw (TimeoutException)error; } if (error instanceof ExecutionException) { throw (ExecutionException)error; } if (error instanceof CancellationException) { throw (CancellationException)error; } if (error instanceof TimeoutException) { throw (TimeoutException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error instanceof IOException) { throw (IOException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error"}, {"ID": 45, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; } \nResponse:", "ground_truth": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "predict": " public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; } \n\n*/\n\nimport java.util.ArrayDeque;\nimport java.util.List;\n\npublic class Flatten {\n\n    public static List<Throwable> flatten(Throwable t) {\n        List<Throwable> list = new Array"}, {"ID": 46, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return (Exception)e; } throw (E)e; } \nResponse:", "ground_truth": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param  the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "predict": " Response<T> throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return Response.success((T)e); } throw (E)e; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.NameValuePair;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.util.Log;\n\npublic class Utils {\n\t\n\tpublic static final String PREF_NAME = \"pref_name\";\n\tpublic static final String PREF_NAME_KEY = \"pref_name_key\";\n\tpublic static final String PREF_NAME_VALUE = \"pref_"}, {"ID": 47, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); } \nResponse:", "ground_truth": "Atomically clears the container, then disposes all the previously contained Disposables.", "predict": " public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); } \n */\n\npublic class DisposableResource {\n    private static final Logger LOGGER = LoggerFactory.getLogger(DisposableResource.class);\n    private static final String DISPOSABLE_RESOURCE_PREFIX = \"DisposableResource\";\n    private static final String DISPOSABLE_RESOURCE_SUFFIX = \"DisposableResource\";\n    private static final String DISPOSABLE_RESOURCE_PREFIX_WITH_SEPARATOR = DISPOSABLE_RESOURCE_PREFIX + \".\";\n    private static final String DISPOSABLE_RESOURCE_SUFFIX_WITH_SEPARATOR = DISPOSABLE_RESOURCE_SUFFIX + \".\";\n    private static final"}, {"ID": 48, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int size() { if (disposed) { return 0; } synchronized (this) { if (disposed) { return 0; } OpenHashSet<Disposable> set = resources; return set != null ? set.size() : 0; } } \nResponse:", "ground_truth": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 49, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (u == null) { EmptyDisposable.complete(observer); return true; } ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u); observer.onSubscribe(sd); sd.run(); } else { r.subscribe(observer); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param  the input value type\n@param  the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "predict": "\n\npublic static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try"}, {"ID": 50, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into an Observable and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "predict": "\n\npublic static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); } \n\n*/\n\npublic class ScalarXMapObservable<T, R> extends Observable<R> {\n    final T value;\n    final Function<? super T, ? extends ObservableSource<? extends R>> mapper;\n\n    public ScalarXMapObservable(T value, Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n        this.value = value;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super R> s) {\n        ObservableSource<? extends R> o;\n        try {\n            o = Object"}, {"ID": 51, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param  the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "predict": " public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; } \n */\n\npublic class Main {\n    public static void main(String[] args) {\n        final int capacity = 10;\n        final int count = 100;\n        final int[] data = new int[count];\n        for (int i = 0; i < count; i++) {\n            data[i] = i;\n        }\n        final int[] data2 = new int[count];\n        for (int i = 0; i < count; i++) {\n            data2[i] ="}, {"ID": 52, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param  the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "predict": " public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; } \n */\n\npublic class Main {\n    public static void main(String[] args) {\n        Observer<Integer> observer = new Observer<Integer>() {\n            @Override\n            public void onNext(Integer integer) {\n                System.out.println(\"onNext: \" + integer);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"onError: \" + e);\n            }\n\n            @Override\n            public void onCompleted()"}, {"ID": 53, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } } \n */\npublic class SpscArrayQueue<T> extends AbstractQueue<T> {\n    private final int bufferSize;\n    private final int mask;\n    private final Object[] items;\n    private int putIndex;\n    private int takeIndex;\n    private int count;\n    private final AtomicLong requested = new AtomicLong();\n    private final AtomicLong produced = new AtomicLong();\n    private final AtomicLong requestedSubscription = new AtomicLong();\n    private final AtomicLong producedSubscription = new AtomicLong();\n    private final AtomicLong requestedSubscriptionPeriod = new AtomicLong();\n    private final AtomicLong producedSubscriptionPeriod = new AtomicLong();\n    private final AtomicLong requestedPeriod = new AtomicLong();\n    private final AtomicLong producedPeriod = new AtomicLong();\n"}, {"ID": 54, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } } \n */\npublic class SpscLinkedArrayQueue<T> extends SpscLinkedArrayQueue<T> {\n    public SpscLinkedArrayQueue(int bufferSize) {\n        super(bufferSize);\n    }\n}\n"}, {"ID": 55, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; } \nResponse:", "ground_truth": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "predict": " public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; } \n\n//end::include[]\n"}, {"ID": 56, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Disposable get() { Disposable d = resource.get(); if (d == DisposableHelper.DISPOSED) { return Disposables.disposed(); } return d; } \nResponse:", "ground_truth": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "predict": " @Nullable public Disposable get() { return resource.get(); } \n */\npublic class DisposableHelper {\n    public static final Disposable DISPOSED = new Disposable() {\n        @Override\n        public void dispose() {\n        }\n    };\n    \n    public static Disposable getDisposable(Disposable resource) {\n        if (resource == null) {\n            return DISPOSED;\n        }\n        return resource;\n    }\n}\n"}, {"ID": 57, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } } \nResponse:", "ground_truth": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "predict": "\n\npublic final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } } \n\n*/\n\npublic final class BlockingObservable<T> extends AbstractBlockingObservable<T> {\n\n    private final BlockingQueue<T> queue;\n\n    public BlockingObservable(BlockingQueue<T> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super"}, {"ID": 58, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); } \nResponse:", "ground_truth": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "predict": " public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); } \n\n*/\n\npublic final class OnErrorFuseable<T> extends AbstractOnErrorFuseable<T> {\n    final ConditionalSubscriber<? super T> actual;\n\n    public OnErrorFuseable(ConditionalSubscriber<? super T> actual) {\n        this.actual = actual;\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        if (e != null) {\n            actual.onError(e);\n        } else {\n            actual.onError(new NullPointerException(\"onError(null)\"));\n        }\n    }\n\n"}, {"ID": 59, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResponse:", "ground_truth": "Complete the target without any value.", "predict": " public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | F"}, {"ID": 60, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) { return concatMapDelayError(mapper, 2, true); } \nResponse:", "ground_truth": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that may throw an {@code IllegalStateException} when that\n{@code Publisher} completes.\nScheduler:\n{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "predict": " @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { return concatMapDelayError(mapper, prefetch, true); } \nResp @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean delayError) { return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, delayError)); } \nResp @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport"}, {"ID": 61, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) { return concatMapIterable(mapper, 2); } \nResponse:", "ground_truth": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.\nScheduler:\n{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see ReactiveX operators documentation: FlatMap", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.internal.functions.ObjectHelper;\nimport io.reactivex.internal.subscriptions.SubscriptionHelper;\nimport io.reactivex.internal.util.BackpressureHelper;\nimport io.reactivex.plugins.RxJavaPlugins;\n\npublic final class FlowableConcatMapIterable<T, U> extends Flowable<U> {\n    final Flow"}, {"ID": 62, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction\"); return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nBackpressure:\nThe operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "predict": " @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse() { return toList().toSingle().map(Functions.response(response -> response.getBody())); } \nResp @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse(ResponseTransformer<R> transformer) { return toList().toSingle().map(Functions.response(transformer)); } \nResp @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse(ResponseTransformer<R> transformer, ResponseConverter<R> converter) { return toList().toSingle()."}, {"ID": 63, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PerfAsyncConsumer await(int count) { if (count <= 1000) { while (getCount() != 0) { } } else { try { await(); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } return this; } \nResponse:", "ground_truth": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class PerfAsyncConsumer {\n    private static final int COUNT = 1000000;\n    private static final int THREAD_COUNT = 4;\n    private static final int THREAD_COUNT_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n\n    private static final AtomicInteger count = new AtomicInteger(0);\n    "}, {"ID": 64, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void request(long n) { Subscription s = this.upstream; if (s != null) { s.request(n); } } \nResponse:", "ground_truth": "Requests from the upstream Subscription.\n@param n the request amount, positive", "predict": " Resp public final void cancel() { Subscription s = this.upstream; if (s != null) { s.cancel(); } } \n\n*/\n\npublic class Subscription {\n\tprivate final Subscriber<? super T> subscriber;\n\tprivate final Subscription upstream;\n\t\n\tpublic Subscription(Subscriber<? super T> subscriber, Subscription upstream) {\n\t\tthis.subscriber = subscriber;\n\t\tthis.upstream = upstream;\n\t}\n\t\n\tpublic void request(long n) {\n\t\tupstream.request(n);\n\t}\n\t\n\tpublic void cancel() {\n\t\tupstream.cancel();\n\t}\n}\n"}, {"ID": 65, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: boolean add(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n + 1]; System.arraycopy(a, 0, b, 0, n); b[n] = ps; if (subscribers.compareAndSet(a, b)) { return true; } } } \nResponse:", "ground_truth": "Tries to add the given subscriber to the subscribers array atomically\nor returns false if the subject has terminated.\n@param ps the subscriber to add\n@return true if successful, false if the subject has terminated", "predict": " void onSuccess(T t) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n - 1]; System.arraycopy(a, 1, b, 0, n - 1); if (subscribers.compareAndSet(a, b)) { return; } } } \nResp void onError(Throwable t) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n - 1]; System.arraycopy(a, 1, b, 0, n - 1); if (subscribers.compareAndSet(a, b)) { return; } } } "}, {"ID": 66, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") void remove(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED || a == EMPTY) { return; } int n = a.length; int j = -1; for (int i = 0; i < n; i++) { if (a[i] == ps) { j = i; break; } } if (j < 0) { return; } PublishDisposable<T>[] b; if (n == 1) { b = EMPTY; } else { b = new PublishDisposable[n - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, n - j - 1); } if (subscribers.compareAndSet(a, b)) { return; } } } \nResponse:", "ground_truth": "Atomically removes the given subscriber if it is subscribed to the subject.\n@param ps the subject to remove", "predict": "\n\npublic class PublishSubscriber<T> extends Subscriber<T> {\n    final Subscriber<? super T> actual;\n    final AtomicLong requested = new AtomicLong();\n    final AtomicReference<Subscriber<? super T>> terminal;\n    final AtomicReference<PublishSubscriber<T>> parent;\n    final int bufferSize;\n    final int prefetch;\n    final int limit;\n    final int index;\n    final int offset;\n    final int mask;\n    final int capacity;\n    final int mask;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    "}, {"ID": 67, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); } \nResponse:", "ground_truth": "Child Subscribers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param cf the ConnectableFlowable to wrap\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "\n\npublic static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\nimport rx.Observable;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\nimport rx.functions.Func2;\nimport rx.functions.Func3;\nimport rx.functions.Func4;\nimport rx.functions.Func5;\nimport rx.functions.Func6;\nimport rx.functions.Func7;\nimport rx.functions.Func8;\nimport rx"}, {"ID": 68, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \"'\" + getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } if (responseType == Response.class) { throw methodError(method, \"Response must include generic type (e.g., Response<String>)\"); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\"HEAD\") && !Void.class.equals(responseType)) { throw methodError(method, \"HEAD method must use Void as response type.\"); } Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable); } } \nResponse:", "ground_truth": "Inspects the annotations on an interface method to construct a reusable service method that\nspeaks HTTP. This requires potentially-expensive reflection so it is best to build each service\nmethod only once and reuse it.", "predict": " Generate the method-level comment for the following java Code. Code: static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType"}, {"ID": 69, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDelay(long amount, TimeUnit unit) { if (amount < 0) { throw new IllegalArgumentException(\"Amount must be positive value.\"); } this.delayMs = unit.toMillis(amount); } \nResponse:", "ground_truth": "Set the network round trip delay.", "predict": "\n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Delay {\n    private long delayMs;\n\n    public Delay(long delayMs) {\n        this.delayMs = delayMs;\n    }\n\n    public void setDelay(long amount, TimeUnit unit) {\n        if (amount < 0) {\n            throw new IllegalArgumentException(\"Amount must be positive value.\");\n        }\n        this.delayMs = unit.toMillis(amount);\n    }\n\n    public long getDelayMs() {\n        return delayMs;\n    }\n}\n"}, {"ID": 70, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response<?> createErrorResponse() { Response<?> call; try { call = errorFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; } \nResponse:", "ground_truth": "The HTTP error to be used when an error is triggered.", "predict": " public Response<?> createResponse() { Response<?> call; try { call = responseFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; } \n\n}\n"}, {"ID": 71, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long calculateDelay(TimeUnit unit) { float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta; // 0.2f --> 0.8f float upperBound = 1f + delta; // 0.2f --> 1.2f float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4) long callDelayMs = (long) (delayMs * delayPercent); return MILLISECONDS.convert(callDelayMs, unit); } \nResponse:", "ground_truth": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "predict": "\n\n*/\n\nimport java.util.Random;\n\npublic class DelayCalculator {\n    private static final float variancePercent = 20f;\n    private static final float lowerBound = 1f - variancePercent / 100f;\n    private static final float upperBound = 1f + variancePercent / 100f;\n    private static final float bound = upperBound - lowerBound;\n    private static final float delayPercent = lowerBound + (new Random().nextFloat() * bound);\n\n    public static long calculateDelay(TimeUnit unit) {\n        return MILLISECONDS.convert(delayMs, unit);\n    }\n}\n"}, {"ID": 72, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createSampleData(String username, String password) { Assert.notNull(documentDao, \"DocumentDao required\"); Assert.hasText(username, \"Username required\"); Authentication auth = new UsernamePasswordAuthenticationToken(username, password); try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder.getContext().setAuthentication(auth); // Create the home directory first Directory home = new Directory(username, Directory.ROOT_DIRECTORY); documentDao.create(home); addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN); addPermission(documentDao, home, \"ROLE_USER\", LEVEL_GRANT_READ); createFiles(documentDao, home); // Now create the confidential directory Directory confid = new Directory(\"confidential\", home); documentDao.create(confid); addPermission(documentDao, confid, \"ROLE_USER\", LEVEL_NEGATE_READ); createFiles(documentDao, confid); // Now create the shared directory Directory shared = new Directory(\"shared\", home); documentDao.create(shared); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_READ); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_WRITE); createFiles(documentDao, shared); } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder.clearContext(); } } \nResponse:", "ground_truth": "Creates a directory for the user, and a series of sub-directories. The root\ndirectory is the parent for the user directory. The sub-directories are\n\"confidential\" and \"shared\". The ROLE_USER will be given read and write access to\n\"shared\".", "predict": "\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doublevalue;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\nimport com.github.dkellenb.formulaevaluator.term.operator.OperatorTerm;\n\n/**\n * Double value greater than operator.\n */\npublic class DoubleValueGreaterThanOperatorTerm\n    extends GenericStackableOperatorTerm<Double, Double>\n    implements DoubleValueOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleValueGreater"}, {"ID": 73, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \nResponse:", "ground_truth": "Provides a save way of obtaining the HttpMethod from a String. If the method is\ninvalid, returns null.\n\n@param method the HTTP method to use.\n\n@return the HttpMethod or null if method is invalid.", "predict": " Response to the following java Code. Code: public static Response valueOf(String response) { try { return Response.valueOf(response); } catch (IllegalArgumentException e) { } return null; } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \n\t\t\n\t\tString method = \"GET\";\n\t\t\n\t\tSystem.out.println(\"Generating the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \");\n\t\t\n\t\tSystem."}, {"ID": 74, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public DirContextOperations searchForUser(String username) { if (logger.isDebugEnabled()) { logger.debug(\"Searching for user '\" + username + \"', with user search \" + this); } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate( contextSource); template.setSearchControls(searchControls); try { return template.searchForSingleEntry(searchBase, searchFilter, new String[] { username }); } catch (IncorrectResultSizeDataAccessException notFound) { if (notFound.getActualSize() == 0) { throw new UsernameNotFoundException(\"User \" + username + \" not found in directory.\"); } // Search should never return multiple results if properly configured, so just // rethrow throw notFound; } } \nResponse:", "ground_truth": "Return the LdapUserDetails containing the user's information\n\n@param username the username to search for.\n\n@return An LdapUserDetails object containing the details of the located user's\ndirectory entry\n\n@throws UsernameNotFoundException if no matching entry is found.", "predict": "\n\n@Override\npublic DirContextOperations searchForUser(String username) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Searching for user '\" + username + \"', with user search \" + this);\n\t}\n\tSpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate(contextSource);\n\ttemplate.setSearchControls(searchControls);\n\ttry {\n\t\treturn template.searchForSingleEntry(searchBase, searchFilter, new String[] { username });\n\t}\n\tcatch (IncorrectResultSizeDataAccessException notFound) {\n\t\tif (notFound.getActualSize() == 0) {\n\t\t\tthrow new UsernameNotFoundException(\"User \" + username + \" not found in directory.\");\n\t\t}\n\t\t// Search should never return multiple results if properly configured, so just\n\t\t// rethrow\n\t\tthrow notFound;\n\t}\n}\n\n@Override\npublic DirContextOper"}, {"ID": 75, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(CharSequence rawPassword) { String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX; return digest(salt, rawPassword); } \nResponse:", "ground_truth": "Encodes the rawPass using a MessageDigest. If a salt is specified it will be merged\nwith the password before encoding.\n\n@param rawPassword The plain text password\n@return Hex string of password digest (or base64 encoded string if\nencodeHashAsBase64 is enabled.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 76, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matches(CharSequence rawPassword, String encodedPassword) { String salt = extractSalt(encodedPassword); String rawPasswordEncoded = digest(salt, rawPassword); return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded); } \nResponse:", "ground_truth": "Takes a previously encoded password and compares it with a rawpassword after mixing\nin the salt and encoding that value\n\n@param rawPassword plain text password\n@param encodedPassword previously encoded password\n@return true or false", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\npublic class PasswordEncoderUtils {\n\n\tprivate static final Pattern ENCODED_PASSWORD_PATTERN = Pattern.compile(\"^(\\\\w{32})(\\\\w{2})(\\\\w{2})(\\\\w{2})(\\\\w{2})("}, {"ID": 77, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void performVersionChecks(String minSpringVersion) { if (minSpringVersion == null) { return; } // Check Spring Compatibility String springVersion = SpringVersion.getVersion(); String version = getVersion(); if (disableChecks(springVersion, version)) { return; } logger.info(\"You are running with Spring Security Core \" + version); if (new ComparableVersion(springVersion) .compareTo(new ComparableVersion(minSpringVersion)) < 0) { logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion); } } \nResponse:", "ground_truth": "Perform version checks with specific min Spring Version\n\n@param minSpringVersion", "predict": "\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double less than or equal operator.\n */\npublic class DoubleLessThanOrEqualOperatorTerm\n    extends GenericStackableOperatorTerm<Double>\n    implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleLessThanOrEqualOperatorTerm(Term<Double> base, Term<Double> applicant) {\n    super(base,"}, {"ID": 78, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); } \nResponse:", "ground_truth": "Disable if springVersion and springSecurityVersion are the same to allow working\nwith Uber Jars.\n\n@param springVersion\n@param springSecurityVersion\n@return", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DisableChecks {\n\n    public static void main(String[] args) {\n        String javaCode = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\";\n        String javaCode2 = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\";\n        String javaCode3 = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion"}, {"ID": 79, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSpringVersion() { Properties properties = new Properties(); try { properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\")); } catch (IOException | NullPointerException e) { return null; } return properties.getProperty(\"org.springframework:spring-core\"); } \nResponse:", "ground_truth": "Loads the spring version or null if it cannot be found.\n@return", "predict": "\n\n<pre>\n{\n  \"status\": \"ok\",\n  \"version\": \"3.2.0.RELEASE\",\n  \"spring-version\": \"3.2.0.RELEASE\",\n  \"spring-security-version\": \"3.2.0.RELEASE\"\n}\n</pre>\n\n*/\n\npackage com.github.springtestdbunit.junit4;\n\nimport static org.springframework.util.StringUtils.hasLength;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.PropertiesLoaderUtils;\n\n/**\n * Utility class for retrieving the Spring version.\n *\n * @author Phillip Webb\n * @author Dave Syer\n * @author Andy Wilkinson\n */\npublic class SpringVersion {\n\n\tprivate static"}, {"ID": 80, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AttributeExchangeConfigurer attributeExchange(String identifierPattern) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer( identifierPattern); this.attributeExchangeConfigurers.add(attributeExchangeConfigurer); return attributeExchangeConfigurer; } \nResponse:", "ground_truth": "", "predict": " Response(String identifierPattern) { this.identifierPattern = identifierPattern; } \n\n*/\n\npublic class AttributeExchangeConfigurer {\n\tprivate String identifierPattern;\n\tprivate List<AttributeExchangeConfigurer> attributeExchangeConfigurers;\n\t\n\tpublic AttributeExchangeConfigurer(String identifierPattern) {\n\t\tthis.identifierPattern = identifierPattern;\n\t\tthis.attributeExchangeConfigurers = new ArrayList<AttributeExchangeConfigurer>();\n\t}\n\t\n\tpublic void addAttributeExchangeConfigurer(AttributeExchangeConfigurer attributeExchangeConfigurer) {\n\t\tthis.attributeExchangeConfigurers.add(attributeExchangeConfigurer);\n\t}\n\t\n\tpublic String getIdentifierPattern() {\n\t\treturn identifierPattern;\n\t}\n\t\n\tpublic List<AttributeExchangeConfigurer> getAttributeExchangeConfigurers() {\n\t\treturn attributeExchangeConfigurers;\n\t}\n}\n"}, {"ID": 81, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception { OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>()); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Client support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ClientConfigurer} for further customizations\n@throws Exception", "predict": " ResponseEntity<OAuth2ClientConfigurer<HttpSecurity>> oauth2Client() throws Exception { return getOrApply(new OAuth2ClientConfigurer<>()); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientProperties;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientPropertiesRegistrationAdapter;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientPropertiesRegistrationAutoConfiguration;\nimport org"}, {"ID": 82, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception { OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Resource Server support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ResourceServerConfigurer} for further customizations\n@throws Exception", "predict": " ResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> oauth2ResourceServer() throws Exception { return getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer) throws Exception { return getOrApply(configurer, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer, String method) throws Exception { return getOrApply(configurer, method, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer, String method, String path) throws Exception { return getOrApply(configurer, method, path, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<Http"}, {"ID": 83, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); } \nResponse:", "ground_truth": "Configures channel security. In order for this configuration to be useful at least\none mapping to a required channel must be provided.\n\nExample Configuration\n\nThe example below demonstrates how to require HTTPs for every request. Only\nrequiring HTTPS for some requests is supported, but not recommended since an\napplication that allows for HTTP introduces many security vulnerabilities. For one\nsuch example, read about Firesheep.\n\n\n\n\n@return the {@link ChannelSecurityConfigurer} for further customizations\n@throws Exception", "predict": " public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); } \n */\n\npublic class ChannelSecurityConfigurer<H extends HttpSecurity> {\n\n    private final ApplicationContext context;\n\n    public ChannelSecurityConfigurer(ApplicationContext context) {\n        this.context = context;\n    }\n\n    public ChannelSecurityConfigurer<H> getOrApply(ChannelSecurityConfigurer<H> configurer) {\n        return configurer;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel() throws Exception {\n        return this;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel(String channel) throws Exception {\n        return this;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel(Channel channel) throws Exception {\n        return this;\n    }\n\n    public ChannelSecurity"}, {"ID": 84, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean compare(final String dn, final String attributeName, final Object value) { final String comparisonFilter = \"(\" + attributeName + \"={0})\"; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext(DirContext ctx) throws NamingException { SearchControls ctls = new SearchControls(); ctls.setReturningAttributes(NO_ATTRS); ctls.setSearchScope(SearchControls.OBJECT_SCOPE); NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls); Boolean match = Boolean.valueOf(results.hasMore()); LdapUtils.closeEnumeration(results); return match; } } Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback()); return matches.booleanValue(); } \nResponse:", "ground_truth": "Performs an LDAP compare operation of the value of an attribute for a particular\ndirectory entry.\n\n@param dn the entry who's attribute is to be used\n@param attributeName the attribute who's value we want to compare\n@param value the value to be checked against the directory value\n\n@return true if the supplied value matches that in the directory", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons.lang"}, {"ID": 85, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) { return (DirContextOperations) executeReadOnly(new ContextExecutor() { public Object executeWithContext(DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve); // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace())); } }); } \nResponse:", "ground_truth": "Composes an object from the attributes of the given DN.\n\n@param dn the directory entry which will be read\n@param attributesToRetrieve the named attributes which will be retrieved from the\ndirectory entry.\n\n@return the object created by the mapper", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.ModificationItem;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;"}, {"ID": 86, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) { String[] attributeNames = new String[] { attributeName }; Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues( base, filter, params, attributeNames); Set<String> result = new HashSet<>(); for (Map<String, List<String>> map : multipleAttributeValues) { List<String> values = map.get(attributeName); if (values != null) { result.addAll(values); } } return result; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the union of the values of\nthe named attribute found in all entries matched by the search. Note that one\ndirectory entry may have several values for the attribute. Intended for role\nsearches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute who's values are to be retrieved.\n\n@return the set of String values for the attribute as a union of the values found\nin all the matching entries.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\n\npublic class SearchForSingleAttributeValues {\n\n\tprivate static final Logger logger = Logger.getLogger(SearchForSingleAttributeValues.class);\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString base = \"http://localhost:8080/openemap-backend/rest/v1/\";\n\t\t\tString"}, {"ID": 87, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i = 0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, List<String>> record = new HashMap<String, List<String>>(); if (attributeNames == null || attributeNames.length == 0) { try { for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae .hasMore();) { Attribute attr = (Attribute) ae.next(); extractStringAttributeValues(adapter, record, attr.getID()); } } catch (NamingException x) { org.springframework.ldap.support.LdapUtils .convertLdapException(x); } } else { for (String attributeName : attributeNames) { extractStringAttributeValues(adapter, record, attributeName); } } record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter))); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null); search(base, formattedFilter, ctls, roleMapper); return set; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the values of each named\nattribute found in all entries matched by the search. Note that one directory entry\nmay have several values for the attribute. Intended for role searches and similar\nscenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching\nentries. The attribute name is the key for each set of values. In addition each map\ncontains the DN as a String with the key predefined key {@link #DN_KEY}.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.ldap.core.DirContextOperations;\nimport org.springframework.ldap.core.DistinguishedName;\nimport org.springframework.ldap.core.LdapTemplate;\nimport org.springframework.ldap.core.support.AbstractContextMapper;\nimport org.springframework.ldap.filter.Filter;\nimport org.springframework.ldap.filter.FilterParser;\nimport org.springframework.ldap.support.LdapUtils;\nimport org.springframework.util.Assert;\n\npublic class LdapTemplateTest {\n\n\tpublic static void main(String[] args) {\n\t\tLdapTemplate template = new Ldap"}, {"ID": 88, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (DirContextAdapter) searchResult.getObject(); Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\"); if (logger.isDebugEnabled()) { logger.debug(\"Found DN: \" + dca.getDn()); } results.add(dca); } } catch (PartialResultException e) { LdapUtils.closeEnumeration(resultsEnum); logger.info(\"Ignoring PartialResultException\"); } if (results.size() == 0) { throw new IncorrectResultSizeDataAccessException(1, 0); } if (results.size() > 1) { throw new IncorrectResultSizeDataAccessException(1, results.size()); } return results.iterator().next(); } \nResponse:", "ground_truth": "Internal method extracted to avoid code duplication in AD search.", "predict": " public static DirContextOperations searchForSingleEntryInternal(DirContextOperations ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (Dir"}, {"ID": 89, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static SearchControls buildControls(SearchControls originalControls) { return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag()); } \nResponse:", "ground_truth": "We need to make sure the search controls has the return object flag set to true, in\norder for the search to return DirContextAdapter instances.\n@param originalControls\n@return", "predict": " Response = new SearchControls(SearchControls.SUBTREE_SCOPE, 1000, 0, new String[] { \"uid\" }, ReturnObject.AS_OBJECT, DerefLink.NEVER); \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@XmlRootElement(name = \"searchControls\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class SearchControls {\n\t@XmlElement(name = \"searchScope\")\n\tprivate SearchScope searchScope;\n\t@XmlElement(name = \"countLimit\")\n\tprivate"}, {"ID": 90, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) { Assert.notNull(acls, \"ACLs are required\"); Assert.notEmpty(findNow, \"Items to find now required\"); String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size()); Set<Long> parentsToLookup = jdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { int i = 0; for (Long toFind : findNow) { i++; ps.setLong(i, toFind); } } }, new ProcessResultSet(acls, sids)); // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if (parentsToLookup.size() > 0) { lookupPrimaryKeys(acls, parentsToLookup, sids); } } \nResponse:", "ground_truth": "Locates the primary key IDs specified in \"findNow\", adding AclImpl instances with\nStubAclParents to the \"acls\" Map.\n\n@param acls the AclImpls (with StubAclParents)\n@param findNow Long-based primary keys to retrieve\n@param sids", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.security.acls.domain.BasePermission;\nimport org.springframework.security.acls.domain.ObjectIdentityImpl;\nimport org.springframework.security.acls.domain.PrincipalSid;\nimport org.springframework.security.acls.model.Acl;\nimport org.springframework.security.acls.model.NotFoundException;\nimport org.springframework.security.acls.model.ObjectIdentity;\nimport org.springframework.security.acls.model.Sid;\nimport org.springframework.security.acls.model.SidRetrievalStrategy;\nimport org.springframework.security.acls.model.UnloadedSidException;\nimport org.springframework.security.acls.model.UnsupportedSidException;\nimport org.springframework"}, {"ID": 91, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails( HttpServletRequest context) { Collection<String> j2eeUserRoles = getUserRoles(context); Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper .getGrantedAuthorities(j2eeUserRoles); if (logger.isDebugEnabled()) { logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\"); } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails( context, userGas); return result; } \nResponse:", "ground_truth": "Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)", "predict": " public Response buildResponse( HttpServletRequest context) { return new Response(); } \n\n}\n"}, {"ID": 92, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); String suffix = element.getAttribute(ATT_ROOT_SUFFIX); if (!StringUtils.hasText(suffix)) { suffix = OPT_DEFAULT_ROOT_SUFFIX; } String port = element.getAttribute(ATT_PORT); if (!StringUtils.hasText(port)) { port = getDefaultPort(); if (logger.isDebugEnabled()) { logger.debug(\"Using default port of \" + port); } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder .rootBeanDefinition(CONTEXT_SOURCE_CLASS); contextSource.addConstructorArgValue(url); contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\"); contextSource.addPropertyValue(\"password\", \"secret\"); RootBeanDefinition apacheContainer = new RootBeanDefinition( \"org.springframework.security.ldap.server.ApacheDSContainer\", null, null); apacheContainer.setSource(source); apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix); String ldifs = element.getAttribute(ATT_LDIF_FILE); if (!StringUtils.hasText(ldifs)) { ldifs = OPT_DEFAULT_LDIF_FILE; } apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs); apacheContainer.getPropertyValues().addPropertyValue(\"port\", port); logger.info(\"Embedded LDAP server bean definition created for URL: \" + url); if (parserContext.getRegistry() .containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) { parserContext.getReaderContext().error( \"Only one embedded server bean is allowed per application context\", element); } parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer); return (RootBeanDefinition) contextSource.getBeanDefinition(); } \nResponse:", "ground_truth": "Will be called if no url attribute is supplied.\n\nRegisters beans to create an embedded apache directory server.\n\n@return the BeanDefinition for the ContextSource for the embedded server.\n\n@see ApacheDSContainer", "predict": "\n\n@RequestMapping(value = \"/ldap/{suffix}\", method = RequestMethod.GET)\npublic class LdapController {\n\t@Autowired\n\tprivate LdapContextSource contextSource;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate;\n\t@Autowired\n\tprivate LdapContextSource contextSource2;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate2;\n\t@Autowired\n\tprivate LdapContextSource contextSource3;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate3;\n\t@Autowired\n\tprivate LdapContextSource contextSource4;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate4;\n\t@Autowired\n\tprivate LdapContextSource contextSource5;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate5;"}, {"ID": 93, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createServletApiFilter(BeanReference authenticationManager) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\"; final String DEF_SERVLET_API_PROVISION = \"true\"; String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION); if (!StringUtils.hasText(provideServletApi)) { provideServletApi = DEF_SERVLET_API_PROVISION; } if (\"true\".equals(provideServletApi)) { servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class); servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager); } } \nResponse:", "ground_truth": "Adds the servlet-api integration filter if required", "predict": "\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <meta name=\"description\" content=\"\">\n  <meta name=\"author\" content=\"\">\n  <title>Welcome to Spring Boot</title>\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3"}, {"ID": 94, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createJaasApiFilter() { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\"; final String DEF_JAAS_API_PROVISION = \"false\"; String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION); if (!StringUtils.hasText(provideJaasApi)) { provideJaasApi = DEF_JAAS_API_PROVISION; } if (\"true\".equals(provideJaasApi)) { jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class); } } \nResponse:", "ground_truth": "Adds the jaas-api integration filter if required", "predict": "\n\n<pre>\n{\n    \"status\": \"OK\",\n    \"message\": \"\",\n    \"jaas-api-provision\": \"true\",\n    \"jaas-api-provision-status\": \"true\",\n    \"jaas-api-provision-message\": \"\",\n    \"jaas-api-provision-status-message\": \"\",\n    \"jaas-api-provision-status-message-code\": \"\",\n    \"jaas-api-provision-status-message-description\": \"\",\n    \"jaas-api-provision-status-message-severity\": \"\",\n    \"jaas-api-provision-status-message-summary\": \"\",\n    \"jaas-api-provision-status-message-type\": \"\",\n    \"jaas-api-provision-status-message-instance\": \"\",\n    \"jaas-api-provision-status-message-component\":"}, {"ID": 95, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() { TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); result = result.init(JsonTypeInfo.Id.CLASS, null); result = result.inclusion(JsonTypeInfo.As.PROPERTY); return result; } \nResponse:", "ground_truth": "Creates a TypeResolverBuilder that performs whitelisting.\n@return a TypeResolverBuilder that performs whitelisting.", "predict": " Response.ok().build();\n\n*/\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.datatype.joda.JodaModule;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeZoneSerializer;\nimport com.fasterxml.jackson.datatype.joda.ser.JacksonJodaFormat;\nimport com.fasterxml.jackson.datatype.joda.ser.JodaSerializer;\nimport com.f"}, {"ID": 96, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = DEFAULT_FILTER_NAME; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy( filterName); String contextAttribute = getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } registerFilter(servletContext, true, filterName, springSecurityFilterChain); } \nResponse:", "ground_truth": "Registers the springSecurityFilterChain\n@param servletContext the {@link ServletContext}", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterRegistration;\nimport javax.servlet.FilterRegistration.Dynamic;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\npublic class FilterRegistrationBean implements FilterRegistration.Dynamic {\n\n\tprivate String name;\n\tprivate Class<? extends Filter> filterClass;\n\tprivate boolean asyncSupported = true;\n\tprivate boolean enabled = true;\n\tprivate String servletName;\n\tprivate String dispatcherTypes;\n\tprivate String description;\n\tprivate String displayName;\n\tprivate String contextAttribute;\n\tprivate String urlPatterns;\n\tprivate String dispatcher"}, {"ID": 97, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PersistentRememberMeToken getTokenForSeries(String seriesId) { try { return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() { public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException { return new PersistentRememberMeToken(rs.getString(1), rs .getString(2), rs.getString(3), rs.getTimestamp(4)); } }, seriesId); } catch (EmptyResultDataAccessException zeroResults) { if (logger.isDebugEnabled()) { logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults); } } catch (IncorrectResultSizeDataAccessException moreThanOne) { logger.error(\"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\"); } catch (DataAccessException e) { logger.error(\"Failed to load token for series \" + seriesId, e); } return null; } \nResponse:", "ground_truth": "Loads the token data for the supplied series identifier.\n\nIf an error occurs, it will be reported and null will be returned (since the result\nshould just be a failed persistent login).\n\n@param seriesId\n@return the token matching the series, or null if no match found or an exception\noccurred.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Date;\nimport java.util.List;\n\n@Service(\"rememberMeTokenService\")\npublic class RememberMeTokenServiceImpl implements RememberMeTokenService {\n\n    @Autowired\n    @Qualifier(\"userDetailsService\")\n"}, {"ID": 98, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { List<GrantedAuthority> result = new ArrayList<>(attributes.size()); for (String attribute : attributes) { result.add(getGrantedAuthority(attribute)); } return result; } \nResponse:", "ground_truth": "Map the given list of string attributes one-to-one to Spring Security\nGrantedAuthorities.", "predict": " ResponseEntity<List<GrantedAuthority>> getGrantedAuthorities(Collection<String> attributes) { return ResponseEntity.ok(getGrantedAuthorities(attributes)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class UserDetailsImpl implements UserDetails {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate String password;\n\tprivate List<GrantedAuthority> authorities;\n\tprivate boolean enabled;\n\tprivate boolean accountNonExpired;\n\tprivate boolean credentialsNonExpired;\n\tprivate boolean accountNonLocked;\n\tprivate boolean admin;\n\tprivate boolean superAdmin;\n"}, {"ID": 99, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cipher newCipher(String algorithm) { try { return Cipher.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e); } catch (NoSuchPaddingException e) { throw new IllegalStateException(\"Should not happen\", e); } } \nResponse:", "ground_truth": "Constructs a new Cipher.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBE"}, {"ID": 100, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void afterPropertiesSet() { try { super.afterPropertiesSet(); } catch (ServletException e) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException(e); } Assert.notNull(authenticationManager, \"An AuthenticationManager must be set\"); } \nResponse:", "ground_truth": "Check whether all required properties have been set.", "predict": " ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) { return authenticationManager.authenticate(loginRequest); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\n@RestController\n@RequestMapping(\"/api/login\")\npublic class LoginController {\n\n\t@Autowired\n\tprivate AuthenticationManager authenticationManager;\n\n\t@RequestMapping(method = RequestMethod.POST)\n\t@JsonView(View.Login"}, {"ID": 101, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); } \nResponse:", "ground_truth": "Try to authenticate a pre-authenticated user with Spring Security if the user has\nnot yet been authenticated.", "predict": " Generate the method-level comment for the following java Code. Code: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;"}, {"ID": 102, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) { Object principal = getPreAuthenticatedPrincipal(request); if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) { return false; } if (principal != null && principal.equals(currentAuthentication.getPrincipal())) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\"); } return true; } \nResponse:", "ground_truth": "Determines if the current principal has changed. The default implementation tries\n\n\nIf the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is a String, the {@link Authentication#getName()} is compared against the pre authenticated principal\nOtherwise, the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is compared against the {@link Authentication#getPrincipal()}\n\n\nSubclasses can override this method to determine when a principal has changed.\n\n\n@param request\n@param currentAuthentication\n@return true if the principal has changed, else false", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Type;\n\npublic final class Primitives {\n    private Primitives() {\n    }\n\n    public static Type primitiveTypeToWrapperType(Type type) {\n        if (type == Boolean.TYPE) {\n            return Boolean.class;\n        }\n        if (type == Byte.TYPE) {\n            return Byte.class;\n        }\n        if (type == Character.TYPE) {\n            return Character.class;\n        }\n        if (type == Double.TYPE) {\n            return Double.class;\n        }\n        if (type == Float.TYPE) {\n            return Float.class;\n        }\n        if (type == Integer.TYPE) {\n            return Integer.class;\n        }\n        if (type == Long.TYPE) {\n            return Long.class;\n        }\n        if (type == Short.TYPE"}, {"ID": 103, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Authentication authResult; Object principal = getPreAuthenticatedPrincipal(request); Object credentials = getPreAuthenticatedCredentials(request); if (principal == null) { if (logger.isDebugEnabled()) { logger.debug(\"No pre-authenticated principal found in request\"); } return; } if (logger.isDebugEnabled()) { logger.debug(\"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\"); } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken( principal, credentials); authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); authResult = authenticationManager.authenticate(authRequest); successfulAuthentication(request, response, authResult); } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); if (!continueFilterChainOnUnsuccessfulAuthentication) { throw failed; } } } \nResponse:", "ground_truth": "Do the actual authentication for a pre-authenticated user.", "predict": "\n\n@Override\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t// TODO Auto-generated method stub\n\t\n}\n\n@Override\npublic void destroy() {\n\t// TODO Auto-generated method stub\n\t\n}\n\n@Override\npublic void init(FilterConfig arg0) throws ServletException {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n"}, {"ID": 104, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkContentLength(long contentLengthToWrite) { this.contentWritten += contentLengthToWrite; boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength; int bufferSize = getBufferSize(); boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize; if (isBodyFullyWritten || requiresFlush) { doOnResponseCommitted(); } } \nResponse:", "ground_truth": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if\nthe response should be written.\n\n@param contentLengthToWrite the size of the content that is about to be written.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://localhost:8080/\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Content-Length\", \"10\");\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setConnectTimeout(10000);\n            connection.setReadTimeout(10000);\n            connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Cache-Control\", \"no-cache\");\n            connection.setRequestProperty(\"Pragma\", \"no-cache\");\n"}, {"ID": 105, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; } \nResponse:", "ground_truth": "Creates a mapping of the supplied authorities based on the case-conversion and\nprefix settings. The mapping will be one-to-one unless duplicates are produced\nduring the conversion. If a default authority has been set, this will also be\nassigned to each mapping.\n\n@param authorities the original authorities\n\n@return the converted set of authorities", "predict": "\n\npublic Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; } \n\n*/\n\npublic class AuthorityMapper {\n\n    private static final Logger LOG = LoggerFactory.getLogger(AuthorityMapper.class);\n\n    private static final String DEFAULT_AUTHORITY = \"ROLE_USER\";\n\n    private static final String DEFAULT_AUTHORITY_PREFIX = \"ROLE_\";\n\n    private static final String DEFAULT_AUTHORITY_SUFFIX = \"\";\n\n    private static final String DEFAULT_AUTHORITY_SEPARATOR = \",\";\n\n    private static"}, {"ID": 106, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); } \nResponse:", "ground_truth": "Specifies the URL to validate the credentials.\n\n@param loginProcessingUrl the URL to validate username and password\n@return the {@link FormLoginConfigurer} for additional customization", "predict": " public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); } \n\n// Generated by IntelliJ IDEA\npublic class AuthFilterTest {\n  public static void main(String[] args) {\n    AuthFilterTest test = new AuthFilterTest();\n    test.testAuthFilter();\n  }\n\n  public void testAuthFilter() {\n    AuthFilter authFilter = new AuthFilter();\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/login\"));\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/logout\"));\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/logout\"));\n    authFilter.setRequiresAuthenticationRequest"}, {"ID": 107, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } if (failureHandler == null) { failureUrl(loginPage + \"?error\"); } final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) { logoutConfigurer.logoutSuccessUrl(loginPage + \"?logout\"); } } \nResponse:", "ground_truth": "Updates the default values for authentication.\n\n@throws Exception", "predict": "\n\n*/\n\nimport org.springframework.security.web.DefaultRedirectStrategy;\nimport org.springframework.security.web.RedirectStrategy;\nimport org.springframework.security.web.util.UrlUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author Rob Winch\n * @since 3.2\n */\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\n\tprivate final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n\tprivate final String logoutSuccessUrl;\n\n\tprivate final List<LogoutHandler> handlers;\n\n\tpublic LogoutSuccessHandlerImpl(String logoutSuccessUrl, LogoutHandler... handlers) {\n\t\tthis.logoutSuccess"}, {"ID": 108, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAccessDefaults(B http) { if (permitAll) { PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl); } } \nResponse:", "ground_truth": "Updates the default values for access.", "predict": " Response.ok().build();\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doublevalue;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double value greater than operator.\n */\npublic class DoubleValueGreaterThanOperator extends GenericStackableOperatorTerm<Double>\n    implements DoubleValueOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant value\n   */\n  public DoubleValueGreaterThanOperator(Term<Double> base, Term<Double> applicant) {\n    super(base,"}, {"ID": 109, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String mapPassword(Object passwordValue) { if (!(passwordValue instanceof String)) { // Assume it's binary passwordValue = new String((byte[]) passwordValue); } return (String) passwordValue; } \nResponse:", "ground_truth": "Extension point to allow customized creation of the user's password from the\nattribute stored in the directory.\n\n@param passwordValue the value of the password attribute\n@return a String representation of the password.", "predict": " Response is generated by the method.\n\n*/\n\npublic class PasswordEncryption {\n\tpublic static void main(String[] args) {\n\t\tString password = \"password\";\n\t\tString encryptedPassword = encrypt(password);\n\t\tSystem.out.println(encryptedPassword);\n\t\tString decryptedPassword = decrypt(encryptedPassword);\n\t\tSystem.out.println(decryptedPassword);\n\t}\n\n\tpublic static String encrypt(String password) {\n\t\treturn \"\";\n\t}\n\n\tpublic static String decrypt(String encryptedPassword) {\n\t\treturn \"\";\n\t}\n}\n"}, {"ID": 110, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String extractRememberMeCookie(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (cookieName.equals(cookie.getName())) { return cookie.getValue(); } } return null; } \nResponse:", "ground_truth": "Locates the Spring Security remember me cookie in the request and returns its\nvalue. The cookie is searched for by name and also by matching the context path to\nthe cookie path.\n\n@param request the submitted request which is to be authenticated\n@return the cookie value (if present), null otherwise.", "predict": " ResponseEntity<String> rememberMe(@RequestBody String login, HttpServletRequest request) { return rememberMeService.login(login); }\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/v1/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(method = RequestMethod.POST)\n    public ResponseEntity<String> login(@RequestBody String login) {\n        return userService.login(login);\n    }"}, {"ID": 111, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String encodeCookie(String[] cookieTokens) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cookieTokens.length; i++) { try { sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString())); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage(), e); } if (i < cookieTokens.length - 1) { sb.append(DELIMITER); } } String value = sb.toString(); sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes()))); while (sb.charAt(sb.length() - 1) == '=') { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); } \nResponse:", "ground_truth": "Inverse operation of decodeCookie.\n\n@param cookieTokens the tokens to be encoded.\n@return base64 encoding of the tokens concatenated with the \":\" delimiter.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class CookieUtils {\n\tprivate static final String DELIMITER = \";\";\n\tprivate static final String EQUAL = \"=\";\n\tprivate static final String VALUE_DELIMITER = \"\\\\s*;\\\\s*\";\n\tprivate static final String NAME_VALUE_DELIMITER = \"\\\\s*=\\\\s*\";\n\tprivate static final String NAME_DELIMITER = \"\\\\s*=\\\\s*\";\n\tprivate static final String PATH_DELIMITER = \"\\\\"}, {"ID": 112, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) { String cookieValue = encodeCookie(tokens); Cookie cookie = new Cookie(cookieName, cookieValue); cookie.setMaxAge(maxAge); cookie.setPath(getCookiePath(request)); if (cookieDomain != null) { cookie.setDomain(cookieDomain); } if (maxAge < 1) { cookie.setVersion(1); } if (useSecureCookie == null) { cookie.setSecure(request.isSecure()); } else { cookie.setSecure(useSecureCookie); } cookie.setHttpOnly(true); response.addCookie(cookie); } \nResponse:", "ground_truth": "Sets the cookie on the response.\n\nBy default a secure cookie will be used if the connection is secure. You can set\nthe {@code useSecureCookie} property to {@code false} to override this. If you set\nit to {@code true}, the cookie will always be flagged as secure. By default the cookie\nwill be marked as HttpOnly.\n\n@param tokens the tokens which will be encoded to make the cookie value.\n@param maxAge the value passed to {@link Cookie#setMaxAge(int)}\n@param request the request\n@param response the response to add the cookie to.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CookieServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String COOKIE_NAME = \"cookieName\";\n\tprivate static final String COOKIE_VALUE = \"cookieValue\";\n\tprivate static final String COOKIE_DOMAIN = \"cookieDomain\";\n\tprivate static final String COOKIE_PATH = \"cookiePath\";\n\tprivate static final String COOKIE_SECURE = \"cookieSecure\";\n\tprivate"}, {"ID": 113, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); } \nResponse:", "ground_truth": "resolve the argument to inject into the controller parameter.\n@param parameter the method parameter.\n@param bindingContext the binding context.\n@param exchange the server web exchange.\n@return the reactive mono object result.", "predict": " @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); } \n\n@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { return Mono.justOrEmpty(resolveSecurityContext(parameter, bindingContext, exchange)); } \n\n@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange"}, {"ID": 114, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) { final String query = request.getQueryString(); if (query == null) { return null; } final String result = artifactPattern.matcher(query).replaceFirst(\"\"); if (result.length() == 0) { return null; } // strip off the trailing & only if the artifact was the first query param return result.startsWith(\"&\") ? result.substring(1) : result; } \nResponse:", "ground_truth": "If present, removes the artifactParameterName and the corresponding value from the\nquery String.\n@param request\n@return the query String minus the artifactParameterName and the corresponding\nvalue.", "predict": "\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class QueryString {\n    public static void main(String[] args) {\n        String query = \"http://www.example.com/search?q=java&a=1&b=2&c=3\";\n        Pattern pattern = Pattern.compile(\"(?<=\\\\?)(.*)(?=&|$)\");\n        Matcher matcher = pattern.matcher(query);\n        if (matcher.find()) {\n            System.out.println(matcher.group());\n        }\n    }\n}\n"}, {"ID": 115, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getServicePort(URL casServiceUrl) { int port = casServiceUrl.getPort(); if (port == -1) { port = casServiceUrl.getDefaultPort(); } return port; } \nResponse:", "ground_truth": "", "predict": " Response.ok().build();\n\n*/\n\npackage com.github.scribejava.core.model;\n\nimport com.github.scribejava.core.exceptions.OAuthException;\nimport com.github.scribejava.core.utils.Preconditions;\nimport java.util.Objects;\n\n/**\n * Represents an HTTP response.\n */\npublic class Response {\n\n    private final int code;\n    private final String body;\n    private final String contentType;\n    private final String charset;\n\n    /**\n     * Creates a new response.\n     *\n     * @param code The HTTP status code.\n     * @param body The HTTP response body.\n     * @param contentType The HTTP content type.\n     * @param charset The HTTP charset.\n     */\n    public Response(int code, String body, String contentType, String charset) {\n        this.code = code;\n        this.body = body;"}, {"ID": 116, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPrincipal() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); if (authentication == null) { log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\"); return \"\"; } Object principal = authentication.getPrincipal(); if (principal instanceof LdapUserDetails) { LdapUserDetails details = (LdapUserDetails) principal; return details.getDn(); } else if (authentication instanceof AnonymousAuthenticationToken) { if (log.isDebugEnabled()) { log.debug(\"Anonymous Authentication, returning empty String as Principal\"); } return \"\"; } else { throw new IllegalArgumentException( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\"); } } \nResponse:", "ground_truth": "Get the principals of the logged in user, in this case the distinguished name.\n\n@return the distinguished name of the logged in user.", "predict": "\n\n*/\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.ldap.userdetails.LdapUserDetails;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LdapUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth == null) {\n            throw new UsernameNotFoundException(\"No user is logged in\");\n        }\n        Object principal = auth.getPrincipal();\n        if (principal instanceof LdapUserDetails) {\n            LdapUserDetails details = (LdapUserDetails) principal;\n            return details;\n        } else {\n            "}, {"ID": 117, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, \"HttpServletRequest required\"); if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(\"Invalidating session: \" + session.getId()); session.invalidate(); } } if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } SecurityContextHolder.clearContext(); } \nResponse:", "ground_truth": "Requires the request to be passed in.\n\n@param request from which to obtain a HTTP session (cannot be null)\n@param response not used (can be null)\n@param authentication not used (can be null)", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Controller\npublic class LogoutController {\n\n    @Autowired\n    private SecurityContextLogout"}, {"ID": 118, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Authentication authenticate(Authentication auth) throws AuthenticationException { if (!(auth instanceof UsernamePasswordAuthenticationToken)) { return null; } UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth; Set<GrantedAuthority> authorities; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext( new InternalCallbackHandler(auth)); // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext.login(); // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet<>(); // Get the subject principals and pass them to each of the AuthorityGranters Set<Principal> principals = loginContext.getSubject().getPrincipals(); for (Principal principal : principals) { for (AuthorityGranter granter : this.authorityGranters) { Set<String> roles = granter.grant(principal); // If the granter doesn't wish to grant any authorities, it should // return null. if ((roles != null) && !roles.isEmpty()) { for (String role : roles) { authorities.add(new JaasGrantedAuthority(role, principal)); } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken( request.getPrincipal(), request.getCredentials(), new ArrayList<>(authorities), loginContext); // Publish the success event publishSuccessEvent(result); // we're done, return the token. return result; } catch (LoginException loginException) { AuthenticationException ase = this.loginExceptionResolver .resolveException(loginException); publishFailureEvent(request, ase); throw ase; } } \nResponse:", "ground_truth": "Attempts to login the user given the Authentication objects principal and\ncredential\n\n@param auth The Authentication object to be authenticated.\n\n@return The authenticated Authentication object, with it's grantedAuthorities set.\n\n@throws AuthenticationException This implementation does not handle 'locked' or\n'disabled' accounts. This method only throws a AuthenticationServiceException, with\nthe message of the LoginException that will be thrown, should the\nloginContext.login() method fail.", "predict": "\n\n*/\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.token.DefaultTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Collection;\nimport java.util.Collections"}, {"ID": 119, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildProviderUrl(List<String> urls, String baseDn) { Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\"); Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\"); String trimmedBaseDn = baseDn.trim(); StringBuilder providerUrl = new StringBuilder(); for (String serverUrl : urls) { String trimmedUrl = serverUrl.trim(); if (\"\".equals(trimmedUrl)) { continue; } providerUrl.append(trimmedUrl); if (!trimmedUrl.endsWith(\"/\")) { providerUrl.append(\"/\"); } providerUrl.append(trimmedBaseDn); providerUrl.append(\" \"); } return providerUrl.toString(); } \nResponse:", "ground_truth": "Builds a Spring LDAP-compliant Provider URL string, i.e. a space-separated list of\nLDAP servers with their base DNs. As the base DN must be identical for all servers,\nit needs to be supplied only once.\n\n@param urls A list of string values which are LDAP server URLs. An example would be\n\n\nldap://ldap.company.com:389\n\n\n. LDAPS URLs may be used as well, given that Spring Security is able to connect to\nthe server.\n@param baseDn The common Base DN for all provided servers, e.g.\n\n\ndc=company,dc=com\n\n\n.\n@return A Spring Security/Spring LDAP-compliant Provider URL string.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.ldap.core.DirContextOperations;\nimport org.springframework.ldap.core.support.LdapContextSource;\nimport org.springframework.ldap.filter.AndFilter;\nimport org.springframework.ldap.filter.EqualsFilter;\nimport org.springframework.ldap.filter.Filter;\nimport org.springframework.ldap.filter.OrFilter;\nimport org.springframework.ldap.filter.WhitespaceWildcardsFilter;\nimport org.springframework.ldap.support.LdapUtils;\nimport org.springframework.util.Assert;\n\npublic class LdapUtilsTest {\n\n\tpublic static void main(String[] args) {\n\t\tLdapContextSource contextSource = new LdapContextSource();\n\t\tcontextSource.setUrl(\""}, {"ID": 120, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setContextEnvironmentProperties(Map<String, Object> environment) { Assert.notEmpty(environment, \"environment must not be empty\"); this.contextEnvironmentProperties = new Hashtable<>(environment); } \nResponse:", "ground_truth": "Allows a custom environment properties to be used to create initial LDAP context.\n\n@param environment the additional environment parameters to use when creating the LDAP Context", "predict": " void\n*/\n\npublic class ContextEnvironmentProperties {\n\tprivate Map<String, Object> contextEnvironmentProperties;\n\n\tpublic ContextEnvironmentProperties(Map<String, Object> contextEnvironmentProperties) {\n\t\tthis.contextEnvironmentProperties = contextEnvironmentProperties;\n\t}\n\n\tpublic Map<String, Object> getContextEnvironmentProperties() {\n\t\treturn contextEnvironmentProperties;\n\t}\n\n\tpublic void setContextEnvironmentProperties(Map<String, Object> contextEnvironmentProperties) {\n\t\tthis.contextEnvironmentProperties = contextEnvironmentProperties;\n\t}\n}\n"}, {"ID": 121, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String getRedirectUrl() { return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString); } \nResponse:", "ground_truth": "Indicates the URL that the user agent used for this request.\n\n@return the full URL of this request", "predict": " @Override public ResponseEntity<String> getResponse(String redirectUrl) { return new ResponseEntity<String>(HttpStatus.OK); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations.ApiResponse;\n"}, {"ID": 122, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int doEndTag() throws JspException { try { if (!authorized && TagLibConfig.isUiSecurityDisabled()) { pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix()); } } catch (IOException e) { throw new JspException(e); } return EVAL_PAGE; } \nResponse:", "ground_truth": "Default processing of the end tag returning EVAL_PAGE.\n\n@return EVAL_PAGE\n@see Tag#doEndTag()", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.struts2.StrutsStatics;\nimport org.apache.struts2.components.Component;\nimport org.apache.struts2.components.UIBean;\nimport org.apache.struts2.views.jsp.TagUtils;\n\nimport com.opensymphony.xwork2.util.ValueStack;\n\n/**\n * @author <a href=\"mailto:"}, {"ID": 123, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void initUserDetailsService() throws Exception { for (UserDetailsBuilder userBuilder : userBuilders) { getUserDetailsService().createUser(userBuilder.build()); } for (UserDetails userDetails : this.users) { getUserDetailsService().createUser(userDetails); } } \nResponse:", "ground_truth": "Populates the users that have been added.\n\n@throws Exception", "predict": " ResponseEntity<UserDetails[]> findAllUsers() { return new ResponseEntity<UserDetails[]>(this.users, HttpStatus.OK); } \nResp ResponseEntity<UserDetails> findUser(String username) { return new ResponseEntity<UserDetails>(this.users.get(username), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> createUser(UserDetails userDetails) { return new ResponseEntity<UserDetails>(this.users.put(userDetails.getUsername(), userDetails), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> updateUser(String username, UserDetails userDetails) { return new ResponseEntity<UserDetails>(this.users.put(username, userDetails), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> deleteUser(String username) { return new ResponseEntity<UserDetails>(this.users.remove(username), HttpStatus.OK); } \nResp ResponseEntity"}, {"ID": 124, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private UserDetailsService getUserDetailsService() { Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class); if (beans.size() == 0) { beans = getBeansOfType(UserDetailsService.class); } if (beans.size() == 0) { throw new ApplicationContextException(\"No UserDetailsService registered.\"); } else if (beans.size() > 1) { throw new ApplicationContextException( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\"); } return (UserDetailsService) beans.values().toArray()[0]; } \nResponse:", "ground_truth": "Obtains a user details service for use in RememberMeServices etc. Will return a\ncaching version if available so should not be used for beans which need to separate\nthe two.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>OpenID Connect Demo</title>\n</head>\n<body>\n<h1>OpenID Connect Demo</h1>\n<p>\nThis example demonstrates how to use the OpenID Connect protocol to authenticate users.\n</p>\n<p>\nThe example uses the <a href=\"http://openid.net/specs/openid-connect-core-1_0.html\">OpenID Connect Core 1.0</a> specification.\n</p>\n<p>\nThe example uses the <a href=\"http://openid.net/specs/openid-connect-discovery-1_0.html\">OpenID Connect Discovery 1.0</a> specification.\n</p>\n<p>\nThe example uses the <a"}, {"ID": 125, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) { String codeVerifier = this.codeVerifierGenerator.generateKey(); attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier); try { String codeChallenge = createCodeChallenge(codeVerifier); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\"); } catch (NoSuchAlgorithmException e) { additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier); } } \nResponse:", "ground_truth": "Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests\n\n@param attributes where {@link PkceParameterNames#CODE_VERIFIER} is stored for the token request\n@param additionalParameters where {@link PkceParameterNames#CODE_CHALLENGE} and, usually,\n{@link PkceParameterNames#CODE_CHALLENGE_METHOD} are added to be used in the authorization request.\n\n@since 5.2\n@see 1.1.  Protocol Flow\n@see 4.1.  Client Creates a Code Verifier\n@see 4.2.  Client Creates the Code Challenge", "predict": " 200 OK\n\n*/\n\npackage com.microsoft.azure.cognitiveservices.language.textanalytics.models;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * The PkceParameters model.\n */\npublic class PkceParameters {\n    /**\n     * The codeVerifier property.\n     */\n    @JsonProperty(value = \"code_verifier\")\n    private String codeVerifier;\n\n    /**\n     * The codeChallenge property.\n     */\n    @JsonProperty(value = \"code_challenge\")\n    private String codeChallenge;\n\n    /**\n     * The codeChallengeMethod property.\n     */\n    @JsonProperty(value = \"code_challenge_method\")\n    private String codeChallengeMethod;\n\n    /**\n     * Get the codeVerifier value.\n     *\n     * @return the codeVerifier value\n     "}, {"ID": 126, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { final boolean serviceTicketRequest = serviceTicketRequest(request, response); final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request)); if (logger.isDebugEnabled()) { logger.debug(\"requiresAuthentication = \" + result); } return result; } \nResponse:", "ground_truth": "Overridden to provide proxying capabilities.", "predict": " Generate the method-level comment for the following java Code. Code: protected boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { final String serviceTicket = serviceTicketRequest(request, response); if (serviceTicket == null) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + serviceTicket); } return serviceTicket; } \nResp Generate the method-level comment for the following java Code. Code: protected boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorRequest(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \nResp Generate the method-level comment for the following java Code. Code: protected boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { final"}, {"ID": 127, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a service ticket. This method exists\nfor readability.\n@param request\n@param response\n@return", "predict": " Generate the method-level comment for the following java Code. Code: private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; } \n\n*/\n\n/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express"}, {"ID": 128, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { if (serviceTicketRequest) { return false; } final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated(); if (logger.isDebugEnabled()) { logger.debug(\"proxyTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a proxy ticket.\n@param request\n@return", "predict": " private boolean authenticateAllArtifacts = false; private boolean authenticated() { return authenticated; } private boolean authenticated = false; private Artifact obtainArtifact(final HttpServletRequest request) { return obtainArtifact(request, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId) { return obtainArtifact(request, artifactId, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType) { return obtainArtifact(request, artifactId, artifactType, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType, final String artifactQualifier) { return obtainArtifact(request, artifactId, artifactType, artifactQualifier, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType, final String artifactQualifier, final String artifactVersion) { return obtainArtifact("}, {"ID": 129, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean authenticated() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken); } \nResponse:", "ground_truth": "Determines if a user is already authenticated.\n@return", "predict": " ResponseEntity<String> authentication(Authentication authentication) { if (authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken)) { return new ResponseEntity<String>(\"User \" + authentication.getName() + \" is authenticated\", HttpStatus.OK); } else { return new ResponseEntity<String>(\"User is not authenticated\", HttpStatus.UNAUTHORIZED); } }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson."}, {"ID": 130, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to be processed as the proxy receptor.\n@param request\n@return", "predict": " Generate the method-level comment for the following java Code. Code: private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Strings;\n\npublic class ProxyReceptorMatcher {\n\n\tprivate static final Pattern proxyReceptorPattern = Pattern.compile(\"^(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.("}, {"ID": 131, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MethodSecurityExpressionOperations createSecurityExpressionRoot( Authentication authentication, MethodInvocation invocation) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot( authentication); root.setThis(invocation.getThis()); root.setPermissionEvaluator(getPermissionEvaluator()); root.setTrustResolver(getTrustResolver()); root.setRoleHierarchy(getRoleHierarchy()); root.setDefaultRolePrefix(getDefaultRolePrefix()); return root; } \nResponse:", "ground_truth": "Creates the root object for expression evaluation.", "predict": " Response = createSecurityExpressionRoot( authentication, invocation).checkPermission( permission); \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.access.expression.SecurityExpressionRoot;\nimport org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;\nimport org.springframework.security.access.expression.method.MethodSecurityExpressionOperations;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n@Component\npublic class MyMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {\n\n    @Autowired\n    @Qualifier(\"myPermissionEval"}, {"ID": 132, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Mono<JWKSet> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); } \nResponse:", "ground_truth": "Updates the cached JWK set from the configured URL.\n\n@return The updated JWK set.\n\n@throws RemoteKeySourceException If JWK retrieval failed.", "predict": "\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwk"}, {"ID": 133, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String utf8UrlEncode(String value) { try { return URLEncoder.encode(value, \"UTF-8\"); } catch (UnsupportedEncodingException e) { Error err = new AssertionError( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\"); err.initCause(e); throw err; } } \nResponse:", "ground_truth": "Performs URL encoding with UTF-8\n\n@param value the value to URL encode\n@return the encoded value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 134, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() { List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser(); Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper .getGrantedAuthorities(webSphereGroups); if (logger.isDebugEnabled()) { logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas); } return userGas; } \nResponse:", "ground_truth": "Get a list of Granted Authorities based on the current user's WebSphere groups.\n\n@return authorities mapped from the user's WebSphere groups.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class WebSphereUserDetails implements UserDetails {\n\n    private static final long serialVersionUID = -828379812085662898L;\n\n    private final String userName;\n    private final String password;\n    private final List<GrantedAuthority> authorities;\n\n    public"}, {"ID": 135, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken( assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); } \nResponse:", "ground_truth": "Template method for retrieving the UserDetails based on the assertion. Default is\nto call configured userDetailsService and pass the username. Deployers can override\nthis method and retrieve the user based on any criteria they desire.\n\n@param assertion The CAS Assertion.\n@return the UserDetails.", "predict": " ResponseEntity<UserDetails> loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service(\"userDetailsService\")\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n"}, {"ID": 136, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = wasHelper.getCurrentUserName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated WebSphere principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the WebSphere user name.", "predict": " Response wasHelper.getPreAuthenticatedPrincipal(HttpServletRequest httpRequest);\n\n*/\n\nimport java.util.logging.Logger;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.ibm.websphere.security.auth.WSSubject;\nimport com.ibm.websphere.security.auth.WSSubjectProvider;\n\npublic class WASHelper {\n\tprivate static final Logger logger = Logger.getLogger(WASHelper.class.getName());\n\t\n\tpublic static Object getCurrentUserName() {\n\t\treturn WSSubject.getCallerPrincipal();\n\t}\n\t\n\tpublic static Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {\n\t\treturn WSSubjectProvider.getCallerPrincipal(httpRequest);\n\t}\n\t"}, {"ID": 137, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] concatenate(byte[]... arrays) { int length = 0; for (byte[] array : arrays) { length += array.length; } byte[] newArray = new byte[length]; int destPos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, newArray, destPos, array.length); destPos += array.length; } return newArray; } \nResponse:", "ground_truth": "Combine the individual byte arrays into one array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 138, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] subArray(byte[] array, int beginIndex, int endIndex) { int length = endIndex - beginIndex; byte[] subarray = new byte[length]; System.arraycopy(array, beginIndex, subarray, 0, length); return subarray; } \nResponse:", "ground_truth": "Extract a sub array of bytes out of the byte array.\n@param array the byte array to extract from\n@param beginIndex the beginning index of the sub array, inclusive\n@param endIndex the ending index of the sub array, exclusive", "predict": "\n\n*/\n\nimport java.util.Arrays;\n\npublic class SubArray {\n    public static byte[] subArray(byte[] array, int beginIndex, int endIndex) {\n        int length = endIndex - beginIndex;\n        byte[] subarray = new byte[length];\n        System.arraycopy(array, beginIndex, subarray, 0, length);\n        return subarray;\n    }\n\n    public static void main(String[] args) {\n        byte[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(Arrays.toString(subArray(array, 2, 4)));\n    }\n}\n"}, {"ID": 139, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { ArrayList<GrantedAuthority> gaList = new ArrayList<>(); for (String attribute : attributes) { Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap .get(attribute); if (c != null) { gaList.addAll(c); } } gaList.trimToSize(); return gaList; } \nResponse:", "ground_truth": "Map the given array of attributes to Spring Security GrantedAuthorities.", "predict": "\n\npublic List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {\n\tArrayList<GrantedAuthority> gaList = new ArrayList<>();\n\tfor (String attribute : attributes) {\n\t\tCollection<GrantedAuthority> c = attributes2grantedAuthoritiesMap.get(attribute);\n\t\tif (c != null) {\n\t\t\tgaList.addAll(c);\n\t\t}\n\t}\n\tgaList.trimToSize();\n\treturn gaList;\n}\n\n*/\n\npublic class GrantedAuthorityImpl implements GrantedAuthority {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String authority;\n\n\tpublic GrantedAuthorityImpl(String authority) {\n\t\tthis.authority = authority;\n\t}\n\n\t@Override\n\tpublic String getAuthority() {\n\t\treturn authority;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;"}, {"ID": 140, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) { Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>( orgMap.size()); for (Map.Entry<?, ?> entry : orgMap.entrySet()) { Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\"); result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue())); } return result; } \nResponse:", "ground_truth": "Preprocess the given map to convert all the values to GrantedAuthority collections\n\n@param orgMap The map to process\n@return the processed Map", "predict": " private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object orgCollection) { if (orgCollection == null) { return null; } if (orgCollection instanceof Collection) { return (Collection<GrantedAuthority>) orgCollection; } if (orgCollection instanceof GrantedAuthority) { return Collections.singletonList((GrantedAuthority) orgCollection); } throw new IllegalArgumentException(\"attributes2grantedAuthoritiesMap contains non-Collection or non-GrantedAuthority objects as values\"); } \n\n*/\n"}, {"ID": 141, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) { Collection<GrantedAuthority> result = new ArrayList<>(); addGrantedAuthorityCollection(result, value); return result; } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.POST)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(@RequestBody Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.PUT)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(@RequestBody Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.DELETE)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection"}, {"ID": 142, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) { if (value == null) { return; } if (value instanceof Collection<?>) { addGrantedAuthorityCollection(result, (Collection<?>) value); } else if (value instanceof Object[]) { addGrantedAuthorityCollection(result, (Object[]) value); } else if (value instanceof String) { addGrantedAuthorityCollection(result, (String) value); } else if (value instanceof GrantedAuthority) { result.add((GrantedAuthority) value); } else { throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName()); } } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities, adding the result\nto the given result collection.\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": "\n\npublic class UserDetailsImpl extends AbstractUserDetails implements UserDetails {\n    private static final long serialVersionUID = 1L;\n    private final String password;\n    private final Collection<GrantedAuthority> authorities;\n    private final boolean accountNonExpired;\n    private final boolean accountNonLocked;\n    private final boolean credentialsNonExpired;\n    private final boolean enabled;\n    private final String username;\n    private final String email;\n    private final String firstName;\n    private final String lastName;\n    private final String phoneNumber;\n    private final String address;\n    private final String city;\n    private final String state;\n    private final String zip;\n    private final String country;\n    private final String organization;\n    private final String organizationUnit;\n    private final String title;\n    private final String department;\n    private final String departmentUnit;\n    private final String departmentTitle;\n    private final String departmentDepartment;\n    private final String"}, {"ID": 143, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest .getUserPrincipal().getName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated J2EE principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the J2EE user name.", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\n\n@Path(\"/\")\npublic class HelloWorldResource {\n\n\tprivate static final Logger logger = Logger.getLogger(HelloWorldResource.class);\n\n\t@GET\n\t@Path(\"/hello\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic String getHelloWorld() {\n\t\tlogger.info(\"HelloWorldResource.getHelloWorld()\");\n\t\treturn \"Hello World\";\n\t}\n\n\t@GET\n\t@Path(\"/users"}, {"ID": 144, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); } \nResponse:", "ground_truth": "Gets a shared Object. Note that object heirarchies are not considered.\n\n@param sharedType the type of the shared Object\n@return the shared Object or null if it is not found", "predict": " @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); } \n\n*/\n\npublic class SharedObjects {\n\tprivate Map<Class<?>, Object> sharedObjects;\n\t\n\tpublic SharedObjects() {\n\t\tsharedObjects = new HashMap<Class<?>, Object>();\n\t}\n\t\n\tpublic <C> C getSharedObject(Class<C> sharedType) {\n\t\treturn (C) sharedObjects.get(sharedType);\n\t}\n\t\n\tpublic <C> void setSharedObject(Class<C> sharedType, C sharedObject) {\n\t\tsharedObjects.put(sharedType, sharedObject);\n\t}\n}\n"}, {"ID": 145, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException { int serverPort = portResolver.getServerPort(request); Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort)); if (httpsPort != null) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder(); urlBuilder.setScheme(\"https\"); urlBuilder.setServerName(request.getServerName()); urlBuilder.setPort(httpsPort.intValue()); urlBuilder.setContextPath(request.getContextPath()); urlBuilder.setServletPath(request.getServletPath()); urlBuilder.setPathInfo(request.getPathInfo()); urlBuilder.setQuery(request.getQueryString()); return urlBuilder.getUrl(); } // Fall through to server-side forward with warning message logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort); return null; } \nResponse:", "ground_truth": "Builds a URL to redirect the supplied request to HTTPS. Used to redirect the\ncurrent request to HTTPS, before doing a forward to the login page.", "predict": "\n\npublic class RedirectUrlBuilder {\n    private String scheme;\n    private String serverName;\n    private int port;\n    private String contextPath;\n    private String servletPath;\n    private String pathInfo;\n    private String query;\n\n    public String getUrl() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(scheme).append(\"://\").append(serverName);\n        if (port != -1) {\n            sb.append(\":\").append(port);\n        }\n        sb.append(contextPath).append(servletPath);\n        if (pathInfo != null) {\n            sb.append(pathInfo);\n        }\n        if (query != null) {\n            sb.append(\"?\").append(query);\n        }\n        return sb.toString();\n    }\n\n    public void setScheme(String scheme) {\n        this.scheme = scheme;\n    }"}, {"ID": 146, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); } \nResponse:", "ground_truth": "Method that is suitable for user with traditional AspectJ-code aspects.\n\n@param jp The AspectJ joint point being invoked which requires a security decision\n@param advisorProceed the advice-defined anonymous class that implements\n{@code AspectJCallback} containing a simple {@code return proceed();} statement\n\n@return The returned value from the method invocation", "predict": " public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); } \n\n*/\n\npackage com.aspectj.autoproxy;\n\nimport java.lang.reflect.Method;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\n\n@Aspect\npublic class Advice {\n\t@Pointcut(\"execution(public * com.aspectj.autoproxy"}, {"ID": 147, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String hasRole(String role) { Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\"); return \"ROLE_\" + role; } \nResponse:", "ground_truth": "Creates a String for specifying a user requires a role.\n\n@param role the role that should be required which is prepended with ROLE_\nautomatically (i.e. USER, ADMIN, etc). It should not start with ROLE_\n@return the {@link ConfigAttribute} expressed as a String", "predict": "\n\n@RequestMapping(value = \"/users/{userId}\", method = RequestMethod.GET)\npublic ResponseEntity<User> getUser(@PathVariable Long userId) {\n    return ResponseEntity.ok()\n        .header(\"Access-Control-Allow-Origin\", \"*\")\n        .header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\")\n        .header(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, DELETE, OPTIONS\")\n        .header(\"Access-Control-Max-Age\", \"3600\")\n        .header(\"Access-Control-Allow-Credentials\", \"true\")\n        .body(userService.getUser(userId));\n}\n\n@RequestMapping(value = \"/users\", method = RequestMethod.GET)\npublic ResponseEntity<List<User>> getAllUsers() {\n    return ResponseEntity."}, {"ID": 148, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String[] hasAnyRole(String... roles) { for (int i = 0; i < roles.length; i++) { roles[i] = \"ROLE_\" + roles[i]; } return roles; } \nResponse:", "ground_truth": "Creates a String for specifying that a user requires one of many roles.\n\n@param roles the roles that the user should have at least one of (i.e. ADMIN, USER,\netc). Each role should not start with ROLE_ since it is automatically prepended\nalready.\n@return the {@link ConfigAttribute} expressed as a String", "predict": " Response.ok().build();\n\n*/\n\npackage com.example.springmvc.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.JoinTable;\nimport javax.persistence.ManyToMany;\nimport javax.persistence.Table;\n\n@Entity\n@Table(name = \"user\")\npublic class User {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.AUTO)\n\t@Column(name = \"id\")\n\tprivate int id;\n\n\t@Column(name = \"name\")\n\tprivate String"}, {"ID": 149, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { if (cookieTokens.length != 2) { throw new InvalidCookieException(\"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\"); } final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException( \"No persistent token found for series id: \" + presentedSeries); } // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( \"PersistentTokenBasedRememberMeServices.cookieStolen\", \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\")); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System .currentTimeMillis()) { throw new RememberMeAuthenticationException(\"Remember-me login has expired\"); } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) { logger.debug(\"Refreshing persistent login token for user '\" + token.getUsername() + \"', series '\" + token.getSeries() + \"'\"); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try { tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); } catch (Exception e) { logger.error(\"Failed to update token: \", e); throw new RememberMeAuthenticationException( \"Autologin failed due to data access problem\"); } return getUserDetailsService().loadUserByUsername(token.getUsername()); } \nResponse:", "ground_truth": "Locates the presented cookie data in the token repository, using the series id. If\nthe data compares successfully with that in the persistent store, a new token is\ngenerated and stored with the same series. The corresponding cookie value is set on\nthe response.\n\n@param cookieTokens the series and token values\n\n@throws RememberMeAuthenticationException if there is no stored token corresponding\nto the submitted cookie, or if the token in the persistent store has expired.\n@throws InvalidCookieException if the cookie doesn't have two tokens as expected.\n@throws CookieTheftException if a presented series value is found, but the stored\ntoken is different from the one presented.", "predict": "\n\n@RequestMapping(value = \"/login\", method = RequestMethod.POST)\npublic String login(@RequestParam(\"j_username\") String username, @RequestParam(\"j_password\") String password, Model model, HttpServletRequest request, HttpServletResponse response) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"login() - username: \" + username + \" - password: \" + password);\n\t}\n\tif (StringUtils.isEmpty(username)) {\n\t\tlogger.warn(\"login() - username is empty\");\n\t\treturn \"login\";\n\t}\n\tif (StringUtils.isEmpty(password)) {\n\t\tlogger.warn(\"login() - password is empty\");\n\t\treturn \"login\";\n\t}\n\ttry {\n\t\tUserDetails userDetails = getUserDetailsService().loadUserByUsername(username);\n\t\tif (userDetails == null) {\n\t\t\tlogger."}, {"ID": 150, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); logger.debug(\"Creating new persistent login for user \" + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try { tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } catch (Exception e) { logger.error(\"Failed to save persistent token \", e); } } \nResponse:", "ground_truth": "Creates a new persistent login token with a new series number, stores the data in\nthe persistent token repository and adds the corresponding cookie to the response.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.env.Environment;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport"}, {"ID": 151, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest; String username = request.getParameter(this.usernameParameter); if (username == null) { username = \"\"; } if (this.logger.isDebugEnabled()) { this.logger.debug(\"Attempt to switch to user [\" + username + \"]\"); } UserDetails targetUser = this.userDetailsService.loadUserByUsername(username); this.userDetailsChecker.check(targetUser); // OK, create the switch user token targetUserRequest = createSwitchUserToken(request, targetUser); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\"); } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser)); } return targetUserRequest; } \nResponse:", "ground_truth": "Attempt to switch to another user. If the user does not exist or is not active,\nreturn null.\n\n@return The new Authentication request if successfully switched to\nanother user, null otherwise.\n\n@throws UsernameNotFoundException If the target user is not found.\n@throws LockedException if the account is locked.\n@throws DisabledException If the target user is disabled.\n@throws AccountExpiredException If the target user account is expired.\n@throws CredentialsExpiredException If the target user credentials are expired.", "predict": "\n\npublic class AuthenticationSwitchUserEvent extends AbstractAuthenticationEvent {\n\tprivate UserDetails userDetails;\n\n\tpublic AuthenticationSwitchUserEvent(Authentication authentication, UserDetails userDetails) {\n\t\tsuper(authentication);\n\t\tthis.userDetails = userDetails;\n\t}\n\n\tpublic UserDetails getUserDetails() {\n\t\treturn this.userDetails;\n\t}\n}\n\n*/\n"}, {"ID": 152, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder.getContext().getAuthentication(); if (null == current) { throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noCurrentUser\", \"No current user associated with this request\")); } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication(current); if (original == null) { this.logger.debug(\"Could not find original user Authentication object!\"); throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noOriginalAuthentication\", \"Could not find original Authentication object\")); } // get the source user details UserDetails originalUser = null; Object obj = original.getPrincipal(); if ((obj != null) && obj instanceof UserDetails) { originalUser = (UserDetails) obj; } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent( new AuthenticationSwitchUserEvent(current, originalUser)); } return original; } \nResponse:", "ground_truth": "Authentication object or null\notherwise.\n\n@throws AuthenticationCredentialsNotFoundException If no\nAuthentication associated with this request.", "predict": "\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.POST)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.GET)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.POST)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod."}, {"ID": 153, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setExitUserUrl(String exitUserUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\"); this.exitUserMatcher = createMatcher(exitUserUrl); } \nResponse:", "ground_truth": "Set the URL to respond to exit user processing.\n\n@param exitUserUrl The exit user URL.", "predict": "\n\n@RequestMapping(value = \"/api/exituser\", method = RequestMethod.POST)\npublic ResponseEntity<ExitUser> exitUser(@RequestBody ExitUser exitUser) {\n\tAssert.notNull(exitUser, \"exitUser cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exit"}, {"ID": 154, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); } \nResponse:", "ground_truth": "The public index page, used for unauthenticated users.", "predict": "\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello"}, {"ID": 155, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); } \nResponse:", "ground_truth": "Creates the Spring Security Filter Chain\n@return the {@link Filter} that represents the security filter chain\n@throws Exception", "predict": "\n\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n@Bean(name = AbstractSecurityWebApplication"}, {"ID": 156, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); } \nResponse:", "ground_truth": "Decode and validate the JWT from its compact claims representation format\n\n@param token the JWT value\n@return a validated {@link Jwt}\n@throws JwtException", "predict": " @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); } \n\n*/\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.datab"}, {"ID": 157, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingAccessExpression() throws IOException { if (SecurityContextHolder.getContext().getAuthentication() == null) { return false; } SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler(); Expression accessExpression; try { accessExpression = handler.getExpressionParser().parseExpression(getAccess()); } catch (ParseException e) { IOException ioException = new IOException(); ioException.initCause(e); throw ioException; } return ExpressionUtils.evaluateAsBoolean(accessExpression, createExpressionEvaluationContext(handler)); } \nResponse:", "ground_truth": "Make an authorization decision based on a Spring EL expression. See the\n\"Expression-Based Access Control\" chapter in Spring Security for details on what\nexpressions can be used.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.access.expression.SecurityExpressionHandler;\nimport org.springframework.security.access.expression.SecurityExpressionOperations;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AccessExpressionEvaluator {\n\t\n\t@Autowired\n\tprivate SecurityExpressionHandler<FilterInvocation> expressionHandler;\n\t\n\tpublic boolean authorizeUsingAccessExpression() {\n\t\tAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\t\tif (authentication == null"}, {"ID": 158, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingUrlCheck() throws IOException { String contextPath = ((HttpServletRequest) getRequest()).getContextPath(); Authentication currentUser = SecurityContextHolder.getContext() .getAuthentication(); return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser); } \nResponse:", "ground_truth": "Make an authorization decision based on the URL and HTTP method attributes. True is\nreturned if the user is allowed to access the given URL as defined.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.S"}, {"ID": 159, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<GrantedAuthority> convert(Jwt jwt) { return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Extracts the authorities\n@param jwt The {@link Jwt} token\n@return The {@link GrantedAuthority authorities} read from the token scopes", "predict": "\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList());\n}\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList());\n}\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new"}, {"ID": 160, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } \nResponse:", "ground_truth": "Generates a new token\n@param request the {@link HttpServletRequest} to use. The\n{@link HttpServletRequest} must have the {@link HttpServletResponse} as an\nattribute with the name of HttpServletResponse.class.getName()", "predict": " @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } \n\nMethod: @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response) { return wrap(request, this.delegate.generateToken(request, response)); } \nResp @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response) { return wrap(request, this.delegate.generateToken(request, response)); } \n\nMethod: @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response, String cookieName) { return wrap(request, this.delegate.generateToken(request, response, cookieName)); } \nResp @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response, String cookieName) {"}, {"ID": 161, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); } \nResponse:", "ground_truth": "Displays the permission admin page for a particular contact.", "predict": "\n\n@RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); } \n\n@RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact));"}, {"ID": 162, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); } \nResponse:", "ground_truth": "Displays the \"add permission\" page for a contact.", "predict": "\n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); } \n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public ModelAndView addPermission(@ModelAttribute(\"addPermission\") AddPermission addPermission, BindingResult result, ModelMap model) { Contact contact = addPermission.getContact(); if (result"}, {"ID": 163, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles submission of the \"add permission\" form.", "predict": "\n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients"}, {"ID": 164, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); } \nResponse:", "ground_truth": "Deletes a permission", "predict": " @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); } \nResp @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\")"}, {"ID": 165, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) { if (role == null) { return role; } if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) { return role; } if (role.startsWith(defaultRolePrefix)) { return role; } return defaultRolePrefix + role; } \nResponse:", "ground_truth": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if role\ndoes not already start with defaultRolePrefix.\n\n@param defaultRolePrefix\n@param role\n@return", "predict": " Response = Response.ok().entity(getRoleWithDefaultPrefix(defaultRolePrefix, role)).build();\n\n*/\n\npackage com.google.code.magja.model.user;\n\nimport java.util.Date;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport com.google.code.magja.model.BaseMagentoModel;\n\n/**\n * @author andre\n * @author Simon Zambrovski\n */\n@XmlRootElement\npublic class User extends BaseMagentoModel {\n\n  private static final long serialVersionUID = -8283798410095537984L;\n\n  private String username;\n\n  private String email;\n\n  private String password;\n\n  private String firstname;\n\n  private String lastname;\n\n  private String address;\n\n  private String city;\n\n  private String state;\n\n  private String country;\n\n  private String zip;\n\n  private String"}, {"ID": 166, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UserDetailsResourceFactoryBean fromString(String users) { InMemoryResource resource = new InMemoryResource(users); return fromResource(resource); } \nResponse:", "ground_truth": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean", "predict": " ResponseEntity<UserDetailsResource> fromResource(Resource resource) { return new ResponseEntity<UserDetailsResource>(new UserDetailsResource(resource), HttpStatus.OK); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.Api"}, {"ID": 167, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; } \nResponse:", "ground_truth": "Returns the values for a specific attribute\n\n@param name the attribute name\n@return a String array, never null but may be zero length", "predict": " public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; } \n\n*/\n\npublic class Solution {\n    public List<String> getAttributeValues(String name) {\n        List<String> result = null;\n        if (attributes != null) {\n            result = attributes.get(name);\n        }\n        if (result == null) {\n            result = Collections.emptyList();\n        }\n        return result;\n    }\n}\n"}, {"ID": 168, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getFirstAttributeValue(String name) { List<String> result = getAttributeValues(name); if (result.isEmpty()) { return null; } else { return result.get(0); } } \nResponse:", "ground_truth": "Returns the first attribute value for a specified attribute\n\n@param name\n@return the first attribute value for a specified attribute, may be null", "predict": " Response is generated by the method getFirstAttributeValue(String name)\n\n*/\n\npublic class GetAttributeValues {\n\tpublic static void main(String[] args) {\n\t\tString name = \"name\";\n\t\tString response = \"Response is generated by the method getFirstAttributeValue(String name)\";\n\t\tSystem.out.println(response);\n\t}\n}\n"}, {"ID": 169, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] encode(CharSequence string) { try { ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string)); byte[] bytesCopy = new byte[bytes.limit()]; System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit()); return bytesCopy; } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } } \nResponse:", "ground_truth": "Get the bytes of the String in UTF-8 encoded form.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String encoded = encode(input);\n        System.out.println(encoded);\n    }\n\n    public static String encode(String input) {\n        byte[] bytes = input.getBytes();\n        byte[] encoded = Base64.getEncoder().encode(bytes);\n        return new String(encoded);\n    }\n\n    public static String decode(String input) {\n        byte[] bytes = Base64.getDecoder().decode(input.getBytes());"}, {"ID": 170, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(byte[] bytes) { try { return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString(); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Decoding failed\", e); } } \nResponse:", "ground_truth": "Decode the bytes in UTF-8 form into a String.", "predict": " public static byte[] encode(String string) { try { return CHARSET.newEncoder().encode(CharBuffer.wrap(string)); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } } \n\n*/\n\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.util.Arrays;\n\npublic class CharsetDemo {\n    public static void main(String[] args) {\n        Charset cs = Charset.forName(\"UTF-8\");\n        CharsetEncoder encoder = cs.newEncoder();\n        CharsetDec"}, {"ID": 171, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends AccessibleObject> String[] lookupParameterNames( ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; } \nResponse:", "ground_truth": "Gets the parameter names or null if not found.\n\n@param parameterNameFactory the {@link ParameterNameFactory} to use\n@param t the {@link AccessibleObject} to find the parameter names on (i.e. Method\nor Constructor)\n@return the parameter names or null", "predict": " private <T extends AccessibleObject> String[] lookupParameterNames(ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ParameterNameFactory"}, {"ID": 172, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles the submission of the contact form, creating a new instance if the username\nand email are valid.", "predict": "\n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST"}, {"ID": 173, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) { if (targetClass == null) { return null; } return findAttributesSpecifiedAgainst(method, targetClass); } \nResponse:", "ground_truth": "Will walk the method inheritance tree to find the most specific declaration\napplicable.", "predict": " Response is generated by the following java Code. Code: @Override protected Collection<ConfigAttribute> findAttributes(Object object) { if (object == null) { return null; } return findAttributesSpecifiedAgainst(object); } \n\n*/\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.springframework.security.access.ConfigAttribute;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.web.FilterInvocation;\n\npublic class FilterInvocationSecurityMetadataSource extends org.springframework.security.access.intercept.FilterInvocationSecurityMetadataSource {\n\n\tpublic Collection<ConfigAttribute> findAttributes(Object object) {\n\t\tif (object instanceof FilterInvocation) {\n\t\t\tFilterInvocation fi = (FilterInvocation) object;\n\t\t\treturn findAttributesSpecifiedAgainst(fi.getHttpRequest().getRequestURI(), fi.get"}, {"ID": 174, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) { Assert.notNull(method, \"RegisteredMethod required\"); Assert.notNull(attr, \"Configuration attribute required\"); if (logger.isInfoEnabled()) { logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\"); } this.methodMap.put(method, attr); } \nResponse:", "ground_truth": "Add configuration attributes for a secure method.\n\n@param method the method to be secured\n@param attr required authorities associated with the method", "predict": "\n\n*/\n\npackage org.springframework.security.oauth2.provider.endpoint;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.security.oauth2.common.exceptions.InvalidClientException;\nimport org.springframework.security.oauth2.common.exceptions.InvalidGrantException;\nimport org.springframework.security.oauth2.common.exceptions.InvalidRequestException;\nimport org.springframework.security.oauth2.common.exceptions.OAuth2Exception;\nimport org.springframework.security.oauth2.provider.ClientDetails;\nimport org.springframework.security.oauth2.provider.ClientRegistrationException;\nimport org.springframework.security.oauth2.provider.OAuth2RequestValidator;\nimport org.springframework.security.oauth2.provider"}, {"ID": 175, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; } \nResponse:", "ground_truth": "Obtains the configuration attributes explicitly defined against this bean.\n\n@return the attributes explicitly defined against this bean", "predict": " @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.security.access.ConfigAttribute;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.web.FilterInvocation;\n\npublic class MethodSecurityMetadataSource extends org.springframework.security.access.method.MethodSecurityMetadataSource {\n\n\tprivate Map<String, List<ConfigAttribute>> methodMap;\n\n\tpublic MethodSecurityMetadataSource(Map<String, List<ConfigAttribute>> methodMap) {\n\t\tthis.methodMap = methodMap;\n"}, {"ID": 176, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isMatch(String methodName, String mappedName) { return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length()))); } \nResponse:", "ground_truth": "Return if the given method name matches the mapped name. The default implementation\nchecks for \"xxx\" and \"xxx\" matches.\n\n@param methodName the method name of the class\n@param mappedName the name in the descriptor\n\n@return if the names match", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.isMatch(\"aa\",\"a\"));\n    }\n\n    public boolean isMatch(String s, String p) {\n        if(s.length() == 0 && p.length() == 0) return true;\n        if(s.length() == 0 || p.length() == 0) return false;\n        if(s.charAt(0) == p.charAt(0)) return isMatch(s.substring(1), p.substring(1));\n        return false;\n    }\n}\n"}, {"ID": 177, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResponse:", "ground_truth": "Maps any request.\n\n@return the object that is chained after creating the {@link RequestMatcher}", "predict": " public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_RE"}, {"ID": 178, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void handleBindException(String userDn, String username, Throwable cause) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to bind as \" + userDn + \": \" + cause); } } \nResponse:", "ground_truth": "Allows subclasses to inspect the exception thrown by an attempt to bind with a\nparticular DN. The default implementation just reports the failure to the debug\nlogger.", "predict": "\n\n*/\n\npackage com.ibm.ws.security.saml.sso20.acs;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.opensaml.saml2.core.Assertion;\nimport org.opensaml.saml2.core.Attribute;\nimport org.opensaml.saml2.core.AttributeStatement;\nimport org.opensaml.saml2.core.AttributeValue;\nimport org.opensaml.saml2.core.Audience;\nimport org.opensaml.saml2.core.AudienceRestriction;\nimport org.opensaml.saml2.core.Conditions;\nimport org.opensaml.saml2.core.NameID;\nimport org.opensaml.saml2"}, {"ID": 179, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); } \nResponse:", "ground_truth": "This is a public method.", "predict": "\n\n@Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); } \n\n*/\n\n@Transactional(readOnly = true)\npublic Contact getRandomContact() {\n\tlogger.debug(\"Returning random contact\");\n\tRandom rnd = new Random();\n\tList<Contact> contacts = contactDao.findAll();\n\tint getNumber = rnd.nextInt(contacts.size());\n\treturn contacts.get(getNumber);\n}\n\n}\n"}, {"ID": 180, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void clearAuthenticationAttributes(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); } \nResponse:", "ground_truth": "Removes temporary authentication-related data which may have been stored in the\nsession during the authentication process.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation."}, {"ID": 181, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException { Assert.notNull(clazz, \"Class required\"); Assert.hasText(fieldName, \"Field name required\"); try { return clazz.getDeclaredField(fieldName); } catch (NoSuchFieldException nsf) { // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName); } throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz); } } \nResponse:", "ground_truth": "Attempts to locate the specified field on the class.\n\n@param clazz the class definition containing the field\n@param fieldName the name of the field to locate\n\n@return the Field (never null)\n\n@throws IllegalStateException if field could not be found", "predict": "\n\n*/\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FieldUtils {\n\n    public static List<Field> getFields(Class<?> clazz) {\n        List<Field> fields = new ArrayList<Field>();\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field : declaredFields) {\n            fields.add(field);\n        }\n        return fields;\n    }\n\n    public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException {\n        Field field = null;\n        try {\n            field = clazz.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException nsf) {\n            // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName);"}, {"ID": 182, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) { return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId); } \nResponse:", "ground_truth": "Constructs a new Service Url. The default implementation relies on the CAS client\nto do the bulk of the work.\n@param request the HttpServletRequest\n@param response the HttpServlet Response\n@return the constructed service url. CANNOT be NULL.", "predict": " Response\n\n*/\n\npackage com.microsoft.bingads.v12.bulk.entities;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.BiConsumer;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport com.microsoft.bingads.internal.functionalinterfaces.Supplier;\nimport com.microsoft.bingads.v12.bulk.BulkFileReader;\nimport com.microsoft.bingads.v12.bulk.BulkFileWriter;\nimport com.microsoft.bingads.v12.bulk.BulkOperation;\nimport com.microsoft.bingads.v12.bulk.BulkServiceManager;\nimport com.microsoft.bingads.v12.bulk.BulkStreamReader;\nimport com.microsoft.bingads.v12.b"}, {"ID": 183, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createRedirectUrl(final String serviceUrl) { return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false); } \nResponse:", "ground_truth": "Constructs the Url for Redirection to the CAS server. Default implementation relies\non the CAS client to do the bulk of the work.\n\n@param serviceUrl the service url that should be included.\n@return the redirect url. CANNOT be NULL.", "predict": " Response\n\n*/\n\npackage com.microsoft.bingads.v12.reporting;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.BiConsumer;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport com.microsoft.bingads.internal.functionalinterfaces.Supplier;\nimport com.microsoft.bingads.v12.reporting.ReportFormat;\nimport com.microsoft.bingads.v12.reporting.ReportTimePeriod;\n\npublic class ReportRequest {\n\t\n\tprivate ReportFormat format;\n\t\n\tprivate ReportTimePeriod timePeriod;\n\t\n\tprivate List<String> reportEntities;\n\t\n\tprivate List<String> reportColumns;\n\t\n\tprivate Map<String, String> reportFilters;\n\t"}, {"ID": 184, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String extractPrefix(String encPass) { if (!encPass.startsWith(\"{\")) { return null; } int secondBrace = encPass.lastIndexOf('}'); if (secondBrace < 0) { throw new IllegalArgumentException( \"Couldn't find closing brace for SHA prefix\"); } return encPass.substring(0, secondBrace + 1); } \nResponse:", "ground_truth": "Returns the hash prefix or null if there isn't one.", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        String[] input = new String[n];\n        for(int a0 = 0; a0 < n; a0++){\n            input[a0] = in.next();\n        }\n        String result = \"\";\n        for(int a0 = 0; a0 < n; a0++){\n            result += input[a0].charAt(0);\n        }\n        System.out.println(result);\n    }\n}\n"}, {"ID": 185, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); } \nResponse:", "ground_truth": "Always returns a 403 error code to the client.", "predict": "\npublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SimpleServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServlet"}, {"ID": 186, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkFilterStack(List<Filter> filters) { checkForDuplicates(SecurityContextPersistenceFilter.class, filters); checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters); checkForDuplicates(SessionManagementFilter.class, filters); checkForDuplicates(BasicAuthenticationFilter.class, filters); checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters); checkForDuplicates(JaasApiIntegrationFilter.class, filters); checkForDuplicates(ExceptionTranslationFilter.class, filters); checkForDuplicates(FilterSecurityInterceptor.class, filters); } \nResponse:", "ground_truth": "Checks the filter list for possible errors and logs them", "predict": "\n\npublic class FilterSecurityInterceptor extends OncePerRequestFilter {\n\t@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n\t\tList<Filter> filters = getFilters(request);\n\t\tcheckFilterStack(filters);\n\t\tfilterChain.doFilter(request, response);\n\t}\n}\n\n*/\n"}, {"ID": 187, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final Class<? extends Throwable>[] getRegisteredTypes() { Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet(); return typeList.toArray(new Class[typeList.size()]); } \nResponse:", "ground_truth": "Returns an array containing the classes for which extractors are registered. The\norder of the classes is the order in which comparisons will occur for resolving a\nmatching extractor.\n\n@return the types for which extractors are registered", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 188, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Throwable extractCause(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractCause(throwable); } } return null; } \nResponse:", "ground_truth": "Extracts the cause of the given throwable using an appropriate extractor.\n\n@param throwable the Throwable (not null\n@return the cause, may be null if none could be resolved", "predict": " Response<T> extractResponse(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractResponse(throwable); } } return null; } \n\n*/\n\npublic class ThrowableCauseExtractor {\n\t\n\tprivate Map<Class<? extends Throwable>, ThrowableCauseExtractor> extractorMap = new HashMap<Class<? extends Throwable>, ThrowableCauseExtractor>();\n\t\n\tpublic ThrowableCauseExtractor() {\n\t\textractorMap.put(NullPointerException.class, new NullPointerCauseExtractor());\n\t\textractorMap.put(IllegalArgumentException.class, new IllegalArgumentCauseExtractor());\n\t\textractor"}, {"ID": 189, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder .rootBeanDefinition(AffirmativeBased.class); ManagedList voters = new ManagedList(4); if (expressionVoter != null) { voters.add(expressionVoter); } voters.add(new RootBeanDefinition(RoleVoter.class)); voters.add(new RootBeanDefinition(AuthenticatedVoter.class)); if (jsr250Enabled) { voters.add(new RootBeanDefinition(Jsr250Voter.class)); } accessMgrBuilder.addConstructorArgValue(voters); BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition(); String id = pc.getReaderContext().generateBeanName(accessManager); pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id)); return id; } \nResponse:", "ground_truth": "Register the default AccessDecisionManager. Adds the special JSR 250 voter jsr-250\nis enabled and an expression voter if expression-based access control is enabled.\n@return", "predict": "\n\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic class AffirmativeBased extends AffirmativeBasedSupport {\n\tpublic AffirmativeBased(List voters) {\n\t\tsuper(voters);\n\t}\n\tpublic boolean isRequestAuthenticated(HttpServletRequest request) {\n\t\treturn super.isRequestAuthenticated(request);\n\t}\n\tpublic boolean supports(Class clazz) {\n\t\treturn super.supports(clazz);\n\t}\n\tpublic void decide(Authentication authentication, Object object, Collection collection) {\n\t\tsuper.decide(authentication, object, collection);\n\t}\n\tpublic void setMessageSource(MessageSource messageSource) {\n\t\tsuper.setMessageSource(messageSource);\n\t}\n\tpublic void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n\t\tsuper.setApplicationEventPublisher(applicationEventPublisher);\n\t}\n\tpublic void setApplicationContext(ApplicationContext application"}, {"ID": 190, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) { Assert.notNull(userAuthorities, \"userAuthorities cannot be null\"); Set<String> set = new HashSet<>(userAuthorities.size()); for (GrantedAuthority authority : userAuthorities) { set.add(authority.getAuthority()); } return set; } \nResponse:", "ground_truth": "Converts an array of GrantedAuthority objects to a Set.\n@return a Set of the Strings obtained from each call to\nGrantedAuthority.getAuthority()", "predict": " ResponseEntity<Set<String>> setAuthorities(Collection<? extends GrantedAuthority> authorities);\n\n*/\n\nimport java.util.Collection;\nimport java.util.Set;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class UserDetailsImpl implements UserDetails {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate String password;\n\tprivate Set<GrantedAuthority> authorities;\n\t\n\tpublic UserDetailsImpl(String username, String password, Collection<? extends GrantedAuthority> authorities) {\n\t\tthis.username = username;\n\t\tthis.password = password;\n\t\tthis.authorities = new HashSet<GrantedAuthority>(authorities);\n\t}\n\n\t@Override\n\tpublic Collection<? extends GrantedAuthor"}, {"ID": 191, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean matches(byte[] expected, byte[] actual) { if (expected.length != actual.length) { return false; } int result = 0; for (int i = 0; i < expected.length; i++) { result |= expected[i] ^ actual[i]; } return result == 0; } \nResponse:", "ground_truth": "Constant time comparison to prevent against timing attacks.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 192, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDefaultFailureUrl(String defaultFailureUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\"); this.defaultFailureUrl = defaultFailureUrl; } \nResponse:", "ground_truth": "The URL which will be used as the failure destination.\n\n@param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".", "predict": " public void setDefaultSuccessUrl(String defaultSuccessUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultSuccessUrl), () -> \"'\" + defaultSuccessUrl + \"' is not a valid redirect URL\"); this.defaultSuccessUrl = defaultSuccessUrl; } \nResp public void setDefaultExceptionUrl(String defaultExceptionUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultExceptionUrl), () -> \"'\" + defaultExceptionUrl + \"' is not a valid redirect URL\"); this.defaultExceptionUrl = defaultExceptionUrl; } \nResp public void setDefaultFailureView(String defaultFailureView) { Assert.isTrue(ViewNames.isValidViewName(defaultFailureView), () -> \"'\" + defaultFailureView + \"' is not a valid view name\"); this.defaultFailureView = defaultFailureView; } \nResp public void setDefaultSuccessView(String defaultSuccessView) { Assert.isTrue(ViewNames.is"}, {"ID": 193, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; } \nResponse:", "ground_truth": "Sets a Function used to resolve a Map of the hidden inputs where the key is the\nname of the input and the value is the value of the input. Typically this is used\nto resolve the CSRF token.\n@param resolveHiddenInputs the function to resolve the inputs", "predict": " public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; } \n\n}\n"}, {"ID": 194, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildRequestUrl(String servletPath, String requestURI, String contextPath, String pathInfo, String queryString) { StringBuilder url = new StringBuilder(); if (servletPath != null) { url.append(servletPath); if (pathInfo != null) { url.append(pathInfo); } } else { url.append(requestURI.substring(contextPath.length())); } if (queryString != null) { url.append(\"?\").append(queryString); } return url.toString(); } \nResponse:", "ground_truth": "Obtains the web application-specific fragment of the URL.", "predict": " private static String buildResponse(String contentType, String content) { return \"HTTP/1.1 200 OK\\r\\nContent-Type: \" + contentType + \"\\r\\nContent-Length: \" + content.length() + \"\\r\\n\\r\\n\" + content; } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Servlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Serv"}, {"ID": 195, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAbsoluteUrl(String url) { if (url == null) { return false; } final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE); return ABSOLUTE_URL.matcher(url).matches(); } \nResponse:", "ground_truth": "Decides if a URL is absolute based on whether it contains a valid scheme name, as\ndefined in RFC 1738.", "predict": "\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static boolean isAbsoluteUrl(String url) {\n        if (url == null) {\n            return false;\n        }\n        final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = ABSOLUTE_URL.matcher(url);\n        return matcher.matches();\n    }\n}\n"}, {"ID": 196, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<OpenIDAttribute> createAttributeList(String identifier) { for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) { if (entry.getKey().matcher(identifier).matches()) { return entry.getValue(); } } return Collections.emptyList(); } \nResponse:", "ground_truth": "Iterates through the patterns stored in the map and returns the list of attributes\ndefined for the first match. If no match is found, returns an empty list.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OpenIDAttribute {\n    private String name;\n    private String type;\n    private String count;\n    private String value;\n    private String valueFormat;\n    private String required;\n    private String description;\n    private String issuer;\n    private String ui;\n    private String preferred;\n    private String isRequired;\n    private String isMultiValued;\n    private String isCounted;\n    private String isToken;\n    private String isUri;\n    private String isEmail;\n    private String isIP;\n    private String isDN;\n    private String isX500;\n    private String isBinary;\n    private String isPattern;\n    private String isRegularExpression;\n    "}, {"ID": 197, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; } \nResponse:", "ground_truth": "Converts the raw type from the database into the right Java type. For most applications the 'raw type' will be Long, for some applications\nit could be String.\n@param identifier The identifier from the database\n@param resultSet  Result set of the query\n@return The identifier in the appropriate target Java type. Typically Long or UUID.\n@throws SQLException", "predict": " Response(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; } \n\n*/\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.J"}, {"ID": 198, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createEntries(final MutableAcl acl) { if (acl.getEntries().isEmpty()) { return; } jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() { public int getBatchSize() { return acl.getEntries().size(); } public void setValues(PreparedStatement stmt, int i) throws SQLException { AccessControlEntry entry_ = acl.getEntries().get(i); Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\"); AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_; stmt.setLong(1, ((Long) acl.getId()).longValue()); stmt.setInt(2, i); stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true) .longValue()); stmt.setInt(4, entry.getPermission().getMask()); stmt.setBoolean(5, entry.isGranting()); stmt.setBoolean(6, entry.isAuditSuccess()); stmt.setBoolean(7, entry.isAuditFailure()); } }); } \nResponse:", "ground_truth": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl\nobject.\n\n@param acl containing the ACEs to insert", "predict": " ResponseCode.SUCCESS\n*/\n\npublic class AclImpl extends AbstractAcl<Long> implements Acl {\n\n    private static final long serialVersionUID = -8283798430740551837L;\n\n    public AclImpl(Long id) {\n        super(id);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries) {\n        super(id, entries);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries, List<Sid> sids) {\n        super(id, entries, sids);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries, List<Sid> sids, boolean isAuditSuccess, boolean isAuditFailure) {\n        super(id, entries, sids, isAuditSuccess, isAuditFailure);\n    }\n\n    public AclImpl(Long id,"}, {"ID": 199, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createObjectIdentity(ObjectIdentity object, Sid owner) { Long sidId = createOrRetrieveSidPrimaryKey(owner, true); Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass()); jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId, Boolean.TRUE); } \nResponse:", "ground_truth": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity.\nThe Sid is also necessary, as acl_object_identity has defined the sid column as\nnon-null.\n\n@param object to represent an acl_object_identity for\n@param owner for the SID column (will be created if there is no acl_sid entry for\nthis particular Sid already)", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 200, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void updateObjectIdentity(MutableAcl acl) { Long parentId = null; if (acl.getParentAcl() != null) { Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl() .getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\"); ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl() .getObjectIdentity(); parentId = retrieveObjectIdentityPrimaryKey(oii); } Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\"); Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true); int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId()); if (count != 1) { throw new NotFoundException(\"Unable to locate ACL to update\"); } } \nResponse:", "ground_truth": "Updates an existing acl_object_identity row, with new information presented in the\npassed MutableAcl object. Also will create an acl_sid entry if needed for the Sid\nthat owns the MutableAcl.\n\n@param acl to modify (a row must already exist in acl_object_identity)\n\n@throws NotFoundException if the ACL could not be found to update.", "predict": " ResponseEntity<Object> updateObjectIdentity(@PathVariable(\"id\") Long id, @RequestBody MutableAcl mutableAcl) { return new ResponseEntity<Object>(updateObjectIdentity(mutableAcl), HttpStatus.OK); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\npublic void deleteObjectIdentity(@PathVariable(\"id\") Long id) { jdbcOperations.update(\"delete from acl_object_identity where id = ?\", id); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\npublic MutableAcl readObjectIdentity(@PathVariable(\"id\") Long id) { return readObjectIdentity(id, false); }\n\n@RequestMapping(value = \"/{id}"}, {"ID": 201, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (requestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); if (createSessionAllowed || request.getSession(false) != null) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request.getSession().setAttribute(this.sessionAttrName, savedRequest); logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest); } } else { logger.debug(\"Request not saved as configured RequestMatcher did not match\"); } } \nResponse:", "ground_truth": "Stores the current request, provided the configuration properties allow it.", "predict": "\n\n*/\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Date;\n\npublic class DefaultSavedRequest {\n\n    private final HttpServletRequest request;\n    private final HttpServletResponse response;\n    private final RequestMatcher requestMatcher;\n    private final PortResolver portResolver;\n    private final String requestCacheKey;\n    private final String requestCachePrefix;\n    private final String sessionAttrName;\n    private final boolean createSessionAllowed;\n\n    public DefaultSavedRequest(HttpServletRequest request, PortResolver portResolver, RequestMatcher requestMatcher, String requestCacheKey, String requestCachePrefix, String sessionAttr"}, {"ID": 202, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); } \nResponse:", "ground_truth": "Creates a matcher that matches on the specific method and any of the provided patterns.\n@param method the method to match on. If null, any method will be matched\n@param patterns the patterns to match on\n@return the matcher to use", "predict": " public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); } \nResp public static ServerWebExchangeMatcher pathMatchers(String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern)); } return new OrServerWebExchangeMatcher(matchers); } \nResp public static ServerWebExchangeMatcher pathMatchers(String pattern, HttpMethod method) { return new PathPatternParserServerWebExchangeMatcher(pattern, method); } \nResp"}, {"ID": 203, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; } \nResponse:", "ground_truth": "Matches any exchange\n@return the matcher to use", "predict": "\n\npublic static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; }\n\n*/\n\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static java.util.stream.Collectors.toMap;\n\npublic class ServerWebExchangeMatcher {\n\n    public static <T> ServerWebExchangeMatcher anyExchange() {\n        return new ServerWebExchangeMatcher();\n    }\n\n    "}, {"ID": 204, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"stronger\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#stronger(CharSequence, CharSequence)", "predict": "\n\npublic static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        String[] input = {\n                \"abc\",\n                \"abcdefghijklmnopqrstuvwxyz\",\n                \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",\n                \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:',./<>"}, {"ID": 205, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"standard\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#standard(CharSequence, CharSequence)", "predict": "\n\npublic static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Base64.DecodingException;\nimport java.util.Base64.EncodingException;\nimport java.util.Base64.UnsupportedEncodingException;\n\npublic class HexEncodingTextEncryptor {\n    private static final Encoder encoder = Base64.getEncoder();\n    private static final Decoder decoder = Base64.getDecoder();\n\n    public static String standard(CharSequence password, CharSequence salt) {\n        byte[] passwordBytes = password.toString().getBytes();\n        byte[] saltBytes = salt.toString()."}, {"ID": 206, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt)); } \nResponse:", "ground_truth": "Creates an encryptor for queryable text strings that uses standard password-based\nencryption. Uses a 16-byte all-zero initialization vector so encrypting the same\ndata results in the same encryption result. This is done to allow encrypted data to\nbe queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the\nsecret key", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Base64.DecodingException;\nimport java.util.Base64.EncodingException;\nimport java.util.Base64.UnsupportedEncodingException;\n\npublic class HexEncodingTextEncryptor implements TextEncryptor {\n    private final Encoder encoder = Base64.getEncoder();\n    private final Decoder decoder = Base64.getDecoder();\n\n    public HexEncodingTextEncryptor(byte[] key) {\n        this.key = key;\n    }\n\n    public String encrypt(String plaintext) {\n        try {\n            return encoder.encodeToString(encrypt(plaintext.getBytes(\"UTF-8\")));\n        } catch (UnsupportedEncodingException e) {\n"}, {"ID": 207, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeHeaders(HttpServletRequest request, HttpServletResponse response) { if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) { String allowFromValue = this.allowFromStrategy.getAllowFromValue(request); if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode()); } } else if (allowFromValue != null) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFromValue); } } } else { response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode()); } } \nResponse:", "ground_truth": "Writes the X-Frame-Options header value, overwritting any previous value.\n\n@param request the servlet request\n@param response the servlet response", "predict": "\n\npublic void writeHeaders(HttpServletRequest request, HttpServletResponse response) {\n\tif (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) {\n\t\tString allowFromValue = this.allowFromStrategy.getAllowFromValue(request);\n\t\tif (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) {\n\t\t\tif (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {\n\t\t\t\tresponse.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode());\n\t\t\t}\n\t\t} else if (allowFromValue != null) {\n\t\t\tif (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {\n\t\t\t\tresponse.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFrom"}, {"ID": 208, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc\n\n@since 5.2", "predict": " ResponseEntity<String> determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations"}, {"ID": 209, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available String targetUrl = null; if (targetUrlParameter != null) { targetUrl = request.getParameter(targetUrlParameter); if (StringUtils.hasText(targetUrl)) { logger.debug(\"Found targetUrlParameter in request: \" + targetUrl); return targetUrl; } } if (useReferer && !StringUtils.hasLength(targetUrl)) { targetUrl = request.getHeader(\"Referer\"); logger.debug(\"Using Referer header: \" + targetUrl); } if (!StringUtils.hasText(targetUrl)) { targetUrl = defaultTargetUrl; logger.debug(\"Using default Url: \" + targetUrl); } return targetUrl; } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc.", "predict": " Generate the method-level comment for the following java Code. Code: protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available ModelAndView modelAndView = null; if (targetUrlParameter != null) { modelAndView = new ModelAndView(new RedirectView(determineTargetUrl(request, response))); } else { modelAndView = new ModelAndView(new RedirectView(determineTargetUrl(request, response))); } if (useReferer && !StringUtils.hasLength(modelAndView.getViewName())) { modelAndView.addObject(\"referer\", request.getHeader(\"Referer\")); } return modelAndView; } \nResp Generate the method-level comment for the following java Code. Code: protected ModelAndView handleRequestInternal(HttpServ"}, {"ID": 210, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResponse:", "ground_truth": "If this property is set, the current request will be checked for this a parameter\nwith this name and the value used as the target URL if present.\n\n@param targetUrlParameter the name of the parameter containing the encoded target\nURL. Defaults to null.", "predict": " ResponseEntity<String> getTargetUrlParameter(@PathVariable(\"id\") String id) { return new ResponseEntity<String>(this.targetUrlParameter, HttpStatus.OK); } \n\nMethod: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResp ResponseEntity<String> getTargetUrlParameter(@PathVariable(\"id\") String id) { return new ResponseEntity<String>(this.targetUrlParameter, HttpStatus.OK); } \n\nMethod: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResp ResponseEntity<String> getTargetUrlParameter(@PathVariable(\""}, {"ID": 211, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Directory getDirectoryWithImmediateParentPopulated(final Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory); FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\"))); return directory; } }); } \nResponse:", "ground_truth": "Executes recursive SQL as needed to build a full Directory hierarchy of objects", "predict": "\n\n@RequestMapping(value = \"/api/v1/directories/{id}\", method = RequestMethod.GET)\n@ResponseBody\npublic Directory getDirectoryWithImmediateParentPopulated(@PathVariable(\"id\") Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory);"}, {"ID": 212, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DistinguishedName buildDn(String username) { DistinguishedName dn = new DistinguishedName(userDnBase); dn.add(usernameAttribute, username); return dn; } \nResponse:", "ground_truth": "Assembles the Distinguished Name that should be used the given username.", "predict": " Response is generated by the method buildDn(String username)\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons.lang3.tuple."}, {"ID": 213, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<Class<? extends Object>, Object> createSharedObjects() { Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>(); sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects()); sharedObjects.put(UserDetailsService.class, userDetailsService()); sharedObjects.put(ApplicationContext.class, context); sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy); sharedObjects.put(AuthenticationTrustResolver.class, trustResolver); return sharedObjects; } \nResponse:", "ground_truth": "Creates the shared objects\n\n@return the shared Objects", "predict": " ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest) { return authenticationService.authenticate(authenticationRequest); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error) { return authenticationService.authenticate(authenticationRequest, error); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error, @RequestParam(required = false) String logout) { return authenticationService.authenticate(authenticationRequest, error, logout); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error, @RequestParam(required = false) String logout, @RequestParam(required = false) String rememberMe) { return authenticationService.authenticate(authenticationRequest, error, logout, rememberMe); } \nResp ResponseEntity<Object"}, {"ID": 214, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void configureJaasUsingLoop() throws IOException { String loginConfigUrl = convertLoginConfigToUrl(); boolean alreadySet = false; int n = 1; final String prefix = \"login.config.url.\"; String existing; while ((existing = Security.getProperty(prefix + n)) != null) { alreadySet = existing.equals(loginConfigUrl); if (alreadySet) { break; } n++; } if (!alreadySet) { String key = prefix + n; log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl); Security.setProperty(key, loginConfigUrl); } } \nResponse:", "ground_truth": "Loops through the login.config.url.1,login.config.url.2 properties looking for the\nlogin configuration. If it is not set, it will be set to the last available\nlogin.config.url.X property.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.Properties;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.NameCallback;\nimport javax.security.auth.callback.PasswordCallback;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.login.Configuration;\nimport javax.security.auth.login.LoginContext;\nimport javax.security.auth.login.LoginException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class LoginServlet extends HttpServlet {\n\n"}, {"ID": 215, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getCurrentDate() { long now = System.currentTimeMillis(); if ((now - currentDateGenerated) > 1000) { synchronized (format) { if ((now - currentDateGenerated) > 1000) { currentDateGenerated = now; currentDate = format.format(new Date(now)); } } } return currentDate; } \nResponse:", "ground_truth": "Gets the current date in HTTP format.\n\n@return Current date in HTTP format", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.text.SimpleDateFormat;\n\npublic class DateTime {\n\tpublic static void main(String[] args) {\n\t\tDate now = new Date();\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tString currentDate = format.format(now);\n\t\tSystem.out.println(currentDate);\n\t}\n}\n"}, {"ID": 216, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Long internalParseDate(String value, DateFormat[] formats) { Date date = null; for (int i = 0; (date == null) && (i < formats.length); i++) { try { date = formats[i].parse(value); } catch (ParseException ignored) { } } if (date == null) { return null; } return new Long(date.getTime()); } \nResponse:", "ground_truth": "Parses date with given formatters.\n\n@param value The string to parse\n@param formats Array of formats to use\n\n@return Parsed date (or null if no formatter mached)", "predict": " Response is generated based on the above java code.\n*/\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DateParser {\n    public static Long internalParseDate(String value, DateFormat[] formats) {\n        Date date = null;\n        for (int i = 0; (date == null) && (i < formats.length); i++) {\n            try {\n                date = formats[i].parse(value);\n            } catch (ParseException ignored) {\n            }\n        }\n        if (date == null) {\n            return null;\n        }\n        return new Long(date.getTime());\n    }\n\n    public static Map<String, Object> parseDate(String value, DateFormat[] formats) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"date\", internalParseDate(value,"}, {"ID": 217, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static void updateCache(HashMap cache, Object key, Object value) { if (value == null) { return; } if (cache.size() > 1000) { cache.clear(); } cache.put(key, value); } \nResponse:", "ground_truth": "Updates cache.\n\n@param cache Cache to be updated\n@param key Key to be updated\n@param value New value", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test();\n    }\n\n    public void test() {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n        map.put(\"c\", 3);\n        map.put(\"d\", 4);\n        map.put(\"e\", 5);\n        map.put(\"f\", 6);\n        map.put(\"g\", 7);\n        map.put(\"h\", 8);\n        map.put(\"i\", 9);\n        map.put(\"j\", 10);\n        map.put(\"k\", 11);\n        map.put(\"l\", 12);\n"}, {"ID": 218, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } \nResponse:", "ground_truth": "Provided so that subclasses may configure what is put into the authentication\nrequest's details property.\n\n@param request that an authentication request is being created for\n@param authRequest the authentication request object that should have its details\nset", "predict": " ResponseEntity<UserDetails> userDetails(UsernamePasswordAuthenticationToken authRequest) { return userDetailsService.loadUserByUsername(authRequest.getName()); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n@RestController\npublic class UserController {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @RequestMapping(value = \"/user\", method = RequestMethod.GET)\n    public UserDetails userDetails() {\n        Authentication authentication = Security"}, {"ID": 219, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSecurityName(final Subject subject) { if (logger.isDebugEnabled()) { logger.debug(\"Determining Websphere security name for subject \" + subject); } String userSecurityName = null; if (subject != null) { // SEC-803 Object credential = subject.getPublicCredentials(getWSCredentialClass()) .iterator().next(); if (credential != null) { userSecurityName = (String) invokeMethod(getSecurityNameMethod(), credential); } } if (logger.isDebugEnabled()) { logger.debug(\"Websphere security name is \" + userSecurityName + \" for subject \" + subject); } return userSecurityName; } \nResponse:", "ground_truth": "Get the security name for the given subject.\n\n@param subject The subject for which to retrieve the security name\n@return String the security name for the given subject", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.NameCallback;\nimport javax.security.auth.callback.PasswordCallback;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.login.LoginContext;\nimport javax.security.auth.login.LoginException;\nimport javax.security.auth.spi.LoginModule;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\npublic class WSSubjectLoginModule implements LoginModule {\n\n    private static final Log log = LogFactory.getLog(WSS"}, {"ID": 220, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception e) { logger.error(\"Exception occured while looking up groups for user\", e); throw new RuntimeException( \"Exception occured while looking up groups for user\", e); } finally { try { if (ic != null) { ic.close(); } } catch (NamingException e) { logger.debug(\"Exception occured while closing context\", e); } } } \nResponse:", "ground_truth": "Get the WebSphere group names for the given security name.\n\n@param securityName The security name for which to retrieve the WebSphere group\nnames\n@return the WebSphere group names for the given security name", "predict": "\n\n@SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception"}, {"ID": 221, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void changePassword(final String oldPassword, final String newPassword) { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); Assert.notNull( authentication, \"No authentication object found in security context. Can't change current user's password!\"); String username = authentication.getName(); logger.debug(\"Changing password for user '\" + username); DistinguishedName userDn = usernameMapper.buildDn(username); if (usePasswordModifyExtensionOperation) { changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword); } else { changePasswordUsingAttributeModification(userDn, oldPassword, newPassword); } } \nResponse:", "ground_truth": "Changes the password for the current user. The username is obtained from the\nsecurity context.\n\nThere are two supported strategies for modifying the user's password depending on\nthe capabilities of the corresponding LDAP server.\n\n\nConfigured one way, this method will modify the user's password via the\n\nLDAP Password Modify Extended Operation\n.\n\nSee {@link LdapUserDetailsManager#setUsePasswordModifyExtensionOperation(boolean)} for details.\n\n\nBy default, though, if the old password is supplied, the update will be made by rebinding as the user,\nthus modifying the password using the user's permissions. If\noldPassword is null, the update will be attempted using a standard\nread/write context supplied by the context source.\n\n\n@param oldPassword the old password\n@param newPassword the new value of the password.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport com.google.common.base.Strings;\n\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\n@Service\npublic class PasswordChangeService implements UserDetailsService {\n\n\t@Autowired\n\tprivate PasswordChangeServiceImpl passwordChangeServiceImpl;\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws Username"}, {"ID": 222, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DistinguishedName buildGroupDn(String group) { DistinguishedName dn = new DistinguishedName(groupSearchBase); dn.add(groupRoleAttributeName, group.toLowerCase()); return dn; } \nResponse:", "ground_truth": "Creates a DN from a group name.\n\n@param group the name of the group\n@return the DN of the corresponding group, including the groupSearchBase", "predict": " Response.ok()\n\n*/\n\npackage com.ibm.ws.security.wim.scim20.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\n\n@JsonInclude(Include.NON_NULL)\npublic class Group {\n\n    private String id;\n    private String displayName;\n    private String name;\n    private String type;\n    private List<String> members = new ArrayList<String>();\n    private List<String> schemas = new ArrayList<String>();\n\n    public Group() {\n    }\n\n    public Group(String id, String displayName, String name, String type, List<String> members, List<String> schemas) {\n        this.id = id;"}, {"ID": 223, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\")); } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null; for (SessionInformation session : sessions) { if ((leastRecentlyUsed == null) || session.getLastRequest() .before(leastRecentlyUsed.getLastRequest())) { leastRecentlyUsed = session; } } leastRecentlyUsed.expireNow(); } \nResponse:", "ground_truth": "Allows subclasses to customise behaviour when too many sessions are detected.\n\n@param sessions either null or all unexpired sessions associated with\nthe principal\n@param allowableSessions the number of concurrent sessions the user is allowed to\nhave\n@param registry an instance of the SessionRegistry for subclass use", "predict": "\n\n*/\n\npublic class ConcurrentSessionControlAuthenticationStrategy extends AbstractSessionControlAuthenticationStrategy {\n\n    private static final Log log = LogFactory.getLog(ConcurrentSessionControlAuthenticationStrategy.class);\n\n    private int allowableSessions = -1;\n    private boolean exceptionIfMaximumExceeded = false;\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions) {\n        this.allowableSessions = allowableSessions;\n    }\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions, boolean exceptionIfMaximumExceeded) {\n        this.allowableSessions = allowableSessions;\n        this.exceptionIfMaximumExceeded = exceptionIfMaximumExceeded;\n    }\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions, boolean exceptionIfMaximumExceeded, String message) {\n        this.allowableSessions = allowableSessions;\n        this.exception"}, {"ID": 224, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void copyDetails(Authentication source, Authentication dest) { if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) { AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest; token.setDetails(source.getDetails()); } } \nResponse:", "ground_truth": "Copies the authentication details from a source Authentication object to a\ndestination one, provided the latter does not already have one set.\n\n@param source source authentication\n@param dest the destination authentication object", "predict": " ResponseEntity<Authentication> authenticationDetails(Authentication authentication) { return new ResponseEntity<Authentication>(authentication, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status) { return new ResponseEntity<Authentication>(authentication, status); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers) { return new ResponseEntity<Authentication>(authentication, status, headers, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers, HttpHeaders responseHeaders) { return new ResponseEntity<Authentication>(authentication, status, responseHeaders, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers, H"}, {"ID": 225, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Filter> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; } \nResponse:", "ground_truth": "Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain", "predict": " ResponseEntity<List<Filter>> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;"}, {"ID": 226, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Filter> getFilters(String url) { return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest()))); } \nResponse:", "ground_truth": "Convenience method, mainly for testing.\n\n@param url the URL\n@return matching filter list", "predict": " public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation.getRequest()); } \nResp public List<Filter> getFilters(Request request) { return getFilters(request.getRequestURI()); } \nResp public List<Filter> getFilters(String url) { return getFilters(new FilterInvocation(url, \"GET\") .getRequest()); } \nResp public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation.getRequest()); } \nResp public List<Filter> getFilters(Request request) { return getFilters(request.getRequestURI()); } \nResp public List<Filter> getFilters(String url) { return getFilters(new FilterInvocation(url, \"GET\") .getRequest()); } \nResp public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation"}, {"ID": 227, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ApplicationContext getContext(PageContext pageContext) { ServletContext servletContext = pageContext.getServletContext(); return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext); } \nResponse:", "ground_truth": "Allows test cases to override where application context obtained from.\n\n@param pageContext so the ServletContext can be accessed as required\nby Spring's WebApplicationContextUtils\n\n@return the Spring application context (never null)", "predict": " Response getContext(PageContext pageContext) { return SecurityWebApplicationContextUtils.getContext(pageContext).getResponse(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport"}, {"ID": 228, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException { DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace()); if (dn.contains(baseDn)) { return dn; } baseDn.append(dn); return baseDn; } \nResponse:", "ground_truth": "Gets the full dn of a name by prepending the name of the context it is relative to.\nIf the name already contains the base name, it is returned unaltered.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.ModificationItem;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.apache.log4j.Logger;\n\npublic class LdapUtils {\n\tprivate static final Logger LOGGER = Logger.getLogger(LdapUtils.class);\n\n\tpublic static DistinguishedName getFullDn(DistinguishedName dn,\n\t\t\tDirContext baseCtx) throws NamingException {\n\t\tDistinguishedName baseDn = new DistinguishedName(baseCtx"}, {"ID": 229, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) { notNull(sessionAttributes, \"sessionAttributes\"); parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes); return this; } \nResponse:", "ground_truth": "Set session attributes.\n\n@param sessionAttributes the session attributes", "predict": " ResponseEntity<Object> response(HttpStatus status) { return response(status, null); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body) { notNull(status, \"status\"); notNull(body, \"body\"); return new ResponseEntity<Object>(body, new HttpHeaders(), status); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body, HttpHeaders headers) { notNull(status, \"status\"); notNull(body, \"body\"); notNull(headers, \"headers\"); return new ResponseEntity<Object>(body, headers, status); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body, HttpHeaders headers, HttpStatus status2) { notNull(status, \"status\"); notNull(body, \"body\"); notNull(headers, \"headers\"); notNull(status2, \"status2\"); return new ResponseEntity<Object>(body, headers, status2); }"}, {"ID": 230, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AuthenticationScheme basic(String userName, String password) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme(); preemptiveBasicAuthScheme.setUserName(userName); preemptiveBasicAuthScheme.setPassword(password); return preemptiveBasicAuthScheme; } \nResponse:", "ground_truth": "", "predict": "\n\npublic class AuthenticationScheme {\n    private String userName;\n    private String password;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AuthenticationScheme {\n    private String userName;\n    private String password;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password"}, {"ID": 231, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(List<Filter> filters) { Validate.notNull(filters, \"Filter list cannot be null\"); RestAssured.filters.addAll(filters); } \nResponse:", "ground_truth": "Add default filters that will be applied to each request.\n\n@param filters The filter list", "predict": " Response with the following java Code. Code: public static Response filters(List<Filter> filters) { return RestAssured.filters(filters); } \n\n*/\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.jayway.restassured.RestAssured;\nimport com.jayway.restassured.filter.Filter;\nimport com.jayway.restassured.filter.FilterContext;\nimport com.jayway.restassured.filter.log.RequestLoggingFilter;\nimport com.jayway.restassured.response.Response;\nimport com.jayway.restassured.specification.FilterableRequestSpecification;\nimport com.jayway.restassured.specification.FilterableResponseSpecification;\n\npublic class FilterTest {\n\n"}, {"ID": 232, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(Filter filter, Filter... additionalFilters) { Validate.notNull(filter, \"Filter cannot be null\"); RestAssured.filters.add(filter); if (additionalFilters != null) { Collections.addAll(RestAssured.filters, additionalFilters); } } \nResponse:", "ground_truth": "Add default filters to apply to each request.\n\n@param filter            The filter to add\n@param additionalFilters An optional array of additional filters to add", "predict": " Response response = RestAssured.given().filter(filter).filter(additionalFilters).when().get(\"/filters\"); \n\n*/\npackage com.jayway.restassured.filter.log;\n\nimport com.jayway.restassured.filter.Filter;\nimport com.jayway.restassured.internal.filter.FilterChainImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextBuilder;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplBuilder;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplBuilderImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl."}, {"ID": 233, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme basic(String userName, String password) { final BasicAuthScheme scheme = new BasicAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); return scheme; } \nResponse:", "ground_truth": "", "predict": " Response { return Response.ok().header(\"WWW-Authenticate\", \"Basic\").build(); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class BasicAuthScheme implements AuthenticationScheme {\n\n\tprivate static final long serialVersionUID = -8285555555555555555L;\n\n\tprivate String userName;\n\tprivate String password;\n\n\tpublic BasicAuthScheme() {\n\t}\n\n\tpublic BasicAuthScheme(String userName, String password) {\n\t\tthis.userName = userName;\n\t\tthis.password"}, {"ID": 234, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) { final NTLMAuthScheme scheme = new NTLMAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setWorkstation(workstation); scheme.setDomain(domain); return scheme; } \nResponse:", "ground_truth": "Create a NTLM authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@param workstation The NTLM workstation.\n@param domain The NTLM workstation.\n@return The authentication scheme", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class NTLMAuthScheme extends AuthenticationScheme {\n\n\tprivate static final long serialVersionUID = -8285555555555555555L;\n\n\tprivate String userName;\n\tprivate String password;\n\tprivate String workstation;\n\tprivate String domain;\n\n\tpublic NTLMAuthScheme() {\n\t\tsuper();\n\t}\n\n\tpublic NTLMAuthScheme(String userName, String password, String workstation, String domain) {\n\t\tsuper();\n\t\t"}, {"ID": 235, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; } \nResponse:", "ground_truth": "Use form authentication with the supplied configuration.\n\n@param userName The user name.\n@param password The password.\n@param config   The form authentication config\n@return The authentication scheme", "predict": " public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; } \n\n*/\n\npublic class FormAuthScheme extends AuthenticationScheme {\n\t\n\tprivate String userName;\n\tprivate String password;\n\tprivate FormAuthConfig config;\n\t\n\tpublic FormAuthScheme() {\n\t\tsuper();\n\t}\n\t\n\tpublic FormAuthScheme(String userName, String password, FormAuthConfig config) {\n\t\tsuper();\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.config = config;\n\t}"}, {"ID": 236, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void proxy(URI uri) { if (uri == null) { throw new IllegalArgumentException(\"Proxy URI cannot be null\"); } proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme())); } \nResponse:", "ground_truth": "Instruct REST Assured to connect to a proxy using a URI.\n\n@param uri The URI of the proxy", "predict": " Response.ok().build();\n\n*/\n\npackage com.google.code.magja.model.product;\n\nimport java.util.Date;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport com.google.code.magja.model.BaseMagentoModel;\n\n/**\n * @author andre\n *\n */\n@XmlRootElement\npublic class ProductAttribute extends BaseMagentoModel {\n\n  private static final long serialVersionUID = -8285555555555555555L;\n\n  private String name;\n  private String value;\n  private String type;\n  private String scope;\n  private String scopeDefault;\n  private String scopeDefaultValue;\n  private String scopeDefaultText;\n  private String scopeDefaultTextValue;\n  private String scopeDefaultTextValue2;\n  private String scopeDefaultTextValue2Value;\n  private String scopeDefaultTextValue2Value2;\n  "}, {"ID": 237, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if (shouldPrettyPrint) { responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody); } else { responseBodyToAppend = responseBody.asString(); } if (logDetail == ALL && !isBlank(responseBodyToAppend)) { builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR); } builder.append(responseBodyToAppend); } String response = builder.toString(); stream.println(response); return response; } \nResponse:", "ground_truth": "Prints the response to the print stream\n\n@return A string of representing the response", "predict": " Generate the method-level comment for the following java Code. Code: public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if ("}, {"ID": 238, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredConfig redirect(RedirectConfig redirectConfig) { notNull(redirectConfig, \"Redirect config\"); return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); } \nResponse:", "ground_truth": "Set the redirect config.\n\n@param redirectConfig The {@link RedirectConfig} to set\n@return An updated RestAssuredConfiguration", "predict": " public Response response(ResponseConfig responseConfig) { notNull(responseConfig, \"Response config\"); return new Response(responseConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); } \nResp public Response response(ResponseConfig responseConfig, ResponseOptions responseOptions) { notNull(responseConfig, \"Response config\"); notNull(responseOptions, \"Response options\"); return new Response(responseConfig, responseOptions.config(HttpClientConfig.class), responseOptions.config(LogConfig.class"}, {"ID": 239, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EncoderConfig defaultQueryParameterCharset(String charset) { return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true); } \nResponse:", "ground_truth": "Specify the default charset for query parameters\n\n@param charset The charset to use.\n@return A new instance of {@link EncoderConfig}", "predict": " Response<ResponseBody> response(ResponseBody responseBody) throws IOException { return responseBody.response(); }\n\n*/\n\n// @formatter:on\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ResponseBody {\n    /**\n     * The HTTP status code to return.\n     */\n    int value() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is empty.\n     */\n    int emptyValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is null.\n     */\n    int nullValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is empty and the emptyValue is not -1.\n     */\n    int emptyEmptyValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is null and the nullValue"}, {"ID": 240, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Creates an object mapper configuration that uses the specified object mapper as default.\n\n@param defaultObjectMapperType The object mapper to use. If null then classpath scanning will be used.", "predict": " Resp public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org."}, {"ID": 241, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Specify a custom JAXB object mapper factory.\n\n@param jaxbObjectMapperFactory The object mapper factory", "predict": " Response(Status status, String message, Object entity)\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double to Double.\n */\npublic class DoubleToDoubleOperator extends GenericStackableOperatorTerm<Double>\n  implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleToDoubleOperator(Term<Double> base, Term<Double> applicant) {\n    super(base, applicant);\n  }"}, {"ID": 242, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) { notNull(logConfig, \"Log config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Log config.\n\n@param logConfig The {@link LogConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"Response body\"); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"Response body\"); notNull(responseOptions, \"Response options\"); return new Response(responseBody.getStatus(), responseBody.getHeaders"}, {"ID": 243, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) { notNull(sessionConfig, \"Session config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the session config.\n\n@param sessionConfig The {@link SessionConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 244, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) { notNull(objectMapperConfig, \"Object mapper config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the object mapper config.\n\n@param objectMapperConfig The {@link ObjectMapperConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResp public Response response(ResponseBuilder responseBuilder) { notNull(responseBuilder, \"Response builder\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseBuilder); } \nResp public Response response(Response response, ResponseBuilder responseBuilder) { notNull(response, \"Response\"); notNull(responseBuilder, \"Response builder\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig,"}, {"ID": 245, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) { notNull(jsonConfig, \"JsonConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Json config.\n\n@param jsonConfig The {@link JsonConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 246, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) { notNull(xmlConfig, \"XmlConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Xml config.\n\n@param xmlConfig The {@link XmlConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 247, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) { notNull(encoderConfig, \"EncoderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the encoder config\n\n@param encoderConfig The {@link EncoderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequest(), response.getErrorMessage(), response.getRawStatusCode(), response.getRawResponseHeaders(), response.getRawResponseBody()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); return new Response(responseBody, responseStatus); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus, ResponseHeaders responseHeaders) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); notNull(responseHeaders"}, {"ID": 248, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) { notNull(headerConfig, \"HeaderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the header config\n\n@param headerConfig The {@link HeaderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequest(), response.getErrorMessage(), response.getRawStatusCode(), response.getRawResponseHeaders(), response.getRawResponseBody()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); return new Response(responseBody, responseStatus); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus, ResponseHeaders responseHeaders) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); notNull(responseHeaders"}, {"ID": 249, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) { notNull(asyncConfig, AsyncConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the async config\n\n@param asyncConfig The {@link AsyncConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getHeaders().getContentType(), response.getHeaders().getContentLength(), response.getHeaders().getContentEncoding(), response.getHeaders().getETag(), response.getHeaders().getLastModified(), response.getHeaders().getLocation(), response.getHeaders().getDate(), response.getHeaders().getServer(), response.getHeaders().getVary(), response.getHeaders().getWWWAuthenticate(), response.getHeaders().getExpires(), response.getHeaders().getAcceptRanges(), response.getHeaders().getContentRange(), response.getHeaders().getContentMD5(), response.getHeaders().getContentType(), response.getHeaders().getContentLength(), response.getHeaders().getContentEnc"}, {"ID": 250, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) { notNull(mockMvcConfig, MockMvcConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the MockMVC config\n\n@param mockMvcConfig The {@link MockMvcConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResponseSpecification: public ResponseSpecification responseSpecification(ResponseSpecification responseSpecification) { notNull(responseSpecification, ResponseSpecification.class); return new ResponseSpecification(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseSpecification); } \nRestAssuredMockMvcConfig: public RestAssuredMockMvcConfig(LogConfig logConfig, EncoderConfig encoderConfig, DecoderConfig decoderConfig, SessionConfig sessionConfig, ObjectMapperConfig objectMapperConfig"}, {"ID": 251, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) { notNull(multiPartConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the multi-part config\n\n@param multiPartConfig The {@link MultiPartConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResponseSpecification: public ResponseSpecification responseSpecification(ResponseSpecification responseSpecification) { notNull(responseSpecification, ResponseSpecification.class); return new ResponseSpecification(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseSpecification); } \nRestAssuredMockMvcConfig: public RestAssuredMockMvcConfig(LogConfig logConfig, EncoderConfig encoderConfig, DecoderConfig decoderConfig, SessionConfig sessionConfig, ObjectMapperConfig objectMapperConfig"}, {"ID": 252, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) { notNull(paramConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the parameter config\n\n@param paramConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, ResponseBody.class); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseBody.getHeaders()); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, ResponseBody.class); notNull(responseOptions, ResponseOptions.class); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseOptions.getHeaders()); } \nResp"}, {"ID": 253, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) { notNull(matcherConfig, MatcherConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the matcher config\n\n@param matcherConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequestMethod(), response.getRequestUrl(), response.getRequestHeaders(), response.getRequestContent(), response.getRequestContentType(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response."}, {"ID": 254, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CertificateAuthSettings allowAllHostnames() { return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory); } \nResponse:", "ground_truth": "", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.Properties;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class CertificateAuthSettings {\n\t\n\tprivate static final String KEYSTORE_TYPE = \"J"}, {"ID": 255, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Specify declared namespaces that will be used when parsing XML.\n\n@param namespacesToDeclare A map containing features that will be used by the underlying {@link groovy.util.XmlSlurper}.\n@return A new instance of XmlPathConfig\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Response is generated by the following java Code. Code: public Response declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); } \n\n*/\n\npackage com.github.fge.grappa.matchers;\n\nimport com.github.fge.grappa.matchers.base.Matcher;\nimport com.github.fge.grappa.matchers.base.MatcherType;\nimport com.github.fge.grappa.parsers.BaseParser;\nimport com.github.fge.grappa.rules.Rule;\nimport com.github.fge.grappa.run.MatcherContext;\nimport com.github.fge.grappa.run.ParseRunner;\nimport"}, {"ID": 256, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) { Validate.notEmpty(prefix, \"Prefix cannot be empty\"); Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\"); Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces); updatedNamespaces.put(prefix, namespaceURI); return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Declares a namespace.\n\n@param prefix       The feature name, which is a fully-qualified URI.\n@param namespaceURI The requested value of the feature (true or false).\n@return A new XmlPathConfig instance\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": "\n\n*/\n\npackage com.github.fge.grappa.transform;\n\nimport com.github.fge.grappa.rules.Rule;\nimport com.github.fge.grappa.run.context.MatcherContext;\nimport com.github.fge.grappa.run.events.MatchFailureEvent;\nimport com.github.fge.grappa.run.events.MatchSuccessEvent;\nimport com.github.fge.grappa.run.events.RuleFailureEvent;\nimport com.github.fge.grappa.run.events.RuleSuccessEvent;\nimport com.github.fge.grappa.run.events.TestFailureEvent;\nimport com.github.fge.grappa.run.events.TestSuccessEvent;\nimport com.github.fge.grappa.run.events.TestSkippedEvent;\nimport com.github.fge.grappa.run.events.TestSkippedEvent"}, {"ID": 257, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); } \nResponse:", "ground_truth": "Make an HTTP request to the default URI, and parse using the default\ncontent-type.\n\n@param method        {@link HttpRequestFactory HTTP method}\n@param configClosure request configuration options\n@return whatever value was returned by the executed response handler.\n@throws ClientProtocolException\n@throws IOException\n@see #request(Object, HttpRequestFactory, Object, Closure)", "predict": " Response<Object> request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(uri, method, contentType, hasBody, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Map<String, Object> params, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(uri, method, contentType, hasBody, params, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Map<String, Object> params"}, {"ID": 258, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setHeaders(Map<?, ?> headers) { this.defaultRequestHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultRequestHeaders.put(key.toString(), val.toString()); } } \nResponse:", "ground_truth": "Set the default headers to add to all requests made by this builder\ninstance.  These values will replace any previously set default headers.\n\n@param headers map of header names & values.", "predict": " public void setHeaders(Map<?, ?> headers) { this.defaultResponseHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultResponseHeaders.put(key.toString(), val.toString()); } } \n\n*/\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport"}, {"ID": 259, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); } \nResponse:", "ground_truth": "null for the default\n@see HttpHost#HttpHost(String, int, String)", "predict": " public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); } \n\n*/\n\npublic class ProxyTest {\n    public static void main(String[] args) {\n        try {\n            // Create a new instance of HttpClient.\n            HttpClient httpclient = new HttpClient();\n\n            // Create a method instance.\n            HttpGet httpget = new HttpGet(\"http://www.google.com/\");\n\n            // Add the Proxy to the execution context.\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, new HttpHost(\"myproxy.com\", 8080));\n\n            // Execute the method.\n            HttpResponse response = httpclient.execute(httpget);\n\n            // Examine the response status.\n            System.out.println(\"Response status"}, {"ID": 260, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder controlName(String controlName) { Validate.notEmpty(controlName, \"Control name cannot be empty\"); this.controlName = controlName; this.isControlNameExplicit = true; return this; } \nResponse:", "ground_truth": "Specify the control name of this multi-part.\n\n@param controlName The control name to use. Default is file.\n@return An instance of MultiPartSpecBuilder", "predict": " Response { return new Response(this); } \n\n*/\n\npublic class MultiPartSpecBuilder {\n\tprivate String controlName;\n\tprivate boolean isControlNameExplicit;\n\t\n\tpublic MultiPartSpecBuilder controlName(String controlName) {\n\t\tthis.controlName = controlName;\n\t\tthis.isControlNameExplicit = true;\n\t\treturn this;\n\t}\n\t\n\tpublic MultiPartSpecBuilder isControlNameExplicit(boolean isControlNameExplicit) {\n\t\tthis.isControlNameExplicit = isControlNameExplicit;\n\t\treturn this;\n\t}\n\t\n\tpublic MultiPartSpec build() {\n\t\treturn new MultiPartSpec(this);\n\t}\n}\n"}, {"ID": 261, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder header(String name, String value) { Validate.notEmpty(name, \"Header name cannot be empty\"); Validate.notEmpty(value, \"Header value cannot be empty\"); // Replace previous header if exists final Set<String> headerNames = headers.keySet(); final String trimmedName = name.trim(); for (String headerName : headerNames) { if (headerName.equalsIgnoreCase(trimmedName)) { headers.remove(headerName); } } // Put the name header in the header list headers.put(name, value); return this; } \nResponse:", "ground_truth": "Add a header to this multipart specification.\n\n@param name The name of the header\n@param value The value of the header\n@return An instance of MultiPartSpecBuilder", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MultiPartSpecBuilder {\n    private Map<String, String> headers = new HashMap<>();\n\n    public MultiPartSpecBuilder header(String name, String value) {\n        headers.put(name, value);\n        return this;\n    }\n\n    public MultiPartSpecBuilder contentType(String contentType) {\n        headers.put(\"Content-Type\", contentType);\n        return this;\n    }\n\n    public MultiPartSpecBuilder file(String fileName, byte[] fileData) {\n        headers.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n        headers.put(\"Content-Type\", \"application/octet-stream\");\n        headers.put(\"Content-Length\", \"\" + fileData.length);\n        return this;\n    }\n\n    public MultiPartSpecBuilder file(String fileName"}, {"ID": 262, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void basic(String host, int port, String user, String pass) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new UsernamePasswordCredentials(user, pass) ); } \nResponse:", "ground_truth": "Set authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass", "predict": "\n\npublic void basic(String host, int port, String user, String pass) {\n        try {\n            builder.getClient().getCredentialsProvider().setCredentials(new AuthScope(host, port), new UsernamePasswordCredentials(user, pass));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org."}, {"ID": 263, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void ntlm(String host, int port, String user, String pass, String workstation, String domain) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain) ); } \nResponse:", "ground_truth": "Set NTLM authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass\n@param workstation\n@param domain", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class NTLM {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://www.google.com\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Authorization\", \"NTLM TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACgAOAAACAAAABQAADQAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}, {"ID": 264, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Headers headers(Header header, Header... additionalHeaders) { notNull(header, \"Header\"); final List<Header> headerList = new LinkedList<Header>(); headerList.add(header); if (additionalHeaders != null) { Collections.addAll(headerList, additionalHeaders); } return new Headers(headerList); } \nResponse:", "ground_truth": "An alternative way to create a Headers object from the constructor.\n\n@param header            The header to be included\n@param additionalHeaders Additional headers to be included (optional)\n@return A new headers object containing the specified headers", "predict": " public static ResponseBuilder response(Response response) { notNull(response, \"Response\"); return new ResponseBuilder(response); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status) { notNull(status, \"Status\"); return new ResponseBuilder(status); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message) { notNull(status, \"Status\"); notNull(message, \"Message\"); return new ResponseBuilder(status, message); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message, Object... args) { notNull(status, \"Status\"); notNull(message, \"Message\"); notNull(args, \"Arguments\"); return new ResponseBuilder(status, message, args); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message, Throwable cause) { notNull(status, \"Status\"); notNull(message, \"Message\"); notNull(cause, \"Cause\"); return new"}, {"ID": 265, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; } \nResponse:", "ground_truth": "Reset all static configurations to their default values.", "predict": "\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null"}, {"ID": 266, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; } \nResponse:", "ground_truth": "Set a specific header\n\n@return The builder", "predict": " ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; } \nResp ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name)."}, {"ID": 267, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; } \nResponse:", "ground_truth": "Build the actual response\n\n@return The response object", "predict": " public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; } \n\n}\n"}, {"ID": 268, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher))); } \nResponse:", "ground_truth": "Verifies whether value of cookie satisfies specified matcher.\n@param valueMatcher value assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed value property assertion", "predict": " public DetailedCookieMatcher value(String value) { return value(equalTo(value)); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"value\", equalTo(\"value\")).matches(new Cookie(\"name\", \"value\")),\n                MatcherAssert.isTrue());\n    }\n}\n"}, {"ID": 269, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); } \nResponse:", "ground_truth": "Verifies whether comment of cookie satisfies specified matcher.\n@param commentMatcher comment assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed comment property assertion", "predict": " public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); } \n\n*/\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.regex.PatternSyntaxException;\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n    private Matcher<String> commentMatcher;\n\n    public DetailedCookieMatcher(Matcher<String> commentMatcher) {\n        super(\"\");\n        this.commentMatcher = commentMatcher;\n    }\n\n    public DetailedCookieMatcher(String comment) {\n        super(\"\");\n        try {\n            this.commentMatcher = Pattern.compile(comment).matcher(\"\");\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException"}, {"ID": 270, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); } \nResponse:", "ground_truth": "Verifies whether expiry date of cookie satisfies specified matcher.\n@param expiryDateMatcher expiry date assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed expiry date property assertion", "predict": " public DetailedCookieMatcher expiryDate(DateMatcher expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\nimport java.util.Date;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(Matchers.hasProperty(\"expiryDate\", Matchers.equalTo(new Date(System.currentTimeMillis() + 10000000L))))\n                .matches(new Cookie(\"name\", \"value\", \"domain\", \"path\", new Date(System.currentTimeMillis() + 10000000L))), Matchers.is(true));"}, {"ID": 271, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher))); } \nResponse:", "ground_truth": "Verifies whether domain of cookie satisfies specified matcher.\n@param domainMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed domain property assertion", "predict": " public DetailedCookieMatcher domain(String domain) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", equalTo(domain)))); } \n\n*/\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.regex.PatternSyntaxException;\n\npublic class DetailedCookieMatcher {\n    private Matcher<String> domainMatcher;\n    private Matcher<String> pathMatcher;\n    private Matcher<String> nameMatcher;\n    private Matcher<String> valueMatcher;\n    private Matcher<String> commentMatcher;\n    private Matcher<String> commentUrlMatcher;\n    private Matcher<String> commentDomainMatcher;\n    private Matcher<String> commentPathMatcher;\n    private Matcher<String> commentNameMatcher;\n    private Matcher<String> commentValueMatcher"}, {"ID": 272, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); } \nResponse:", "ground_truth": "Verifies whether path of cookie satisfies specified matcher.\n@param pathMatcher assertion for path property\n@return A {@link DetailedCookieMatcher} instance with and-composed path property assertion", "predict": " public DetailedCookieMatcher path(String path) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", equalTo(path)))); } \n\n*/\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n\n    public DetailedCookieMatcher(Matcher<? super Cookie> matcher) {\n        super(matcher);\n    }\n\n    @Override\n    protected String getName() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getDescription() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getJavadoc() {\n        return \"Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); } \";\n    }\n}"}, {"ID": 273, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); } \nResponse:", "ground_truth": "Verifies whether secured property of cookie satisfies specified matcher.\n@param securedMatcher assertion for secured property\n@return A {@link DetailedCookieMatcher} instance with and-composed secured property assertion", "predict": " Response with the following java Code. Code: public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.hamcrest.Matcher;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class DetailedCookieMatcher {\n\t\n\tprivate final Matcher<Cookie> matcher;\n\t\n\tpublic DetailedCookieMatcher(Matcher<Cookie"}, {"ID": 274, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); } \nResponse:", "ground_truth": "", "predict": " public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); } \n\nThe method-level comment will be used for the following java Code. Code: public DetailedCookieMatcher httpOnly(boolean httpOnly) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", equalTo(httpOnly)))); } \nResp public DetailedCookieMatcher httpOnly(boolean httpOnly) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", equalTo(httpOnly)))); } \n\nThe method-level comment will be used for the following java Code. Code: public DetailedCookieMatcher httpOnly(boolean httpOnly, boolean ignoreCase) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\""}, {"ID": 275, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); } \nResponse:", "ground_truth": "Verifies whether version of cookie satisfies specified matcher.\n@param versionMatcher assertion for version property\n@return A {@link DetailedCookieMatcher} instance with and-composed version property assertion", "predict": " public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); } \n\n*/\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n\n    public DetailedCookieMatcher(Matcher<? super Cookie> cookieMatcher) {\n        super(cookieMatcher);\n    }\n\n    @Override\n    protected String getName() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getDescription() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getJavadoc() {\n        return \"Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher)));"}, {"ID": 276, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); } \nResponse:", "ground_truth": "Verifies whether max age of cookie satisfies specified matcher.\n@param maxAgeMatcher assertion for max age property\n@return A {@link DetailedCookieMatcher} instance with and-composed max age property assertion", "predict": " public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"maxAge\", Matchers.hasProperty(\"maxAge\", Matchers.equalTo(10))).matches(new Cookie(\"maxAge\", \"10\")), Matchers.is(true));\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"maxAge\", Matchers.hasProperty(\"maxAge\", Matchers.equalTo(10))).matches(new Cookie(\""}, {"ID": 277, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) { spec.header(headerName, expectedValueMatcher); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied header name and hamcrest matcher.\n\n@param headerName           The name of the expected header\n@param expectedValueMatcher The Hamcrest matcher that must conform to the value\n@return The builder", "predict": " ResponseSpecBuilder expectStatusCode(int statusCode) { spec.expectStatusCode(statusCode); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase) { spec.expectStatusCode(statusCode, reasonPhrase); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String content) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String content, String charset) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, content, charset); return this"}, {"ID": 278, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) { spec.header(headerName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied name and value.\n\n@param headerName    The name of the expected header\n@param expectedValue The value of the expected header\n@return The builder", "predict": " ResponseSpecBuilder expectStatusCode(int statusCode) { spec.expectStatusCode(statusCode); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase) { spec.expectStatusCode(statusCode, reasonPhrase); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String charset) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, charset); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, byte[] content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatus"}, {"ID": 279, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) { spec.cookie(cookieName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response cookie matches the supplied name and value.\n\n@param cookieName    The name of the expected cookie\n@param expectedValue The value of the expected cookie\n@return The builder", "predict": "\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain) {\n        spec.cookie(cookieName, expectedValue, domain);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path) {\n        spec.cookie(cookieName, expectedValue, domain, path);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path, boolean secure) {\n        spec.cookie(cookieName, expectedValue, domain, path, secure);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path, boolean secure, boolean httpOnly"}, {"ID": 280, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProxySpecification withHost(String host) { return new ProxySpecification(host, port, scheme, username, password); } \nResponse:", "ground_truth": "Specify the hostname of the proxy.\n\n@param host The hostname of the proxy.\n@return A new ProxySpecification instance", "predict": " Response withHost(String host) { return new Response(host, port, scheme, username, password); }\n\n*/\n\npublic class ProxySpecification {\n\tprivate String host;\n\tprivate int port;\n\tprivate String scheme;\n\tprivate String username;\n\tprivate String password;\n\t\n\tpublic ProxySpecification(String host, int port, String scheme, String username, String password) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.scheme = scheme;\n\t\tthis.username = username;\n\t\tthis.password = password;\n\t}\n\t\n\tpublic ProxySpecification(String host, int port, String scheme) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.scheme = scheme;\n\t}\n\t\n\tpublic ProxySpecification(String host, int port) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t}\n"}, {"ID": 281, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.\n\n@param numberReturnType The choice.\n@return A new instance of JsonPathConfig with the given configuration", "predict": "\n\n*/\n\npackage com.github.fge.jsonschema.main;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.JSONPObject;\nimport com.fasterxml.jackson.databind.util.JSONWrappedObject;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.StdTimeFormat;\nimport com.fasterxml.jackson.databind.util.StdTimestampFormat;\nimport com.github.fge.jsonschema.core.exceptions.ProcessingException;\nimport com.github."}, {"ID": 282, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig defaultParserType(JsonParserType defaultParserType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Creates an json path configuration that uses the specified parser type as default.\n\n@param defaultParserType The parser type to use. If null then classpath scanning will be used.", "predict": " Response(JsonPathConfig config) { return new Response(config); }\n\n*/\n\npackage com.github.fge.jsonschema.main;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.JSONPObject;\nimport com.fasterxml.jackson.databind.util.JSONWrappedObject;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.StdDateFormat.DateFormat;\nimport com.github.fge.jsonschema.core.exceptions.ProcessingException;\nimport com.github.fge.js"}, {"ID": 283, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig defaultStream(PrintStream printStream) { return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Specify a new default stream to the print to.\n\n@param printStream The stream\n@return A new LogConfig instance", "predict": " Response is generated by the method.\n */\npublic class LogConfig {\n    private PrintStream printStream;\n    private boolean logDetailIfValidationFails;\n    private String urlEncodeRequestUri;\n    private boolean isRequestUriEncoded;\n\n    public LogConfig(PrintStream printStream, boolean logDetailIfValidationFails, String urlEncodeRequestUri, boolean isRequestUriEncoded) {\n        this.printStream = printStream;\n        this.logDetailIfValidationFails = logDetailIfValidationFails;\n        this.urlEncodeRequestUri = urlEncodeRequestUri;\n        this.isRequestUriEncoded = isRequestUriEncoded;\n    }\n\n    public PrintStream getPrintStream() {\n        return printStream;\n    }\n\n    public boolean isLogDetailIfValidationFails() {\n        return logDetailIfValidationFails;\n    }"}, {"ID": 284, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail\n\n@param logDetail The log detail to show in the log\n@return A new LogConfig instance", "predict": " public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); } \n\n*/\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogConfig {\n    private static final Logger LOGGER = Logger.getLogger(LogConfig.class.getName());\n    private static final String LOG_CONFIG_PREFIX = \"LogConfig\";\n    private static final String LOG_CONFIG_SUFFIX = \"LogConfig\";\n    private static final String LOG_CONFIG_PREFIX_PRETTY_PRINTING = \"LogConfig (pretty printing)\";\n    private static final String LOG_CONFIG_SUFFIX_PRETTY_PRINTING = \"LogConfig (pretty printing)\";\n    private static"}, {"ID": 285, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) { String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\"); Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method); final HttpRequestBase httpRequest; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) { httpRequest = new CustomHttpMethod(method, uri); } else { try { httpRequest = type.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } httpRequest.setURI(uri); } return httpRequest; } \nResponse:", "ground_truth": "Get the HttpRequest class that represents this request type.\n\n@return a non-abstract class that implements {@link HttpRequest}", "predict": " Generate the method-level comment for the following java Code. Code: static HttpResponseBase createHttpResponse(int statusCode, String statusText, String contentType, InputStream content) { Class<? extends HttpResponseBase> type = HTTP_STATUS_CODE_TO_HTTP_RESPONSE_TYPE.get(statusCode); final HttpResponseBase httpResponse; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingResponse.class)) && content != null)) { httpResponse = new CustomHttpResponse(statusCode, statusText, contentType, content); } else { try { httpResponse = type.newInstance(); } catch (Exception e) { throw new Runtime"}, {"ID": 286, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartConfig defaultBoundary(String defaultBoundary) { return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true); } \nResponse:", "ground_truth": "Specify an explicit default multipart boundary to use when sending multi-part data.\n\n@param defaultBoundary The boundary to set\n@return An updated MultiPartConfig", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 287, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) { spec.attribute(attributeName, attributeValue); return this; } \nResponse:", "ground_truth": "Add request attribute\n\n@param attributeName  The attribute name\n@param attributeValue The attribute value\n@return The request specification builder", "predict": " Response is generated by the method-level comment. \n\n*/\n\npublic class MockMvcRequestSpecBuilder {\n\t\n\tprivate final MockMvcRequestSpecification spec;\n\t\n\tpublic MockMvcRequestSpecBuilder(MockMvcRequestSpecification spec) {\n\t\tthis.spec = spec;\n\t}\n\t\n\tpublic MockMvcRequestSpecification and() {\n\t\treturn spec;\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec) {\n\t\treturn spec.and(spec);\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec, MockMvcRequestSpecification spec2) {\n\t\treturn spec.and(spec2);\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec, MockMvcRequestSpecification spec2, MockMvcRequestSpecification spec3) {\n"}, {"ID": 288, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) { spec.header(headerName, headerValue); return this; } \nResponse:", "ground_truth": "Add a header to be sent with the request\n\n@param headerName  The header name\n@param headerValue The header value\n@return The request specification builder", "predict": " Response = new ResponseBuilder().setStatusCode(200).setBody(\"{\\\"id\\\":\\\"123\\\",\\\"name\\\":\\\"John\\\"}\").build(); \n\n*/\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.springframework"}, {"ID": 289, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) { spec.multiPart(controlName, mimeType); return this; } \nResponse:", "ground_truth": "Specify a string to send to the server using multi-part form data with a specific mime-type.\n\n@param controlName Defines the control name of the body part. In HTML this is the attribute name of the input tag.\n@param contentBody The string to send\n@param mimeType    The mime-type\n@return The request specification", "predict": " MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8)\n\n*/\n\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"ID": 290, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.resultHandlers(resultHandler, additionalResultHandlers); return this; } \nResponse:", "ground_truth": "Add a result handler\n\n@param resultHandler The result handler\n@return MockMvcRequestSpecBuilder", "predict": " public MockMvcResponseSpecBuilder addResponseHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResponseResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResponseResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, Result"}, {"ID": 291, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> HttpClientConfig setParam(String parameterName, T parameterValue) { notNull(parameterName, \"Parameter name\"); final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams); newParams.put(parameterName, parameterValue); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "            The parameter type\n@return An updated HttpClientConfig", "predict": " public <T> Response<T> get(String url, Class<T> responseType, Map<String, Object> params, Map<String, String> headers, HttpMultipartMode httpMultipartMode, boolean shouldReuseHttpClientInstance, HttpClient httpClient, boolean shouldAutoCloseHttpClient, HttpClientConfig httpClientConfig) { notNull(url, \"URL\"); notNull(responseType, \"Response type\"); notNull(params, \"Parameters\"); notNull(headers, \"Headers\"); notNull(httpMultipartMode, \"HttpMultipartMode\"); notNull(shouldReuseHttpClientInstance, \"Should reuse http client instance\"); notNull(httpClient, \"HttpClient\"); notNull(shouldAutoCloseHttpClient, \"Should auto close http client\"); notNull(httpClientConfig, \"HttpClientConfig\"); return new Response<T>(httpClient.get(url, responseType, params, headers, httpMultipartMode, shouldReuseHttpClientInstance"}, {"ID": 292, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig addParams(Map<String, ?> httpClientParams, HttpMultipartMode httpMultipartMode) { notNull(httpClientParams, \"httpClientParams\"); notNull(httpMultipartMode, \"httpMultipartMode\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams);"}, {"ID": 293, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultip"}, {"ID": 294, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); } \n\n*/\n\npublic class HttpClientConfig {\n\tprivate HttpClientFactory httpClientFactory;\n\tprivate HttpClientParams httpClientParams;\n\tprivate HttpMultipartMode httpMultipartMode;\n\tprivate boolean shouldReuseHttpClientInstance;\n\tprivate HttpClient httpClient;\n\tprivate boolean isHttpClientConfig;\n\t\n\tpublic HttpClientConfig(HttpClientFactory httpClientFactory, HttpClientParams httpClientParams, HttpMultipartMode httpMultipartMode, boolean shouldReuseHttpClientInstance, HttpClient httpClient, boolean isHttpClientConfig) {\n\t\tthis.httpClientFactory = httpClientFactory;\n\t\tthis.http"}, {"ID": 295, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T get(String path) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a boolean.\n\n@param path The Object path.\n@return The object matching the Object path. This may be any primitive type, a List or a Map.  A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " public <T> T get(String path, Map<String, Object> params) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResp public <T> T get(String path, Map<String, Object> params, Map<String, Object> headers) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params, headers); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResp public <T> T get(String path, Map<String, Object> params, Map<String, Object> headers, Map<String, Object> cookies) { final JSONAssertion jsonAssertion = create"}, {"ID": 296, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as an int.\n\n@param path The Object path.\n@return The int matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " The method-level comment is now generated. Code: public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus"}, {"ID": 297, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte getByte(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Byte) { return (Byte) value; } else if (value instanceof Long) { return ((Long) value).byteValue(); } else if (value instanceof Integer) { return ((Integer) value).byteValue(); } else { return ObjectConverter.convertObjectTo(value, Byte.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a byte.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a byte.\n\n*/\n\npublic class ByteGetter implements Getter {\n    public Object get(Object object) {\n        return ((Map) object).get(key);\n    }\n}\n"}, {"ID": 298, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a short.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a short value.\n\n*/\n\npublic class ShortGetter extends Getter {\n    public Object getValue(Object obj) {\n        Object value = get(obj);\n        if (value instanceof Short) {\n            return value;\n        } else if (value instanceof Long) {\n            return ((Long) value).shortValue();\n        } else if (value instanceof Integer) {\n            return ((Integer) value).shortValue();\n        } else {\n            return ObjectConverter.convertObjectTo(value, Short.class);\n        }\n    }\n}\n"}, {"ID": 299, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public float getFloat(String path) { final Object value = get(path); //Groovy will always return a Double for floating point values. if (value instanceof Double) { return ((Double) value).floatValue(); } else { return ObjectConverter.convertObjectTo(value, Float.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a float.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is generated by the method getFloat(String path) in the class ObjectConverter.java.\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ObjectConverter {\n    private static Map<String, Object> cache = new ConcurrentHashMap<String, Object>();\n\n    public static Object get(String path) {\n        if (cache.containsKey(path)) {\n            return cache.get(path);\n        }\n        return null;\n    }\n\n    public static void set(String path, Object value) {\n        cache.put(path, value);\n    }\n\n    public static List<Object> getList(String path) {\n        List<Object> list = new ArrayList<Object>();\n        if (cache.containsKey(path)) {\n            list.add("}, {"ID": 300, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public double getDouble(String path) { final Object value = get(path); if (value instanceof Double) { return (Double) value; } return ObjectConverter.convertObjectTo(value, Double.class); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a double.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is generated by the method.\n\n*/\n\npublic class ObjectConverter {\n\t\n\tpublic static Object convertObjectTo(Object value, Class<?> clazz) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (clazz.isAssignableFrom(value.getClass())) {\n\t\t\treturn value;\n\t\t}\n\t\tif (clazz.isAssignableFrom(String.class)) {\n\t\t\treturn value.toString();\n\t\t}\n\t\tif (clazz.isAssignableFrom(Integer.class)) {\n\t\t\treturn Integer.valueOf(value.toString());\n\t\t}\n\t\tif (clazz.isAssignableFrom(Double.class)) {\n\t\t\treturn Double.valueOf(value.toString());\n\t\t}\n\t\tif (clazz.isAssignableFrom(Float.class)) {\n\t\t\treturn Float.valueOf(value.toString());\n\t\t}"}, {"ID": 301, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a long.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a long value.\n\n*/\n\npublic class GroovyObjectConverter {\n\t\n\tpublic static Object convertObjectTo(Object value, Class<?> clazz) {\n\t\tif (clazz.equals(Long.class)) {\n\t\t\treturn (Long) value;\n\t\t} else if (clazz.equals(Short.class)) {\n\t\t\treturn (Short) value;\n\t\t} else if (clazz.equals(Integer.class)) {\n\t\t\treturn (Integer) value;\n\t\t} else if (clazz.equals(Float.class)) {\n\t\t\treturn (Float) value;\n\t\t} else if (clazz.equals(Double.class)) {\n\t\t\treturn (Double) value;\n\t\t} else if (clazz.equals(Boolean.class)) {\n\t\t\treturn (Boolean) value;\n\t\t} else if (clazz.equals(String.class)) {\n\t\t\treturn (String)"}, {"ID": 302, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> List<T> getList(String path, Class<T> genericType) { if (genericType == null) { throw new IllegalArgumentException(\"Generic type cannot be null\"); } final List<T> original = get(path); final List<T> newList = new LinkedList<T>(); if (original != null) { for (T t : original) { T e; if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) { // TODO Avoid double parsing String str = objectToString(t); //noinspection unchecked e = (T) jsonStringToObject(str, genericType); } else { e = ObjectConverter.convertObjectTo(t, genericType); } newList.add(e); } } return Collections.unmodifiableList(newList); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a list.\n\n@param path        The Object path.\n@param genericType The generic list type\n@param          The type\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " public <T> List<T> getList(String path, Class<T> genericType) { return get(path, genericType); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class ObjectConverter {\n\n    public static <T> T convertObjectTo(Object object, Class<T> genericType) {\n        if (genericType == null) {\n            throw new IllegalArgumentException(\"Generic type cannot be null\");\n        }\n        if (object == null) {\n            return null;\n        }\n        if (genericType.isAssignableFrom(object.getClass())) {\n            return (T) object;\n        }\n        if (genericType.isAssignableFrom(Map.class)) {\n            return (T) objectToMap(object);\n        }\n        if (genericType.isAssignableFrom(List.class)) {\n            return (T"}, {"ID": 303, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <K, V> Map<K, V> getMap(String path) { return get(path); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a map.\n\n@param path The Object path.\n@param   The type of the expected key\n@param   The type of the expected value\n@return The map matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 304, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); } \nResponse:", "ground_truth": "Get an XML document as a Java Object.\n\n@param objectType The type of the java object.\n@param         The type of the java object\n@return A Java object representation of the XML document", "predict": " public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); } \n\n*/\n\npublic class GetObject {\n\tpublic static void main(String[] args) {\n\t\tString path = \"\";\n\t\tString objectType = \"\";\n\t\t\n\t\tif (args.length == 2) {\n\t\t\tpath = args[0];\n\t\t\tobjectType = args[1];\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Generating the method-level comment for the following java Code.\");\n\t\tSystem.out.println(\"Code: public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); }\");\n\t\tSystem.out.println(\"Resp public <T> T getObject(String path, Class<T> object"}, {"ID": 305, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponse:", "ground_truth": "", "predict": " ResponseSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponseSpecBuilder setBody(Object object) { spec.body(object); return this; } \nResponseSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType) { spec.body(object, mimeType); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, String charset) { spec.body(object, mimeType, charset); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, Charset charset) { spec.body(object, mimeType, charset); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, String charsetName) { spec.body"}, {"ID": 306, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { spec.cookie(key, value, cookieNameValuePairs); return this; } \nResponse:", "ground_truth": "Add a cookie to be sent with the request.\n\n@param key                  The cookie key\n@param value                The cookie value\n@param cookieNameValuePairs Additional cookies values. This will actually create two cookies with the same name but with different values.\n@return The request specification builder", "predict": " public ResponseSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { return spec.response().addCookie(key, value, cookieNameValuePairs); } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode) { spec.expectStatus(statusCode); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase) { spec.expectStatus(statusCode, reasonPhrase); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase, String content) { spec.expectStatus(statusCode, reasonPhrase, content); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase, String contentType, String content) { spec.expectStatus(statusCode, reasonPhrase, contentType, content); return this; } \nResponseSpecBuilder"}, {"ID": 307, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a parameter to be sent with the request.\n\n@param parameterName   The parameter name\n@param parameterValues Zero to many parameter values for this parameter name.\n@return The request specification builder", "predict": " ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody) { spec.response(httpStatusCode, responseBody); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType) { spec.response(httpStatusCode, responseBody, contentType); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding, acceptHeader); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader, String content"}, {"ID": 308, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a multi-value parameter to be sent with the request.\n\n@param parameterName   The parameter key\n@param parameterValues The parameter values\n@return The request specification builder", "predict": " ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody) { spec.response(httpStatusCode, responseBody); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType) { spec.response(httpStatusCode, responseBody, contentType); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding, acceptHeader); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader, String content"}, {"ID": 309, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) { return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true); } \nResponse:", "ground_truth": "Set form parameter update strategy to the given value.\n\n@param updateStrategy The update strategy to use for form parameters\n@return A new instance of {@link MockMvcParamConfig}", "predict": " public MockMvcResponse response(MockMvcResult result) { return new MockMvcResponse(result); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType) { return new MockMvcResponse(result, contentType); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content) { return new MockMvcResponse(result, contentType, content); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content, String contentTypeOverride) { return new MockMvcResponse(result, contentType, content, contentTypeOverride); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content, String contentTypeOverride, String charset) { return new MockMvcResponse(result, contentType, content, contentTypeOverride, charset); } \nResp public MockM"}, {"ID": 310, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \nResponse:", "ground_truth": "Create a new logging filter without using the \"new\" operator.\nWill make the DSL look nicer.\n\n@param stream The print stream to log to\n@param matcher The matcher that must be fulfilled in order for logging to occur\n@return a new instance of the filter", "predict": "\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIf"}, {"ID": 311, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Cookies(cookieList); } \nResponse:", "ground_truth": "An alternative way to create a Cookies object from the constructor.\n\n@param cookie            The cookie to be included\n@param additionalCookies Additional cookies to be included (optional)\n@return A new cookies object containing the specified cookies", "predict": " Response cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Response(cookieList); } \n\n*/\n\npublic class Cookies {\n\tprivate List<Cookie> cookies;\n\t\n\tpublic Cookies(List<Cookie> cookies) {\n\t\tthis.cookies = cookies;\n\t}\n\t\n\tpublic Response cookies(Cookie cookie, Cookie... additionalCookies) {\n\t\tAssertParameter.notNull(cookie, \"Cookie\");\n\t\tfinal List<Cookie> cookieList = new LinkedList<Cookie>();\n\t\tcookieList.add(cookie);\n\t\tCollections.addAll(cookieList, additionalCookies);\n\t\treturn new Response(cookieList);\n\t}\n}\n"}, {"ID": 312, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) { synchronized (lock) { for (KeyAndSource keyAndSource : keysAndSources) { Multiset<Object> set = backingMap.get(keyAndSource.key); if (set != null) { set.remove(keyAndSource.source); if (set.isEmpty()) { backingMap.remove(keyAndSource.key); } } } } } \nResponse:", "ground_truth": "There may be multiple child injectors blacklisting a certain key so only remove the source\nthat's relevant.", "predict": "\n\n*/\n\npublic class Solution {\n    public void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) {\n        synchronized (lock) {\n            for (KeyAndSource keyAndSource : keysAndSources) {\n                Multiset<Object> set = backingMap.get(keyAndSource.key);\n                if (set != null) {\n                    set.remove(keyAndSource.source);\n                    if (set.isEmpty()) {\n                        backingMap.remove(keyAndSource.key);\n                    }\n                }\n            }\n        }\n    }\n}\n"}, {"ID": 313, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } } \nResponse:", "ground_truth": "Indexes bindings by type.", "predict": " void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } } \n */\n\npublic class GenerateMethodComment {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString className = \"Test\";\n\t\tString methodName = \"index\";\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"/**\\n\");\n\t\tsb.append(\" * Generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2\\n\");\n\t\tsb.append(\" * See <a href=\\\"http://java.sun.com/xml/jaxb\\\">http://java.sun.com/xml/jaxb</a>\\n\");\n\t\tsb.append(\" * Any modifications to this file will be lost upon recompilation of the source"}, {"ID": 314, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); } \nResponse:", "ground_truth": "Gets a binding implementation. First, it check to see if the parent has a binding. If the\nparent has a binding and the binding is scoped, it will use that binding. Otherwise, this\nchecks for an explicit binding. If no explicit binding is found, it looks for a just-in-time\nbinding.", "predict": " Response<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding.getResponse(errors); } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); } \n\n}\n"}, {"ID": 315, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException { // Find a constant string binding. Key<String> stringKey = key.ofType(STRING_TYPE); BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey); if (stringBinding == null || !stringBinding.isConstant()) { return null; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @SuppressWarnings(\"unchecked\") String stringValue = ((InstanceBinding<String>) stringBinding).getInstance(); Object source = stringBinding.getSource(); // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type); if (converted == null) { throw errors .converterReturnedNull(stringValue, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(stringValue, source, type, typeConverterBinding, converted) .toException(); } return new ConvertedConstantBindingImpl<T>( this, key, converted, stringBinding, typeConverterBinding); } catch (ErrorsException e) { throw e; } catch (RuntimeException e) { throw errors .conversionError(stringValue, source, type, typeConverterBinding, e) .toException(); } } \nResponse:", "ground_truth": "Converts a constant string binding to the required type.\n\n@return the binding if it could be resolved, or null if the binding doesn't exist\n@throws com.google.inject.internal.ErrorsException if there was an error resolving the binding", "predict": " Response<T> { // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(value, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(value, type); if (converted == null) { throw errors .converterReturnedNull(value, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(value, source, type, typeConverterB"}, {"ID": 316, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if (failed) { removeFailedJitBinding(depBinding, ip); bindingFailed = true; } } else if (state.getExplicitBinding(depKey) == null) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true; } } } return bindingFailed; } \nResponse:", "ground_truth": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "predict": " public boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if"}, {"ID": 317, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) { failedJitBindings.add(binding.getKey()); jitBindings.remove(binding.getKey()); membersInjectorStore.remove(binding.getKey().getTypeLiteral()); provisionListenerStore.remove(binding); if (ip != null) { constructors.remove(ip); } } \nResponse:", "ground_truth": "Cleans up any state that may have been cached when constructing the JIT binding.", "predict": "\n\n*/\n\npackage com.google.inject.internal;\n\nimport com.google.inject.Binding;\nimport com.google.inject.Key;\nimport com.google.inject.internal.util.StackTraceElements;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.HasDependencies;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding;\nimport com.google.inject.spi.ProvidesProviderTarget"}, {"ID": 318, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) { if (binding instanceof ConstructorBindingImpl) { return ((ConstructorBindingImpl) binding).getInternalDependencies(); } else if (binding instanceof HasDependencies) { return ((HasDependencies) binding).getDependencies(); } else { return ImmutableSet.of(); } } \nResponse:", "ground_truth": "Safely gets the dependencies of possibly not initialized bindings.", "predict": " Response<Set<Dependency<?>>>\n\n*/\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.name.Names;\n\n@Path(\"/\")\npublic class MyResource {\n\n    private final Injector injector;\n\n    @Inject\n    public MyResource(Injector injector) {\n        this.injector = injector;\n    }\n\n    @GET\n    @Path(\"/get\")\n    @Produces(MediaType.AP"}, {"ID": 319, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException { Class<?> rawType = key.getTypeLiteral().getRawType(); ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class); // Don't try to inject arrays or enums annotated with @ImplementedBy. if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) { throw errors.missingImplementationWithHint(key, this).toException(); } // Handle TypeLiteral<T> by binding the inner type if (rawType == TypeLiteral.class) { @SuppressWarnings(\"unchecked\") // we have to fudge the inner type as Object BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors); return binding; } // Handle @ImplementedBy if (implementedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createImplementedByBinding(key, scoping, implementedBy, errors); } // Handle @ProvidedBy. ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class); if (providedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createProvidedByBinding(key, scoping, providedBy, errors); } return ConstructorBindingImpl.create( this, key, null, /* use default constructor */ source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired); } \nResponse:", "ground_truth": "Creates a binding for an injectable type with the given scope. Looks for a scope on the type if\nnone is specified.", "predict": " Response<T> createResponse( Class<T> responseType, Object response, Scoping scoping, Errors errors) { return new Response<T>( responseType, response, scoping, errors ); } \n\n}\n"}, {"ID": 320, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException { if (parameterInjectors == null) { return NO_ARGUMENTS; } int size = parameterInjectors.length; Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) { parameters[i] = parameterInjectors[i].inject(context); } return parameters; } \nResponse:", "ground_truth": "Returns an array of parameter values.", "predict": " Response = new Response(new Object[] {parameterInjectors});\n\n*/\n\npublic class SingleParameterInjector<T> implements ParameterInjector<T> {\n    private final Class<T> clazz;\n    private final T value;\n\n    public SingleParameterInjector(Class<T> clazz, T value) {\n        this.clazz = clazz;\n        this.value = value;\n    }\n\n    @Override\n    public Class<T> getParameterClass() {\n        return clazz;\n    }\n\n    @Override\n    public T inject(InternalContext context) throws InternalProvisionException {\n        return value;\n    }\n}\n"}, {"ID": 321, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindInjector(InjectorImpl injector) { Key<Injector> key = Key.get(Injector.class); InjectorFactory injectorFactory = new InjectorFactory(injector); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Injector>( injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Injector is a special case because we allow both parent and child injectors to both have a\nbinding for that key.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Providers.ProviderInstanceBinding;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilder;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilderImpl;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilderImpl.ProviderInstanceBindingBuilder"}, {"ID": 322, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding"}, {"ID": 323, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) { Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation( errors, member, ((AnnotatedElement) member).getAnnotations()); if (misplacedBindingAnnotation == null) { return false; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if (member instanceof Method) { try { if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) { return false; } } catch (NoSuchFieldException ignore) { } } errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation); return true; } \nResponse:", "ground_truth": "Returns true if the binding annotation is in the wrong place.", "predict": "\n\n*/\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Documented\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Response {\n    String value();\n}\n"}, {"ID": 324, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean overrides(Method a, Method b) { // See JLS section 8.4.8.1 int modifiers = b.getModifiers(); if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) { return true; } if (Modifier.isPrivate(modifiers)) { return false; } // b must be package-private return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage()); } \nResponse:", "ground_truth": "Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\nclass is a subclass of b's declaring class.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add(\"m\");\n        list.add(\"n\");\n        list.add(\"o\");\n        list.add(\"p\");\n        list.add(\"q\");\n        list.add(\"r\");\n        list.add(\"s\");\n        list.add(\"t\");\n        list"}, {"ID": 325, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(MembersInjector<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual members injector.\n\n@throws IllegalStateException if the delegate is already set", "predict": " public void injectMembers(T instance) { checkState(this.delegate != null, \"delegate not initialized\"); this.delegate.injectMembers(instance); } \n\n*/\n\npublic class MembersInjectorGenerator extends AbstractMethodGenerator {\n    public MembersInjectorGenerator(int access, Type returnType, Type... argumentTypes) {\n        super(access, returnType, argumentTypes);\n    }\n\n    @Override\n    public void generate(CodeEmitter cv) {\n        cv.visitMethodInsn(Opcodes.INVOKESTATIC, \"MembersInjector\", \"initializeDelegate\",\n                \"(LMembersInjector;)V\", false);\n        cv.visitVarInsn(Opcodes.ALOAD, 0);\n        cv.visitMethodInsn(Opcodes.INVOKESTATIC, \"MembersInjector\", \"injectMembers\",\n                \"(Ljava/"}, {"ID": 326, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final TypeLiteral<Provider<T>> providerType() { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())); } \nResponse:", "ground_truth": "Gets the type of this type's provider.", "predict": " Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType) { return get(type, annotations, mediaType, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders) { return get(type, annotations, mediaType, httpHeaders, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders, final Class<? extends Annotation> annotationType) { return get(type, annotations, mediaType, httpHeaders, annotationType, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final"}, {"ID": 327, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<TypeLiteral<?>> resolveAll(Type[] types) { TypeLiteral<?>[] result = new TypeLiteral<?>[types.length]; for (int t = 0; t < types.length; t++) { result[t] = resolve(types[t]); } return ImmutableList.copyOf(result); } \nResponse:", "ground_truth": "Returns an immutable list of the resolved types.", "predict": " private TypeLiteral<?> resolve(Type type) { return TypeLiteral.get(type); } \n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class TypeLiteralTest {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list2 = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list3 = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list4 = Arrays.asList"}, {"ID": 328, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { Type type = typeLiteral.getType(); if (!isFullySpecified(type)) { Errors errors = new Errors().keyNotFullySpecified(typeLiteral); throw new ConfigurationException(errors.getMessages()); } if (typeLiteral.getRawType() == javax.inject.Provider.class) { ParameterizedType parameterizedType = (ParameterizedType) type; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @SuppressWarnings(\"unchecked\") TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0])); return guiceProviderType; } @SuppressWarnings(\"unchecked\") TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral); if (wrappedPrimitives != null) { return wrappedPrimitives; } // If we know this isn't a subclass, return as-is. if (typeLiteral.getClass() == TypeLiteral.class) { return typeLiteral; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @SuppressWarnings(\"unchecked\") TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType()); return recreated; } \nResponse:", "ground_truth": "Returns an type that's appropriate for use in a key.\n\nIf the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a\n{@code com.google.inject.Provider} with the same type parameters.\n\nIf the type is a primitive, the corresponding wrapper type will be returned.\n\n@throws ConfigurationException if {@code type} contains a type variable", "predict": " public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { return canonicalizeForKey(typeLiteral, new Errors()); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors) { return canonicalizeForKey(typeLiteral, errors, new TypeLiteral[0]); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors, TypeLiteral<?>... typeLiterals) { return canonicalizeForKey(typeLiteral, errors, Arrays.asList(typeLiterals)); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors, Collection<TypeL"}, {"ID": 329, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \"TypeConverter<Character>\"; } }); convertToClasses( injector, Matchers.subclassesOf(Enum.class), new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { return Enum.valueOf((Class) toType.getRawType(), value); } @Override public String toString() { return \"TypeConverter<E extends Enum<E>>\"; } }); internalConvertToTypes( injector, new AbstractMatcher<TypeLiteral<?>>() { @Override public boolean matches(TypeLiteral<?> typeLiteral) { return typeLiteral.getRawType() == Class.class; } @Override public String toString() { return \"Class<?>\"; } }, new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new RuntimeException(e.getMessage()); } } @Override public String toString() { return \"TypeConverter<Class<?>>\"; } }); } \nResponse:", "ground_truth": "Installs default converters for primitives, enums, and class literals.", "predict": " Response<String> convertToString(String value) { return Response.ok(value); } \nResp Response<Integer> convertToInteger(String value) { return Response.ok(Integer.valueOf(value)); } \nResp Response<Long> convertToLong(String value) { return Response.ok(Long.valueOf(value)); } \nResp Response<Boolean> convertToBoolean(String value) { return Response.ok(Boolean.valueOf(value)); } \nResp Response<Byte> convertToByte(String value) { return Response.ok(Byte.valueOf(value)); } \nResp Response<Short> convertToShort(String value) { return Response.ok(Short.valueOf(value)); } \nResp Response<Float> convertToFloat(String value) { return Response.ok(Float.valueOf(value)); } \nResp Response<Double> convertToDouble(String value) { return Response."}, {"ID": 330, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static ClassLoader canonicalize(ClassLoader classLoader) { return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent(); } \nResponse:", "ground_truth": "Attempts to canonicalize null references to the system class loader. May return null if for\nsome reason the system loader is unavailable.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 331, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasSameVersionOfCglib(ClassLoader classLoader) { Class<?> fc = net.sf.cglib.reflect.FastClass.class; try { return classLoader.loadClass(fc.getName()) == fc; } catch (ClassNotFoundException e) { return false; } } \nResponse:", "ground_truth": "Returns true if the types classloader has the same version of cglib that BytecodeGen has. This\nonly returns false in strange OSGI situations, but it prevents us from using FastClass for non\npublic members.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class CglibProxy {\n\tpublic static void main(String[] args) {\n\t\tEnhancer enhancer = new Enhancer();\n\t\tenhancer.setSuperclass(Object.class);\n\t\tenhancer.setCallback(new MethodInterceptor() {\n\t\t\t@Override\n\t\t\tpublic Object intercept(Object obj, Method method, Object[] args,\n\t\t\t\t\tMethodProxy proxy) throws Throwable {\n\t\t\t\tSystem.out.println(\"CglibProxy: \" + method.getName());\n\t\t\t\treturn proxy.invokeSuper(obj, args);\n\t\t\t}\n\t\t});\n\t\tenhancer.setUseCache(false);"}, {"ID": 332, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean isPubliclyCallable(Member member) { if (!Modifier.isPublic(member.getModifiers())) { return false; } Class<?>[] parameterTypes; if (member instanceof Constructor) { parameterTypes = ((Constructor) member).getParameterTypes(); } else { Method method = (Method) member; if (!Modifier.isPublic(method.getReturnType().getModifiers())) { return false; } parameterTypes = method.getParameterTypes(); } for (Class<?> type : parameterTypes) { if (!Modifier.isPublic(type.getModifiers())) { return false; } } return true; } \nResponse:", "ground_truth": "Returns true if the member can be called by a fast class generated in a different classloader.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n    public static void main(String[] args) {\n        List<String> javaCode = new ArrayList<>();\n        javaCode.add(\"package com.example.myapp;\");\n        javaCode.add(\"\");\n        javaCode.add(\"import java.util.ArrayList;\");\n        javaCode.add(\"import java.util.List;\");\n        javaCode.add(\"\");\n        javaCode.add(\"public class JavaCodeGenerator {\");\n        javaCode.add(\"\");\n        javaCode.add(\"    private static boolean isPubliclyCallable(Member member) {\");\n        javaCode.add(\"        if (!Modifier.isPublic(member.getModifiers())) {\");\n        javaCode.add(\"            return false;\");\n        javaCode.add(\"        }\");\n        javaCode"}, {"ID": 333, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); } \nResponse:", "ground_truth": "Replace annotation instances with annotation types, this is only appropriate for testing if a\nkey is bound and not for injecting.\n\n", "predict": " public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface FixAnnotations {\n}\n"}, {"ID": 334, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Initializable<T> requestInjection( InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Member injection could not be requested after validation is started\"); ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding); // short circuit if the object has no injections or listeners. if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return Initializables.of(instance); } if (initializablesCache.containsKey(instance)) { @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T> Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance); return cached; } InjectableReference<T> injectableReference = new InjectableReference<T>( injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass())); initializablesCache.put(instance, injectableReference); pendingInjections.add(injectableReference); return injectableReference; } \nResponse:", "ground_truth": "Registers an instance for member injection when that step is performed.\n\n@param instance an instance that optionally has members to be injected (each annotated\nwith @Inject).\n@param binding the binding that caused this initializable to be created, if it exists.\n@param source the source location that this injection was requested", "predict": " void requestStaticInjection( InjectorImpl injector, Class<?> type, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Static injection could not be requested after validation is started\"); ProvisionListenerStackCallback<Object> provisionCallback = injector.provisionListenerStore.get(type); // short circuit if the object has no injections or listeners. if (type == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return; } if (staticInjections.containsKey(type)) { @SuppressWarnings(\"unchecked\") // Map from Class<T> to StaticInjection<T> StaticInjection<T> cached = (StaticInjection<T>) staticInjections.get(type); return cached; } StaticInjection<Object> staticInjection = new StaticIn"}, {"ID": 335, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } } \nResponse:", "ground_truth": "Prepares member injectors for all injected instances. This prompts Guice to do static analysis\non the injected instances.", "predict": " void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } } \n */\n\npublic class InjectableReference<T> {\n    private final Class<T> type;\n    private final String name;\n    private final String description;\n    private final boolean optional;\n    private final boolean required;\n    private final boolean injectable;\n    private final boolean injectableAtStartup;\n    private final boolean injectableAtShutdown;\n    private final boolean injectableAtValidation;\n    private final boolean injectableAtInitialization;\n    private final boolean injectableAtValidation;\n    private final boolean injectableAtInitialization;\n    private final boolean injectableAtShutdown;\n    private"}, {"ID": 336, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T newInstance(Object[] args) throws Throwable { constructor.setAccessible(true); try { return constructor.newInstance(args); } catch (InvocationTargetException e) { throw e.getCause(); } } \nResponse:", "ground_truth": "Returns an instance of T, constructed using this constructor, with the supplied arguments.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        try {\n            test.newInstance(new Object[]{});\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n\n    public Test() {\n    }\n\n    public Test(Object[] args) {\n    }\n\n    public Test(Object arg) {\n    }\n\n    public Test(Object arg1, Object arg2) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4, Object arg"}, {"ID": 337, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"JavaDoc\", \"deprecation\"}) private ServletRequest withDispatcher( ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if (!servletPipeline.hasServletsMapped()) { return servletRequest; } HttpServletRequest request = (HttpServletRequest) servletRequest; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper(request) { @Override public RequestDispatcher getRequestDispatcher(String path) { final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path); return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path); } }; } \nResponse:", "ground_truth": "Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular\npipeline based on uri-path match. This proxy also provides minimal forwarding support.\n\nWe cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline\nis not called again). However, we can wrap requests with our own dispatcher to forward the\n*other* way. web.xml Servlets/JSPs can forward to themselves as per normal.\n\nThis is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,\nincrementally, but not the other way around (which, we should actively discourage).", "predict": "\n\npublic class HttpServletRequestWrapper extends HttpServletRequestWrapper {\n    private final HttpServletRequest request;\n    private final ManagedServletPipeline servletPipeline;\n\n    public HttpServletRequestWrapper(HttpServletRequest request, ManagedServletPipeline servletPipeline) {\n        super(request);\n        this.request = request;\n        this.servletPipeline = servletPipeline;\n    }\n\n    @Override public ServletContext getServletContext() {\n        return servletPipeline.getServletContext();\n    }\n\n    @Override public AsyncContext startAsync() throws IllegalStateException {\n        return request.startAsync();\n    }\n\n    @Override public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException {\n        return request.startAsync(servletRequest, servletResponse);"}, {"ID": 338, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> InternalFactory<? extends T> scope( Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) { if (scoping.isNoScope()) { return creator; } Scope scope = scoping.getScopeInstance(); // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here. If you change the type make sure to update // SingletonScope as well. Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)); return new InternalFactoryToProviderAdapter<T>(scoped, source); } \nResponse:", "ground_truth": "Scopes an internal factory.", "predict": "\n\n*/\n\npackage com.google.inject.internal;\n\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.internal.util.SourceProvider;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding;\nimport com.google.inject.spi.ProvidesProviderTargetVisitor;\nimport com.google.inject.spi.ProvidesScoping;\n"}, {"ID": 339, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) { Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation(); if (scopeAnnotation == null) { return scoping; } ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation); if (scope != null) { return forInstance(scope.getScope()); } errors.scopeNotFound(scopeAnnotation); return UNSCOPED; } \nResponse:", "ground_truth": "Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance\nmap. If the scope annotation has no corresponding instance, an error will be added and unscoped\nwill be retuned.", "predict": " Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance("}, {"ID": 340, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static String normalizePath(String path) { StringBuilder sb = new StringBuilder(path.length()); int queryStart = path.indexOf('?'); String query = null; if (queryStart != -1) { query = path.substring(queryStart); path = path.substring(0, queryStart); } // Normalize the path. we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List<String> segments = new ArrayList<>(); for (String segment : SLASH_SPLITTER.split(path)) { // This decodes all non-special characters from the path segment. so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false)); if (\".\".equals(normalized)) { // skip } else if (\"..\".equals(normalized)) { if (segments.size() > 1) { segments.remove(segments.size() - 1); } } else { segments.add(normalized); } } SLASH_JOINER.appendTo(sb, segments); if (query != null) { sb.append(query); } return sb.toString(); } \nResponse:", "ground_truth": "Normalizes a path by unescaping all safe, percent encoded characters.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static String normalizePath(String path) {\n        StringBuilder sb = new StringBuilder(path.length());\n        int queryStart = path.indexOf('?');\n        String query = null;\n        if (queryStart != -1) {\n            query = path.substring(queryStart);\n            path = path.substring(0, queryStart);\n        }\n        // Normalize the path. we need to decode path segments, normalize and rejoin in order to\n        // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p'\n        // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/'\n        "}, {"ID": 341, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); } \nResponse:", "ground_truth": "Generates an Annotation for the annotation class. Requires that the annotation is all\noptionals.", "predict": " public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common"}, {"ID": 342, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) { Retention retention = annotationType.getAnnotation(Retention.class); return retention != null && retention.value() == RetentionPolicy.RUNTIME; } \nResponse:", "ground_truth": "Returns true if the given annotation is retained at runtime.", "predict": "\n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class RetentionPolicy {\n\n    public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) {\n        Retention retention = annotationType.getAnnotation(Retention.class);\n        return retention != null && retention.value() == RetentionPolicy.RUNTIME;\n    }\n\n    public static Set<String> getRetainedAnnotationTypes(Class<? extends Annotation> annotationType) {\n        Set<String> retainedAnnotationTypes = new HashSet<>();\n        for (Method method : annotationType.getMethods()) {\n            if (method.getName().startsWith(\"is\")) {\n                retainedAnnotationTypes.add(method.getName().substring(2));\n            "}, {"ID": 343, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class<? extends Annotation> findScopeAnnotation( Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; } \nResponse:", "ground_truth": "Returns the scoping annotation, or null if there isn't one.", "predict": " public static Class<? extends Annotation> findScopeAnnotation(Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ScopeAnnotation {\n    Class<? extends Annotation> value();\n}\n"}, {"ID": 344, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); } \nResponse:", "ground_truth": "Gets a key for the given type, member and annotations.", "predict": " public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\n\n"}, {"ID": 345, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } } \nResponse:", "ground_truth": "Returns the name the binding should use. This is based on the annotation. If the annotation has\nan instance and is not a marker annotation, we ask the annotation for its toString. If it was a\nmarker annotation or just an annotation type, we use the annotation's name. Otherwise, the name\nis the empty string.", "predict": " public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class AnnotationUtils {\n\n    private static final Map<Class<? extends Annotation>, Set<Class<?>>> annotationMap = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();\n\n    static {\n        ann"}, {"ID": 346, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual provider.\n\n@throws IllegalStateException if the delegate is already set", "predict": " public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState("}, {"ID": 347, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); } \nResponse:", "ground_truth": "Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate\nbindings.", "predict": " Response is generated by the following java Code. Code: private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); } \n */\n\npublic class RealDirectTypeProvider<T> implements Provider<T> {\n    private final BindingSelection bindingSelection;\n\n    public RealDirectTypeProvider(BindingSelection bindingSelection) {\n        this.bindingSelection = bindingSelection;\n    }\n\n    @Override\n    public T get() {\n        return bindingSelection.getDirectKey();\n    }\n}\n"}, {"ID": 348, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); } \nResponse:", "ground_truth": "Returns a new complete constructor injector with injection listeners registered.", "predict": " public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); } \n\n*/\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\n\npublic class ConstructorInjector<T> {\n\t\n\tprivate final Constructor<T> constructor;\n\tprivate final List"}, {"ID": 349, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasScope(Class<? extends Interceptor> interceptorClass) { for (Annotation annotation : interceptorClass.getAnnotations()) { if (Annotations.isScopeAnnotation(annotation.annotationType())) { return true; } } return false; } \nResponse:", "ground_truth": "Returns true if the given class has a scope annotation.", "predict": " Response response = null;\nif (hasScope(interceptorClass)) {\nresponse = interceptorClass.newInstance().intercept(request);\n}\nreturn response;\n}\n\n*/\n"}, {"ID": 350, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <K, V> RealMapBinder<K, V> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) { binder = binder.skipSources(RealMapBinder.class); TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral(); return newRealMapBinder( binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder( binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType)))); } \nResponse:", "ground_truth": "since it's an easy way to group a type and an optional annotation type or instance.", "predict": " Response<RealMapBinder<K, V>> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, TypeLiteral<E> elementType, Multibinder<E> elements) { return newRealMapBinder( binder, keyType, valueType, elementType, elements, RealMultibinder.newRealSetBinder( binder, elementType)); } \nResp Response<RealMapBinder<K, V>> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, TypeLiteral<E> elementType, Multibinder<E> elements, SetBinder<V> valueSetBinder) { return newRealMapBinder( binder, keyType, valueType, elementType, elements, valueSetBinder, RealMultibinder.newRealSetBinder( binder,"}, {"ID": 351, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<V> getKeyForNewValue(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey)); return valueKey; } \nResponse:", "ground_truth": "Adds a binding to the map for the given key.", "predict": " Response<V> getValueForKey(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); return entrySetBinder.get(key).get(); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.multibindings.Multibinder;\nimport com.google.inject.name.Names;\n\npublic class MapBinderModule extends AbstractModule {\n\n\t@Override\n\tprotected void configure() {\n\t\tMultibinder<Map.Entry<String,"}, {"ID": 352, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return t; } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor(cause) .addSource(constructionProxy.getInjectionPoint()); } finally { constructionContext.removeCurrentReference(); } } \nResponse:", "ground_truth": "Provisions a new T.", "predict": " Response<T> provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return Response.instance(t); } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor("}, {"ID": 353, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object writeReplace() throws ObjectStreamException { Object[] sourcesAsStrings = sources.toArray(); for (int i = 0; i < sourcesAsStrings.length; i++) { sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString(); } return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause); } \nResponse:", "ground_truth": "When serialized, we eagerly convert sources to strings. This hurts our formatting, but it\nguarantees that the receiving end will be able to read the message.", "predict": " Response(Message message) { this.message = message; } \nResp Response(Message message, Throwable cause) { this.message = message; this.cause = cause; } \nResp Response(Throwable cause) { this.cause = cause; } \nResp Response(Throwable cause, Message message) { this.message = message; this.cause = cause; } \nResp Response(Throwable cause, Message message, Object[] sources) { this.message = message; this.cause = cause; this.sources = sources; } \nResp Response(Throwable cause, Message message, Object[] sources, Object[] params) { this.message = message; this.cause = cause; this.sources = sources; this.params = params; } \nResp Response(Throwable cause, Message message, Object[] sources, Object[] params, Object[] args) { this.message = message; this.cause = cause; this.sources = sources;"}, {"ID": 354, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Module forModule(Module module) { // avoid infinite recursion, since installing a module always installs itself if (module instanceof CheckedProviderMethodsModule) { return Modules.EMPTY_MODULE; } return new CheckedProviderMethodsModule(module); } \nResponse:", "ground_truth": "Returns a module which creates bindings for provider methods from the given module.", "predict": "\n\n*/\n\npublic class CheckedProviderMethodsModule extends AbstractModule {\n    private final Module module;\n\n    public CheckedProviderMethodsModule(Module module) {\n        this.module = module;\n    }\n\n    @Override\n    protected void configure() {\n        install(module);\n    }\n}\n"}, {"ID": 355, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings(\"unchecked\") public Collection<AssistedMethod> getAssistedMethods() { return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values(); } \nResponse:", "ground_truth": "the collection is immutable.", "predict": " Response is generated by the method getResponse() in the class Response.\n*/\n\npublic class AssistData {\n\t\n\tprivate String methodName;\n\tprivate String methodDescription;\n\tprivate String methodReturnType;\n\tprivate String methodReturnDescription;\n\tprivate String methodReturnTypeName;\n\tprivate String methodReturnDescriptionName;\n\tprivate String methodReturnTypeNameWithGenerics;\n\tprivate String methodReturnDescriptionNameWithGenerics;\n\tprivate String methodReturnTypeNameWithGenericsAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParametersAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParametersAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParametersAndParametersAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParametersAndParametersAndParameters;\n\tprivate"}, {"ID": 356, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) { Collection<Message> messages = ce.getErrorMessages(); if (messages.size() == 1) { Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages()); return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage()); } else { return false; } } \nResponse:", "ground_truth": "Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully\nspecified.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport org.junit.Test;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedMap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class TestGenerate {\n\n\t@Test\n\tpublic void testGenerate() {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t"}, {"ID": 357, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean constructorHasMatchingParams( TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException { List<TypeLiteral<?>> params = type.getParameterTypes(constructor); Annotation[][] paramAnnotations = constructor.getParameterAnnotations(); int p = 0; List<Key<?>> constructorKeys = Lists.newArrayList(); for (TypeLiteral<?> param : params) { Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors); constructorKeys.add(paramKey); } // Require that every key exist in the constructor to match up exactly. for (Key<?> key : paramList) { // If it didn't exist in the constructor set, we can't use it. if (!constructorKeys.remove(key)) { return false; } } // If any keys remain and their annotation is Assisted, we can't use it. for (Key<?> key : constructorKeys) { if (key.getAnnotationType() == Assisted.class) { return false; } } // All @Assisted params match up to the method's parameters. return true; } \nResponse:", "ground_truth": "Matching logic for constructors annotated with AssistedInject. This returns true if and only if\nall @Assisted parameters in the constructor exactly match (in any order) all @Assisted\nparameters the method's parameter.", "predict": " private Response<R> invoke(TypeLiteral<?> type, Object[] args, Type genericReturnType, Type genericReturnType2, Type genericReturnType3, Type genericReturnType4, Type genericReturnType5, Type genericReturnType6, Type genericReturnType7, Type genericReturnType8, Type genericReturnType9, Type genericReturnType10, Type genericReturnType11, Type genericReturnType12, Type genericReturnType13, Type genericReturnType14, Type genericReturnType15, Type genericReturnType16, Type genericReturnType17, Type genericReturnType18, Type genericReturnType19, Type genericReturnType20, Type genericReturnType21, Type genericReturnType22, Type genericReturnType23, Type genericReturnType24, Type genericReturnType25, Type genericReturnType26, Type genericReturnType27, Type genericReturnType28, Type genericReturnType29, Type genericReturnType30, Type genericReturnType31, Type genericReturnType32, Type genericReturnType33,"}, {"ID": 358, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); builder.addAll(ctorPoint.getDependencies()); if (!implementation.getRawType().isInterface()) { for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) { builder.addAll(ip.getDependencies()); } } return builder.build(); } \nResponse:", "ground_truth": "Calculates all dependencies required by the implementation and constructor.", "predict": " Response<T> get(Request<T> request) { return null; } \nResp Response<T> post(Request<T> request) { return null; } \nResp Response<T> put(Request<T> request) { return null; } \nResp Response<T> delete(Request<T> request) { return null; } \nResp Response<T> head(Request<T> request) { return null; } \nResp Response<T> options(Request<T> request) { return null; } \nResp Response<T> trace(Request<T> request) { return null; } \nResp Response<T> patch(Request<T> request) { return null; } \nResp Response<T> connect(Request<T> request) { return null; } \nResp Response<T> patch(Request<T> request) { return null; } \nResp Response<T> options("}, {"ID": 359, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); for (Dependency<?> dep : deps) { Class<?> annotationType = dep.getKey().getAnnotationType(); if (annotationType == null || !annotationType.equals(Assisted.class)) { builder.add(dep); } } return builder.build(); } \nResponse:", "ground_truth": "Return all non-assisted dependencies.", "predict": " Response<Set<Dependency<?>>> removeAssistedDeps(Set<Dependency<?>> deps) { return Response.success(removeAssistedDeps(deps)); } \n */\n\npublic class RemoveAssistedDeps {\n    public static void main(String[] args) {\n        Response<Set<Dependency<?>>> response = Response.success(removeAssistedDeps(new HashSet<Dependency<?>>()));\n        System.out.println(response.body());\n    }\n}\n"}, {"ID": 360, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { Set<Dependency<?>> badDeps = null; // optimization: create lazily for (Dependency<?> dep : dependencies) { if (isInjectorOrAssistedProvider(dep)) { if (badDeps == null) { badDeps = Sets.newHashSet(); } badDeps.add(dep); } } if (badDeps != null && !badDeps.isEmpty()) { logger.log( Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!) \" + \"The exact offending deps are: {2}\", new Object[] {factoryType, implementation, badDeps}); return false; } return true; } \nResponse:", "ground_truth": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "predict": "\n\n@AssistedInject\npublic class MyAssistedInjectFactory implements Factory<MyAssistedInjectFactory> {\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider2;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider2;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider3;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider3;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider4;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider4;\n    private final Provider<My"}, {"ID": 361, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey).toProvider(Providers.of(args[p++])); } } else { for (Key<?> paramKey : data.paramTypes) { // Bind to our ThreadLocalProviders. binder.bind((Key) paramKey).toProvider(data.providers.get(p++)); } } Constructor constructor = data.constructor; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if (constructor != null) { binder .bind(returnKey) .toConstructor(constructor, (TypeLiteral) data.implementationType) .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type } } }; Injector forCreate = injector.createChildInjector(assistedModule); Binding<?> binding = forCreate.getBinding(returnKey); // If we have providers cached in data, cache the binding for future optimizations. if (data.optimized) { data.cachedBinding = binding; } return binding; } \nResponse:", "ground_truth": "Creates a child injector that binds the args, and returns the binding for the method's result.", "predict": " public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey"}, {"ID": 362, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if (methodHandleByMethod.containsKey(method)) { return methodHandleByMethod.get(method).invokeWithArguments(args); } if (method.getDeclaringClass().equals(Object.class)) { if (\"equals\".equals(method.getName())) { return proxy == args[0]; } else if (\"hashCode\".equals(method.getName())) { return System.identityHashCode(proxy); } else { return method.invoke(this, args); } } AssistData data = assistDataByMethod.get(method); checkState(data != null, \"No data for method: %s\", method); Provider<?> provider; if (data.cachedBinding != null) { // Try to get optimized form... provider = data.cachedBinding.getProvider(); } else { provider = getBindingFromNewInjector(method, args, data).getProvider(); } try { int p = 0; for (ThreadLocalProvider tlp : data.providers) { tlp.set(args[p++]); } return provider.get(); } catch (ProvisionException e) { // if this is an exception declared by the factory method, throw it as-is if (e.getErrorMessages().size() == 1) { Message onlyError = getOnlyElement(e.getErrorMessages()); Throwable cause = onlyError.getCause(); if (cause != null && canRethrow(method, cause)) { throw cause; } } throw e; } finally { for (ThreadLocalProvider tlp : data.providers) { tlp.remove(); } } } \nResponse:", "ground_truth": "When a factory method is invoked, we create a child injector that binds all parameters, then\nuse that to get an instance of the return type.", "predict": "\n\npublic Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n  Object result = null;\n  try {\n    result = invokeProxy(proxy, method, args);\n  } catch (InvocationTargetException e) {\n    Throwable cause = e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw (RuntimeException) cause;\n    } else if (cause instanceof Error) {\n      throw (Error) cause;\n    } else {\n      throw e;\n    }\n  }\n  return result;\n}\n\npublic Object invokeProxy(Object proxy, final Method method, final Object[] args) throws Throwable {\n  Object result = null;\n  try {\n    result = method.invoke(this, args);\n  } catch (InvocationTargetException e) {\n    Throwable cause = e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw ("}, {"ID": 363, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb.append(format(\"%n * %s\", sameTypes.get(i).getKey())); } int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED; if (remaining > 0) { String plural = (remaining == 1) ? \"\" : \"s\"; sb.append(format(\"%n %d more binding%s with other annotations.\", remaining, plural)); } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type.toString(); Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings(); for (Key<?> bindingKey : bindingMap.keySet()) { String have = bindingKey.getTypeLiteral().toString(); if (have.contains(want) || want.contains(have)) { Formatter fmt = new Formatter(); Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource()); String match = String.format(\"%s bound%s\", convert(bindingKey), fmt.toString()); possibleMatches.add(match); // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) { // Early exit if we have found more than we need. break; } } } if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) { sb.append(format(\"%n Did you mean?\")); for (String possibleMatch : possibleMatches) { sb.append(format(\"%n %s\", possibleMatch)); } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotation() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) { // We don't recommend using such simple types without annotations. sb.append(format(\"%nThe key seems very generic, did you forget an annotation?\")); } return addMessage(sb.toString()); } \nResponse:", "ground_truth": "Within guice's core, allow for better missing binding messages", "predict": " Generate the method-level comment for the following java Code. Code: <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look"}, {"ID": 364, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); RealMultibinder<T> result = new RealMultibinder<>(binder, key); binder.install(result); return result; } \nResponse:", "ground_truth": "Implementation of newSetBinder.", "predict": " public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); return new RealMultibinder<>(binder, key); } \n\n*/\n\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\n@Singleton\npublic class RealMultibinder<T> {\n  private final Provider<Binder> binder;\n  private final Key<T> key;\n\n  @Inject\n  RealMultibinder(Provider<Binder> binder, Key<T> key) {\n    this.binder = binder;\n    this.key = key;\n  }\n\n  public void bind(Class<? extends T> clazz) {\n    binder.get()."}, {"ID": 365, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<T> getKeyForNewItem() { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Key.get( bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\")); } \nResponse:", "ground_truth": "Adds a new entry to the set and returns the key for it.", "predict": " Response<T> getItem(Key<T> key) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key); } \nResp Response<T> getItem(Key<T> key, String name) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key, name); } \nResp Response<T> getItem(Key<T> key, String name, String description) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key, name, description); } \nResp Response<T> getItem(Key<T> key, String name, String description, String shortDescription) { checkConfiguration(!bindingSelection.is"}, {"ID": 366, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Filter findNextFilter(HttpServletRequest request) { while (++index < filterDefinitions.length) { Filter filter = filterDefinitions[index].getFilterIfMatching(request); if (filter != null) { return filter; } } return null; } \nResponse:", "ground_truth": "Iterates over the remaining filter definitions. Returns the first applicable filter, or null if\nnone apply.", "predict": " Response filter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { return chain.doFilter(request, response); } \n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FilterChainTest implements Filter {\n\n\tprivate List<Filter> filters = new ArrayList<Filter>();\n\t\n\tpublic void init(FilterConfig filterConfig)"}, {"ID": 367, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasAtInject(Constructor cxtor) { return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class); } \nResponse:", "ground_truth": "Returns true if the inject annotation is on the constructor.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\n@Component\npublic class MethodInjector {\n\n\tprivate Map<Method, List<Injector>> injectors = Maps.newHashMap();\n\n\tpublic void addInjector(Method method, Injector injector) {\n\t\tList<Injector> list = injectors.get(method);\n\t\tif (list == null) {\n\t\t\tlist = new ArrayList<Injector>();\n\t\t\tinjectors"}, {"ID": 368, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: InjectionPoint getInternalConstructor() { if (factory.constructorInjector != null) { return factory.constructorInjector.getConstructionProxy().getInjectionPoint(); } else { return constructorInjectionPoint; } } \nResponse:", "ground_truth": "Returns an injection point that can be used to clean up the constructor store.", "predict": " Response getInternalConstructor() { return factory.constructorInjector.getConstructionProxy().getResponse(); } \n\n*/\n\npublic class ConstructorInjectionPoint extends InjectionPoint {\n\t\n\tprivate ConstructorInjectionPoint(Constructor<?> constructor, Type type, AnnotatedType<Constructor> annotatedType) {\n\t\tsuper(constructor, type, annotatedType);\n\t}\n\t\n\tpublic static ConstructorInjectionPoint create(Constructor<?> constructor, Type type, AnnotatedType<Constructor> annotatedType) {\n\t\treturn new ConstructorInjectionPoint(constructor, type, annotatedType);\n\t}\n\t\n\tpublic Constructor<?> getConstructor() {\n\t\treturn (Constructor<?>) getMember();\n\t}\n\t\n\tpublic Response getResponse() {\n\t\treturn new Response(getConstructor());\n\t}\n\t\n\tpublic Response getResponse(Object[] args) {\n\t\treturn"}, {"ID": 369, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Set<Dependency<?>> getInternalDependencies() { ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder(); if (factory.constructorInjector == null) { builder.add(constructorInjectionPoint); // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder.addAll( InjectionPoint.forInstanceMethodsAndFields( constructorInjectionPoint.getDeclaringType())); } catch (ConfigurationException ignored) { } } else { builder.add(getConstructor()).addAll(getInjectableMembers()); } return Dependency.forInjectionPoints(builder.build()); } \nResponse:", "ground_truth": "Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.", "predict": " Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response"}, {"ID": 370, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) { return forObject(module, false, scanner); } \nResponse:", "ground_truth": "Returns a module which creates bindings methods in the module that match the scanner.", "predict": "\n\n*/\n\npublic class ModuleAnnotatedMethodScanner extends AnnotatedMethodScanner {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ModuleAnnotatedMethodScanner.class);\n\n    private final ModuleScanner scanner;\n\n    public ModuleAnnotatedMethodScanner(ModuleScanner scanner) {\n        this.scanner = scanner;\n    }\n\n    @Override\n    public void scan(Object module, AnnotatedMethodScannerContext context) {\n        if (module instanceof Module) {\n            scanModule((Module) module, context);\n        } else if (module instanceof ModuleIdentifier) {\n            scanModule((ModuleIdentifier) module, context);\n        } else {\n            LOGGER.warn(\"Unsupported module type: {}\", module.getClass().getName());\n        }\n    }\n\n    private void scanModule(ModuleIdentifier module, AnnotatedMethodScannerContext context) {\n        "}, {"ID": 371, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; } \nResponse:", "ground_truth": "Returns the annotation that is claimed by the scanner, or null if there is none.", "predict": " private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; } \n */\n\npublic class AnnotationScanner {\n    private final List<Class<? extends Annotation>> annotationClasses;\n\n    public AnnotationScanner(List<Class<? extends Annotation>> annotationClasses) {\n        this.annotationClasses = annotationClasses;\n    }\n\n    public List<"}, {"ID": 372, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Integer getLineNumber(Member member) { Preconditions.checkArgument( type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type); return lines.get(memberKey(member)); } \nResponse:", "ground_truth": "Get the line number associated with the given member.\n\n@param member a field, constructor, or method belonging to the class used during construction\n@return the wrapped line number, or null if not available\n@throws IllegalArgumentException if the member does not belong to the class used during\nconstruction", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class LineNumberGenerator {\n    private final Map<String, Integer> lines = new TreeMap<>();\n\n    public LineNumberGenerator(Class<?> type) {\n        for (Method method : type.getMethods()) {\n            lines.put(methodKey(method), method.getAnnotation(LineNumber.class).value());\n        }\n    }\n\n    public int getLineNumber(Member member) {\n        Preconditions.checkArgument(member.getDeclaringClass() == type, \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type);\n        return lines.get(methodKey(member));\n    }\n\n    private String methodKey(Member member) {\n        return member.getDeclaringClass().getName"}, {"ID": 373, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void initialize(Errors errors) { injector.lookups = injector; new LookupProcessor(errors).process(injector, lookups); } \nResponse:", "ground_truth": "Initialize the specified lookups, either immediately or when the injector is created.", "predict": " Response.ok().build();\n */\n\npublic class LookupProcessor extends AbstractProcessor {\n\n    private final Errors errors;\n\n    public LookupProcessor(Errors errors) {\n        this.errors = errors;\n    }\n\n    @Override\n    public void process(RequestContext context) {\n        final String lookupName = context.getPathTokens().get(1);\n        final Lookup lookup = context.getLookup(lookupName);\n        if (lookup == null) {\n            throw new NotFoundException(errors.getErrorMessage(ErrorCode.LOOKUP_NOT_FOUND, lookupName));\n        }\n        context.setLookup(lookupName, lookup);\n    }\n}\n"}, {"ID": 374, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"continues\" the HTTP request in another\nthread. This acts as a way of transporting request context data from the request processing\nthread to to worker threads.\n\nThere are some limitations:\n\n\nDerived objects (i.e. anything marked @RequestScoped will not be transported.\nState changes to the HttpServletRequest after this method is called will not be seen in the\ncontinued thread.\nOnly the HttpServletRequest, ServletContext and request parameter map are available in the\ncontinued thread. The response and session are not available.\n\nThe returned callable will throw a {@link ScopingException} when called if the HTTP request\nscope is still active on the current thread.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@param seedMap the initial set of scoped instances for Guice to seed the request scope with. To\nseed a key with null, use {@code null} as the value.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 3.0\n@deprecated You probably want to use {@code transferRequest} instead", "predict": " @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); } \n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Pre"}, {"ID": 375, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"transfers\" the request to another\nthread. This acts as a way of transporting request context data from the current thread to a\nfuture thread.\n\nAs opposed to {@link #continueRequest}, this method propagates all existing scoped objects.\nThe primary use case is in server implementations where you can detach the request processing\nthread while waiting for data, and reattach to a different thread to finish processing at a\nlater time.\n\nBecause request-scoped objects are not typically thread-safe, the callable returned by this\nmethod must not be run on a different thread until the current request scope has terminated.\nThe returned callable will block until the current thread has released the request scope.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 4.0", "predict": " public static <T> Response<T> transferRequest(Response<T> response) { return wrap(response, transferRequest()); } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport"}, {"ID": 376, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; } \nResponse:", "ground_truth": "Validates the key and object, ensuring the value matches the key type, and canonicalizing null\nobjects to the null sentinel.", "predict": " public static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; } \n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentHashMap<>();\n        map.put(\"a\", \"b\");\n        map.put(\"c\", \"d\");\n        map.put(\"e\", \"f\");\n        map.put(\"g\", \"h"}, {"ID": 377, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") // the MembersInjector type always agrees with the passed type public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException { return (MembersInjectorImpl<T>) cache.get(key, errors); } \nResponse:", "ground_truth": "Returns a new complete members injector with injection listeners registered.", "predict": "\n\npublic class MembersInjectorImpl<T> implements MembersInjector<T> {\n    private final TypeLiteral<T> typeLiteral;\n    private final MembersInjectionComponentAdapter<T> adapter;\n    private final ImmutableList<MembersInjectionComponentAdapter<? super T>> delegates;\n\n    public MembersInjectorImpl(TypeLiteral<T> typeLiteral, MembersInjectionComponentAdapter<T> adapter, ImmutableList<MembersInjectionComponentAdapter<? super T>> delegates) {\n        this.typeLiteral = typeLiteral;\n        this.adapter = adapter;\n        this.delegates = delegates;\n    }\n\n    public void injectMembers(T instance) {\n        adapter.inject(instance, typeLiteral);\n        for (MembersInjectionComponentAdapter<? super T> delegate : delegates) {\n            delegate.inject(instance, typeLiteral);\n        }\n    "}, {"ID": 378, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Set<InjectionPoint> injectionPoints; try { injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type); } catch (ConfigurationException e) { errors.merge(e.getErrorMessages()); injectionPoints = e.getPartialValue(); } ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors); errors.throwIfNewErrors(numErrorsBefore); EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups); Set<TypeListener> alreadySeenListeners = Sets.newHashSet(); for (TypeListenerBinding binding : typeListenerBindings) { TypeListener typeListener = binding.getListener(); if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) { alreadySeenListeners.add(typeListener); try { typeListener.hear(type, encounter); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } encounter.invalidate(); errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(injector, type, encounter, injectors); } \nResponse:", "ground_truth": "Creates a new members injector and attaches both injection listeners and method aspects.", "predict": " private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors, Set<TypeListener> listeners) throws ErrorsException { int numErrorsBefore = errors.size(); ImmutableList.Builder<SingleMemberInjector> builder = ImmutableList.builder(); for (TypeListenerBinding binding : typeListenerBindings) { if (listeners.contains(binding.getListener())) { try { binding.getListener().hear(type, new EncounterImpl<>(errors, binding.getInjector().lookups)); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(binding.getInjector(), type, new EncounterImpl<>(errors, binding.getInjector().lookups), builder.build()); } \n}\n"}, {"ID": 379, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); } \nResponse:", "ground_truth": "Returns the injectors for the specified injection points.", "predict": " ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); } \n\n}\n"}, {"ID": 380, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); } \nResponse:", "ground_truth": "Gets a key for an injection type and an annotation strategy.", "predict": " Response<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Response<T>(type, annotationStrategy); } \n\n*/\n\npublic class KeyGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); } \n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Response<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Response<T>(type, annotationStrategy); } \n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, Annotation"}, {"ID": 381, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Annotation annotation) { checkNotNull(annotation, \"annotation\"); Class<? extends Annotation> annotationType = annotation.annotationType(); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); if (Annotations.isMarker(annotationType)) { return new AnnotationTypeStrategy(annotationType, annotation); } return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation)); } \nResponse:", "ground_truth": "Gets the strategy for an annotation.", "predict": " Response<T> get(Request request) { return strategyFor(request.annotation()).get(request); } \nResp Response<T> post(Request request) { return strategyFor(request.annotation()).post(request); } \nResp Response<T> put(Request request) { return strategyFor(request.annotation()).put(request); } \nResp Response<T> delete(Request request) { return strategyFor(request.annotation()).delete(request); } \nResp Response<T> head(Request request) { return strategyFor(request.annotation()).head(request); } \nResp Response<T> options(Request request) { return strategyFor(request.annotation()).options(request); } \nResp Response<T> trace(Request request) { return strategyFor(request.annotation()).trace(request); } \nResp Response<T> patch(Request request) { return strategyFor"}, {"ID": 382, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, null); } \nResponse:", "ground_truth": "Gets the strategy for an annotation type.", "predict": " static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType, Annotation annotation) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType, annotation)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, annotation); } \nResp static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType, Annotation[] annotations) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType, annotations)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation("}, {"ID": 383, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pruneStacktrace(Throwable throwable) { for (Throwable t = throwable; t != null; t = t.getCause()) { StackTraceElement[] stackTrace = t.getStackTrace(); List<StackTraceElement> pruned = Lists.newArrayList(); for (StackTraceElement element : stackTrace) { String className = element.getClassName(); if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) { pruned.add(element); } } t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()])); } } \nResponse:", "ground_truth": "Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace\nand any causes it may have.", "predict": "\n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Compar"}, {"ID": 384, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getBindingSource() { if (source instanceof Class) { return StackTraceElements.forType((Class) source).toString(); } else if (source instanceof Member) { return StackTraceElements.forMember((Member) source).toString(); } else { return source.toString(); } } \nResponse:", "ground_truth": "Returns a string describing where this dependency was bound. If the binding was just-in-time,\nthere is no valid binding source, so this describes the class in question.", "predict": "\n\n*/\n\npublic class BindingSource {\n\t\n\tpublic static String getBindingSource(Object source) {\n\t\tif (source instanceof Class) {\n\t\t\treturn StackTraceElements.forType((Class) source).toString();\n\t\t} else if (source instanceof Member) {\n\t\t\treturn StackTraceElements.forMember((Member) source).toString();\n\t\t} else {\n\t\t\treturn source.toString();\n\t\t}\n\t}\n}\n"}, {"ID": 385, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause); if (!causes.containsKey(causeEquivalence)) { causes.put(causeEquivalence, thisIdx); fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause)); } else { int causeIdx = causes.get(causeEquivalence); fmt.format( \"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx); } } fmt.format(\"%n\"); } if (errorMessages.size() == 1) { fmt.format(\"1 error\"); } else { fmt.format(\"%s errors\", errorMessages.size()); } return fmt.toString(); } \nResponse:", "ground_truth": "Returns the formatted message for an exception with the specified messages.", "predict": " public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE"}, {"ID": 386, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message without a cause.\n\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Resp public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); } \n\n*/\n\npublic class Message {\n\tprivate String messageFormat;\n\tprivate Object[] arguments;\n\t\n\tpublic Message(String messageFormat, Object... arguments) {\n\t\tthis.messageFormat = messageFormat;\n\t\tthis.arguments = arguments;\n\t}\n\t\n\tpublic String getMessageFormat() {\n\t\treturn messageFormat;\n\t}\n\t\n\tpublic Object[] getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic static Message create(String messageFormat, Object... arguments) {\n\t\treturn new Message(messageFormat, arguments);\n\t}\n}\n"}, {"ID": 387, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(Throwable cause, String messageFormat, Object... arguments) { return create(cause, ImmutableList.of(), messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message with the given cause.\n\n@param cause The exception that caused the error\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Response.create(cause, ImmutableList.of(), messageFormat, arguments);\n\n*/\n\npublic class Response {\n    private final Throwable cause;\n    private final ImmutableList<Object> arguments;\n    private final String messageFormat;\n\n    public Response(Throwable cause, ImmutableList<Object> arguments, String messageFormat) {\n        this.cause = cause;\n        this.arguments = arguments;\n        this.messageFormat = messageFormat;\n    }\n\n    public static Response create(Throwable cause, ImmutableList<Object> arguments, String messageFormat, Object... arguments) {\n        return new Response(cause, arguments, messageFormat);\n    }\n\n    public Throwable getCause() {\n        return cause;\n    }\n\n    public ImmutableList<Object> getArguments() {\n        return arguments;\n    }\n\n    public String getMessageFormat() {\n        return messageFormat;\n    }\n}\n"}, {"ID": 388, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Message(sources, message, cause); } \nResponse:", "ground_truth": "Creates a new Message with the given cause and a binding source stack.\n\n@param cause The exception that caused the error\n@param sources The binding sources for the source stack\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Response is generated by the following java Code. Code: public static Response create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Response(sources, message, cause); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MessageFormat {\n\n    private static final String MESSAGE_PATTERN = \"\\\\{\\\\{(.*?)\\\\}\\\\}\";\n    private static final Pattern MESSAGE_PATTERN_PATTERN = Pattern.compile(MESSAGE_PATTERN);\n\n    private static final String MESSAGE_FORMAT_PATTERN = \"\\\\{\\\\{(.*?)\\\\"}, {"ID": 389, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object convert(Object o) { ElementSource source = null; if (o instanceof ElementSource) { source = (ElementSource) o; o = source.getDeclaringSource(); } return convert(o, source); } \nResponse:", "ground_truth": "Formats an object in a user friendly way.", "predict": " Response is generated by the method convert(Object o, ElementSource source)\n\n*/\n\npublic class Convert {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 390, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean shouldBeSkipped(String className) { return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className); } \nResponse:", "ground_truth": "Returns true if the className should be skipped.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassNameFilter {\n    private List<String> classNamesToSkip = new ArrayList<>();\n\n    public ClassNameFilter(String[] classNamesToSkip) {\n        for (String className : classNamesToSkip) {\n            this.classNamesToSkip.add(className);\n        }\n    }\n\n    public boolean shouldBeSkipped(String className) {\n        return classNamesToSkip.contains(className);\n    }\n}\n"}, {"ID": 391, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; } \nResponse:", "ground_truth": "Returns the non-skipped module class name.", "predict": " public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate"}, {"ID": 392, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\"); System.err.println(\"Then run 'jconsole' to connect.\"); System.exit(1); } Module module = (Module) Class.forName(args[0]).newInstance(); Injector injector = Guice.createInjector(module); manage(args[0], injector); System.out.println(\"Press Ctrl+C to exit...\"); // Sleep forever. Thread.sleep(Long.MAX_VALUE); } \nResponse:", "ground_truth": "Run with no arguments for usage instructions.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.servlet.GuiceServletContextListener;\nimport com.google.inject.servlet.ServletModule;\nimport com.sun.management.jmxremote.JMXServiceURL;\nimport com.sun.management.jmxremote.LocalConnectorServer;\nimport com.sun.management.jmxremote.NotificationListener;\nimport com.sun.management.jmxremote.NotificationListenerMBean;\nimport com.sun.management.jmxremote.NotificationSupport;\nimport com.sun.management.jmxremote.remote.JMXConnectorServer;\nimport com.sun.management.jmxremote.remote.JMXConnectorServerFactory;\nimport com.sun.management.jmxremote.remote.JMXServiceURL;\nimport com.sun.management.jmxremote"}, {"ID": 393, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Dependency<?> pushDependency(Dependency<?> dependency, Object source) { Dependency<?> previous = this.dependency; this.dependency = dependency; doPushState(dependency, source); return previous; } \nResponse:", "ground_truth": "Sets the new current dependency & adds it to the state.", "predict": " void pushState(Object source) { doPushState(null, source); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source"}, {"ID": 394, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); } \nResponse:", "ground_truth": "Adds to the state without setting the dependency.", "predict": " void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); } \n\n*/\n\npublic class PushState {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 395, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Initializable<T> of(final T instance) { return new Initializable<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; } \nResponse:", "ground_truth": "Returns an initializable for an instance that requires no initialization.", "predict": " Response<T> of(final T instance) { return new Response<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; } \n\n*/\n\npublic class Initializable<T> {\n\tprivate T instance;\n\t\n\tpublic Initializable(T instance) {\n\t\tthis.instance = instance;\n\t}\n\t\n\tpublic T get() {\n\t\treturn instance;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn String.valueOf(instance);\n\t}\n}\n\n/*\n\npublic class Response<T> {\n\tprivate T instance;\n\t\n\tpublic Response(T instance) {\n\t\tthis.instance = instance;\n\t}\n\t\n\tpublic T get() {\n\t\treturn instance;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn String.valueOf(instance);\n\t}\n}"}, {"ID": 396, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T provision( Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { T t = provider.get(); if (t == null && !dependency.isNullable()) { InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency); } constructionContext.setProxyDelegates(t); return t; } \nResponse:", "ground_truth": "Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as\nErrorsExceptions.", "predict": " Response<T> provision(Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { return Response.from(provider.get()); } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.jboss.weld.environment.se.Weld;\nimport org.jboss.weld.environment.se.WeldContainer;\nimport org.junit.Test;\n\nimport com.google.common.base.Optional;\n\npublic class TestProvisioning {\n\n\t@Test\n\tpublic void testProvisioning() {\n\t\tWeld weld = new Weld();\n\t\tWeldContainer container ="}, {"ID": 397, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } } \nResponse:", "ground_truth": "Dispatch events.\n\n@param type\n@param remoteAddr\n@param conn", "predict": " Response is generated by the following java Code. Code: public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ConnectionEventProcessor {\n\t\n\tprivate List<ConnectionEventProcessor> processors;\n\t\n\tpublic ConnectionEventProcessor() {\n\t\tprocessors = new ArrayList<ConnectionEventProcessor>();\n\t}\n\t\n\tpublic void addProcessor(ConnectionEventProcessor processor) {\n\t\tprocessors.add(processor);\n\t}\n\t\n\tpublic void onEvent(String remoteAddr, Connection conn) {\n\t\tfor (ConnectionEventProcessor processor : processors)"}, {"ID": 398, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList == null) { this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1)); processorList = this.processors.get(type); } processorList.add(processor); } \nResponse:", "ground_truth": "Add event processor.\n\n@param type\n@param processor", "predict": " void\n*/\n\npublic class ConnectionEventProcessor {\n\tprivate ConnectionEventType type;\n\tprivate ConnectionEventProcessor processor;\n\t\n\tpublic ConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) {\n\t\tthis.type = type;\n\t\tthis.processor = processor;\n\t}\n\t\n\tpublic ConnectionEventType getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic ConnectionEventProcessor getProcessor() {\n\t\treturn processor;\n\t}\n}\n"}, {"ID": 399, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) { T t = null; if (null != task) { try { t = task.getAfterRun(); } catch (InterruptedException e) { logger.error(\"Future task interrupted!\", e); } catch (ExecutionException e) { logger.error(\"Future task execute failed!\", e); } catch (FutureTaskNotRunYetException e) { logger.error(\"Future task has not run yet!\", e); } catch (FutureTaskNotCompleted e) { logger.error(\"Future task has not completed!\", e); } } return t; } \nResponse:", "ground_truth": "get the result of a future task\n\nNotice: the run method of this task should have been called at first.\n\n@param task\n@param \n@return", "predict": "\n\n*/\n\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class FutureTaskTest {\n    public static void main(String[] args) {\n        RunStateRecordedFutureTask<String> task = new RunStateRecordedFutureTask<String>(\"Hello World\");\n        System.out.println(task.getAfterRun());\n        System.out.println(task.getState());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecord"}, {"ID": 400, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void launderThrowable(Throwable t) { if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new IllegalStateException(\"Not unchecked!\", t); } } \nResponse:", "ground_truth": "launder the throwable\n\n@param t", "predict": "\n\npublic static void launderThrowable(Throwable t) {\n    if (t instanceof RuntimeException) {\n        throw (RuntimeException) t;\n    } else if (t instanceof Error) {\n        throw (Error) t;\n    } else {\n        throw new IllegalStateException(\"Not unchecked!\", t);\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LaunderThrowable {\n\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<String>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n"}, {"ID": 401, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); } \nResponse:", "ground_truth": "Register processor to process command that has the command code of cmdCode.\n\n@param cmdCode\n@param processor", "predict": " public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); } \n\n*/\n\npublic class CommandProcessorRegistry {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(CommandProcessorRegistry.class);\n\t\n\tprivate Map<CommandCode, RemotingProcessor<?>> cmd2processors = new HashMap<CommandCode, RemotingProcessor<?>>();\n\t\n\tpublic void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) {\n\t\tif (this.cmd2processors"}, {"ID": 402, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerDefaultProcessor(RemotingProcessor<?> processor) { if (this.defaultProcessor == null) { this.defaultProcessor = processor; } else { throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass()); } } \nResponse:", "ground_truth": "Register the default processor to process command with no specific processor registered.\n\n@param processor", "predict": " public void registerProcessor(RemotingProcessor<?> processor) { if (this.processors.containsKey(processor.getClass())) { throw new IllegalStateException(\"The processor has already been registered: \" + processor.getClass()); } this.processors.put(processor.getClass(), processor); } \nResp public void unregisterProcessor(RemotingProcessor<?> processor) { this.processors.remove(processor.getClass()); } \nResp public void unregisterDefaultProcessor(RemotingProcessor<?> processor) { this.defaultProcessor = null; } \nResp public void unregisterAllProcessors() { this.processors.clear(); } \nResp public void setDefaultProcessor(RemotingProcessor<?> processor) { this.defaultProcessor = processor; } \nResp public RemotingProcessor<?> getDefaultProcessor() { return this.defaultProcessor; } \nResp public RemotingProcessor"}, {"ID": 403, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RemotingProcessor<?> getProcessor(CommandCode cmdCode) { RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode); if (processor != null) { return processor; } return this.defaultProcessor; } \nResponse:", "ground_truth": "Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.\n\n@param cmdCode\n@return", "predict": " public Response<?> process(CommandCode cmdCode, Object... args) { Response<?> response = this.cmd2responses.get(cmdCode); if (response != null) { return response; } return this.defaultResponse; } \n\n*/\n\npublic class CommandProcessor {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(CommandProcessor.class);\n\t\n\tprivate static final String DEFAULT_COMMAND_PROCESSOR_CLASS = \"org.apache.commons.lang3.mutable.MutableInt\";\n\tprivate static final String DEFAULT_RESPONSE_PROCESSOR_CLASS = \"org.apache.commons.lang3.mutable.MutableInt\";\n\t\n\tprivate static final String DEFAULT_COMMAND_PROCESSOR_CLASS_NAME = \"org.apache.commons.lang3.mutable.MutableInt\";\n\tprivate static final String DE"}, {"ID": 404, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); } \nResponse:", "ground_truth": "try get from cache\n\n@param url\n@return", "predict": " private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.tryGet(\"http://www.google.com/\"));\n    }\n    \n    public Url tryGet(String url) {\n        return Url.parsedUrls.get(url);\n    }\n}\n\nclass Url {\n    public static HashMap<String, SoftReference<Url>> parsedUrls = new HashMap<String, SoftReference<Url>>();\n    \n    public static void addUrl(String url, Url parsedUrl) {\n        parsedUrls.put(url, new SoftReference<Url>(parsedUrl));"}, {"ID": 405, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ProtocolCode decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; } \nResponse:", "ground_truth": "decode the protocol code\n\n@param in input byte buf\n@return an instance of ProtocolCode", "predict": " Generate the method-level comment for the following java Code. Code: public void encodeProtocolCode(ByteBuf out, ProtocolCode protocolCode) { if (protocolCode != null) { out.writeBytes(protocolCode.toBytes()); } } \nResp Generate the method-level comment for the following java Code. Code: public void decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; } \n */\n\npublic class ProtocolCode {\n    public static final int protocolCodeLength = 1;\n    public static final byte PROTOCOL_CODE_RESPONSE = 0x00;\n    public static final byte PROTOCOL_CODE_REQUEST = 0x01;\n    public static final byte PROTOCOL_"}, {"ID": 406, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> getAll() { Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>(); Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this .getConnPools().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); if (null != pool) { allConnections.put(entry.getKey(), pool.getAll()); } } return allConnections; } \nResponse:", "ground_truth": "Get all connections of all poolKey.\n\n@return a map with poolKey as key and a list of connections in ConnectionPool as value", "predict": " Response = Response.ok().entity(allConnections).build();\n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.ListenableScheduledFuture;\nimport com.google.common.util.concurrent.ListeningScheduledExecutorService;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.common.util.concurrent.SettableFuture;\n\npublic class ConnectionPool {\n\tprivate static final Logger logger = Logger.getLogger(ConnectionPool.class);\n\tprivate static final ListeningScheduledExecutorService executor"}, {"ID": 407, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void scan() { if (null != this.connTasks && !this.connTasks.isEmpty()) { Iterator<String> iter = this.connTasks.keySet().iterator(); while (iter.hasNext()) { String poolKey = iter.next(); ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey)); if (null != pool) { pool.scan(); if (pool.isEmpty()) { if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) { iter.remove(); logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey); } } } } } } \nResponse:", "ground_truth": "in case of cache pollution and connection leak, to do schedule scan\n\n@see com.alipay.remoting.Scannable#scan()", "predict": "\n\n*/\n\npackage com.taobao.tddl.dbsync.binlog.event;\n\nimport com.taobao.tddl.dbsync.binlog.LogBuffer;\n\n/**\n * @author <a href=\"mailto:changyuan.lh@taobao.com\">Changyuan.lh</a>\n * @version 1.0\n */\npublic final class QueryLogHeader extends LogHeader {\n\n    public QueryLogHeader(LogHeader header) {\n        super(header);\n    }\n\n    public QueryLogHeader(LogBuffer buffer) {\n        super(buffer);\n    }\n\n    @Override\n    public final LogHeaderType getHeaderType() {\n        return LogHeaderType.QUERY_EVENT;\n    }\n\n}\n"}, {"ID": 408, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\n\n@see ConnectionManager#getAndCreateIfAbsent(Url)", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss.netty.channel.socket"}, {"ID": 409, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\nIf task cached, check whether the number of connections adequate, if not then heal it.\n\n@param url\n@return\n@throws InterruptedException\n@throws RemotingException", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss.netty.channel.socket"}, {"ID": 410, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeTask(String poolKey) { RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey); if (null != task) { ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger); if (null != pool) { pool.removeAllAndTryClose(); } } } \nResponse:", "ground_truth": "remove task and remove all connections\n\n@param poolKey", "predict": " void\n*/\n\npublic class RemoveTask implements Runnable {\n    private final String poolKey;\n    private final Logger logger;\n\n    public RemoveTask(String poolKey, Logger logger) {\n        this.poolKey = poolKey;\n        this.logger = logger;\n    }\n\n    @Override\n    public void run() {\n        try {\n            removeTask(poolKey);\n        } catch (Exception e) {\n            logger.error(\"Failed to remove task for poolKey: \" + poolKey, e);\n        }\n    }\n}\n"}, {"ID": 411, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException { String poolKey = url.getUniqueKey(); // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) { FutureTask<Integer> task = this.healTasks.get(poolKey); if (null == task) { task = new FutureTask<Integer>(new HealConnectionCall(url, pool)); task = this.healTasks.putIfAbsent(poolKey, task); if (null == task) { task = this.healTasks.get(poolKey); task.run(); } } try { int numAfterHeal = task.get(); if (logger.isDebugEnabled()) { logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup()); } } catch (InterruptedException e) { this.healTasks.remove(poolKey); throw e; } catch (ExecutionException e) { this.healTasks.remove(poolKey); Throwable cause = e.getCause(); if (cause instanceof RemotingException) { throw (RemotingException) cause; } else { FutureTaskUtil.launderThrowable(cause); } } // heal task is one-off, remove from cache directly after run this.healTasks.remove(poolKey); } } \nResponse:", "ground_truth": "execute heal connection tasks if the actual number of connections in pool is less than expected\n\n@param pool\n@param url", "predict": "\npublic class Response {\npublic static final int SUCCESS = 0;\npublic static final int FAILURE = 1;\npublic static final int RETRY = 2;\npublic static final int RETRY_IMMEDIATELY = 3;\npublic static final int RETRY_IN_TIME = 4;\npublic static final int RETRY_IN_TIMEOUT = 5;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY = 6;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IMMEDIATELY = 7;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIME = 8;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIMEOUT = 9;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIMEOUT_AND_RETRY = 10;\npublic static final int RETRY_IN"}, {"ID": 412, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException { final int actualNum = pool.size(); final int expectNum = url.getConnNum(); if (actualNum < expectNum) { if (logger.isDebugEnabled()) { logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName); } if (url.isConnWarmup()) { for (int i = actualNum; i < expectNum; ++i) { Connection connection = create(url); pool.add(connection); } } else { if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) { throw new IllegalArgumentException( \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\"); } // create connection in sync way if (syncCreateNumWhenNotWarmup > 0) { for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) { Connection connection = create(url); pool.add(connection); } if (syncCreateNumWhenNotWarmup == url.getConnNum()) { return; } } // initialize executor in lazy way initializeExecutor(); pool.markAsyncCreationStart();// mark the start of async try { this.asyncCreateConnectionExecutor.execute(new Runnable() { @Override public void run() { try { for (int i = pool.size(); i < url.getConnNum(); ++i) { Connection conn = null; try { conn = create(url); } catch (RemotingException e) { logger .error( \"Exception occurred in async create connection thread for {}, taskName {}\", url.getUniqueKey(), taskName, e); } pool.add(conn); } } finally { pool.markAsyncCreationDone();// mark the end of async } } }); } catch (RejectedExecutionException e) { pool.markAsyncCreationDone();// mark the end of async when reject throw e; } } // end of NOT warm up } // end of if } \nResponse:", "ground_truth": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport com.alibaba.dubbo.common.URL;\nimport com.alibaba.dubbo.remoting.Channel;\nimport com.alibaba.dubbo.remoting.ChannelHandler;\nimport com.alibaba.dubbo.remoting.RemotingException;\nimport com.alibaba.dubbo.remoting.transport.AbstractClient;\n\nimport org.jboss.netty.channel.ChannelFactory;\nimport org.jboss.netty.channel.ChannelPipeline;\nimport org.jboss.netty.channel.ChannelPipelineFactory;\nimport org.jboss.netty.channel.Channels;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n\nimport java.net.InetSocketAddress;\nimport java"}, {"ID": 413, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void closeConnection(String addr) { Url url = this.addressParser.parse(addr); this.connectionManager.remove(url.getUniqueKey()); } \nResponse:", "ground_truth": "Close all connections of a address\n\n@param addr", "predict": " Response = this.connectionManager.get(url.getUniqueKey()); \n\n*/\n\npublic class ConnectionManager {\n\tprivate static final Logger logger = Logger.getLogger(ConnectionManager.class);\n\tprivate static final String CONNECTION_MANAGER_NAME = \"ConnectionManager\";\n\tprivate static final String CONNECTION_MANAGER_DESCRIPTION = \"Manages the connections to the database\";\n\tprivate static final String CONNECTION_MANAGER_VERSION = \"1.0\";\n\tprivate static final String CONNECTION_MANAGER_AUTHOR = \"Saravanan R\";\n\tprivate static final String CONNECTION_MANAGER_EMAIL = \"saravanan.r@gmail.com\";\n\tprivate static final String CONNECTION_MANAGER_WEBSITE = \"http://www.saravanan.in\";\n\tprivate static final String CONNECTION_MANAGER_LICENSE ="}, {"ID": 414, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } } \nResponse:", "ground_truth": "Do something when closing.", "predict": " public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } } \n\n*/\n"}, {"ID": 415, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } } \nResponse:", "ground_truth": "Close the connection.", "predict": "\npublic void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } } \n\n*/\n"}, {"ID": 416, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); } \nResponse:", "ground_truth": "set attribute if key absent.\n\n@param key\n@param value\n@return", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 417, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (processor instanceof MultiInterestUserProcessor) { registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors); } else { if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register single-interest user processor.\n\n@param processor  the processor need to be registered\n@param userProcessors   the map of user processors", "predict": " public static void registerUserProcessor(MultiInterestUserProcessor processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } \n\n*/\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.thrift.TException;\nimport org.apache.thrift"}, {"ID": 418, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) { throw new RuntimeException(\"Processor interest should not be blank!\"); } for (String interest : processor.multiInterest()) { UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register multi-interest user processor.\n\n@param processor  the processor with multi-interest need to be registered\n@param userProcessors    the map of user processors", "predict": "\n\n*/\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TFramedTransport;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\n\nimport com.twitter.heron.api.generated.TopologyAPI;\nimport com.twitter.heron.api.utils.TopologyUtils;\nimport com.twitter.heron.common.basics.ByteAmount;\nimport com.twitter.heron.common.basics.SysUtils;"}, {"ID": 419, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) { final int id = cmd.getId(); final byte type = cmd.getType(); // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass()); if (processor instanceof AsyncUserProcessor) { try { processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject()); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } else { try { Object responseObject = processor .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), cmd.getRequestObject()); sendResponseIfNecessary(ctx, type, this.getCommandFactory().createResponse(responseObject, cmd)); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } } \nResponse:", "ground_truth": "dispatch request command to user processor\n@param ctx remoting context\n@param cmd rpc request command", "predict": "\n\n*/\n\npublic class RpcRequestProcessor implements AsyncProcessor<RpcRequestCommand, RpcResponseCommand> {\n\n    private static final Logger logger = LoggerFactory.getLogger(RpcRequestProcessor.class);\n\n    private final RpcCommandFactory commandFactory;\n\n    private final AsyncProcessor<RpcRequestCommand, RpcResponseCommand> processor;\n\n    public RpcRequestProcessor(RpcCommandFactory commandFactory, AsyncProcessor<RpcRequestCommand, RpcResponseCommand> processor) {\n        this.commandFactory = commandFactory;\n        this.processor = processor;\n    }\n\n    @Override\n    public RpcResponseCommand process(RpcRequestCommand request) throws Exception {\n        RpcResponseCommand response = null;\n        try {\n            response = processor.process(request);\n        } catch (Exception e) {\n            logger.error(\"process rpc request failed, request={}\", request, e"}, {"ID": 420, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) { boolean result; try { cmd.deserialize(level); result = true; } catch (DeserializationException e) { logger .error( \"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e)); result = false; } catch (Throwable t) { String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" + cmd.getId() + \", deserializeLevel=\" + level; logger.error(errMsg, t); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), t, errMsg)); result = false; } return result; } \nResponse:", "ground_truth": "deserialize request command\n\n@return true if deserialize success; false if exception catched", "predict": "\n    public static class Response {\n        private final RpcResponseCommand cmd;\n        private final RpcResponseStatus status;\n        private final String errMsg;\n        public Response(RpcResponseCommand cmd, RpcResponseStatus status, String errMsg) {\n            this.cmd = cmd;\n            this.status = status;\n            this.errMsg = errMsg;\n        }\n        public RpcResponseCommand getCmd() {\n            return cmd;\n        }\n        public RpcResponseStatus getStatus() {\n            return status;\n        }\n        public String getErrMsg() {\n            return errMsg;\n        }\n    }\n    public static class ResponseStatus {\n        public static final RpcResponseStatus SUCCESS = new RpcResponseStatus(0, \"Success\");\n        public static final RpcResponseStatus FAILURE = new RpcResponseStatus(1, \"Failure\");\n        public static final RpcResponseStatus SERVER_DESER"}, {"ID": 421, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); } \nResponse:", "ground_truth": "pre process remoting context, initial some useful infos and pass to biz\n\n@param ctx remoting context\n@param cmd rpc request command\n@param currentTimestamp current timestamp", "predict": " private void processRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); } \n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.j"}, {"ID": 422, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } \nResponse:", "ground_truth": "print some log when request timeout and discarded in io thread.", "predict": "\n    public void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{"}, {"ID": 423, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } } \nResponse:", "ground_truth": "print some debug log when receive request", "predict": " Generate the method-level comment for the following java Code. Code: private void debugLog(RemotingContext ctx, RpcResponseCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc response received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } } \n */\n\npublic class RpcRequestCommand extends RpcCommand {\n    private static final long serialVersionUID = -828379842290987908L;\n\n    private String methodName;\n    private Object[] args;\n    private long arriveTime;\n    private long timeout;\n\n    "}, {"ID": 424, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } } \nResponse:", "ground_truth": "Process the remoting command with its own executor or with the defaultExecutor if its own if null.\n\n@param ctx\n@param msg\n@param defaultExecutor\n@throws Exception", "predict": " Generate the method-level comment for the following java Code. Code: @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } } \n */\n\npublic class ProcessTask implements Runnable {\n\tprivate RemotingContext ctx;\n\tprivate Object msg;\n\tprivate ExecutorService defaultExecutor;\n\t\n\tpublic ProcessTask(RemotingContext ctx, Object msg) {\n\t\tthis.ctx = ctx;\n\t\tthis.msg = msg;\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tthis.ctx.getProcessor().process(this.ctx, this.msg);\n\t\t} catch (Exception e) {\n\t\t\tthis.ctx.getProcessor()."}, {"ID": 425, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), invokeCallback); conn.addInvokeFuture(future); final int requestId = request.getId(); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(requestId); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn .getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture cf) throws Exception { if (!cf.isSuccess()) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse( conn.getRemoteAddress(), cf.cause())); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause()); } } }); } catch (Exception e) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e)); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } \nResponse:", "ground_truth": "Invocation with callback.\n\n@param conn\n@param request\n@param invokeCallback\n@param timeoutMillis\n@throws InterruptedException", "predict": " public void invokeAsync(final Connection conn, final RemotingCommand request, final long timeoutMillis) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException, RemotingTooMuchRequestException, RemotingExecuteException { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), null); conn.addInvokeFuture(future); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(request.getId()); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn.getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFuture"}, {"ID": 426, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } } \nResponse:", "ground_truth": "Oneway invocation.\n\n@param conn\n@param request\n@throws InterruptedException", "predict": " public void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } } \n\n*/\n"}, {"ID": 427, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; } \nResponse:", "ground_truth": "from bit set to byte\n@param bs\n@return byte represent the bit set", "predict": "\n\npublic static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; } \n\n*/\n\nimport java.util.BitSet;\n\npublic class Solution {\n    public static byte toByte(BitSet bs) {\n        int value = 0;\n        for (int i = 0; i < bs.length(); ++i) {\n            if (bs.get(i)) {\n                value += 1 << i;\n            }\n        }\n"}, {"ID": 428, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; } \nResponse:", "ground_truth": "from byte to bit set\n@param value\n@return bit set represent the byte", "predict": "\n\npublic static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; } \n\n*/\n\nimport java.util.BitSet;\n\npublic class Solution {\n    public static BitSet toBitSet(int value) {\n        BitSet bs = new BitSet();\n        int index = 0;\n        while (value != 0) {\n            if (value % 2 != 0) {\n                bs.set("}, {"ID": 429, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); } \nResponse:", "ground_truth": "add reconnect task\n\n@param url", "predict": " public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); } \n\n*/\n\npublic class ReconnectTask extends Task {\n\tprivate Url url;\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\turl.reconnect();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void setUrl(Url url) {\n\t\tthis.url = url;\n\t}\n}\n"}, {"ID": 430, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop() { if (!this.started) { return; } this.started = false; healConnectionThreads.interrupt(); this.tasks.clear(); this.canceled.clear(); } \nResponse:", "ground_truth": "stop reconnect thread", "predict": "\n\n*/\n\npublic class Stop extends AbstractInstruction {\n\t\n\tpublic Stop(String name, String description) {\n\t\tsuper(name, description);\n\t}\n\t\n\t@Override\n\tpublic void execute(Context context) {\n\t\t\n\t\t// Get the connection\n\t\tConnection connection = context.getConnection();\n\t\t\n\t\t// Get the thread\n\t\tThread thread = context.getThread();\n\t\t\n\t\t// Get the task\n\t\tTask task = context.getTask();\n\t\t\n\t\t// Get the canceled\n\t\tSet<Task> canceled = context.getCanceled();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t//"}, {"ID": 431, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException { RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request); if (null != invokeContext) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER); if (null != clientCustomSerializer) { try { command.setSerializer((Byte) clientCustomSerializer); } catch (ClassCastException e) { throw new IllegalArgumentException( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\"); } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE); if (null != crcSwitch && crcSwitch) { command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } } else { // enable crc by default, if there is no invoke context. command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } command.setTimeout(timeoutMillis); command.setRequestClass(request.getClass().getName()); command.setInvokeContext(invokeContext); command.serialize(); logDebugInfo(command); return command; } \nResponse:", "ground_truth": "Convert application request object to remoting request command.\n\n@param request\n@param conn\n@param timeoutMillis\n@return\n@throws CodecException", "predict": " public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, null); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object arg) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, new Object[] { arg }); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object[] args) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, args, null); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object[] args, final Object arg) throws InterruptedException, Rem"}, {"ID": 432, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> filter(List<Connection> connections) { List<Connection> serviceOnConnections = new ArrayList<Connection>(); List<Connection> serviceOffConnections = new ArrayList<Connection>(); Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>(); for (Connection connection : connections) { String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS); if (serviceStatus != null) { if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) { serviceOffConnections.add(connection); } } else { serviceOnConnections.add(connection); } } filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections); filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections); return filteredConnections; } \nResponse:", "ground_truth": "Filter connections to monitor\n\n@param connections", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec."}, {"ID": 433, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) { try { if (null != connPools && !connPools.isEmpty()) { Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools .entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter .next(); String poolKey = entry.getKey(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); List<Connection> connections = pool.getAll(); Map<String, List<Connection>> filteredConnectons = this.filter(connections); List<Connection> serviceOnConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_ON); List<Connection> serviceOffConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_OFF); if (serviceOnConnections.size() > CONNECTION_THRESHOLD) { Connection freshSelectConnect = serviceOnConnections.get(random .nextInt(serviceOnConnections.size())); freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF); Connection lastSelectConnect = freshSelectConnections.remove(poolKey); freshSelectConnections.put(poolKey, freshSelectConnect); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } else { if (freshSelectConnections.containsKey(poolKey)) { Connection lastSelectConnect = freshSelectConnections.remove(poolKey); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } if (logger.isInfoEnabled()) { logger .info( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD); } } for (Connection offConn : serviceOffConnections) { if (offConn.isFine()) { offConn.close(); } } } } } catch (Exception e) { logger.error(\"ScheduledDisconnectStrategy monitor error\", e); } } \nResponse:", "ground_truth": "Monitor connections and close connections with status is off\n\n@param connPools", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel"}, {"ID": 434, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException { if (null != lastSelectConnect) { if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { Thread.sleep(RETRY_DETECT_PERIOD); if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { if (logger.isInfoEnabled()) { logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel())); } } } } } \nResponse:", "ground_truth": "close the connection of the fresh select connections\n\n@param lastSelectConnect\n@param serviceOffConnections\n@throws InterruptedException", "predict": "\n    public void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException {\n        if (null != lastSelectConnect) {\n            if (lastSelectConnect.isInvokeFutureMapFinish()) {\n                serviceOffConnections.add(lastSelectConnect);\n            } else {\n                Thread.sleep(RETRY_DETECT_PERIOD);\n                if (lastSelectConnect.isInvokeFutureMapFinish()) {\n                    serviceOffConnections.add(lastSelectConnect);\n                } else {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel()));\n                    }\n                }\n            }\n        }\n    }\n    \n    public void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws Interrupted"}, {"ID": 435, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean getBool(String key, String defaultValue) { return Boolean.parseBoolean(System.getProperty(key, defaultValue)); } \nResponse:", "ground_truth": "~~~ public helper methods to retrieve system property", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 436, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void infoLog(String format, String addr) { if (logger.isInfoEnabled()) { if (StringUtils.isNotEmpty(addr)) { logger.info(format, addr); } else { logger.info(format, \"UNKNOWN-ADDR\"); } } } \nResponse:", "ground_truth": "print info log\n@param format\n@param addr", "predict": "\n\n*/\n\npublic class Logger {\n    private static final String TAG = \"Logger\";\n    private static final String LOG_TAG = \"Logger\";\n    private static final String LOG_TAG_PREFIX = \"Logger\";\n    private static final String LOG_TAG_PREFIX_PREFIX = \"Logger_\";\n    private static final String LOG_TAG_PREFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX = \"Logger\";\n    private static final String LOG_TAG_POSTFIX_PREFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String"}, {"ID": 437, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isRequestTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; } \nResponse:", "ground_truth": "whether this request already timeout\n\n@return", "predict": " public boolean isResponseTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.RESPONSE_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; } \n\n*/\n\npublic class RpcCommand {\n\t\n\tprivate RpcCommandType rpcCommandType;\n\tprivate String rpcCommand;\n\tprivate String rpcCommandArguments;\n\tprivate long arriveTimestamp;\n\tprivate long timeout;\n\t\n\tpublic RpcCommand(RpcCommandType rpcCommandType, String rpcCommand, String rpcCommandArguments, long arriveTimestamp, long timeout) {\n\t\tthis.rpcCommandType = rpcCommandType;\n\t\tthis.rpcCommand = rpcCommand;\n\t\tthis.rpcCommandArguments = rpcCommandArguments;\n\t\tthis.arriveTimestamp ="}, {"ID": 438, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public UserProcessor<?> getUserProcessor(String className) { return StringUtils.isBlank(className) ? null : this.userProcessors.get(className); } \nResponse:", "ground_truth": "Get user processor for class name.\n\n@param className\n@return", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 439, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; } \nResponse:", "ground_truth": "get one connection randomly\n\n@param conns\n@return", "predict": " private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class RandomGet {\n\t\n\tprivate static final int MAX_TIMES = 100;\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tList<Connection> conns = new ArrayList<Connection>();\n\t\t\n\t\tconns.add(new Connection(\"1\", \"2\"));\n\t\t"}, {"ID": 440, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; } \nResponse:", "ground_truth": "get and use default if not found\n\n@param key\n@param defaultIfNotFound\n@param \n@return", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 441, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getProperty(String key) { if (properties == null) { return null; } return properties.getProperty(key); } \nResponse:", "ground_truth": "Get property value according to property key\n\n@param key\n@return property value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 442, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException { preProcess(responseCommand, addr); if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return toResponseObject(responseCommand); } else { String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId()); logger.warn(msg); if (responseCommand.getCause() != null) { throw new InvokeException(msg, responseCommand.getCause()); } else { throw new InvokeException(msg + \", please check the server log for more.\"); } } } \nResponse:", "ground_truth": "Analyze the response command and generate the response object.\n\n@param responseCommand response command\n@param addr response address\n@return response object", "predict": " public static Object toResponseObject(ResponseCommand responseCommand) { if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return responseCommand.getResult(); } else { return responseCommand.getCause(); } } \n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.reflect.MethodUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.serializer.SerializerFeature.WriteMapNullValue;\nimport com.alibaba.fastjson.serial"}, {"ID": 443, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); } \nResponse:", "ground_truth": "Convert remoting response command to application response object.", "predict": " private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonDeserializationContext;\nimport com.google.gson.JsonDeserializer;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParseException;\nimport com.google.gson.JsonPrimitive;\nimport"}, {"ID": 444, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; } \nResponse:", "ground_truth": "Convert remoting response command to throwable if it is a throwable, otherwise return null.", "predict": " Generate the method-level comment for the following java Code. Code: private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.Collections;\nimport java.util.BitSet;\nimport java.util.Arrays;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.LinkedHashMap;\nimport java.util."}, {"ID": 445, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } } \nResponse:", "ground_truth": "Detail your error msg with the error msg returned from response command", "predict": " Generate the method-level comment for the following java Code. Code: private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } } \n */\n\npublic class RpcResponseCommand {\n    private String errorMsg;\n    private String errorCode;\n    private String errorCodeDesc;\n    private String errorCodeDetail;\n    private String errorCodeDetailDesc;\n    private String errorCodeDetailCode;\n    private String errorCodeDetailCodeDesc;\n    private String errorCodeDetailCodeDescCode;\n    private String errorCodeDetailCodeDescCode"}, {"ID": 446, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; } \nResponse:", "ground_truth": "create server exception using error msg and fill the stack trace using the stack trace of throwable.\n\n@param t the origin throwable to fill the stack trace of rpc server exception\n@param errMsg additional error msg, null is allowed\n@return an instance of RpcServerException", "predict": " public RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; } \n\n}\n"}, {"ID": 447, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } } \nResponse:", "ground_truth": "print trace log\n@param traceId\n@param invokeContext", "predict": " public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } } \n\n*/\n"}, {"ID": 448, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) { return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory); } \nResponse:", "ground_truth": "Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.\n\n@param nThreads\n@param threadFactory\n@return an EventLoopGroup suitable for the current platform", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool(new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread t = new Thread(r);\n                t.setDaemon(true);\n                return t;\n            }\n        });\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello World\");\n            }\n        });\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.SECONDS);\n"}, {"ID": 449, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the remote address of the channel.\n\n@param channel\n@return", "predict": " public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); } \n\n*/\n\npublic class RemoteAddressParser {\n    public static final String REMOTE_ADDRESS_PATTERN = \"^(\\\\w+\\\\.\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+|\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+|\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+|\\\\w+\\\\"}, {"ID": 450, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the local address of the channel.\n\n@param channel\n@return", "predict": " public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); } \n\n*/\n\npublic class ChannelLocalAddressParser extends AbstractParser {\n\n    public ChannelLocalAddressParser() {\n        super();\n    }\n\n    @Override\n    public String parse(String channel) {\n        if (null == channel) {\n            return StringUtils.EMPTY;\n        }\n        final SocketAddress local = channel.localAddress();\n        return local != null ? local.toString().trim() : StringUtils.EMPTY;\n    }\n\n}\n"}, {"ID": 451, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote host ip of the channel.\n\n@param channel\n@return", "predict": " Generate the method-level comment for the following java Code. Code: public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \n */\n\npublic class RemoteIP {\n    public static void main(String[] args) {\n        String ip = \"\";\n        try {\n            ip = InetAddress.getLocalHost().getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        System.out.println(ip);\n    }\n}\n"}, {"ID": 452, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote hostname of the channel.\n\nNote: take care to use this method, for a reverse name lookup takes uncertain time in {@link InetAddress#getHostName}.\n\n@param channel\n@return", "predict": " Generate the method-level comment for the following java Code. Code: public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; } \n */\n\npublic class RemoteHostName {\n    public static void main(String[] args) {\n        String hostName = \"\";\n        try {\n            hostName = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        System.out.println(hostName);\n    }\n}\n"}, {"ID": 453, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the local host ip of the channel.\n\n@param channel\n@return", "predict": " public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LocalIP {\n\tpublic static void main(String[] args) {\n\t\tString ip = \"192.168.1.1\";\n\t\tString ip2 = \"192.168.1.1\";\n\t\tString ip3 = \"192.168.1.1\";\n\t\tString ip4 = \"192.168.1.1\";\n\t\tString ip5 = \"192.168.1.1\";\n\t\tString ip6 = \"192.168.1.1\";\n\t\tString ip7 = \""}, {"ID": 454, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the remote host port of the channel.\n\n@param channel\n@return int", "predict": " public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; } \n */\n\npublic class Solution {\n    public static int parseRemotePort(final Channel channel) {\n        if (null == channel) {\n            return -1;\n        }\n        final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress();\n        if (remote != null) {\n            return remote.getPort();\n        }\n        return -1;\n    }\n}\n"}, {"ID": 455, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the local host port of the channel.\n\n@param channel\n@return int", "predict": " public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; } \n */\n\npublic class Solution {\n    public static int parseLocalPort(final Channel channel) {\n        if (null == channel) {\n            return -1;\n        }\n        final InetSocketAddress local = (InetSocketAddress) channel.localAddress();\n        if (local != null) {\n            return local.getPort();\n        }\n        return -1;\n    }\n}\n"}, {"ID": 456, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseSocketAddressToHostIp(SocketAddress socketAddress) { final InetSocketAddress addrs = (InetSocketAddress) socketAddress; if (addrs != null) { InetAddress addr = addrs.getAddress(); if (null != addr) { return addr.getHostAddress(); } } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the host ip of socket address.\n\ne.g. /127.0.0.1:1234 -> 127.0.0.1\n\n@param socketAddress\n@return String", "predict": "\n\n*/\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SocketAddressToHostIp {\n\n    public static void main(String[] args) {\n        SocketAddress socketAddress = new InetSocketAddress(\"localhost\", 8080);\n        System.out.println(parseSocketAddressToHostIp(socketAddress));\n    }\n\n    public static String parseSocketAddressToHostIp(SocketAddress socketAddress) {\n        if (socketAddress == null) {\n            return \"\";\n        }\n        if (socketAddress instanceof InetSocketAddress) {\n            InetSocketAddress addrs = (InetSocketAddress) socketAddress;\n            if (addrs != null) {\n                InetAddress addr = addrs.getAddress();\n                if (addr != null) {\n                    return addr.getHostAddress();\n                "}, {"ID": 457, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.addIfAbsent(connection); if (res) { connection.increaseRef(); } } \nResponse:", "ground_truth": "add a connection\n\n@param connection", "predict": " public void remove(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } } \nResp public void remove(Connection connection, boolean force) { markAccess(); if (null == connection) { return; } boolean res = this.conns.remove(connection, force); if (res) { connection.decreaseRef(); } } \nResp public void removeAll(Collection<Connection> connections) { markAccess(); if (null == connections) { return; } for (Connection connection : connections) { this.remove(connection); } } \nResp public void removeAll(Collection<Connection> connections, boolean force) { markAccess(); if (null == connections) { return; } for (Connection connection : connections) { this.remove(connection, force); } } \nResp public void clear() { markAccess(); this.conns.clear"}, {"ID": 458, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } } \nResponse:", "ground_truth": "removeAndTryClose a connection\n\n@param connection", "predict": " public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n    \n    public void test() {\n        Connection conn1 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn2 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn3 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn4 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn5 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn"}, {"ID": 459, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Connection get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } } \nResponse:", "ground_truth": "get a connection\n\n@return", "predict": " Response is generated by the following java Code. Code: public Response get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        List<Connection> conns = new ArrayList<Connection>();\n        conns.add(new Connection(\"a\", \"b\"));\n        conns.add(new Connection(\"a\", \"c\"));\n        conns.add(new Connection(\"b\", \"c\"));\n        conns.add(new Connection(\"c\", \"d\"));\n        conns.add(new"}, {"ID": 460, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(String className, CustomSerializer serializer) { CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for class name.\n\n@param className\n@param serializer\n@return", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CustomSerializer {\n    private static Map<String, CustomSerializer> customSerializerMap = new HashMap<String, CustomSerializer>();\n\n    public static void registerCustomSerializer(String className, CustomSerializer customSerializer) {\n        customSerializerMap.put(className, customSerializer);\n    }\n\n    public static CustomSerializer getCustomSerializer(String className) {\n        return customSerializerMap.get(className);\n    }\n}\n"}, {"ID": 461, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(String className) { if (!classCustomSerializer.isEmpty()) { return classCustomSerializer.get(className); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for class name.\n\n@param className\n@return", "predict": " Response = Response.ok(CustomSerializer.getCustomSerializer(className)).build();\n\n*/\n\npublic class CustomSerializer {\n\t\n\tprivate static final Logger logger = Logger.getLogger(CustomSerializer.class);\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE = \"com.fasterxml.jackson.databind.ser.std.ToStringSerializer\";\n\tprivate static final String CUSTOM_SERIALIZER_CLASS = \"ToStringSerializer\";\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE_NAME = \"com.fasterxml.jackson.databind.ser.std.ToStringSerializer\";\n\tprivate static final String CUSTOM_SERIALIZER_CLASS_NAME = \"ToStringSerializer\";\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE_NAME_"}, {"ID": 462, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) { CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for command code.\n\n@param code\n@param serializer\n@return", "predict": " ResponseCode.SUCCESS\n*/\n\npublic class CommandSerializer {\n    private static final Logger logger = LoggerFactory.getLogger(CommandSerializer.class);\n\n    private static final Map<CommandCode, CustomSerializer> customSerializers = new HashMap<>();\n\n    public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) {\n        customSerializers.put(code, serializer);\n    }\n\n    public static ResponseCode serialize(CommandCode code, Object command) {\n        if (code == null) {\n            return ResponseCode.INVALID_COMMAND_CODE;\n        }\n\n        if (command == null) {\n            return ResponseCode.INVALID_COMMAND_OBJECT;\n        }\n\n        CustomSerializer serializer = customSerializers.get(code);\n        if (serializer == null) {\n            return ResponseCode.UNSUPPORTED_COMMAND_"}, {"ID": 463, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(CommandCode code) { if (!commandCustomSerializer.isEmpty()) { return commandCustomSerializer.get(code); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for command code.\n\n@param code\n@return", "predict": " ResponseCode = 0, if the method is successfully executed. Otherwise, ResponseCode = -1, ResponseMessage = Error Message.\n*/\n\npublic class CommandSerializer {\n    private static final Logger logger = LoggerFactory.getLogger(CommandSerializer.class);\n    private static final String COMMAND_SERIALIZER_CLASS_NAME = \"CommandSerializer\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_PREFIX = \"CommandSerializer_\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_SUFFIX = \"CommandSerializer\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_PREFIX_WITH_SUFFIX = COMMAND_SERIALIZER_CLASS_NAME_PREFIX + COMMAND_SERIALIZER_CLASS_NAME_SUFFIX;\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_"}, {"ID": 464, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager.conn_monitor_initial_delay(); /** period of schedule task, unit: ms*/ long period = ConfigManager.conn_monitor_period(); this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy()); MonitorTask monitorTask = new MonitorTask(); this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS); } \nResponse:", "ground_truth": "Start schedule task", "predict": "\n\n*/\n\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionMonitorTask implements Runnable {\n\tprivate ScheduledExecutorService executor;\n\tprivate ScheduledFuture<?> monitorTask;\n\t\n\tpublic ConnectionMonitorTask() {\n\t\texecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"ConnectionMonitorThread\", true));\n\t}\n\t\n\tpublic void start() {\n\t\tmonitorTask = executor.scheduleAtFixedRate(this, ConfigManager.conn_monitor_initial_delay(), ConfigManager.conn_monitor_period(), TimeUnit.MILLISECONDS);\n\t}\n\t\n\tpublic void stop() {\n\t\tmonitorTask.cancel(true);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n"}, {"ID": 465, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isConnected(String remoteAddr) { Url url = this.rpcRemoting.addressParser.parse(remoteAddr); return this.isConnected(url); } \nResponse:", "ground_truth": "check whether a client address connected\n\n@param remoteAddr\n@return", "predict": " public boolean isConnected(Url url) { return this.rpcRemoting.isConnected(url); } \n*/\n\npublic class RpcRemoting {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(RpcRemoting.class);\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_FILE = \"rpc-remoting.properties\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_PREFIX = \"rpc.remoting.\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_SERVER_LIST = RPC_REMOTING_CONFIG_KEY_PREFIX + \"server.list\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_SERVER_LIST_SEPARATOR = \",\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_"}, {"ID": 466, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void initWriteBufferWaterMark() { int lowWaterMark = this.netty_buffer_low_watermark(); int highWaterMark = this.netty_buffer_high_watermark(); if (lowWaterMark > highWaterMark) { throw new IllegalArgumentException( String .format( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\", highWaterMark, lowWaterMark)); } else { logger.warn( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\", lowWaterMark, highWaterMark); } this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( lowWaterMark, highWaterMark)); } \nResponse:", "ground_truth": "init netty write buffer water mark", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.WriteCompletionEvent;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss."}, {"ID": 467, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } } \nResponse:", "ground_truth": "Get a frame with a specific opcode\n\n@param opcode the opcode representing the frame\n@return the frame with a specific opcode", "predict": " public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } } \n\n*/\n\npackage org.java_websocket.exceptions;\n\npublic class InvalidDataException extends InvalidFrameException {\n\tprivate static final long serialVersionUID = -8680098990129154701L;\n\n\tpublic InvalidDataException(String s) {\n\t\tsuper(s);\n\t}\n}\n"}, {"ID": 468, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if( buffer == null ) { if( sockchannel instanceof WrappedByteChannel ) { c = (WrappedByteChannel) sockchannel; if( c.isNeedWrite() ) { c.writeMore(); } } } else { do {// FIXME writing as much as possible is unfair!! /*int written = */sockchannel.write( buffer ); if( buffer.remaining() > 0 ) { return false; } else { ws.outQueue.poll(); // Buffer finished. Remove it. buffer = ws.outQueue.peek(); } } while ( buffer != null ); } if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {// ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); } \nResponse:", "ground_truth": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_17;\nimport org.java_websocket.drafts.Draft_75;\nimport org.java_websocket.drafts.Draft_76;\nimport org.java_websocket.drafts.Draft_77;\nimport org.java_websocket.drafts.Draft_78;\nimport org.java_websocket.drafts.Draft_79;\nimport org.java_websocket.drafts.Draft_80;\nimport org.java_websocket.drafts.Draft"}, {"ID": 469, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setCode(int code) { this.code = code; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = \"\"; } updatePayload(); } \nResponse:", "ground_truth": "Set the close code for this close frame\n@param code the close code", "predict": " public void setResponse(byte[] response) { this.response = response; } \n\n*/\n\npublic class CloseFrame extends FramedataImpl1 implements Close {\n    public static final byte TYPE = 8;\n\n    private int code;\n    private String reason;\n    private byte[] response;\n\n    /**\n     * Create a new Close request with the given status code\n     *\n     * @param code The status code\n     */\n    public CloseFrame(int code) {\n        super(TYPE);\n        this.code = code;\n    }\n\n    /**\n     * Create a new Close request with the given status code and reason\n     *\n     * @param code The status code\n     * @param reason The reason\n     */\n    public CloseFrame(int code, String reason) {\n        super(TYPE);\n        this.code = code;\n        this.reason = reason;\n    }\n\n    /**\n     * Create a new Close request with the given"}, {"ID": 470, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position( payload.position() + 2 ); reason = Charsetfunctions.stringUtf8( payload ); } catch ( IllegalArgumentException e ) { throw new InvalidDataException( CloseFrame.NO_UTF8 ); } finally { payload.position( mark ); } } \nResponse:", "ground_truth": "Validate the payload to valid utf8\n@param mark the current mark\n@param payload the current payload\n@throws InvalidDataException the current payload is not a valid utf8", "predict": "\n\npublic void onFailure(String reason, int code, String message) {\n}\n\npublic void onSuccess(String message) {\n}\n\npublic void onSuccess(String message, int code, String reason) {\n}\n\npublic void onSuccess(String message, int code) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo, String otherReason) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo, String otherReason, String otherEvidence) {\n"}, {"ID": 471, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); } \nResponse:", "ground_truth": "Update the payload to represent the close code and the reason", "predict": " Response = new Response(Response.OK, super.getPayload());\n*/\n\npublic class Payload {\n\tpublic static final int OK = 0;\n\tpublic static final int ERROR = 1;\n\tpublic static final int ERROR_INVALID_PAYLOAD = 2;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH = 3;\n\tpublic static final int ERROR_INVALID_PAYLOAD_TYPE = 4;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE = 5;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_OR_CODE = 6;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_OR_CODE_OR_REASON = 7;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_"}, {"ID": 472, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; } \nResponse:", "ground_truth": "Check if the requested protocol is part of this draft\n@param requestedProtocol the requested protocol\n@return MATCHED if it is matched, otherwise NOT_MATCHED", "predict": " HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return Response.ACCEPTED; } } return Response.REJECTED; } \nResp HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return Response.ACCEPTED; } } return Response.REJECTED; } \nResp HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if("}, {"ID": 473, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if( length > Integer.MAX_VALUE ) { log.trace(\"Limit exedeed: Payloadsize is to big...\"); throw new LimitExceededException(\"Payloadsize is to big...\"); } if( length > maxFrameSize) { log.trace( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize, length); throw new LimitExceededException( \"Payload limit reached.\", maxFrameSize ); } if( length < 0 ) { log.trace(\"Limit underflow: Payloadsize is to little...\"); throw new LimitExceededException(\"Payloadsize is to little...\"); } } \nResponse:", "ground_truth": "Check if the frame size exceeds the allowed limit\n@param length the current payload length\n@throws LimitExceededException if the payload length is to big", "predict": "\n\n*/\n\npublic class Frame {\n\t\n\tprivate static final Logger log = LoggerFactory.getLogger(Frame.class);\n\t\n\tprivate static final int MAX_PAYLOAD_SIZE = 65535;\n\t\n\tprivate static final int MAX_FRAME_SIZE = 65535;\n\t\n\tprivate static final int MAX_FRAME_SIZE_LOWER_BOUND = 0;\n\t\n\tprivate static final int MAX_FRAME_SIZE_UPPER_BOUND = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_DEFAULT = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MIN = 0;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MAX = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MIDDLE = MAX_PAYLOAD"}, {"ID": 474, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } } \nResponse:", "ground_truth": "Check if the max packet size is smaller than the real packet size\n@param maxpacketsize the max packet size\n@param realpacketsize the real packet size\n@throws IncompleteException if the maxpacketsize is smaller than the realpackagesize", "predict": " Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } } \n*/\n\npublic class FrameCheckPacketSize extends Frame {\n\tpublic FrameCheckPacketSize() {\n\t\tsuper();\n\t\tthis.setOpcode(Frame.OPCODE_CHECK_PACKET_SIZE);\n\t}\n\t\n\tpublic FrameCheckPacketSize(int maxpacketsize, int realpacketsize) {\n\t\tthis();\n\t\tthis.setMaxPacketSize(maxpacketsize);\n\t\tthis.setRealPacketSize(realpacketsize);\n\t}\n\t\n\tpublic int getMaxPacketSize() {"}, {"ID": 475, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String generateFinalKey( String in ) { String seckey = in.trim(); String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance( \"SHA1\" ); } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException( e ); } return Base64.encodeBytes( sh1.digest( acc.getBytes() ) ); } \nResponse:", "ground_truth": "Generate a final key from a input string\n@param in the input string\n@return a final key", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class FinalKeyGenerator {\n\tpublic static void main(String[] args) {\n\t\tString input = \"\";\n\t\ttry {\n\t\t\tinput = \"test\";\n\t\t\tSystem.out.println(generateFinalKey(input));\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static String generateFinalKey(String input) throws NoSuchAlgorithmException {\n\t\tMessageDigest sh1;\n\t\ttry {\n\t\t\tsh1 = MessageDigest.getInstance(\"SHA1\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tbyte"}, {"ID": 476, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if( curop != Opcode.CONTINUOUS ) { processFrameIsNotFin(frame); } else if( frame.isFin() ) { processFrameIsFin(webSocketImpl, frame); } else if( currentContinuousFrame == null ) { log.error( \"Protocol error: Continuous frame sequence was not started.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } //Check if the whole payload is valid utf8, when the opcode indicates a text if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) { log.error( \"Protocol error: Payload is not UTF8\" ); throw new InvalidDataException( CloseFrame.NO_UTF8 ); } //Checking if the current continuous frame contains a correct payload with the other frames combined if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) { addToBufferList(frame.getPayloadData()); } } \nResponse:", "ground_truth": "Process the frame if it is a continuous frame or the fin bit is not set\n@param webSocketImpl the websocket implementation to use\n@param frame the current frame\n@param curop the current Opcode\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) {\n\tif( frame.getOpcode() == Opcode.CONTINUOUS ) {\n\t\tif( currentContinuousFrame != null ) {\n\t\t\tcurrentContinuousFrame.setPayload(currentContinuousFrame.getPayload() + frame.getPayloadData());\n\t\t} else {\n\t\t\tcurrentContinuousFrame = new FramedataImpl1(frame);\n\t\t}\n\t} else {\n\t\tif( currentContinuousFrame != null ) {\n\t\t\tcurrentContinuousFrame.setPayload(currentContinuousFrame.getPayload() + frame.getPayloadData());\n\t\t\tprocessFrameIsFin(webSocketImpl, currentContinuousFrame);\n\t\t} else {\n\t\t\tprocessFrameIsNotFin(frame);\n\t\t}\n\t}\n}\n\npublic void processFrameIsNotFin(Framedata frame) {\n\tif( frame.getOpcode()"}, {"ID": 477, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a binary frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\npublic void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \n\n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger logger = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final int MAX_FRAME_SIZE = 16384;\n\t\n\tprivate final int port;\n\t\n\tprivate final ServerSocketChannel server;\n\t\n\tprivate final ExecutorService executor;\n\t\n\tprivate final WebSocketServerFactory wsFactory;\n\t\n\tprivate final Map<WebSocket, WebSocketWorker> workers = new HashMap<WebSocket, WebSocketWorker>();\n\t\n\tprivate final Map<WebSocket, Web"}, {"ID": 478, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { log.error( \"Runtime exception during onWebsocketMessage\", e ); webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e ); } \nResponse:", "ground_truth": "Log the runtime exception to the specific WebSocketImpl\n@param webSocketImpl the implementation of the websocket\n@param e the runtime exception", "predict": "\npublic void onWebsocketMessage(WebSocket webSocket, String message) {\n\ttry {\n\t\tlog.info( \"Received message: \" + message );\n\t\twebSocket.getWebSocketListener().onWebsocketMessage( webSocket, message );\n\t} catch (RuntimeException e) {\n\t\tlogRuntimeException(webSocket, e);\n\t}\n}\n\npublic void onWebsocketError(WebSocket webSocket, Exception ex) {\n\ttry {\n\t\tlog.error( \"Error during onWebsocketError\", ex );\n\t\twebSocket.getWebSocketListener().onWebsocketError( webSocket, ex );\n\t} catch (RuntimeException e) {\n\t\tlogRuntimeException(webSocket, e);\n\t}\n}\n\npublic void onWebsocketClose(WebSocket webSocket, int code, String reason, boolean remote) {\n\ttry {\n\t\tlog.info( \"Connection closed: \" + code + \" -"}, {"ID": 479, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a text frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\npublic void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \n\n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger LOG = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final String WEBSOCKET_PATH = \"/websocket\";\n\t\n\tprivate static final int DEFAULT_PORT = 8080;\n\t\n\tprivate static final int DEFAULT_BACKLOG = 10;\n\t\n\tprivate static final int DEFAULT_READ_TIMEOUT = 0;\n\t\n\tprivate static final int DEFAULT_WRITE_TIMEOUT = 0;\n\t\n"}, {"ID": 480, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if( currentContinuousFrame == null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); } \nResponse:", "ground_truth": "Process the frame if it is the last frame\n@param webSocketImpl the websocket impl\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic void sendFrame( Framedata frame ) {\nif( !isOpen() ) { throw new IllegalStateException( \"this.webSocketImpl.getReadyState() != READYSTATE.OPEN\" ); }\nif( frame.getOpcode() == Opcode.CONTINUOUS ) { if( currentContinuousFrame != null ) { throw new IllegalArgumentException( \"Only a single continuous frame is allowed.\" ); } currentContinuousFrame = frame; } else { if( currentContinuousFrame != null ) { throw new IllegalStateException( \"A continuous frame is already being processed.\" ); } }\nif( frame.getOpcode() == Opcode.TEXT ) { if( !frame.isFin() ) { throw new InvalidFrameException( \"A text frame must be a final frame (FIN bit set).\" ); } }\nif( frame.getOpcode() == Opcode.BINARY ) { if( !frame.isFin() ) { throw new InvalidFrameException"}, {"ID": 481, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if( currentContinuousFrame != null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" ); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); } \nResponse:", "ground_truth": "Process the frame if it is not the last frame\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic class ServerHandshake extends WebSocketServerHandshaker {\n    private static final Logger log = LoggerFactory.getLogger(ServerHandshake.class);\n    private final String subprotocols;\n    private final boolean allowExtensions;\n    private final int maxFramePayloadLength;\n    private final int maxMessagePayloadLength;\n    private final boolean allowMaskMismatch;\n    private final boolean checkStartsWith;\n    private final boolean maskedPayload;\n    private final int maxBufferSize;\n    private final boolean sendCloseFrame;\n    private final boolean expectCloseFrame;\n    private final boolean sendMask;\n    private final int maxBinaryFramePayloadLength;\n    private final int maxTextFramePayloadLength;\n    private final boolean allowMaskMismatch;\n    private final boolean checkStartsWith;\n    private final boolean maskedPayload;\n    private final int maxBufferSize;\n    private final boolean sendCloseFrame"}, {"ID": 482, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = \"\"; if( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) { // complete the close handshake by disconnecting webSocketImpl.closeConnection( code, reason, true ); } else { // echo close handshake if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY ) webSocketImpl.close( code, reason, true ); else webSocketImpl.flushAndClose( code, reason, false ); } } \nResponse:", "ground_truth": "Process the frame if it is a closing frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger LOG = Logger.getLogger(WebSocketServer.class.getName());\n    private static final String WEBSOCKET_PATH = \"/websocket\";\n    private static final String WEBSOCKET_PATH_PROPERTY = \"websocket.path\";\n    private static final String WEBSOCKET_HOST = \"websocket.host\";\n    private static final String WEBSOCKET_HOST_PROPERTY = \"websocket.host\";\n    private static final String WEBSOCKET_PORT = \"websocket.port\";\n    private static final String WEBSOCKET_PORT_PROPERTY = \"websocket.port\";\n    private static final String WEBSOCKET_MAX_CONNECTIONS = \"websocket.maxConnections\";\n    private static final String WEBSOCKET_MAX_CONNECTIONS_PROPERTY = \""}, {"ID": 483, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if( totalSize > maxFrameSize ) { clearBufferList(); log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize); throw new LimitExceededException(maxFrameSize); } } \nResponse:", "ground_truth": "Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size\n@throws LimitExceededException if the current size is bigger than the allowed size", "predict": "\n\n*/\n\npublic class Frame {\n    private final int frameSize;\n    private final int frameType;\n    private final int frameVersion;\n    private final int frameFlags;\n    private final int frameLength;\n    private final int framePayloadSize;\n    private final int framePayloadOffset;\n    private final int framePayloadLength;\n    private final int framePayloadData;\n    private final int framePayloadDataOffset;\n    private final int framePayloadDataLength;\n    private final int framePayloadDataOffsetEnd;\n    private final int framePayloadDataLengthEnd;\n    private final int framePayloadDataOffsetStart;\n    private final int framePayloadDataLengthStart;\n    private final int framePayloadDataOffsetStartEnd;\n    private final int framePayloadDataLengthStartEnd;\n    private final int framePayloadDataOffsetEnd;\n    private final int framePayloadDataLengthEnd;\n    private final int framePay"}, {"ID": 484, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate( (int) totalSize ); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put( buffer ); } } resultingByteBuffer.flip(); return resultingByteBuffer; } \nResponse:", "ground_truth": "Method to generate a full bytebuffer out of all the fragmented frame payload\n@return a bytebuffer containing all the data\n@throws LimitExceededException will be thrown when the totalSize is bigger then Integer.MAX_VALUE due to not being able to allocate more", "predict": " ResponseCode = 0, ErrorMessage = null \n*/\n\npublic class ByteBufferList {\n\tprivate List<ByteBuffer> byteBufferList;\n\tprivate int totalSize;\n\tprivate int limit;\n\t\n\tpublic ByteBufferList() {\n\t\tbyteBufferList = new ArrayList<ByteBuffer>();\n\t\ttotalSize = 0;\n\t\tlimit = 0;\n\t}\n\t\n\tpublic void add(ByteBuffer buffer) {\n\t\tbyteBufferList.add(buffer);\n\t\ttotalSize += buffer.limit();\n\t\tlimit = totalSize;\n\t}\n\t\n\tpublic ByteBuffer get(int index) {\n\t\treturn byteBufferList.get(index);\n\t}\n\t\n\tpublic int size() {\n\t\treturn byteBufferList.size();\n\t}\n\t\n\tpublic int getLimit() {\n\t\treturn limit;\n\t}\n\t\n\tpublic void checkBufferLimit() throws LimitExceededException {\n\t\tif (limit >"}, {"ID": 485, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; } \nResponse:", "ground_truth": "Get the current size of the resulting bytebuffer in the bytebuffer list\n@return the size as long (to not get an integer overflow)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 486, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return clienthandshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as server\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the SERVER if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ServerHandshakeBuilder serverhandshake = new HandshakeImpl1Server(); serverhandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return serverhandshake; } \n\n*/\n"}, {"ID": 487, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] ); return handshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as client\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage("}, {"ID": 488, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time if( socketBuffer.hasRemaining() ) { decodeFrames( socketBuffer ); } else if( tmpHandshakeBytes.hasRemaining() ) { decodeFrames( tmpHandshakeBytes ); } } } } \nResponse:", "ground_truth": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "predict": " public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { decodeFrames( socketBuffer ); } } } \nResp public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socket"}, {"ID": 489, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem", "predict": " Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void close"}, {"ID": 490, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToInternalServerError( RuntimeException exception ) { write( generateHttpResponseDueToError( 500 ) ); flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if there was a server error by a RuntimeException\n\n@param exception the RuntimeException causing this problem", "predict": "\n\npublic class HttpResponse {\n    private final int statusCode;\n    private final String reasonPhrase;\n    private final byte[] content;\n    private final String contentType;\n    private final int contentLength;\n\n    public HttpResponse(int statusCode, String reasonPhrase, byte[] content, String contentType, int contentLength) {\n        this.statusCode = statusCode;\n        this.reasonPhrase = reasonPhrase;\n        this.content = content;\n        this.contentType = contentType;\n        this.contentLength = contentLength;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getReasonPhrase() {\n        return reasonPhrase;\n    }\n\n    public byte[] getContent() {\n        return content;\n    }\n\n    public String getContentType() {\n        return contentType;\n    }\n\n    public int getContentLength() {\n        return"}, {"ID": 491, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); } \nResponse:", "ground_truth": "", "predict": " Generate the method-level comment for the following java Code. Code: private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); } \n"}, {"ID": 492, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); } \nResponse:", "ground_truth": "Send Text data to the other end.\n\n@throws WebsocketNotConnectedException websocket is not yet connected", "predict": " @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); } \n\n*/\n\npublic class WebSocketImpl {\n    private final WebSocketDraft draft;\n    private final WebSocketListener listener;\n    private final WebSocketClientHandshaker handshaker;\n    private final URI uri;\n    private final WebSocketClientHandler handler;\n    private final WebSocketClientProtocolHandler protocolHandler;\n    private final HttpHeaders customHeaders;\n    private final int maxFramePayloadLength;\n    private final int maxMessagePayloadLength;\n    private final boolean allowExtensions;\n    private final boolean performMasking;\n    private final boolean useMask;\n    private final int maxFrameSize;\n    private final int maxMessagesPerFrame;\n    private final int"}, {"ID": 493, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\"); } try { closeBlocking(); if( writeThread != null ) { this.writeThread.interrupt(); this.writeThread = null; } if( connectReadThread != null ) { this.connectReadThread.interrupt(); this.connectReadThread = null; } this.draft.reset(); if( this.socket != null ) { this.socket.close(); this.socket = null; } } catch ( Exception e ) { onError( e ); engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() ); return; } connectLatch = new CountDownLatch( 1 ); closeLatch = new CountDownLatch( 1 ); this.engine = new WebSocketImpl( this, this.draft ); } \nResponse:", "ground_truth": "Reset everything relevant to allow a reconnect\n@since 1.3.8", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private final WebSocketDelegate delegate;\n    private final WebSocketDraft draft;\n    private final Socket socket;\n    private final InputStream in;\n    private final OutputStream out;\n    private final List<WebSocket> connections = new ArrayList<WebSocket>();\n    private final List<WebSocketWorker> workers = new ArrayList<WebSocketWorker>();\n    private final List<WebSocketImpl> connections_ = new ArrayList<WebSocketImpl>();\n    private volatile boolean closed = false;\n    private volatile boolean closedRemotely = false;\n    private volatile boolean failed = false;\n    private volatile boolean disposed = false;\n    private volatile boolean disposedRemotely = false;\n    private volatile boolean open = false;\n    private volatile boolean openRemotely = false;\n    private volatile boolean wasConnected = false;\n    private volatile boolean wasDisconnected = false;\n    private volatile boolean"}, {"ID": 494, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void connect() { if( connectReadThread != null ) throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" ); connectReadThread = new Thread( this ); connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() ); connectReadThread.start(); } \nResponse:", "ground_truth": "Initiates the websocket connection. This method does not block.", "predict": " public void run() { try { if( connectReadThread != null ) connectReadThread.join(); } catch( InterruptedException e ) { } } \n\n*/\n\npublic class WebSocketClient {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger( WebSocketClient.class );\n\t\n\tprivate final String host;\n\tprivate final int port;\n\tprivate final String path;\n\tprivate final String protocol;\n\tprivate final String username;\n\tprivate final String password;\n\tprivate final String url;\n\tprivate final String method;\n\tprivate final String contentType;\n\tprivate final String content;\n\tprivate final String contentEncoding;\n\tprivate final String accept;\n\tprivate final String acceptEncoding;\n\tprivate final String acceptLanguage;\n\tprivate final String acceptCharset;\n\tprivate final String cookie;\n\tprivate final String cookieDomain;\n\tprivate final String cookiePath;\n\tprivate final String cookieMaxAge;"}, {"ID": 495, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getPort() { int port = uri.getPort(); if( port == -1 ) { String scheme = uri.getScheme(); if( \"wss\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_WSS_PORT; } else if( \"ws\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_PORT; } else { throw new IllegalArgumentException( \"unknown scheme: \" + scheme ); } } return port; } \nResponse:", "ground_truth": "Extract the specified port\n@return the specified port or the default port for the specific scheme", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger logger = Logger.getLogger(WebSocketServer.class.getName());\n\n    private static final String WEBSOCKET_PATH = \"/websocket\";\n    private static final String WEBSOCKET_PATH_WITH_PORT = \"/websocket/:port\";\n\n    private static final String WEBSOCKET_PATH_WITH_SSL = \"/websocket/ssl\";\n    private static final String WEBSOCKET_PATH_WITH_SSL_WITH_PORT = \"/websocket/ssl/:port\";\n\n    private static final String WEBSOCKET_PATH_WITH_SSL_AND_AUTH = \"/websocket/ssl/auth\";\n    private static final String WEBSOCKET_PATH_WITH_SSL_AND_AUTH_WITH_PORT = \"/websocket/ssl/auth/:port\";\n\n    private static final String"}, {"ID": 496, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if( part1 == null || part1.length() == 0 ) path = \"/\"; else path = part1; if( part2 != null ) path += '?' + part2; int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? \":\" + port : \"\" ); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor( path ); handshake.put( \"Host\", host ); if( headers != null ) { for( Map.Entry<String,String> kv : headers.entrySet() ) { handshake.put( kv.getKey(), kv.getValue() ); } } engine.startHandshake( handshake ); } \nResponse:", "ground_truth": "Create and send the handshake to the other endpoint\n@throws InvalidHandshakeException  a invalid handshake was created", "predict": " Send a Server Handshake\n\n*/\n\npublic class WebSocketServerHandshaker13 extends WebSocketServerHandshaker {\n\n    private static final String WEBSOCKET_13 = \"WebSocket-Version: 13\";\n\n    public WebSocketServerHandshaker13(String webSocketURL, String subprotocols, int maxFramePayloadLength, int maxIdleTime, int maxTextMessageSize, int maxBinaryMessageSize, boolean allowExtensions) {\n        super(webSocketURL, subprotocols, maxFramePayloadLength, maxIdleTime, maxTextMessageSize, maxBinaryMessageSize, allowExtensions);\n    }\n\n    @Override\n    protected String getWebSocketVersion() {\n        return WEBSOCKET_13;\n    }\n}\n"}, {"ID": 497, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setConnectionLostTimeout( int connectionLostTimeout ) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); return; } if (this.websocketRunning) { log.trace(\"Connection lost timer restarted\"); //Reset all the pings try { ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { log.error(\"Exception during connection lost restart\", e); } restartConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Setter for the interval checking for lost connections\nA value lower or equal 0 results in the check to be deactivated\n\n@param connectionLostTimeout the interval in seconds\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private static final Logger log = LoggerFactory.getLogger(WebSocketImpl.class);\n    private static final long serialVersionUID = -8288880591730267843L;\n    private static final int DEFAULT_CONNECTION_LOST_TIMEOUT = 60;\n    private static final int DEFAULT_CONNECTION_TIMEOUT = 60;\n    private static final int DEFAULT_PING_INTERVAL = 60;\n    private static final int DEFAULT_PONG_TIMEOUT = 60;\n    private static final int DEFAULT_MAX_BINARY_MESSAGE_SIZE = 16384;\n    private static final int DEFAULT_MAX_TEXT_MESSAGE_SIZE = 16384;\n    private static final int DEFAULT_MAX_PONG_MESSAGES = 10;\n    private static final int DEFAULT_MAX_PONG_"}, {"ID": 498, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Stop the connection lost timer\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketConnectionLostTimerTask extends TimerTask {\n    private static final Logger log = LoggerFactory.getLogger(WebSocketConnectionLostTimerTask.class);\n    private final WebSocketConnectionManager wsConnectionManager;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener wsConnectionStateListener;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionState;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateTo;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateFrom;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFrom;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFromTo;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFromToTo;\n    private final WebSocketConnectionManager"}, {"ID": 499, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } } \nResponse:", "ground_truth": "Start the connection lost timer\n@since 1.3.4", "predict": " public void onClose(int code, String reason, boolean remote) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer stopped\"); this.websocketRunning = false; stopConnectionLostTimer(); } } \nResp public void onError(Exception ex) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer stopped\"); this.websocketRunning = false; stopConnectionLostTimer(); } } \nResp public void onOpen(ServerHandshake handshakeData) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } } \nResp"}, {"ID": 500, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"connectionLostChecker\")); Runnable connectionLostChecker = new Runnable() { /** * Keep the connections in a separate list to not cause deadlocks */ private ArrayList<WebSocket> connections = new ArrayList<WebSocket>( ); @Override public void run() { connections.clear(); try { connections.addAll( getConnections() ); long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 )); for( WebSocket conn : connections ) { executeConnectionLostDetection(conn, minimumPongTime); } } catch ( Exception e ) { //Ignore this exception } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); } \nResponse:", "ground_truth": "This methods allows the reset of the connection lost timer in case of a changed parameter\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger LOGGER = LoggerFactory.getLogger(WebSocketServer.class);\n    private final int port;\n    private final List<WebSocket> connections = new ArrayList<WebSocket>();\n    private final List<WebSocket> connectionsToRemove = new ArrayList<WebSocket>();\n    private final List<WebSocket> connectionsToAdd = new ArrayList<WebSocket>();\n    private final ScheduledExecutorService connectionLostCheckerService;\n    private final ScheduledFuture connectionLostCheckerFuture;\n    private final long connectionLostTimeout;\n    private final WebSocketServerHandler handler;\n    private final WebSocketServerConfig config;\n\n    public WebSocketServer(int port, WebSocketServerHandler handler, WebSocketServerConfig config) {\n        this.port = port;\n        this.handler = handler;\n        this.config = config;\n        this.connectionLostTimeout = config"}, {"ID": 501, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if( webSocketImpl.getLastPong() < minimumPongTime ) { log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl); webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ); } else { if( webSocketImpl.isOpen() ) { webSocketImpl.sendPing(); } else { log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl); } } } \nResponse:", "ground_truth": "Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping\n@param webSocket the websocket instance\n@param minimumPongTime the lowest/oldest allowable last pong time (in nanoTime) before we consider the connection to be lost", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.websocket.ClientEndpoint;\nimport javax.websocket.CloseReason;\nimport javax.websocket.ContainerProvider;\nimport javax.websocket.DeploymentException;\nimport javax.websocket.Endpoint;\nimport javax.websocket.EndpointConfig;\nimport javax.websocket.MessageHandler;\nimport javax.websocket.Session;\n\nimport org.apache.log4j.Logger;\n\n@ClientEndpoint\npublic class WebSocketClientEndpoint extends Endpoint {\n\n\tprivate static final Logger log = Logger.getLogger(WebSocket"}, {"ID": 502, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cancelConnectionLostTimer() { if( connectionLostCheckerService != null ) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } } \nResponse:", "ground_truth": "Cancel any running timer for the connection lost detection\n@since 1.3.4", "predict": "\n\n*/\n\npublic class ConnectionLostCheckerService extends ScheduledThreadPoolExecutor {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionLostCheckerService.class);\n    private static final int DEFAULT_THREAD_POOL_SIZE = 1;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT = 60;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT = TimeUnit.SECONDS;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_VALUE = DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT_VALUE = DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT;\n    private static final long DEFAULT_"}, {"ID": 503, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); } \nResponse:", "ground_truth": "This default implementation does not do anything. Go ahead and overwrite it.\n\n@see org.java_websocket.WebSocketListener#onWebsocketHandshakeReceivedAsServer(WebSocket, Draft, ClientHandshake)", "predict": " @Override public WebSocket handshake( FullHttpRequest request, HttpHeaders headers, int maxFramePayloadLength, int maxHeaderSize, int maxInitialLineLength, ChannelPromise promise ) { return new WebSocketServerHandshaker13( \"ws\" ).handshake( request, headers, maxFramePayloadLength, maxHeaderSize, maxInitialLineLength, promise ); }\n\n}\n"}, {"ID": 504, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void onWebsocketPing( WebSocket conn, Framedata f ) { conn.sendFrame( new PongFrame( (PingFrame)f ) ); } \nResponse:", "ground_truth": "This default implementation will send a pong in response to the received ping.\nThe pong frame will have the same payload as the ping frame.\n\n@see org.java_websocket.WebSocketListener#onWebsocketPing(WebSocket, Framedata)", "predict": " @Override public void onWebsocketPong( WebSocket conn, Framedata f ) { } \nResp @Override public void onWebsocketClose( WebSocket conn, int code, String reason, boolean remote ) { } \nResp @Override public void onWebsocketError( WebSocket conn, Exception ex ) { } \nResp @Override public void onWebsocketMessage( WebSocket conn, String message ) { } \nResp @Override public void onWebsocketOpen( WebSocket conn, Handshakedata d ) { } \n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final int MAX_CONTENT_LENGTH = 1024 * 1024 * 10;\n\t\n\tprivate static final int MIN_CONTENT_LENGTH = 1024 * 1024 * 2;\n\t\n\tprivate static final int RECON"}, {"ID": 505, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop( int timeout ) throws InterruptedException { if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections return; } List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList<WebSocket>( connections ); } for( WebSocket ws : socketsToClose ) { ws.close( CloseFrame.GOING_AWAY ); } wsf.close(); synchronized ( this ) { if( selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join( timeout ); } } } \nResponse:", "ground_truth": "Closes all connected clients sockets, then closes the underlying\nServerSocketChannel, effectively killing the server socket selectorthread,\nfreeing the port the server was bound to and stops all internal workerthreads.\n\nIf this method is called before the server is started it will never start.\n\n@param timeout\nSpecifies how many milliseconds the overall close handshaking may take altogether before the connections are closed without proper close handshaking.\n\n@throws InterruptedException Interrupt", "predict": "\n\n*/\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_17;\nimport org.java_websocket.exceptions.InvalidDataException;\nimport org.java_websocket.exceptions.InvalidHandshakeException;\nimport org.java_websocket.exceptions.WebsocketNotConnectedException;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.handshake.Handshakedata;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java"}, {"ID": 506, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getPort() { int port = getAddress().getPort(); if( port == 0 && server != null ) { port = server.socket().getLocalPort(); } return port; } \nResponse:", "ground_truth": "Gets the port number that this server listens on.\n\n@return The port number.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 507, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while ( !iqueue.isEmpty() ) { conn = iqueue.remove( 0 ); WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() ); ByteBuffer buf = takeBuffer(); try { if( SocketChannelIOHelper.readMore( buf, conn, c ) ) iqueue.add( conn ); if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } } } \nResponse:", "ground_truth": "Do an additional read\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": "\npublic void doAdditionalWrite( WrappedByteChannel channel, ByteBuffer buffer ) throws IOException { if( buffer.hasRemaining() ) { WrappedByteChannel c = ( (WrappedByteChannel) channel ); ByteBuffer buf = takeBuffer(); try { SocketChannelIOHelper.write( buf, c, buffer ); } catch ( IOException e ) { throw e; } finally { pushBuffer( buf ); } } } \npublic void setMaxBinaryMessageBufferSize( int max ) { this.maxBinaryMessageBufferSize = max; } \npublic int getMaxBinaryMessageBufferSize() { return this.maxBinaryMessageBufferSize; } \npublic void setMaxTextMessageBufferSize( int max ) { this.maxTextMessageBufferSize = max; } \npublic int getMaxTextMessageBufferSize() { return this.maxTextMessageBufferSize; } \npublic void setMaxIdleTime( int maxIdleTime ) { this.maxIdleTime = maxId"}, {"ID": 508, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if( !onConnect( key ) ) { key.cancel(); return; } SocketChannel channel = server.accept(); if(channel==null){ return; } channel.configureBlocking( false ); Socket socket = channel.socket(); socket.setTcpNoDelay( isTcpNoDelay() ); socket.setKeepAlive( true ); WebSocketImpl w = wsf.createWebSocket( this, drafts ); w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w )); try { w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() )); i.remove(); allocateBuffers( w ); } catch (IOException ex) { if( w.getSelectionKey() != null ) w.getSelectionKey().cancel(); handleIOException( w.getSelectionKey(), null, ex ); } } \nResponse:", "ground_truth": "Execute a accept operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@throws InterruptedException  thrown by taking a buffer\n@throws IOException if an error happened during accept", "predict": "\npublic void onConnect(SelectionKey key) throws IOException {\n}\npublic void onMessage(SelectionKey key, WebSocketMessage m) throws IOException {\n}\npublic void onClose(SelectionKey key, WebSocketMessage m) {\n}\npublic void onError(SelectionKey key, Throwable t) {\n}\npublic void onStart() {\n}\npublic void onStop() {\n}\npublic void onIdle() {\n}\npublic void onMessage(byte[] data, int offset, int length) {\n}\npublic void onMessage(byte[] data, int offset, int length, boolean last) {\n}\npublic void onMessage(ByteBuffer data) {\n}\npublic void onMessage(ByteBuffer data, boolean last) {\n}\npublic void onMessage(String data) {\n}\npublic void onMessage(String data, boolean last) {\n}\npublic void onMessage(byte[] data, int offset, int length"}, {"ID": 509, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if(conn.getChannel() == null){ key.cancel(); handleIOException( key, conn, new IOException() ); return false; } try { if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) { if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); i.remove(); if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) { iqueue.add( conn ); } } else { pushBuffer(buf); } } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } return true; } \nResponse:", "ground_truth": "Execute a read operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@return true, if the read was successful, or false if there was an error\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " private void handleIOException(SelectionKey key, WebSocket conn, IOException ex) { try { SelectionKeyUtil.cancel(key); SelectionKeyUtil.close(key, ex); conn.close( CloseFrame.ABNORMAL_CLOSE, ex.getMessage() ); } catch (IOException e) { e.printStackTrace(); } } \n\n}\n"}, {"ID": 510, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doWrite(SelectionKey key) throws IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) { if( key.isValid() ) { key.interestOps(SelectionKey.OP_READ); } } } \nResponse:", "ground_truth": "Execute a write operation\n@param key the selectionkey to write on\n@throws IOException if an error happened during batch", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private final WebSocketClientHandshaker handshaker;\n    private final URI uri;\n    private final List<WebSocketChannel> channels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> closeChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverConnectedChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientConnectedChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverCloseChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientCloseChannels = new"}, {"ID": 511, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doSetupSelectorAndServerThread() { selectorthread.setName( \"WebSocketSelector-\" + selectorthread.getId() ); try { server = ServerSocketChannel.open(); server.configureBlocking( false ); ServerSocket socket = server.socket(); socket.setReceiveBufferSize( WebSocketImpl.RCVBUF ); socket.setReuseAddress( isReuseAddr() ); socket.bind( address ); selector = Selector.open(); server.register( selector, server.validOps() ); startConnectionLostTimer(); for( WebSocketWorker ex : decoders ){ ex.start(); } onStart(); } catch ( IOException ex ) { handleFatal( null, ex ); return false; } return true; } \nResponse:", "ground_truth": "Setup the selector thread as well as basic server settings\n@return true, if everything was successful, false if some error happened", "predict": "\n\n*/\n\npublic class WebSocketWorker implements Runnable {\n    private final WebSocketClientHandler handler;\n    private final WebSocketClient client;\n    private final WebSocketDecoderRx decoder;\n    private final WebSocketEncoderRx encoder;\n    private final WebSocketDecoderRx.FrameProcessor processor;\n    private final WebSocketEncoderRx.FrameProcessor frameProcessor;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult result;\n    private final WebSocketEncoderRx.FrameProcessor.FrameProcessorResult frameResult;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult.FrameProcessorResultHandler handler;\n    private final WebSocketEncoderRx.FrameProcessor.FrameProcessorResult.FrameProcessorResultHandler frameHandler;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult.FrameProcessor"}, {"ID": 512, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doEnsureSingleThread() { synchronized ( this ) { if( selectorthread != null ) throw new IllegalStateException( getClass().getName() + \" can only be started once.\" ); selectorthread = Thread.currentThread(); if( isclosed.get() ) { return false; } } return true; } \nResponse:", "ground_truth": "The websocket server can only be started once\n@return true, if the server can be started, false if already a thread is running", "predict": "\n\n*/\n\npublic class SingleThreadedSelector extends Selector {\n    private final Selector selector;\n    private final AtomicBoolean isclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselecting = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthread = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopenclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopenopen = new Atomic"}, {"ID": 513, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doServerShutdown() { stopConnectionLostTimer(); if( decoders != null ) { for( WebSocketWorker w : decoders ) { w.interrupt(); } } if( selector != null ) { try { selector.close(); } catch ( IOException e ) { log.error( \"IOException during selector.close\", e ); onError( null, e ); } } if( server != null ) { try { server.close(); } catch ( IOException e ) { log.error( \"IOException during server.close\", e ); onError( null, e ); } } } \nResponse:", "ground_truth": "Clean up everything after a shutdown", "predict": "\n\n*/\n\npublic class WebSocketWorker extends Thread {\n    private final WebSocketServer server;\n    private final Selector selector;\n    private final WebSocketFactory factory;\n    private final Map<WebSocket, Set<WebSocketWorker>> connections = new HashMap<WebSocket, Set<WebSocketWorker>>();\n    private final Map<WebSocket, WebSocketWorker> workers = new HashMap<WebSocket, WebSocketWorker>();\n    private final Map<WebSocket, WebSocket> sockets = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverse = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverseConnections = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverseConnections2 = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket,"}, {"ID": 514, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Socket getSocket( WebSocket conn ) { WebSocketImpl impl = (WebSocketImpl) conn; return ( (SocketChannel) impl.getSelectionKey().channel() ).socket(); } \nResponse:", "ground_truth": "Getter to return the socket used by this specific connection\n@param conn The specific connection\n@return The socket used by this connection", "predict": " Generate the method-level comment for the following java Code. Code: private void setSocket( WebSocket conn, SocketChannel channel ) { WebSocketImpl impl = (WebSocketImpl) conn; ((SocketChannel) impl.getSelectionKey().channel() ).socket().setSoTimeout( WEBSOCKET_TIMEOUT ); } \n */\n\npublic class WebSocketServer {\n\tpublic static void main(String[] args) throws Exception {\n\t\tint port = 8080;\n\t\tif (args.length > 0) {\n\t\t\tport = Integer.parseInt(args[0]);\n\t\t}\n\t\tnew WebSocketServer(port).run();\n\t}\n\n\tpublic WebSocketServer(int port) {\n\t\tthis.port = port;\n\t}\n\n\tpublic void run() {\n\t\tSystem.out.println(\"Starting WebSocketServer on port \" + port);\n\t\ttry {\n\t\t\tServerSocketChannel ssc = ServerSocketChannel.open();\n\t\t\tssc.configure"}, {"ID": 515, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); } \nResponse:", "ground_truth": "Send a byte array to a specific collection of websocket connections\n@param data the data to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": "\n\n*/\n\nimport java.util.Collection;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer."}, {"ID": 516, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); } \nResponse:", "ground_truth": "Send a text to a specific collection of websocket connections\n@param text the text to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Response is generated by the method doBroadcast(String text, Collection<WebSocket> clients)\n\n*/\n\npublic class Broadcast {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new WebSocket object\n\t\tWebSocket ws = new WebSocket();\n\t\t\n\t\t// Create a new WebSocketClient object\n\t\tWebSocketClient wsClient = new WebSocketClient();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer2 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer3 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer4 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer w"}, {"ID": 517, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doBroadcast(Object data, Collection<WebSocket> clients) { String sData = null; if (data instanceof String) { sData = (String)data; } ByteBuffer bData = null; if (data instanceof ByteBuffer) { bData = (ByteBuffer)data; } if (sData == null && bData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>(); for( WebSocket client : clients ) { if( client != null ) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, sData, bData); try { client.sendFrame( draftFrames.get( draft ) ); } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } } \nResponse:", "ground_truth": "Private method to cache all the frames to improve memory footprint and conversion time\n@param data the data to broadcast\n@param clients the clients to send the message to", "predict": "\n\n*/\n\npublic class WebSocketServer extends WebSocket implements Runnable {\n\n    private final int port;\n    private final List<WebSocket> connections = Collections.synchronizedList(new ArrayList<WebSocket>());\n    private final List<WebSocket> clients = Collections.synchronizedList(new ArrayList<WebSocket>());\n    private Thread serverThread;\n    private ServerSocketChannel server;\n    private Selector selector;\n    private Draft draft;\n    private final ObjectMapper mapper = new ObjectMapper();\n\n    public WebSocketServer(int port) {\n        this(port, null);\n    }\n\n    public WebSocketServer(int port, Draft draft) {\n        this.port = port;\n        this.draft = draft;\n    }\n\n    public void start() {\n        try {\n            server = ServerSocketChannel.open();\n            server.configureBlocking(false);\n            server.socket().bind(new"}, {"ID": 518, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { if( !draftFrames.containsKey( draft ) ) { List<Framedata> frames = null; if (sData != null) { frames = draft.createFrames( sData, false ); } if (bData != null) { frames = draft.createFrames( bData, false ); } if (frames != null) { draftFrames.put(draft, frames); } } } \nResponse:", "ground_truth": "Fills the draftFrames with new data for the broadcast\n@param draft The draft to use\n@param draftFrames The list of frames per draft to fill\n@param sData the string data, can be null\n@param bData the bytebuffer data, can be null", "predict": "\n\n*/\n\npublic class Draft_7_1_1 extends Draft {\n    public static final int METHOD_ID = 1;\n\n    public static final int REQUEST_ID = 1;\n\n    public static final String NAME = \"WebSocket\";\n\n    public static final String VERSION = \"7.1.1\";\n\n    public static final String DESCRIPTION = \"The WebSocket protocol provides a way to send and receive messages between a client and a server.\";\n\n    public static final String REFERENCE = \"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07\";\n\n    public static final int[] WEBSOCKET_VERSIONS = { 7, 8, 13 };\n\n    public static final int WEBSOCKET_VERSION_NOT_SET = 0;\n\n    public static final int WEBSOCKET_VERSION_DRAFT_7_1_1 = 7;\n\n    public static final int WEBSOCKET_"}, {"ID": 519, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } } \nResponse:", "ground_truth": "Transfer from one ByteBuffer to another ByteBuffer\n\n@param source the ByteBuffer to copy from\n@param dest   the ByteBuffer to copy to\n@return the number of transferred bytes", "predict": " public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } } \nResp public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fre"}, {"ID": 520, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JPAApi start() { jpaConfig .persistenceUnits() .forEach( persistenceUnit -> emfs.put( persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName))); return this; } \nResponse:", "ground_truth": "Initialise JPA entity manager factories.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 521, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return emf.createEntityManager(); } \nResponse:", "ground_truth": "Get a newly created EntityManager for the specified persistence unit name.\n\n@param name The persistence unit name", "predict": " ResponseEntity<EntityManager> em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return new ResponseEntity<EntityManager>(emf.createEntityManager(), HttpStatus.OK); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.PersistenceContext;\nimport javax.persistence.PersistenceContextType;\nimport javax.persistence.PersistenceUnit;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.crit"}, {"ID": 522, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void withTransaction(Consumer<EntityManager> block) { withTransaction( em -> { block.accept(em); return null; }); } \nResponse:", "ground_truth": "Run a block of code with a newly created EntityManager for the default Persistence Unit.\n\n@param block Block of code to execute", "predict": "\n\npublic void withTransaction(Consumer<EntityManager> block) {\n    withTransaction(em -> {\n        block.accept(em);\n        return null;\n    });\n}\n\n*/\n\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Transaction {\n\n    public static <T> T withTransaction(Consumer<EntityManager> block) {\n        return withTransaction(em -> {\n            block.accept(em);\n            return null;\n        });\n    }\n\n    public static <T> T withTransaction(Function<EntityManager, T> block) {\n        return withTransaction(em -> {\n            block.apply(em);\n            return null;\n        });\n    }\n\n    public static <T> T withTransaction(Supplier<T> block) {\n        return withTransaction(em -> {\n            block.get();\n            return null"}, {"ID": 523, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Seq<Object> convertArgsToScalaBuffer(final Object... args) { return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args)) .asScala() .toList(); } \nResponse:", "ground_truth": "Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate list\nif necessary\n\n@param args the message arguments\n@return scala type for message processing", "predict": " Response = convertArgsToScalaBuffer(args)\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaConverters {\n    public static List<Object> wrapArgsToListIfNeeded(Object... args) {\n        List<Object> list = new ArrayList<Object>();\n        for (Object arg : args) {\n            if (arg instanceof List) {\n                list.addAll((List) arg);\n            } else {\n                list.add(arg);\n            }\n        }\n        return list;\n    }\n\n    public static Seq<Object> asScalaBufferConverter(List<Object> list) {\n        return new Seq<Object>(list);\n    }\n}\n"}, {"ID": 524, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; } \nResponse:", "ground_truth": "Wraps arguments passed into a list if necessary.\n\nReturns the first value as is if it is the only argument and a subtype of `java.util.List`\nOtherwise, it calls Arrays.asList on args\n\n@param args arguments as a List", "predict": " @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SafeVarargs {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"Hello\");\n        list.add(\"World\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add"}, {"ID": 525, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, String key, Object... args) { Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(key, scalaArgs, lang); } \nResponse:", "ground_truth": "Translates a message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " public play.api.i18n.Lang messages(play.api.i18n.Lang lang, String key, Seq<Object> args) { return messages.apply(key, args, lang); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletionStage;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons."}, {"ID": 526, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) { Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala(); Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(keyArgs.toSeq(), scalaArgs, lang); } \nResponse:", "ground_truth": "Translates the first defined message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " public play.api.i18n.Lang lang; List<String> keys; Object[] args; \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\nimport play.api.i18n.Lang;\nimport play.api.i18n.MessagesApi;\nimport scala.collection.JavaConverters;\nimport scala.collection.Seq;\n\npublic class Java_MessagesApi_Impl implements MessagesApi {\n    @Override\n    public String get(Lang lang, List<String> keys, Object... args) {\n        Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);\n        return Messages.apply(JavaConverters.asScalaBufferConverter(keys).asScala(), scalaArgs, lang);\n    }\n}\n"}, {"ID": 527, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); } \nResponse:", "ground_truth": "Check if a message key is defined.\n\n@param lang the message lang\n@param key the message key\n@return a Boolean", "predict": " public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); } \n\n*/\n\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.con"}, {"ID": 528, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given candidates.\n\nWill select a language from the candidates, based on the languages available, and fallback\nto the default language if none of the candidates are available.\n\n@param candidates the candidate languages\n@return the most appropriate Messages instance given the candidate languages", "predict": " public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); } \n\n*/\npackage play.api.i18n;\n\nimport scala.collection.Seq;\n\nimport java.util.List;\n\npublic class Messages {\n    public final Lang lang;\n    public final MessagesImpl impl;\n\n    public Messages(Lang lang, MessagesImpl impl) {\n        this.lang = lang;\n        this.impl = impl;\n    }\n\n    public Messages(Seq<Lang> candidates) {\n        this.lang = candidates.head();\n        this.impl = new MessagesImpl(this.lang, this);\n    }\n\n    public Messages preferred(Seq<Lang> candidates) {\n"}, {"ID": 529, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given request.\n\nWill select a language from the request, based on the languages available, and fallback to\nthe default language if none of the candidates are available.\n\n@param request the incoming request\n@return the preferred messages context for the request", "predict": " public play.api.i18n.Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); } \n\n*/\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Completion"}, {"ID": 530, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); } \nResponse:", "ground_truth": "Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.\n\n@param result the result where the lang will be set.\n@param lang the lang to set on the result\n@return a new result with the lang.", "predict": " public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the Java code for the following java Code. Code: public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); } \n\t\t\n\t\tString javaCode = \"public class JavaCodeGenerator { \" +\n\t\t\t\t\"public static void main(String[] args) { \" +\n\t\t\t\t\"Result result = new Result(); \" +\n\t\t\t\t\"Lang lang = new Lang(); \" +\n\t\t\t\t\"result.setLang(result, lang); \" +\n\t\t\t\t\"System.out.println(result.asJava()); \" +\n\t\t\t\t\"} \" +\n\t\t\t\t\"}\";\n\t\t\n\t\tSystem.out.println(javaCode);"}, {"ID": 531, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Add bindings from guiceable modules.\n\n@param modules the set of modules to bind\n@return a copy of this builder configured with those modules", "predict": " public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module) { return newBuilder(delegate.bindings(module)); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule... modules) { return newBuilder(delegate.bindings(module, Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule module1) { return newBuilder(delegate.bindings(module, module1)); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule module1, GuiceableModule... modules) { return newBuilder(delegate.bindings(module, module1, Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module, Guice"}, {"ID": 532, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Add bindings from Play modules.\n\n@param modules the set of Guice modules whose bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.inject.Binding;\nimport play.api.inject.Module;\nimport scala.collection.JavaConverters;\n\npublic class Guiceable {\n    public static Module[] modules(Module... modules) {\n        List<Module> list = new ArrayList<Module>();\n        for (Module module : modules) {\n            list.add(module);\n        }\n        return list.toArray(new Module[list.size()]);\n    }\n\n    public static Binding[] bindings(Binding... bindings) {\n        List<Binding> list = new ArrayList<Binding>();\n        for (Binding binding : bindings) {\n            list.add(binding);\n        }"}, {"ID": 533, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Add Play bindings.\n\n@param bindings the set of play bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Guiceable {\n    public static final String[] DEFAULT_BINDINGS = new String[] {\n        \"play.api.inject.Binding<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$T"}, {"ID": 534, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(GuiceableModule... modules) { return newBuilder(delegate.overrides(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override bindings using guiceable modules.\n\n@param modules the set of Guice modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(GuiceableModule module) { return newBuilder(delegate.overrides(module)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2) { return newBuilder(delegate.overrides(module1, module2)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3) { return newBuilder(delegate.overrides(module1, module2, module3)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3, GuiceableModule module4) { return newBuilder(delegate.overrides(module1, module2, module3, module4)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3"}, {"ID": 535, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override bindings using Play modules.\n\n@param modules the set of Play modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.inject.Binding;\nimport play.api.inject.Module;\nimport scala.collection.JavaConverters;\n\npublic class Guiceable {\n    public static Module[] modules(Module... modules) {\n        List<Module> list = new ArrayList<Module>();\n        for (Module module : modules) {\n            list.add(module);\n        }\n        return list.toArray(new Module[list.size()]);\n    }\n\n    public static Binding[] bindings(Binding... bindings) {\n        List<Binding> list = new ArrayList<Binding>();\n        for (Binding binding : bindings) {\n            list.add(binding);\n"}, {"ID": 536, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override bindings using Play bindings.\n\n@param bindings a set of Play bindings that override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Overrides {\n    \n    /**\n     * The Guice bindings to use for the method.\n     * @return\n     */\n    public Guiceable.Binding<?>[] value();\n}\n"}, {"ID": 537, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); } \nResponse:", "ground_truth": "Disable modules by class.\n\n@param moduleClasses the module classes whose bindings should be disabled\n@return a copy of this builder configured to ignore the provided module classes", "predict": " public final Self disable(Class<?> moduleClass) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass))); } \nResp public final Self disable(Class<?> moduleClass, Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClasses))); } \nResp public final Self disable(Class<?> moduleClass, Collection<? extends Class<?>> moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClasses))); } \nResp public final Self disable(Class<?> moduleClass, Class<?> moduleClass1, Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClass1), Scala.toSeq(moduleClasses)));"}, {"ID": 538, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \nResponse:", "ground_truth": "the\nmigration guide for more details.", "predict": " @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \n\n// TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \n\n// TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().add"}, {"ID": 539, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<Result> call( Request req) { // TODO: Make this method abstract after removing call(Context) return Context.safeCurrent() .map( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS)); Context.setCurrent(newCtx); return call(newCtx); }) .orElseGet( () -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents); ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>()); return call(ctx); }); } \nResponse:", "ground_truth": "", "predict": "\n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport static java.util.Optional.ofNullable;\n\npublic class Context {\n    private final Optional<Map<String, Object>> args;\n    private final Supplier<Map<String, Object>> contextComponents;\n\n    public Context(Optional<Map<String, Object>> args, Supplier<Map<String, Object>> contextComponents) {\n        this.args = args;\n        this.contextComponents = contextComponents;\n    }\n\n    public Context(Optional<Map<String, Object>> args) {\n        this(args, () -> new HashMap<>());\n    }\n\n    public Context(Supplier<Map<String, Object>> contextComponents) {\n        this(Optional.empty(), contextComponents);\n    }\n\n    public Context() {\n        this(Optional.empty"}, {"ID": 540, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \nResponse:", "ground_truth": "Retrieves a file relative to the application root path. This method returns an Optional, using\nempty if the file was not found.\n\n@param relativePath relative path of the file to fetch\n@return an existing file", "predict": " public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\n\npublic class JavaCodeGenerator {\n\n    public static void main(String[] args) {\n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional"}, {"ID": 541, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> Binding<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); } \nResponse:", "ground_truth": "Configure the scope for this binding.", "predict": " Response<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String JAVA_CODE_PREFIX = \"public class \";\n\tprivate static final String JAVA_CODE_SUFFIX = \" { } \";\n\t\n\tprivate static final String JAVA_CODE_PREFIX_WITH_ANNOTATION = \"public class \";\n\tprivate static final String JAVA_CODE_SUFFIX_WITH_ANNOTATION = \" { } \";\n\t\n\tprivate static final String JAVA_CODE_PREFIX_WITH_IMPORT = \"import \";\n\tprivate static final String JAVA_CODE_SUFFIX_WITH_IMPORT = \"; \";\n\t\n\tprivate static final String JAVA_CODE_P"}, {"ID": 542, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); } \nResponse:", "ground_truth": "Constructs a tuple of A,B\n\n@param a The a value\n@param b The b value\n@param  a's type\n@param  b's type\n@return The tuple", "predict": "\n\npublic static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tuple {\n    private List<Object> values;\n\n    public Tuple() {\n        values = new ArrayList<Object>();\n    }\n\n    public Tuple(Object... values) {\n        this.values = new ArrayList<Object>();\n        for (Object value : values) {\n            this.values.add(value);\n        }\n    }\n\n    public List<Object> getValues() {\n        return values;\n    }\n\n    public void setValues(List<Object> values) {\n        this.values = values;\n    }\n\n    public Object get(int index) {\n        return values.get(index);\n    }\n\n    "}, {"ID": 543, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); } \nResponse:", "ground_truth": "Constructs a tuple of A,B,C,D,E\n\n@param a The a value\n@param b The b value\n@param c The c value\n@param d The d value\n@param e The e value\n@param  a's type\n@param  b's type\n@param  c's type\n@param  d's type\n@param  e's type\n@return The tuple", "predict": "\n\npublic static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); } \n\n*/\n\npublic class Tuple5<A, B, C, D, E> {\n\tpublic final A a;\n\tpublic final B b;\n\tpublic final C c;\n\tpublic final D d;\n\tpublic final E e;\n\n\tpublic Tuple5(A a, B b, C c, D d, E e) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t\tthis.e = e;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \""}, {"ID": 544, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Executor toExecutor(ExecutionContext ec) { ExecutionContext prepared = ec.prepare(); if (prepared instanceof Executor) { return (Executor) prepared; } else { return prepared::execute; } } \nResponse:", "ground_truth": "Converts the execution context to an executor, preparing it first.\n\n@param ec the execution context.\n@return the Java Executor.", "predict": " Response<Executor>\n*/\n\npublic class Executor {\n    public static Response<Executor> toExecutor(ExecutionContext ec) {\n        ExecutionContext prepared = ec.prepare();\n        if (prepared instanceof Executor) {\n            return Response.success((Executor) prepared);\n        } else {\n            return Response.success(prepared::execute);\n        }\n    }\n}\n"}, {"ID": 545, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String name, String unitName) { return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given name and unit name.\n\n@param name the name for the entity manager factory\n@param unitName the persistence unit name as used in `persistence.xml`\n@return a default JPA configuration", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 546, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String n1, String u1, String n2, String u2) { return new DefaultJPAConfig( new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given names and unit names.\n\n@param n1 Name of the first entity manager factory\n@param u1 Name of the first unit\n@param n2 Name of the second entity manager factory\n@param u2 Name of the second unit\n@return a default JPA configuration with the provided persistence units.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class JPAConfigTest {\n\n\tprivate static EntityManagerFactory emf;\n\tprivate static EntityManager em;\n\tprivate static JPAConfig jpaConfig;\n\n\t@BeforeClass\n\tpublic static void setUpBeforeClass() throws Exception {\n\t\temf = Persistence.createEntityManagerFactory(\"test\");\n\t\tem = emf.createEntityManager();\n\t\tjpaConfig = new JPAConfig(em);\n\t}\n\n\t@AfterClass\n\tpublic"}, {"ID": 547, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig from(Map<String, String> map) { ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>(); for (Map.Entry<String, String> entry : map.entrySet()) { persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue())); } return new DefaultJPAConfig(persistenceUnits.build()); } \nResponse:", "ground_truth": "Create a default JPA configuration from a map of names to unit names.\n\n@param map Map of entity manager factory names to unit names\n@return a JPAConfig configured with the provided mapping", "predict": " ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id) { return new ResponseEntity<JPAConfig>(new JPAConfig(id), HttpStatus.OK); } \nResp ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id, @RequestParam(value = \"include\", required = false) String include) { return new ResponseEntity<JPAConfig>(new JPAConfig(id, include), HttpStatus.OK); } \nResp ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id, @RequestParam(value = \"include\", required = false) String include, @RequestParam(value = \"exclude\", required = false) String exclude) { return new ResponseEntity<JPAConfig>(new JPAConfig(id, include, exclude), HttpStatus.OK); } \nResp ResponseEntity"}, {"ID": 548, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<String, ByteString, NotUsed> string(String callbackName) { return Flow.of(String.class) .map( str -> { return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\"); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a Flow of escaped ByteString from a series of String elements. Calls out to Comet.flow\ninternally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Response.ok(ByteString.fromString(\"'Hello World'\")).build();\n\n*/\n\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.google.common.base.Preconditions;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.Single;\nimport io.reactivex.SingleObserver;\nimport io.reactivex.SingleSource;\nimport io.reactivex.functions.Function3;\nimport io.reactivex.functions.Function4;\nimport io.reactivex.functions.Function5;\nimport io.reactivex.functions.Function6;\nimport io.reactivex.functions.Function7;\nimport io.reactivex.functions.Function8;\nimport io.reactivex.functions.Function9;\nimport io.reactivex.functions.FunctionN;\n"}, {"ID": 549, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) { return Flow.of(JsonNode.class) .map( json -> { return ByteString.fromString(Json.stringify(json)); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode. Calls out to\nComet.flow internally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Response.ok(ByteString.fromString(\"{\\\"foo\\\":\\\"bar\\\"}\"));\n\n*/\n\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.reflect.TypeToken;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class FlowTest {\n\n  @Test\n  public void testFlow() {\n    Flow<String"}, {"ID": 550, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) { validators.put(key, () -> constraintValidator); return this; } \nResponse:", "ground_truth": "Adds validator as a singleton.\n\n@param key the constraint validator type\n@param constraintValidator the constraint validator instance\n@param  the type of constraint validator implementation\n@return {@link MappedConstraintValidatorFactory} with the given constraint validator added.", "predict": " public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, Supplier<T> constraintValidator) { validators.put(key, constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator, T defaultConstraintValidator) { validators.put(key, () -> constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, Supplier<T> constraintValidator, T defaultConstraintValidator) { validators.put(key, constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>>"}, {"ID": 551, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) { try { return key.getDeclaredConstructor().newInstance(); } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) { throw new RuntimeException(ex); } } \nResponse:", "ground_truth": "need to do so.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.run();\n    }\n\n    private void run() {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add"}, {"ID": 552, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method getMatchingAccessibleMethod( final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { try { final Method method = cls.getMethod(methodName, parameterTypes); MemberUtils.setAccessibleWorkaround(method); return method; } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null; final Method[] methods = cls.getMethods(); for (final Method method : methods) { // compare name and parameters if (method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod(method); if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) { bestMatch = accessibleMethod; } } } if (bestMatch != null) { MemberUtils.setAccessibleWorkaround(bestMatch); } if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) { final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes(); final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType(); final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName(); final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName(); final String parameterTypeSuperClassName = parameterTypes[parameterTypes.length - 1].getSuperclass().getName(); if (!methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) { return null; } } return bestMatch; } \nResponse:", "ground_truth": "Finds an accessible method that matches the given name and has compatible parameters.\nCompatible parameters mean that every method parameter is assignable from the given parameters.\nIn other words, it finds a method with the given name that will take the parameters given.\n\nThis method can match primitive parameter by passing in wrapper classes. For example, a\n{@code Boolean} will match a primitive {@code boolean} parameter.\n\n@param cls find method in this class\n@param methodName find method with this name\n@param parameterTypes find method with most compatible parameters\n@return The accessible method", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MethodUtils {\n\n    public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n        try {\n            final Method method = cls.getMethod(methodName, parameterTypes);\n            MemberUtils.setAccessibleWorkaround(method);\n            return method;\n        } catch (final NoSuchMethodException e) {\n            // NOPMD - Swallow the exception\n        }\n        // search through all methods\n        final List<Method> methods = new ArrayList<Method>(Arrays.asList(cls.getMethods()));\n        final List<Method> matchingMethods = new ArrayList<Method>();\n        for (final Method method : methods) {\n            // compare"}, {"ID": 553, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } } \nResponse:", "ground_truth": "Invoked when a client error occurs, that is, an error in the 4xx series.\n\nThe base implementation calls onBadRequest, onForbidden, onNotFound, or onOtherClientError\ndepending on the HTTP status code.\n\n@param request The request that caused the client error.\n@param statusCode The error status code. Must be greater or equal to 400, and less than 500.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } } \nResp @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404)"}, {"ID": 554, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.badRequest( views.html.defaultpages.badRequest.render( request.method(), request.uri(), message, request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a bad request.\n\nReturns Results.badRequest (400) with the included template from {@code\nviews.html.defaultpages.badRequest} as the content.\n\n@param request The request that was bad.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjdu"}, {"ID": 555, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onForbidden(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a request that was forbidden.\n\nReturns Results.forbidden (401) with the included template from {@code\nviews.html.defaultpages.unauthorized} as the content.\n\n@param request The forbidden request.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>My first Spring Boot application</title>\n\n    <!-- Bootstrap -->\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com"}, {"ID": 556, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onNotFound(RequestHeader request, String message) { if (environment.isProd()) { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.notFound.render( request.method(), request.uri(), request.asScala()))); } else { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.devNotFound.render( request.method(), request.uri(), Some.apply(routes.get()), request.asScala()))); } } \nResponse:", "ground_truth": "Invoked when a handler or resource is not found.\n\nIf the environment's mode is production, then returns Results.notFound (404) with the\nincluded template from `views.html.defaultpages.notFound` as the content.\n\nOtherwise, Results.notFound (404) is rendered with {@code\nviews.html.defaultpages.devNotFound} template.\n\n@param request The request that no handler was found to handle.\n@param message A message, which is not used by the default implementation.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjdu"}, {"ID": 557, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return CompletableFuture.completedFuture(Results.internalServerError()); } } \nResponse:", "ground_truth": "Invoked when a server error occurs.\n\nBy default, the implementation of this method delegates to [[onProdServerError()]] when in\nprod mode, and [[onDevServerError()]] in dev mode. It is recommended, if you want Play's debug\ninfo on the error page in dev mode, that you override [[onProdServerError()]] instead of this\nmethod.\n\n@param request The request that triggered the server error.\n@param exception The server error.\n@return a CompletionStage containing the Result.", "predict": " @Override public Response onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return Response.serverError().build(); } } \nResp @Override public Response onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return Response.serverError()."}, {"ID": 558, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void logServerError(RequestHeader request, UsefulException usefulException) { logger.error( String.format( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException); } \nResponse:", "ground_truth": "Responsible for logging server errors.\n\nThe base implementation uses a SLF4J Logger. If a special annotation is desired for internal\nserver errors, you may want to use SLF4J directly with the Marker API to distinguish server\nerrors from application errors.\n\nThis can also be overridden to add additional logging information, eg. the id of the\nauthenticated user.\n\n@param request The request that triggered the server error.\n@param usefulException The server error.", "predict": " ResponseHeader response = new ResponseHeader(StatusCode.INTERNAL_SERVER_ERROR, \"Internal server error\");\n\n*/\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tHttpClient httpclient = new DefaultHttpClient();\n\t\tHttpGet httpget = new HttpGet(\"http://localhost:8080/test/test\");\n\t\t\n\t\ttry {\n\t\t\tHttpResponse response = httpclient.execute("}, {"ID": 559, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final UsefulException throwableToUsefulException(final Throwable throwable) { return HttpErrorHandlerExceptions.throwableToUsefulException( sourceMapper.sourceMapper(), environment.isProd(), throwable); } \nResponse:", "ground_truth": "Convert the given exception to an exception that Play can report more information about.\n\nThis will generate an id for the exception, and in dev mode, will load the source code for\nthe code that threw the exception, making it possible to report on the location that the\nexception was thrown from.", "predict": " Response.ok().entity(throwableToUsefulException(throwable)).build();\n\n}\n\n}\n"}, {"ID": 560, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in dev mode when a server error occurs. Note that this method is where the URL set by\nplay.editor is used.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.devError}.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " public CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); } \n\n*/\n\npackage controllers.defaultpages;\n\nimport com.feth.play.module.pa.PlayAuthenticate;\nimport com.feth.play.module.pa.user.AuthUser;\nimport com.feth.play.module.pa.user.NoAuthUser;\nimport com.feth.play.module.pa.user.NoAuthUserFound;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUser;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUser$;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUserFactory;\n"}, {"ID": 561, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in prod mode when a server error occurs.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.error} template.\n\nOverride this rather than [[onServerError()]] if you don't want to change Play's debug\noutput when logging errors in dev mode.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>My first Spring Boot application</title>\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n"}, {"ID": 562, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); } \nResponse:", "ground_truth": "Create a BuildDocHandler that serves documentation from the given files, which could either be\ndirectories or jar files. The baseDir array must be the same length as the files array, and the\ncorresponding entry in there for jar files is used as a base directory to use resources from in\nthe jar.\n\n@param files The directories or jar files to serve documentation from.\n@param baseDirs The base directories for the jar files. Entries may be null.\n@return a BuildDocHandler.", "predict": " public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); } \n\n*/\n"}, {"ID": 563, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectory(File directory) { FileRepository repo = new FilesystemRepository(directory); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given directory by wrapping a\nFilesystemRepository.\n\n@param directory The directory to serve the documentation from.", "predict": " Response is a generic type. It is used to return the result of a request.\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double unary minus operator.\n */\npublic class DoubleUnaryMinusOperatorTerm\n  extends GenericStackableOperatorTerm<Double>\n  implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   */\n  public DoubleUnaryMinusOperatorTerm(Term<Double> base) {\n    super(base);\n"}, {"ID": 564, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) { return fromDirectoryAndJar(directory, jarFile, base, false); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Response is generated by the method.\n*/\n\npublic class BuildDocHandler {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString base = \"\";\n\t\t\tif (args.length > 0) {\n\t\t\t\tbase = args[0];\n\t\t\t}\n\t\t\tFile directory = new File(\".\");\n\t\t\tJarFile jarFile = new JarFile(base);\n\t\t\tString[] files = directory.list();\n\t\t\tfor (String file : files) {\n\t\t\t\tif (file.endsWith(\".java\")) {\n\t\t\t\t\tString className = file.substring(0, file.length() - 5);\n\t\t\t\t\tString classNameWithPackage = className.replace(\"/\", \".\");\n\t\t\t\t\tSystem.out.println(\"Processing \" + classNameWithPackage);\n\t\t\t\t\tClass<?> clazz = Class.forName(classNameWithPackage);\n\t\t\t\t\tMethod[] methods = clazz.getMethods();\n\t\t\t\t\tfor (Method method : methods) {\n\t\t\t\t\t\tif"}, {"ID": 565, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.\n@param fallbackToJar Whether the doc handler should fall back to the jar repo for docs.", "predict": " Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern"}, {"ID": 566, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromJar(JarFile jarFile, String base) { FileRepository repo = new JarRepository(jarFile, Option.apply(base)); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a\nJarRepository.\n\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Response to the request.\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double to String.\n */\npublic class DoubleToStringOperator extends GenericStackableOperatorTerm<String> {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   */\n  public DoubleToStringOperator(Term base) {\n    super(base);\n  }\n\n  @Override\n  public String calculateDefault(FormulaEvaluatorConfiguration conf,\n                                 Double v1, Double v2) {"}, {"ID": 567, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResponse:", "ground_truth": "Consumes the data.\n\nThis method should be used carefully, since if the source represents an ephemeral stream,\nthen the entity may not be usable after this method is invoked.\n\n@param mat the application's materializer.\n@return a CompletionStage holding the data", "predict": " public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \n\n// The following java Code is generated. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResp public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \n\n// The following java Code is generated. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResp public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), Byte"}, {"ID": 568, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given content.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); } \n\n*/\n\nimport java.util.Optional;\n\npublic class Strict {\n    private final ByteString content;\n    private final Optional<String> contentType;\n\n    public Strict(ByteString content, Optional<String> contentType) {\n        this.content = content;\n        this.contentType = contentType;\n    }\n\n    public ByteString content() {\n        return content;\n    }\n\n    public Optional<String> contentType() {\n        return contentType;\n    }"}, {"ID": 569, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromString(String content, String charset) { return new Strict( ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given String.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " ResponseEntity<byte[]> fromString(String content, String charset) { return new ResponseEntity<byte[]>(ByteString.fromString(content, charset).toByteArray(), HttpStatus.OK); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class HttpEntity {\n    private final ByteString content;\n    private final Optional<String> contentType;\n\n    public HttpEntity(ByteString content, Optional<String> contentType) {\n        this.content = content;\n        this.contentType = contentType;\n    }\n\n    public ByteString getContent() {\n        return content;\n    }\n\n    public Optional<String> getContentType() {\n        return contentType;\n    }\n\n    public static HttpEntity fromString(String content, String charset) {\n        return new HttpEntity(ByteString"}, {"ID": 570, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); } \nResponse:", "ground_truth": "Convert the given source of ByteStrings to a chunked entity.\n\n@param data The source.\n@param contentType The optional content type.\n@return The ByteStrings.", "predict": " ResponseEntity<byte[]> chunked(HttpEntity<ByteString> chunk, Optional<String> contentType) { return new ResponseEntity<>(chunk.getBody(), chunk.getHeaders(), chunk.getStatusCode()); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Chunked {\n    private final Supplier<HttpEntity<ByteString>> supplier;\n    private final Optional<String> contentType;\n\n    public Chunked(Supplier<HttpEntity<ByteString>> supplier, Optional<String> contentType) {\n        this.supplier = supplier;\n        this.contentType = contentType;\n    }\n\n    public static Chunked chunked(Supplier<HttpEntity<ByteString>> supplier, Optional<String> contentType) {\n        return new Chunked(supplier, contentType);\n    }\n\n    public static"}, {"ID": 571, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content) { return status(status, content, JsonEncoding.UTF8); } \nResponse:", "ground_truth": "Generates a simple result with json content and UTF8 encoding.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content as a play-json object\n@return the result", "predict": " Response(int status, JsonNode content, JsonEncoding encoding) {\n    this.status = status;\n    this.content = content;\n    this.encoding = encoding;\n}\n\n*/\n\npackage com.github.fge.grappa.matchers;\n\nimport com.github.fge.grappa.matchers.base.Matcher;\nimport com.github.fge.grappa.matchers.base.MatcherType;\nimport com.github.fge.grappa.run.MatcherContext;\n\nimport java.util.Objects;\n\n/**\n * Matches a JSON node with a given name.\n */\npublic final class JsonNodeMatcher\n    extends Matcher\n{\n    private final String name;\n\n    public JsonNodeMatcher(final String name)\n    {\n        super(MatcherType.JSON_NODE);\n        this.name = Objects.requireNonNull(name"}, {"ID": 572, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content, JsonEncoding encoding) { if (content == null) { throw new NullPointerException(\"Null content\"); } return status(status).sendJson(content, encoding); } \nResponse:", "ground_truth": "Generates a simple result with json content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a play-json object\n@param encoding the encoding into which the json should be encoded\n@return the result", "predict": " Response.status(status).sendJson(content, encoding);\n\n*/\n\npackage com.example.mydemo.http.response;\n\nimport com.example.mydemo.http.HttpStatus;\nimport com.example.mydemo.http.JsonNode;\nimport com.example.mydemo.http.JsonEncoding;\nimport com.example.mydemo.http.JsonEncoder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderBuilder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext.JsonEncoderContextBuilder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext.JsonEncoderContextBuilder.JsonEncoderContextBuilderContext;\nimport com."}, {"ID": 573, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, byte[] content) { if (content == null) { throw new NullPointerException(\"Null content\"); } return new Result( status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty())); } \nResponse:", "ground_truth": "Generates a simple result with byte-array content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a byte array\n@return the result", "predict": " Response(int status, HttpEntity entity) { this.status = status; this.entity = entity; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.google.common.base.Optional;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations.ApiResponse;\nimport io.swagger.annot"}, {"ID": 574, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, InputStream content, long contentLength) { return status(status).sendInputStream(content, contentLength); } \nResponse:", "ground_truth": "Generates a chunked result.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the input stream containing data to chunk over\n@param contentLength the length of the provided content in bytes.\n@return the result", "predict": " Response.status(status).sendInputStream(content, contentLength);\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.ResponseHandler;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class HttpClient {\n\t\n\tprivate static final AtomicInteger threadId = new AtomicInteger"}, {"ID": 575, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, File content) { return status(status, content, StaticFileMimeTypes.fileMimeTypes()); } \nResponse:", "ground_truth": "Generates a result with file contents.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the file to send\n@return the result", "predict": "\n\npublic static Result status(int status, File content, MimeTypes mimeTypes) {\n    return status(status, content, mimeTypes, null);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType) {\n    return status(status, content, mimeTypes, contentType);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType) {\n    return status(status, content, mimeTypes, contentType, null);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType, String contentDisposition) {\n    return status(status, content, mimeTypes, contentType, contentDisposition);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType, String contentDisposition) {\n    return status(status, content"}, {"ID": 576, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private User findById(Long id) { if (id > 3) return null; User user = new User(); user.id = id; user.name = \"User \" + String.valueOf(id); return user; } \nResponse:", "ground_truth": "designed to be lightweight operation", "predict": "\n\npublic User findById(Long id) {\n    if (id > 3) return null;\n    User user = new User();\n    user.id = id;\n    user.name = \"User \" + String.valueOf(id);\n    return user;\n}\n\n*/\n\npublic class JavaCodeGenerator {\n    public static void main(String[] args) {\n        String className = \"User\";\n        String methodName = \"findById\";\n        String methodReturnType = \"User\";\n        String methodParameters = \"Long id\";\n        String methodComment = \"\";\n        String methodBody = \"\";\n        String methodBodyComment = \"\";\n        String methodBodyComment2 = \"\";\n        String methodBodyComment3 = \"\";\n        String methodBodyComment4 = \"\";\n        String methodBodyComment5 = \"\";\n        String methodBodyComment6 = \"\";\n        String methodBodyComment7 = \"\";\n        String methodBodyComment"}, {"ID": 577, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); } \nResponse:", "ground_truth": "Select a preferred language, given the list of candidates.\n\nWill select the preferred language, based on what languages are available, or return the\ndefault language if none of the candidates are available.\n\n@param candidates The candidate languages\n@return The preferred language", "predict": " Resp public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.spark.SparkConf;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.api.java.function.Function;\nimport org.apache.spark.api.java.function.PairFunction;\nimport org.apache.spark.mllib.linalg.Vectors;\nimport org.apache.spark.mllib.regression.LabeledPoint;\nimport org.apache.spark.mllib.tree.RandomForest;"}, {"ID": 578, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); } \nResponse:", "ground_truth": "Append a unique identifier to the URL.\n\n@return a copy if this call with a unique identifier to this url", "predict": " public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); } \n\n*/\n\npackage play.api.mvc;\n\nimport java.util.concurrent.CompletionStage;\n\nimport play.mvc.Http.Request;\nimport play.mvc.Result;\n\n/**\n * The Call class represents a request to a controller method.\n *\n * @author Michael Lavelle\n */\npublic class Call {\n\n    /**\n     * The method to call.\n     */\n    public final String method;\n\n    /**\n     * The URL to call.\n     */\n    public final String url;\n\n    /**\n     * The fragment to call.\n     */\n    public final String fragment;\n\n    /**\n     * The request.\n     */\n    public final Request request;\n\n    /**\n     * The result.\n     */\n    public final CompletionStage<"}, {"ID": 579, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); } \nResponse:", "ground_truth": "Returns a new Call with the given fragment.\n\n@param fragment the URL fragment\n@return a copy of this call that contains the fragment", "predict": " public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); } \n\n*/\n\npackage play.api.mvc;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation is used to mark a method as a controller method.\n *\n * @see Controller\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Controller {\n    /**\n     * The controller method name.\n     */\n    String value();\n}\n"}, {"ID": 580, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String absoluteURL(Http.Request request) { return absoluteURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an absolute URL.\n\n@param request used to identify the host and protocol that should base this absolute URL\n@return the absolute URL string", "predict": " Response.ok()\n\n*/\n\npackage com.example.android.sunshine.app;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.text.TextUtils;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * Created by karan on 9/30/15.\n */\npublic class Utility {\n    public static String getPreferredLocation(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context.getString(R.string.pref_location_key),\n                context.getString(R.string.pref_location_default));\n    }\n\n    public static boolean isMetric(Context context) {\n        SharedPreferences prefs = PreferenceManager.get"}, {"ID": 581, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String webSocketURL(Http.Request request) { return webSocketURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an WebSocket URL.\n\n@param request used as the base for forming the WS url\n@return the websocket url string", "predict": " Response.ok()\n\n*/\n\npackage com.example.android.sunshine.app;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.text.TextUtils;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class Utility {\n    public static String getPreferredLocation(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context.getString(R.string.pref_location_key),\n                context.getString(R.string.pref_location_default));\n    }\n\n    public static boolean isMetric(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context"}, {"ID": 582, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new AbstractFunction1<Connection, BoxedUnit>() { public BoxedUnit apply(Connection connection) { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionRunnable.\n\n@param block a Java functional interface instance to wrap\n@return a scala function that wraps the given block", "predict": " Response<BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new Response<BoxedUnit>() { public BoxedUnit getBody() { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<Boxed"}, {"ID": 583, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) { return new AbstractFunction1<Connection, A>() { public A apply(Connection connection) { try { return block.call(connection); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionCallable.\n\n@param block a Java functional interface instance to wrap\n@param  the provided block's return type\n@return a scala function wrapping the given block", "predict": " Response<A> connectionFunction(final ConnectionCallable<A> block) { return new Response<A>() { public A get() { try { return block.call(); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<String> future = executor.submit(new Callable<String>() {"}, {"ID": 584, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) { return new Builder().mode(mode).http(port).build(block); } \nResponse:", "ground_truth": "Create a server for the router returned by the given block.\n\n@param block The block which creates a router.\n@param mode The mode the server will run on.\n@param port The port the server will run on.\n@return The running server.", "predict": "\n\n*/\n\npublic class Builder {\n    private Mode mode;\n    private int httpPort;\n    private Function<BuiltInComponents, Router> router;\n\n    public Builder mode(Mode mode) {\n        this.mode = mode;\n        return this;\n    }\n\n    public Builder http(int httpPort) {\n        this.httpPort = httpPort;\n        return this;\n    }\n\n    public Builder router(Function<BuiltInComponents, Router> router) {\n        this.router = router;\n        return this;\n    }\n\n    public Server build(Function<BuiltInComponents, Router> router) {\n        return new Server(mode, httpPort, router);\n    }\n}\n"}, {"ID": 585, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts an object to JsonNode.\n\n@param data Value to convert in Json.\n@return the JSON node.", "predict": " public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleComparator;\nimport org.apache.commons.lang3.tuple.TripleFactory;\nimport org.apache.commons.lang3.tuple.TripleImpl;\nimport org.apache.commons.lang3.tuple.TripleImpl.Tri"}, {"ID": 586, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts a JsonNode to a Java value\n\n@param  the type of the return value.\n@param json Json value to convert.\n@param clazz Expected Java value type.\n@return the return value.", "predict": " public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\npublic class JsonUtils {\n\n\tpublic static <T> T fromJson(JsonNode json, Class<T> clazz) {\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\ttry {\n\t\t\treturn mapper.treeToValue("}, {"ID": 587, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(String src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON string.\n@return the JSON node.", "predict": " Response(JsonNode node) { this.node = node; }\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.utils.URLEncodedUtils;\nimport org.apache.http.impl.client"}, {"ID": 588, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a InputStream representing a json, and return it as a JsonNode.\n\n@param src the JSON input stream.\n@return the JSON node.", "predict": " public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonMappingException;"}, {"ID": 589, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relative(String startPath, String targetPath) { // If the start and target path's are the same then link to the current directory if (startPath.equals(targetPath)) { return CURRENT_DIR; } String[] start = toSegments(canonical(startPath)); String[] target = toSegments(canonical(targetPath)); // If start path has no trailing separator (a \"file\" path), then drop file segment if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1); // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = \"\"; if (!targetPath.endsWith(SEPARATOR)) { targetFile = target[target.length - 1]; target = Arrays.copyOfRange(target, 0, target.length - 1); } // Work out how much of the filepath is shared by start and path. String[] common = commonPrefix(start, target); String[] parents = toParentDirs(start.length - common.length); int relativeStartIdx = common.length; String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length); String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length); System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length); // If this is not a sibling reference append a trailing / to path String trailingSep = \"\"; if (relativePath.length > 0) trailingSep = SEPARATOR; return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR)) + trailingSep + targetFile; } \nResponse:", "ground_truth": "Create a path to targetPath that's relative to the given startPath.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        String startPath = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test\\\\\";\n        String targetPath = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test\\\\\";\n        String relativePath = \"\";\n        String targetFile = \"\";\n        String[] start = toSegments(canonical(startPath));\n        String[] target = toSegments(canonical(targetPath));\n        String[] common = commonPrefix(start, target);\n        String[] parents = toParentDirs(start.length - common.length);\n        int relative"}, {"ID": 590, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String canonical(String url) { String[] urlPath = toSegments(url); Stack<String> canonical = new Stack<>(); for (String comp : urlPath) { if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue; if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp); else canonical.pop(); } String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\"; String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\"; return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep; } \nResponse:", "ground_truth": "Create a canonical path that does not contain parent directories, current directories, or\nsuperfluous directory separators.", "predict": "\n\npublic static String canonical(String url) {\n    String[] urlPath = toSegments(url);\n    Stack<String> canonical = new Stack<>();\n    for (String comp : urlPath) {\n        if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue;\n        if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp);\n        else canonical.pop();\n    }\n    String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\";\n    String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\";\n    return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep;\n}\n\npublic static String canonical(String url) {\n    String[] urlPath = toSegments(url"}, {"ID": 591, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Converts a set of constraints to human-readable values. Does not guarantee the order of the\nreturned constraints.\n\nThis method calls {@code displayableConstraint} under the hood.\n\n@param constraints the set of constraint descriptors.\n@return a list of pairs of tuples assembled from displayableConstraint.", "predict": "\n\npublic static List<Tuple<String, List<Object>>> displayableConstraint(ConstraintDescriptor<?> constraint) {\n    return constraint.getAnnotation().annotationType().isAnnotationPresent(Display.class) ? constraint.getAnnotation().annotationType().getAnnotation(Display.class).value() : Collections.emptyList();\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class DisplayableConstraint {\n\n    public static List<Tuple<String, List<Object>>> displayableConstraint(ConstraintDescriptor<?> constraint) {\n        return constraint.getAnnotation().annotationType().isAnnotationPresent(Display.class) ? constraint.getAnnotation().annotationType().getAnnotation(Display.class).value() : Collections.emptyList();\n    }\n\n    public static List<T"}, {"ID": 592, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Tuple<String, List<Object>> displayableConstraint( ConstraintDescriptor<?> constraint) { final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class); return Tuple( displayAnnotation.name(), Collections.unmodifiableList( Stream.of(displayAnnotation.attributes()) .map(attr -> constraint.getAttributes().get(attr)) .collect(Collectors.toList()))); } \nResponse:", "ground_truth": "Converts a constraint to a human-readable value.\n\n@param constraint the constraint descriptor.\n@return A tuple containing the constraint's display name and the constraint attributes.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons."}, {"ID": 593, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResponse:", "ground_truth": "Creates a CompletionStage that returns either the input stage, or a futures.\n\nNote that timeout is not the same as cancellation. Even in case of futures, the given\ncompletion stage will still complete, even though that completed value is not returned.\n\n@param stage the input completion stage that may time out.\n@param amount The amount (expressed with the corresponding unit).\n@param unit The time Unit.\n@param  the completion's result type.\n@return either the completed future, or a completion stage that failed with futures.", "predict": " @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final FiniteDuration duration) { requireNonNull(stage, \"Null stage\"); requireNonNull(duration, \"Null duration\"); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResp @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final Duration duration) { requireNonNull(stage, \"Null stage\"); requireNonNull(duration, \"Null duration\"); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResp @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit, final Executor executor) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); require"}, {"ID": 594, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAssignable( Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) { return false; } if (classArray == null) { classArray = EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } \nResponse:", "ground_truth": "Checks if an array of Classes can be assigned to another array of Classes.\n\nThis method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in\nthe input arrays. It can be used to check if a set of arguments (the first parameter) are\nsuitably compatible with a set of method parameter types (the second parameter).\n\nUnlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into\naccount widenings of primitive classes and {@code null}s.\n\nPrimitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code\ndouble}. This method returns the correct result for these cases.\n\n{@code Null} may be assigned to any reference type. This method will return {@code true} if\n{@code null} is passed in and the toClass is non-primitive.\n\nSpecifically, this method tests whether the type represented by the specified {@code Class}\nparameter can be converted to the type represented by this {@code Class} object via an identity\nconversion widening primitive or widening reference conversion. See The Java Language Specification, sections\n5.1.1, 5.1.2 and 5.1.4 for details.\n\n@param classArray the array of Classes to check, may be {@code null}\n@param toClassArray the array of Classes to try to assign into, may be {@code null}\n@param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n@return {@code true} if assignment possible", "predict": "\n\npublic static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n\tif (classArray == null) {\n\t\tclassArray = EMPTY_CLASS_ARRAY;\n\t}\n\tif (toClassArray == null) {\n\t\ttoClassArray = EMPTY_CLASS_ARRAY;\n\t}\n\tif (classArray.length != toClassArray.length) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < classArray.length; i++) {\n\t\tif (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\npublic static boolean isAssignable(Class<?> clazz, Class<?> toClass, boolean autoboxing) {\n\tif (clazz == null) {\n"}, {"ID": 595, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Date parseCRONExpression(String cron) { try { return new CronExpression(cron).getNextValidTimeAfter(new Date()); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Parses a CRON expression.\n\n@param cron the CRON String\n@return the next Date that satisfies the expression", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CronExpression {\n    private static final String MINUTE = \"\\\\d{1,2}\";\n    private static final String HOUR = \"\\\\d{1,2}\";\n    private static final String DAY_OF_MONTH = \"\\\\d{1,2}\";\n    private static final String MONTH = \"\\\\d{1,2}\";\n    private static final String YEAR = \"\\\\d{4}\";\n    private static final String WEEKDAY = \"\\\\w\";\n    private"}, {"ID": 596, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long cronInterval(String cron, Date date) { try { return new CronExpression(cron).getNextInterval(date); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Compute the number of milliseconds between the next valid date and the one after.\n\n@param cron the CRON String\n@param date the date to start search\n@return the number of milliseconds between the next valid date and the one after, with an\ninvalid interval between", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone"}, {"ID": 597, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); } \nResponse:", "ground_truth": "Creates WS client manually from configuration, internally creating a new instance of\nAsyncHttpClient and managing its own thread pool.\n\nThis client is not managed as part of Play's lifecycle, and must be closed by calling\nws.close(), otherwise you will run into memory leaks.\n\n@param config a config object, usually from AhcWSClientConfigFactory\n@param cache if not null, provides HTTP caching.\n@param materializer an Akka materializer\n@return a new instance of AhcWSClient.", "predict": " public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); } \n\n*/\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.Http"}, {"ID": 598, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder builder(ApplicationLoader.Context context) { return initialBuilder .in(context.environment()) .loadConfig(context.initialConfig()) .overrides(overrides(context)); } \nResponse:", "ground_truth": "Construct a builder to use for loading the given context.\n\n@param context the context the returned builder will load\n@return the builder", "predict": " Response.ok().build();\n\n@Override\npublic Response.ResponseBuilder responseBuilder() {\n\treturn Response.ok();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status) {\n\treturn Response.status(status).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message) {\n\treturn Response.status(status).entity(message).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message, Object... args) {\n\treturn Response.status(status).entity(String.format(message, args)).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message, Throwable throwable) {\n\treturn Response.status(status).entity(message + \": \" + throwable.getMessage()).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder"}, {"ID": 599, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); } \nResponse:", "ground_truth": "Generates a 501 NOT_IMPLEMENTED simple result.", "predict": " public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); } \n\n*/\n\npackage controllers\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/julienc91/heygo/app/models\"\n\t\"github.com/julienc91/heygo/app/utils\"\n)\n\n// TODO: Add a description of the controller here.\ntype TodoController struct {\n\t*utils.BaseController\n}\n\n// TODO: Add a description of the controller here.\nfunc (c *TodoController) Index(w http.ResponseWriter, r *http.Request) {\n\t// TODO: Add a description of the controller here."}, {"ID": 600, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void session(String key, String value) { session().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the current session.\n\n@param key the key to set into the session\n@param value the value to set for key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " @Deprecated public static void session(String key, String value) { session().put(key, value); } \n\n*/\n\npublic class Session {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new session\n\t\tSession session = new Session();\n\t\t\n\t\t// Set the session value\n\t\tsession.set(\"key\", \"value\");\n\t\t\n\t\t// Get the session value\n\t\tString value = session.get(\"key\");\n\t\t\n\t\t// Print the session value\n\t\tSystem.out.println(value);\n\t\t\n\t\t// Close the session\n\t\tsession.close();\n\t\t\n\t}\n\t\n\t// Set the session value\n\tpublic void set(String key, String value) {\n\t\t\n\t\t// Create a new session\n\t\tSession session = new Session();\n\t\t\n\t\t// Set the session value\n\t\tsession.set(key, value);\n\t\t\n\t\t// Close the session\n\t\tsession.close();\n"}, {"ID": 601, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void flash(String key, String value) { flash().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the flash scope.\n\n@param key the key to put into the flash scope\n@param value the value corresponding to key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " @Deprecated public static void flash(String key, String value) { flash().put(key, value); } \n\n*/\n\npublic class Flash {\n\t\n\tpublic static void put(String key, String value) {\n\t\t\n\t\tif (key == null || value == null) {\n\t\t\tthrow new IllegalArgumentException(\"key and value cannot be null\");\n\t\t}\n\t\t\n\t\tif (key.length() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"key cannot be empty\");\n\t\t}\n\t\t\n\t\tif (value.length() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"value cannot be empty\");\n\t\t}\n\t\t\n\t\tif (key.length() > 255) {\n\t\t\tthrow new IllegalArgumentException(\"key cannot be longer than 255 characters\");\n\t\t}\n\t\t\n\t\tif (value.length() > 255) {\n\t\t\tthrow new IllegalArgumentException(\"value cannot be longer than 255 characters\");\n\t\t}\n\t\t"}, {"ID": 602, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given instance of an annotation.\n\nThis can be used to specify bindings with annotations that have particular values.", "predict": " Response<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); } \n\n*/\n\npublic class BindingKey<T> {\n\t\n\tprivate final BindingKey<T> underlying;\n\t\n\tpublic BindingKey(BindingKey<T> underlying) {\n\t\tthis.underlying = underlying;\n\t}\n\t\n\tpublic BindingKey<T> asJava() {\n\t\treturn this;\n\t}\n\t\n\tpublic Response<T> asJava(Response<T> response) {\n\t\treturn response;\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance) {\n\t\treturn underlying.qualifiedWith(instance);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance, final Response<T> response) {\n\t\treturn underlying.qualifiedWith(instance, response);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance"}, {"ID": 603, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given annotation.\n\nFor example, you may have both a cached implementation, and a direct implementation of a\nservice. To differentiate between them, you may define a Cached annotation:\n\n{@code\nbindClass(Foo.class).qualifiedWith(Cached.class).to(FooCached.class),\nbindClass(Foo.class).to(FooImpl.class)\n\n...\n\nclass MyController {\n{@literal @}Inject\nMyController({@literal @}Cached Foo foo) {\n...\n}\n...\n}\n}\n\nIn the above example, the controller will get the cached {@code Foo} service.", "predict": " Response<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation); } \n\n*/\n\npublic class BindingKey<T> {\n\t\n\tprivate final BindingKey<T> underlying;\n\t\n\tpublic BindingKey(BindingKey<T> underlying) {\n\t\tthis.underlying = underlying;\n\t}\n\t\n\tpublic BindingKey<T> asJava() {\n\t\treturn new BindingKey<T>(underlying.asJava());\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Class<? extends Annotation> annotation) {\n\t\treturn underlying.qualifiedWith(annotation);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation annotation) {\n\t\treturn underlying.qualifiedWith(annotation);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation annotation, final Class<? extends Annotation> annotation2) {\n\t\treturn underlying.qualifiedWith"}, {"ID": 604, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given implementation class.\n\nThis class will be instantiated and injected by the injection framework.", "predict": " Response<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String JAVA_PACKAGE_PREFIX = \"java.lang.\";\n\tprivate static final String JAVA_PACKAGE_SUFFIX = \"\";\n\tprivate static final String JAVA_PACKAGE_SEPARATOR = \".\";\n\t\n\tprivate static final String JAVA_PACKAGE_PREFIX_WITH_SEPARATOR = JAVA_PACKAGE_PREFIX + JAVA_PACKAGE_SEPARATOR;\n\tprivate static final String JAVA_PACKAGE_SUFFIX_WITH_SEPARATOR = JAVA_PACKAGE_SUFFIX + JAVA_PACKAGE_SEPARATOR;\n\t\n\tprivate static final String J"}, {"ID": 605, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider instance.\n\nThis provider instance will be invoked to obtain the implementation for the key.", "predict": " Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResponse"}, {"ID": 606, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given instance.", "predict": " public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); } \n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)); } \n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final"}, {"ID": 607, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to another binding key.", "predict": " Response<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder, final Response.ResponseBuilder errorResponseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder, errorResponseBuilder); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder, final Response.ResponseBuilder errorResponseBuilder, final Response.ResponseBuilder errorResponseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder, errorResponseBuilder, errorResponseBuilder); } \nResp"}, {"ID": 608, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) { return underlying.toProvider(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider class.\n\nThe dependency injection framework will instantiate and inject this provider, and then\ninvoke its `get` method whenever an instance of the class is needed.", "predict": " public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response) { return underlying.toProvider(provider, response).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener) { return underlying.toProvider(provider, response, errorListener).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener, final Response.Listener<T> listener) { return underlying.toProvider(provider, response, errorListener, listener).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener, final Response.Listener<T>"}, {"ID": 609, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Lang> availables(Application app) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables()); return availableLangs.stream().map(Lang::new).collect(toList()); } \nResponse:", "ground_truth": "Retrieve Lang availables from the application configuration.\n\n@param app the current application.\n@return the list of available Lang.", "predict": " public static play.libs.F.Promise<Result> index(Application app) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs, play.api.i18n.Lang lang) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs, play.api.i"}, {"ID": 610, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); } \nResponse:", "ground_truth": "Guess the preferred lang in the langs set passed as argument. The first Lang that matches an\navailable Lang wins, otherwise returns the first Lang available in this application.\n\n@param app the currept application\n@param availableLangs the set of langs from which to guess the preferred\n@return the preferred lang.", "predict": " public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); } \n\n*/\n\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.stream.Stream;\n\nimport play.api.i18n.Langs;\nimport play.api.i18n.Lang;\nimport scala.collection.Seq;\n\npublic class LangsJava {\n\n    public"}, {"ID": 611, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); } \nResponse:", "ground_truth": "Create an evolutions reader based on a simple map of database names to evolutions.\n\n@param evolutions The map of database names to evolutions.\n@return the evolutions reader.", "predict": " public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.db.evolutions.EvolutionsReader;\nimport play.api.db.evolutions.EvolutionsWriter;\nimport play.api.db.evolutions.EvolutionsWriter.Evolution;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType.EvolutionTypeEnum;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType.EvolutionTypeEnum.EvolutionTypeEnumBuilder;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType."}, {"ID": 612, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); } \nResponse:", "ground_truth": "Create an evolutions reader for the default database from a list of evolutions.\n\n@param evolutions The list of evolutions.\n@return the evolutions reader.", "predict": " public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); } \n\n*/\n\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.SortedMap;\nimport java.util.SortedSet;"}, {"ID": 613, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cleanupEvolutions(Database database, boolean autocommit, String schema) { DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema); evolutions.evolve(evolutions.resetScripts(), autocommit); } \nResponse:", "ground_truth": "Cleanup evolutions for the given database.\n\nThis will run the down scripts for all the applied evolutions.\n\n@param database The database to apply the evolutions to.\n@param autocommit Whether autocommit should be used.\n@param schema The schema where all the play evolution tables are saved in", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.spark.SparkConf;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.api.java.function.Function;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.types.DataTypes;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\n\nimport scala.Tuple2;\n\npublic class DatabaseEvolutions {\n\t\n\tprivate static final String DATABASE_NAME = \"database\";\n"}, {"ID": 614, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); } \nResponse:", "ground_truth": "Set the initial configuration loader. Overrides the default or any previously configured\nvalues.\n\n@param load the configuration loader\n@return the configured application builder", "predict": " public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigValue;\nimport com.typesafe.config.ConfigValueType;\nimport com.typesafe.config.ConfigValueType.ValueType;\nimport com.typesafe.config.ConfigValueVisitor;\nimport com.typesafe.config.ConfigValueVisitor"}, {"ID": 615, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); } \nResponse:", "ground_truth": "Set the module loader. Overrides the default or any previously configured values.\n\n@param loader the configuration\n@return the configured application builder", "predict": " public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigValue;\nimport com.typesafe.config.ConfigValueType;\nimport com.typesafe.config.ConfigValueType.ValueType;\nimport com.typesafe.config.ConfigValueVisitor;\nimport com.typesafe.config"}, {"ID": 616, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override the module loader with the given guiceable modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Providers.Provider;\nimport com.google.inject.util.Providers.TypeLiteral;\nimport com.google.inject.util.Types;\n\nimport scala.collection.JavaConversions;\nimport scala.collection.imm"}, {"ID": 617, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(com.google.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Guice modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "\n\npublic GuiceApplicationBuilder load(Module... modules) {\n    return Guice.createInjector(modules);\n}\n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Guiceable {\n    public static Module modules(Module... modules) {\n        List<Module> list = new Array"}, {"ID": 618, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Play modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "\n\npublic GuiceApplicationBuilder load(Guiceable.Module... modules) {\n    return GuiceApplicationBuilder.load(modules);\n}\n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedType;\nimport com.google.inject.util.Types.WildcardType;\nimport com.google.inject.util.Types.Visitor;\nimport com.google.inject.util.Types.Visitor.VisitorException;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\n"}, {"ID": 619, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override the module loader with the given Play bindings.\n\n@param bindings the set of binding override\n@return an application builder that incorporates the overrides", "predict": " public GuiceApplicationBuilder load(Guiceable.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Binding;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Module;\nimport com.google.inject.Provider;\nimport com.google.inject.Provides;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types"}, {"ID": 620, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); } \nResponse:", "ground_truth": "Implementation of Self creation for GuiceBuilder.\n\n@return the application builder", "predict": " public GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl.Substitution;\nimport com.google.inject.util.Types.WildcardTypeImpl.TypeVar;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect."}, {"ID": 621, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); encode(buf, cookie); return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Cookie header value.\n\n@param cookie specified the cookie\n@return a Rfc6265 style Cookie header value", "predict": " public String decode(String cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); decode(buf, cookie); return stripLeadingSeparator(buf); } \n\n*/\n\npublic class CookieEncoder {\n    private static final String BOUNDARY = \"7d87f1b8cfa9c\";\n\n    public static String encode(Cookie cookie) {\n        if (cookie == null) {\n            throw new NullPointerException(\"cookie\");\n        }\n\n        StringBuilder buf = new StringBuilder();\n        encode(buf, cookie);\n        return buf.toString();\n    }\n\n    public static void encode(StringBuilder buf, Cookie cookie) {\n        if (cookie == null) {\n            throw new NullPointerException(\"cookie\");\n        }\n\n        buf.append(\"Cookie: \");\n        buf.append(cookie.getName());\n        buf.append(\""}, {"ID": 622, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em() { Deque<EntityManager> ems = this.emStack(true); if (ems.isEmpty()) { Http.Context.safeCurrent() .map( ctx -> { throw new RuntimeException( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\"); }) .orElseGet( () -> { throw new RuntimeException( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\"); }); } return ems.peekFirst(); } \nResponse:", "ground_truth": "Get the default EntityManager for this thread.\n\n@throws RuntimeException if no EntityManager is bound to the current Http.Context or the\ncurrent Thread.\n@return the EntityManager", "predict": " public EntityManager em() { return em(); }\n\n*/\n\npackage controllers;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport controllers.deadbolt.DeadboltHandler;\nimport controllers.deadbolt.Restricted;\nimport models.User;\nimport play.Logger;\nimport play.api.libs.json.JsObject;\nimport play.api.libs.json.JsObjectApi;\nimport play.api.libs.json.JsValue;\nimport play.api.libs.json.JsValueApi;\nimport play.api.libs.json.JsValueConver"}, {"ID": 623, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Deque<EntityManager> emStack(boolean threadLocalFallback) { return Http.Context.safeCurrent() .map( context -> { Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER); if (emsObject != null) { return (Deque<EntityManager>) emsObject; } else { Deque<EntityManager> ems = new ArrayDeque<>(); context.args.put(CURRENT_ENTITY_MANAGER, ems); return ems; } }) .orElseGet( () -> { // Not a web request if (threadLocalFallback) { return this.get(); } else { throw new RuntimeException( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\"); } }); } \nResponse:", "ground_truth": "Get the EntityManager stack.\n\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.\n@return the queue of entity managers.", "predict": "\n\n*/\n\nimport java.util.Deque;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.collect.Queues;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClient;\nimport io.vertx.core.http.HttpClientOptions;\nimport io.vertx.core.http.HttpClientRequest;\nimport io"}, {"ID": 624, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } } \nResponse:", "ground_truth": "Pushes or pops the EntityManager stack depending on the value of the em argument. If em is\nnull, then the current EntityManager is popped. If em is non-null, then em is pushed onto the\nstack and becomes the current EntityManager.\n\n@param em the entity manager to push, if null then will pop one off the stack.\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.", "predict": " void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } } \n */\n\npublic class EmStack {\n\tprivate Deque<EntityManager> ems = new ArrayDeque<EntityManager>();\n\tprivate boolean threadLocalFallback = false;\n\t\n\tpublic EmStack(boolean threadLocalFallback) {\n\t\tthis.threadLocalFallback = threadLocalFallback;\n\t}\n\t\n\tpublic void push(EntityManager em) {\n\t\tems.push(em);\n\t}\n\t\n\tpublic EntityManager pop() {\n\t\treturn ems.pop();\n\t}\n\t\n\tpublic EntityManager"}, {"ID": 625, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) { return bypassWith( Flow.<In>create().map(splitter::apply), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), flow); } \nResponse:", "ground_truth": "Bypass the given flow using the given splitter function.\n\nIf the splitter function returns Left, they will go through the flow. If it returns Right,\nthey will bypass the flow.\n\nUses onlyFirstCanFinishMerge(2) by default.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow\n@param flow the original flow\n@param splitter the splitter function to use\n@return the flow with a bypass.", "predict": "\n\n*/\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport akka.NotUsed;\nimport akka.actor.ActorSystem;\nimport akka.stream.ActorMaterializer;\nimport akka.stream.javadsl.Flow;\nimport akka.stream.javadsl.Sink;\nimport akka.stream.javadsl.Source;\nimport akka.util.ByteString;\nimport scala.concurrent"}, {"ID": 626, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) { return splitter.via( Flow.fromGraph( GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true)); UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy); Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.left.isPresent()) { return x.left.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, Out, ?> collectOut = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.right.isPresent()) { return x.right.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel = play.api.libs.streams.AkkaStreams .<F.Either<FlowIn, Out>>ignoreAfterCancellation() .asJava(); // Normal flow builder .from(broadcast.out(0)) .via(builder.add(collectIn)) .via(builder.add(flow)) .toInlet(merge.in(0)); // Bypass flow, need to ignore downstream finish builder .from(broadcast.out(1)) .via(builder.add(blockCancel)) .via(builder.add(collectOut)) .toInlet(merge.in(1)); return new FlowShape<>(broadcast.in(), merge.out()); }))); } \nResponse:", "ground_truth": "Using the given splitter flow, allow messages to bypass a flow.\n\nIf the splitter flow produces Left, they will be fed into the flow. If it produces Right,\nthey will bypass the flow.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow.\n@param flow the original flow.\n@param splitter the splitter function.\n@param mergeStrategy the merge strategy (onlyFirstCanFinishMerge, ignoreAfterFinish,\nignoreAfterCancellation)\n@return the flow with a bypass.", "predict": "\n\n<pre>{@code\npublic static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith(Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) {\n  return splitter.via(Flow.fromGraph(GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create(builder -> {\n    UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true));\n    UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy);\n    Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala"}, {"ID": 627, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); } \nResponse:", "ground_truth": "Create a flow that is handled by an actor.\n\nMessages can be sent downstream by sending them to the actor passed into the props function.\nThis actor meets the contract of the actor returned by {@link\nakka.stream.javadsl.Source#actorRef}.\n\nThe props function should return the props for an actor to handle the flow. This actor will\nbe created using the passed in {@link akka.actor.ActorRefFactory}. Each message received will\nbe sent to the actor - there is no back pressure, if the actor is unable to process the\nmessages, they will queue up in the actors mailbox. The upstream can be cancelled by the actor\nterminating itself.\n\n@param  the In type parameter for a Flow\n@param  the Out type parameter for a Flow\n@param props A function that creates the props for actor to handle the flow.\n@param bufferSize The maximum number of elements to buffer.\n@param overflowStrategy The strategy for how to handle a buffer overflow.\n@param factory The Actor Factory used to create the actor to handle the flow - for example, an\nActorSystem.\n@param mat The materializer to materialize the flow.\n@return the flow itself.", "predict": " public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); } \n\n*/\npackage play.libs.streams;\n\nimport java.util.concurrent.Callable;\n\nimport scala.concurrent.Future;\nimport scala.concurrent.duration.Duration;\nimport scala.concurrent.duration.FiniteDuration;\n\nimport play.libs.Scala;\nimport play.mvc.Http.Request;\nimport play.mvc."}, {"ID": 628, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Object> convertErrorArguments(Object[] arguments) { if (arguments == null) { return Collections.emptyList(); } List<Object> converted = Arrays.stream(arguments) .filter( arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable)) .collect(Collectors.toList()); return Collections.unmodifiableList(converted); } \nResponse:", "ground_truth": "Convert the error arguments.\n\n@param arguments The arguments to convert.\n@return The converted arguments.", "predict": " ResponseEntity<Object> convertErrorResponse(Object response) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, HttpStatus.OK); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, status); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status, String message) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, status); converted.getBody().add(new ErrorMessage(message)); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status, String message, Object... arguments) { if (response == null) { return null; } ResponseEntity<Object> converted"}, {"ID": 629, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Form<T> fill(T value) { if (value == null) { throw new RuntimeException(\"Cannot fill a form with a null value\"); } return new Form<>( rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess); } \nResponse:", "ground_truth": "Populates this form with an existing value, used for edit forms.\n\n@param value existing value of type T used to fill this form\n@return a copy of this form filled with the new data", "predict": "\n\npublic Form<T> fill(T value) {\n    if (value == null) {\n        throw new RuntimeException(\"Cannot fill a form with a null value\");\n    }\n    return new Form<>(rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess);\n}\n\npublic Form<T> fill(T value, String... groupNames) {\n    if (value == null) {\n        throw new RuntimeException(\"Cannot fill a form with a null value\");\n    }\n    return new Form<>(rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), Arrays.asList(groupNames), messagesApi, formatters, validatorFactory, config, lang, directField"}, {"ID": 630, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<ValidationError> globalErrors() { return Collections.unmodifiableList( errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList())); } \nResponse:", "ground_truth": "Retrieve all global errors - errors without a key.\n\n@return All global errors.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 631, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); } \nResponse:", "ground_truth": "Returns the form errors serialized as Json using the given Lang.\n\n@param lang the language to use.\n@return the JSON node containing the errors.", "predict": " public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); } \n\n*/\n"}, {"ID": 632, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<Object> value(String key) { return super.value().map(v -> v.getData().get(asNormalKey(key))); } \nResponse:", "ground_truth": "Gets the concrete value\n\n@param key the string key.\n@return the value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 633, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DynamicForm fill(Map<String, Object> value) { Form<Dynamic> form = super.fill(new Dynamic(value)); return new DynamicForm( form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null)); } \nResponse:", "ground_truth": "Fills the form with existing data.\n\n@param value the map of values to fill in the form.\n@return the modified form.", "predict": "\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.POST)\npublic ResponseEntity<DynamicForm> fill(@RequestBody Map<String, Object> value) {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(value), HttpStatus.OK);\n}\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.GET)\npublic ResponseEntity<DynamicForm> get() {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(new Dynamic(new HashMap<String, Object>())), HttpStatus.OK);\n}\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.PUT)\npublic ResponseEntity<DynamicForm> put(@RequestBody Map<String, Object> value) {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(value), HttpStatus.OK);\n}"}, {"ID": 634, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); } \nResponse:", "ground_truth": "Parses this string as instance of the given class.\n\n@param text the text to parse\n@param clazz class representing the required type\n@param  the type to parse out of the text\n@return the parsed value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 635, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T parse(Field field, String text) { return (T) conversion.convert(text, new TypeDescriptor(field)); } \nResponse:", "ground_truth": "Parses this string as instance of a specific field\n\n@param field the related field (custom formatters are extracted from this field annotation)\n@param text the text to parse\n@param  the type to parse out of the text\n@return the parsed value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 636, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(T t) { if (t == null) { return \"\"; } if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value.\n\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new Test()));\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new Test()));\n    }\n}\n"}, {"ID": 637, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific field.\n\n@param field the related field - custom formatters are extracted from this field annotation\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class <T> String print(Field field, T t) {\n    return print(new TypeDescriptor(field), t);\n}\n\npublic class TypeDescriptor {\n    private final Field field;\n    private final Class<?> type;\n\n    public TypeDescriptor(Field field) {\n        this.field = field;\n        this.type = field.getType();\n    }\n\n    public String print() {\n        return field.getName() + \": \" + type.getSimpleName();\n    }\n}\n\n*/\n\npublic class TypeDescriptor {\n    private final Field field;\n    private final Class<?> type;\n\n    public TypeDescriptor(Field field) {\n        this.field = field;\n        this.type = field.getType();\n    }\n\n    public String print() {\n        return field.getName() + \": \" + type.getSimpleName();\n    }\n"}, {"ID": 638, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(TypeDescriptor desc, T t) { if (t == null) { return \"\"; } if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) { return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class)); } else if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific type.\n\n@param desc the field descriptor - custom formatters are extracted from this descriptor.\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new TypeDescriptor(String.class), \"Hello World\"));\n        System.out.println(test.print(new TypeDescriptor(String.class), null));\n        System.out.println(test.print(new TypeDescriptor(String.class), new Object()));\n    }\n}\n\nOutput:\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(\"Hello World\");\n        System.out.println(\"\");\n        System.out.println(\"\");\n    }\n}\n\n*/\n\npublic class TypeDescriptor {\n    private final Class<?> clazz;\n\n    public TypeDescriptor(Class<?> clazz) {\n        this.clazz ="}, {"ID": 639, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Formatters registerOptional() { conversion.addConverter( new GenericConverter() { public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map( o -> conversion.convert( source, sourceType.getElementTypeDescriptor(), targetType)) .orElse(\"\"); } return null; } public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<ConvertiblePair> result = new HashSet<>(); result.add(new ConvertiblePair(Optional.class, String.class)); result.add(new ConvertiblePair(String.class, Optional.class)); return result; } }); return this; } \nResponse:", "ground_truth": "Converter for String -> Optional and Optional -> String", "predict": " Response<String> registerOptional(Optional<String> optional) { return null; } \nResp Response<String> registerOptional(String optional) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, String optional2) { return null; } \nResp Response<String> registerOptional(String optional, String optional2) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, Optional<String> optional2) { return null; } \nResp Response<String> registerOptional(String optional, Optional<String> optional2) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, Optional<String> optional2, String optional3) { return null; } \nResp Response<String> registerOptional(String optional, Optional<String> optional2, String optional3) { return null; } \nResp Response<String> registerOptional(Optional"}, {"ID": 640, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; } \nResponse:", "ground_truth": "Registers a simple formatter.\n\n@param clazz class handled by this formatter\n@param  the type that this formatter will parse and print\n@param formatter the formatter to register\n@return the modified Formatters object.", "predict": " public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter, final Response response) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; } \nResp public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter, final Response response, final String pattern) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException"}, {"ID": 641, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) sourceType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.print(a, (T) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return \"@\" + annotationType.getName() + \" \" + clazz.getName() + \" -> \" + String.class.getName() + \": \" + formatter; } }); conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(String.class, clazz)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (targetType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) targetType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.parse(a, (String) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return String.class.getName() + \" -> @\" + annotationType.getName() + \" \" + clazz.getName() + \": \" + formatter; } }); return this; } \nResponse:", "ground_truth": "Registers an annotation-based formatter.\n\n@param clazz class handled by this formatter\n@param formatter the formatter to register\n@param  the annotation type\n@param  the type that will be parsed or printed\n@return the modified Formatters object.", "predict": " public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter, final Response.Status status) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor"}, {"ID": 642, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } final String name = cookie.name(); final String value = cookie.value() != null ? cookie.value() : \"\"; validateCookie(name, value); StringBuilder buf = new StringBuilder(); if (cookie.wrap()) { addQuoted(buf, name, value); } else { add(buf, name, value); } if (cookie.maxAge() != Integer.MIN_VALUE) { add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge()); Date expires = cookie.maxAge() <= 0 ? new Date(0) // Set expires to the Unix epoch : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis()); add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires)); } if (cookie.sameSite() != null) { add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite()); } if (cookie.path() != null) { add(buf, CookieHeaderNames.PATH, cookie.path()); } if (cookie.domain() != null) { add(buf, CookieHeaderNames.DOMAIN, cookie.domain()); } if (cookie.isSecure()) { add(buf, CookieHeaderNames.SECURE); } if (cookie.isHttpOnly()) { add(buf, CookieHeaderNames.HTTPONLY); } return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Set-Cookie header value.\n\n@param cookie the cookie\n@return a single Set-Cookie header value", "predict": " Generate the method-level comment for the following java Code. Code: public Cookie decode(String name, String value) { if (name == null) { throw new NullPointerException(\"name\"); } if (value == null) { throw new NullPointerException(\"value\"); } validateCookie(name, value); if (name.indexOf('=') != -1) { throw new IllegalArgumentException(\"Cookie name cannot contain '=' character\"); } if (value.indexOf('=') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain '=' character\"); } if (value.indexOf(' ') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain space character\"); } if (value.indexOf('\\t') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain tab character\"); } if (value.indexOf('\\r') != -1) { throw new IllegalArgumentException(\"Cookie value"}, {"ID": 643, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static NodeList selectNodes(String path, Object node) { return selectNodes(path, node, null); } \nResponse:", "ground_truth": "Select all nodes that are selected by this XPath expression. If multiple nodes match, multiple\nnodes will be returned. Nodes will be returned in document-order,\n\n@param path the xpath expression\n@param node the starting node\n@return result of evaluating the xpath expression against node", "predict": " Resp public static NodeList selectNodes(String path, Object node, Object result) { \n\tNodeList nodes = null;\n\ttry {\n\t\tnodes = XPathAPI.selectNodeList(node, path);\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\treturn nodes;\n}\n\n*/\n\n}\n"}, {"ID": 644, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) { return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList(); } \nResponse:", "ground_truth": "Converts a Java List to Scala Seq.\n\n@param list    the java list.\n@return the converted Seq.\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class JavaStreams {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list2 = Arrays.asList(\"d\", \"e\", \"f\");"}, {"ID": 645, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) { return toSeq(java.util.Arrays.asList(array)); } \nResponse:", "ground_truth": "Converts a Java Array to Scala Seq.\n\n@param array    the java array.\n@return the converted Seq.\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCode {\n    public static <T> List<T> toList(T[] array) {\n        List<T> list = new ArrayList<T>();\n        for (T t : array) {\n            list.add(t);\n        }\n        return list;\n    }\n\n    public static <T> List<T> toList(List<T> list) {\n        return list;\n    }\n\n    public static <T> List<T> toList(Iterable<T> iterable) {\n        List<T> list = new ArrayList<T>();\n        for (T t : iterable) {\n            list.add(t);\n        }\n        return list;\n    }\n\n    public static <T> List<T> toList(Iterable<T> iterable, int size) {\n        "}, {"ID": 646, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs public static <T> scala.collection.immutable.Seq<T> varargs(T... array) { return toSeq(array); } \nResponse:", "ground_truth": "Converts a Java varargs to Scala varargs.\n\n@param array    the java array.\n@return the Scala varargs\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class JavaSafeVarargs {\n    public static <T> List<T> varargs(T... array) {\n        return Arrays.asList(array);\n    }\n\n    public static void main(String[] args) {\n        List<String> list = varargs(\"a\", \"b\", \"c\");\n        System.out.println(list);\n    }\n}\n"}, {"ID": 647, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); } catch (Exception e) { throw new RuntimeException(e); } }); } \nResponse:", "ground_truth": "Acceptor for JSON WebSockets.\n\n@param in The class of the incoming messages, used to decode them from the JSON.\n@param  The websocket's input type (what it receives from clients)\n@param  The websocket's output type (what it writes to clients)\n@return The WebSocket acceptor.", "predict": " public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); }"}, {"ID": 648, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get().map(outMapper::apply)); return F.Either.Right(flow); } }); } }; } \nResponse:", "ground_truth": "Helper to create handlers for WebSockets.\n\n@param inMapper Function to map input messages. If it produces left, the message will be passed\nto the WebSocket flow, if it produces right, the message will be sent back out to the\nclient - this can be used to send errors directly to the client.\n@param f The function to handle the WebSocket.\n@param outMapper Function to map output messages.\n@return The WebSocket handler.", "predict": "\n\npublic static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get()."}, {"ID": 649, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static boolean setAccessibleWorkaround(final AccessibleObject o) { if (o == null || o.isAccessible()) { return false; } final Member m = (Member) o; if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { try { o.setAccessible(true); return true; } catch (final SecurityException e) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false; } \nResponse:", "ground_truth": "XXX Default access superclass workaround.\n\nWhen a {@code public} class has a default access superclass with {@code public} members,\nthese members are accessible. Calling them from compiled code works fine. Unfortunately, on\nsome JVMs, using reflection to invoke these members seems to (wrongly) prevent access even when\nthe modifier is {@code public}. Calling {@code setAccessible(true)} solves the problem but will\nonly work from sufficiently privileged code. Better workarounds would be gratefully accepted.\n\n@param o the AccessibleObject to set as accessible\n@return a boolean indicating whether the accessibility of the object was set to true.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution.setAccessibleWorkaround(null);\n    }\n\n    public static boolean setAccessibleWorkaround(final AccessibleObject o) {\n        if (o == null || o.isAccessible()) {\n            return false;\n        }\n        final Member m = (Member) o;\n        if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n            try {\n                o.setAccessible(true);\n                return true;\n            } catch (final SecurityException e) {\n                // NOPMD // ignore in favor of subsequent IllegalAccessException\n            }\n        }\n        return false;\n    }\n\n    private static boolean isPackageAccess(final int modifiers) {\n        return Modifier.isPublic(modifiers) && !"}, {"ID": 650, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getPrimitivePromotionCost( final Class<?> srcClass, final Class<?> destClass) { float cost = 0.0f; Class<?> cls = srcClass; if (!cls.isPrimitive()) { // slight unwrapping penalty cost += 0.1f; cls = ClassUtils.wrapperToPrimitive(cls); } for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { if (cls == ORDERED_PRIMITIVE_TYPES[i]) { cost += 0.1f; if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { cls = ORDERED_PRIMITIVE_TYPES[i + 1]; } } } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required to promote a primitive number to another type.\n\n@param srcClass the (primitive) source class\n@param destClass the (primitive) destination class\n@return The cost of promoting the primitive", "predict": "\n\n*/\n\npublic class Solution {\n    public static float getPrimitivePromotionCost(Class<?> srcClass, Class<?> destClass) {\n        float cost = 0.0f;\n        Class<?> cls = srcClass;\n        if (!cls.isPrimitive()) {\n            cost += 0.1f;\n            cls = ClassUtils.wrapperToPrimitive(cls);\n        }\n        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n                cost += 0.1f;\n                if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n                    cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n                }\n            }\n        }\n        "}, {"ID": 651, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getTotalTransformationCost( final Class<?>[] srcArgs, final Executable executable) { final Class<?>[] destArgs = executable.getParameterTypes(); final boolean isVarArgs = executable.isVarArgs(); // \"source\" and \"destination\" are the actual and declared args respectively. float totalCost = 0.0f; final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length; if (srcArgs.length < normalArgsLen) { return Float.MAX_VALUE; } for (int i = 0; i < normalArgsLen; i++) { totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]); } if (isVarArgs) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs.length < destArgs.length; final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray(); final float varArgsCost = 0.001f; final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType(); if (noVarArgsPassed) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost; } else if (explicitArrayForVarags) { final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType(); totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost; } else { // This is typical varargs case. for (int i = destArgs.length - 1; i < srcArgs.length; i++) { final Class<?> srcClass = srcArgs[i]; totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost; } } } return totalCost; } \nResponse:", "ground_truth": "Returns the sum of the object transformation cost for each class in the source argument list.\n\n@param srcArgs The source arguments\n@param executable The executable to calculate transformation costs for\n@return The total transformation cost", "predict": "\n\npublic static float getTotalTransformationCost(final Class<?>[] srcArgs, final Executable executable) {\n\tfinal Class<?>[] destArgs = executable.getParameterTypes();\n\tfinal boolean isVarArgs = executable.isVarArgs();\n\tfinal long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length;\n\tif (srcArgs.length < normalArgsLen) {\n\t\treturn Float.MAX_VALUE;\n\t}\n\tfloat totalCost = 0.0f;\n\tfor (int i = 0; i < normalArgsLen; i++) {\n\t\ttotalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);\n\t}\n\tif (isVarArgs) {\n\t\tfinal boolean noVarArgsPassed = srcArgs.length < destArgs.length;\n\t\tfinal boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1"}, {"ID": 652, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { if (destClass.isPrimitive()) { return getPrimitivePromotionCost(srcClass, destClass); } float cost = 0.0f; while (srcClass != null && !destClass.equals(srcClass)) { if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f; break; } cost++; srcClass = srcClass.getSuperclass(); } /* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if (srcClass == null) { cost += 1.5f; } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required needed to turn the source class into the destination class.\nThis represents the number of steps in the object hierarchy graph.\n\n@param srcClass The source class\n@param destClass The destination class\n@return The cost of transforming an object", "predict": "\n\npublic static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {\n\tfloat cost = 0.0f;\n\twhile (srcClass != null && !destClass.equals(srcClass)) {\n\t\tif (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {\n\t\t\t// slight penalty for interface match.\n\t\t\tcost += 0.25f;\n\t\t\tbreak;\n\t\t}\n\t\tcost++;\n\t\tsrcClass = srcClass.getSuperclass();\n\t}\n\t/* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */\n\tif (srcClass == null) {\n\t\tcost += 1.5f;\n\t}\n\treturn cost;\n}\n\n*/\n"}, {"ID": 653, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(String key, Object... args) { return messagesApi.get(lang, key, args); } \nResponse:", "ground_truth": "Get the message at the given key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 654, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(List<String> keys, Object... args) { return messagesApi.get(lang, keys, args); } \nResponse:", "ground_truth": "Get the message at the first defined key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author jaehong.kim\n */\npublic class MethodJsonParser {\n    private final Object object;\n    private final Method method;\n    private final StringBuilder builder;\n    private final List<Object> list;\n\n    public MethodJsonParser(final Object object, final Method method) {\n        this.object = object;\n        this.method = method;\n        this.builder = new StringBuilder();\n        this.list = new ArrayList<Object>();\n    }\n\n    public StringBuilder getBuilder() {\n        return builder;\n    }\n\n    public List<Object> getList() {\n        return list;\n    }\n\n    public void parse() {\n        final Class<?>"}, {"ID": 655, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Database createFrom( String driver, String url, Map<String, ? extends Object> config) { return createFrom(\"default\", driver, url, config); } \nResponse:", "ground_truth": "Create a pooled database named \"default\" with the given configuration.\n\n@param driver the database driver class\n@param url the database url\n@param config a map of extra database configuration\n@return a configured database", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 656, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ParallelSorter create(Object[] arrays) { Generator gen = new Generator(); gen.setArrays(arrays); return gen.create(); } \nResponse:", "ground_truth": "Create a new ParallelSorter object for a set of arrays. You may\nsort the arrays multiple times via the same ParallelSorter object.\n@param arrays An array of arrays to sort. The arrays may be a mix\nof primitive and non-primitive types, but should all be the same\nlength.\n@param loader ClassLoader for generated class, uses \"current\" if null", "predict": " public static ParallelSorter create(Object[] arrays) { return new ParallelSorter(arrays); }\n\n*/\n\npublic class ParallelSorter {\n\tprivate Object[] arrays;\n\tprivate int[] indexes;\n\tprivate int[] sizes;\n\tprivate int[] offsets;\n\tprivate int[] lengths;\n\tprivate int[] offsets2;\n\tprivate int[] lengths2;\n\tprivate int[] offsets3;\n\tprivate int[] lengths3;\n\tprivate int[] offsets4;\n\tprivate int[] lengths4;\n\tprivate int[] offsets5;\n\tprivate int[] lengths5;\n\tprivate int[] offsets6;\n\tprivate int[] lengths6;\n\tprivate int[] offsets7;\n\tprivate int[] lengths7;\n\tprivate int[] offsets8;\n\tprivate int[] lengths8;\n\tprivate int[] offsets9;\n\tprivate int[] lengths9;\n\tprivate int[] offsets10;\n\tprivate int[] lengths10;\n\tprivate int"}, {"ID": 657, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void quickSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.quickSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using the quicksort algorithm.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "\n\npublic void quickSort(int index, int lo, int hi, Comparator cmp) {\n\tif (lo >= hi) return;\n\tint mid = partition(index, lo, hi, cmp);\n\tquickSort(index, lo, mid - 1, cmp);\n\tquickSort(index, mid + 1, hi, cmp);\n}\n\npublic int partition(int index, int lo, int hi, Comparator cmp) {\n\tint i = lo, j = hi + 1;\n\tint pivot = lo;\n\twhile (true) {\n\t\twhile (cmp.compare(array[index], array[lo]) < 0) lo++;\n\t\twhile (cmp.compare(array[index], array[j]) > 0) j--;\n\t\tif (j < i) break;\n\t\tswap(index, j, lo);\n\t\tlo++;\n\t\tj--;\n\t}\n\tswap(index, lo"}, {"ID": 658, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void mergeSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.mergeSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using an in-place merge sort.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "\n\npublic void mergeSort(int index, int lo, int hi, Comparator cmp) {\n    if (lo < hi) {\n        int mid = (lo + hi) / 2;\n        mergeSort(index, lo, mid, cmp);\n        mergeSort(index, mid + 1, hi, cmp);\n        merge(index, lo, mid, hi, cmp);\n    }\n}\n\npublic void merge(int index, int lo, int mid, int hi, Comparator cmp) {\n    int[] a = new int[hi - lo + 1];\n    int i = lo;\n    int j = mid + 1;\n    int k = lo;\n    while (i <= mid && j <= hi) {\n        if (cmp.compare(a[k], a[j]) <= 0) {\n            a[k++] = a[j++];\n        } else {\n            a[k"}, {"ID": 659, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } } \nResponse:", "ground_truth": "Invoke the original method, on a different object of the same type.\n@param obj the compatible object; recursion will result if you use the object passed as the first\nargument to the MethodInterceptor (usually not what you want)\n@param args the arguments passed to the intercepted method; you may substitute a different\nargument array as long as the types are compatible\n@see MethodInterceptor#intercept\n@throws Throwable the bare exceptions thrown by the called method are passed through\nwithout wrapping in an InvocationTargetException", "predict": " public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } } \n\n*/\n\npublic class FastClassInfo {\n\tpublic int i1;\n\tpublic int i2;\n\tpublic int i3;\n\tpublic int i4;\n\tpublic int i5;\n\tpublic int i6;\n\tpublic int i7;\n\tpublic int i8;\n\tpublic int i9;\n\tpublic int i10;\n\tpublic int i11;\n\tpublic int i12;\n\tpublic int i13;\n\tpublic int i"}, {"ID": 660, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.LONG_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.L2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.L2F); } else { mv.visitInsn(Constants.L2I); cast_numeric(Type.INT_TYPE, to); } } else { if (to == Type.BYTE_TYPE) { mv.visitInsn(Constants.I2B); } else if (to == Type.CHAR_TYPE) { mv.visitInsn(Constants.I2C); } else if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.I2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.I2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.I2L); } else if (to == Type.SHORT_TYPE) { mv.visitInsn(Constants.I2S); } } } } \nResponse:", "ground_truth": "Casts from one primitive numeric type to another", "predict": "\npublic void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_"}, {"ID": 661, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); } \nResponse:", "ground_truth": "Pushes the specified argument of the current method onto the stack.\n@param index the zero-based index into the argument list", "predict": "\n\n*/\n\npublic class LoadArgument extends Instruction {\n\tpublic LoadArgument(int index) {\n\t\tsuper(OpCode.LoadArgument);\n\t\tthis.index = index;\n\t}\n\t\n\tpublic void execute(Frame frame) {\n\t\tframe.stack.push(frame.stack.get(frame.stack.size() - 1 - index));\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"load_arg \" + index;\n\t}\n\t\n\tpublic void load(BytecodeReader reader) {\n\t\tindex = reader.readInt();\n\t}\n\t\n\tpublic void store(BytecodeWriter writer) {\n\t\twriter.writeInt(index);\n\t}\n\t\n\tpublic int getIndex() {\n\t\treturn index;\n\t}\n\t\n\tprivate int index;\n}\n"}, {"ID": 662, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); } \nResponse:", "ground_truth": "package-protected for EmitUtils, try to fix", "predict": "\n\n*/\n\npublic class FieldInsnNode extends AbstractInsnNode {\n    private int opcode;\n    private Type ctype;\n    private String name;\n    private Type ftype;\n\n    public FieldInsnNode(int opcode, Type ctype, String name, Type ftype) {\n        super(Opcodes.FIELDINSN);\n        this.opcode = opcode;\n        this.ctype = ctype;\n        this.name = name;\n        this.ftype = ftype;\n    }\n\n    public int getOpcode() {\n        return opcode;\n    }\n\n    public Type getCtype() {\n        return ctype;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Type getFtype() {\n        return ftype;\n    }\n\n    public void accept(Visitor visitor) {\n        visitor.visitFieldInsn(this);\n"}, {"ID": 663, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } } \nResponse:", "ground_truth": "Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.", "predict": "\n\npublic void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.InsnNode;\nimport org.objectweb.asm.tree.IntInsnNode;\n"}, {"ID": 664, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } } \nResponse:", "ground_truth": "Unboxes the object on the top of the stack. If the object is null, the\nunboxed primitive value becomes zero.", "predict": " Generate the method-level comment for the following java Code. Code: public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } } \n */\n\npublic class Unboxing {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n"}, {"ID": 665, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) { Type componentType = TypeUtils.getComponentType(type); Local array = e.make_local(); Local loopvar = e.make_local(Type.INT_TYPE); Label loopbody = e.make_label(); Label checkloop = e.make_label(); e.store_local(array); e.push(0); e.store_local(loopvar); e.goTo(checkloop); e.mark(loopbody); e.load_local(array); e.load_local(loopvar); e.array_load(componentType); callback.processElement(componentType); e.iinc(loopvar, 1); e.mark(checkloop); e.load_local(loopvar); e.load_local(array); e.arraylength(); e.if_icmp(e.LT, loopbody); } \nResponse:", "ground_truth": "Process an array on the stack. Assumes the top item on the stack\nis an array of the specified type. For each element in the array,\nputs the element on the stack and triggers the callback.\n@param type the type of the array (type.isArray() must be true)\n@param callback the callback triggered for each element", "predict": "\n\n*/\n\npublic class ProcessArrayCallback {\n    public void processElement(Type type) {\n        // TODO Auto-generated method stub\n        \n    }\n}\n"}, {"ID": 666, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) { e.dup2(); Label nonNull = e.make_label(); Label oneNullHelper = e.make_label(); Label end = e.make_label(); e.ifnonnull(nonNull); e.ifnonnull(oneNullHelper); e.pop2(); e.goTo(bothNull); e.mark(nonNull); e.ifnull(oneNullHelper); e.goTo(end); e.mark(oneNullHelper); e.pop2(); e.goTo(oneNull); e.mark(end); } \nResponse:", "ground_truth": "If both objects on the top of the stack are non-null, does nothing.\nIf one is null, or both are null, both are popped off and execution\nbranches to the respective label.\n@param oneNull label to branch to if only one of the objects is null\n@param bothNull label to branch to if both of the objects are null", "predict": "\n\npublic static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n\tif (oneNull == null) {\n\t\tif (bothNull == null) {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(bothNull);\n\t\t} else {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(oneNull);\n\t\t}\n\t} else {\n\t\tif (bothNull == null) {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(oneNull);\n\t\t} else {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(bothNull);\n\t\t}\n\t}\n}\n\n*/\n"}, {"ID": 667, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; } \nResponse:", "ground_truth": "Finds all bridge methods that are being called with invokespecial &\nreturns them.", "predict": " public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; } \n\n}\n"}, {"ID": 668, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void getMethods(Class superclass, Class[] interfaces, List methods) { getMethods(superclass, interfaces, methods, null, null); } \nResponse:", "ground_truth": "Finds all of the methods that will be extended by an\nEnhancer-generated class using the specified superclass and\ninterfaces. This can be useful in building a list of Callback\nobjects. The methods are added to the end of the given list.  Due\nto the subclassing nature of the classes generated by Enhancer,\nthe methods are guaranteed to be non-static, non-final, and\nnon-private. Each method signature will only occur once, even if\nit occurs in multiple classes.\n@param superclass the class that will be extended, or null\n@param interfaces the list of interfaces that will be implemented, or null\n@param methods the list into which to copy the applicable methods", "predict": "\n\n*/\n\npublic class GetMethods {\n\tpublic static void main(String[] args) {\n\t\tClass superclass = Object.class;\n\t\tClass[] interfaces = new Class[] {};\n\t\tList methods = new ArrayList();\n\t\t\n\t\tgetMethods(superclass, interfaces, methods, null, null);\n\t\t\n\t\tfor (Iterator i = methods.iterator(); i.hasNext();) {\n\t\t\tMethod m = (Method) i.next();\n\t\t\tSystem.out.println(m.getName());\n\t\t}\n\t}\n\t\n\tpublic static void getMethods(Class superclass, Class[] interfaces, List methods, String prefix, String suffix) {\n\t\tif (superclass != null) {\n\t\t\tgetMethods(superclass.getSuperclass(), interfaces, methods, prefix, suffix);\n\t\t\t\n\t\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\t\tgetMethods(interfaces[i], interfaces, methods, prefix, suffix"}, {"ID": 669, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void filterConstructors(Class sc, List constructors) { CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true)); if (constructors.size() == 0) throw new IllegalArgumentException(\"No visible constructors in \" + sc); } \nResponse:", "ground_truth": "Filter the list of constructors from the superclass. The\nconstructors which remain will be included in the generated\nclass. The default implementation is to filter out all private\nconstructors, but subclasses may extend Enhancer to override this\nbehavior.\n@param sc the superclass\n@param constructors the list of all declared constructors from the superclass\n@throws IllegalArgumentException if there are no non-private constructors", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class VisibilityPredicate implements Predicate<Constructor> {\n    private final Class<?> clazz;\n    private final boolean visible;\n\n    public VisibilityPredicate(Class<?> clazz, boolean visible) {\n        this.clazz = clazz;\n        this.visible = visible;\n    }\n\n    @Override\n    public boolean evaluate(Constructor constructor) {\n        return visible == isVisible(constructor);\n    }\n\n    private boolean isVisible(Constructor constructor) {\n        return isVisible(constructor.getDeclaringClass());\n    }\n\n    private boolean isVisible(Class<?> clazz) {\n        return clazz.getModifiers() == (clazz.getModifiers() & ~Modifier.PRIVATE);\n    "}, {"ID": 670, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setSuperclass(Class superclass) { if (superclass != null && superclass.equals(Object.class)) { superclass = null; } this.superclass = superclass; } \nResponse:", "ground_truth": "Set the class which the generated class will extend. The class\nmust not be declared as final, and must have a non-private\nno-argument constructor.\n@param superclass class to extend, or null to extend Object", "predict": "\n\n*/\n\npublic class Test {\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.setSuperclass(Object.class);\n    }\n}\n"}, {"ID": 671, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void getField(String[] names) throws Exception { final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null); e.load_this(); e.load_arg(0); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label end) { Type type = (Type)fields.get(key); e.getfield((String)key); e.box(type); e.return_value(); } public void processDefault() { e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\"); } }); e.end_method(); } \nResponse:", "ground_truth": "to avoid JVM hashcode implementation incompatibilities", "predict": "\npublic void getField(String[] names) throws Exception {\n\tfinal CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);\n\te.load_this();\n\te.load_arg(0);\n\tEmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n\t\tpublic void processCase(Object key, Label end) {\n\t\t\tType type = (Type)fields.get(key);\n\t\t\te.getfield((String)key);\n\t\t\te.box(type);\n\t\t\te.return_value();\n\t\t}\n\t\tpublic void processDefault() {\n\t\t\te.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\n\t\t}\n\t});\n\te.end_method();\n}\n\n}\n"}, {"ID": 672, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Method method) { add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method)); } \nResponse:", "ground_truth": "Add a method signature to the interface. The method modifiers are ignored,\nsince interface methods are by definition abstract and public.\n@param method the method to add to the interface", "predict": " Response = new Response(this.getClass().getName(), \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add"}, {"ID": 673, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; } \nResponse:", "ground_truth": "If bit 31 is set then this method results in an infinite loop.\n\n@return the number of bits set to true in this TinyBitSet.", "predict": "\n\npublic int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; }\n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.countBit(1));\n        System.out.println(s.countBit(2));\n        System.out.println(s.countBit(3));\n        System.out.println(s.countBit(4));\n        System.out.println(s.countBit(5));\n        System.out.println(s.countBit(6));\n        System.out.println(s.countBit(7));\n        System.out.println(s.countBit"}, {"ID": 674, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setNamingPolicy(NamingPolicy namingPolicy) { if (namingPolicy == null) namingPolicy = DefaultNamingPolicy.INSTANCE; this.namingPolicy = namingPolicy; } \nResponse:", "ground_truth": "Override the default naming policy.\n@see DefaultNamingPolicy\n@param namingPolicy the custom policy, or null to use the default", "predict": " Response is generated.\n*/\n\npublic class NamingPolicy {\n    private static final NamingPolicy instance = new NamingPolicy();\n    private NamingPolicy() {\n    }\n    public static NamingPolicy getInstance() {\n        return instance;\n    }\n    public String getName(String name) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName, boolean isAttributeName) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName, boolean isAttributeName, boolean isTypeName) {\n        return name;\n    }\n    public String getName(String"}, {"ID": 675, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) { Map map = new HashMap(); for (int i = 0; i < methods.length; i++) { Method method = methods[i]; map.put(method.getName() + Type.getMethodDescriptor(method), method); } Method[] result = new Method[namesAndDescriptors.length / 2]; for (int i = 0; i < result.length; i++) { result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]); if (result[i] == null) { // TODO: error? } } return result; } \nResponse:", "ground_truth": "used by MethodInterceptorGenerated generated code", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\npublic class MethodVisitor extends MethodNode {\n\tprivate final List<AbstractInsnNode> instructions = new ArrayList<>();\n\tprivate final List<AbstractInsnNode> instructionsToRemove = new ArrayList<>();\n\tprivate final List<AbstractInsnNode> instructions"}, {"ID": 676, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Path resolve(final Path base, String child) { if (StringUtil.startsWithChar(child, File.separatorChar)) { child = child.substring(1); } return base.resolve(child); } \nResponse:", "ground_truth": "Resolves subpath in safer way. For some reason, if child starts with\na separator it gets resolved as a full path, ignoring the base.\nThis method acts different.", "predict": "\n\npublic static Path resolve(final Path base, String child) {\n    if (StringUtil.startsWithChar(child, File.separatorChar)) {\n        child = child.substring(1);\n    }\n    return base.resolve(child);\n}\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        String javaCode = readFile(\"src/main/java/com/example/Path.java\");\n        String javaCode2 = readFile(\"src/main/"}, {"ID": 677, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer); return writer.toString(); } } \nResponse:", "ground_truth": "Reads path content.", "predict": "\n\npublic static String readString(final Path path) throws IOException {\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n        StringWriter writer = new StringWriter();\n        StreamUtil.copy(reader, writer);\n        return writer.toString();\n    }\n}\n\n*/\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String fileName = scanner.nextLine();\n        File file = new File(fileName);\n        List<String>"}, {"ID": 678, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; } \nResponse:", "ground_truth": "Sets request host name.", "predict": " public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n\tprivate String host;\n\tprivate List<String> headers = new ArrayList<String>();\n\t\n\tpublic HttpRequest() {\n\t\t\n\t}\n\t\n\tpublic HttpRequest(String host) {\n\t\tthis.host = host;\n\t}\n\t\n\tpublic HttpRequest(String host, List<String> headers) {\n\t\tthis.host = host;\n\t\tthis.headers = headers;\n\t}\n\t\n\tpublic String getHost() {\n\t\treturn host;\n\t}\n\t\n\tpublic void setHost(String host) {\n\t\tthis.host = host;"}, {"ID": 679, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest create(final String method, final String destination) { return new HttpRequest() .method(method.toUpperCase()) .set(destination); } \nResponse:", "ground_truth": "Generic request builder, usually used when method is a variable.\nOtherwise, use one of the other static request builder methods.", "predict": " public static HttpResponse create(final String method, final String destination) { return new HttpResponse() .method(method.toUpperCase()) .set(destination); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> params;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> params, String destination) {\n\t\tthis.method = method;\n\t\tthis.params = params;\n\t\tthis.destination = destination;\n\t}\n\t\n\tpublic String getMethod() {\n\t\treturn method;\n\t}\n\t\n\tpublic void setMethod(String method) {\n\t\tthis.method = method;\n\t}\n\t"}, {"ID": 680, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest connect(final String destination) { return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination); } \nResponse:", "ground_truth": "Builds a CONNECT request.", "predict": " public static HttpResponse connect(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate Map<String, String> cookies;\n\tprivate String body;\n\tprivate String destination;\n\tprivate String url;\n\tprivate String contentType;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptCharset;\n\tprivate String acceptLanguage;\n\tprivate String host;\n\tprivate String userAgent;\n\tprivate String remoteAddress;\n\tprivate String remoteHost;\n\tprivate String remoteUser;\n\tprivate String serverName;\n\tprivate String serverPort;\n\tprivate String serverProtocol;\n\tprivate String scheme;\n\tprivate String status;\n"}, {"ID": 681, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest get(final String destination) { return new HttpRequest() .method(HttpMethod.GET) .set(destination); } \nResponse:", "ground_truth": "Builds a GET request.", "predict": " Response get(final String destination) { return new Response() .set(destination); }\n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString destination = \"destination\";\n\t\t\n\t\tHttpRequest httpRequest = new HttpRequest()\n\t\t\t\t.method(HttpMethod.GET)\n\t\t\t\t.set(destination);\n\t\t\n\t\tResponse response = new Response()\n\t\t\t\t.set(destination);\n\t\t\n\t\tSystem.out.println(httpRequest.toString());\n\t\tSystem.out.println(response.toString());\n\t\t\n\t}\n\n}\n"}, {"ID": 682, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest post(final String destination) { return new HttpRequest() .method(HttpMethod.POST) .set(destination); } \nResponse:", "ground_truth": "Builds a POST request.", "predict": " Response<HttpRequest> post(final String destination) { return new Response<HttpRequest>() .request(new HttpRequest() .method(HttpMethod.POST) .set(destination)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tList<String> lines = new ArrayList<String>();\n\t\t\n\t\tlines.add(\"package com.example.myapp;\");\n\t\tlines.add(\"\");\n\t\tlines.add(\"import com.example.myapp.http.HttpRequest;\");\n\t\tlines.add(\"import com.example.myapp.http.HttpResponse;\");\n\t\tlines.add(\"import com.example.myapp.http.Response;\");\n\t\tlines.add(\"\");\n\t\tlines.add(\"public class JavaCodeGenerator {\");\n\t\tlines.add(\"\");"}, {"ID": 683, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest put(final String destination) { return new HttpRequest() .method(HttpMethod.PUT) .set(destination); } \nResponse:", "ground_truth": "Builds a PUT request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> parameters;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.parameters = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> headers, Map<String, String> parameters, String body, String destination) {\n\t\tthis.method = method;\n\t\tthis.headers = headers;\n\t\tthis.parameters = parameters;\n\t\tthis.body = body;\n\t\tthis.destination = destination;\n\t}\n\t"}, {"ID": 684, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest patch(final String destination) { return new HttpRequest() .method(HttpMethod.PATCH) .set(destination); } \nResponse:", "ground_truth": "Builds a PATCH request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n    private List<String> headers = new ArrayList<>();\n    private List<String> params = new ArrayList<>();\n    private List<String> cookies = new ArrayList<>();\n    private String method;\n    private String url;\n    private String body;\n    private String contentType;\n    private String contentEncoding;\n    private String acceptEncoding;\n    private String accept;\n    private String acceptCharset;\n    private String acceptLanguage;\n    private String host;\n    private int port;\n    private String protocol;\n    private String userAgent;\n    private String remoteAddress;\n    private String remoteHost;\n    private String remotePort;\n    private String remoteUser;\n    private String serverName;\n    private String serverPort"}, {"ID": 685, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest delete(final String destination) { return new HttpRequest() .method(HttpMethod.DELETE) .set(destination); } \nResponse:", "ground_truth": "Builds a DELETE request.", "predict": " Response is generated by the following java Code. Code: public static HttpResponse delete(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n\tprivate List<String> headers = new ArrayList<String>();\n\tprivate List<String> params = new ArrayList<String>();\n\tprivate List<String> cookies = new ArrayList<String>();\n\tprivate String method;\n\tprivate String url;\n\tprivate String body;\n\tprivate String contentType;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptCharset;\n\tprivate String acceptLanguage;\n\tprivate String host;\n\tprivate String userAgent;\n\tprivate String remoteAddr;\n\tprivate String remoteHost;\n\tprivate"}, {"ID": 686, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest head(final String destination) { return new HttpRequest() .method(HttpMethod.HEAD) .set(destination); } \nResponse:", "ground_truth": "Builds a HEAD request.", "predict": " Response<HttpRequest> head(final String destination) { return new Response<HttpRequest>(new HttpRequest() .method(HttpMethod.HEAD) .set(destination)); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> headers, Map<String, String> params, String body, String destination) {\n\t\tthis.method = method;\n\t\tthis.headers = headers;\n\t\tthis.params"}, {"ID": 687, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest trace(final String destination) { return new HttpRequest() .method(HttpMethod.TRACE) .set(destination); } \nResponse:", "ground_truth": "Builds a TRACE request.", "predict": " public static HttpResponse trace(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\npublic class Trace {\n\tpublic static void main(String[] args) {\n\t\tHttpRequest request = new HttpRequest()\n\t\t\t\t.method(HttpMethod.TRACE)\n\t\t\t\t.set(\"http://www.google.com\");\n\t\tHttpResponse response = new HttpResponse()\n\t\t\t\t.status(HttpStatus.OK)\n\t\t\t\t.set(\"http://www.google.com\");\n\t\tSystem.out.println(request);\n\t\tSystem.out.println(response);\n\t}\n}\n"}, {"ID": 688, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest options(final String destination) { return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination); } \nResponse:", "ground_truth": "Builds an OPTIONS request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\npublic class HttpRequest {\n\tprivate HttpMethod method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = HttpMethod.GET;\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(HttpMethod method) {\n\t\tthis.method = method;\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic H"}, {"ID": 689, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest path(String path) { // this must be the only place that sets the path if (!path.startsWith(StringPool.SLASH)) { path = StringPool.SLASH + path; } int ndx = path.indexOf('?'); if (ndx != -1) { String queryString = path.substring(ndx + 1); path = path.substring(0, ndx); query = HttpUtil.parseQuery(queryString, true); } else { query = HttpMultiMap.newCaseInsensitiveMap(); } this.path = path; return this; } \nResponse:", "ground_truth": "Sets request path. Query string is allowed.\nAdds a slash if path doesn't start with one.\nQuery will be stripped out from the path.\nPrevious query is discarded.\n@see #query()", "predict": " public HttpRequest method(String method) { this.method = method; return this; } \nResp public HttpRequest header(String name, String value) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } this.headers.put(name, value); return this; } \nResp public HttpRequest header(String name, List<String> values) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } for (String value : values) { this.headers.put(name, value); } return this; } \nResp public HttpRequest header(String name, Map<String, List<String>> values) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } for (Map.Entry<String, List<String>> entry : values.entrySet()) { this.headers.put(entry.get"}, {"ID": 690, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; } \nResponse:", "ground_truth": "Sets cookies to the request.", "predict": " public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; } \nResp public HttpRequest cookies(final Map<String, Cookie> cookies) { if (cookies.isEmpty()) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Map.Entry<String, Cookie> cookie : cookies.entrySet()) { if (!first) { cookieString.append(\""}, {"ID": 691, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResponse:", "ground_truth": "Adds many query parameters at once. Although it accepts objects,\neach value will be converted to string.", "predict": " public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResp public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResp public HttpRequest query(final String name1, final Object value1, final Object... parameters) {"}, {"ID": 692, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final Map<String, String> queryMap) { for (Map.Entry<String, String> entry : queryMap.entrySet()) { query.add(entry.getKey(), entry.getValue()); } return this; } \nResponse:", "ground_truth": "Adds all parameters from the provided map.", "predict": " Response<T> query(final Map<String, String> queryMap) { return this.query(queryMap, null); } \nResp Response<T> query(final Map<String, String> queryMap, final Response.Listener<T> listener) { return this.query(queryMap, null, listener); } \nResp Response<T> query(final Map<String, String> queryMap, final Response.ErrorListener errorListener) { return this.query(queryMap, null, errorListener); } \nResp Response<T> query(final Map<String, String> queryMap, final Map<String, String> headers, final Response.Listener<T> listener) { return this.query(queryMap, headers, null, listener); } \nResp Response<T> query(final Map<String, String> queryMap, final Map<String, String> headers, final Response.ErrorListener errorListener) { return this.query(queryMap, headers,"}, {"ID": 693, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; } \nResponse:", "ground_truth": "Sets query from provided query string. Previous query values\nare discarded.", "predict": " public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset) { this.query = HttpUtil.parseQuery(queryString, decode, charset); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset, final String contentType) { this.query = HttpUtil.parseQuery(queryString, decode, charset, contentType); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset, final String contentType, final String contentEncoding) { this.query = HttpUtil.parseQuery(queryString, decode, charset, contentType, contentEncoding); return this; } \n"}, {"ID": 694, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String queryString() { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResponse:", "ground_truth": "Generates query string. All values are URL encoded.", "predict": " public String queryString(String query, String queryEncoding) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResp public String queryString(String query) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResp public String queryString(String query, String queryEncoding, String acceptEncoding) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding, acceptEncoding); } \nResp public String queryString(String query, String queryEncoding, String acceptEncoding, String acceptLanguage) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding, acceptEncoding, acceptLanguage); } \nResp"}, {"ID": 695, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); } \nResponse:", "ground_truth": "Returns just host url, without path and query.", "predict": " public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); } \n\n*/\n\npublic class StringBand {\n\tprivate StringBuffer buffer = new StringBuffer();\n\tprivate int length = 0;\n\t\n\tpublic StringBand(int length) {\n\t\tthis.length = length;\n\t}\n\t\n\tpublic void append(String string) {\n\t\tbuffer.append(string);\n\t\tlength += string.length();\n\t}\n\t\n\tpublic String toString() {\n\t\treturn buffer.toString();\n\t}\n\t\n\tpublic int length() {\n\t\treturn length;\n\t}\n}\n"}, {"ID": 696, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest basicAuthentication(final String username, final String password) { if (username != null && password != null) { String data = username.concat(StringPool.COLON).concat(password); String base64 = Base64.encodeToString(data); headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64); } return this; } \nResponse:", "ground_truth": "Enables basic authentication by adding required header.", "predict": "\n\n*/\n\npublic class BasicAuthentication extends HttpRequest {\n\n    private static final String HEADER_AUTHORIZATION = \"Authorization\";\n    private static final String HEADER_AUTHORIZATION_VALUE = \"Basic \";\n    private static final String HEADER_AUTHORIZATION_VALUE_BASE64 = \"Basic \";\n    private static final String HEADER_AUTHORIZATION_VALUE_BASE64_ENCODED = \"Basic \" + Base64.encodeToString(new String(new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T"}, {"ID": 697, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest setHostHeader() { String hostPort = this.host; if (port != Defaults.DEFAULT_PORT) { hostPort += StringPool.COLON + port; } headerOverwrite(HEADER_HOST, hostPort); return this; } \nResponse:", "ground_truth": "Sets 'Host' header from current host and port.", "predict": " public HttpRequest setHostHeader() { return this; }\n\n*/\n\npublic class HttpRequest {\n\t\n\tprivate String host;\n\tprivate int port;\n\tprivate String path;\n\tprivate String method;\n\tprivate String contentType;\n\tprivate String content;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String acceptEncodingCharset;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String acceptEncoding;\n\tprivate String acceptEncodingCharset;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String accept;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n"}, {"ID": 698, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Buffer buffer(final boolean fullRequest) { // INITIALIZATION // host port if (header(HEADER_HOST) == null) { setHostHeader(); } // form Buffer formBuffer = formBuffer(); // query string String queryString = queryString(); // user-agent if (header(\"User-Agent\") == null) { header(\"User-Agent\", Defaults.userAgent); } // POST method requires Content-Type to be set if (method.equals(\"POST\") && (contentLength() == null)) { contentLength(0); } // BUILD OUT Buffer request = new Buffer(); request.append(method) .append(SPACE) .append(path); if (query != null && !query.isEmpty()) { request.append('?'); request.append(queryString); } request.append(SPACE) .append(httpVersion) .append(CRLF); populateHeaderAndBody(request, formBuffer, fullRequest); return request; } \nResponse:", "ground_truth": "Prepares the request buffer.", "predict": " Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason) { // BUILD OUT Response response = new Response(buffer, status, reason); // BUILD OUT populateHeaderAndBody(response, buffer, false); return response; } \nResp Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason, final String contentType, final String content) { // BUILD OUT Response response = new Response(buffer, status, reason); // BUILD OUT populateHeaderAndBody(response, buffer, false); return response; } \nResp Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason, final String contentType, final String content, final String contentEncoding) { // BUILD OUT Response response = new Response(buffer,"}, {"ID": 699, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); } \nResponse:", "ground_truth": "Syntax sugar.", "predict": " public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); } \n\n*/\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\n\npublic class HttpClientTest {\n\n\tpublic static void main(String[] args) {\n\t\tHttpClient httpClient = Http"}, {"ID": 700, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Handler removeRange(final Handler firstHandler, final Label start, final Label end) { if (firstHandler == null) { return null; } else { firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end); } int handlerStart = firstHandler.startPc.bytecodeOffset; int handlerEnd = firstHandler.endPc.bytecodeOffset; int rangeStart = start.bytecodeOffset; int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) { return firstHandler; } if (rangeStart <= handlerStart) { if (rangeEnd >= handlerEnd) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler.nextHandler; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler(firstHandler, end, firstHandler.endPc); } } else if (rangeEnd >= handlerEnd) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler(firstHandler, firstHandler.startPc, start); } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = // [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc); return new Handler(firstHandler, firstHandler.startPc, start); } } \nResponse:", "ground_truth": "Removes the range between start and end from the Handler list that begins with the given\nelement.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@param start the start of the range to be removed.\n@param end the end of the range to be removed. Maybe {@literal null}.\n@return the exception handler list with the start-end range removed.", "predict": "\n\n*/\n\npublic class Handler {\n    public Handler(Handler nextHandler, Label start, Label end) {\n        this.nextHandler = nextHandler;\n        this.startPc = start;\n        this.endPc = end;\n    }\n\n    public Handler(Handler nextHandler, Label start, int end) {\n        this.nextHandler = nextHandler;\n        this.startPc = start;\n        this.endPc = new Label();\n        this.endPc.bytecodeOffset = end;\n    }\n\n    public Handler(Handler nextHandler, int start, Label end) {\n        this.nextHandler = nextHandler;\n        this.startPc = new Label();\n        this.startPc.bytecodeOffset = start;\n        this.endPc = end;\n    }\n\n    public Handler(Handler nextHandler, int start, int end) {\n        this.nextHandler = nextHandler;\n        this."}, {"ID": 701, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; } \nResponse:", "ground_truth": "Returns the number of elements of the Handler list that begins with the given element.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@return the number of elements of the Handler list that begins with 'handler'.", "predict": " static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; } \n\n*/\n\npublic class Solution {\n    public static int getExceptionTableLength(Handler firstHandler) {\n        int length = 0;\n        Handler handler = firstHandler;\n        while (handler != null) {\n            length++;\n            handler = handler.nextHandler;\n        }\n        return length;\n    }\n}\n"}, {"ID": 702, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionInterceptors() { final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors(); interceptors = new ArrayList<>(); interceptors.addAll(interceptorValues); interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all interceptors.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InterceptorsManager {\n    private List<ActionInterceptor> interceptors = new ArrayList<>();\n\n    public InterceptorsManager() {\n        interceptors.add(new ActionInterceptor() {\n            @Override\n            public void intercept(ActionInvocation invocation) throws Exception {\n                System.out.println(\"Action Interceptor 1\");\n            }\n        });\n        interceptors.add(new ActionInterceptor() {\n            @Override\n            public void intercept(ActionInvocation invocation) throws Exception {\n                System.out.println(\"Action Interceptor 2\");\n            }\n        });\n    }\n\n    public List<ActionInterceptor> getAllInterceptors() {\n        return interceptors;\n    }\n}\n"}, {"ID": 703, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionFilters() { final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters(); filters = new ArrayList<>(); filters.addAll(filterValues); filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all filters.", "predict": " Response = new Response(); Response.setStatus(Response.Status.OK); Response.setEntity(filters); return Response; }\n\n@GET\n@Path(\"/{id}\")\n@Produces(MediaType.APPLICATION_JSON)\npublic Response getActionFilterById(@PathParam(\"id\") String id) {\n\tActionFilter filter = filtersManager.getActionFilterById(id);\n\tif (filter == null) {\n\t\treturn Response.status(Response.Status.NOT_FOUND).build();\n\t}\n\treturn Response.ok(filter).build();\n}\n\n@POST\n@Path(\"/{id}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic Response addActionFilter(@PathParam(\"id\") String id, ActionFilter filter) {\n\tActionFilter filterToAdd = filtersManager.getActionFilterById(id);\n\tif ("}, {"ID": 704, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all action results.", "predict": " public void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \n\n*/\n\npublic class ActionResultCollector {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new instance of the ActionResultCollector class.\n\t\tActionResultCollector collector = new ActionResultCollector();\n\t\t\n\t\t// TODO: Create a new instance of the ActionResultManager class.\n\t\tActionResultManager manager = new ActionResultManager();\n\t\t\n\t\t// TODO: Create a new instance of the ActionResult class.\n\t\tActionResult result = new ActionResult();\n\t\t\n\t\t// TODO: Add the ActionResult to the ActionResultManager.\n\t\tmanager.addActionResult(result);\n\t\t\n\t\t//"}, {"ID": 705, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); } \nResponse:", "ground_truth": "Collects all action runtime configurations.", "predict": "\n\n*/\n\npackage com.epam.jdi.uitests.mobile.appium.elements.common;\n\nimport com.epam.commons.Timer;\nimport com.epam.jdi.uitests.core.interfaces.base.IClickable;\nimport com.epam.jdi.uitests.mobile.appium.elements.BaseElement;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\n\nimport java.util.List;\n\nimport static com.epam.commons.LinqUtils.first;\nimport static com.epam.commons.LinqUtils.select;\nimport static com.epam.jdi.uitests.core.settings.JDISettings.exception;\nimport static com.epam.jdi.uitests.mobile.appium.driver.WebDriverByUtils.fillByTemplate;"}, {"ID": 706, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected void setSimpleProperty(final BeanProperty bp, final Object value) { Setter setter = bp.getSetter(isDeclared); // try: setter if (setter != null) { invokeSetter(setter, bp, value); return; } // try: put(\"property\", value) if (bp.isMap()) { ((Map) bp.bean).put(bp.name, value); return; } if (isSilent) { return; } throw new BeanException(\"Simple property not found: \" + bp.name, bp); } \nResponse:", "ground_truth": "Sets a value of simple property.", "predict": " void\n*/\n\npublic class BeanException extends RuntimeException {\n    private static final long serialVersionUID = -828379842290987909L;\n\n    public BeanException(final String message, final BeanProperty bp) {\n        super(message + \": \" + bp);\n    }\n}\n"}, {"ID": 707, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <T> T getProperty(final Object bean, final String name) { BeanProperty beanProperty = new BeanProperty(this, bean, name); if (!isSilent) { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } else { try { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } catch (Exception ignore) { return null; } } } \nResponse:", "ground_truth": "Returns value of bean's property.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 708, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); } \nResponse:", "ground_truth": "Extract the first name of this reference.", "predict": " @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); } \n\n*/\n\npublic class ExtractThisReference {\n\n\tpublic static void main(String[] args) {\n\t\tString code = \"public class Test { \" +\n\t\t\t\t\"private String name; \" +\n\t\t\t\t\"private int age; \" +\n\t\t\t\t\"private String address; \" +\n\t\t\t\t\"private String[] friends; \" +\n\t\t\t\t\"private String[] friends2; \" +\n\t\t\t\t\"private String[] friends3; \" +\n\t\t\t\t\"private String[] friends4; \" +\n\t\t\t\t\"private String[] friends5; \" +\n\t\t\t\t\"private String[] friends6; \" +\n\t\t\t\t\"private String[] friends7; \" +\n\t\t\t\t\"private String[] friends8; \" +\n\t\t\t\t\""}, {"ID": 709, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; } \nResponse:", "ground_truth": "Returns buffered writer. Buffer will be created if not already used.", "predict": " @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(arr[i] + arr[j] > max){\n                    max = arr[i] + arr[j];\n                }\n            }\n        }\n        System.out.println(max);"}, {"ID": 710, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setObjectReference(final String name, final Object object) { if (objectRefs == null) { objectRefs = new HashMap<>(); } objectRefs.put(name, object); } \nResponse:", "ground_truth": "Saves object reference.", "predict": " Response is generated by the method.\n\n*/\n\npublic class ObjectReference {\n\t\n\tpublic static void setObjectReference(final String name, final Object object) {\n\t\tif (objectRefs == null) {\n\t\t\tobjectRefs = new HashMap<>();\n\t\t}\n\t\tobjectRefs.put(name, object);\n\t}\n\t\n\tpublic static Object getObjectReference(final String name) {\n\t\treturn objectRefs.get(name);\n\t}\n\t\n\tprivate static HashMap<String, Object> objectRefs = null;\n}\n"}, {"ID": 711, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); } \nResponse:", "ground_truth": "Returns object reference.", "predict": " Resp public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); } \n\n*/\n\npublic class ObjectReference {\n\t\n\tprivate static final String OBJECT_REFERENCE_PREFIX = \"ObjectReference: \";\n\t\n\tprivate static final String OBJECT_REFERENCE_SUFFIX = \"\";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR = \" \";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX = \"\\\\s+\";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX_MATCHER = Pattern.compile(OBJECT_REFERENCE_SEPARATOR_REGEX);\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX_MATCHER_MATCHER"}, {"ID": 712, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; } \nResponse:", "ground_truth": "Lookups for object reference and throws an exception if reference doesn't exist.", "predict": " public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; } \n\n*/\n\npublic class DbSqlBuilderException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic DbSqlBuilderException(final String message) {\n\t\tsuper(message);\n\t}\n}\n"}, {"ID": 713, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor getTableDescriptor(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.desc; } \nResponse:", "ground_truth": "Returns entity descriptor for provided table reference.", "predict": " Response is generated by the method getTableDescriptor(final String tableRef)\n*/\n\npublic class TableRefData {\n\tpublic DbEntityDescriptor desc;\n\tpublic String tableRef;\n\tpublic TableRefData(DbEntityDescriptor desc, String tableRef) {\n\t\tthis.desc = desc;\n\t\tthis.tableRef = tableRef;\n\t}\n}\n"}, {"ID": 714, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) { for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) { DbEntityDescriptor ded = entry.getValue().desc; if (ded.findByPropertyName(columnRef) != null) { return ded; } } return null; } \nResponse:", "ground_truth": "Finds entity descriptor of a table that contains provided column reference.", "predict": " Response = Response.ok().build();\n\n*/\n\npublic class TableRefData {\n\tprivate String tableName;\n\tprivate DbEntityDescriptor ded;\n\t\n\tpublic TableRefData(String tableName, DbEntityDescriptor ded) {\n\t\tthis.tableName = tableName;\n\t\tthis.ded = ded;\n\t}\n\t\n\tpublic String getTableName() {\n\t\treturn tableName;\n\t}\n\t\n\tpublic DbEntityDescriptor getDed() {\n\t\treturn ded;\n\t}\n}\n"}, {"ID": 715, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getTableAlias(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.alias; } \nResponse:", "ground_truth": "Returns table alias for provided table reference.", "predict": " Response is generated by the method getTableAlias(final String tableRef)\n*/\n\npublic class TableRefData {\n\tpublic String tableRef;\n\tpublic String alias;\n\t\n\tpublic TableRefData(String tableRef, String alias) {\n\t\tthis.tableRef = tableRef;\n\t\tthis.alias = alias;\n\t}\n}\n"}, {"ID": 716, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) { if (tableRefs == null) { tableRefs = new HashMap<>(); } TableRefData t = new TableRefData(ded, tableAlias); if (tableRefs.put(tableReference, t) != null) { throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference); } } \nResponse:", "ground_truth": "Registers table reference for provided entity.", "predict": "\n\n*/\n\npublic class TableRefData {\n    private final DbEntityDescriptor ded;\n    private final String tableAlias;\n\n    public TableRefData(final DbEntityDescriptor ded, final String tableAlias) {\n        this.ded = ded;\n        this.tableAlias = tableAlias;\n    }\n\n    public DbEntityDescriptor getDed() {\n        return ded;\n    }\n\n    public String getTableAlias() {\n        return tableAlias;\n    }\n}\n"}, {"ID": 717, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor lookupTableRef(final String tableRef) { DbEntityDescriptor ded = getTableDescriptor(tableRef); if (ded == null) { throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef); } return ded; } \nResponse:", "ground_truth": "Lookups for table reference and throws an exception if table reference not found.", "predict": " Response = new Response();\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTable"}, {"ID": 718, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); } \nResponse:", "ground_truth": "Registers a hint.", "predict": " public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        String[] hints = {\"hint1\", \"hint2\", \"hint3\"};\n        int hintCount = hints.length;\n        String[] hintStrings = new String[hintCount];\n        for (int i = 0; i < hintCount; i++) {\n            hintStrings[i] = hints[i];\n        }\n        System.out.println(hintStrings);\n    }\n}\n"}, {"ID": 719, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public final boolean serialize(final JsonContext jsonContext, final T value) { if (jsonContext.pushValue(value)) { // prevent circular dependencies return false; } serializeValue(jsonContext, value); jsonContext.popValue(); return true; } \nResponse:", "ground_truth": "Detects circular dependencies and pushes value as current\ntype context.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 720, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) { final Enumeration<String> attributeNames = servletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attrName = attributeNames.nextElement(); targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(attrName); if (name != null) { final Object attrValue = servletRequest.getAttribute(attrName); target.writeValue(name, attrValue, true); } }); } } \nResponse:", "ground_truth": "Injects request attributes.", "predict": " Response is generated by the following java Code. Code: public Response getResponse(final Targets targets) { final Response response = new Response(); final Enumeration<String> attributeNames = targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(target.getName()); if (name != null) { final Object attrValue = target.getValue(name); response.addAttribute(name, attrValue); } }); return response; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Target {\n    private String name;\n    private List<Injection> injections = new ArrayList<>();\n\n    public Target(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n"}, {"ID": 721, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) { final boolean encode = encodeGetParams && servletRequest.getMethod().equals(\"GET\"); final Enumeration<String> paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = ServletUtil.prepareParameters( paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues != null) { if (encode) { for (int j = 0; j < paramValues.length; j++) { final String p = paramValues[j]; if (p != null) { final String encoding = madvocEncoding.getEncoding(); paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding); } } } final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]); target.writeValue(name, value, true); } } }); } } \nResponse:", "ground_truth": "Inject request parameters.", "predict": "\n\n*/\npackage org.madvoc.servlet.multipart;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.util.Streams;\nimport org"}, {"ID": 722, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) { if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } final Enumeration<String> paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { final FileUpload[] paramValues = multipartRequest.getFiles(paramName); if (ignoreInvalidUploadFiles) { for (int j = 0; j < paramValues.length; j++) { final FileUpload paramValue = paramValues[j]; if ((!paramValue.isValid()) || (!paramValue.isUploaded())) { paramValues[j] = null; } } } final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues); target.writeValue(name, value, true); } }); } } \nResponse:", "ground_truth": "Inject uploaded files from multipart request parameters.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\npublic class UploadServlet extends BaseServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String UPLOAD_DIR = \"upload\";\n\n\tprivate static final int MAX"}, {"ID": 723, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertPropertyNameToColumnName(final String propertyName) { StringBuilder tableName = new StringBuilder(propertyName.length() * 2); if (splitCamelCase) { String convertedTableName = Format.fromCamelCase(propertyName, separatorChar); tableName.append(convertedTableName); } else { tableName.append(propertyName); } if (!changeCase) { return tableName.toString(); } return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString(); } \nResponse:", "ground_truth": "Converts property name to column name.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConvertPropertyNameToColumnName {\n\n    public static void main(String[] args) {\n        String propertyName = \"propertyName\";\n        String separatorChar = \".\";\n        boolean splitCamelCase = true;\n        boolean changeCase = true;\n        boolean uppercase = true;\n\n        StringBuilder tableName = new StringBuilder(propertyName.length() * 2);\n        if (splitCamelCase) {\n            String convertedTableName = Format.fromCamelCase(propertyName, separatorChar);\n            tableName.append(convertedTableName);\n        } else {\n            tableName.append(propertyName);\n        }\n        if (!changeCase) {\n            return tableName.toString();\n        "}, {"ID": 724, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertColumnNameToPropertyName(final String columnName) { StringBuilder propertyName = new StringBuilder(columnName.length()); int len = columnName.length(); if (splitCamelCase) { boolean toUpper = false; for (int i = 0; i < len; i++) { char c = columnName.charAt(i); if (c == separatorChar) { toUpper = true; continue; } if (toUpper) { propertyName.append(Character.toUpperCase(c)); toUpper = false; } else { propertyName.append(Character.toLowerCase(c)); } } return propertyName.toString(); } return columnName; } \nResponse:", "ground_truth": "Converts column name to property name.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println("}, {"ID": 725, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String applyToColumnName(final String columnName) { String propertyName = convertColumnNameToPropertyName(columnName); return convertPropertyNameToColumnName(propertyName); } \nResponse:", "ground_truth": "Applies column naming strategy to given column name hint.\nReturns full column name.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 726, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException { T t = TypeConverterManager.get().convertType(value, sqlType); set(st, index, t, dbSqlType); } \nResponse:", "ground_truth": "Stores value in database. Value is casted to sql type.", "predict": " Response is generated by the method-level comment.\n\n*/\n\npublic class TypeConverterManager {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(TypeConverterManager.class);\n\t\n\tprivate static final String SQL_TYPE_PREFIX = \"java.sql.Types.\";\n\t\n\tprivate static final Map<String, Class<?>> SQL_TYPE_MAP = new HashMap<String, Class<?>>();\n\t\n\tstatic {\n\t\tSQL_TYPE_MAP.put(\"BIT\", Boolean.class);\n\t\tSQL_TYPE_MAP.put(\"TINYINT\", Byte.class);\n\t\tSQL_TYPE_MAP.put(\"SMALLINT\", Short.class);\n\t\tSQL_TYPE_MAP.put(\"INTEGER\", Integer.class);\n\t\tSQL_TYPE_MAP.put(\"BIGINT\", Long.class);\n\t\tSQL_TYPE_MAP.put(\"FLOAT\", Float.class"}, {"ID": 727, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected <E> E prepareGetValue(final T t, final Class<E> destinationType) { if (t == null) { return null; } if (destinationType == null) { return (E) t; } return TypeConverterManager.get().convertType(t, destinationType); } \nResponse:", "ground_truth": "Once when value is read from result set, prepare it to match destination type.\n@param t get value\n@param destinationType destination type", "predict": " Response<T> prepareGetValue(final T t, final Class<T> destinationType) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t); } return Response.ok(TypeConverterManager.get().convertType(t, destinationType)); } \nResp Response<T> prepareGetValue(final T t, final Class<T> destinationType, final String contentType) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t); } return Response.ok(TypeConverterManager.get().convertType(t, destinationType), contentType); } \nResp Response<T> prepareGetValue(final T t, final Class<T> destinationType, final String contentType, final String accept) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t"}, {"ID": 728, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Set<T> getAll() { final Set<T> set = new HashSet<>(wrappers.size()); set.addAll(wrappers.values()); return set; } \nResponse:", "ground_truth": "Returns all action wrappers. Returns a copy in new set.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 729, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; } \nResponse:", "ground_truth": "Resolves single wrapper. Creates new wrapper instance if not already registered.\nDoes not expand the wrappers.", "predict": " public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; } \n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class WrapperGenerator {\n\t\n\tprivate static final String WRAPPER_PACKAGE = \"com.github.javaparser.wrapper\";\n\tprivate static final String WRAPPER_CLASS_NAME = \"Wrapper\";\n\tprivate static final String WRAPPER_CLASS_FULL_NAME = WRAPPER_PACKAGE + \".\" + WRAPPER_CLASS_NAME;\n\tprivate static final String WRAPPER_CLASS_DESCRIPTION = \"Wrapper class for the given type\";\n\tprivate static final String WR"}, {"ID": 730, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } } \nResponse:", "ground_truth": "Creates new wrapper.", "predict": " public <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } } \n\n*/\n\npackage madvoc.sample.simple;\n\nimport java.util.Date;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.web.servlet.ModelAndView;\n\nimport madvoc.ActionMethod;\nimport madvoc.MadvocConfig;\nimport madvoc.sample.simple.model.User;\n\n/**\n * @author mariotaku\n */\npublic class SimpleAction {\n\n\t@ActionMethod(value = \"/simple/{id}\")\n\tpublic ModelAndView show(HttpServletRequest request, HttpServletResponse"}, {"ID": 731, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } } \nResponse:", "ground_truth": "Converts all separators to the system separator.\n\n@param path  the path to be changed, null ignored\n@return the updated path", "predict": "\n\npublic static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } } \n\npublic static String separatorsToWindows(final String path) { if (path == null) { return null; } if (path.indexOf(WINDOWS_SEPARATOR) == -1) { return path; } else { return path.replace(WINDOWS_SEPARATOR, SYSTEM_SEPARATOR); } } \npublic static String separatorsToUnix(final String path) { if (path == null) { return null; } if (path.indexOf(SYSTEM_SEPARATOR) == -1) { return path; } else { return path.replace(SYSTEM_SEPARATOR, WINDOWS_SEPARATOR); } } \n\npublic static String separators"}, {"ID": 732, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String doGetPath(final String filename, final int separatorAdd) { if (filename == null) { return null; } int prefix = getPrefixLength(filename); if (prefix < 0) { return null; } int index = indexOfLastSeparator(filename); int endIndex = index + separatorAdd; if (prefix >= filename.length() || index < 0 || prefix >= endIndex) { return StringPool.EMPTY; } return filename.substring(prefix, endIndex); } \nResponse:", "ground_truth": "Does the work of getting the path.\n\n@param filename  the filename\n@param separatorAdd  0 to omit the end separator, 1 to return it\n@return the path", "predict": "\n\n*/\n\npublic class Solution {\n    public static int getPrefixLength(String filename) {\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return -1;\n        }\n        return index;\n    }\n\n    public static int indexOfLastSeparator(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int lastUnixPos = filename.lastIndexOf('/');\n        int lastWindowsPos = filename.lastIndexOf('\\\\');\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    public static String getPath(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return StringPool.EMPTY;\n        }\n        return filename.substring"}, {"ID": 733, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } return new String[] {prefix, path, baseName, extension}; } \nResponse:", "ground_truth": "Splits filename into a array of four Strings containing prefix, path, basename and extension.\nPath will contain ending separator.", "predict": " public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool."}, {"ID": 734, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relativePath(final String targetPath, final String basePath) { return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString(); } \nResponse:", "ground_truth": "Calculates relative path of target path on base path.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 735, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; } \nResponse:", "ground_truth": "Registers additional Madvoc components after the registration of default components.", "predict": " public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String... path) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String path) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String path, final String... pathSegments) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path, pathSeg"}, {"ID": 736, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; } \nResponse:", "ground_truth": "Configures the action configurations.", "predict": " public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; } \nResp public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer, actionConfigConsumer)); return this; } \nResp public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer, final BiConsumer<A, Response> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with("}, {"ID": 737, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp start() { log = LoggerFactory.getLogger(WebApp.class); log.debug(\"Initializing Madvoc WebApp\"); //// params & props for (final Map<String, Object> params : paramsList) { madvocContainer.defineParams(params); } for (final Props props : propsList) { madvocContainer.defineParams(props); } propsList = null; //// components registerMadvocComponents(); madvocComponents.forEach( madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer())); madvocComponents = null; madvocComponentInstances.forEach(madvocContainer::registerComponentInstance); madvocComponentInstances = null; configureDefaults(); //// listeners madvocContainer.fireEvent(Init.class); //// component configuration componentConfigs.accept(madvocContainer); componentConfigs = null; initialized(); madvocContainer.fireEvent(Start.class); if (!madvocRouterConsumers.isEmpty()) { final MadvocRouter madvocRouter = MadvocRouter.create(); madvocContainer.registerComponentInstance(madvocRouter); madvocRouterConsumers.accept(madvocRouter); } madvocRouterConsumers = null; started(); madvocContainer.fireEvent(Ready.class); ready(); return this; } \nResponse:", "ground_truth": "Initializes and starts web application.", "predict": " public WebApp start() { return null; } \npublic WebApp start() { return null; } \npublic WebApp start(final Map<String, Object> params) { return null; } \npublic WebApp start(final Props props) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Props props, final Map<String, Object> componentConfigs, final Map<String,"}, {"ID": 738, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void configureDefaults() { final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class); actionConfigManager.registerAnnotation(Action.class); actionConfigManager.registerAnnotation(RestAction.class); } \nResponse:", "ground_truth": "Configure defaults.", "predict": "\n\n*/\n\npackage org.madvoc.config;\n\nimport org.madvoc.Action;\nimport org.madvoc.MadvocConfigurator;\nimport org.madvoc.Scope;\nimport org.madvoc.ScopeType;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.ActionConfigBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder.RestActionConfigBuilderBuilderBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder.RestActionConfigBuilderBuilderBuilderBuilder;\nimport"}, {"ID": 739, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerMadvocComponents() { if (madvocContainer == null) { throw new MadvocException(\"Madvoc WebApp not initialized.\"); } log.debug(\"Registering Madvoc WebApp components\"); madvocContainer.registerComponent(MadvocEncoding.class); madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext)); madvocContainer.registerComponent(ActionConfigManager.class); madvocContainer.registerComponent(ActionMethodParamNameResolver.class); madvocContainer.registerComponent(ActionMethodParser.class); madvocContainer.registerComponent(ActionPathRewriter.class); madvocContainer.registerComponent(ActionsManager.class); madvocContainer.registerComponent(ContextInjectorComponent.class); madvocContainer.registerComponent(InterceptorsManager.class); madvocContainer.registerComponent(FiltersManager.class); madvocContainer.registerComponent(MadvocController.class); madvocContainer.registerComponent(RootPackages.class); madvocContainer.registerComponent(ResultsManager.class); madvocContainer.registerComponent(ResultMapper.class); madvocContainer.registerComponent(ScopeResolver.class); madvocContainer.registerComponent(ScopeDataInspector.class); madvocContainer.registerComponent(AsyncActionExecutor.class); madvocContainer.registerComponent(FileUploader.class); } \nResponse:", "ground_truth": "Registers default Madvoc components.", "predict": "\n\n*/\n\npackage org.madvoc.config;\n\nimport org.madvoc.interceptor.Interceptor;\nimport org.madvoc.interceptor.InterceptorsManager;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.InterceptorType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Type;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType.PriorityTypeType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType.PriorityTypeTypeType;"}, {"ID": 740, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeJars(final String... excludedJars) { for (final String excludedJar : excludedJars) { rulesJars.exclude(excludedJar); } return this; } \nResponse:", "ground_truth": "Specify excluded jars.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 741, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeJars(final String... includedJars) { for (final String includedJar : includedJars) { rulesJars.include(includedJar); } return this; } \nResponse:", "ground_truth": "Specify included jars.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 742, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; } \nResponse:", "ground_truth": "Sets included set of names that will be considered during configuration.\n@see InExRules", "predict": " Resp public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; } \n\n*/\n\npublic class ClassScanner {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(ClassScanner.class);\n\t\n\tprivate final String[] includedEntries;\n\tprivate final String[] excludedEntries;\n\tprivate final String[] includedPackages;\n\tprivate final String[] excludedPackages;\n\tprivate final String[] includedClasses;\n\tprivate final String[] excludedClasses;\n\tprivate final String[] includedMethods;\n\tprivate final String[] excludedMethods;\n\tprivate final String[] includedFields;\n\tprivate final String[] excludedFields;\n\tprivate final String[] includedAnnotations;\n\tprivate final String[] excludedAnnotations;\n\tprivate final String[] includedInterfaces;\n\tprivate final"}, {"ID": 743, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeEntries(final String... excludedEntries) { for (final String excludedEntry : excludedEntries) { rulesEntries.exclude(excludedEntry); } return this; } \nResponse:", "ground_truth": "Sets excluded names that narrows included set of packages.\n@see InExRules", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 744, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanJarFile(final File file) { final ZipFile zipFile; try { zipFile = new ZipFile(file); } catch (IOException ioex) { if (!ignoreException) { throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex); } return; } final Enumeration entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry zipEntry = (ZipEntry) entries.nextElement(); final String zipEntryName = zipEntry.getName(); try { if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) { final String entryName = prepareEntryName(zipEntryName, true); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } else if (includeResources) { final String entryName = prepareEntryName(zipEntryName, false); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } } catch (RuntimeException rex) { if (!ignoreException) { ZipUtil.close(zipFile); throw rex; } } } ZipUtil.close(zipFile); } \nResponse:", "ground_truth": "Scans classes inside single JAR archive. Archive is scanned as a zip file.\n@see #onEntry(ClassPathEntry)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class JarScanner {\n    private static final String CLASS_FILE_EXT = \".class\";\n    private static final String JAR_FILE_EXT = \".jar\";\n    private static final String JAR_FILE_MARKER = \"META-INF/MANIFEST.MF\";\n    private static final String JAR_FILE_MARKER_PREFIX = \"META-INF/\";\n    private static final String JAR_FILE_MARKER_SUFFIX = \"/MANIFEST.MF\";\n    private static final String JAR_FILE_MARKER_PREFIX_LENGTH = JAR_"}, {"ID": 745, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanClassPath(final File root) { String rootPath = root.getAbsolutePath(); if (!rootPath.endsWith(File.separator)) { rootPath += File.separatorChar; } final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath); File file; while ((file = ff.nextFile()) != null) { final String filePath = file.getAbsolutePath(); try { if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) { scanClassFile(filePath, rootPath, file, true); } else if (includeResources) { scanClassFile(filePath, rootPath, file, false); } } catch (RuntimeException rex) { if (!ignoreException) { throw rex; } } } } \nResponse:", "ground_truth": "Scans single classpath directory.\n@see #onEntry(ClassPathEntry)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleBuilder;\nimport org.apache.commons.lang3.tuple.Triple.Tri"}, {"ID": 746, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] bytecodeSignatureOfType(final Class type) { final String name = 'L' + type.getName().replace('.', '/') + ';'; return name.getBytes(); } \nResponse:", "ground_truth": "Returns type signature bytes used for searching in class file.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n    public static String generateJavaCode(String className, List<String> methods) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"public class \" + className + \" {\\n\");\n        for (String method : methods) {\n            builder.append(method + \"\\n\");\n        }\n        builder.append(\"}\");\n        return builder.toString();\n    }\n}\n"}, {"ID": 747, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner scan(final String... paths) { for (final String path : paths) { filesToScan.add(new File(path)); } return this; } \nResponse:", "ground_truth": "Scans provided paths.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 748, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (detectEntriesMode) { rulesEntries.detectMode(); } filesToScan.forEach(file -> { final String path = file.getAbsolutePath(); if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) { if (!acceptJar(file)) { return; } scanJarFile(file); } else if (file.isDirectory()) { scanClassPath(file); } }); } \nResponse:", "ground_truth": "Starts with the scanner.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.apache.commons.io"}, {"ID": 749, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) { return new DbJtxTransaction(this, tm, scope, active); } \nResponse:", "ground_truth": "Builds new transaction instance.", "predict": "\n\n*/\n\npackage com.arjuna.ats.internal.jta.transaction.jts.subordinate.jca;\n\nimport javax.transaction.xa.XAException;\nimport javax.transaction.xa.XAResource;\nimport javax.transaction.xa.Xid;\n\nimport com.arjuna.ats.arjuna.common.Uid;\nimport com.arjuna.ats.arjuna.coordinator.ActionStatus;\nimport com.arjuna.ats.arjuna.coordinator.AddOutcome;\nimport com.arjuna.ats.arjuna.coordinator.RecordType;\nimport com.arjuna.ats.arjuna.coordinator.TwoPhaseOutcome;\nimport com.arjuna.ats.arjuna.state.InputObjectState;\nimport com.arjuna.ats.arjuna.state."}, {"ID": 750, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass); } \nResponse:", "ground_truth": "Lookups the scope instance of given scope annotation.\nIf instance does not exist, it will be created, cached and returned.", "predict": "\n\n@SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass); } \n\n@SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass, final String scopeName) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass, scopeName); } \n\n@SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass, final String scopeName, final String scopeValue) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope"}, {"ID": 751, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) { for (final MadvocScope s : allScopes) { if (s.getClass().equals(madvocScopeType)) { return s; } } // new scope detected final MadvocScope newScope; try { newScope = madpc.createBean(madvocScopeType); } catch (Exception ex) { throw new MadvocException(\"Unable to create scope: \" + madvocScopeType, ex); } allScopes.add(newScope); return newScope; } \nResponse:", "ground_truth": "Performs search for the scope class and returns it's instance.", "predict": "\n\n*/\n\npackage madvoc.sample.service;\n\nimport madvoc.sample.service.impl.MyScope;\n\nimport java.util.List;\n\n/**\n * @author Ivar Conradi \u00d8sthus\n */\npublic interface MyService {\n\n    MyScope getOrInitScope(Class<? extends MyScope> scopeType);\n\n    List<MyScope> getAllScopes();\n}\n"}, {"ID": 752, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) { final MadvocScope scope = getOrInitScope(scopeType); madvocScopeConsumer.accept(scope); } \nResponse:", "ground_truth": "Finds a given scope and consumes it.", "predict": " public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) { final MadvocScope scope = getOrInitScope(scopeType); madvocScopeConsumer.accept(scope); } \n\n*/\n\npublic class ScopeMethodCommentGenerator extends AbstractMethodCommentGenerator {\n\n\tpublic ScopeMethodCommentGenerator(final String className, final String methodName) {\n\t\tsuper(className, methodName);\n\t}\n\n\t@Override\n\tprotected String getComment(final Method method) {\n\t\tfinal MadvocScope scope = getOrInitScope(method.getDeclaringClass());\n\t\tfinal StringBuilder comment = new StringBuilder();\n\t\tcomment.append(\"public void \");\n\t\tcomment.append(methodName);\n\t\tcomment.append(\"(\");\n\t\tcomment.append(scope.getClass().getSimpleName());\n\t\tcomment.append(\" scope) {\");\n\t\tcomment.append(System.lineSepar"}, {"ID": 753, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] decode(final char[] arr) { int length = arr.length; if (length == 0) { return new byte[0]; } int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0; int len = ((cnt - sepCnt) * 6 >> 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) { int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx++]] << 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i >> 16); dest[d++] = (byte) (i >> 8); dest[d++] = (byte) i; if (sepCnt > 0 && ++cc == 19) { sndx += 2; cc = 0; } } if (d < len) { int i = 0; for (int j = 0; sndx <= endx - pad; j++) { i |= INV[arr[sndx++]] << (18 - j * 6); } for (int r = 16; d < len; r -= 8) { dest[d++] = (byte) (i >> r); } } return dest; } \nResponse:", "ground_truth": "Decodes a BASE64 encoded char array.", "predict": "\npublic static byte[] decode(final char[] arr) { int length = arr.length; if (length == 0) { return new byte[0]; } int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0; int len = ((cnt - sepCnt) * 6 >> 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) { int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx"}, {"ID": 754, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static String prepareCsrfToken(final HttpSession session, final int timeToLive) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if (tokenSet == null) { tokenSet = new HashSet<>(); session.setAttribute(CSRF_TOKEN_SET, tokenSet); } String value; boolean unique; do { value = RandomString.get().randomAlphaNumeric(32); assureSize(tokenSet); unique = tokenSet.add(new Token(value, timeToLive)); } while (!unique); return value; } \nResponse:", "ground_truth": "Generates new CSRF token and puts it in the session. Returns generated token value.", "predict": "\n\n*/\n\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class CsrfTokenGenerator {\n\n    private static final ConcurrentMap<String, String> tokens = new ConcurrentHashMap<>();\n\n    public static String generate(HttpSession session, int timeToLive) {\n        String token = tokens.get(session.getId());\n        if (token == null) {\n            token = generateToken();\n            tokens.put(session.getId(), token);\n        }\n        return token;\n    }\n\n    private static String generateToken() {\n        Random random = new Random();\n        return Long.toHexString(random.nextLong());\n    }\n\n    private static void assureSize(Set<Token> tokenSet) {\n        while (tokenSet.size() < 100"}, {"ID": 755, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static void assureSize(final Set<Token> tokenSet) { if (tokenSet.size() < maxTokensPerSession) { return; } long validUntilMin = Long.MAX_VALUE; Token tokenToRemove = null; Iterator<Token> iterator = tokenSet.iterator(); while (iterator.hasNext()) { Token token = iterator.next(); if (token.isExpired()) { iterator.remove(); continue; } if (token.validUntil < validUntilMin) { validUntilMin = token.validUntil; tokenToRemove = token; } } if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) { tokenSet.remove(tokenToRemove); } } \nResponse:", "ground_truth": "Removes expired tokens if token set is full.\n@see #setMaxTokensPerSession(int)", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] a = new int[n];\n        for(int a_i=0; a_i < n; a_i++){\n            a[a_i] = in.nextInt();\n        }\n        int[] b = new int[n];\n        for(int b_i=0; b_i < n; b_i++){\n            b[b_i] = in.nextInt();\n        }\n        int[] c = new int[n];\n        for(int c_i=0; c_i < n; c_i++){\n            c[c_i] = in.nextInt();\n        }\n        int[] d = new int[n];"}, {"ID": 756, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if ((tokenSet == null) && (tokenValue == null)) { return true; } if ((tokenSet == null) || (tokenValue == null)) { return false; } boolean found = false; Iterator<Token> it = tokenSet.iterator(); while (it.hasNext()) { Token t = it.next(); if (t.isExpired()) { it.remove(); continue; } if (t.getValue().equals(tokenValue)) { it.remove(); found = true; } } return found; } \nResponse:", "ground_truth": "Checks token value.\nC", "predict": "\n\n*/\n\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.servlet.http.HttpSession;\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport com.google.common.collect.Sets;\n\npublic class CsrfTokenUtil {\n\n\tprivate static final String CSRF_TOKEN_SET = \"CSRF_TOKEN_SET\";\n\tprivate static final String CSRF_TOKEN_VALUE = \"CSRF_TOKEN_VALUE\";\n\tprivate static final String CSRF_TOKEN_EXPIRED = \"CSRF_TOKEN_EXPIRED\";\n\tprivate static final String CSRF_TOKEN_REQUEST_ATTRIBUTE = \"CSRF_TOKEN_REQUEST_ATTRIBUTE\";\n\tprivate static final String CS"}, {"ID": 757, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BeanCopy from(final Object source) { BeanCopy beanCopy = new BeanCopy(source); beanCopy.isSourceMap = source instanceof Map; return beanCopy; } \nResponse:", "ground_truth": "Defines source, detects a map.", "predict": " Response is generated by the following java Code. Code: public static BeanCopy from(final Object source) { BeanCopy beanCopy = new BeanCopy(source); beanCopy.isSourceMap = source instanceof Map; return beanCopy; } \n\n*/\n\npublic class BeanCopy {\n\tprivate Object source;\n\tprivate boolean isSourceMap;\n\t\n\tpublic BeanCopy(Object source) {\n\t\tthis.source = source;\n\t}\n\t\n\tpublic Object getSource() {\n\t\treturn source;\n\t}\n\t\n\tpublic boolean isSourceMap() {\n\t\treturn isSourceMap;\n\t}\n\t\n\tpublic void setSourceMap(boolean isSourceMap) {\n\t\tthis.isSourceMap = isSourceMap;\n\t}\n}\n"}, {"ID": 758, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void copy() { beanUtil = new BeanUtilBean() .declared(declared) .forced(forced) .silent(true); visit(); } \nResponse:", "ground_truth": "Performs the copying.", "predict": "\n\n*/\n\npublic class BeanUtilBean {\n\t\n\tprivate boolean declared = false;\n\tprivate boolean forced = false;\n\tprivate boolean silent = false;\n\t\n\tpublic BeanUtilBean() {\n\t\t\n\t}\n\t\n\tpublic BeanUtilBean(boolean declared, boolean forced, boolean silent) {\n\t\tthis.declared = declared;\n\t\tthis.forced = forced;\n\t\tthis.silent = silent;\n\t}\n\t\n\tpublic void copy() {\n\t\t\n\t}\n\t\n\tpublic boolean isDeclared() {\n\t\treturn declared;\n\t}\n\t\n\tpublic void setDeclared(boolean declared) {\n\t\tthis.declared = declared;\n\t}\n\t\n\tpublic boolean isForced() {\n\t\treturn forced;\n\t}\n\t\n\tpublic void setForced(boolean forced) {\n\t\tthis.forced = forced;\n\t}\n\t\n\t"}, {"ID": 759, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected boolean visitProperty(String name, final Object value) { if (isTargetMap) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } beanUtil.setProperty(destination, name, value); return true; } \nResponse:", "ground_truth": "Copies single property to the destination.\nExceptions are ignored, so copying continues if\ndestination does not have some of the sources properties.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 760, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final TemplateData templateData) { super.init(templateData); if (entity != null) { ded = lookupType(entity); } else { Object object = templateData.getObjectReference(entityName); if (object != null) { ded = lookupType(resolveClass(object)); } else { ded = lookupName(entityName); } } String tableReference = this.tableReference; if (tableReference == null) { tableReference = tableAlias; } if (tableReference == null) { tableReference = entityName; } if (tableReference == null) { tableReference = ded.getEntityName(); } templateData.registerTableReference(tableReference, ded, tableAlias); } \nResponse:", "ground_truth": "Resolves and registers table references.", "predict": "\n\n*/\n\npackage com.jmstudios.chibe.adapters;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.CursorAdapter;\nimport android.widget.TextView;\n\nimport com.jmstudios.chibe.R;\nimport com.jmstudios.chibe.model.Deduction;\nimport com.jmstudios.chibe.model.DeductionType;\nimport com.jmstudios.chibe.model.Entity;\nimport com.jmstudios.chibe.model.Table;\nimport com.jmstudios.chibe.model.TableAlias;\nimport com.jmstudios.chibe.model.TableReference;\nimport com.jmstudios.chibe.model."}, {"ID": 761, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <S extends Scope> S resolveScope(final Class<S> scopeType) { S scope = (S) scopes.get(scopeType); if (scope == null) { try { scope = newInternalInstance(scopeType, (PetiteContainer) this); } catch (Exception ex) { throw new PetiteException(\"Invalid Petite scope: \" + scopeType.getName(), ex); } registerScope(scopeType, scope); scopes.put(scopeType, scope); } return scope; } \nResponse:", "ground_truth": "Resolves and registers scope from a scope type.", "predict": "\n\n*/\n\npackage org.petite.util;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.petite.PetiteException;\nimport org.petite.util.ClassUtil.ClassInfo;\n\n/**\n * @author juank\n *\n */\npublic class ScopeUtil {\n\n\tprivate static final Map<Class<?>, Constructor<?>> CONSTRUCTOR_CACHE = new HashMap<Class<?>, Constructor<?>>();\n\n\tpublic static <S extends Scope> S newInstance(final Class<S> scopeType) {\n\t\ttry {\n\t\t\treturn newInstance(scopeType, null);\n\t\t} catch (PetiteException ex) {\n\t\t\tthrow ex;\n\t\t} catch (Exception ex) {\n\t\t\tthrow new PetiteException(\"Invalid Petite scope: \" + scopeType"}, {"ID": 762, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> BeanDefinition<T> registerPetiteBean( final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer ) { if (name == null) { name = resolveBeanName(type); } if (wiringMode == null) { wiringMode = annotationResolver.resolveBeanWiringMode(type); } if (wiringMode == WiringMode.DEFAULT) { wiringMode = petiteConfig.getDefaultWiringMode(); } if (scopeType == null) { scopeType = annotationResolver.resolveBeanScopeType(type); } if (scopeType == null) { scopeType = SingletonScope.class; } // remove existing bean BeanDefinition existing = removeBean(name); if (existing != null) { if (petiteConfig.getDetectDuplicatedBeanNames()) { throw new PetiteException( \"Duplicated bean name detected while registering class '\" + type.getName() + \"'. Petite bean class '\" + existing.type.getName() + \"' is already registered with the name: \" + name); } } // check if type is valid if (type.isInterface()) { throw new PetiteException(\"PetiteBean can not be an interface: \" + type.getName()); } // registration if (log.isDebugEnabled()) { log.info(\"Petite bean: [\" + name + \"] --> \" + type.getName() + \" @ \" + scopeType.getSimpleName() + \":\" + wiringMode.toString()); } // register Scope scope = resolveScope(scopeType); BeanDefinition<T> beanDefinition = createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); registerBean(name, beanDefinition); // providers ProviderDefinition[] providerDefinitions = petiteResolvers.resolveProviderDefinitions(type, name); if (providerDefinitions != null) { for (ProviderDefinition providerDefinition : providerDefinitions) { providers.put(providerDefinition.name, providerDefinition); } } // define if (define) { beanDefinition.ctor = petiteResolvers.resolveCtorInjectionPoint(beanDefinition.type()); beanDefinition.properties = PropertyInjectionPoint.EMPTY; beanDefinition.methods = MethodInjectionPoint.EMPTY; beanDefinition.initMethods = InitMethodPoint.EMPTY; beanDefinition.destroyMethods = DestroyMethodPoint.EMPTY; } // return return beanDefinition; } \nResponse:", "ground_truth": "Registers or defines a bean.\n\n@param type bean type, must be specified\n@param name bean name, if null it will be resolved from the class (name or annotation)\n@param scopeType bean scope, if null it will be resolved from the class (annotation or default one)\n@param wiringMode wiring mode, if null it will be resolved from the class (annotation or default one)\n@param define when set to true bean will be defined - all injection points will be set to none", "predict": " public <T> BeanDefinition<T> registerPetiteBean( final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer, final Consumer<T> postConstruct, final Consumer<T> preDestroy ) { if (name == null) { name = resolveBeanName(type); } if (wiringMode == null) { wiringMode = petiteConfig.getDefaultWiringMode(); } if (scopeType == null) { scopeType = annotationResolver.resolveBeanScopeType(type); } if (scopeType == null) { scopeType = SingletonScope.class; } // remove existing bean BeanDefinition existing = removeBean(name); if (existing != null) { if (petiteConfig.getDetectDuplicatedBeanNames()) { throw new PetiteException( \"Duplicated bean name detected while registering class '\" + type.getName() + \"'. Petite"}, {"ID": 763, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerBean(final String name, final BeanDefinition beanDefinition) { beans.put(name, beanDefinition); if (!petiteConfig.isUseAltBeanNames()) { return; } Class type = beanDefinition.type(); if (annotationResolver.beanHasAnnotationName(type)) { return; } Class[] interfaces = ClassUtil.resolveAllInterfaces(type); for (Class anInterface : interfaces) { String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames()); if (name.equals(altName)) { continue; } if (beans.containsKey(altName)) { continue; } if (beansAlt.containsKey(altName)) { BeanDefinition existing = beansAlt.get(altName); if (existing != null) { beansAlt.put(altName, null); // store null as value to mark that alt name is duplicate } } else { beansAlt.put(altName, beanDefinition); } } } \nResponse:", "ground_truth": "Registers bean definition by putting it in the beans map. If bean does\nnot have petite name explicitly defined, alternative bean names\nwill be registered.", "predict": "\n\n*/\n\npackage petite.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Petite bean registration annotation.\n *\n * @author Mugen87 (https://github.com/Mugen87)\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Register {\n\n    /**\n     * The name of the bean.\n     *\n     * @return The name of the bean\n     */\n    String value();\n\n    /**\n     * The bean definition.\n     *\n     * @return The bean definition\n     */\n    BeanDefinition bean() default @BeanDefinition(type = Object.class);\n\n"}, {"ID": 764, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeBean(final Class type) { // collect bean names Set<String> beanNames = new HashSet<>(); for (BeanDefinition def : beans.values()) { if (def.type.equals(type)) { beanNames.add(def.name); } } // remove collected bean names for (String beanName : beanNames) { removeBean(beanName); } } \nResponse:", "ground_truth": "Removes all petite beans of provided type. Bean name is not resolved from a type!\nInstead, all beans are iterated and only beans with equal types are removed.\n@see #removeBean(String)", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class RemoveBean {\n\n    public static void main(String[] args) {\n        Map<String, BeanDefinition> beans = new BeanDefinitionBuilder().build();\n        Set<String> beanNames = new BeanDefinitionBuilder().build().keySet();\n        List<String> beanNamesList = new ArrayList<>(beanNames);\n        for (String beanName : beanNamesList) {\n            beans.remove(beanName);\n        }\n    }\n}\n"}, {"ID": 765, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] resolveBeanNamesForType(final Class type) { String[] beanNames = beanCollections.get(type); if (beanNames != null) { return beanNames; } ArrayList<String> list = new ArrayList<>(); for (Map.Entry<String, BeanDefinition> entry : beans.entrySet()) { BeanDefinition beanDefinition = entry.getValue(); if (ClassUtil.isTypeOf(beanDefinition.type, type)) { String beanName = entry.getKey(); list.add(beanName); } } if (list.isEmpty()) { beanNames = StringPool.EMPTY_ARRAY; } else { beanNames = list.toArray(new String[0]); } beanCollections.put(type, beanNames); return beanNames; } \nResponse:", "ground_truth": "Resolves bean names for give type.", "predict": "\n\n*/\n\npublic class BeanCollection {\n    private static final Logger LOG = LoggerFactory.getLogger(BeanCollection.class);\n\n    private static final String[] EMPTY_ARRAY = new String[0];\n\n    private final Map<String, BeanDefinition> beans = new HashMap<>();\n\n    public BeanCollection(final Map<String, BeanDefinition> beans) {\n        this.beans.putAll(beans);\n    }\n\n    public BeanCollection(final BeanCollection beanCollection) {\n        this.beans.putAll(beanCollection.beans);\n    }\n\n    public BeanCollection() {\n    }\n\n    public void addBean(final BeanDefinition bean) {\n        this.beans.put(bean.name, bean);\n    }\n\n    public void addBean(final String name, final Class type) {\n        this.beans.put(name, new BeanDefinition(name, type));\n    }\n\n    public void addBe"}, {"ID": 766, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Constructor constructor = null; if (paramTypes == null) { CtorDescriptor[] ctors = cd.getAllCtorDescriptors(); if (ctors != null && ctors.length > 0) { if (ctors.length > 1) { throw new PetiteException(ctors.length + \" suitable constructor found as injection point for: \" + beanDefinition.type.getName()); } constructor = ctors[0].getConstructor(); } } else { CtorDescriptor ctorDescriptor = cd.getCtorDescriptor(paramTypes, true); if (ctorDescriptor != null) { constructor = ctorDescriptor.getConstructor(); } } if (constructor == null) { throw new PetiteException(\"Constructor not found: \" + beanDefinition.type.getName()); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(constructor, references); beanDefinition.ctor = new CtorInjectionPoint(constructor, ref); } \nResponse:", "ground_truth": "Registers constructor injection point.\n\n@param beanName bean name\n@param paramTypes constructor parameter types, may be null\n@param references references for arguments", "predict": " public void registerPetiteBean(final String beanName, final Class type, final String scope, final boolean singleton, final boolean lazyInit, final boolean eagerInit, final boolean destroyOnShutdown, final boolean destroyOnClose, final boolean destroyOnError, final boolean destroyOnErrorHandling, final boolean destroyOnException, final boolean destroyOnErrorHandlingThrows, final boolean destroyOnCloseThrows, final boolean destroyOnShutdownThrows, final boolean destroyOnErrorThrows, final boolean destroyOnErrorHandlingThrowsThrows, final boolean destroyOnCloseThrowsThrows, final boolean destroyOnShutdownThrowsThrows, final boolean destroyOnErrorThrowsThrowsThrows, final boolean destroyOnErrorHandlingThrowsThrowsThrows, final boolean destroyOnCloseThrowsThrowsThrows, final boolean destroyOnShutdownThrowsThrowsThrows, final boolean destroyOnErrorThrowsThrowsThrowsThrows, final boolean destroyOnErrorHandlingThrowsThrowsThrowsTh"}, {"ID": 767, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference); PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref); beanDefinition.addPropertyInjectionPoint(pip); } \nResponse:", "ground_truth": "Registers property injection point.\n\n@param beanName bean name\n@param property property name\n@param reference explicit injection reference, may be null", "predict": " public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference); PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref); beanDefinition.addPropertyInjectionPoint(pip); } \n\n}\n"}, {"ID": 768, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteSetInjectionPoint(final String beanName, final String property) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor); beanDefinition.addSetInjectionPoint(sip); } \nResponse:", "ground_truth": "Registers set injection point.\n\n@param beanName bean name\n@param property set property name", "predict": " public void registerPetiteSetInjectionPoint(final String beanName, final String property) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor); beanDefinition.addSetInjectionPoint(sip); } \n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"ID": 769, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Method method = null; if (arguments == null) { MethodDescriptor[] methods = cd.getAllMethodDescriptors(methodName); if (methods != null && methods.length > 0) { if (methods.length > 1) { throw new PetiteException(methods.length + \" suitable methods found as injection points for: \" + beanDefinition.type.getName() + '#' + methodName); } method = methods[0].getMethod(); } } else { MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md != null) { method = md.getMethod(); } } if (method == null) { throw new PetiteException(\"Method not found: \" + beanDefinition.type.getName() + '#' + methodName); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(method, references); MethodInjectionPoint mip = new MethodInjectionPoint(method, ref); beanDefinition.addMethodInjectionPoint(mip); } \nResponse:", "ground_truth": "Registers method injection point.\n\n@param beanName bean name\n@param methodName method name\n@param arguments method arguments, may be null\n@param references injection references", "predict": " public void registerPetiteBean(final String beanName, final Class type, final String scope) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); beanDefinition.type = type; beanDefinition.scope = scope; } \nResp public void registerPetiteBean(final String beanName, final Class type, final String scope, final String scopeType) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); beanDefinition.type = type; beanDefinition.scope = scope; beanDefinition.scopeType = scopeType; } \nResp public void registerPetiteBean(final String beanName, final Class type, final String scope, final String scopeType, final String scopeKey) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); beanDefinition.type = type; beanDefinition.scope = scope; beanDefinition.scopeType = scopeType; beanDefinition.scopeKey = scopeKey; } \nResp public void registerPetiteBe"}, {"ID": 770, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (initMethodNames == null) { initMethodNames = StringPool.EMPTY_ARRAY; } int total = initMethodNames.length; InitMethodPoint[] initMethodPoints = new InitMethodPoint[total]; int i; for (i = 0; i < initMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Init method not found: \" + beanDefinition.type.getName() + '#' + initMethodNames[i]); } initMethodPoints[i] = new InitMethodPoint(md.getMethod(), i, invocationStrategy); } beanDefinition.addInitMethodPoints(initMethodPoints); } \nResponse:", "ground_truth": "Registers init method.\n\n@param beanName bean name\n@param invocationStrategy moment of invocation\n@param initMethodNames init method names", "predict": " public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) { registerPetiteInitMethods(beanName, invocationStrategy, initMethodNames); } \n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.RuntimeBeanReference;\nimport org.springframework.beans.factory.support.AbstractBeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.spring"}, {"ID": 771, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (destroyMethodNames == null) { destroyMethodNames = StringPool.EMPTY_ARRAY; } int total = destroyMethodNames.length; DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total]; int i; for (i = 0; i < destroyMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Destroy method not found: \" + beanDefinition.type.getName() + '#' + destroyMethodNames[i]); } destroyMethodPoints[i] = new DestroyMethodPoint(md.getMethod()); } beanDefinition.addDestroyMethodPoints(destroyMethodPoints); } \nResponse:", "ground_truth": "Registers destroy method.\n\n@param beanName bean name\n@param destroyMethodNames destroy method names", "predict": " public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) { registerPetiteDestroyMethods(beanName, destroyMethodNames, null); } \nResp public void registerPetiteDestroyMethods(final String beanName, String[] destroyMethodNames, String[] destroyMethodNames2) { registerPetiteDestroyMethods(beanName, destroyMethodNames, destroyMethodNames2, null); } \nResp public void registerPetiteDestroyMethods(final String beanName, String[] destroyMethodNames, String[] destroyMethodNames2, String[] destroyMethodNames3) { registerPetiteDestroyMethods(beanName, destroyMethodNames, destroyMethodNames2, destroyMethodNames3, null); } \nResp public void registerPetiteDestroyMethods(final String beanName, String[] destroyMethodNames, String[] destroyMethodNames2, String[] destroyMethodNames3, String[] destroyMethodNames4) { registerPetiteDestroyMethods(beanName, destroyMethodNames, destroyMethodNames2, destroy"}, {"ID": 772, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) { BeanDefinition beanDefinition = lookupBeanDefinition(beanName); if (beanDefinition == null) { throw new PetiteException(\"Bean not found: \" + beanName); } Class beanType = beanDefinition.type; ClassDescriptor cd = ClassIntrospector.get().lookup(beanType); MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + methodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod()); providers.put(providerName, providerDefinition); } \nResponse:", "ground_truth": "Registers instance method provider.\n\n@param providerName provider name\n@param beanName bean name\n@param methodName instance method name\n@param arguments method argument types", "predict": " public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments, final Object[] args) { BeanDefinition beanDefinition = lookupBeanDefinition(beanName); if (beanDefinition == null) { throw new PetiteException(\"Bean not found: \" + beanName); } Class beanType = beanDefinition.type; ClassDescriptor cd = ClassIntrospector.get().lookup(beanType); MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + methodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod()); providers.put(providerName, providerDefinition); } \nResp public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments, final Object[] args, final Class"}, {"ID": 773, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + staticMethodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod()); providers.put(providerName, providerDefinition); } \nResponse:", "ground_truth": "Registers static method provider.\n\n@param providerName provider name\n@param type class type\n@param staticMethodName static method name\n@param arguments method argument types", "predict": " public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + staticMethodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod()); providers.put(providerName, providerDefinition); } \n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.petite.annotation.PetiteBean;\nimport org.petite.annotation.PetiteComponent;\nimport org.petite.context.PetiteContext;\nimport org.petite.util.ReflectionUtil;\n\n/**"}, {"ID": 774, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) { forEachBean(bd -> { if (ClassUtil.isTypeOf(bd.type, type)) { beanNameConsumer.accept(bd.name); } }); } \nResponse:", "ground_truth": "Iterates all beans that are of given type.", "predict": "\n\npublic void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) {\n    forEachBean(bd -> {\n        if (ClassUtil.isTypeOf(bd.type, type)) {\n            beanNameConsumer.accept(bd.name);\n        }\n    });\n}\n\n*/\n\npublic class BeanType {\n    public final String name;\n    public final Class type;\n\n    public BeanType(String name, Class type) {\n        this.name = name;\n        this.type = type;\n    }\n}\n"}, {"ID": 775, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void defineParameters(final Map<?, ?> properties) { for (Map.Entry<?, ?> entry : properties.entrySet()) { defineParameter(entry.getKey().toString(), entry.getValue()); } } \nResponse:", "ground_truth": "Defines many parameters at once.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 776, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object intercept(final ActionRequest actionRequest) throws Exception { printBefore(actionRequest); long startTime = System.currentTimeMillis(); Object result = null; try { result = actionRequest.invoke(); } catch (Exception ex) { result = \"<exception>\"; throw ex; } catch (Throwable th) { result = \"<throwable>\"; throw new Exception(th); } finally { long executionTime = System.currentTimeMillis() - startTime; printAfter(actionRequest, executionTime, result); } return result; } \nResponse:", "ground_truth": "Measure action invocation time.", "predict": " @Override public Object intercept(final ActionRequest actionRequest) throws Exception { printBefore(actionRequest); long startTime = System.currentTimeMillis(); Object result = null; try { result = actionRequest.invoke(); } catch (Exception ex) { result = \"<exception>\"; throw ex; } catch (Throwable th) { result = \"<throwable>\"; throw new Exception(th); } finally { long executionTime = System.currentTimeMillis() - startTime; printAfter(actionRequest, executionTime, result); } return result; } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.log4j.Logger;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.firefox.FirefoxProfile;\nimport org.openqa.selenium.remote.DesiredCapabilities;\nimport org"}, {"ID": 777, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int resolveJavaVersion(final int version) { final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber(); final int platformVersion = javaVersionNumber - 8 + 52; return version > platformVersion ? version : platformVersion; } \nResponse:", "ground_truth": "Resolves Java version from current version.", "predict": "\n\n*/\n\npublic class Solution {\n    public static int resolveJavaVersion(int version) {\n        int javaVersionNumber = SystemUtil.info().getJavaVersionNumber();\n        int platformVersion = javaVersionNumber - 8 + 52;\n        return version > platformVersion ? version : platformVersion;\n    }\n}\n"}, {"ID": 778, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void pushInt(final MethodVisitor mv, final int value) { if (value <= 5) { mv.visitInsn(ICONST_0 + value); } else if (value <= Byte.MAX_VALUE) { mv.visitIntInsn(BIPUSH, value); } else { mv.visitIntInsn(SIPUSH, value); } } \nResponse:", "ground_truth": "Pushes int value in an optimal way.", "predict": "\n\npublic static void pushInt(final MethodVisitor mv, final int value) { if (value <= 5) { mv.visitInsn(ICONST_0 + value); } else if (value <= Byte.MAX_VALUE) { mv.visitIntInsn(BIPUSH, value); } else { mv.visitIntInsn(SIPUSH, value); } } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test(1);\n        s.test(2);\n        s.test(3);\n        s.test(4);\n        s.test(5);\n        s.test(6);\n        s.test(7);\n        s.test(8);\n        s.test(9);\n        s.test(10);\n        s.test(11);\n        s.test(12);"}, {"ID": 779, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) { if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) { throw new ProxettaException(\"Invalid argument index: \" + argIndex); } } \nResponse:", "ground_truth": "Validates argument index.", "predict": "\n\n*/\n\npackage com.javadeobfuscator.deobfuscator.transformers.general.matcher;\n\nimport com.javadeobfuscator.deobfuscator.transformers.Transformer;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.ClassMatcher;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.MethodMatcher;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.MethodMatcherHelper;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.MethodMatcherHelper.MethodMatch;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.MethodMatcherHelper.MethodMatchType;"}, {"ID": 780, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String adviceFieldName(final String name, final int index) { return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index; } \nResponse:", "ground_truth": "Builds advice field name.", "predict": "\n\n*/\n\npublic class AdviceFieldName {\n\n    public static String adviceFieldName(String name, int index) {\n        return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index;\n    }\n}\n"}, {"ID": 781, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String adviceMethodName(final String name, final int index) { return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index; } \nResponse:", "ground_truth": "Builds advice method name.", "predict": "\n\n*/\n\npublic class AdviceMethodNameGenerator {\n\n    public static String generate(final String name, final int index) {\n        return \"public static String adviceMethodName(final String name, final int index) { return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index; } \";\n    }\n}\n"}, {"ID": 782, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { mv.visitVarInsn(ALOAD, 0); for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKESPECIAL call.", "predict": "\npublic static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { mv.visitVarInsn(ALOAD, 0); for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \n\n*/\n\npublic class SpecialMethodArguments {\n\t\n\tpublic static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {\n\t\tmv.visitVarInsn(ALOAD, 0);\n\t\tfor (int i = 1; i <= methodInfo.getArgumentsCount(); i++) {\n\t\t\tloadMethodArgument(mv, methodInfo, i);\n\t\t}\n\t}\n\t\n\tprivate static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int i) {\n\t\tfinal Class<?> argumentType = methodInfo.getArg"}, {"ID": 783, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 0; i < methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKESTATIC call.", "predict": "\n\n*/\n\npublic class LoadStaticMethodArguments extends Instruction {\n\tpublic LoadStaticMethodArguments(int opcode, int index) {\n\t\tsuper(opcode, index);\n\t}\n\n\tpublic LoadStaticMethodArguments(int opcode, int index, int line) {\n\t\tsuper(opcode, index, line);\n\t}\n\n\tpublic void accept(JVMInstructionVisitor insVisitor) {\n\t\tinsVisitor.visit(this);\n\t}\n}\n"}, {"ID": 784, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKEVIRTUAL call.", "predict": "\n\n*/\n\npublic class LoadVirtualMethodArguments extends Instruction {\n\t\n\tpublic LoadVirtualMethodArguments(int opcode, int codeOffset, int codeLength, int[] code) {\n\t\tsuper(opcode, codeOffset, codeLength, code);\n\t}\n\t\n\tpublic Instruction parse(byte[] code, int offset) {\n\t\treturn new LoadVirtualMethodArguments(code[offset], code[offset + 1], code[offset + 2], new int[] { code[offset + 3], code[offset + 4] });\n\t}\n\t\n\tpublic int[] getCode() {\n\t\treturn code;\n\t}\n\t\n\tpublic int getOpcode() {\n\t\treturn opcode;\n\t}\n\t\n\tpublic int getCodeOffset() {\n\t\treturn codeOffset;\n\t}\n\t\n\tpublic int getCodeLength() {\n\t\treturn codeLength;\n\t}\n\t\n\tpublic int getArgumentCount() {\n\t\t"}, {"ID": 785, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ILOAD, offset); break; case 'J': mv.visitVarInsn(LLOAD, offset); break; case 'F': mv.visitVarInsn(FLOAD, offset); break; case 'D': mv.visitVarInsn(DLOAD, offset); break; default: mv.visitVarInsn(ALOAD, offset); } } \nResponse:", "ground_truth": "Loads one argument. Index is 1-based. No conversion occurs.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MethodArgument {\n    private int opcode;\n    private int offset;\n    private int type;\n\n    public MethodArgument(int opcode, int offset, int type) {\n        this.opcode = opcode;\n        this.offset = offset;\n        this.type = type;\n    }\n\n    public int getOpcode() {\n        return opcode;\n    }\n\n    public int getOffset() {\n        return offset;\n    }\n\n    public int getType() {\n        return type;\n    }\n}\n"}, {"ID": 786, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ISTORE, offset); break; case 'J': mv.visitVarInsn(LSTORE, offset); break; case 'F': mv.visitVarInsn(FSTORE, offset); break; case 'D': mv.visitVarInsn(DSTORE, offset); break; default: mv.visitVarInsn(ASTORE, offset); } } \nResponse:", "ground_truth": "Stores one argument. Index is 1-based. No conversion occurs.", "predict": " public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ISTORE, offset); break; case 'J': mv.visitVarInsn(LSTORE, offset); break; case 'F': mv.visitVarInsn(FSTORE, offset); break; case 'D': mv.visitVarInsn(DSTORE, offset); break; default: mv.visitVarInsn(ASTORE, offset); } } \n\n*/\n"}, {"ID": 787, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) { varOffset += methodInfo.getAllArgumentsSize(); switch (methodInfo.getReturnType().getOpcode()) { case 'V': mv.visitInsn(ACONST_NULL); break; case 'B': AsmUtil.valueOfByte(mv); break; case 'C': AsmUtil.valueOfCharacter(mv); break; case 'S': AsmUtil.valueOfShort(mv); break; case 'I': AsmUtil.valueOfInteger(mv); break; case 'Z': AsmUtil.valueOfBoolean(mv); break; case 'J': AsmUtil.valueOfLong(mv); break; case 'F': AsmUtil.valueOfFloat(mv); break; case 'D': AsmUtil.valueOfDouble(mv); break; } } \nResponse:", "ground_truth": "Prepares return value.", "predict": " public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) { varOffset += methodInfo.getAllArgumentsSize(); switch (methodInfo.getReturnType().getOpcode()) { case 'V': mv.visitInsn(ACONST_NULL); break; case 'B': AsmUtil.valueOfByte(mv); break; case 'C': AsmUtil.valueOfCharacter(mv); break; case 'S': AsmUtil.valueOfShort(mv); break; case 'I': AsmUtil.valueOfInteger(mv); break; case 'Z': AsmUtil.valueOfBoolean(mv); break; case 'J': AsmUtil.valueOfLong(mv); break; case 'F': AsmUtil.valueOfFloat(mv); break; case 'D': AsmUtil.valueOfDouble(mv); break;"}, {"ID": 788, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) { return new StringBand(7) .append(access) .append(COLON) .append(description) .append(StringPool.UNDERSCORE) .append(className) .append(StringPool.HASH) .append(methodName) .toString(); } \nResponse:", "ground_truth": "Creates unique key for method signatures map.", "predict": "\n\npublic static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) { return new StringBand(7) .append(access) .append(COLON) .append(description) .append(StringPool.UNDERSCORE) .append(className) .append(StringPool.HASH) .append(methodName) .toString(); } \n\n*/\n\npublic class MethodSignaturesKeyGenerator {\n\t\n\tpublic static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) {\n\t\treturn new StringBand(7)\n\t\t\t\t.append(access)\n\t\t\t\t.append(COLON)\n\t\t\t\t.append(description)\n\t\t\t\t.append(StringPool.UNDERSCORE)\n\t\t\t\t.append(className)\n\t\t\t\t.append(StringPool.HASH)\n\t\t\t\t.append(methodName)\n\t\t\t\t.toString();"}, {"ID": 789, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void newArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitIntInsn(NEWARRAY, T_INT); return; } if (componentType == long.class) { mv.visitIntInsn(NEWARRAY, T_LONG); return; } if (componentType == float.class) { mv.visitIntInsn(NEWARRAY, T_FLOAT); return; } if (componentType == double.class) { mv.visitIntInsn(NEWARRAY, T_DOUBLE); return; } if (componentType == byte.class) { mv.visitIntInsn(NEWARRAY, T_BYTE); return; } if (componentType == short.class) { mv.visitIntInsn(NEWARRAY, T_SHORT); return; } if (componentType == boolean.class) { mv.visitIntInsn(NEWARRAY, T_BOOLEAN); return; } if (componentType == char.class) { mv.visitIntInsn(NEWARRAY, T_CHAR); return; } mv.visitTypeInsn(ANEWARRAY, AsmUtil.typeToSignature(componentType)); } \nResponse:", "ground_truth": "Creates new array.", "predict": "\npublic static void newArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitIntInsn(NEWARRAY, T_INT); return; } if (componentType == long.class) { mv.visitIntInsn(NEWARRAY, T_LONG); return; } if (componentType == float.class) { mv.visitIntInsn(NEWARRAY, T_FLOAT); return; } if (componentType == double.class) { mv.visitIntInsn(NEWARRAY, T_DOUBLE); return; } if (componentType == byte.class) { mv.visitIntInsn(NEWARRAY, T_BYTE); return; } if (componentType == short.class) { mv.visitIntInsn(NEWARRAY, T_SHORT); return; } if (componentType == boolean.class)"}, {"ID": 790, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeIntoArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitInsn(IASTORE); return; } if (componentType == long.class) { mv.visitInsn(LASTORE); return; } if (componentType == float.class) { mv.visitInsn(FASTORE); return; } if (componentType == double.class) { mv.visitInsn(DASTORE); return; } if (componentType == byte.class) { mv.visitInsn(BASTORE); return; } if (componentType == short.class) { mv.visitInsn(SASTORE); return; } if (componentType == boolean.class) { mv.visitInsn(BASTORE); return; } if (componentType == char.class) { mv.visitInsn(CASTORE); return; } mv.visitInsn(AASTORE); } \nResponse:", "ground_truth": "Stores element on stack into an array.", "predict": "\n\npublic static void storeIntoArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitInsn(IASTORE); return; } if (componentType == long.class) { mv.visitInsn(LASTORE); return; } if (componentType == float.class) { mv.visitInsn(FASTORE); return; } if (componentType == double.class) { mv.visitInsn(DASTORE); return; } if (componentType == byte.class) { mv.visitInsn(BASTORE); return; } if (componentType == short.class) { mv.visitInsn(SASTORE); return; } if (componentType == boolean.class) { mv.visitInsn(BASTORE); return; } if (componentType == char.class) { mv.visitInsn("}, {"ID": 791, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String extractEncoding(final String contentType, String defaultEncoding) { String encoding = extractEncoding(contentType); if (encoding == null) { if (defaultEncoding == null) { defaultEncoding = JoddCore.encoding; } encoding = defaultEncoding; } return encoding; } \nResponse:", "ground_truth": "Extracts encoding from a given content type.\n\n@param contentType     content type.\n@param defaultEncoding Default encoding to be used if extract returns {@code null}.\nIf defaultEncoding is {@code null}, {@link JoddCore#encoding} will be used.\n@return Encoding from the content type.\n@see #extractEncoding(String)", "predict": "\n\npublic static String extractEncoding(final String contentType) {\n\tif (contentType == null) {\n\t\treturn null;\n\t}\n\tfinal int index = contentType.indexOf(\"charset=\");\n\tif (index == -1) {\n\t\treturn null;\n\t}\n\tfinal int end = contentType.indexOf(';', index);\n\tif (end == -1) {\n\t\treturn contentType.substring(index + 8);\n\t}\n\treturn contentType.substring(index + 8, end);\n}\n\n*/\n"}, {"ID": 792, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isEmptyFlags(Flags flags) { if (flags == null) return true; Flags.Flag[] systemFlags = flags.getSystemFlags(); if (systemFlags != null && systemFlags.length > 0) { return false; } String[] userFlags = flags.getUserFlags(); if (userFlags != null && userFlags.length > 0) { return false; } return true; } \nResponse:", "ground_truth": "Check whether flags is a empty flags\n@param flags a flags of message to check\n@return whether the flags is empty", "predict": "\n\n*/\n\npublic class Flags {\n    public static final String[] SYSTEM_FLAGS = new String[] {\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN\",\n            \"UNKNOWN"}, {"ID": 793, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveAuthBearerToken(final HttpServletRequest request) { String header = request.getHeader(HEADER_AUTHORIZATION); if (header == null) { return null; } int ndx = header.indexOf(\"Bearer \"); if (ndx == -1) { return null; } return header.substring(ndx + 7).trim(); } \nResponse:", "ground_truth": "Returns Bearer token.", "predict": "\n\npublic static String resolveAuthBearerToken(final HttpServletRequest request) {\n    String header = request.getHeader(HEADER_AUTHORIZATION);\n    if (header == null) {\n        return null;\n    }\n    int ndx = header.indexOf(\"Bearer \");\n    if (ndx == -1) {\n        return null;\n    }\n    return header.substring(ndx + 7).trim();\n}\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class AuthBearerToken {\n\n    public static String resolveAuthBearerToken(final HttpServletRequest request) {\n        String header = request.getHeader(HEADER_AUTHORIZATION);\n        if (header == null) {\n            return null;\n        }\n        int ndx = header.indexOf(\"Bearer \");\n"}, {"ID": 794, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException { resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"'); resp.sendError(HttpServletResponse.SC_UNAUTHORIZED); } \nResponse:", "ground_truth": "Sends correct headers to require basic authentication for the given realm.", "predict": "\n\npublic static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException { resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"'); resp.sendError(HttpServletResponse.SC_UNAUTHORIZED); } \n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RequireAuthentication extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Servlet"}, {"ID": 795, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); } prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length()); } \nResponse:", "ground_truth": "Prepares response for file download with provided mime type.", "predict": " Generate the method-level comment for the following java Code. Code: public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); } prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length()); } \nResp Generate the method-level comment for the following java Code. Code: public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); }"}, {"ID": 796, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) { if ((mimeType == null) && (fileName != null)) { String extension = FileNameUtil.getExtension(fileName); mimeType = MimeTypes.getMimeType(extension); } if (mimeType != null) { response.setContentType(mimeType); } if (fileSize >= 0) { response.setContentLength(fileSize); } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if (fileName != null) { String name = FileNameUtil.getName(fileName); String encodedFileName = URLCoder.encode(name); response.setHeader(CONTENT_DISPOSITION, \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName); } } \nResponse:", "ground_truth": "null\n@param fileSize if less then 0 it will be ignored", "predict": " Generate the method-level comment for the following java Code. Code: public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) { if ((mimeType == null) && (fileName != null)) { String extension = FileNameUtil.getExtension(fileName); mimeType = MimeTypes.getMimeType(extension); } if (mimeType != null) { response.setContentType(mimeType); } if (fileSize >= 0) { response.setContentLength(fileSize); } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if (fileName != null) { String name = FileNameUtil.getName(fileName); String encodedFileName = URLCoder.encode(name); response.setHeader(CONTENT_DISPOSITION, \"attachment;filename=\\\"\" +"}, {"ID": 797, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) { Cookie[] cookies = request.getCookies(); if (cookies == null) { return null; } ArrayList<Cookie> list = new ArrayList<>(cookies.length); for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { list.add(cookie); } } if (list.isEmpty()) { return null; } return list.toArray(new Cookie[0]); } \nResponse:", "ground_truth": "", "predict": " public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) { Cookie[] cookies = request.getCookies(); if (cookies == null) { return null; } ArrayList<Cookie> list = new ArrayList<>(cookies.length); for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { list.add(cookie); } } if (list.isEmpty()) { return null; } return list.toArray(new Cookie[0]); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CookieUtils {\n\t\n\tpublic static List<Cookie> getAllCookies(HttpServletRequest request, String cookieName) {\n\t\tList<Cookie> cookies = new ArrayList<>();\n\t\tCookie[] cookiesArray = request.getCookies();\n\t\tif (cookiesArray == null) {\n"}, {"ID": 798, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException { BufferedReader buff = request.getReader(); StringWriter out = new StringWriter(); StreamUtil.copy(buff, out); return out.toString(); } \nResponse:", "ground_truth": "Reads HTTP request body using the request reader. Once body is read,\nit cannot be read again!", "predict": " public static String readResponseBodyFromReader(final HttpServletResponse response) throws IOException { BufferedReader buff = response.getReader(); StringWriter out = new StringWriter(); StreamUtil.copy(buff, out); return out.toString(); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io."}, {"ID": 799, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException { String charEncoding = request.getCharacterEncoding(); if (charEncoding == null) { charEncoding = JoddCore.encoding; } CharArrayWriter charArrayWriter = new CharArrayWriter(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding)); StreamUtil.copy(bufferedReader, charArrayWriter); } else { return StringPool.EMPTY; } } finally { StreamUtil.close(bufferedReader); } return charArrayWriter.toString(); } \nResponse:", "ground_truth": "Reads HTTP request body using the request stream. Once body is read,\nit cannot be read again!", "predict": " Generate the method-level comment for the following java Code. Code: public static String readResponseBodyFromStream(final HttpServletResponse response) throws IOException { String charEncoding = response.getCharacterEncoding(); if (charEncoding == null) { charEncoding = JoddCore.encoding; } CharArrayWriter charArrayWriter = new CharArrayWriter(); BufferedReader bufferedReader = null; try { OutputStream outputStream = response.getOutputStream(); if (outputStream != null) { bufferedReader = new BufferedReader(new OutputStreamReader(outputStream, charEncoding)); StreamUtil.copy(bufferedReader, charArrayWriter); } else { return StringPool.EMPTY; } } finally { StreamUtil.close(bufferedReader); } return charArrayWriter.toString(); } \n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util"}, {"ID": 800, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) { String ctxPath = getContextPath(pageContext); HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); request.setAttribute(contextPathVariableName, ctxPath); ServletContext servletContext = pageContext.getServletContext(); servletContext.setAttribute(contextPathVariableName, ctxPath); } \nResponse:", "ground_truth": "Stores context path in server context and request scope.", "predict": " public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) { String ctxPath = getContextPath(pageContext); HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); request.setAttribute(contextPathVariableName, ctxPath); ServletContext servletContext = pageContext.getServletContext(); servletContext.setAttribute(contextPathVariableName, ctxPath); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache."}, {"ID": 801, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) { String ctxPath = getContextPath(servletContext); servletContext.setAttribute(contextPathVariableName, ctxPath); } \nResponse:", "ground_truth": "Stores context path in page context and request scope.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport com.google.gson.Gson;\n\npublic class ContextPathController extends AbstractController {\n\t\n\tprivate static final Logger logger = Logger.getLogger(ContextPathController.class);\n\t\n\tprivate static final String CONT"}, {"ID": 802, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isGetParameter(final HttpServletRequest request, String name) { name = URLCoder.encodeQueryParam(name) + '='; String query = request.getQueryString(); String[] nameValuePairs = StringUtil.splitc(query, '&'); for (String nameValuePair : nameValuePairs) { if (nameValuePair.startsWith(name)) { return true; } } return false; } \nResponse:", "ground_truth": "Checks if some parameter is in GET parameters.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class TestServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\tresp.setContentType(\"text/html\");\n\t\tPrintWriter out = resp.getWriter();\n\t\tout.println(\"<html><head><title>TestServ"}, {"ID": 803, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] prepareParameters( final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) { int emptyCount = 0; int total = paramValues.length; for (int i = 0; i < paramValues.length; i++) { String paramValue = paramValues[i]; if (paramValue == null) { emptyCount++; continue; } if (paramValue.length() == 0) { emptyCount++; if (treatEmptyParamsAsNull) { paramValue = null; } } paramValues[i] = paramValue; } if ((ignoreEmptyRequestParams) && (emptyCount == total)) { return null; } } return paramValues; } \nResponse:", "ground_truth": "Prepares parameters for further processing.\n@param paramValues\tstring array of param values\n@param treatEmptyParamsAsNull\tempty parameters should be treated as null\n@param ignoreEmptyRequestParams\tif all parameters are empty, return null", "predict": " public static String[] prepareParameters( final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) { int emptyCount = 0; int total = paramValues.length; for (int i = 0; i < paramValues.length; i++) { String paramValue = paramValues[i]; if (paramValue == null) { emptyCount++; continue; } if (paramValue.length() == 0) { emptyCount++; if (treatEmptyParamsAsNull) { paramValue = null; } } paramValues[i] = paramValue; } if ((ignoreEmptyRequestParams) && (emptyCount == total)) { return null; } } return paramValues; } \n\n*/\n"}, {"ID": 804, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copyParamsToAttributes( final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { Enumeration paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues == null) { continue; } servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } // multipart if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } FileUpload[] paramValues = multipartRequest.getFiles(paramName); servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } } \nResponse:", "ground_truth": "Copies all request parameters to attributes.", "predict": " public static void copyParamsToAttributes( final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { Enumeration paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues == null) { continue; } servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } // multipart if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!"}, {"ID": 805, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void invokeBody(final JspFragment body) throws JspException { if (body == null) { return; } try { body.invoke(null); } catch (IOException ioex) { throw new JspException(\"Tag body failed\", ioex); } } \nResponse:", "ground_truth": "Invokes tag body.", "predict": " public static void invokeBody(final JspFragment body) throws JspException { if (body == null) { return; } try { body.invoke(null); } catch (IOException ioex) { throw new JspException(\"Tag body failed\", ioex); } } \n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.tagext.JspFragment;\n\npublic class JspFragmentTag extends JspFragment {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate List<JspFragment> fragments = new ArrayList<JspFragment>();\n\tprivate JspFragment body;\n\tprivate JspFragment head;\n\tprivate"}, {"ID": 806, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] renderBody(final JspFragment body) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter(); invokeBody(body, writer); return writer.toCharArray(); } \nResponse:", "ground_truth": "Renders tag body to char array.", "predict": " public static char[] renderBody(final JspFragment body) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter(); invokeBody(body, writer); return writer.toCharArray(); } \n\n*/\n\npublic class JspFragment {\n    private static final String JSP_FRAGMENT_CLASS_NAME = \"JspFragment\";\n    private static final String JSP_FRAGMENT_CLASS_NAME_WITH_PACKAGE = \"org.apache.jasper.runtime.JspFragment\";\n    private static final String JSP_FRAGMENT_CLASS_NAME_WITH_PACKAGE_AND_IMPORT = \"org.apache.jasper.runtime.JspFragment\";\n    private static final String JSP_FRAGMENT_CLASS_NAME_WITH_PACKAGE_AND_IMPORT_AND_IMPORT = \"org.apache.jasper.runtime.JspFragment\";\n    "}, {"ID": 807, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String renderBodyToString(final JspFragment body) throws JspException { char[] result = renderBody(body); return new String(result); } \nResponse:", "ground_truth": "Renders tag body to string.\n@see #renderBody(javax.servlet.jsp.tagext.JspFragment)", "predict": " public static char[] renderBody(final JspFragment body) throws JspException { \n\tfinal char[] result = new char[body.getLength()];\n\tfinal int length = body.getLength();\n\tfor (int i = 0; i < length; i++) { result[i] = body.getCh(); }\n\treturn result; } \n\n}\n"}, {"ID": 808, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) { for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) { if (invocationStrategy != initMethod.invocationStrategy) { continue; } try { initMethod.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid init method: \" + initMethod, ex); } } } \nResponse:", "ground_truth": "Invokes init methods.", "predict": "\n\n*/\n\npackage petite.test;\n\nimport petite.Bean;\nimport petite.Petite;\nimport petite.PetiteException;\nimport petite.PetiteInitException;\nimport petite.PetiteInitMethod;\nimport petite.PetiteInitMethodPoint;\nimport petite.PetiteUtil;\nimport petite.reflect.ReflectUtil;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author Juozas Baliuka\n */\npublic class InitMethodInvocationStrategy {\n\n    private final Bean bean;\n    private final List<InitMethodPoint> initMethodPoints;\n\n    public InitMethodInvocationStrategy(Bean bean) {\n        this.bean = bean;\n        this.initMethodPoints = new ArrayList<InitMethodPoint>();\n    }\n\n    public void addInitMethodPoint("}, {"ID": 809, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void callDestroyMethods() { for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) { try { destroyMethodPoint.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex); } } } \nResponse:", "ground_truth": "Calls destroy methods on given BeanData. Destroy methods are called\nwithout any order.", "predict": " void\n*/\n\npublic class DestroyMethodPoint {\n    public final Method method;\n    public final Object bean;\n\n    public DestroyMethodPoint(Method method, Object bean) {\n        this.method = method;\n        this.bean = bean;\n    }\n}\n"}, {"ID": 810, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object newBeanInstance() { if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) { throw new PetiteException(\"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition.type.getName()); } int paramNo = beanDefinition.ctor.references.length; Object[] args = new Object[paramNo]; // wiring if (beanDefinition.wiringMode != WiringMode.NONE) { for (int i = 0; i < paramNo; i++) { args[i] = pc.getBean(beanDefinition.ctor.references[i]); if (args[i] == null) { if ((beanDefinition.wiringMode == WiringMode.STRICT)) { throw new PetiteException( \"Wiring constructor failed. References '\" + beanDefinition.ctor.references[i] + \"' not found for constructor: \" + beanDefinition.ctor.constructor); } } } } // create instance final Object bean; try { bean = beanDefinition.ctor.constructor.newInstance(args); } catch (Exception ex) { throw new PetiteException(\"Failed to create new bean instance '\" + beanDefinition.type.getName() + \"' using constructor: \" + beanDefinition.ctor.constructor, ex); } return bean; } \nResponse:", "ground_truth": "Creates a new instance.", "predict": "\n\n*/\n\npackage petite.wiring;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport petite.BeanDefinition;\nimport petite.PetiteException;\nimport petite.Wiring;\n\n/**\n * Generates method-level comment for the following java Code. Code: public Object newBeanInstance() { if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) { throw new PetiteException(\"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition.type.getName()); } int paramNo = beanDefinition.ctor.references.length; Object[] args = new Object[paramNo]; // wiring if (beanDefinition.wiringMode != WiringMode.NONE) { for (int i = 0; i < paramNo; i++) {"}, {"ID": 811, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) { if (beanDefinition.name == null) { return; } if (implicitParamInjection) { // implicit final int len = beanDefinition.name.length() + 1; for (final String param : beanDefinition.params) { final Object value = paramManager.get(param); final String destination = param.substring(len); try { BeanUtil.declared.setProperty(bean, destination, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition.name, ex); } } } // explicit for (final ValueInjectionPoint pip : beanDefinition.values) { final String value = paramManager.parseKeyTemplate(pip.valueTemplate); try { BeanUtil.declared.setProperty(bean, pip.property, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set value for: '\" + pip.valueTemplate + \"' to bean: \" + beanDefinition.name, ex); } } } \nResponse:", "ground_truth": "Injects all parameters.", "predict": "\n\n*/\n\npackage petite.test;\n\nimport petite.Bean;\nimport petite.Petite;\nimport petite.PetiteException;\nimport petite.ValueInjectionPoint;\nimport petite.util.BeanUtil;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author \tSacha Zyto\n * @since \t1.0\n */\npublic class TestBean {\n\n\tpublic static void main(String[] args) {\n\t\tPetite petite = new Petite();\n\t\tpetite.registerPetiteBean(TestBean.class);\n\t\tpetite.registerPetiteBean(TestBean2.class);\n\t\tpetite.registerPetiteBean(TestBean3.class);\n\t\tpetite.registerPetiteBean(TestBean4.class);\n\t\tpetite"}, {"ID": 812, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"UnusedDeclaration\"}) public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) { return actionPath; } \nResponse:", "ground_truth": "Rewrites action path.", "predict": " @SuppressWarnings({\"UnusedDeclaration\"}) public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) { return actionPath; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport"}, {"ID": 813, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addHeader(final String name, final String value) { List<String> valuesList = super.getAll(name); if (valuesList.isEmpty()) { super.add(name, value); return; } super.remove(name); valuesList.add(value); super.addAll(name, valuesList); } \nResponse:", "ground_truth": "Adds new header value. If existing value exist, it will be removed\nso the store the new key value.", "predict": " public void addHeader(final String name, final String value) { List<String> valuesList = super.getAll(name); if (valuesList.isEmpty()) { super.add(name, value); return; } super.remove(name); valuesList.add(value); super.addAll(name, valuesList); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.addHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.117 Safari/537.36\");\n        s.addHeader(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n        s.addHeader(\"Accept-Language\", \"en"}, {"ID": 814, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) { String realValue = value; if (append || appendDuplicateProps) { PropsEntry pv = map.get(key); if (pv != null) { realValue = pv.value + APPEND_SEPARATOR + realValue; } } PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); } \nResponse:", "ground_truth": "Puts key-value pair into the map, with respect of appending duplicate properties", "predict": " public void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) { String realValue = value; if (append || appendDuplicateProps) { PropsEntry pv = map.get(key); if (pv != null) { realValue = pv.value + APPEND_SEPARATOR + realValue; } } PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); } \n\n}\n"}, {"ID": 815, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void putBaseProperty(final String key, final String value, final boolean append) { put(null, baseProperties, key, value, append); } \nResponse:", "ground_truth": "Adds base property.", "predict": " Resp public void putBaseProperty(final String key, final String value, final boolean append) { put(null, baseProperties, key, value, append); } \n\n*/\n\npublic class BaseProperty {\n\t\n\tprivate String key;\n\tprivate String value;\n\tprivate boolean append;\n\t\n\tpublic BaseProperty(String key, String value, boolean append) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.append = append;\n\t}\n\t\n\tpublic String getKey() {\n\t\treturn key;\n\t}\n\t\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\t\n\tpublic boolean isAppend() {\n\t\treturn append;\n\t}\n\t\n\tpublic void setKey(String key) {\n\t\tthis.key = key;\n\t}\n\t\n\tpublic void setValue(String value) {\n\t\tthis.value = value;\n\t}\n"}, {"ID": 816, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void putProfileProperty(final String key, final String value, final String profile, final boolean append) { Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>()); put(profile, map, key, value, append); } \nResponse:", "ground_truth": "Adds profile property.", "predict": "\n\n*/\n\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ProfileProperties {\n    private static final String PROPERTIES_FILE = \"profile.properties\";\n    private static final String PROPERTY_PREFIX = \"profile.property.\";\n    private static final String PROPERTY_SUFFIX = \".value\";\n    private static final String PROPERTY_APPEND = \".append\";\n    private static final String PROPERTY_KEY = \".key\";\n    private static final String PROPERTY_VALUE = \".value\";\n    private static final String PROPERTY_PROFILE = \".profile\";\n    private static final String PROPERTY_APPEND_VALUE = \".append.value\";\n    private static final String PROPERTY_APPEND_PROFILE = \".append.profile\";\n    private static final String PROPERTY_APPEND_KEY ="}, {"ID": 817, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropsEntry getProfileProperty(final String profile, final String key) { final Map<String, PropsEntry> profileMap = profileProperties.get(profile); if (profileMap == null) { return null; } return profileMap.get(key); } \nResponse:", "ground_truth": "Returns profile property.", "predict": " public PropsEntry getProfileProperty(final String profile, final String key) { final Map<String, PropsEntry> profileMap = profileProperties.get(profile); if (profileMap == null) { return null; } return profileMap.get(key); } \n\n*/\n\npublic class ProfileProperties {\n\tprivate Map<String, Map<String, PropsEntry>> profileProperties;\n\t\n\tpublic ProfileProperties() {\n\t\tprofileProperties = new HashMap<String, Map<String, PropsEntry>>();\n\t}\n\t\n\tpublic void addProfile(final String profile, final Map<String, PropsEntry> properties) {\n\t\tprofileProperties.put(profile, properties);\n\t}\n\t\n\tpublic PropsEntry getProfileProperty(final String profile, final String key) {\n\t\tfinal Map<String, PropsEntry> profileMap = profileProperties.get(profile);\n\t\tif (profileMap == null) {"}, {"ID": 818, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveMacros(String value, final String... profiles) { // create string template parser that will be used internally StringTemplateParser stringTemplateParser = new StringTemplateParser(); stringTemplateParser.setResolveEscapes(false); if (!ignoreMissingMacros) { stringTemplateParser.setReplaceMissingKey(false); } else { stringTemplateParser.setReplaceMissingKey(true); stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY); } final Function<String, String> macroResolver = macroName -> { String[] lookupProfiles = profiles; int leftIndex = macroName.indexOf('<'); if (leftIndex != -1) { int rightIndex = macroName.indexOf('>'); String profiles1 = macroName.substring(leftIndex + 1, rightIndex); macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(profiles1, ','); StringUtil.trimAll(lookupProfiles); } return lookupValue(macroName, lookupProfiles); }; // start parsing int loopCount = 0; while (loopCount++ < MAX_INNER_MACROS) { final String newValue = stringTemplateParser.parse(value, macroResolver); if (newValue.equals(value)) { break; } if (skipEmptyProps) { if (newValue.length() == 0) { return null; } } value = newValue; } return value; } \nResponse:", "ground_truth": "Resolves all macros in this props set. Called on property lookup.", "predict": "\n\n*/\n\npublic class MacroResolver {\n\n    private static final String TEMPLATE_PREFIX = \"template\";\n    private static final String TEMPLATE_SUFFIX = \".st\";\n    private static final String TEMPLATE_EXTENSION = \".st\";\n    private static final String TEMPLATE_PREFIX_WITH_EXTENSION = TEMPLATE_PREFIX + TEMPLATE_EXTENSION;\n    private static final String TEMPLATE_SUFFIX_WITH_EXTENSION = TEMPLATE_SUFFIX + TEMPLATE_EXTENSION;\n    private static final String TEMPLATE_PREFIX_WITH_DOT = TEMPLATE_PREFIX + \".\";\n    private static final String TEMPLATE_SUFFIX_WITH_DOT = TEMPLATE_SUFFIX + \".\";\n    private static final"}, {"ID": 819, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) { if (target == null) { target = new HashMap(); } // make sure prefix ends with a dot if (prefix != null) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } } if (profiles != null) { for (String profile : profiles) { while (true) { final Map<String, PropsEntry> map = this.profileProperties.get(profile); if (map != null) { extractMap(target, map, profiles, wildcardPatterns, prefix); } final int ndx = profile.lastIndexOf('.'); if (ndx == -1) { break; } profile = profile.substring(0, ndx); } } } extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix); return target; } \nResponse:", "ground_truth": "Extracts props to target map. This is all-in-one method, that does many things at once.", "predict": " public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) { if (target == null) { target = new HashMap(); } // make sure prefix ends with a dot if (prefix != null) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } } if (profiles != null) { for (String profile : profiles) { while (true) { final Map<String, PropsEntry> map = this.profileProperties.get(profile); if (map != null) { extractMap(target, map, profiles, wildcardPatterns, prefix); } final int ndx = profile.lastIndexOf('.'); if (ndx == -1) { break; } profile = profile.substring(0, ndx); } } } extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix); return target; } \n\n}\n"}, {"ID": 820, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int streamtoword(byte[] data, int[] offp) { int i; int word = 0; int off = offp[0]; for (i = 0; i < 4; i++) { word = (word << 8) | (data[off] & 0xff); off = (off + 1) % data.length; } offp[0] = off; return word; } \nResponse:", "ground_truth": "Cycically extract a word of key material.\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static int streamtoword(byte[] data, int[] offp) {\n        int i;\n        int word = 0;\n        int off = offp[0];\n        for (i = 0; i < 4; i++) {\n            word = (word << 8) | (data[off] & 0xff);\n            off = (off + 1) % data.length;\n        }\n        offp[0] = off;\n        return word;\n    }\n\n    public static void main(String[] args) {\n        byte[] data = {(byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, ("}, {"ID": 821, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String hashpw(String password, String salt) { BCrypt B; String real_salt; byte[] passwordb, saltb, hashed; char minor = (char) 0; int rounds, off; StringBuffer rs = new StringBuffer(); if (salt.charAt(0) != '$' || salt.charAt(1) != '2') { throw new IllegalArgumentException(\"Invalid salt version\"); } if (salt.charAt(2) == '$') { off = 3; } else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') { throw new IllegalArgumentException(\"Invalid salt revision\"); } off = 4; } // Extract number of rounds if (salt.charAt(off + 2) > '$') { throw new IllegalArgumentException(\"Missing salt rounds\"); } rounds = Integer.parseInt(salt.substring(off, off + 2)); real_salt = salt.substring(off + 3, off + 25); try { passwordb = (password + (minor >= 'a' ? \"\\000\" : \"\")).getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { throw new AssertionError(\"UTF-8 is not supported\"); } saltb = decode_base64(real_salt, BCRYPT_SALT_LEN); B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, (int[]) bf_crypt_ciphertext.clone()); rs.append(\"$2\"); if (minor >= 'a') { rs.append(minor); } rs.append('$'); if (rounds < 10) { rs.append('0'); } if (rounds > 30) { throw new IllegalArgumentException( \"rounds exceeds maximum (30)\"); } rs.append(rounds) .append('$') .append(encode_base64(saltb, saltb.length)) .append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); } \nResponse:", "ground_truth": "Hash a password using the OpenBSD bcrypt scheme.\n\n@param password the password to hash\n@param salt the salt to hash with (perhaps generated\nusing BCrypt.gensalt)\n@return the hashed password", "predict": "\n\npublic static String hashpw(String password, String salt) {\nBCrypt B; String real_salt; byte[] passwordb, saltb, hashed; char minor = (char) 0; int rounds, off; StringBuffer rs = new StringBuffer(); if (salt.charAt(0) != '$' || salt.charAt(1) != '2') { throw new IllegalArgumentException(\"Invalid salt version\"); } if (salt.charAt(2) == '$') { off = 3; } else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') { throw new IllegalArgumentException(\"Invalid salt revision\"); } off = 4; } // Extract number of rounds if (salt.charAt(off + 2) > '$') { throw new IllegalArgumentException(\"Missing salt rounds\"); } rounds = Integer.parseInt(salt.substring(off,"}, {"ID": 822, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean checkpw(String plaintext, String hashed) { byte[] hashed_bytes; byte[] try_bytes; try { String try_pw = hashpw(plaintext, hashed); hashed_bytes = hashed.getBytes(\"UTF-8\"); try_bytes = try_pw.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { return false; } if (hashed_bytes.length != try_bytes.length) { return false; } byte ret = 0; for (int i = 0; i < try_bytes.length; i++) { ret |= hashed_bytes[i] ^ try_bytes[i]; } return ret == 0; } \nResponse:", "ground_truth": "Check that a plaintext password matches a previously hashed\none.\n\n@param plaintext the plaintext password to verify\n@param hashed the previously-hashed password\n@return true if the passwords match, false otherwise", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Base64;\n\npublic class Hashpw {\n    public static String hashpw(String plaintext, String hashed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.update(plaintext.getBytes(\"UTF-8\"));\n            byte[] hashed_bytes = digest.digest(hashed.getBytes(\"UTF-8\"));\n            return Base64.getEncoder().encodeToString(hashed_bytes);\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n            return null;\n        }\n    }\n}\n"}, {"ID": 823, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int copyAll(final OutputStream out) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; } return count; } \nResponse:", "ground_truth": "Copies bytes from this stream to some output until boundary is\nreached. Returns number of copied bytes. It will throw an exception\nfor any irregular behaviour.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CopyAll {\n    public static void main(String[] args) throws IOException {\n        OutputStream out = System.out;\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write(0x00);\n        out.write"}, {"ID": 824, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; } \nResponse:", "ground_truth": "Copies max or less number of bytes to output stream. Useful for determining\nif uploaded file is larger then expected.", "predict": "\n\npublic int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; }\n\npublic int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; }\n\npublic int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count;"}, {"ID": 825, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod); final ActionConfig actionConfig = resolveActionConfig(annotationValues); // interceptors ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig); // filters ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig); // build action definition when not provided if (actionDefinition == null) { actionDefinition = parseActionDefinition(actionClass, actionMethod); } detectAndRegisterAlias(annotationValues, actionDefinition); final boolean async = parseMethodAsyncFlag(actionMethod); final boolean auth = parseMethodAuthFlag(actionMethod); final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod); final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult(); return createActionRuntime( null, actionClass, actionMethod, actionResult, defaultActionResult, actionFilters, actionInterceptors, actionDefinition, async, auth); } \nResponse:", "ground_truth": "Parses java action method annotation and returns its action runtime.\n\n@param actionClass action class\n@param actionMethod action method\n@param actionDefinition optional action def, usually null so to be parsed", "predict": " public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod); final ActionConfig actionConfig = resolveActionConfig(annotationValues); // interceptors ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig); // filters ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig); // build action definition when not provided if (actionDefinition == null) { actionDefinition = parseActionDefinition(actionClass, actionMethod); } detectAndRegisterAlias(annotationValues, actionDefinition); final boolean async = parseMethodAsyncFlag(actionMethod); final boolean auth = parseMethodAuthFlag(actionMethod); final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod); final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult(); return createActionRuntime( null, actionClass, actionMethod"}, {"ID": 826, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) { final Class<? extends Annotation> annotationType; if (annotationValues == null) { annotationType = Action.class; } else { annotationType = annotationValues.annotationType(); } return actionConfigManager.lookup(annotationType); } \nResponse:", "ground_truth": "Resolves action config.", "predict": " public ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) { final Class<? extends Annotation> annotationType; if (annotationValues == null) { annotationType = Action.class; } else { annotationType = annotationValues.annotationType(); } return actionConfigManager.lookup(annotationType); } \n */\n\npublic class ActionConfigManager {\n    private static final Logger LOG = LoggerFactory.getLogger(ActionConfigManager.class);\n\n    private final Map<Class<? extends Annotation>, ActionConfig> actionConfigs = new HashMap<>();\n\n    public ActionConfigManager() {\n        // TODO: add support for multiple ActionConfigs\n        actionConfigs.put(Action.class, new ActionConfig());\n    }\n\n    public ActionConfig lookup(final Class<? extends Annotation> annotationType) {\n        return actionConfigs.get(annotationType);\n    }\n\n    public void register(final ActionConfig actionConfig) {\n"}, {"ID": 827, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) { final String alias = parseMethodAlias(annotationValues); if (alias != null) { String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH); actionsManager.registerPathAlias(alias, aliasPath); } } \nResponse:", "ground_truth": "Detects if alias is defined in annotation and registers it if so.", "predict": " void\n*/\npublic class ActionAnnotationProcessor extends AbstractJavaSourceProcessor {\n\n    private static final String ACTION_ANNOTATION_CLASS_NAME = \"org.apache.struts2.convention.annotation.Action\";\n    private static final String ACTION_ANNOTATION_CLASS_NAME_WITH_DOT = ACTION_ANNOTATION_CLASS_NAME + \".\";\n    private static final String ACTION_ANNOTATION_CLASS_NAME_WITH_DOT_WITH_DOT = ACTION_ANNOTATION_CLASS_NAME_WITH_DOT + \".\";\n    private static final String ACTION_ANNOTATION_CLASS_NAME_WITH_DOT_WITH_DOT_WITH_DOT = ACTION_ANNOTATION_CLASS_NAME_WITH_DOT_WITH_DOT + \".\";\n    private static final String ACTION_ANNOTATION_CLASS_NAME_WITH_DOT_WITH"}, {"ID": 828, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionInterceptor>[] result = null; InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class); if (interceptedBy != null) { result = interceptedBy.value(); if (result.length == 0) { result = null; } } return result; } \nResponse:", "ground_truth": "Reads class or method annotation for action interceptors.", "predict": " Response response = null; InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class); if (interceptedBy != null) { response = interceptedBy.response(); if (response == null) { response = Response.class; } } return response; } \n\n// Generated code\n\n@InterceptedBy(value = {@InterceptedBy.Action(value = \"com.example.action.Action1\"), @InterceptedBy.Action(value = \"com.example.action.Action2\")})\npublic class InterceptedByTest {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n"}, {"ID": 829, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionFilter>[] result = null; FilteredBy filteredBy = actionClassOrMethod.getAnnotation(FilteredBy.class); if (filteredBy != null) { result = filteredBy.value(); if (result.length == 0) { result = null; } } return result; } \nResponse:", "ground_truth": "Reads class or method annotation for action filters.", "predict": " Response = new Response(); Response.setStatus(HttpStatus.OK.value()); Response.setEntity(new ResponseEntity<>(new Response(), HttpStatus.OK)); return Response; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.sw"}, {"ID": 830, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] readPackageActionPath(final Class actionClass) { Package actionPackage = actionClass.getPackage(); final String actionPackageName = actionPackage.getName(); // 1 - read annotations first String packageActionPathFromAnnotation; mainloop: while (true) { MadvocAction madvocActionAnnotation = actionPackage.getAnnotation(MadvocAction.class); packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null; if (StringUtil.isEmpty(packageActionPathFromAnnotation)) { packageActionPathFromAnnotation = null; } if (packageActionPathFromAnnotation == null) { // next package String newPackage = actionPackage.getName(); actionPackage = null; while (actionPackage == null) { final int ndx = newPackage.lastIndexOf('.'); if (ndx == -1) { // end of hierarchy, nothing found break mainloop; } newPackage = newPackage.substring(0, ndx); actionPackage = Packages.of(actionClass.getClassLoader(), newPackage); } } else { // annotation found, register root rootPackages.addRootPackage(actionPackage.getName(), packageActionPathFromAnnotation); break; } } // 2 - read root package String packagePath = rootPackages.findPackagePathForActionPackage(actionPackageName); if (packagePath == null) { return ArraysUtil.array(null, null); } return ArraysUtil.array( StringUtil.stripChar(packagePath, '/'), StringUtil.surround(packagePath, StringPool.SLASH) ); } \nResponse:", "ground_truth": "Reads action path for package.\nIf annotation is not set on package-level, class package will be used for\npackage action path part.", "predict": "\n\npublic class ActionPath {\n\tprivate String[] path;\n\tprivate String[] packagePath;\n\tprivate String packageActionPathFromAnnotation;\n\tprivate String packageActionPathFromRoot;\n\tprivate String packageActionPathFromRootPackage;\n\tprivate String packageActionPathFromRootPackagePath;\n\tprivate String packageActionPathFromRootPackagePathSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlashSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlashSlashSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlashSlashSlashSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlashSlashSlashSlashSlash;\n\tprivate String packageActionPathFromRootPackagePathSlashSlashSlashSlashSlashSlashSlashSlash;\n\tprivate String packageActionPathFrom"}, {"ID": 831, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) { // read annotation String methodActionPath = annotationValues != null ? annotationValues.value() : null; if (methodActionPath == null) { methodActionPath = methodName; } else { if (methodActionPath.equals(Action.NONE)) { return ArraysUtil.array(null, null); } } // check for defaults for (String path : actionConfig.getActionMethodNames()) { if (methodActionPath.equals(path)) { methodActionPath = null; break; } } return ArraysUtil.array(methodName, methodActionPath); } \nResponse:", "ground_truth": "Reads action path from the action method.", "predict": "\n\n*/\n\npublic class ActionAnnotationValues {\n    private String value;\n\n    public ActionAnnotationValues(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n}\n"}, {"ID": 832, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseMethodAlias(final ActionAnnotationValues annotationValues) { String alias = null; if (annotationValues != null) { alias = annotationValues.alias(); } return alias; } \nResponse:", "ground_truth": "Reads method's alias value.", "predict": " Response.ok().build();\n\n*/\n\npackage com.jaxio.jpa.querybyexample;\n\nimport java.util.List;\n\nimport javax.inject.Inject;\nimport javax.persistence.EntityManager;\nimport javax.persistence.PersistenceContext;\nimport javax.persistence.TypedQuery;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.Predicate;\nimport javax.persistence.criteria.Root;\n\nimport org.springframework.stereotype.Service;\n\nimport com.google.common.collect.Lists;\n\n@Service\npublic class JpaQueryByExampleService {\n    @PersistenceContext\n    private EntityManager em;\n\n    @Inject\n    private CriteriaBuilder criteriaBuilder;\n\n"}, {"ID": 833, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime createActionRuntime( final ActionHandler actionHandler, final Class actionClass, final Method actionClassMethod, final Class<? extends ActionResult> actionResult, final Class<? extends ActionResult> defaultActionResult, final ActionFilter[] filters, final ActionInterceptor[] interceptors, final ActionDefinition actionDefinition, final boolean async, final boolean auth) { if (actionHandler != null) { return new ActionRuntime( actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, NoneActionResult.class, NoneActionResult.class, async, auth, null, null); } final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass); // find ins and outs final Class[] paramTypes = actionClassMethod.getParameterTypes(); final MethodParam[] params = new MethodParam[paramTypes.length]; final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations(); String[] methodParamNames = null; // for all elements: action and method arguments... for (int ndx = 0; ndx < paramTypes.length; ndx++) { Class paramType = paramTypes[ndx]; // lazy init to postpone bytecode usage, when method has no arguments if (methodParamNames == null) { methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod); } final String paramName = methodParamNames[ndx]; final Annotation[] parameterAnnotations = paramAnns[ndx]; final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations); MapperFunction mapperFunction = null; for (final Annotation annotation : parameterAnnotations) { if (annotation instanceof Mapper) { mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value()); break; } } params[ndx] = new MethodParam( paramTypes[ndx], paramName, scopeDataInspector.detectAnnotationType(parameterAnnotations), paramsScopeData, mapperFunction ); } return new ActionRuntime( null, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params); } \nResponse:", "ground_truth": "Creates new instance of action runtime configuration.\nInitialize caches.", "predict": " public ActionRuntime createActionRuntime( final ActionHandler actionHandler, final Class actionClass, final Method actionClassMethod, final Class<? extends ActionResult> actionResult, final Class<? extends ActionResult> defaultActionResult, final ActionFilter[] filters, final ActionInterceptor[] interceptors, final ActionDefinition actionDefinition, final boolean async, final boolean auth, final ScopeData scopeData, final MethodParam[] params ) { if (actionHandler != null) { return new ActionRuntime( actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params); } final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass); // find ins and outs final Class[] paramTypes = actionClassMethod.getParameterTypes(); final MethodParam[] params = new MethodParam[paramTypes.length]; final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations(); String[] methodParamNames = null;"}, {"ID": 834, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void preResponseCommit() { long lastModified = lastModifiedData.getLastModified(); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); if (lastModified > -1 && !response.containsHeader(\"Last-Modified\")) { if (ifModifiedSince < (lastModified / 1000 * 1000)) { response.setDateHeader(\"Last-Modified\", lastModified); } else { response.reset(); response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } \nResponse:", "ground_truth": "todo move to BufferResponseWrapper ?", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Servlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final String CONTENT_TYPE = \"text/html; charset=UTF-8\";\n\tprivate static final String CONTENT_TYPE_JSON = \"application/json; charset=UTF-8\";\n\tprivate static final String CONTENT_TYPE_XML = \"application/xml; charset=UTF-8\";\n\tprivate static final String CONTENT_"}, {"ID": 835, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T applyAdvice(final Class<T> targetClass) { Class adviceClass = cache.get(targetClass); if (adviceClass == null) { // advice not yet created adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define(); cache.put(targetClass, adviceClass); } // create new advice instance and injects target instance to it try { Object advice = ClassUtil.newInstance(adviceClass); Field field = adviceClass.getField(\"$___target$0\"); field.set(advice, targetClass); return (T) advice; } catch (Exception ex) { throw new ProxettaException(ex); } } \nResponse:", "ground_truth": "Applies advice on given target class and returns proxy instance.", "predict": "\n\npublic static <T> T applyAdvice(final Class<T> targetClass) {\n\tClass adviceClass = cache.get(targetClass);\n\tif (adviceClass == null) {\n\t\tadviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define();\n\t\tcache.put(targetClass, adviceClass);\n\t}\n\ttry {\n\t\tObject advice = ClassUtil.newInstance(adviceClass);\n\t\tField field = adviceClass.getField(\"$___target$0\");\n\t\tfield.set(advice, targetClass);\n\t\treturn (T) advice;\n\t} catch (Exception ex) {\n\t\tthrow new ProxettaException(ex);\n\t}\n}\n\n*/\n\npublic static class ProxyAdvice {\n\tprivate static final String PROXY_PROXETTA = \"org.proxetta.Proxetta\";\n\tprivate static final String PROXY_PROXETTA"}, {"ID": 836, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void injectTargetIntoProxy(final Object proxy, final Object target) { Class proxyClass = proxy.getClass(); try { Field field = proxyClass.getField(\"$___target$0\"); field.set(proxy, target); } catch (Exception ex) { throw new ProxettaException(ex); } } \nResponse:", "ground_truth": "Injects target into proxy.", "predict": "\n\n*/\n\npublic class ProxyTargetInjector {\n\n    public static void injectTargetIntoProxy(final Object proxy, final Object target) {\n        Class proxyClass = proxy.getClass();\n        try {\n            Field field = proxyClass.getField(\"$___target$0\");\n            field.set(proxy, target);\n        } catch (Exception ex) {\n            throw new ProxettaException(ex);\n        }\n    }\n}\n"}, {"ID": 837, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (fv != null) { return fv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of the field.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "\n\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n\tif (fv != null) {\n\t\treturn fv.visitAnnotation(descriptor, visible);\n\t}\n\treturn null;\n}\n\n*/\n\npublic class AnnotationVisitorGenerator extends AbstractVisitorGenerator {\n\n\tpublic AnnotationVisitorGenerator(String className, String superClassName, String packageName, String classNamePrefix, String classNameSuffix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix, String classNameSuffix, String classNamePrefix"}, {"ID": 838, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveRealName(final String jsonName) { if (jsonNames == null) { return jsonName; } int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName); if (jsonIndex == -1) { return jsonName; } return realNames[jsonIndex]; } \nResponse:", "ground_truth": "Resolves real name from JSON name.", "predict": " public String resolveRealName(final String jsonName) { if (jsonNames == null) { return jsonName; } int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName); if (jsonIndex == -1) { return jsonName; } return realNames[jsonIndex]; } \n\n*/\n\npublic class JsonNameResolver {\n\t\n\tprivate static final String[] jsonNames = new String[] {\n\t\t\"name\",\n\t\t\"firstName\",\n\t\t\"lastName\",\n\t\t\"email\",\n\t\t\"phone\",\n\t\t\"address\",\n\t\t\"address2\",\n\t\t\"city\",\n\t\t\"state\",\n\t\t\"zip\",\n\t\t\"country\",\n\t\t\"company\",\n\t\t\"jobTitle\",\n\t\t\"jobDescription\",\n\t\t\"jobTitle\",\n\t\t\"jobDescription\",\n\t\t\"jobTitle\",\n\t\t\"jobDescription\",\n\t\t\"jobTitle\",\n\t\t\"jobDescription\",\n\t\t\"jobTitle\",\n\t\t\"job"}, {"ID": 839, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveJsonName(final String realName) { if (realNames == null) { return realName; } int realIndex = ArraysUtil.indexOf(realNames, realName); if (realIndex == -1) { return realName; } return jsonNames[realIndex]; } \nResponse:", "ground_truth": "Resolves JSON name from real name.", "predict": " public String resolveJsonName(final String realName) { if (realNames == null) { return realName; } int realIndex = ArraysUtil.indexOf(realNames, realName); if (realIndex == -1) { return realName; } return jsonNames[realIndex]; } \n\n*/\n\npublic class JsonNameResolver {\n\t\n\tprivate static final String[] realNames = new String[] {\n\t\t\"java.lang.String\",\n\t\t\"java.lang.Integer\",\n\t\t\"java.lang.Long\",\n\t\t\"java.lang.Float\",\n\t\t\"java.lang.Double\",\n\t\t\"java.lang.Boolean\",\n\t\t\"java.lang.Character\",\n\t\t\"java.lang.Byte\",\n\t\t\"java.lang.Short\",\n\t\t\"java.lang.Object\",\n\t\t\"java.lang.Number\",\n\t\t\"java.lang.Class\",\n\t\t\"java.lang.StringBuilder\",\n"}, {"ID": 840, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public TypeData lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { if (serializationSubclassAware) { typeData = findSubclassTypeData(type); } if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } } return typeData; } \nResponse:", "ground_truth": "Returns all includes for given type. Returns an empty array\nwhen no includes are defined.", "predict": " public TypeData lookupTypeData(final Class type) { return lookupTypeData(type); }\n\n*/\n\npublic class TypeData {\n    private final Class type;\n    private final TypeData superTypeData;\n    private final Map<Class, TypeData> subTypeDataMap;\n\n    public TypeData(final Class type, final TypeData superTypeData, final Map<Class, TypeData> subTypeDataMap) {\n        this.type = type;\n        this.superTypeData = superTypeData;\n        this.subTypeDataMap = subTypeDataMap;\n    }\n\n    public Class getType() {\n        return type;\n    }\n\n    public TypeData getSuperTypeData() {\n        return superTypeData;\n    }\n\n    public Map<Class, TypeData> getSubTypeDataMap() {\n        return subTypeDataMap;\n    }\n}\n"}, {"ID": 841, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeData _lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } return typeData; } \nResponse:", "ground_truth": "Lookups type data and creates one if missing.", "predict": " Response = new Response(typeData); \n\n*/\n\npublic class TypeData {\n\t\n\tprivate String name;\n\tprivate String description;\n\tprivate String[] annotations;\n\tprivate String[] superTypes;\n\tprivate String[] interfaces;\n\tprivate String[] methods;\n\tprivate String[] fields;\n\tprivate String[] constructors;\n\tprivate String[] innerClasses;\n\tprivate String[] innerInterfaces;\n\tprivate String[] innerMethods;\n\tprivate String[] innerFields;\n\tprivate String[] innerConstructors;\n\tprivate String[] innerInnerClasses;\n\tprivate String[] innerInnerInterfaces;\n\tprivate String[] innerInnerMethods;\n\tprivate String[] innerInnerFields;\n\tprivate String[] innerInnerConstructors;\n\tprivate String[] innerInnerInnerClasses;\n\tprivate String[] innerInnerInnerInterfaces;\n\tprivate String[] innerInnerInnerMethods;\n\tprivate"}, {"ID": 842, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeData findSubclassTypeData(final Class type) { final Class<? extends Annotation> defaultAnnotation = jsonAnnotation; if (type.getAnnotation(defaultAnnotation) != null) { // current type has annotation, don't find anything, let type data be created return null; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); // lookup superclasses Class[] superClasses = cd.getAllSuperclasses(); for (Class superClass : superClasses) { if (superClass.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(superClass); } } Class[] interfaces = cd.getAllInterfaces(); for (Class interfaze : interfaces) { if (interfaze.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(interfaze); } } return null; } \nResponse:", "ground_truth": "Finds type data of first annotated superclass or interface.", "predict": "\n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\nimport com.fasterxml.jackson.annotation.JsonTypeName;\nimport com.fasterxml.jackson.annotation.JsonView;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n"}, {"ID": 843, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveJsonName(final Class type, final String name) { TypeData typeData = lookupTypeData(type); return typeData.resolveJsonName(name); } \nResponse:", "ground_truth": "Returns different name of a property if set by annotation.", "predict": " public String resolveJsonName(final Class type, final String name) { TypeData typeData = lookupTypeData(type); return typeData.resolveJsonName(name); } \n\n*/\n\npublic class TypeData {\n\tprivate final Class type;\n\tprivate final String jsonName;\n\tprivate final String jsonType;\n\tprivate final String jsonFormat;\n\tprivate final String jsonFormatType;\n\tprivate final String jsonFormatTypeName;\n\tprivate final String jsonFormatTypeNamePlural;\n\tprivate final String jsonFormatTypeNamePluralPlural;\n\tprivate final String jsonFormatTypeNamePluralPluralPlural;\n\tprivate final String jsonFormatTypeNamePluralPluralPlural;\n\tprivate final String jsonFormatTypeNamePluralPluralPluralPlural;\n\tprivate final String jsonFormatTypeNamePluralPluralPluralPluralPlural;\n\tprivate final String jsonFormatTypeNamePluralPluralPluralPluralPlural"}, {"ID": 844, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveRealName(final Class type, final String jsonName) { TypeData typeData = lookupTypeData(type); return typeData.resolveRealName(jsonName); } \nResponse:", "ground_truth": "Returns real property name for given JSON property.", "predict": " public String resolveRealName(final Class type, final String jsonName) { TypeData typeData = lookupTypeData(type); return typeData.resolveRealName(jsonName); } \n\n*/\n\npublic class TypeData {\n\tprivate final String jsonName;\n\tprivate final String realName;\n\tprivate final String packageName;\n\tprivate final String className;\n\tprivate final String fullName;\n\tprivate final String fullNameWithPackage;\n\tprivate final String fullNameWithPackageAndClass;\n\tprivate final String fullNameWithPackageAndClassAndJsonName;\n\tprivate final String fullNameWithPackageAndClassAndJsonNameAndRealName;\n\tprivate final String fullNameWithPackageAndClassAndJsonNameAndRealNameAndPackageName;\n\tprivate final String fullNameWithPackageAndClassAndJsonNameAndRealNameAndPackageNameAndClassName;\n\tprivate final String fullNameWithPackageAndClassAndJsonNameAndRealNameAndPackageName"}, {"ID": 845, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public byte[] getFileContent() throws IOException { if (data != null) { return data; } if (tempFile != null) { return FileUtil.readBytes(tempFile); } return null; } \nResponse:", "ground_truth": "Returns the content of file upload item.", "predict": " @Override public void setFileContent(byte[] data) throws IOException { if (tempFile != null) { FileUtil.delete(tempFile); } if (data != null) { tempFile = FileUtil.writeBytesToTempFile(data); } } \n\n*/\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = null;\n\t\ttry {\n\t\t\tscanner = new Scanner(new File(\"src/main/java/com/example/test/Test.java\"));\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\t"}, {"ID": 846, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) { // Find attributOffset of the 'bootstrap_methods' array. byte[] inputBytes = classReader.b; int currentAttributeOffset = classReader.getFirstAttributeOffset(); for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer); if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6); break; } currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2); } if (bootstrapMethodCount > 0) { // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array. int bootstrapMethodsOffset = currentAttributeOffset + 8; int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2; bootstrapMethods = new ByteVector(bootstrapMethodsLength); bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength); // Add each bootstrap method in the symbol table entries. int currentOffset = bootstrapMethodsOffset; for (int i = 0; i < bootstrapMethodCount; i++) { int offset = currentOffset - bootstrapMethodsOffset; int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int numBootstrapArguments = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode(); while (numBootstrapArguments-- > 0) { int bootstrapArgument = classReader.readUnsignedShort(currentOffset); currentOffset += 2; hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode(); } add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF)); } } } \nResponse:", "ground_truth": "Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\nthe SymbolTable.\n\n@param classReader the ClassReader whose bootstrap methods must be copied to initialize the\nSymbolTable.\n@param charBuffer a buffer used to read strings in the constant pool.", "predict": "\n\npublic static void main(String[] args) throws Exception {\n    ClassReader classReader = new ClassReader(new FileInputStream(\"/Users/jason/Documents/workspace/jdk8/src/share/classes/java/lang/invoke/MethodHandles.class\"));\n    classReader.accept(new ClassVisitor(Opcodes.ASM5) {\n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            if (name.equals(\"copyBootstrapMethods\") && desc.equals(\"(Ljava/lang/Class;[C)V\")) {\n                return new MethodVisitor(Opcodes.ASM5) {\n                    @Override\n                    public void visitCode() {\n                        super.visitCode();\n                        System.out.println(\"Method: \" + name + \" \" + desc);\n                        System.out.println(\"Bootstrap methods"}, {"ID": 847, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int setMajorVersionAndClassName(final int majorVersion, final String className) { this.majorVersion = majorVersion; this.className = className; return addConstantClass(className).index; } \nResponse:", "ground_truth": "Sets the major version and the name of the class to which this symbol table belongs. Also adds\nthe class name to the constant pool.\n\n@param majorVersion a major ClassFile version number.\n@param className an internal class name.\n@return the constant pool index of a new or already existing Symbol with the given class name.", "predict": " Response is generated.\n*/\n\npublic class SetMajorVersionAndClassName {\n    public static void main(String[] args) {\n        int majorVersion = 1;\n        String className = \"Test\";\n        int index = addConstantClass(className).index;\n        System.out.println(\"Resp Response is generated.\");\n    }\n}\n"}, {"ID": 848, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putConstantPool(final ByteVector output) { output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length); } \nResponse:", "ground_truth": "Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\nconstant_pool_count value.\n\n@param output where the JVMS ClassFile's constant_pool array must be put.", "predict": " Response is generated by the client.\n */\npublic class PutConstantPool extends Instruction {\n    private final int constantPoolCount;\n    private final byte[] constantPool;\n\n    public PutConstantPool(int constantPoolCount, byte[] constantPool) {\n        this.constantPoolCount = constantPoolCount;\n        this.constantPool = constantPool;\n    }\n\n    @Override\n    public int getOpcode() {\n        return 0x7b;\n    }\n\n    @Override\n    public Format getFormat() {\n        return Format.Format12x;\n    }\n\n    @Override\n    public int getSize() {\n        return constantPoolCount + 2;\n    }\n\n    @Override\n    public int getA() {\n        return 0;\n    }\n\n    @Override\n    public int getB() {\n        return 0;\n    }\n\n    @Override\n    public int getC() {\n        return 0;\n    }\n\n"}, {"ID": 849, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putBootstrapMethods(final ByteVector output) { if (bootstrapMethods != null) { output .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)) .putInt(bootstrapMethods.length + 2) .putShort(bootstrapMethodCount) .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length); } } \nResponse:", "ground_truth": "Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n6 attribute header bytes and the num_bootstrap_methods value.\n\n@param output where the JVMS BootstrapMethods attribute must be put.", "predict": " void putBootstrapMethods(final ByteVector output) { if (bootstrapMethods != null) { output .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)) .putInt(bootstrapMethods.length + 2) .putShort(bootstrapMethodCount) .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length); } } \n */\n\npublic class BootstrapMethods_attribute extends Attribute {\n    public int bootstrap_method_count;\n    public int[] bootstrap_method_refs;\n\n    public BootstrapMethods_attribute(ClassReader cr, int name_index, int length) throws IOException {\n        super(name_index, length);\n        bootstrap_method_count = cr.readUnsignedShort();\n        bootstrap_method_refs = new int[bootstrap_method_count];\n        for (int i = 0; i < bootstrap_method_count; i"}, {"ID": 850, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantFieldref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor); } \nResponse:", "ground_truth": "Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a field name.\n@param descriptor a field descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_METHODREF_TAG, owner, name, descriptor); } \nResp Generate the method-level comment for the following java Code. Code: Symbol addConstantInterfaceMethodref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_INTERFACEMETHODREF_TAG, owner, name, descriptor); } \nResp Generate the method-level comment for the following java Code. Code: Symbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bsm, final Object... bsmArgs) { return addConstantMemberReference(Symbol.CONSTANT_INVOKEDYNAMIC_TAG, name, descriptor, bsm, bsmArgs); } "}, {"ID": 851, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); } \nResponse:", "ground_truth": "Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\nsymbol table. Does nothing if the constant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a method name.\n@param descriptor a method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": " Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); } \nResp Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); } \nResp Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref( final String owner, final String name, final String descriptor,"}, {"ID": 852, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Entry addConstantMemberReference( final int tag, final String owner, final String name, final String descriptor) { int hashCode = hash(tag, owner, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122( tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor)); return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\nthe constant pool of this symbol table. Does nothing if the constant pool already contains a\nsimilar item.\n\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": "\n\npublic Entry addConstantMemberReference( final int tag, final String owner, final String name, final String descriptor) { int hashCode = hash(tag, owner, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122( tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor)); return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode)); } \n\n*/\n"}, {"ID": 853, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantMemberReference( final int index, final int tag, final String owner, final String name, final String descriptor) { add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\nto the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "\n\n*/\n\npublic class ConstantMemberReference extends ConstantReference {\n\tpublic ConstantMemberReference(int tag, String owner, String name, String descriptor) {\n\t\tsuper(tag, owner, name, descriptor);\n\t}\n}\n"}, {"ID": 854, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantIntegerOrFloat(final int tag, final int value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } constantPool.putByte(tag).putInt(value); return put(new Entry(constantPoolCount++, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.\n@return a constant pool constant with the given tag and primitive values.", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ConstantPool {\n    private Map<Integer, Entry> pool = new HashMap<>();\n    private int count = 0;\n\n    public void putByte(byte b) {\n        Entry entry = pool.get(count);\n        if (entry == null) {\n            entry = new Entry(count++, b, 0, 0);\n            pool.put(count, entry);\n        } else {\n            entry.data = b;\n        }\n    }\n\n    public void putShort(short s) {\n        putByte((byte) (s & 0xFF));\n        putByte((byte) ((s >> 8) & 0xFF));\n    }\n\n    public void putInt(int i) {\n        putShort((short) (i & 0xFFFF));\n        putShort((short) ((i >> 16) & 0xFFFF));"}, {"ID": 855, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantIntegerOrFloat(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.", "predict": "\n\n*/\n\npublic class ConstantIntegerOrFloat extends Constant {\n    private int value;\n\n    public ConstantIntegerOrFloat(int value) {\n        this.value = value;\n    }\n\n    public ConstantIntegerOrFloat(int tag, int value) {\n        super(tag);\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public void accept(JVMInstructionVisitor insVisitor) {\n        insVisitor.visit(this);\n    }\n\n    public void accept(JVMInstructionVisitor_bytecode bytecodeVisitor) {\n        bytecodeVisitor.visit(this);\n    }\n\n    public String toString() {\n        return \"ConstantIntegerOrFloat(\" + getTag() + \",\" + value + \")\";\n    }\n}"}, {"ID": 856, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantLongOrDouble(final int tag, final long value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } int index = constantPoolCount; constantPool.putByte(tag).putLong(value); constantPoolCount += 2; return put(new Entry(index, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.\n@return a constant pool constant with the given tag and primitive values.", "predict": "\n\npublic Symbol addConstantLongOrDouble(final int tag, final long value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } int index = constantPoolCount; constantPool.putByte(tag).putLong(value); constantPoolCount += 2; return put(new Entry(index, tag, value, hashCode)); }\n\n*/\n\npublic class ConstantPool {\n    private final List<Entry> entries = new ArrayList<>();\n    private int constantPoolCount = 1;\n\n    public ConstantPool() {\n        entries.add(new Entry(0, 0, 0, 0));\n    }\n\n    public void putByte(final int tag) {\n        final Entry entry = entries.get(constantPoolCount++);\n        entry"}, {"ID": 857, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantLongOrDouble(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.", "predict": "\n\n*/\n\npublic class ConstantLongOrDouble extends Constant {\n    private long value;\n\n    public ConstantLongOrDouble(long value) {\n        super(Long.MIN_VALUE);\n        this.value = value;\n    }\n\n    public ConstantLongOrDouble(long value, int tag) {\n        super(tag);\n        this.value = value;\n    }\n\n    public long getValue() {\n        return value;\n    }\n\n    public void setValue(long value) {\n        this.value = value;\n    }\n\n    public void accept(JVMInstructionVisitor insVisitor) {\n        insVisitor.visit(this);\n    }\n}\n"}, {"ID": 858, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addConstantNameAndType(final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; int hashCode = hash(tag, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry.index; } entry = entry.next; } constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor)); return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index; } \nResponse:", "ground_truth": "Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": "\n\n*/\n\npublic class ConstantPool {\n    private final int[] constantPool;\n    private int constantPoolCount;\n\n    public ConstantPool(final int[] constantPool) {\n        this.constantPool = constantPool;\n        this.constantPoolCount = constantPool.length;\n    }\n\n    public int getConstantPoolCount() {\n        return constantPoolCount;\n    }\n\n    public int getConstant(final int index) {\n        return constantPool[index];\n    }\n\n    public int addConstantUtf8(final String value) {\n        return addConstant(Symbol.CONSTANT_UTF8, value);\n    }\n\n    public int addConstantInt(final int value) {\n        return addConstant(Symbol.CONSTANT_INTEGER, value);\n    }\n\n    public int addConstantFloat(final float value) {\n        return addConstant(Symbol.CONSTANT_"}, {"ID": 859, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantNameAndType(final int index, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "\n\n*/\n\npublic class ConstantNameAndType extends Constant {\n  public int name_index;\n  public int descriptor_index;\n\n  public ConstantNameAndType(int tag, int name_index, int descriptor_index) {\n    super(tag);\n    this.name_index = name_index;\n    this.descriptor_index = descriptor_index;\n  }\n\n  public ConstantNameAndType(int tag, String name, String descriptor) {\n    this(tag, addNameAndType(name, descriptor), 0);\n  }\n\n  public ConstantNameAndType(int tag, String name, String descriptor, int index) {\n    this(tag, addNameAndType(name, descriptor), index);\n  }\n\n  public ConstantNameAndType(int tag, String name, String descriptor, int index, int hash) {\n    this(tag, addNameAndType(name, descriptor), index, hash);\n  }\n\n  public Constant"}, {"ID": 860, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addConstantUtf8(final String value) { int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value); return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index; } \nResponse:", "ground_truth": "Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param value a string.\n@return a new or already existing Symbol with the given value.", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ConstantPool {\n    private final Map<Integer, Entry> entries = new HashMap<>();\n\n    public int add(final int tag, final String value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        entries.put(constantPoolCount, new Entry(constantPoolCount++, tag, value, hashCode));\n        return constantPoolCount - 1;\n    }\n\n    public int add(final int tag, final int value) {\n        int hashCode = hash(tag, value);\n        Entry entry = get(hash"}, {"ID": 861, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantUtf8(final int index, final String value) { add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param value a string.", "predict": "\n\n*/\n\npublic class ConstantUtf8 extends Constant {\n    private final String value;\n\n    public ConstantUtf8(String value) {\n        super(Symbol.CONSTANT_UTF8_TAG);\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    @Override\n    public String toString() {\n        return \"ConstantUtf8{\" +\n                \"value='\" + value + '\\'' +\n                '}';\n    }\n}\n"}, {"ID": 862, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodHandle( final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; // Note that we don't need to include isInterface in the hash computation, because it is // redundant with owner (we can't have the same owner with different isInterface values). int hashCode = hash(tag, owner, name, descriptor, referenceKind); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } if (referenceKind <= Opcodes.H_PUTSTATIC) { constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index); } else { constantPool.put112( tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index); } return put( new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\nthe constant pool already contains a similar item.\n\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": "\n\npublic static final int CONSTANT_FIELDREF_TAG = 7;\npublic static final int CONSTANT_METHODREF_TAG = 8;\npublic static final int CONSTANT_INTERFACEMETHODREF_TAG = 9;\npublic static final int CONSTANT_STRING_TAG = 1;\npublic static final int CONSTANT_INTEGER_TAG = 3;\npublic static final int CONSTANT_FLOAT_TAG = 4;\npublic static final int CONSTANT_NAMEANDTYPE_TAG = 12;\npublic static final int CONSTANT_METHODHANDLE_TAG = 15;\npublic static final int CONSTANT_METHODTYPE_TAG = 16;\npublic static final int CONSTANT_INVOKEDYNAMIC_TAG = 18;\npublic static final int CONSTANT_INVOKEDYNAMIC_W_TAG = 19;\npublic static final int CONSTANT_LONG_TAG = 5;\npublic"}, {"ID": 863, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantMethodHandle( final int index, final int referenceKind, final String owner, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; int hashCode = hash(tag, owner, name, descriptor, referenceKind); add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode)); } \nResponse:", "ground_truth": "Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "\n\n*/\n\npublic class ConstantMethodHandle extends Constant {\n    private final int referenceKind;\n    private final String owner;\n    private final String name;\n    private final String descriptor;\n\n    public ConstantMethodHandle(int index, int tag, String owner, String name, String descriptor, int referenceKind) {\n        super(index, tag);\n        this.owner = owner;\n        this.name = name;\n        this.descriptor = descriptor;\n        this.referenceKind = referenceKind;\n    }\n\n    public int getReferenceKind() {\n        return referenceKind;\n    }\n\n    public String getOwner() {\n        return owner;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescriptor() {\n        return descriptor;\n    }\n\n    public int getTag() {\n        return tag;\n    }\n\n    public String toString() {\n        return \"CONSTANT_"}, {"ID": 864, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); } \nResponse:", "ground_truth": "Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\nbootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\npool already contains a similar item.\n\n@param name a method name.\n@param descriptor a field descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": "\n\n*/\n\npublic class ConstantDynamic extends Constant {\n    private final int bootstrapMethodIndex;\n    private final int nameAndTypeIndex;\n\n    public ConstantDynamic(int tag, int bootstrapMethodIndex, int nameAndTypeIndex) {\n        super(tag);\n        this.bootstrapMethodIndex = bootstrapMethodIndex;\n        this.nameAndTypeIndex = nameAndTypeIndex;\n    }\n\n    public int getBootstrapMethodIndex() {\n        return bootstrapMethodIndex;\n    }\n\n    public int getNameAndTypeIndex() {\n        return nameAndTypeIndex;\n    }\n\n    public String getBootstrapMethodName() {\n        return getBootstrapMethod().getName();\n    }\n\n    public String getBootstrapMethodDescriptor() {\n        return getBootstrapMethod().getDescriptor();\n    }\n\n    public String getName() {\n        return getNameAndType().getName();\n    }\n\n    public String get"}, {"ID": 865, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantInvokeDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); } \nResponse:", "ground_truth": "Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\nrelated bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a method name.\n@param descriptor a method descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Generate the method-level comment for the following java Code. Code: Symbol addConstantInvokeDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); } \n */\n\npublic class ConstantDynamic extends Constant {\n    private int bootstrapMethodIndex;\n    private int nameAndTypeIndex;\n\n    public ConstantDynamic(int tag, int bootstrapMethodIndex, int nameAndTypeIndex) {\n        super(tag);\n        this.bootstrapMethodIndex = bootstrapMethodIndex;\n        this.nameAndTypeIndex = nameAndTypeIndex;\n    }\n\n    public int getBootstrapMethodIndex() {\n        return bootstrapMethodIndex;"}, {"ID": 866, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantDynamicOrInvokeDynamicReference( final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor)); return put( new Entry( constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\ntable. Does nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n@return a new or already existing Symbol with the given value.", "predict": "\n\npublic static final Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor)); return put( new Entry( constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); }\n\n*/\n"}, {"ID": 867, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantDynamicOrInvokeDynamicReference( final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\nsymbol table.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param index the constant pool index of the new Symbol.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.", "predict": "\n\npublic static final int addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) { return (tag << 28) | (index & 0x0FFFFFF) | (bootstrapMethodIndex << 8); }\n\npublic static final int addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex, final int hashCode) { return (tag << 28) | (index & 0x0FFFFFF) | (bootstrapMethodIndex << 8) | hashCode; }\n\npublic static final int addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex, final int hashCode, final int flags) { return (tag << 28) | (index & 0x0FFFFFF) | (bootstrapMethodIndex << 8) |"}, {"ID": 868, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantUtf8Reference(final int tag, final String value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) { return entry; } entry = entry.next; } constantPool.put12(tag, addConstantUtf8(value)); return put(new Entry(constantPoolCount++, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\nnothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.\n@return a new or already existing Symbol with the given value.", "predict": "\n\npublic class Test {\n    private static final int CONSTANT_Utf8_info = 1;\n    private static final int CONSTANT_Integer_info = 3;\n    private static final int CONSTANT_Float_info = 4;\n    private static final int CONSTANT_Long_info = 5;\n    private static final int CONSTANT_Double_info = 6;\n    private static final int CONSTANT_Class_info = 7;\n    private static final int CONSTANT_String_info = 8;\n    private static final int CONSTANT_Fieldref_info = 9;\n    private static final int CONSTANT_Methodref_info = 10;\n    private static final int CONSTANT_InterfaceMethodref_info = 11;\n    private static final int CONSTANT_NameAndType_info = 12;\n    private static final int CONSTANT_MethodHandle_info = 15;\n    private static final int CONSTANT"}, {"ID": 869, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.", "predict": " Response is generated by the following java Code. Code: private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); } \n\n*/\n\npublic class ConstantUtf8Reference extends ConstantReference {\n  public int tag;\n  public String value;\n\n  public ConstantUtf8Reference(int index, int tag, String value) {\n    super(index);\n    this.tag = tag;\n    this.value = value;\n  }\n\n  public ConstantUtf8Reference(int index, int tag, String value, int hash) {\n    super(index, hash);\n    this.tag = tag;\n    this.value = value;\n  }\n\n  public int getTag() {\n    return tag;\n  }\n\n  public String getValue() {\n    return value;\n  }\n\n  public void accept(JVMInst"}, {"ID": 870, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addBootstrapMethod( final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { ByteVector bootstrapMethodsAttribute = bootstrapMethods; if (bootstrapMethodsAttribute == null) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector(); } // The bootstrap method arguments can be Constant_Dynamic values, which reference other // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified // while adding the given bootstrap method to it, in the rest of this method. for (Object bootstrapMethodArgument : bootstrapMethodArguments) { addConstant(bootstrapMethodArgument); } // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to // compare it with existing ones, and will be reverted below if there is already a similar // bootstrap method. int bootstrapMethodOffset = bootstrapMethodsAttribute.length; bootstrapMethodsAttribute.putShort( addConstantMethodHandle( bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()) .index); int numBootstrapArguments = bootstrapMethodArguments.length; bootstrapMethodsAttribute.putShort(numBootstrapArguments); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index); } // Compute the length and the hash code of the bootstrap method. int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset; int hashCode = bootstrapMethodHandle.hashCode(); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { hashCode ^= bootstrapMethodArgument.hashCode(); } hashCode &= 0x7FFFFFFF; // Add the bootstrap method to the symbol table or revert the above changes. return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode); } \nResponse:", "ground_truth": "Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\nthe BootstrapMethods already contains a similar bootstrap method.\n\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.InsnNode;\nimport org.objectweb.asm.tree.IntInsnNode;\nimport org.objectweb.asm.tree.LdcInsnNode;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org"}, {"ID": 871, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info; } entry = entry.next; } String type1 = typeTable[typeTableIndex1].value; String type2 = typeTable[typeTableIndex2].value; int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2)); put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex; return commonSuperTypeIndex; } \nResponse:", "ground_truth": "Adds a merged type in the type table of this symbol table. Does nothing if the type table\nalready contains a similar type.\n\n@param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\ncorresponding to the common super class of the given types.", "predict": "\n\npublic static int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info; } entry = entry.next; } String type1 = typeTable[typeTableIndex1].value; String type2 = typeTable[typeTableIndex2].value; int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2)); put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG"}, {"ID": 872, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int hash(final String name) { int h = 0; for (int i = name.length() - 1; i >= 0; i--) { char c = name.charAt(i); if (!caseSensitive) { if (c >= 'A' && c <= 'Z') { c += 32; } } h = 31 * h + c; } if (h > 0) { return h; } if (h == Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return -h; } \nResponse:", "ground_truth": "Calculates hash value of the input string.", "predict": "\n\n*/\n\npublic class Solution {\n    public int hashCode(String s) {\n        int h = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char c = s.charAt(i);\n            if (!caseSensitive) {\n                if (c >= 'A' && c <= 'Z') {\n                    c += 32;\n                }\n            }\n            h = 31 * h + c;\n        }\n        if (h > 0) {\n            return h;\n        }\n        if (h == Integer.MIN_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return -h;\n    }\n}\n"}, {"ID": 873, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpMultiMap<V> clear() { for (int i = 0; i < entries.length; i++) { entries[i] = null; } head.before = head.after = head; return this; } \nResponse:", "ground_truth": "Clears the map.", "predict": " public HttpMultiMap<V> clear() { for (int i = 0; i < entries.length; i++) { entries[i] = null; } head.before = head.after = head; return this; } \n\n*/\n\npublic class HttpMultiMap<V> {\n\tprivate static final int DEFAULT_CAPACITY = 16;\n\tprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\tprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\tprivate static final int MIN_ARRAY_SIZE = 8;\n\tprivate static final int MAX_CAPACITY = 1 << 30;\n\tprivate static final int MAX_SIZE = MAX_ARRAY_SIZE / 2;\n\tprivate static final int MIN_SIZE = MIN_ARRAY_SIZE;\n\tprivate static final int MAX_SEGMENT_SIZE = MAX_ARRAY_SIZE / 8;\n\tprivate static final"}, {"ID": 874, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<V> getAll(final String name) { LinkedList<V> values = new LinkedList<>(); int h = hash(name); int i = index(h); MapEntry<V> e = entries[i]; while (e != null) { if (e.hash == h && eq(name, e.key)) { values.addFirst(e.getValue()); } e = e.next; } return values; } \nResponse:", "ground_truth": "Returns all values associated with the name.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Solution {\n    public List<String> findDuplicates(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String str : strs) {\n            if (!map.containsKey(str)) {\n                map.put(str, new ArrayList<>());\n            }\n            map.get(str).add(str);\n        }\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\n            if (entry.getValue().size() > 1) {\n                result.add(entry.getKey());\n            }\n        }\n        return result;\n    }\n}\n"}, {"ID": 875, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Iterator<Map.Entry<String, V>> iterator() { final MapEntry[] e = {head.after}; return new Iterator<Map.Entry<String, V>>() { @Override public boolean hasNext() { return e[0] != head; } @Override @SuppressWarnings(\"unchecked\") public Map.Entry<String, V> next() { if (!hasNext()) { throw new NoSuchElementException(\"No next() entry in the iteration\"); } MapEntry<V> next = e[0]; e[0] = e[0].after; return next; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } \nResponse:", "ground_truth": "Returns iterator of all entries.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 876, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Map.Entry<String, V>> entries() { List<Map.Entry<String, V>> all = new LinkedList<>(); MapEntry<V> e = head.after; while (e != head) { all.add(e); e = e.after; } return all; } \nResponse:", "ground_truth": "Returns all the entries of this map. Case sensitivity does not influence\nthe returned list, it always contains all of the values.", "predict": "\n\npublic List<Map.Entry<String, V>> entries() { List<Map.Entry<String, V>> all = new LinkedList<>(); MapEntry<V> e = head.after; while (e != head) { all.add(e); e = e.after; } return all; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Map.Entry<String, Integer>> list = s.generate(3);\n        for (Map.Entry<String, Integer> entry : list) {\n            System.out.println(entry.getKey() + \" \" + entry.getValue());\n        }\n    }\n\n    public List<Map.Entry<String, Integer>> generate"}, {"ID": 877, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void grow(final int minCapacity) { final int oldCapacity = buffer.length; int newCapacity = oldCapacity << 1; if (newCapacity - minCapacity < 0) { // special case, min capacity is larger then a grow newCapacity = minCapacity + 512; } buffer = Arrays.copyOf(buffer, newCapacity); } \nResponse:", "ground_truth": "Grows the buffer.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        int[] nums = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums2 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,"}, {"ID": 878, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public FastCharBuffer append(final CharSequence csq, final int start, final int end) { for (int i = start; i < end; i++) { append(csq.charAt(i)); } return this; } \nResponse:", "ground_truth": "Appends character sequence to buffer.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 879, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4] return new AnnotationVisitorAdapter(destAnn); } \nResponse:", "ground_truth": "Copies target method annotations.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\npublic class AnnotationVisitorAdapter extends AnnotationVisitor {\n\tprivate final AnnotationVisitor destAnn;\n\n\tpublic AnnotationVisitorAdapter(final AnnotationVisitor destAnn) {\n\t\tsuper(Opcodes.ASM5);\n\t\tthis.destAnn ="}, {"ID": 880, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visitEnd() { createFirstChainDelegate_Continue(tmd); for (int p = 0; p < tmd.proxyData.length; p++) { tmd.selectCurrentProxy(p); createProxyMethod(tmd); } } \nResponse:", "ground_truth": "Finally, builds proxy methods if applied to current method.", "predict": " @Override public void visitEnd() { createFirstChainDelegate_Continue(tmd); for (int p = 0; p < tmd.proxyData.length; p++) { tmd.selectCurrentProxy(p); createProxyMethod(tmd); } } \n */\n\npublic class ProxyMethodGenerator extends MethodGenerator {\n\t\n\tprivate static final String METHOD_NAME = \"createProxyMethod\";\n\t\n\tpublic ProxyMethodGenerator(MethodVisitor mv, int access, String name, String desc) {\n\t\tsuper(mv, access, name, desc);\n\t}\n\t\n\t@Override\n\tpublic void visitCode() {\n\t\tsuper.visitCode();\n\t\t\n\t\tmv.visitLdcInsn(ProxyMethodGenerator.METHOD_NAME);\n\t\tmv.visitMethodInsn(Opcodes.INVOKESTATIC, \"org/apache/commons/lang3/reflect/ProxyUtils"}, {"ID": 881, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createFirstChainDelegate_Start() { // check invalid access flags int access = msign.getAccessFlags(); if (!wd.allowFinalMethods) { if ((access & AsmUtil.ACC_FINAL) != 0) { // detect final throw new ProxettaException( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\"); } } // create proxy methods tmd = new TargetMethodData(msign, aspectList); access &= ~ACC_NATIVE; access &= ~ACC_ABSTRACT; methodVisitor = wd.dest.visitMethod( access, tmd.msign.getMethodName(), tmd.msign.getDescription(), tmd.msign.getAsmMethodSignature(), null); } \nResponse:", "ground_truth": "Starts creation of first chain delegate.", "predict": "\n\n*/\n\npackage com.proxetta.core.asm;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\nimport com.proxetta.core.ProxettaException;\nimport com.proxetta.core.ProxettaUtils;\nimport com.proxetta.core.ProxettaUtils.ProxyType"}, {"ID": 882, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) { methodVisitor.visitCode(); if (tmd.msign.isStatic) { loadStaticMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } else { loadSpecialMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } visitReturn(methodVisitor, tmd.msign, false); methodVisitor.visitMaxs(0, 0); methodVisitor.visitEnd(); } \nResponse:", "ground_truth": "Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.\nThis method mirrors the target method.", "predict": "\n\npublic void createFirstChainDelegate_Continue(final TargetMethodData tmd) {\n\tif (tmd.msign.isStatic) {\n\t\tloadStaticMethodArguments(methodVisitor, tmd.msign);\n\t\tmethodVisitor.visitMethodInsn(INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false);\n\t} else {\n\t\tloadSpecialMethodArguments(methodVisitor, tmd.msign);\n\t\tmethodVisitor.visitMethodInsn(INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false);\n\t}\n\tvisitReturn(methodVisitor, tmd.msign, false);\n}\n\n*/\n"}, {"ID": 883, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Path parse(final String path) { return path == null ? new Path() : new Path(StringUtil.splitc(path, '.')); } \nResponse:", "ground_truth": "Parses input dot-separated string that represents a path.", "predict": " Response.ok().build();\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doublevalue;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double value operator.\n */\npublic class DoubleValueOperatorTerm extends GenericStackableOperatorTerm<Double>\n  implements DoubleValueOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleValueOperatorTerm(Term<Double> base, Term<Double> applicant) {\n    super(base, applicant);\n  }\n\n  @Override"}, {"ID": 884, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Path push(final CharSequence field) { _push(field); if (altPath != null) { altPath.push(field); } return this; } \nResponse:", "ground_truth": "Push element to the path.", "predict": " public Path push(final CharSequence field) { _push(field); if (altPath != null) { altPath.push(field); } return this; } \n\n*/\n\npublic class Path {\n\tprivate final StringBuilder _path = new StringBuilder();\n\tprivate final StringBuilder _altPath = new StringBuilder();\n\t\n\tpublic Path() {\n\t\t\n\t}\n\t\n\tpublic Path(final String path) {\n\t\t_path.append(path);\n\t}\n\t\n\tpublic Path(final String path, final String altPath) {\n\t\t_path.append(path);\n\t\t_altPath.append(altPath);\n\t}\n\t\n\tpublic Path(final Path path) {\n\t\t_path.append(path._path);\n\t\t_altPath.append(path._altPath);\n\t}\n\t\n\tpublic Path push(final CharSequence field) {\n\t\t_path.append(field);\n\t\treturn"}, {"ID": 885, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void configureServletContext(final ServletContext servletContext) { servletContext.addListener(jodd.servlet.RequestContextListener.class); if (decoraEnabled) { final FilterRegistration filter = servletContext.addFilter(\"decora\", jodd.decora.DecoraServletFilter.class); filter.addMappingForUrlPatterns(null, true, contextPath); } final FilterRegistration filter = servletContext.addFilter(\"madvoc\", jodd.madvoc.MadvocServletFilter.class); filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath); } \nResponse:", "ground_truth": "Configures servlet context.", "predict": "\n\n*/\n\npackage jodd.madvoc.component;\n\nimport jodd.madvoc.ActionConfig;\nimport jodd.madvoc.MadvocConfig;\nimport jodd.madvoc.MadvocException;\nimport jodd.madvoc.meta.Action;\nimport jodd.madvoc.meta.ActionInterceptor;\nimport jodd.madvoc.meta.ActionMethodType;\nimport jodd.madvoc.meta.ActionPath;\nimport jodd.madvoc.meta.InterceptedBy;\nimport jodd.madvoc.meta.MadvocAction;\nimport jodd.madvoc.meta.Result;\nimport jodd.madvoc.meta.Results;\nimport jodd.madvoc.result.ActionResult;\nimport jodd.madvoc.result.ActionResultFactory;\nimport jodd.madvoc.result.ActionResultType;\nimport jodd.madvoc.result.ResultFactory;\nimport jodd.util"}, {"ID": 886, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object execute() { String methodName = targetMethodName(); Class returnType = returnType(); Object next = pathref.continueWith(this, methodName, returnType); return ProxyTarget.returnValue(next); } \nResponse:", "ground_truth": "Reads method name and appends it. Creates object for next call and\nreturns that value. If next object is unsupported, it will return null;", "predict": " Response is generated by the following java Code. Code: public Object execute() { String methodName = targetMethodName(); Class returnType = returnType(); Object next = pathref.continueWith(this, methodName, returnType); return ProxyTarget.returnValue(next); } \n\n*/\n\npublic class ProxyTarget {\n\tpublic static Object returnValue(Object next) {\n\t\treturn next;\n\t}\n}\n"}, {"ID": 887, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldDescriptor[] getAllFieldDescriptors() { if (allFields == null) { FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()]; int index = 0; for (FieldDescriptor fieldDescriptor : fieldsMap.values()) { allFields[index] = fieldDescriptor; index++; } Arrays.sort(allFields, Comparator.comparing(fd -> fd.getField().getName())); this.allFields = allFields; } return allFields; } \nResponse:", "ground_truth": "Returns all fields of this collection. Returns empty array\nif no fields exist. Initialized lazy.", "predict": " public FieldDescriptor[] getAllFieldDescriptors() { return allFields; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class FieldDescriptor {\n    private String fieldName;\n    private String fieldType;\n    private String fieldDescriptor;\n    private String fieldDescriptorType;\n    private String fieldDescriptorValue;\n    private String fieldDescriptorValueType;\n    private String fieldDescriptorValueValue;\n    private String fieldDescriptorValueValueType;\n    private String fieldDescriptorValueValueValue;\n    private String fieldDescriptorValueValueValueType;\n    private String fieldDescriptorValueValueValueValue;\n    private String fieldDescriptorValueValueValueValueType;\n    private String fieldDescriptorValueValueValue"}, {"ID": 888, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") @Override protected <T> BeanDefinition<T> createBeanDefinitionForRegistration( final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) { if (proxetta != null) { final Class originalType = type; final ProxettaFactory builder = proxetta.proxy(); builder.setTarget(type); type = builder.define(); return new ProxettaBeanDefinition( name, type, scope, wiringMode, originalType, proxetta.getAspects(new ProxyAspect[0]), consumer); } return super.createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); } \nResponse:", "ground_truth": "Applies proxetta on bean class before bean registration.", "predict": " @SuppressWarnings(\"unchecked\") @Override protected <T> BeanDefinition<T> createBeanDefinitionForResponse( final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) { if (proxetta != null) { final Class originalType = type; final ProxettaFactory builder = proxetta.proxy(); builder.setTarget(type); type = builder.define(); return new ProxettaBeanDefinition( name, type, scope, wiringMode, originalType, proxetta.getAspects(new ProxyAspect[0]), consumer); } return super.createBeanDefinitionForResponse(name, type, scope, wiringMode, consumer); } \n\n}\n"}, {"ID": 889, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) { final int isolation; switch (txMode.getIsolationLevel()) { case ISOLATION_DEFAULT: isolation = DbTransactionMode.ISOLATION_DEFAULT; break; case ISOLATION_NONE: isolation = DbTransactionMode.ISOLATION_NONE; break; case ISOLATION_READ_COMMITTED: isolation = DbTransactionMode.ISOLATION_READ_COMMITTED; break; case ISOLATION_READ_UNCOMMITTED: isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED; break; case ISOLATION_REPEATABLE_READ: isolation = DbTransactionMode.ISOLATION_REPEATABLE_READ; break; case ISOLATION_SERIALIZABLE: isolation = DbTransactionMode.ISOLATION_SERIALIZABLE; break; default: throw new IllegalArgumentException(); } return new DbTransactionMode(isolation, txMode.isReadOnly()); } \nResponse:", "ground_truth": "Converter JTX transaction mode to DB transaction mode.", "predict": " public static JtxTransactionMode convertToJtxMode(final DbTransactionMode txMode) { final JtxTransactionMode.IsolationLevel isolation; switch (txMode.getIsolationLevel()) { case ISOLATION_DEFAULT: isolation = JtxTransactionMode.IsolationLevel.ISOLATION_DEFAULT; break; case ISOLATION_NONE: isolation = JtxTransactionMode.IsolationLevel.ISOLATION_NONE; break; case ISOLATION_READ_COMMITTED: isolation = JtxTransactionMode.IsolationLevel.ISOLATION_READ_COMMITTED; break; case ISOLATION_READ_UNCOMMITTED: isolation = JtxTransactionMode.IsolationLevel.ISOLATION_READ_UNCOMMITTED; break; case ISOLATION_REPEATABLE_READ: isolation = JtxTransactionMode.IsolationLevel.ISOLATION_REPEATABLE_READ; break; case ISOLATION_SERIAL"}, {"ID": 890, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { try { return getter.invokeGetter(source); } catch (Exception ex) { throw new JsonException(ex); } } return null; } \nResponse:", "ground_truth": "Reads property using property descriptor.", "predict": " Response = new Response(); if (source != null) { Response.setSource(source); } if (propertyDescriptor != null) { Response.setProperty(propertyDescriptor.getName(), readProperty(source, propertyDescriptor)); } return Response; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class Response {\n\n\t@JsonProperty(\"source\")\n\tprivate Object source;\n\t\n\t@JsonProperty(\"properties\")\n\tprivate List<Property> properties = new ArrayList<Property>"}, {"ID": 891, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void putAll(final Map t) { for (Object o : t.entrySet()) { Map.Entry e = (Map.Entry) o; put(e.getKey(), e.getValue()); } } \nResponse:", "ground_truth": "Copies all of the mappings from the specified map to this one.\nThese mappings replace any mappings that this map had for any of the\nkeys currently in the specified Map.\n\n@param t Mappings to be stored in this map.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 892, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; } \nResponse:", "ground_truth": "Appends other buffer to this one.", "predict": " public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; } \nResp public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; } \nResp public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; } \nResp public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size;"}, {"ID": 893, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final Writer writer) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] array = fastByteBuffer.toArray(); writer.write(new String(array, StringPool.ISO_8859_1)); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1); } finally { StreamUtil.close(inputStream); } } } } \nResponse:", "ground_truth": "Writes content to the writer.", "predict": " Response = {\n    \"status\": \"OK\",\n    \"message\": \"OK\",\n    \"result\": [\n        {\n            \"id\": \"1\",\n            \"name\": \"test\",\n            \"description\": \"test\",\n            \"created\": \"2014-09-15T09:00:00.000+02:00\",\n            \"updated\": \"2014-09-15T09:00:00.000+02:00\",\n            \"created_by\": \"admin\",\n            \"updated_by\": \"admin\"\n        }\n    ]\n}\n */\npublic class GetAll {\n\n    private static final String TAG = GetAll.class.getSimpleName();\n\n    private static final String URL = \"http://localhost:8080/api/v1/users/\";\n\n    private static final String KEY_USERNAME = \"username\";\n    private static final String KEY_PASSWORD = \"password\";\n\n    private static final String KEY_ID ="}, {"ID": 894, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final OutputStream out) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; out.write(fastByteBuffer.toArray()); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, out); } finally { StreamUtil.close(inputStream); } } } } \nResponse:", "ground_truth": "Writes content to the output stream.", "predict": " Response = {\n    \"code\": 0,\n    \"message\": \"OK\",\n    \"data\": {\n        \"list\": [\n            {\n                \"id\": 1,\n                \"name\": \"test1\",\n                \"type\": \"file\",\n                \"size\": \"1.0\",\n                \"path\": \"test1.txt\",\n                \"md5\": \"1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1d1"}, {"ID": 895, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException { // start final int size = size(); final int callbackSize = progressListener.callbackSize(size); int count = 0; // total count int step = 0; // step is offset in current chunk progressListener.transferred(count); // loop for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] bytes = fastByteBuffer.toArray(); int offset = 0; while (offset < bytes.length) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the bytes array if (offset + chunk > bytes.length) { chunk = bytes.length - offset; } // writes the chunk out.write(bytes, offset, chunk); offset += chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); int remaining = uploadable.getSize(); try { while (remaining > 0) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the remaining size if (chunk > remaining) { chunk = remaining; } // writes remaining chunk StreamUtil.copy(inputStream, out, chunk); remaining -= chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } finally { StreamUtil.close(inputStream); } } } // end if (step != 0) { progressListener.transferred(count); } } \nResponse:", "ground_truth": "Writes content to the output stream, using progress listener to track the sending progress.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.ResponseHandler;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.ByteArrayEntity;\nimport org.apache.http.impl.client.BasicResponseHandler;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.util.EntityUtils;\n\nimport android.util.Log;\n\npublic class Uploader {\n\tprivate static final String TAG = \"Uploader\";\n\tprivate static final String SERVER"}, {"ID": 896, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getString(final String key) { CharSequence cs = (CharSequence) map.get(key); return cs == null ? null : cs.toString(); } \nResponse:", "ground_truth": "Returns the string value with the specified key.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 897, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Integer getInteger(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Integer) { return (Integer) number; } return number.intValue(); } \nResponse:", "ground_truth": "returns the integer value with the specified key.", "predict": " Response is generated by the method.\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.run();\n    }\n\n    public void run() {\n        String[] keys = {\"a\", \"b\", \"c\"};\n        Map<String, Number> map = new HashMap<String, Number>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n        map.put(\"c\", 3);\n        for (String key : keys) {\n            System.out.println(key + \": \" + getInteger(key));\n        }\n    }\n\n    public int getInteger(String key) {\n        Number number = map.get(key);\n        if (number == null) {\n            return null;\n        }\n        if (number instanceof Integer) {\n            return (Integer) number;\n        }\n        return number"}, {"ID": 898, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Long getLong(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Long) { return (Long) number; } return number.longValue(); } \nResponse:", "ground_truth": "Returns the long value with the specified key.", "predict": " Response is generated by the method.\n*/\n\npublic class GetLong {\n    public static void main(String[] args) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"key\", \"value\");\n        Long number = (Long) map.get(\"key\");\n        System.out.println(number);\n    }\n}\n"}, {"ID": 899, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Double getDouble(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Double) { return (Double) number; } return number.doubleValue(); } \nResponse:", "ground_truth": "Returns the double value with the specified key.", "predict": " Response is generated by the method.\n*/\n\npublic class MapGetter {\n    public static void main(String[] args) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"key\", new Double(1.0));\n        System.out.println(map.get(\"key\"));\n    }\n}\n"}, {"ID": 900, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Float getFloat(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Float) { return (Float) number; } return number.floatValue(); } \nResponse:", "ground_truth": "Returns the float value with the specified key.", "predict": " Response is generated by the method.\n*/\n\npublic class GetFloat {\n    public static void main(String[] args) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"key\", new Float(1.0));\n        System.out.println(getFloat(\"key\"));\n    }\n\n    public static Float getFloat(final String key) {\n        Number number = (Number) map.get(key);\n        if (number == null) {\n            return null;\n        }\n        if (number instanceof Float) {\n            return (Float) number;\n        }\n        return number.floatValue();\n    }\n}\n"}, {"ID": 901, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T getValue(final String key) { T val = (T) map.get(key); if (val instanceof Map) { return (T) new JsonObject((Map) val); } if (val instanceof List) { return (T) new JsonArray((List) val); } return val; } \nResponse:", "ground_truth": "Returns the value with the specified key, as an object.", "predict": " Response.ok().entity(new JsonObject(map)).build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n@Path(\"/\")\npublic class JsonObject {\n\n\t@GET\n\t@Path(\"/\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic Response getJson() {\n\t\tMap<String, Object> map = new HashMap<String, Object>();\n\t\t"}, {"ID": 902, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonObject put(final String key, final String value) { Objects.requireNonNull(key); map.put(key, value); return this; } \nResponse:", "ground_truth": "Puts a string into the JSON object with the specified key.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 903, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useFolder(final String folderName) { closeFolderIfOpened(folder); try { this.folderName = folderName; this.folder = getService().getFolder(folderName); try { folder.open(Folder.READ_WRITE); } catch (final MailException ignore) { folder.open(Folder.READ_ONLY); } } catch (final MessagingException msgexc) { throw new MailException(\"Failed to connect to folder: \" + folderName, msgexc); } } \nResponse:", "ground_truth": "Opens new folder and closes previously opened folder.\n\n@param folderName Folder to open", "predict": "\n\n*/\n\npackage com.google.appengine.api.mail.mailjet;\n\nimport com.google.appengine.api.mail.MailService;\nimport com.google.appengine.api.mail.MailServiceFactory;\nimport com.google.appengine.api.mail.MailServicePb.MailMessage;\nimport com.google.appengine.api.mail.MailServicePb.MailServiceError;\nimport com.google.appengine.api.mail.MailServicePb.MailServiceErrors;\nimport com.google.appengine.api.mail.MailServicePb.MailServiceRequest;\nimport com.google.appengine.api.mail.MailServicePb.MailServiceResponse;\nimport com.google.appengine.api.mail.MailServicePb.SendMailRequest;\nimport com.google.appengine.api.mail.MailServicePb.SendMailResponse;\nimport com.google.appengine"}, {"ID": 904, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: ReceivedEmail[] receiveMessages( final EmailFilter filter, final Flags flagsToSet, final Flags flagsToUnset, final boolean envelope, final Consumer<Message[]> processedMessageConsumer) { useAndOpenFolderIfNotSet(); final Message[] messages; try { if (filter == null) { messages = folder.getMessages(); } else { messages = folder.search(filter.getSearchTerm()); } if (messages.length == 0) { return ReceivedEmail.EMPTY_ARRAY; } if (envelope) { final FetchProfile fetchProfile = new FetchProfile(); fetchProfile.add(FetchProfile.Item.ENVELOPE); fetchProfile.add(FetchProfile.Item.FLAGS); folder.fetch(messages, fetchProfile); } // process messages final ReceivedEmail[] emails = new ReceivedEmail[messages.length]; for (int i = 0; i < messages.length; i++) { final Message msg = messages[i]; // we need to parse message BEFORE flags are set! emails[i] = new ReceivedEmail(msg, envelope, attachmentStorage); if (!EmailUtil.isEmptyFlags(flagsToSet)) { emails[i].flags(flagsToSet); msg.setFlags(flagsToSet, true); } if (!EmailUtil.isEmptyFlags(flagsToUnset)) { emails[i].flags().remove(flagsToUnset); msg.setFlags(flagsToUnset, false); } if (EmailUtil.isEmptyFlags(flagsToSet) && !emails[i].isSeen()) { msg.setFlag(Flags.Flag.SEEN, false); } } if (processedMessageConsumer != null) { processedMessageConsumer.accept(messages); } // if messages were marked to be deleted, we need to expunge the folder if (!EmailUtil.isEmptyFlags(flagsToSet)) { if (flagsToSet.contains(Flags.Flag.DELETED)) { folder.expunge(); } } return emails; } catch (final MessagingException msgexc) { throw new MailException(\"Failed to fetch messages\", msgexc); } } \nResponse:", "ground_truth": "The main email receiving method.", "predict": "\n\n*/\n"}, {"ID": 905, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void updateEmailFlags(final ReceivedEmail receivedEmail) { useAndOpenFolderIfNotSet(); try { folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true); } catch (MessagingException mex) { throw new MailException(\"Failed to fetch messages\", mex); } } \nResponse:", "ground_truth": "Updates the email flags on the server.", "predict": "\n\n*/\n\npublic class EmailFlags {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Add your code here.\n\t\t\n\t}\n\t\n\tpublic static void useAndOpenFolderIfNotSet() {\n\t\t\n\t\t// TODO: Add your code here.\n\t\t\n\t}\n\t\n\tpublic static void setFlags(int[] messageNumbers, int[] flags, boolean set) {\n\t\t\n\t\t// TODO: Add your code here.\n\t\t\n\t}\n\t\n\tpublic static void setFlags(int[] messageNumbers, int[] flags) {\n\t\t\n\t\t// TODO: Add your code here.\n\t\t\n\t}\n\t\n\tpublic static void setFlags(int[] messageNumbers, int[] flags, boolean set, boolean openFolder) {\n\t\t\n\t\t// TODO: Add your code here.\n\t\t\n\t}\n\t\n\tpublic static void setFlags(int[] messageNumbers, int"}, {"ID": 906, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void closeFolderIfOpened(final Folder folder) { if (folder != null) { try { folder.close(true); } catch (final MessagingException ignore) { } } } \nResponse:", "ground_truth": "Closes folder if opened and expunge deleted messages.", "predict": " void\nExceptions:  IllegalStateException - if this folder is not opened.\n            MessagingException - if an error occurs while closing the folder.\n            IOException - if an error occurs while accessing the folder.\n            UnsupportedOperationException - if this folder does not support\n                                            folders.\n */\n\npublic class CloseFolderIfOpened extends AbstractJavaMethod {\n    public String getMethodName() {\n        return \"closeFolderIfOpened\";\n    }\n\n    public String getDescription() {\n        return \"Generate the method-level comment for the following java Code. Code: protected void closeFolderIfOpened(final Folder folder) { if (folder != null) { try { folder.close(true); } catch (final MessagingException ignore) { } } } \";\n    }\n\n    public String getReturnDescription() {\n        return \"void\";\n    }\n\n    public String getExceptionDescription() {\n        return \"IllegalStateException - if"}, {"ID": 907, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: DbQueryNamedParameter lookupNamedParameter(final String name) { DbQueryNamedParameter p = rootNP; while (p != null) { if (p.equalsName(name)) { return p; } p = p.next; } return null; } \nResponse:", "ground_truth": "Lookup for named parameter.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 908, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String alias(final String target) { return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV); } \nResponse:", "ground_truth": "Creates alias.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 909, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean validateAction(final String... profiles) { prepareValidator(); vtor.useProfiles(profiles); vtor.validate(this); vtor.resetProfiles(); List<Violation> violations = vtor.getViolations(); return violations == null; } \nResponse:", "ground_truth": "Validates action. Profiles are reset after the invocation.\n@return true if validation is successful, otherwise returns false", "predict": " Response = Response.ok().build(); \n\n*/\n\npublic class ValidateAction {\n\t\n\tprivate static final Logger logger = Logger.getLogger(ValidateAction.class);\n\t\n\tpublic Response validateAction(final String... profiles) {\n\t\tlogger.info(\"validateAction\");\n\t\t\n\t\tResponse response = null;\n\t\t\n\t\ttry {\n\t\t\tresponse = Response.ok().build();\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"validateAction\", e);\n\t\t\tresponse = Response.serverError().build();\n\t\t}\n\t\t\n\t\treturn response;\n\t}\n\t\n}\n"}, {"ID": 910, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addViolation(final String name, final Object invalidValue) { prepareValidator(); vtor.addViolation(new Violation(name, this, invalidValue)); } \nResponse:", "ground_truth": "Adds action violation.", "predict": " public void addViolation(final String name, final Object invalidValue) { addViolation(name, invalidValue); } \n\n*/\n\npublic class Validator {\n\t\n\tprivate static final String METHOD_NAME = \"addViolation\";\n\t\n\tprivate static final String PARAM_NAME_NAME = \"name\";\n\tprivate static final String PARAM_NAME_INVALID_VALUE = \"invalidValue\";\n\t\n\tprivate static final String PARAM_NAME_VALIDATOR = \"validator\";\n\t\n\tprivate static final String PARAM_NAME_VALIDATOR_NAME = \"name\";\n\tprivate static final String PARAM_NAME_VALIDATOR_INVALID_VALUE = \"invalidValue\";\n\t\n\tprivate static final String PARAM_NAME_VALIDATOR_VALIDATE = \"validate\";\n\t\n\tprivate static final String PARAM_NAME_VALIDATOR_VALIDATE_NAME = \"name\";\n"}, {"ID": 911, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RawData as(final String mimeOrExtension) { if (mimeOrExtension.contains(StringPool.SLASH)) { this.mimeType = mimeOrExtension; } else { this.mimeType = MimeTypes.getMimeType(mimeOrExtension); } return this; } \nResponse:", "ground_truth": "Defines mime type by providing real mime type or just extension!", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 912, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RawData downloadableAs(final String downloadFileName) { this.downloadFileName = downloadFileName; this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName)); return this; } \nResponse:", "ground_truth": "Defines download file name and mime type from the name extension.", "predict": "\n\n*/\n\npublic class RawData {\n    private String downloadFileName;\n    private String mimeType;\n\n    public RawData(String downloadFileName, String mimeType) {\n        this.downloadFileName = downloadFileName;\n        this.mimeType = mimeType;\n    }\n\n    public String getDownloadFileName() {\n        return downloadFileName;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n}\n"}, {"ID": 913, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T setTarget(final InputStream target) { assertTargetIsNotDefined(); targetInputStream = target; targetClass = null; targetClassName = null; return _this(); } \nResponse:", "ground_truth": "Defines class input stream as a target.", "predict": " Response = new Response();\nResponse.setTarget(targetInputStream);\nreturn Response;\n}\n\npublic Response setTarget(final InputStream target) {\nassertTargetIsNotDefined();\ntargetInputStream = target;\ntargetClass = null;\ntargetClassName = null;\nreturn _this();\n}\n\npublic Response setTarget(final Class<?> targetClass) {\nassertTargetIsNotDefined();\ntargetInputStream = null;\ntargetClass = targetClass;\ntargetClassName = null;\nreturn _this();\n}\n\npublic Response setTarget(final String targetClassName) {\nassertTargetIsNotDefined();\ntargetInputStream = null;\ntargetClass = null;\ntargetClassName = targetClassName;\nreturn _this();\n}\n\nprotected void assertTargetIsNotDefined() {\nif (targetInputStream != null || targetClass != null || targetClassName != null) {\nthrow new IllegalStateException(\"Target has already been set"}, {"ID": 914, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T setTarget(final String targetName) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(targetName); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + targetName); } targetClassName = targetName; targetClass = null; } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to get stream class name: \" + targetName, ioex); } return _this(); } \nResponse:", "ground_truth": "Defines class name as a target.\nClass will not be loaded by classloader!", "predict": " public T setTarget(final String targetName) { return setTarget(targetName); } \n\n}\n"}, {"ID": 915, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T setTarget(final Class target) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(target); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + target.getName()); } targetClass = target; targetClassName = target.getName(); } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex); } return _this(); } \nResponse:", "ground_truth": "Defines class as a target.", "predict": " public T setTarget(final Class target) { return setTarget(target, null); } \nResp public T setTarget(final Class target, final String targetClassName) { return setTarget(target, targetClassName, null); } \nResp public T setTarget(final Class target, final String targetClassName, final String targetMethodName) { return setTarget(target, targetClassName, targetMethodName, null); } \nResp public T setTarget(final Class target, final String targetClassName, final String targetMethodName, final String targetMethodSignature) { return setTarget(target, targetClassName, targetMethodName, targetMethodSignature, null); } \nResp public T setTarget(final Class target, final String targetClassName, final String targetMethodName, final String targetMethodSignature, final String targetMethodBody) { return setTarget(target, targetClassName, targetMethodName, targetMethodSignature, targetMethodBody, null); } "}, {"ID": 916, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void process() { if (targetInputStream == null) { throw new ProxettaException(\"Target missing: \" + targetClassName); } // create class reader final ClassReader classReader; try { classReader = new ClassReader(targetInputStream); } catch (IOException ioex) { throw new ProxettaException(\"Error reading class input stream\", ioex); } // reads information final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader()); classReader.accept(targetClassInfoReader, 0); this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES); // create proxy if (log.isDebugEnabled()) { log.debug(\"processing: \" + classReader.getClassName()); } WorkData wd = process(classReader, targetClassInfoReader); // store important data proxyApplied = wd.proxyApplied; proxyClassName = wd.thisReference.replace('/', '.'); } \nResponse:", "ground_truth": "Reads the target and creates destination class.", "predict": "\n\n*/\n\npackage com.proxetta.generator;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.commons.EmptyVisitor;\n\nimport com.proxetta.ProxettaException;\nimport com.proxetta.ProxettaOptions;\nimport com.proxetta.asm.ProxettaClassVisitor;\nimport com.proxetta.asm.ProxettaMethodVisitor;\nimport com.proxetta.asm.ProxettaMethodVisitor.MethodInfo;\nimport com.proxetta.asm.ProxettaMethodVisitor."}, {"ID": 917, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] create() { process(); byte[] result = toByteArray(); dumpClassInDebugFolder(result); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } return null; } if (log.isDebugEnabled()) { log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName)); } return result; } \nResponse:", "ground_truth": "Returns byte array of created class.", "predict": " public byte[] create() { process(); byte[] result = toByteArray(); dumpClassInDebugFolder(result); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } return null; } if (log.isDebugEnabled()) { log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName)); } return result; } \n\n*/\n\npublic class ProxyGenerator {\n\n    private static final Logger log = LoggerFactory.getLogger(ProxyGenerator.class);\n\n    private static final String PROXY_PACKAGE = \"org.apache.camel.component.jmx.springboot\";\n    private static final String PROXY_CLASS_NAME = \"JMXEndpoint\";\n    private static final String PROXY_FULL_CLASS_NAME = PROXY_"}, {"ID": 918, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class define() { process(); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } if (targetClass != null) { return targetClass; } if (targetClassName != null) { try { return ClassLoaderUtil.loadClass(targetClassName); } catch (ClassNotFoundException cnfex) { throw new ProxettaException(cnfex); } } } if (log.isDebugEnabled()) { log.debug(\"Proxy created: \" + StringUtil.toSafeString(targetClassName)); } try { ClassLoader classLoader = proxetta.getClassLoader(); if (classLoader == null) { classLoader = ClassLoaderUtil.getDefaultClassLoader(); if ((classLoader == null) && (targetClass != null)) { classLoader = targetClass.getClassLoader(); } } final byte[] bytes = toByteArray(); dumpClassInDebugFolder(bytes); return DefineClass.of(getProxyClassName(), bytes, classLoader); } catch (Exception ex) { throw new ProxettaException(\"Class definition failed\", ex); } } \nResponse:", "ground_truth": "Defines class.", "predict": "\n\npublic Class define() {\n\tprocess();\n\tif ((!proxetta.isForced()) && (!isProxyApplied())) {\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName));\n\t\t}\n\t\tif (targetClass != null) {\n\t\t\treturn targetClass;\n\t\t}\n\t\tif (targetClassName != null) {\n\t\t\ttry {\n\t\t\t\treturn ClassLoaderUtil.loadClass(targetClassName);\n\t\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\t\tthrow new ProxettaException(cnfex);\n\t\t\t}\n\t\t}\n\t}\n\tif (log.isDebugEnabled()) {\n\t\tlog.debug(\"Proxy created: \" + StringUtil.toSafeString(targetClassName));\n\t}\n\ttry {\n\t\tClassLoader classLoader = proxetta.getClassLoader();\n\t\tif ("}, {"ID": 919, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object newInstance() { Class type = define(); try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new ProxettaException(\"Invalid Proxetta class\", ex); } } \nResponse:", "ground_truth": "Creates new instance of created class.\nAssumes default no-arg constructor.", "predict": "\n\npublic class Foo {\n    public Object newInstance() {\n        Class type = define();\n        try {\n            return ClassUtil.newInstance(type);\n        } catch (Exception ex) {\n            throw new ProxettaException(\"Invalid Proxetta class\", ex);\n        }\n    }\n}\n\n*/\n\npublic class ClassUtil {\n\n    public static Class define() {\n        return null;\n    }\n\n    public static Object newInstance(Class type) {\n        try {\n            return ClassUtil.newInstance(type);\n        } catch (Exception ex) {\n            throw new ProxettaException(\"Invalid Proxetta class\", ex);\n        }\n    }\n\n    public static Object newInstance(Class type, Object[] args) {\n        try {\n            return ClassUtil.newInstance(type, args);\n        } catch (Exception ex) {\n            throw new ProxettaException(\"Invalid Proxetta class\","}, {"ID": 920, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void dumpClassInDebugFolder(final byte[] bytes) { File debugFolder = proxetta.getDebugFolder(); if (debugFolder == null) { return; } if (!debugFolder.exists() || !debugFolder.isDirectory()) { log.warn(\"Invalid debug folder: \" + debugFolder); } String fileName = proxyClassName; if (fileName == null) { fileName = \"proxetta-\" + System.currentTimeMillis(); } fileName += \".class\"; File file = new File(debugFolder, fileName); try { FileUtil.writeBytes(file, bytes); } catch (IOException ioex) { log.warn(\"Error writing class as \" + file, ioex); } } \nResponse:", "ground_truth": "Writes created class content to output folder for debugging purposes.", "predict": "\n\n*/\n\npackage com.github.fge.grappa.transform.base;\n\nimport com.github.fge.grappa.transform.TestParser;\nimport com.github.fge.grappa.transform.base.ClassContext;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor.RuleMethodProcessorBuilder;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor.RuleMethodProcessorContext;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor.RuleMethodProcessorFactory;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor.RuleMethodProcessorType;\nimport com.github.fge.grappa.transform.base.RuleMethodProcessor.RuleMethodProcessorTypeBuilder;\nimport"}, {"ID": 921, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T from(final String personalName, final String from) { return from(new EmailAddress(personalName, from)); } \nResponse:", "ground_truth": "Sets the FROM address by providing personal name and address.\n\n@param personalName personal name.\n@param from         email address.\n@return this\n@see #from(EmailAddress)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 922, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T to(final EmailAddress to) { this.to = ArraysUtil.append(this.to, to); return _this(); } \nResponse:", "ground_truth": "Appends TO address.\n\n@param to {@link EmailAddress} to add.\n@return this", "predict": " public T to(final EmailAddress to, final EmailAddress... tos) { this.to = ArraysUtil.append(this.to, to, tos); return _this(); } \nResp public T to(final EmailAddress to, final Collection<EmailAddress> tos) { this.to = ArraysUtil.append(this.to, to, tos); return _this(); } \nResp public T to(final EmailAddress to, final EmailAddress to1, final EmailAddress... tos) { this.to = ArraysUtil.append(this.to, to, tos); return _this(); } \nResp public T to(final EmailAddress to, final EmailAddress to1, final Collection<EmailAddress> tos) { this.to = ArraysUtil.append(this.to, to, tos); return _this(); } \nResp public T to(final EmailAddress to, final EmailAddress to1, final"}, {"ID": 923, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T to(final String personalName, final String to) { return to(new EmailAddress(personalName, to)); } \nResponse:", "ground_truth": "Appends TO address by personal name and email address.\n\n@param personalName personal name.\n@param to           email address.\n@return this\n@see #to(EmailAddress)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 924, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T replyTo(final EmailAddress... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \nResponse:", "ground_truth": "Appends REPLY-TO addresses.\n\n@param replyTo vararg of {@link EmailAddress}es to set.\n@return this", "predict": " public T replyTo(final String... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \nResp public T replyTo(final Collection<String> replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \nResp public T replyTo(final String replyTo) { this.replyTo = replyTo; return _this(); } \nResp public T replyTo(final EmailAddress... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \nResp public T replyTo(final Collection<EmailAddress> replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \n"}, {"ID": 925, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T cc(final EmailAddress... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResponse:", "ground_truth": "Appends CC addresses.\n\n@param ccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " public T cc(final String... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResp public T cc(final Collection<String> ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResp public T cc(final String cc) { this.cc = cc; return _this(); } \nResp public T cc(final String... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResp public T cc(final Collection<String> ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResp public T cc(final EmailAddress cc) { this.cc = cc;"}, {"ID": 926, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T textMessage(final String text, final String encoding) { return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding)); } \nResponse:", "ground_truth": "Adds plain message text.\n\n@param text     The text to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Generate the method-level comment for the following java Code. Code: public T textMessage(final String text, final String encoding) { return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding)); } \n\n*/\n\npublic class EmailMessage {\n\tprivate String text;\n\tprivate String mimeType;\n\tprivate String encoding;\n\t\n\tpublic EmailMessage(String text, String mimeType, String encoding) {\n\t\tthis.text = text;\n\t\tthis.mimeType = mimeType;\n\t\tthis.encoding = encoding;\n\t}\n\t\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\t\n\tpublic String getMimeType() {\n\t\treturn mimeType;\n\t}\n\t\n\tpublic String getEncoding() {\n\t\treturn encoding;\n\t}\n}\n"}, {"ID": 927, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); } \nResponse:", "ground_truth": "Adds HTML message.\n\n@param html     The HTML to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); } \nResp Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); } \nResp Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); } \nResp Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML"}, {"ID": 928, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T header(final String name, final String value) { headers.put(name, value); return _this(); } \nResponse:", "ground_truth": "Sets header value.\n\n@param name  The name of the header.\n@param value The value of the header.\n@return this", "predict": " public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header(name, value); } \nResp public T header(final String name, final String value) { return header("}, {"ID": 929, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String get(final String name, final String defaultValue) { Objects.requireNonNull(name); String value = null; try { if (System.getSecurityManager() == null) { value = System.getProperty(name); } else { value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name)); } } catch (Exception ignore) { } if (value == null) { return defaultValue; } return value; } \nResponse:", "ground_truth": "Returns system property. If key is not available, returns the default value.", "predict": " public static String get(final String name, final String defaultValue) { Objects.requireNonNull(name); String value = null; try { if (System.getSecurityManager() == null) { value = System.getProperty(name); } else { value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name)); } } catch (Exception ignore) { } if (value == null) { return defaultValue; } return value; } \n\n*/\n\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    private static final String PROPERTIES_FILE = \"config.properties\";\n    private static final String DEFAULT_PROPERTY = \"default.property\";\n    private static final String PROPERTY_NAME = \"property.name\";\n    private static final String PROPERTY_VALUE = \"property.value\";\n    private static final String PROPER"}, {"ID": 930, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean getBoolean(final String name, final boolean defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); switch (value) { case \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true; case \"false\": case \"no\" : case \"0\" : case \"off\" : return false; default: return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as boolean.", "predict": " Response is a string that is returned to the client.\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int[] arr2 = new int[m];\n        for(int i = 0; i < m; i++){\n            arr2[i] = in.nextInt();\n        }\n        int[] arr3 = new int[n];\n        for(int i = 0; i < n; i++){\n            arr3[i] = arr[i];\n        }\n        int[] arr4 = new int[m"}, {"ID": 931, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getInt(final String name, final int defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Integer.parseInt(value); } catch (NumberFormatException nfex) { return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as an int.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(arr[i] > arr[j]){\n                    max = Math.max(max, arr[i] - arr[j]);\n                }\n            }\n        }\n        System.out.println(max);\n    }\n}\n"}, {"ID": 932, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getLong(final String name, final long defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Long.parseLong(value); } catch (NumberFormatException nfex) { return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as a long.", "predict": " Response is generated by the method getLong(final String name, final long defaultValue)\n\n*/\n\npublic class GetLong {\n\tpublic static void main(String[] args) {\n\t\tString name = \"name\";\n\t\tlong defaultValue = 0;\n\t\tlong value = getLong(name, defaultValue);\n\t\tSystem.out.println(\"Resp \" + value);\n\t}\n\t\n\tpublic static long getLong(final String name, final long defaultValue) {\n\t\tString value = get(name);\n\t\tif (value == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\tvalue = value.trim().toLowerCase();\n\t\ttry {\n\t\t\treturn Long.parseLong(value);\n\t\t} catch (NumberFormatException nfex) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\t\n\tpublic static String get(final String name) {\n\t\treturn System.getProperty(name);\n\t}\n}\n"}, {"ID": 933, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: MethodParameter[] getResolvedParameters() { if (paramExtractor == null) { return MethodParameter.EMPTY_ARRAY; } if (!paramExtractor.debugInfoPresent) { throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName); } return paramExtractor.getMethodParameters(); } \nResponse:", "ground_truth": "Returns method parameters once when method is parsed.\nIf method has no parameters, an empty array is returned.", "predict": " ResponseType getResponse() { if (responseExtractor == null) { return ResponseType.NONE; } if (!responseExtractor.debugInfoPresent) { throw new ParamoException(\"Response not available for method: \" + declaringClass.getName() + '#' + methodName); } return responseExtractor.getResponse(); } \n\n*/\n\npublic class MethodParameterExtractor {\n\t\n\tprivate final String methodName;\n\tprivate final String declaringClass;\n\tprivate final String[] parameterNames;\n\tprivate final boolean debugInfoPresent;\n\tprivate final ResponseExtractor responseExtractor;\n\tprivate final ParameterExtractor paramExtractor;\n\t\n\tpublic MethodParameterExtractor(String methodName, String declaringClass, String[] parameterNames, boolean debugInfoPresent, ResponseExtractor responseExtractor, ParameterExtractor paramExtractor) {\n\t\tthis.methodName = methodName;\n\t\tthis.declaringClass = declaringClass;\n\t\tthis.parameterNames"}, {"ID": 934, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) { if ((value == null) && jsonContext.isExcludeNulls()) { return count; } if (key != null) { currentPath.push(key.toString()); } else { currentPath.push(StringPool.NULL); } // check if we should include the field boolean include = true; if (value != null) { // + all collections are not serialized by default include = jsonContext.matchIgnoredPropertyTypes(value.getClass(), false, include); // + path queries: excludes/includes include = jsonContext.matchPathToQueries(include); } // done if (!include) { currentPath.pop(); return count; } if (key == null) { jsonContext.pushName(null, count > 0); } else { jsonContext.pushName(key.toString(), count > 0); } jsonContext.serialize(value); if (jsonContext.isNamePopped()) { count++; } currentPath.pop(); return count; } \nResponse:", "ground_truth": "Serializes key and a value.", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.io.IOException;\nimport java.io.Writer;\n\n/**\n * A simple writer that will simply write the contents to the underlying\n * writer.\n */\npublic final class SimpWriter extends Writer {\n    private final Writer writer;\n\n    public SimpWriter(Writer writer) {\n        this.writer = writer;\n    }\n\n    @Override\n    public void write(char[] cbuf, int off, int len) throws IOException {\n        writer.write(cbuf, off, len);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        writer.flush();\n    }\n\n    @Override\n    public void close() throws IOException {\n        writer.close();\n    }\n}\n"}, {"ID": 935, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String lookupAlias(final String alias) { String value = actionsManager.lookupPathAlias(alias); if (value == null) { ActionRuntime cfg = actionsManager.lookup(alias); if (cfg != null) { value = cfg.getActionPath(); } } return value; } \nResponse:", "ground_truth": "Lookups value as an alias and, if not found, as a default alias.", "predict": " Response.ok().build();\n\n*/\n\npackage com.jivesoftware.os.upena.deployable.profiler.profiler.service;\n\nimport com.jivesoftware.os.upena.deployable.profiler.profiler.service.resource.ProfilerResource;\nimport com.jivesoftware.os.upena.deployable.profiler.profiler.service.resource.ProfilerResource.ProfilerResourceBuilder;\nimport com.jivesoftware.os.upena.deployable.profiler.profiler.service.resource.ProfilerResource.ProfilerResourceKey;\nimport com.jivesoftware.os.upena.deployable.profiler.profiler.service.resource.ProfilerResource.ProfilerResourceValue;\nimport com.jivesoftware.os.upena.deployable.profiler.profiler.service.resource.ProfilerResource.ProfilerResourceValue"}, {"ID": 936, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveAlias(final String value) { final StringBuilder result = new StringBuilder(value.length()); int i = 0; int len = value.length(); while (i < len) { int ndx = value.indexOf('<', i); if (ndx == -1) { // alias markers not found if (i == 0) { // try whole string as an alias String alias = lookupAlias(value); return (alias != null ? alias : value); } else { result.append(value.substring(i)); } break; } // alias marked found result.append(value.substring(i, ndx)); ndx++; int ndx2 = value.indexOf('>', ndx); String aliasName = (ndx2 == -1 ? value.substring(ndx) : value.substring(ndx, ndx2)); // process alias String alias = lookupAlias(aliasName); if (alias != null) { result.append(alias); } else { // alias not found if (log.isWarnEnabled()) { log.warn(\"Alias not found: \" + aliasName); } } i = ndx2 + 1; } // fix prefix '//' - may happened when aliases are used i = 0; len = result.length(); while (i < len) { if (result.charAt(i) != '/') { break; } i++; } if (i > 1) { return result.substring(i - 1, len); } return result.toString(); } \nResponse:", "ground_truth": "Returns resolved alias result value or passed on, if alias doesn't exist.", "predict": "\n\npublic String resolveAlias(final String value) {\n\tfinal StringBuilder result = new StringBuilder(value.length());\n\tint i = 0; int len = value.length(); while (i < len) {\n\t\tint ndx = value.indexOf('<', i);\n\t\tif (ndx == -1) {\n\t\t\t// alias markers not found if (i == 0) { // try whole string as an alias\n\t\t\t// String alias = lookupAlias(value); return (alias != null ? alias : value);\n\t\t\t// } else { result.append(value.substring(i)); } break;\n\t\t\tresult.append(value.substring(i));\n\t\t\tbreak;\n\t\t}\n\t\t// alias marked found result.append(value.substring(i, ndx)); ndx++; int ndx2 =\n\t\t// value.indexOf('>', ndx); String aliasName = (ndx2 == -1 ? value.substring(ndx"}, {"ID": 937, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResultPath resolveResultPath(String path, String value) { boolean absolutePath = false; if (value != null) { // [*] resolve alias in value value = resolveAlias(value); // [*] absolute paths if (StringUtil.startsWithChar(value, '/')) { absolutePath = true; int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path = value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { path = value; value = null; } } else { // [*] resolve # in value and path int i = 0; while (i < value.length()) { if (value.charAt(i) != '#') { break; } int dotNdx = MadvocUtil.lastIndexOfSlashDot(path); if (dotNdx != -1) { // dot found path = path.substring(0, dotNdx); } i++; } if (i > 0) { // remove # from value value = value.substring(i); // [*] update path and value if (StringUtil.startsWithChar(value, '.')) { value = value.substring(1); } else { int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path += '.' + value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { if (value.length() > 0) { if (StringUtil.endsWithChar(path, '/')) { path += value; } else { path += '.' + value; } } value = null; } } } } } if (!absolutePath) { if (resultPathPrefix != null) { path = resultPathPrefix + path; } } return new ResultPath(path, value); } \nResponse:", "ground_truth": "Resolves result path.", "predict": " public Response resolveResponse(String path, String value) { if (value != null) { // [*] resolve alias in value value = resolveAlias(value); // [*] absolute paths if (StringUtil.startsWithChar(value, '/')) { int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path = value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { path = value; value = null; } } else { // [*] resolve # in value and path int i = 0; while (i < value.length()) { if (value.charAt(i) != '#') { break; } int dotNdx = MadvocUtil.lastIndexOfSlashDot(path); if (dotNdx != -1) { // dot found path = path.substring(0, dotNdx); } i++; } if (i > 0) { // remove # from"}, {"ID": 938, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveResultPathString(final String path, final String value) { final ResultPath resultPath = resolveResultPath(path, value); final String result = resultPath.pathValue(); return resolveAlias(result); } \nResponse:", "ground_truth": "Resolves result path as a string, when parts are not important\nand when only full string matters. Additional alias resolving\non full path is done.", "predict": " public String resolveResultPathString(final String path, final String value) { final ResultPath resultPath = resolveResultPath(path, value); final String result = resultPath.pathValue(); return resolveAlias(result); } \n\n*/\n\npublic class ResultPath {\n\t\n\tprivate String pathValue;\n\tprivate String alias;\n\t\n\tpublic ResultPath(String pathValue, String alias) {\n\t\tthis.pathValue = pathValue;\n\t\tthis.alias = alias;\n\t}\n\t\n\tpublic String getPathValue() {\n\t\treturn pathValue;\n\t}\n\t\n\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n\t\n\tpublic String resolveAlias(String alias) {\n\t\treturn alias;\n\t}\n\t\n\tpublic String resolveResultPathString(String path, String value) {\n\t\treturn path + \".\" + value;\n\t}\n\t\n\tpublic String resolveResultPathString(String path, String value"}, {"ID": 939, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int lastIndexOfSlashDot(final String str) { int slashNdx = str.lastIndexOf('/'); int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); if (dotNdx == -1) { if (slashNdx == -1) { return -1; } slashNdx++; if (slashNdx < str.length() - 1) { dotNdx = slashNdx; } else { dotNdx = -1; } } return dotNdx; } \nResponse:", "ground_truth": "Locates last dot after the last slash or just slash.", "predict": "\n\npublic static int lastIndexOfSlashDot(final String str) { int slashNdx = str.lastIndexOf('/'); int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); if (dotNdx == -1) { if (slashNdx == -1) { return -1; } slashNdx++; if (slashNdx < str.length() - 1) { dotNdx = slashNdx; } else { dotNdx = -1; } } return dotNdx; } \n\n*/\n\npublic class Solution {\n    public static int lastIndexOfSlashDot(String str) {\n        int slashNdx = str.lastIndexOf('/');\n        int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);\n        if (dotNdx == -1) {\n            if (slash"}, {"ID": 940, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int lastIndexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); slashNdx++; return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); } \nResponse:", "ground_truth": "Locates last index of dot after the optional last slash.", "predict": "\n\npublic static int lastIndexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); } \n\n*/\n\npublic class Solution {\n    public static int lastIndexOfDotAfterSlash(String str) {\n        int slashNdx = str.lastIndexOf('/');\n        return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);\n    }\n}\n"}, {"ID": 941, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); if (slashNdx == -1) { slashNdx = 0; } return str.indexOf('.', slashNdx); } \nResponse:", "ground_truth": "Locates first dot after the last slash.", "predict": "\n\npublic static int indexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); if (slashNdx == -1) { slashNdx = 0; } return str.indexOf('.', slashNdx); } \n\n*/\n\npublic class Solution {\n    public static int indexOfDotAfterSlash(String str) {\n        int slashNdx = str.lastIndexOf('/');\n        if (slashNdx == -1) {\n            slashNdx = 0;\n        }\n        return str.indexOf('.', slashNdx);\n    }\n}\n"}, {"ID": 942, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripLastCamelWord(String name) { int ndx = name.length() - 1; while (ndx >= 0) { if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) { break; } ndx--; } if (ndx >= 0) { name = name.substring(0, ndx); } return name; } \nResponse:", "ground_truth": "Removes last CamelWord", "predict": "\n\npublic static String stripLastCamelWord(String name) {\n    int ndx = name.length() - 1;\n    while (ndx >= 0) {\n        if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) {\n            break;\n        }\n        ndx--;\n    }\n    if (ndx >= 0) {\n        name = name.substring(0, ndx);\n    }\n    return name;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String name = \"abc\";\n        System.out.println(stripLastCamelWord(name));\n    }\n\n    public static String stripLastCamelWord(String name) {\n        int ndx = name.length() - 1;\n        while (ndx >= 0) {\n            if (CharUtil.isUppercaseAlpha(name.charAt("}, {"ID": 943, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) { String schemaName = null; final DbTable dbTable = type.getAnnotation(DbTable.class); if (dbTable != null) { schemaName = dbTable.schema().trim(); } if ((schemaName == null) || (schemaName.length() == 0)) { schemaName = defaultSchemaName; } return schemaName; } \nResponse:", "ground_truth": "Resolves schema name from a type. Uses default schema name if not specified.", "predict": " public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) { String schemaName = null; final DbTable dbTable = type.getAnnotation(DbTable.class); if (dbTable != null) { schemaName = dbTable.schema().trim(); } if ((schemaName == null) || (schemaName.length() == 0)) { schemaName = defaultSchemaName; } return schemaName; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\n\npublic class SchemaNameResolver {\n\n\tpublic static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) {\n\t\tString schemaName = null;\n\t\tfinal DbTable dbTable = type.getAnnotation(DbTable.class);"}, {"ID": 944, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbEntityColumnDescriptor resolveColumnDescriptors( final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) { String columnName = null; boolean isId = false; Class<? extends SqlType> sqlTypeClass = null; // read ID annotation DbId dbId = null; if (property.getFieldDescriptor() != null) { dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class); } if (dbId == null && property.getReadMethodDescriptor() != null) { dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId == null && property.getWriteMethodDescriptor() != null) { dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId != null) { columnName = dbId.value().trim(); sqlTypeClass = dbId.sqlType(); isId = true; } else { DbColumn dbColumn = null; if (property.getFieldDescriptor() != null) { dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getReadMethodDescriptor() != null) { dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getWriteMethodDescriptor() != null) { dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn != null) { columnName = dbColumn.value().trim(); sqlTypeClass = dbColumn.sqlType(); } else { if (isAnnotated) { return null; } } } if (StringUtil.isEmpty(columnName)) { // default annotation value columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName()); } else { if (!columnNamingStrategy.isStrictAnnotationNames()) { columnName = columnNamingStrategy.applyToColumnName(columnName); } } if (sqlTypeClass == SqlType.class) { sqlTypeClass = null; } return new DbEntityColumnDescriptor( dbEntityDescriptor, quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()), property.getName(), property.getType(), isId, sqlTypeClass); } \nResponse:", "ground_truth": "Resolves column descriptor from property. If property is annotated value will be read\nfrom annotation. If property is not annotated, then property will be ignored\nif entity is annotated. Otherwise, column name is generated from the property name.", "predict": " public static DbEntityColumnDescriptor resolveColumnDescriptors( final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) { String columnName = null; boolean isId = false; Class<? extends SqlType> sqlTypeClass = null; // read ID annotation DbId dbId = null; if (property.getFieldDescriptor() != null) { dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class); } if (dbId == null && property.getReadMethodDescriptor() != null) { dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId == null && property.getWriteMethodDescriptor() != null) { dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId"}, {"ID": 945, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(final long[] key, final long[] tweak) { final int newNw = key.length; // only create new arrays if the value of N{w} changes (different key size) if (nw != newNw) { nw = newNw; switch (nw) { case WORDS_4: pi = PI4; rpi = RPI4; r = R4; break; case WORDS_8: pi = PI8; rpi = RPI8; r = R8; break; case WORDS_16: pi = PI16; rpi = RPI16; r = R16; break; default: throw new RuntimeException(\"Invalid threefish key\"); } this.k = new long[nw + 1]; // instantiation of these fields here for performance reasons vd = new long[nw]; // v is the intermediate value v{d} at round d ed = new long[nw]; // ed is the value of e{d} at round d fd = new long[nw]; // fd is the value of f{d} at round d ksd = new long[nw]; // ksd is the value of k{s} at round d } System.arraycopy(key, 0, this.k, 0, key.length); long knw = EXTENDED_KEY_SCHEDULE_CONST; for (int i = 0; i < nw; i++) { knw ^= this.k[i]; } this.k[nw] = knw; // set tweak values t[0] = tweak[0]; t[1] = tweak[1]; t[2] = t[0] ^ t[1]; } \nResponse:", "ground_truth": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Threefish {\n    private static final int WORDS_4 = 4;\n    private static final int WORDS_8 = 8;\n    private static final int WORDS_16 = 16;\n    private static final int EXTENDED_KEY_SCHEDULE_CONST = 0x87654321;\n    private static final int PI4 = 0x87654321;\n    private static final int PI8 = 0x12345678;\n    private static final int PI16 = 0x87654321;\n    private static final int R4 = 0x87654321;\n    private static final int R8 = 0x12345678;\n    private static final int R16 = 0x87654321;\n    private static final int R32 = 0x12345678;\n    private static final int R64 = 0x876543"}, {"ID": 946, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void mix(final int j, final int d) { y[0] = x[0] + x[1]; final long rotl = r[d % DEPTH_OF_D_IN_R][j]; // java left rotation for a long y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl)); y[1] ^= y[0]; } \nResponse:", "ground_truth": "Implementation of the MIX function.\n\n@param j the index in the rotation constants\n@param d the round", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        int[] x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] y = new int[2];\n        int[] r = new int[x.length];\n        s.mix(0, x.length - 1);\n        System.out.println(Arrays.toString(y));\n    }\n\n    public void mix(int j, int d) {\n        if (j == 0) {\n            y[0] = x[0] + x[1];\n            return;\n        }\n        if (j == 1) {\n            y[0] = (x[1] << 1) | (x[1] >>>"}, {"ID": 947, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void demix(final int j, final int d) { y[1] ^= y[0]; final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack! // right shift x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr); x[0] = y[0] - x[1]; } \nResponse:", "ground_truth": "Implementation of the un-MIX function.", "predict": "\n\n*/\n\npublic class Demo {\n    public static void main(String[] args) {\n        int[] x = new int[2];\n        int[] y = new int[2];\n        int[] r = new int[DEPTH_OF_D_IN_R];\n        int[] d = new int[DEPTH_OF_D_IN_R];\n        int j = 0;\n        int d_i = 0;\n        int r_i = 0;\n        int x_i = 0;\n        int y_i = 0;\n        int r_j = 0;\n        int d_j = 0;\n        int x_j = 0;\n        int y_j = 0;\n        int r_k = 0;\n        int d_k = 0;\n        int x_k = 0;\n        int y_k = 0;\n        int r_l = 0;\n        int d_l = 0;"}, {"ID": 948, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void keySchedule(final int s) { for (int i = 0; i < nw; i++) { // just put in the main key first ksd[i] = k[(s + i) % (nw + 1)]; // don't add anything for i = 0,...,Nw - 4 if (i == nw - 3) { // second to last ksd[i] += t[s % TWEAK_VALUES]; } else if (i == nw - 2) { // first to last ksd[i] += t[(s + 1) % TWEAK_VALUES]; } else if (i == nw - 1) { // last ksd[i] += s; } } } \nResponse:", "ground_truth": "Creates the subkeys.\n\n@param s the value of the round devided by 4", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] k = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n        int[] t = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n        int nw = k.length;\n        int[] ksd = new int[nw];\n        for (int i = 0; i < nw; i++) {\n            ksd[i] = k[(i + 1) % nw];\n        }\n        int[] ksd2 = new int"}, {"ID": 949, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(final String keyMessage, final long tweak1, final long tweak2) { long[] tweak = new long[] {tweak1, tweak2}; byte[] key = new byte[blockSize / Byte.SIZE]; byte[] keyData = StringUtil.getBytes(keyMessage); System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length); init(bytesToLongs(key), tweak); } \nResponse:", "ground_truth": "Initializes cipher in a simple way.", "predict": " public void init(final long[] key, final long[] tweak) { } \n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString keyMessage = \"Hello World\";\n\t\tlong tweak1 = 0x123456789abcdef0L;\n\t\tlong tweak2 = 0xfedcba9876543210L;\n\t\t\n\t\tlong[] tweak = new long[] {tweak1, tweak2};\n\t\tbyte[] key = new byte[32];\n\t\tbyte[] keyData = StringUtil.getBytes(keyMessage);\n\t\tSystem.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length);\n\t\t\n\t\tlong[] keyBytes = bytesToLongs(key);\n\t\tlong[] tweakBytes = bytesToLongs(tweak);\n\t\t\n\t\tSystem.out.println(\"Generating Java code for the"}, {"ID": 950, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public byte[] encryptBlock(final byte[] content, final int offset) { long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes); long[] encryptedBlock = new long[blockSize / Long.SIZE]; blockEncrypt(contentBlock, encryptedBlock); return longsToBytes(encryptedBlock); } \nResponse:", "ground_truth": "Encrypts a block.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class BlockEncrypt {\n    public static void main(String[] args) {\n        int blockSize = 16;\n        int keySize = 16;\n        int iterations = 1;\n        byte[] key = new byte[keySize];\n        byte[] plaintext = new byte[blockSize];\n        byte[] ciphertext = new byte[blockSize];\n        byte[] iv = new byte[blockSize];\n        byte[] output = new byte[blockSize];\n        byte[] output2 = new byte[blockSize];\n        byte[] output3 = new byte[blockSize];\n        byte[] output4 = new byte[blockSize];\n        byte[] output5 = new byte[blockSize];\n        byte[] output6 = new byte[blockSize];\n        byte[] output7 = new byte[blockSize];\n        byte[] output8 = new byte[blockSize"}, {"ID": 951, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) { long[] result = new long[size >> 3]; int i8 = offset; for (int i = 0; i < result.length; i++) { result[i] = Bits.getLong(ba, i8); i8 += 8; } return result; } \nResponse:", "ground_truth": "Converts segment of byte array into long array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 952, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String removeAnyBounding(final char s, final char e, final String str) { if (str == null || str.length() < 2) { return str; } if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) { return str.substring(1, str.length() - 1); } return str; } \nResponse:", "ground_truth": "If the string starts and ends with start and end char, remove them,\notherwise return the string as it was passed in.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.removeAnyBounding('a','c','abc'));\n    }\n    public String removeAnyBounding(String S, String T, String str) {\n        if(str == null || str.length() < 2) return str;\n        if(str.startsWith(S) && str.endsWith(T)){\n            return str.substring(1, str.length() - 1);\n        }\n        return str;\n    }\n}"}, {"ID": 953, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String path() { if (methref != null) { final String methodName = methref.ref(); return target.getName() + '#' + methodName; } return path; } \nResponse:", "ground_truth": "Returns path value.", "predict": " Response to the request.\n\n*/\n\npublic class Path {\n\t\n\tpublic static String path(String path, String methodName) {\n\t\t\n\t\tif (methodName != null) {\n\t\t\treturn path + '#' + methodName;\n\t\t}\n\t\t\n\t\treturn path;\n\t}\n\t\n}\n"}, {"ID": 954, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File zlib(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't zlib folder\"); } FileInputStream fis = new FileInputStream(file); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); String zlibFileName = file.getAbsolutePath() + ZLIB_EXT; DeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater); try { StreamUtil.copy(fis, dos); } finally { StreamUtil.close(dos); StreamUtil.close(fis); } return new File(zlibFileName); } \nResponse:", "ground_truth": "Compresses a file into zlib archive.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.Deflater;\nimport java.util.zip.DeflaterOutputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\npublic class Zlib {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFile file = new File(\"/home/jason/Desktop/test.txt\");\n\t\tFileInputStream fis = new FileInputStream(file);\n\t\tDeflater deflater = new Deflater(Deflater.BEST_COMPRESSION);\n\t\tString zlibFileName = file.getAbsolutePath() + ZLIB_EXT;\n\t\tDeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater"}, {"ID": 955, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File gzip(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't gzip folder\"); } FileInputStream fis = new FileInputStream(file); String gzipName = file.getAbsolutePath() + GZIP_EXT; GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(gzipName)); try { StreamUtil.copy(fis, gzos); } finally { StreamUtil.close(gzos); StreamUtil.close(fis); } return new File(gzipName); } \nResponse:", "ground_truth": "Compresses a file into gzip archive.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.GZIPOutputStream;\n\npublic class Gzip {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fis = new FileInputStream(new File(\"/home/jason/Desktop/test.txt\"));\n        FileOutputStream fos = new FileOutputStream(new File(\"/home/jason/Desktop/test.txt.gz\"));\n        GZIPOutputStream gzos = new GZIPOutputStream(fos);\n        StreamUtil.copy(fis, gzos);\n        StreamUtil.close(gzos);\n        StreamUtil.close(fis);\n    }\n}\n"}, {"ID": 956, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File ungzip(final File file) throws IOException { String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath()); File out = new File(outFileName); out.createNewFile(); FileOutputStream fos = new FileOutputStream(out); GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file)); try { StreamUtil.copy(gzis, fos); } finally { StreamUtil.close(fos); StreamUtil.close(gzis); } return out; } \nResponse:", "ground_truth": "Decompress gzip archive.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class FileNameUtil {\n\tpublic static String removeExtension(String fileName) {\n\t\tint index = fileName.lastIndexOf(\".\");\n\t\tif (index == -1) {\n\t\t\treturn fileName;\n\t\t}\n\t\treturn fileName.substring(0, index);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString fileName = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test.txt\";\n\t\tString outFileName = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test.txt\";\n\t\ttry {\n\t\t\tFileInputStream fis = new FileInputStream(fileName);"}, {"ID": 957, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<String> listZip(final File zipFile) throws IOException { List<String> entries = new ArrayList<>(); ZipFile zip = new ZipFile(zipFile); Enumeration zipEntries = zip.entries(); while (zipEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipEntries.nextElement(); String entryName = entry.getName(); entries.add(entryName); } return Collections.unmodifiableList(entries); } \nResponse:", "ground_truth": "Lists zip content.", "predict": " public static List<String> listZip(final File zipFile) throws IOException { List<String> entries = new ArrayList<>(); ZipFile zip = new ZipFile(zipFile); Enumeration zipEntries = zip.entries(); while (zipEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipEntries.nextElement(); String entryName = entry.getName(); entries.add(entryName); } return Collections.unmodifiableList(entries); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class ZipFile {\n\tpublic static List<String> listZip(final File zipFile) throws IOException {\n\t\tList<String> entries = new ArrayList<>();\n\t\tScanner scanner = new Scanner(zipFile);\n\t\twhile (scan"}, {"ID": 958, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException { unzip(new File(zipFile), new File(destDir), patterns); } \nResponse:", "ground_truth": "Extracts zip file content to the target directory.\n@see #unzip(java.io.File, java.io.File, String...)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\npublic class Unzip {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length < 3) {\n            System.out.println(\"Usage: java -jar unzip.jar <zipFile> <destDir> <pattern>*\");\n            System.exit(1);\n        }\n\n        File zipFile = new File(args[0]);\n        File destDir = new File(args[1]);\n        List<String> patterns = Arrays.asList(args).subList(2, args.length);\n\n        if (!zipFile.exists()) {\n            System.out.println(\"Zip file does not exist: \" + zipFile.getAbsolute"}, {"ID": 959, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException { if (!file.exists()) { throw new FileNotFoundException(file.toString()); } if (path == null) { path = file.getName(); } while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } boolean isDir = file.isDirectory(); if (isDir) { // add folder record if (!StringUtil.endsWithChar(path, '/')) { path += '/'; } } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(file.lastModified()); if (comment != null) { zipEntry.setComment(comment); } if (isDir) { zipEntry.setSize(0); zipEntry.setCrc(0); } zos.putNextEntry(zipEntry); if (!isDir) { InputStream is = new FileInputStream(file); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } } zos.closeEntry(); // continue adding if (recursive && file.isDirectory()) { boolean noRelativePath = StringUtil.isEmpty(path); final File[] children = file.listFiles(); if (children != null && children.length != 0) { for (File child : children) { String childRelativePath = (noRelativePath ? StringPool.EMPTY : path) + child.getName(); addToZip(zos, child, childRelativePath, comment, recursive); } } } } \nResponse:", "ground_truth": "Adds single entry to ZIP output stream.\n\n@param zos zip output stream\n@param file file or folder to add\n@param path relative path of file entry; if null files name will be used instead\n@param comment optional comment\n@param recursive when set to true content of added folders will be added, too", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class ZipUtil {\n    public static void addToZip(final File file, final String path, final String comment, final boolean recursive) throws IOException {\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.toString());\n        }\n        if (path == null) {\n            path = file.getName();\n        }\n        while (path.length() != 0 && path.charAt(0) == '/') {\n            path = path.substring(1);\n        }\n        boolean isDir = file.isDirectory();\n        if (isDir) {\n            if (!StringUtil.endsWithChar"}, {"ID": 960, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException { while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } if (StringUtil.endsWithChar(path, '/')) { path = path.substring(0, path.length() - 1); } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(System.currentTimeMillis()); if (comment != null) { zipEntry.setComment(comment); } zos.putNextEntry(zipEntry); InputStream is = new ByteArrayInputStream(content); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } zos.closeEntry(); } \nResponse:", "ground_truth": "Adds byte content into the zip as a file.", "predict": " public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException { while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } if (StringUtil.endsWithChar(path, '/')) { path = path.substring(0, path.length() - 1); } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(System.currentTimeMillis()); if (comment != null) { zipEntry.setComment(comment); } zos.putNextEntry(zipEntry); InputStream is = new ByteArrayInputStream(content); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } zos.closeEntry(); } \n\n*/\n"}, {"ID": 961, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) { final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name); if (fieldDescriptor != null) { if (!fieldDescriptor.matchDeclared(declared)) { return null; } } return fieldDescriptor; } \nResponse:", "ground_truth": "Returns field descriptor.", "predict": " Resp public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) { final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name); if (fieldDescriptor != null) { if (!fieldDescriptor.matchDeclared(declared)) { return null; } } return fieldDescriptor; } \n\n*/\n\npublic class FieldDescriptor {\n\tprivate String name;\n\tprivate boolean declared;\n\tprivate boolean matchDeclared;\n\t\n\tpublic FieldDescriptor(String name, boolean declared) {\n\t\tthis.name = name;\n\t\tthis.declared = declared;\n\t\tthis.matchDeclared = declared;\n\t}\n\t\n\tpublic FieldDescriptor(String name, boolean declared, boolean matchDeclared) {\n\t\tthis.name = name;\n\t\tthis.declared = declared;\n\t\tthis.matchDeclared = matchDeclared;\n\t}\n"}, {"ID": 962, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) { PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name); if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) { return propertyDescriptor; } return null; } \nResponse:", "ground_truth": "Returns property descriptor. Declared flag is matched on both read and write\nmethods.", "predict": " Response = new Response(); Response.setPropertyDescriptor(name, declared); return Response; }\n\npublic Response getPropertyDescriptor(final String name, final boolean declared) {\n\tif (name == null) {\n\t\tthrow new IllegalArgumentException(\"name is null\");\n\t}\n\tif (name.length() == 0) {\n\t\tthrow new IllegalArgumentException(\"name is empty\");\n\t}\n\tif (name.indexOf('.') != -1) {\n\t\tthrow new IllegalArgumentException(\"name contains a '.'\");\n\t}\n\tif (name.indexOf('[') != -1) {\n\t\tthrow new IllegalArgumentException(\"name contains a '['\");\n\t}\n\tif (name.indexOf('(') != -1) {\n\t\tthrow new IllegalArgumentException(\"name contains a '('\");\n\t}\n\tif (name.indexOf(' ') != -1) {\n\t\tthrow new Illegal"}, {"ID": 963, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void setRequestBundleName(final ServletRequest request, final String bundleName) { if (log.isDebugEnabled()) { log.debug(\"Bundle name for this request: \" + bundleName); } request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName); } \nResponse:", "ground_truth": "Sets bundle name for provided servlet request.", "predict": "\n\n*/\n\npublic class BundleNameRequestAttributeListener implements ServletRequestAttributeListener {\n\n    private static final Logger log = LoggerFactory.getLogger(BundleNameRequestAttributeListener.class);\n\n    @Override\n    public void attributeAdded(ServletRequestAttributeEvent event) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Bundle name added to request: \" + event.getValue());\n        }\n        event.getServletRequest().setAttribute(REQUEST_BUNDLE_NAME_ATTR, event.getValue());\n    }\n\n    @Override\n    public void attributeRemoved(ServletRequestAttributeEvent event) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Bundle name removed from request: \" + event.getValue());\n        }\n        event.getServletRequest().removeAttribute(REQUEST_BUNDLE_NAME_ATTR);\n    }\n\n    @Override"}, {"ID": 964, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void setSessionLocale(final HttpSession session, final String localeCode) { if (log.isDebugEnabled()) { log.debug(\"Locale stored to session: \" + localeCode); } Locale locale = Locale.forLanguageTag(localeCode); session.setAttribute(SESSION_LOCALE_ATTR, locale); } \nResponse:", "ground_truth": "Saves Locale to HTTP session.", "predict": "\n\n*/\n\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LocaleController {\n\n\tprivate static final String SESSION_LOCALE_ATTR = \"locale\";\n\n\tprivate static final Map<String, Locale> locales = new ConcurrentHashMap<>();\n\n\t@RequestMapping(value = \"/locale\", method = RequestMethod.GET)\n\tpublic Locale getLocale(@RequestParam(required = false) String localeCode) {\n\t\tLocale locale = locales.get(localeCode);"}, {"ID": 965, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Locale getSessionLocale(final HttpSession session) { Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR); return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale; } \nResponse:", "ground_truth": "Returns current locale from session.\ns", "predict": " public static Locale getSessionLocale(final HttpSession session) { Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR); return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale; } \n\n*/\n\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic class LocaleUtils {\n\n    public static Locale getLocale(HttpSession session) {\n        Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR);\n        return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale;\n    }\n\n    public static void setLocale(HttpSession session, Locale locale) {\n        session.setAttribute(SESSION_LOCALE_ATTR, locale);\n    }\n\n    public static ResourceBundle getResourceBundle(HttpSession session"}, {"ID": 966, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) { beanName = beanName + '.'; List<String> list = new ArrayList<>(); for (Map.Entry<String, Object> entry : params.entrySet()) { String key = entry.getKey(); if (!key.startsWith(beanName)) { continue; } list.add(key); if (!resolveReferenceParams) { continue; } // resolve all references String value = PropertiesUtil.resolveProperty(params, key); entry.setValue(value); } if (list.isEmpty()) { return StringPool.EMPTY_ARRAY; } else { return list.toArray(new String[0]); } } \nResponse:", "ground_truth": "Returns an array of param keys that belongs to provided bean.\nOptionally resolves the value of returned parameters.", "predict": " public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) { beanName = beanName + '.'; List<String> list = new ArrayList<>(); for (Map.Entry<String, Object> entry : params.entrySet()) { String key = entry.getKey(); if (!key.startsWith(beanName)) { continue; } list.add(key); if (!resolveReferenceParams) { continue; } // resolve all references String value = PropertiesUtil.resolveProperty(params, key); entry.setValue(value); } if (list.isEmpty()) { return StringPool.EMPTY_ARRAY; } else { return list.toArray(new String[0]); } } \n\n*/\n"}, {"ID": 967, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropsEntries profile(final String... profiles) { if (profiles == null) { return this; } for (String profile : profiles) { addProfiles(profile); } return this; } \nResponse:", "ground_truth": "Enables profiles to iterate.", "predict": " public PropsEntries profile(final String... profiles) { if (profiles == null) { return this; } for (String profile : profiles) { addProfiles(profile); } return this; } \n\n*/\n\npublic class PropsEntries {\n\t\n\tprivate static final String PROFILES_KEY = \"profiles\";\n\tprivate static final String PROFILES_SEPARATOR = \",\";\n\t\n\tprivate final List<String> profiles;\n\t\n\tpublic PropsEntries(final List<String> profiles) {\n\t\tthis.profiles = profiles;\n\t}\n\t\n\tpublic PropsEntries(final String profiles) {\n\t\tthis.profiles = Arrays.asList(profiles.split(PROFILES_SEPARATOR));\n\t}\n\t\n\tpublic PropsEntries addProfiles(final String... profiles) {\n\t\tfor (String profile : profiles) {\n\t\t\tthis.profiles"}, {"ID": 968, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getLongLittleEndian(final byte[] buf, final int offset) { return ((long) buf[offset + 7] << 56) // no mask needed | ((buf[offset + 6] & 0xffL) << 48) | ((buf[offset + 5] & 0xffL) << 40) | ((buf[offset + 4] & 0xffL) << 32) | ((buf[offset + 3] & 0xffL) << 24) | ((buf[offset + 2] & 0xffL) << 16) | ((buf[offset + 1] & 0xffL) << 8) | ((buf[offset] & 0xffL)); // no shift needed } \nResponse:", "ground_truth": "Gets a long from a byte buffer in little endian byte order.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] buf = new byte[8];\n        Arrays.fill(buf, (byte) 0);\n        Random r = new Random();\n        r.nextBytes(buf);\n        long l = ((long) buf[7] << 56) // no mask needed | ((buf[6] & 0xffL) << 48) | ((buf[5] & 0xffL) << 40) | ((buf[4] & 0xffL) << 32) | ((buf[3] & 0xffL) << 24) | ((buf[2] & 0xffL) << 16) | ((buf[1] & 0xffL) << 8) | ((buf[0] & 0xffL)); // no shift needed\n        System.out.println(l);\n    }\n}\n"}, {"ID": 969, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException { if (inputStream == null) { throw new IOException(\"Class not found\"); } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE]; int bytesRead; while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) { outputStream.write(data, 0, bytesRead); } outputStream.flush(); return outputStream.toByteArray(); } finally { if (close) { inputStream.close(); } } } \nResponse:", "ground_truth": "Reads the given input stream and returns its content as a byte array.\n\n@param inputStream an input stream.\n@param close true to close the input stream after reading.\n@return the content of the given input stream.\n@throws IOException if a problem occurs during reading.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"https://api.github.com/repos/joshua2ua/Java-Simple-HTTP-Server/releases/latest\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.setRequestProperty(\"Accept-Charset\", \"UTF-8\");\n        connection.setRequestProperty(\"Accept-Encoding\", \"gzip,"}, {"ID": 970, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Label readLabel(final int bytecodeOffset, final Label[] labels) { if (labels[bytecodeOffset] == null) { labels[bytecodeOffset] = new Label(); } return labels[bytecodeOffset]; } \nResponse:", "ground_truth": "Returns the label corresponding to the given bytecode offset. The default implementation of\nthis method creates a label for the given offset if it has not been already created.\n\n@param bytecodeOffset a bytecode offset in a method.\n@param labels the already created labels, indexed by their offset. If a label already exists\nfor bytecodeOffset this method must not create a new one. Otherwise it must store the new\nlabel in this array.\n@return a non null Label, which must be equal to labels[bytecodeOffset].", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 971, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getTypeAnnotationBytecodeOffset( final int[] typeAnnotationOffsets, final int typeAnnotationIndex) { if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) { return -1; } return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1); } \nResponse:", "ground_truth": "Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n-1 if there is no such type_annotation of if it does not have a bytecode offset.\n\n@param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\nRuntime[In]VisibleTypeAnnotations attribute, or null.\n@param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n@return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\nif there is no such type_annotation of if it does not have a bytecode offset.", "predict": "\n\n*/\n\npublic class TypeReference_Generated {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Generated code for class: TypeReference\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecodeOffset\");\n\t\tSystem.out.println(\"Generated code for method: getTypeAnnotationBytecode"}, {"ID": 972, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int readElementValues( final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) { int currentOffset = annotationOffset; // Read the num_element_value_pairs field (or num_values field for an array_value). int numElementValuePairs = readUnsignedShort(currentOffset); currentOffset += 2; if (named) { // Parse the element_value_pairs array. while (numElementValuePairs-- > 0) { String elementName = readUTF8(currentOffset, charBuffer); currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer); } } else { // Parse the array_value array. while (numElementValuePairs-- > 0) { currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer); } } if (annotationVisitor != null) { annotationVisitor.visitEnd(); } return currentOffset; } \nResponse:", "ground_truth": "Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\nthem. This method can also be used to read the values of the JVMS 'array_value' field of an\nannotation's 'element_value'.\n\n@param annotationVisitor the visitor that must visit the values.\n@param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\nfield) or of an 'array_value' structure.\n@param named if the annotation values are named or not. This should be true to parse the values\nof a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\nannotation's element_value.\n@param charBuffer the buffer used to read strings in the constant pool.\n@return the end offset of the JVMS 'annotation' or 'array_value' structure.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.run();\n    }\n\n    public void run() {\n        int currentOffset = 0;\n        int numElementValuePairs = 0;\n        int annotationOffset = currentOffset;\n        currentOffset = readElementValues(null, currentOffset, false, null);\n        System.out.println(\"currentOffset = \" + currentOffset);\n        System.out.println(\"numElementValuePairs = \" + numElementValuePairs);\n    }\n}\n\nResp\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.run();\n    }\n\n    public void run() {\n        int currentOffset = 0;\n        int numElementValuePairs = 0;\n        int annotationOffset = currentOffset;\n        currentOffset = readElementValues(null,"}, {"ID": 973, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int readVerificationTypeInfo( final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) { int currentOffset = verificationTypeInfoOffset; int tag = b[currentOffset++] & 0xFF; switch (tag) { case Frame.ITEM_TOP: frame[index] = Opcodes.TOP; break; case Frame.ITEM_INTEGER: frame[index] = Opcodes.INTEGER; break; case Frame.ITEM_FLOAT: frame[index] = Opcodes.FLOAT; break; case Frame.ITEM_DOUBLE: frame[index] = Opcodes.DOUBLE; break; case Frame.ITEM_LONG: frame[index] = Opcodes.LONG; break; case Frame.ITEM_NULL: frame[index] = Opcodes.NULL; break; case Frame.ITEM_UNINITIALIZED_THIS: frame[index] = Opcodes.UNINITIALIZED_THIS; break; case Frame.ITEM_OBJECT: frame[index] = readClass(currentOffset, charBuffer); currentOffset += 2; break; case Frame.ITEM_UNINITIALIZED: frame[index] = createLabel(readUnsignedShort(currentOffset), labels); currentOffset += 2; break; default: throw new IllegalArgumentException(); } return currentOffset; } \nResponse:", "ground_truth": "Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\narray.\n\n@param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\nread.\n@param frame the array where the parsed type must be stored.\n@param index the index in 'frame' where the parsed type must be stored.\n@param charBuffer the buffer used to read strings in the constant pool.\n@param labels the labels of the method currently being parsed, indexed by their offset. If the\nparsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\nstored in this array if it does not already exist.\n@return the end offset of the JVMS 'verification_type_info' structure.", "predict": "\npublic static int readFrameType(final int frameOffset, final Object[] frame) { int tag = b[frameOffset++] & 0xFF; switch (tag) { case Frame.ITEM_TOP: return Opcodes.TOP; case Frame.ITEM_INTEGER: return Opcodes.INTEGER; case Frame.ITEM_FLOAT: return Opcodes.FLOAT; case Frame.ITEM_DOUBLE: return Opcodes.DOUBLE; case Frame.ITEM_LONG: return Opcodes.LONG; case Frame.ITEM_NULL: return Opcodes.NULL; case Frame.ITEM_UNINITIALIZED_THIS: return Opcodes.UNINITIALIZED_THIS; case Frame.ITEM_OBJECT: return Opcodes.OBJECT; case Frame.ITEM_UNINITIALIZED: return Opcodes.UNINITIALIZED; default: throw new IllegalArgumentException(); } } "}, {"ID": 974, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int[] readBootstrapMethodsAttribute(final int maxStringLength) { char[] charBuffer = new char[maxStringLength]; int currentAttributeOffset = getFirstAttributeOffset(); int[] currentBootstrapMethodOffsets = null; for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { // Read the attribute_info's attribute_name and attribute_length fields. String attributeName = readUTF8(currentAttributeOffset, charBuffer); int attributeLength = readInt(currentAttributeOffset + 2); currentAttributeOffset += 6; if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { // Read the num_bootstrap_methods field and create an array of this size. currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)]; // Compute and store the offset of each 'bootstrap_methods' array field entry. int currentBootstrapMethodOffset = currentAttributeOffset + 2; for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) { currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset; // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each), // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2). currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2; } return currentBootstrapMethodOffsets; } currentAttributeOffset += attributeLength; } return null; } \nResponse:", "ground_truth": "Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n\n@param maxStringLength a conservative estimate of the maximum length of the strings contained\nin the constant pool of the class.\n@return the offsets of the bootstrap methods or null.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleBuilder;\nimport org.apache.commons.lang3.tuple.Triple.TripleType;\nimport org.apache.commons.lang3.tuple.Triple.TripleTypeBuilder;\nimport org.apache.commons.lang3.tuple.TripleType.TripleTypeBuilder;\nimport org.apache.commons"}, {"ID": 975, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CtorDescriptor[] inspectConstructors() { Class type = classDescriptor.getType(); Constructor[] ctors = type.getDeclaredConstructors(); CtorDescriptor[] allCtors = new CtorDescriptor[ctors.length]; for (int i = 0; i < ctors.length; i++) { Constructor ctor = ctors[i]; CtorDescriptor ctorDescriptor = createCtorDescriptor(ctor); allCtors[i] = ctorDescriptor; if (ctorDescriptor.isDefault()) { defaultCtor = ctorDescriptor; } } return allCtors; } \nResponse:", "ground_truth": "Inspects all declared constructors of a target type.", "predict": "\n\n*/\n\npublic class CtorDescriptor {\n    private final Constructor constructor;\n    private final boolean isDefault;\n\n    public CtorDescriptor(Constructor constructor, boolean isDefault) {\n        this.constructor = constructor;\n        this.isDefault = isDefault;\n    }\n\n    public Constructor getConstructor() {\n        return constructor;\n    }\n\n    public boolean isDefault() {\n        return isDefault;\n    }\n}\n"}, {"ID": 976, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CtorDescriptor getCtorDescriptor(final Class... args) { ctors: for (CtorDescriptor ctorDescriptor : allCtors) { Class[] arg = ctorDescriptor.getParameters(); if (arg.length != args.length) { continue; } for (int j = 0; j < arg.length; j++) { if (arg[j] != args[j]) { continue ctors; } } return ctorDescriptor; } return null; } \nResponse:", "ground_truth": "Finds constructor description that matches given argument types.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.method();\n    }\n\n    public void method() {\n        System.out.println(\"Hello World!\");\n    }\n}\n"}, {"ID": 977, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) { return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME); } \nResponse:", "ground_truth": "", "predict": " Resp @SuppressWarnings(\"unchecked\") protected Map<String, TransientBeanData> getResponseMap(final HttpServletResponse servletResponse) { return (Map<String, TransientBeanData>) servletResponse.getAttribute(ATTR_NAME); } \n\n*/\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.TreeSet;\nimport java.util.TreeMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java."}, {"ID": 978, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) { Map<String, TransientBeanData> map = new HashMap<>(); servletRequest.setAttribute(ATTR_NAME, map); return map; } \nResponse:", "ground_truth": "Creates instance map and stores it in the request.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 979, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected long[] convertArrayToArray(final Object value) { final Class valueComponentType = value.getClass().getComponentType(); final long[] result; if (valueComponentType.isPrimitive()) { result = convertPrimitiveArrayToArray(value, valueComponentType); } else { // convert object array to target array final Object[] array = (Object[]) value; result = new long[array.length]; for (int i = 0; i < array.length; i++) { result[i] = convertType(array[i]); } } return result; } \nResponse:", "ground_truth": "Converts array value to array.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.convert(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,"}, {"ID": 980, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final FilterConfig filterConfig) throws ServletException { // final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER); if (decoraManagerClass != null) { try { final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass); decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType); } catch (Exception ex) { log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex); throw new ServletException(ex); } } else { decoraManager = createDecoraManager(); } // final String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER); if (decoraParserClass != null) { try { final Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass); decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType); } catch (Exception ex) { log.error(\"Unable to load Decora parser class: \" + decoraParserClass, ex); throw new ServletException(ex); } } else { decoraParser = createDecoraParser(); } // final String decoraCache = filterConfig.getInitParameter(PARAM_DECORA_CACHE); if (decoraCache != null) { cached = Converter.get().toBoolean(decoraCache, false); } } \nResponse:", "ground_truth": "Initializes Decora filter. Loads manager and parser from init parameters.", "predict": "\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport java.util.List;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double to Double.\n */\npublic class DoubleToDoubleOperatorTerm extends GenericStackableOperatorTerm<Double>\n  implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleToDoubleOperatorTerm(Term<Double> base, Term<Double> applicant) {\n    super(base, applicant);\n  }"}, {"ID": 981, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile onFile(final Consumer<File> fileConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer); } else { consumers.add(fileConsumer); } return this; } \nResponse:", "ground_truth": "Registers file consumer", "predict": " public FindFile onFile(final Consumer<File> fileConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer); } else { consumers.add(fileConsumer); } return this; } \nResp public FindFile onFile(final Consumer<File> fileConsumer, final Consumer<Throwable> errorConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer, errorConsumer); } else { consumers.add(fileConsumer, errorConsumer); } return this; } \nResp public FindFile onFile(final Consumer<File> fileConsumer, final Consumer<Throwable> errorConsumer, final Runnable onComplete) { if (consumers == null) { consumers = Consumers.of(fileConsumer, errorConsumer, onComplete); } else { consumers.add(fileConsumer, errorConsumer, onComplete); } return this; } \nResp public FindFile onFile(final Consumer<File> fileConsumer, final Consumer<Throwable>"}, {"ID": 982, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile searchPath(final URI searchPath) { File file; try { file = new File(searchPath); } catch (Exception ex) { throw new FindFileException(\"URI error: \" + searchPath, ex); } addPath(file); return this; } \nResponse:", "ground_truth": "Specifies the search path. Throws an exception if URI is invalid.", "predict": " public FindFile searchPath(final URI searchPath) { File file; try { file = new File(searchPath); } catch (Exception ex) { throw new FindFileException(\"URI error: \" + searchPath, ex); } addPath(file); return this; } \n\n*/\n\npublic class FindFile {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new FindFile object.\n\t\tFindFile findFile = new FindFile();\n\t\t\n\t\t// TODO: Add a new path to the list of paths.\n\t\tfindFile.addPath(new File(\"/home/user/path/to/file\"));\n\t\t\n\t\t// TODO: Add a new path to the list of paths.\n\t\tfindFile.addPath(new File(\"/home/user/path/to/file2\"));\n\t\t\n\t\t// TODO: Add a new path to the list of paths.\n\t\tfindFile.add"}, {"ID": 983, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile searchPath(final URL searchPath) { File file = FileUtil.toContainerFile(searchPath); if (file == null) { throw new FindFileException(\"URL error: \" + searchPath); } addPath(file); return this; } \nResponse:", "ground_truth": "Specifies the search path. Throws an exception if URL is invalid.", "predict": " public FindFile searchPath(final URL searchPath) { File file = FileUtil.toContainerFile(searchPath); if (file == null) { throw new FindFileException(\"URL error: \" + searchPath); } addPath(file); return this; } \n\n*/\n\npublic class FindFile {\n\t\n\tprivate static final String SEARCH_PATH = \"searchPath\";\n\tprivate static final String SEARCH_PATH_URL = \"searchPathURL\";\n\tprivate static final String SEARCH_PATH_FILE = \"searchPathFile\";\n\tprivate static final String SEARCH_PATH_FILE_URL = \"searchPathFileURL\";\n\tprivate static final String SEARCH_PATH_FILE_PATH = \"searchPathFilePath\";\n\tprivate static final String SEARCH_PATH_FILE_PATH_URL = \"searchPathFilePathURL\";\n\t\n\tprivate static final String SEARCH_PATH_URL_ERROR = \"URL error: \";\n\tprivate static final String"}, {"ID": 984, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile include(final String... patterns) { for (String pattern : patterns) { rules.include(pattern); } return this; } \nResponse:", "ground_truth": "Defines include patterns.", "predict": " Resp public FindFile include(final String... patterns) { for (String pattern : patterns) { rules.include(pattern); } return this; } \n\n*/\n\npublic class FindFile {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 985, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile exclude(final String... patterns) { for (String pattern : patterns) { rules.exclude(pattern); } return this; } \nResponse:", "ground_truth": "Defines exclude patterns.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 986, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addPath(final File path) { if (!path.exists()) { return; } if (pathList == null) { pathList = new LinkedList<>(); } pathList.add(path); } \nResponse:", "ground_truth": "Adds existing search path to the file list.\nNon existing files are ignored.\nIf path is a folder, it will be scanned for all files.", "predict": " void\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.addPath(new File(\"/home/lionel/Desktop/test\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test2\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test3\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test4\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test5\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test6\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test7\"));\n        s.addPath(new File(\"/home/lionel/Desktop/test8\"));\n        s."}, {"ID": 987, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<File> findAll() { List<File> allFiles = new ArrayList<>(); File file; while ((file = nextFile()) != null) { allFiles.add(file); } return allFiles; } \nResponse:", "ground_truth": "Finds all files and returns list of founded files.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 988, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void init() { rules.detectMode(); todoFiles = new LinkedList<>(); todoFolders = new LinkedList<>(); if (pathList == null) { pathList = new LinkedList<>(); return; } if (pathListOriginal == null) { pathListOriginal = (LinkedList<File>) pathList.clone(); } String[] files = new String[pathList.size()]; int index = 0; Iterator<File> iterator = pathList.iterator(); while (iterator.hasNext()) { File file = iterator.next(); if (file.isFile()) { files[index++] = file.getAbsolutePath(); iterator.remove(); } } if (index != 0) { FilesIterator filesIterator = new FilesIterator(files); todoFiles.add(filesIterator); } } \nResponse:", "ground_truth": "Initializes file walking.\nSeparates input files and folders.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] pathList = scanner.nextLine().split(\" \");\n        List<File> pathListOriginal = new ArrayList<>();\n        for (String path : pathList) {\n            File file = new File(path);\n            if (file.isDirectory()) {\n                pathListOriginal.add(file);\n            }\n        }\n        scanner.close();\n        String[] files = scanner.nextLine().split(\" \");\n        List<File> todoFiles = new ArrayList<>();\n        List<File> todoFolders = new ArrayList<>();\n        for (String file : files) {\n"}, {"ID": 989, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Iterator<File> iterator() { return new Iterator<File>() { private File nextFile; @Override public boolean hasNext() { nextFile = nextFile(); return nextFile != null; } @Override public File next() { if (nextFile == null) { throw new NoSuchElementException(); } return nextFile; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } \nResponse:", "ground_truth": "Returns file walking iterator.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 990, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WiringMode resolveBeanWiringMode(final Class type) { PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class); return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT; } \nResponse:", "ground_truth": "Resolves bean's auto-wire flag from the annotation. Returns default auto-wire if annotation doesn't exist.", "predict": " public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class type) { return WiringMode.DEFAULT; } \nResp public WiringMode resolveBeanWiringMode(final Class"}, {"ID": 991, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveBeanName(final Class type, final boolean useLongTypeName) { PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class); String name = null; if (petiteBean != null) { name = petiteBean.value().trim(); } if ((name == null) || (name.length() == 0)) { if (useLongTypeName) { name = type.getName(); } else { name = StringUtil.uncapitalize(type.getSimpleName()); } } return name; } \nResponse:", "ground_truth": "Resolves bean's name from bean annotation or type name. May be used for resolving bean name\nof base type during registration of bean subclass.", "predict": " public String resolveBeanName(final Class type, final boolean useLongTypeName) { PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class); String name = null; if (petiteBean != null) { name = petiteBean.value().trim(); } if ((name == null) || (name.length() == 0)) { if (useLongTypeName) { name = type.getName(); } else { name = StringUtil.uncapitalize(type.getSimpleName()); } } return name; } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface PetiteBean {\n    "}, {"ID": 992, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PrintWriter getWriter() { if (outWriter == null) { if (outStream != null) { throw new IllegalStateException(\"Can't call getWriter() after getOutputStream()\"); } bufferedWriter = new FastCharArrayWriter(); outWriter = new PrintWriter(bufferedWriter) { @Override public void close() { // do not close the print writer after rendering // since it will remove reference to bufferedWriter } }; } return outWriter; } \nResponse:", "ground_truth": "Returns a writer.", "predict": "\n\n*/\n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Response {\n\n    private static final Logger LOGGER = Logger.getLogger(Response.class.getName());\n\n    private final PrintWriter outWriter;\n    private final BufferedWriter bufferedWriter;\n    private final OutputStream outStream;\n\n    public Response(OutputStream outStream) {\n        this.outStream = outStream;\n        this.outWriter = new PrintWriter(new OutputStreamWriter(outStream));\n        this.bufferedWriter = new BufferedWriter(outWriter);\n    }\n\n    public PrintWriter getWriter() {\n        return outWriter;\n    }\n\n    public BufferedWriter"}, {"ID": 993, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ServletOutputStream getOutputStream() { if (outStream == null) { if (outWriter != null) { throw new IllegalStateException(\"Can't call getOutputStream() after getWriter()\"); } bufferOutputStream = new FastByteArrayServletOutputStream(); outStream = bufferOutputStream; } return outStream; } \nResponse:", "ground_truth": "Returns a servlet output stream.", "predict": " public ServletOutputStream getOutputStream() { return outStream; } \n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Locale;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FastByteArrayServletOutputStream extends ServletOutputStream {\n    private PrintWriter outWriter;\n    private byte[] buffer;\n    private int bufferSize;\n    private int bufferPosition;\n    private int contentLength;\n    private boolean closed;\n\n    public FastByteArrayServletOutputStream() {\n        this(1024);\n    }\n\n    public FastByteArrayServletOutputStream(int bufferSize) {\n        this.bufferSize = bufferSize;\n        buffer = new byte[bufferSize];\n    }\n\n    public void setContentLength(int content"}, {"ID": 994, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { stringBuilder.append(\"[]\"); } return stringBuilder.toString(); case OBJECT: case INTERNAL: return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.'); default: throw new AssertionError(); } } \nResponse:", "ground_truth": "Returns the binary name of the class corresponding to this type. This method must not be used\non method types.\n\n@return the binary name of the class corresponding to this type.", "predict": " public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { stringBuilder.append(\"[]\"); } return stringBuilder.toString(); case OBJECT: case INTERNAL: return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.'); default: throw new AssertionError(); } } \n"}, {"ID": 995, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getConstructorDescriptor(final Constructor<?> constructor) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = constructor.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } return stringBuilder.append(\")V\").toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given constructor.\n\n@param constructor a {@link Constructor} object.\n@return the descriptor of the given constructor.", "predict": " public static String getConstructorDescriptor(final Constructor<?> constructor) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = constructor.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } return stringBuilder.append(\")V\").toString(); } \n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getConstructorDescriptor(Main.class.getDeclaredConstructors()[0]));\n    }\n}\n"}, {"ID": 996, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); for (Type argumentType : argumentTypes) { argumentType.appendDescriptor(stringBuilder); } stringBuilder.append(')'); returnType.appendDescriptor(stringBuilder); return stringBuilder.toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given argument and return types.\n\n@param returnType the return type of the method.\n@param argumentTypes the argument types of the method.\n@return the descriptor corresponding to the given argument and return types.", "predict": " public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); for (Type argumentType : argumentTypes) { argumentType.appendDescriptor(stringBuilder); } stringBuilder.append(')'); returnType.appendDescriptor(stringBuilder); return stringBuilder.toString(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MethodDescriptor {\n    private final String methodName;\n    private final List<Type> argumentTypes;\n    private final Type returnType;\n\n    public MethodDescriptor(String methodName, List<Type> argumentTypes, Type returnType) {\n        this.methodName = methodName;\n        this.argumentTypes = argumentTypes;\n        this.returnType = returnType;\n    }\n\n    public String getMethodName() {\n        return methodName;\n"}, {"ID": 997, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getMethodDescriptor(final Method method) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = method.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } stringBuilder.append(')'); appendDescriptor(method.getReturnType(), stringBuilder); return stringBuilder.toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given method.\n\n@param method a {@link Method} object.\n@return the descriptor of the given method.", "predict": " public static String getMethodDescriptor(final Method method) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = method.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } stringBuilder.append(')'); appendDescriptor(method.getReturnType(), stringBuilder); return stringBuilder.toString(); } \n\n*/\n\npublic class MethodDescriptor {\n    private final String methodName;\n    private final String methodDescriptor;\n\n    public MethodDescriptor(String methodName, String methodDescriptor) {\n        this.methodName = methodName;\n        this.methodDescriptor = methodDescriptor;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public String getMethodDescriptor() {\n        return methodDescriptor;\n    }\n}\n"}, {"ID": 998, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void appendDescriptor(final StringBuilder stringBuilder) { if (sort == OBJECT) { stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';'); } else { stringBuilder.append(valueBuffer, valueBegin, valueEnd); } } \nResponse:", "ground_truth": "Appends the descriptor corresponding to this type to the given string buffer.\n\n@param stringBuilder the string builder to which the descriptor must be appended.", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"private void appendDescriptor(final StringBuilder stringBuilder) { if (sort == OBJECT) { stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';'); } else { stringBuilder.append(valueBuffer, valueBegin, valueEnd); } } \n        \");\n        stringBuilder.append(\"public void main(String[] args) {\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder.append(\"\\n\");\n        stringBuilder"}, {"ID": 999, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getSize() { switch (sort) { case VOID: return 0; case BOOLEAN: case CHAR: case BYTE: case SHORT: case INT: case FLOAT: case ARRAY: case OBJECT: case INTERNAL: return 1; case LONG: case DOUBLE: return 2; default: throw new AssertionError(); } } \nResponse:", "ground_truth": "Returns the size of values of this type. This method must not be used for method types.\n\n@return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n{@code void} and 1 otherwise.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.run();\n    }\n\n    public void run() {\n        List<String> list = new ArrayList<>();\n        list.add(\"VOID\");\n        list.add(\"BOOLEAN\");\n        list.add(\"CHAR\");\n        list.add(\"BYTE\");\n        list.add(\"SHORT\");\n        list.add(\"INT\");\n        list.add(\"FLOAT\");\n        list.add(\"ARRAY\");\n        list.add(\"OBJECT\");\n        list.add(\"INTERNAL\");\n        list.add(\"LONG\");\n        list.add(\"DOUBLE\");\n        list.add(\"OBJECT\");\n        list.add(\"OBJECT\");\n        list.add(\"OBJECT\");"}, {"ID": 1000, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int getArgumentsAndReturnSizes(final String methodDescriptor) { int argumentsSize = 1; // Skip the first character, which is always a '('. int currentOffset = 1; int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration. while (currentChar != ')') { if (currentChar == 'J' || currentChar == 'D') { currentOffset++; argumentsSize += 2; } else { while (methodDescriptor.charAt(currentOffset) == '[') { currentOffset++; } if (methodDescriptor.charAt(currentOffset++) == 'L') { // Skip the argument descriptor content. currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1; } argumentsSize += 1; } currentChar = methodDescriptor.charAt(currentOffset); } currentChar = methodDescriptor.charAt(currentOffset + 1); if (currentChar == 'V') { return argumentsSize << 2; } else { int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1; return argumentsSize << 2 | returnSize; } } \nResponse:", "ground_truth": "Computes the size of the arguments and of the return value of a method.\n\n@param methodDescriptor a method descriptor.\n@return the size of the arguments of the method (plus one for the implicit this argument),\nargumentsSize, and the size of its return value, returnSize, packed into a single int i =\n{@code (argumentsSize << 2) | returnSize} (argumentsSize is therefore equal to {@code\ni >> 2}, and returnSize to {@code i & 0x03}).", "predict": "\n\npublic static int getArgumentsAndReturnSizes(final String methodDescriptor) {\n    int argumentsSize = 1; // Skip the first character, which is always a '('.\n    int currentOffset = 1;\n    int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration.\n    while (currentChar != ')') {\n        if (currentChar == 'J' || currentChar == 'D') {\n            currentOffset++;\n            argumentsSize += 2;\n        } else {\n            while (methodDescriptor.charAt(currentOffset) == '[') {\n                currentOffset++;\n            }\n            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n                // Skip the argument descriptor content.\n                currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;\n            }\n            argumentsSize"}, {"ID": 1001, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = th; status = STATUS_MARKED_ROLLBACK; } \nResponse:", "ground_truth": "Modify the transaction associated with the target object such that the only possible outcome\nof the transaction is to roll back the transaction.", "predict": " public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = th; status = STATUS_MARKED_ROLLBACK; } \nResp public void setRollbackOnly() { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = null; status = STATUS_MARKED_ROLLBACK; } \nResp public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status !="}, {"ID": 1002, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void commitOrRollback(boolean doCommit) { if (log.isDebugEnabled()) { if (doCommit) { log.debug(\"Commit JTX\"); } else { log.debug(\"Rollback JTX\"); } } boolean forcedRollback = false; if (!isNoTransaction()) { if (isRollbackOnly()) { if (doCommit) { doCommit = false; forcedRollback = true; } } else if (!isActive()) { if (isCompleted()) { throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\"); } throw new JtxException(\"No active TX to \" + (doCommit ? \"commit\" : \"rollback\")); } } if (doCommit) { commitAllResources(); } else { rollbackAllResources(forcedRollback); } } \nResponse:", "ground_truth": "Performs either commit or rollback on all transaction resources.", "predict": "\n\n*/\n\npublic class JtxTransactionManager extends AbstractTransactionManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JtxTransactionManager.class);\n\n    private static final String JTX_TRANSACTION_MANAGER_NAME = \"JTX_TRANSACTION_MANAGER\";\n\n    private static final String JTX_TRANSACTION_MANAGER_NAME_PROPERTY = \"jtx.transaction.manager.name\";\n\n    private static final String JTX_TRANSACTION_MANAGER_NAME_DEFAULT = \"JTX_TRANSACTION_MANAGER\";\n\n    private static final String JTX_TRANSACTION_MANAGER_NAME_PROPERTY_DEFAULT = \"JTX_TRANSACTION_MANAGER\";\n\n    private static final String JTX_TRANSACTION_MANAGER_NAME_PROPERTY_DESCRIPTION = \"The name of the JTX Transaction Manager\";\n\n    private"}, {"ID": 1003, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void rollbackAllResources(final boolean wasForced) { status = STATUS_ROLLING_BACK; Exception lastException = null; Iterator<JtxResource> it = resources.iterator(); while (it.hasNext()) { JtxResource resource = it.next(); try { resource.rollbackTransaction(); } catch (Exception ex) { lastException = ex; } finally { it.remove(); } } txManager.removeTransaction(this); status = STATUS_ROLLEDBACK; if (lastException != null) { status = STATUS_UNKNOWN; throw new JtxException(\"Rollback failed: one or more TX resources couldn't rollback a TX\", lastException); } if (wasForced) { throw new JtxException(\"TX rolled back because it has been marked as rollback-only\", rollbackCause); } } \nResponse:", "ground_truth": "Rollbacks all attached resources. Resource will be closed. and detached from this transaction.\nIf exception occurs, it will be rethrown at the end.", "predict": "\n\n*/\n\npublic class JtxRollbackAll extends JtxAbstractResource {\n    private static final long serialVersionUID = 1L;\n\n    public JtxRollbackAll(JtxTransactionManager txManager) {\n        super(txManager);\n    }\n\n    @Override\n    public void rollback() {\n        if (status != STATUS_ACTIVE) {\n            throw new JtxException(\"Transaction is not active\");\n        }\n        txManager.removeTransaction(this);\n        status = STATUS_ROLLEDBACK;\n    }\n}\n"}, {"ID": 1004, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E requestResource(final Class<E> resourceType) { if (isCompleted()) { throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\"); } if (isRollbackOnly()) { throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause); } if (!isNoTransaction() && !isActive()) { throw new JtxException(\"Resources are not available since TX is not active\"); } checkTimeout(); E resource = lookupResource(resourceType); if (resource == null) { int maxResources = txManager.getMaxResourcesPerTransaction(); if ((maxResources != -1) && (resources.size() >= maxResources)) { throw new JtxException(\"TX already has attached max. number of resources\"); } JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType); resource = resourceManager.beginTransaction(mode, isActive()); resources.add(new JtxResource<>(this, resourceManager, resource)); } return resource; } \nResponse:", "ground_truth": "Requests a resource. If resource is not found, it will be created and new transaction will be started on it.", "predict": " public <E> E requestResource(final Class<E> resourceType, final Response<E> response) { if (isCompleted()) { throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\"); } if (isRollbackOnly()) { throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause); } if (!isNoTransaction() && !isActive()) { throw new JtxException(\"Resources are not available since TX is not active\"); } checkTimeout(); E resource = lookupResource(resourceType); if (resource == null) { int maxResources = txManager.getMaxResourcesPerTransaction(); if ((maxResources != -1) && (resources.size() >= maxResources)) { throw new JtxException(\"TX already has attached max. number of resources\"); } JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType); resource = resourceManager.beginTransaction(mode, isActive()); resources"}, {"ID": 1005, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void popName() { if (isPushed) { if (pushedComma) { writeComma(); } String name = pushedName; pushedName = null; isPushed = false; writeName(name); } } \nResponse:", "ground_truth": "Writes stored name to JSON string. Cleans storage.", "predict": "\n\n*/\n\npublic class PopName {\n\tpublic static void main(String[] args) {\n\t\tString name = \"\";\n\t\tboolean isPushed = false;\n\t\tboolean pushedComma = false;\n\t\tboolean pushedName = false;\n\t\t\n\t\tname = \"\";\n\t\tisPushed = false;\n\t\tpushedComma = false;\n\t\tpushedName = false;\n\t\t\n\t\tname = \"\";\n\t\tisPushed = false;\n\t\tpushedComma = false;\n\t\tpushedName = false;\n\t\t\n\t\tname = \"\";\n\t\tisPushed = false;\n\t\tpushedComma = false;\n\t\tpushedName = false;\n\t\t\n\t\tname = \"\";\n\t\tisPushed = false;\n\t\tpushedComma = false;\n\t\tpushedName = false;\n\t\t\n\t\tname = \"\";\n\t\tisPushed = false;\n\t\tpushedComma = false;\n"}, {"ID": 1006, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeString(final String value) { popName(); write(StringPool.QUOTE); int len = value.length(); for (int i = 0; i < len; i++) { char c = value.charAt(i); switch (c) { case '\"': write(\"\\\\\\\"\"); break; case '\\\\': write(\"\\\\\\\\\"); break; case '/': if (strictStringEncoding) { write(\"\\\\/\"); } else { write(c); } break; case '\\b': write(\"\\\\b\"); break; case '\\f': write(\"\\\\f\"); break; case '\\n': write(\"\\\\n\"); break; case '\\r': write(\"\\\\r\"); break; case '\\t': write(\"\\\\t\"); break; default: if (Character.isISOControl(c)) { unicode(c); } else { write(c); } } } write(StringPool.QUOTE); } \nResponse:", "ground_truth": "Write a quoted and escaped value to the output.", "predict": "\n\n*/\n\npublic class StringEncoder {\n    private static final StringPool stringPool = new StringPool();\n    private static final String[] hex = stringPool.hex;\n    private static final char[] escape = stringPool.escape;\n\n    public static void write(final char c) {\n        if (c < 0x20 || c > 0x7e) {\n            writeEscape(c);\n        } else {\n            writeDirect(c);\n        }\n    }\n\n    public static void write(final String s) {\n        final int len = s.length();\n        for (int i = 0; i < len; i++) {\n            write(s.charAt(i));\n        }\n    }\n\n    public static void writeEscape(final char c) {\n        writeDirect(escape[(c >> 12) & 15]);\n        writeDirect(escape[(c >> 8) & 15]);\n        writeDirect(escape[("}, {"ID": 1007, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void unicode(final char c) { write(\"\\\\u\"); int n = c; for (int i = 0; i < 4; ++i) { int digit = (n & 0xf000) >> 12; char hex = CharUtil.int2hex(digit); write(hex); n <<= 4; } } \nResponse:", "ground_truth": "Writes unicode representation of a character.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        String s = \"abc\";\n        System.out.println(s.codePointAt(0));\n        System.out.println(s.codePointAt(1));\n        System.out.println(s.codePointAt(2));\n        System.out.println(s.codePointAt(3));\n        System.out.println(s.codePointAt(4));\n        System.out.println(s.codePointAt(5));\n        System.out.println(s.codePointAt(6));\n        System.out.println(s.codePointAt(7));\n        System.out.println(s.codePointAt(8));\n        System.out.println(s.codePointAt(9));\n        System"}, {"ID": 1008, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void write(final CharSequence charSequence) { popName(); try { out.append(charSequence); } catch (IOException ioex) { throw new JsonException(ioex); } } \nResponse:", "ground_truth": "Appends char sequence to the buffer. Used for numbers, nulls, booleans, etc.", "predict": " Response is generated by the method-level comment.\n\n*/\n\npublic class JsonGenerator {\n\tprivate static final String TAG = \"JsonGenerator\";\n\tprivate static final String JSON_GENERATOR_CLASS = \"JsonGenerator\";\n\tprivate static final String JSON_GENERATOR_METHOD = \"write\";\n\tprivate static final String JSON_GENERATOR_RESPONSE = \"Response\";\n\tprivate static final String JSON_GENERATOR_NAME = \"JsonGenerator\";\n\tprivate static final String JSON_GENERATOR_PACKAGE = \"com.example.jsongenerator\";\n\tprivate static final String JSON_GENERATOR_PACKAGE_PATH = \"/\" + JSON_GENERATOR_PACKAGE.replace(\".\", \"/\");\n\tprivate static final String JSON_GENERATOR_PACKAGE_PATH_WITH_SLASH = JSON_GENERATOR_PACKAGE_PATH + \"/\";\n\tprivate static"}, {"ID": 1009, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) { logLevel = logLevel.trim().toUpperCase(); parsingErrorLogLevel = Logger.Level.valueOf(logLevel); return this; } \nResponse:", "ground_truth": "Sets parsing error log level as a name.", "predict": "\n\n*/\n\npublic class LagartoDomBuilderConfig {\n    private static final String TAG = \"LagartoDomBuilderConfig\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_NAME = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_VALUE = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_NAME_VALUE = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_VALUE_VALUE = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_NAME_VALUE_VALUE = \"ERROR\";\n    private static final String DEFAULT_PARSING_ERROR_LOG_LEVEL_NAME_VALUE_VALUE_VALUE = \""}, {"ID": 1010, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startRegion(final int start, final int tagLen, final int deepLevel) { this.regionStart = start + tagLen; this.regionLength = 0; this.regionTagStart = start; this.deepLevel = deepLevel; } \nResponse:", "ground_truth": "Starts defining region by setting the start index and reset region length to zero.", "predict": " public void endRegion(final int tagLen, final int deepLevel) { this.regionLength = tagLen; this.regionTagEnd = this.regionStart - tagLen; this.deepLevel = deepLevel; } \nResp public void endRegion(final int tagLen, final int deepLevel, final int tagCount) { this.regionLength = tagLen; this.regionTagEnd = this.regionStart - tagLen; this.deepLevel = deepLevel; } \nResp public void endRegion(final int tagLen, final int deepLevel, final int tagCount, final int tagCount2) { this.regionLength = tagLen; this.regionTagEnd = this.regionStart - tagLen; this.deepLevel = deepLevel; } \nResp public void endRegion(final int tagLen, final int deepLevel, final int tagCount, final int tagCount2, final int tagCount3) { this.regionLength = tagLen; this.regionTagEnd ="}, {"ID": 1011, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isContaining(final String include) { if (value == null) { return false; } if (splits == null) { splits = StringUtil.splitc(value, ' '); } for (String s: splits) { if (s.equals(include)) { return true; } } return false; } \nResponse:", "ground_truth": "Returns true if attribute is containing some value.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.isContaining(\"aa bb cc\"));\n    }\n\n    public boolean isContaining(String s) {\n        if (s == null) {\n            return false;\n        }\n        if (s.length() == 0) {\n            return false;\n        }\n        if (s.length() == 1) {\n            return true;\n        }\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] == 0) {\n                return false;\n            }\n        }\n        return true;\n"}, {"ID": 1012, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pseudoFunctionType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction); } \nResponse:", "ground_truth": "Registers pseudo function.", "predict": "\n\n*/\n\npublic class PseudoFunction extends CSSellyFunction {\n\t\n\tpublic PseudoFunction(String pseudoFunctionName) {\n\t\tsuper(pseudoFunctionName);\n\t}\n\t\n\t@Override\n\tpublic String getJavaCode() {\n\t\treturn \"public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pseudoFunctionType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction); } \";\n\t}\n\t\n\t@Override\n\tpublic String getCSSText() {\n\t\treturn \"public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pse"}, {"ID": 1013, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName); if (pseudoFunction == null) { throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName); } return pseudoFunction; } \nResponse:", "ground_truth": "Lookups pseudo function for given pseudo function name.", "predict": " public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName); if (pseudoFunction == null) { throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName); } return pseudoFunction; } \n\n*/\n\npublic class PseudoFunction extends CSSellyASTNode {\n\t\n\tprivate final String pseudoFunctionName;\n\t\n\tpublic PseudoFunction(final String pseudoFunctionName) {\n\t\tthis.pseudoFunctionName = pseudoFunctionName;\n\t}\n\t\n\tpublic String getPseudoFunctionName() {\n\t\treturn pseudoFunctionName;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"PseudoFunction [pseudoFunctionName=\" + pseudoFunctionName + \"]\";\n\t}\n\t\n\t@Override\n\tpublic void accept(CSSellyNodeVisitor"}, {"ID": 1014, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) { wd.init(name, superName, this.suffix, this.reqProxyClassName); // change access of destination access &= ~AsmUtil.ACC_ABSTRACT; // write destination class final int v = ProxettaAsmUtil.resolveJavaVersion(version); wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null); wd.proxyAspects = new ProxyAspectData[aspects.length]; for (int i = 0; i < aspects.length; i++) { wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i); } } \nResponse:", "ground_truth": "Creates destination subclass header from current target class. Destination name is created from targets by\nadding a suffix and, optionally, a number. Destination extends the target.", "predict": "\n\n*/\n\npublic class ProxyAspectData {\n    public final Aspect aspect;\n    public final int index;\n    public final ProxyAspectData parent;\n    public final String suffix;\n    public final String reqProxyClassName;\n    public final String proxyClassName;\n    public final String proxyClassNameSuffix;\n    public final String proxyClassNameSuffixSuffix;\n    public final String proxyClassNameSuffixSuffixSuffix;\n    public final String proxyClassNameSuffixSuffixSuffixSuffix;\n    public final String proxyClassNameSuffixSuffixSuffixSuffixSuffix;\n    public final String proxyClassNameSuffixSuffixSuffixSuffixSuffixSuffix;\n    public final String proxyClassNameSuffixSuffixSuffixSuffixSuffixSuffixSuffix;\n    public final String proxy"}, {"ID": 1015, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3] return new AnnotationVisitorAdapter(destAnn); } \nResponse:", "ground_truth": "Copies all destination type annotations to the target.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.Attribute.TypeCompound;\nimport com.sun.tools"}, {"ID": 1016, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void makeStaticInitBlock() { if (wd.adviceClinits != null) { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null); mv.visitCode(); for (String name : wd.adviceClinits) { mv.visitMethodInsn( INVOKESTATIC, wd.thisReference, name, DESC_VOID, false); } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } } \nResponse:", "ground_truth": "Creates static initialization block that simply calls all\nadvice static init methods in correct order.", "predict": "\n\npublic static void main(String[] args) {\n\ttry {\n\t\tClass<?> clazz = Class.forName(\"com.example.Test\");\n\t\tMethod method = clazz.getMethod(\"makeStaticInitBlock\");\n\t\tmethod.invoke(null);\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n}\n\n*/\n"}, {"ID": 1017, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void makeProxyConstructor() { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null); mv.visitCode(); if (wd.adviceInits != null) { for (String name : wd.adviceInits) { mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn (INVOKESPECIAL, wd.thisReference, name, DESC_VOID, false); } } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } \nResponse:", "ground_truth": "Creates init method that simply calls all advice constructor methods in correct order.\nThis created init method is called from each destination's constructor.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.makeProxyConstructor();\n    }\n\n    protected void makeProxyConstructor() {\n        MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null);\n        mv.visitCode();\n        if (wd.adviceInits != null) {\n            for (String name : wd.adviceInits) {\n                mv.visitVarInsn(ALOAD, 0);\n                mv.visitMethodInsn (INVOKESPECIAL, wd.thisReference, name, DESC_VOID, false);\n            }\n        }\n        mv.visitInsn(RETURN);\n        m"}, {"ID": 1018, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void processSuperMethods() { for (ClassReader cr : targetClassInfo.superClassReaders) { cr.accept(new EmptyClassVisitor() { String declaredClassName; @Override public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) { declaredClassName = name; } @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { if (name.equals(INIT) || name.equals(CLINIT)) { return null; } MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName); if (msign == null) { return null; } return applyProxy(msign); } }, 0); } } \nResponse:", "ground_truth": "Checks for all public super methods that are not overridden.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.MethodNode;\n\npublic class ProxyGenerator {\n\tprivate static final String INIT = \"<init>\";\n\tprivate static final"}, {"ID": 1019, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int findLast(int low, int high) { int ndx = -1; while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(mid); if (delta > 0) { high = mid - 1; } else { if (delta == 0) { ndx = mid; } low = mid + 1; } } if (ndx == -1) { return -(low + 1); } return ndx; } \nResponse:", "ground_truth": "Finds very last index of given element in inclusive index range. Returns negative\nvalue if element is not found.", "predict": "\n\npublic int findLast(int low, int high) { int ndx = -1; while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(mid); if (delta > 0) { high = mid - 1; } else { if (delta == 0) { ndx = mid; } low = mid + 1; } } if (ndx == -1) { return -(low + 1); } return ndx; }\n\n*/\n\npublic class Solution {\n    public int findLast(int A[], int n) {\n        int low = 0;\n        int high = n - 1;\n        int mid;\n        while (low <= high) {\n            mid = (low + high) >>> 1;\n            if (A[mid] > A[high]) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        "}, {"ID": 1020, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String on(final String string) { if (!enabled) { return string; } final StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix).append(\"m\"); } sb.append(string); if (suffix != null) { sb.append(suffix).append(\"m\"); } return sb.toString(); } \nResponse:", "ground_truth": "Returns chalked string.", "predict": " public String on(final String string) { if (!enabled) { return string; } final StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix).append(\"m\"); } sb.append(string); if (suffix != null) { sb.append(suffix).append(\"m\"); } return sb.toString(); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String PREFIX = \"public class JavaCodeGenerator {\\n\";\n\tprivate static final String SUFFIX = \"}\";\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(PREFIX);\n\t\tsb.append(\"public class JavaCodeGenerator {\\n\");\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"\tpublic static void main(String[] args) {\\n\");\n\t\tsb.append(\""}, {"ID": 1021, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) { final Attribute[] attributes = getAttributePrototypes(); firstField = null; lastField = null; firstMethod = null; lastMethod = null; lastRuntimeVisibleAnnotation = null; lastRuntimeInvisibleAnnotation = null; lastRuntimeVisibleTypeAnnotation = null; lastRuntimeInvisibleTypeAnnotation = null; moduleWriter = null; nestHostClassIndex = 0; numberOfNestMemberClasses = 0; nestMemberClasses = null; firstAttribute = null; compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING; new ClassReader(classFile, 0, /* checkClassVersion = */ false) .accept( this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS); return toByteArray(); } \nResponse:", "ground_truth": "Returns the equivalent of the given class file, with the ASM specific instructions replaced\nwith standard ones. This is done with a ClassReader -> ClassWriter round trip.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            Class<?> clazz = Class.forName(\"Test\");\n            byte[] classFile = clazz.getClassLoader().getResourceAsStream(\"Test.class\").readAllBytes();\n            byte[] bytes = replaceAsmInstructions(classFile, false);\n            FileOutputStream fos = new FileOutputStream(\"Test.class\");\n            fos.write(bytes);\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n*/\n"}, {"ID": 1022, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Attribute[] getAttributePrototypes() { Attribute.Set attributePrototypes = new Attribute.Set(); attributePrototypes.addAttributes(firstAttribute); FieldWriter fieldWriter = firstField; while (fieldWriter != null) { fieldWriter.collectAttributePrototypes(attributePrototypes); fieldWriter = (FieldWriter) fieldWriter.fv; } MethodWriter methodWriter = firstMethod; while (methodWriter != null) { methodWriter.collectAttributePrototypes(attributePrototypes); methodWriter = (MethodWriter) methodWriter.mv; } return attributePrototypes.toArray(); } \nResponse:", "ground_truth": "Returns the prototypes of the attributes used by this class, its fields and its methods.\n\n@return the prototypes of the attributes used by this class, its fields and its methods.", "predict": " Response = new Response(getAttributePrototypes()); \n */\n\npublic class FieldWriter {\n\t\n\tprivate FieldWriter parent;\n\tprivate FieldWriter fieldWriter;\n\tprivate MethodWriter methodWriter;\n\tprivate String fieldName;\n\tprivate String methodName;\n\tprivate String methodSignature;\n\tprivate String fieldSignature;\n\tprivate String fieldType;\n\tprivate String methodType;\n\tprivate String fieldTypeName;\n\tprivate String methodTypeName;\n\tprivate String fieldTypeName2;\n\tprivate String methodTypeName2;\n\tprivate String fieldTypeName3;\n\tprivate String methodTypeName3;\n\tprivate String fieldTypeName4;\n\tprivate String methodTypeName4;\n\tprivate String fieldTypeName5;\n\tprivate String methodTypeName5;\n\tprivate String fieldTypeName6;\n\tprivate String methodTypeName6;\n\tprivate String fieldTypeName7;\n\tprivate String methodTypeName7;\n\tprivate"}, {"ID": 1023, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerDefaults() { register(Integer.class, IntegerSqlType.class); register(int.class, IntegerSqlType.class); register(MutableInteger.class, IntegerSqlType.class); register(Float.class, FloatSqlType.class); register(float.class, FloatSqlType.class); register(MutableFloat.class, FloatSqlType.class); register(Double.class, DoubleSqlType.class); register(double.class, DoubleSqlType.class); register(MutableDouble.class, DoubleSqlType.class); register(Byte.class, ByteSqlType.class); register(byte.class, ByteSqlType.class); register(MutableByte.class, ByteSqlType.class); register(Boolean.class, BooleanSqlType.class); register(boolean.class, BooleanSqlType.class); register(MutableBoolean.class, BooleanSqlType.class); register(Long.class, LongSqlType.class); register(long.class, LongSqlType.class); register(MutableLong.class, LongSqlType.class); register(Short.class, ShortSqlType.class); register(short.class, ShortSqlType.class); register(MutableShort.class, ShortSqlType.class); register(Character.class, CharacterSqlType.class); register(char.class, CharacterSqlType.class); register(BigDecimal.class, BigDecimalSqlType.class); register(BigInteger.class, BigIntegerSqlType.class); register(String.class, StringSqlType.class); register(LocalDateTime.class, LocalDateTimeSqlType.class); register(LocalDate.class, LocalDateSqlType.class); register(LocalTime.class, LocalTimeSqlType.class); register(Date.class, SqlDateSqlType.class); register(Timestamp.class, TimestampSqlType.class); register(Time.class, TimeSqlType.class); register(java.util.Date.class, DateSqlType.class); register(JulianDate.class, JulianDateSqlType.class); register(byte[].class, ByteArraySqlType.class); register(URL.class, URLSqlType.class); register(Blob.class, BlobSqlType.class); register(Clob.class, ClobSqlType.class); register(Array.class, SqlArraySqlType.class); register(Ref.class, SqlRefSqlType.class); } \nResponse:", "ground_truth": "Registers default set of SQL types.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView.Type;\nimport com.google.common.collect.Sets.SetView.Type.Equality;\nimport com.google.common.collect.Sets.SetView.Type.TransitiveEquality;\nimport com.google.common.collect.Sets.SetView.Type.TransitiveTransitivity;\nimport com.google.common.collect.Sets.SetView"}, {"ID": 1024, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) { types.put(type, lookupSqlType(sqlTypeClass)); } \nResponse:", "ground_truth": "Registers sql type for provided type.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1025, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SqlType lookup(final Class clazz) { SqlType sqlType; for (Class x = clazz; x != null; x = x.getSuperclass()) { sqlType = types.get(clazz); if (sqlType != null) { return sqlType; } Class[] interfaces = x.getInterfaces(); for (Class i : interfaces) { sqlType = types.get(i); if (sqlType != null) { return sqlType; } } } return null; } \nResponse:", "ground_truth": "Retrieves SQL type for provided type. All subclasses and interfaces are examined\nfor matching sql type.", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SqlType {\n    private static Map<Class, SqlType> types = new HashMap<Class, SqlType>();\n\n    public static SqlType get(Class clazz) {\n        SqlType sqlType = types.get(clazz);\n        if (sqlType == null) {\n            sqlType = new SqlType(clazz);\n            types.put(clazz, sqlType);\n        }\n        return sqlType;\n    }\n\n    private Class clazz;\n    private String name;\n    private String description;\n    private String jdbcType;\n    private String javaType;\n    private String javaTypeName;\n    private String javaTypeNameShort;\n    private String javaTypeNameLong;\n    private String javaTypeNameFull;\n    private String javaTypeNameFullShort;\n    private String javaType"}, {"ID": 1026, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) { SqlType sqlType = sqlTypes.get(sqlTypeClass); if (sqlType == null) { try { sqlType = ClassUtil.newInstance(sqlTypeClass); } catch (Exception ex) { throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex); } sqlTypes.put(sqlTypeClass, sqlType); } return sqlType; } \nResponse:", "ground_truth": "Returns sql type instance. Instances are stored for better performances.", "predict": " public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) { return lookupSqlType(sqlTypeClass); } \n\n*/\n\npublic class SqlTypeLookup {\n\tprivate static final Map<Class<? extends SqlType>, SqlType> sqlTypes = new HashMap<Class<? extends SqlType>, SqlType>();\n\t\n\tpublic static SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) {\n\t\tSqlType sqlType = sqlTypes.get(sqlTypeClass);\n\t\tif (sqlType == null) {\n\t\t\ttry {\n\t\t\t\tsqlType = ClassUtil.newInstance(sqlTypeClass);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex);\n\t\t\t}\n\t\t\tsqlTypes.put(sqlTypeClass, sqlType);\n\t\t}\n\t\t"}, {"ID": 1027, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null); } \nResponse:", "ground_truth": "Creates SOCKS4 proxy.", "predict": " Resp public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp Resp public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp Resp public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp Resp public static ProxyInfo httpsProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType"}, {"ID": 1028, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResponse:", "ground_truth": "Creates SOCKS5 proxy.", "predict": " Response is generated by the following java Code. Code: public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ProxyInfo {\n\tprivate ProxyType proxyType;\n\tprivate String proxyAddress;\n\tprivate int proxyPort;\n\tprivate String proxyUser;\n\tprivate String proxyPassword;\n\t\n\tpublic ProxyInfo(ProxyType proxyType, String proxyAddress, int proxyPort, String proxyUser, String proxyPassword) {\n\t\tthis.proxyType = proxyType;\n\t\tthis.proxyAddress = proxyAddress;\n\t\tthis.proxyPort = proxyPort;\n\t\tthis.proxyUser = proxyUser;\n\t\tthis.proxyPassword = proxyPassword;\n\t}\n\t"}, {"ID": 1029, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResponse:", "ground_truth": "Creates HTTP proxy.", "predict": " public static ProxyInfo httpsProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTPS, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp public static ProxyInfo socksProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResp public static ProxyInfo socks4aProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS4A,"}, {"ID": 1030, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int totalThreadTransactions() { ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { return 0; } return txList.size(); } \nResponse:", "ground_truth": "Returns total number of transactions associated with current thread.", "predict": " public int totalThreadTransactions() { return txStack.get().size(); }\n\n*/\n\npublic class JtxThreadLocal extends ThreadLocal<ArrayList<JtxTransaction>> {\n    public JtxThreadLocal() {\n        super();\n    }\n\n    public void set(ArrayList<JtxTransaction> txList) {\n        super.set(txList);\n    }\n\n    public ArrayList<JtxTransaction> get() {\n        return super.get();\n    }\n}\n"}, {"ID": 1031, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int totalThreadTransactionsWithStatus(final JtxStatus status) { ArrayList<JtxTransaction> txlist = txStack.get(); if (txlist == null) { return 0; } int count = 0; for (JtxTransaction tx : txlist) { if (tx.getStatus() == status) { count++; } } return count; } \nResponse:", "ground_truth": "Returns total number of transactions of the specified status associated with current thread.", "predict": "\n\n*/\n\npublic class JtxStatus {\n    public static final int STATUS_ACTIVE = 1;\n    public static final int STATUS_COMMITTED = 2;\n    public static final int STATUS_ROLLED_BACK = 3;\n    public static final int STATUS_PREPARED = 4;\n    public static final int STATUS_COMMITTING = 5;\n    public static final int STATUS_ROLLING_BACK = 6;\n    public static final int STATUS_PREPARING = 7;\n    public static final int STATUS_ROLLING_BACK_ROLLED_BACK = 8;\n    public static final int STATUS_ROLLING_BACK_COMMITTED = 9;\n    public static final int STATUS_ROLLING_BACK_PREPARED = 10;\n    public static final int STATUS_ROLLING_BACK_COMMITTING = 11;\n    public static final int STAT"}, {"ID": 1032, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void associateTransaction(final JtxTransaction tx) { totalTransactions++; ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { txList = new ArrayList<>(); txStack.set(txList); } txList.add(tx); // add last } \nResponse:", "ground_truth": "Associate transaction to current thread.", "predict": "\n\n*/\n\npublic class JtxTransactionStack {\n    private final List<JtxTransaction> txList = new ArrayList<>();\n    private final AtomicInteger totalTransactions = new AtomicInteger(0);\n\n    public JtxTransactionStack() {\n    }\n\n    public JtxTransactionStack(final JtxTransactionStack txStack) {\n        txList.addAll(txStack.txList);\n        totalTransactions.addAndGet(txStack.totalTransactions.get());\n    }\n\n    public JtxTransactionStack(final JtxTransaction tx) {\n        txList.add(tx);\n        totalTransactions.incrementAndGet();\n    }\n\n    public JtxTransactionStack(final JtxTransactionStack txStack) {\n        txList.addAll(txStack.txList);\n        totalTransactions.addAndGet(txStack.totalTransactions.get());\n    }\n\n    public JtxTransactionStack(final List<Jtx"}, {"ID": 1033, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) { if (!validateExistingTransaction) { return; } JtxTransactionMode sourceMode = sourceTx.getTransactionMode(); JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel(); if (destIsolationLevel != ISOLATION_DEFAULT) { JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel(); if (currentIsolationLevel != destIsolationLevel) { throw new JtxException(\"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel); } } if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) { throw new JtxException(\"Participating TX is not marked as read-only, but existing TX is\"); } } \nResponse:", "ground_truth": "Check if propagation of a transaction is possible, due to source and destination transaction modes.\n@see #setValidateExistingTransaction(boolean)", "predict": "\n\n*/\n\npackage com.arjuna.ats.internal.jta.transaction.jts.subordinate;\n\nimport com.arjuna.ats.arjuna.common.Uid;\nimport com.arjuna.ats.arjuna.coordinator.ActionStatus;\nimport com.arjuna.ats.arjuna.coordinator.AddOutcome;\nimport com.arjuna.ats.arjuna.coordinator.RecordType;\nimport com.arjuna.ats.arjuna.coordinator.TwoPhaseOutcome;\nimport com.arjuna.ats.arjuna.state.InputObjectState;\nimport com.arjuna.ats.internal.jta.transaction.jts.orbspecific.TransactionImple;\nimport com.arjuna.ats.internal.jta.transaction.jts.orbspecific.TransactionImple_impl;\nimport com"}, {"ID": 1034, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; } \nResponse:", "ground_truth": "Lookups resource manager for provided type. Throws an exception if provider doesn't exists.", "predict": " public <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; } \n\n}\n"}, {"ID": 1035, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected C createProxyObject(Class<C> target) { target = ProxettaUtil.resolveTargetClass(target); Class proxyClass = cache.get(target); if (proxyClass == null) { proxyClass = proxetta.defineProxy(target); cache.put(target, proxyClass); } C proxy; try { proxy = (C) ClassUtil.newInstance(proxyClass); } catch (Exception ex) { throw new PathrefException(ex); } return proxy; } \nResponse:", "ground_truth": "Creates proxy object.", "predict": "\n\n*/\n\npackage com.tremolosecurity.proxy.util;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.tremolosecurity.proxy.util.ProxyUtil.Target;\n\npublic class ProxyUtil {\n\n\tpublic static Map<Target,Class> cache = new HashMap<Target,Class>();\n\t\n\tpublic static Class getProxyClass(Target target) {\n\t\tClass clazz = cache.get(target);\n\t\tif (clazz == null) {\n\t\t\tclazz = createProxyClass(target);\n\t\t\tcache.put(target, clazz);\n\t\t}\n\t\treturn clazz;\n\t}\n\t\n\tpublic static Class createProxyClass(Target target) {\n\t\tClass clazz = null;\n\t\ttry {\n\t\t\tclazz = Class.forName(target.getTargetClass());\n\t\t} catch"}, {"ID": 1036, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void append(final String methodName) { if (path.length() != 0) { path += StringPool.DOT; } if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) { path = StringUtil.substring(path, 0, -1); } path += methodName; } \nResponse:", "ground_truth": "Appends method name to existing path.", "predict": "\n\n*/\n\npublic class AppendMethodComment extends AbstractJavaMethod {\n\n\tpublic static final String CLASS_NAME = \"AppendMethodComment\";\n\n\tpublic static final String METHOD_NAME = \"append\";\n\n\tpublic static final String JAVA_CODE = \"protected void append(final String methodName) {\\n\" +\n\t\t\t\"\tif (path.length() != 0) {\\n\" +\n\t\t\t\"\t\tpath += StringPool.DOT;\\n\" +\n\t\t\t\"\t}\\n\" +\n\t\t\t\"\tif (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) {\\n\" +\n\t\t\t\"\t\tpath = StringUtil.substring(path, 0, -1);\\n\" +\n\t\t\t\"\t}\\n\" +\n\t\t\t\"\tpath += methodName;\\n\" +\n\t\t\t\"}\";\n\n\t@Override\n\tpublic String getClassName() {\n\t\treturn CLASS_NAME;\n\t}"}, {"ID": 1037, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String alignLeftAndPad(final String text, final int size) { int textLength = text.length(); if (textLength > size) { return text.substring(0, size); } final StringBuilder sb = new StringBuilder(size); sb.append(text); while (textLength++ < size) { sb.append(' '); } return sb.toString(); } \nResponse:", "ground_truth": "Puts the text to the left and pads with spaces until the size is reached.", "predict": "\n\npublic static String alignLeftAndPad(final String text, final int size) { int textLength = text.length(); if (textLength > size) { return text.substring(0, size); } final StringBuilder sb = new StringBuilder(size); sb.append(text); while (textLength++ < size) { sb.append(' '); } return sb.toString(); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String text = \"Hello World\";\n        int size = text.length();\n        System.out.println(text);\n        System.out.println(alignLeftAndPad(text, size));\n    }\n    \n    public static String alignLeftAndPad(String text, int size) {\n        int textLength = text.length();\n        if (textLength > size) {\n            return text.substring(0, size);\n        }\n        "}, {"ID": 1038, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toPrettyString(final Object value) { if (value == null) { return StringPool.NULL; } final Class<?> type = value.getClass(); if (type.isArray()) { final Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { final StringBuilder sb = new StringBuilder(); sb.append('['); if (componentType == int.class) { sb.append(ArraysUtil.toString((int[]) value)); } else if (componentType == long.class) { sb.append(ArraysUtil.toString((long[]) value)); } else if (componentType == double.class) { sb.append(ArraysUtil.toString((double[]) value)); } else if (componentType == float.class) { sb.append(ArraysUtil.toString((float[]) value)); } else if (componentType == boolean.class) { sb.append(ArraysUtil.toString((boolean[]) value)); } else if (componentType == short.class) { sb.append(ArraysUtil.toString((short[]) value)); } else if (componentType == byte.class) { sb.append(ArraysUtil.toString((byte[]) value)); } else { throw new IllegalArgumentException(); } sb.append(']'); return sb.toString(); } else { final StringBuilder sb = new StringBuilder(); sb.append('['); final Object[] array = (Object[]) value; for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(array[i])); } sb.append(']'); return sb.toString(); } } else if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final StringBuilder sb = new StringBuilder(); sb.append('{'); int i = 0; for (final Object o : iterable) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(o)); i++; } sb.append('}'); return sb.toString(); } return value.toString(); } \nResponse:", "ground_truth": "Converts object into pretty string. All arrays are iterated.", "predict": " public static String toPrettyString(final Object value) { if (value == null) { return StringPool.NULL; } final Class<?> type = value.getClass(); if (type.isArray()) { final Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { final StringBuilder sb = new StringBuilder(); sb.append('['); if (componentType == int.class) { sb.append(ArraysUtil.toString((int[]) value)); } else if (componentType == long.class) { sb.append(ArraysUtil.toString((long[]) value)); } else if (componentType == double.class) { sb.append(ArraysUtil.toString((double[]) value)); } else if (componentType == float.class) { sb.append(ArraysUtil.toString((float[]) value)); } else if (componentType == boolean.class) { sb."}, {"ID": 1039, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) { final int length = input.length(); final StringBuilder sb = new StringBuilder(length); boolean upperCase = firstCharUppercase; for (int i = 0; i < length; i++) { final char ch = input.charAt(i); if (ch == separator) { upperCase = true; } else if (upperCase) { sb.append(Character.toUpperCase(ch)); upperCase = false; } else { sb.append(ch); } } return sb.toString(); } \nResponse:", "ground_truth": "Converts separated string value to CamelCase.", "predict": "\n\npublic static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) {\n    final int length = input.length();\n    final StringBuilder sb = new StringBuilder(length);\n    boolean upperCase = firstCharUppercase;\n    for (int i = 0; i < length; i++) {\n        final char ch = input.charAt(i);\n        if (ch == separator) {\n            upperCase = true;\n        } else if (upperCase) {\n            sb.append(Character.toUpperCase(ch));\n            upperCase = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.toCamelCase"}, {"ID": 1040, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) { StringBuilder str = new StringBuilder(); int total = src.length(); int from = 0; while (from < total) { int to = from + len; if (to >= total) { to = total; } else if (breakOnWhitespace) { int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from); if (ndx != -1) { to = ndx + 1; } } int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to); if (cutFrom != -1) { int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1; str.append(src, cutFrom, cutTo); } str.append('\\n'); from = to; } return str.toString(); } \nResponse:", "ground_truth": "Formats provided string as paragraph.", "predict": "\n\npublic static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) { StringBuilder str = new StringBuilder(); int total = src.length(); int from = 0; while (from < total) { int to = from + len; if (to >= total) { to = total; } else if (breakOnWhitespace) { int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from); if (ndx != -1) { to = ndx + 1; } } int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to); if (cutFrom != -1) { int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1; str.append(src, cutFrom, cutTo); } str.append('\\n'); from = to; } return str.toString(); } \n\n*/"}, {"ID": 1041, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String convertTabsToSpaces(final String line, final int tabWidth) { int tab_index, tab_size; int last_tab_index = 0; int added_chars = 0; if (tabWidth == 0) { return StringUtil.remove(line, '\\t'); } StringBuilder result = new StringBuilder(); while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) { tab_size = tabWidth - ((tab_index + added_chars) % tabWidth); if (tab_size == 0) { tab_size = tabWidth; } added_chars += tab_size - 1; result.append(line, last_tab_index, tab_index); result.append(StringUtil.repeat(' ', tab_size)); last_tab_index = tab_index+1; } if (last_tab_index == 0) { return line; } result.append(line.substring(last_tab_index)); return result.toString(); } \nResponse:", "ground_truth": "Converts all tabs on a line to spaces according to the provided tab width.\nThis is not a simple tab to spaces replacement, since the resulting\nindentation remains the same.", "predict": "\n\npublic static String convertTabsToSpaces(final String line, final int tabWidth) { int tab_index, tab_size; int last_tab_index = 0; int added_chars = 0; if (tabWidth == 0) { return StringUtil.remove(line, '\\t'); } StringBuilder result = new StringBuilder(); while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) { tab_size = tabWidth - ((tab_index + added_chars) % tabWidth); if (tab_size == 0) { tab_size = tabWidth; } added_chars += tab_size - 1; result.append(line, last_tab_index, tab_index); result.append(StringUtil.repeat(' ', tab_size)); last_tab_index = tab_index+1; } if (last_tab_index == 0) { return line; } result.append(line"}, {"ID": 1042, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String escapeJava(final String string) { int strLen = string.length(); StringBuilder sb = new StringBuilder(strLen); for (int i = 0; i < strLen; i++) { char c = string.charAt(i); switch (c) { case '\\b' : sb.append(\"\\\\b\"); break; case '\\t' : sb.append(\"\\\\t\"); break; case '\\n' : sb.append(\"\\\\n\"); break; case '\\f' : sb.append(\"\\\\f\"); break; case '\\r' : sb.append(\"\\\\r\"); break; case '\\\"' : sb.append(\"\\\\\\\"\"); break; case '\\\\' : sb.append(\"\\\\\\\\\"); break; default: if ((c < 32) || (c > 127)) { String hex = Integer.toHexString(c); sb.append(\"\\\\u\"); for (int k = hex.length(); k < 4; k++) { sb.append('0'); } sb.append(hex); } else { sb.append(c); } } } return sb.toString(); } \nResponse:", "ground_truth": "Escapes a string using java rules.", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(in.next());\n        }\n        System.out.println(escapeJava(sb.toString()));\n    }\n\n    public static String escapeJava(String string) {\n        int strLen = string.length();\n        StringBuilder sb = new StringBuilder(strLen);\n        for (int i = 0; i < strLen; i++) {\n            char c = string.charAt(i);\n            switch (c) {\n                case '\\b':\n                    sb.append(\"\\\\b\");\n                    break;\n                case '\\t':\n                    "}, {"ID": 1043, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String unescapeJava(final String str) { char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(str.length()); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c != '\\\\') { sb.append(c); continue; } i++; c = chars[i]; switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\\\"'); break; case '\\\\': sb.append('\\\\'); break; case 'u' : char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16); sb.append(hex); i += 4; break; default: throw new IllegalArgumentException(\"Invalid escaping character: \" + c); } } return sb.toString(); } \nResponse:", "ground_truth": "Unescapes a string using java rules.", "predict": "\n\npublic static String unescapeJava(final String str) { char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(str.length()); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c != '\\\\') { sb.append(c); continue; } i++; c = chars[i]; switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\\\"'); break; case '\\\\': sb.append('\\\\'); break; case 'u' : char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16"}, {"ID": 1044, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final Class<T> type) { String name = resolveBeanName(type); return (T) getBean(name); } \nResponse:", "ground_truth": "Returns Petite bean instance. Bean name will be resolved from provided type.", "predict": " @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final String name) { return (T) getBean(name, new HashMap()); } \nResp @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final String name, final Map<String, Object> args) { return (T) getBean(name, args, new HashMap()); } \nResp @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final String name, final Map<String, Object> args, final Map<String, Object> context) { return (T) getBean(name, args, context, new HashMap()); } \nResp @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final String name, final Map<String, Object> args, final Map<String, Object> context, final Map<String,"}, {"ID": 1045, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T getBean(final String name) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name); if (def == null) { // try provider ProviderDefinition providerDefinition = providers.get(name); if (providerDefinition != null) { return (T) invokeProvider(providerDefinition); } return null; } // Find the bean in its scope Object bean = def.scopeLookup(); if (bean == null) { // Create new bean in the scope initBeanDefinition(def); final BeanData beanData = new BeanData(this, def); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData); bean = beanData.bean(); } return (T) bean; } \nResponse:", "ground_truth": "Returns Petite bean instance.\nPetite container will find the bean in corresponding scope and all its dependencies,\neither by constructor or property injection. When using constructor injection, cyclic dependencies\ncan not be prevented, but at least they are detected.\n\n@see PetiteContainer#createBean(Class)", "predict": " public <T> T getBean(final String name) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name); if (def == null) { // try provider ProviderDefinition providerDefinition = providers.get(name); if (providerDefinition != null) { return (T) invokeProvider(providerDefinition); } return null; } // Find the bean in its scope Object bean = def.scopeLookup(); if (bean == null) { // Create new bean in the scope initBeanDefinition(def); final BeanData beanData = new BeanData(this, def); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData); bean = beanData.bean(); } return (T) bean; } \n\n}\n"}, {"ID": 1046, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initBeanDefinition(final BeanDefinition def) { // init methods if (def.initMethods == null) { def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type); } // destroy methods if (def.destroyMethods == null) { def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type); } // properties if (def.properties == null) { def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // methods if (def.methods == null) { def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type); } // ctors if (def.ctor == null) { def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type); } // values if (def.values == null) { def.values = paramManager.resolveParamInjectionPoints(def.type); } // sets if (def.sets == null) { def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // params if (def.params == null) { def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters()); } } \nResponse:", "ground_truth": "Resolves and initializes bean definition. May be called multiple times.", "predict": "\n\n*/\n\npackage com.petitevents.controller.petitevents;\n\nimport com.petitevents.controller.petitevents.model.Event;\nimport com.petitevents.controller.petitevents.model.EventType;\nimport com.petitevents.controller.petitevents.model.EventTypeId;\nimport com.petitevents.controller.petitevents.model.EventTypeRepository;\nimport com.petitevents.controller.petitevents.model.EventTypeRepositoryImpl;\nimport com.petitevents.controller.petitevents.model.EventTypeRepositoryImpl.EventTypeRepositoryImplException;\nimport com.petitevents.controller.petitevents.model.EventTypeRepositoryImpl.EventTypeRepositoryImplException2;\nimport com.petitevents.controller.petitevents.model.EventTypeRepository"}, {"ID": 1047, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeProvider(final ProviderDefinition provider) { if (provider.method != null) { final Object bean; if (provider.beanName != null) { // instance factory method bean = getBean(provider.beanName); } else { // static factory method bean = null; } try { return provider.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid provider method: \" + provider.method.getName(), ex); } } throw new PetiteException(\"Invalid provider\"); } \nResponse:", "ground_truth": "Invokes provider to get a bean.", "predict": " public Object invoke(final Request request) { if (request.method != null) { final Object bean; if (request.beanName != null) { // instance method bean = getBean(request.beanName); } else { // static method bean = null; } try { return request.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid method: \" + request.method.getName(), ex); } } throw new PetiteException(\"Invalid method\"); } \n\n*/\n\npackage petite.providers;\n\nimport java.lang.reflect.Method;\n\nimport petite.Bean;\nimport petite.PetiteException;\nimport petite.Request;\nimport petite.Response;\n\n/**\n * Abstract base class for provider implementations.\n * \n * @author Juergen Hoeller\n * @since 13.06.2003\n */\npublic abstract class AbstractProvider implements Provider\n{\n\t/**\n\t * The bean"}, {"ID": 1048, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addBean(final String name, final Object bean, WiringMode wiringMode) { wiringMode = petiteConfig.resolveWiringMode(wiringMode); registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null); BeanDefinition def = lookupExistingBeanDefinition(name); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean)); } \nResponse:", "ground_truth": "Adds object instance to the container as singleton bean.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.RuntimeBeanReference;\nimport org.springframework.beans.factory.support.AbstractBeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.support.ManagedList;\nimport org.springframework.beans.factory.support.ManagedMap;\nimport org.springframework.beans.factory.support.ManagedSet;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;\nimport org.springframework"}, {"ID": 1049, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setBeanProperty(final String name, final Object value) { Object bean = null; int ndx = name.length(); while (true) { ndx = name.lastIndexOf('.', ndx); if (ndx == -1) { break; } String beanName = name.substring(0, ndx); bean = getBean(beanName); if (bean != null) { break; } ndx--; } if (bean == null) { throw new PetiteException(\"Invalid bean property: \" + name); } try { BeanUtil.declared.setProperty(bean, name.substring(ndx + 1), value); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } } \nResponse:", "ground_truth": "Sets petite bean property.", "predict": "\n\n*/\n\npublic class BeanUtil {\n\n    public static Object getBean(String name) {\n        Object bean = null;\n        try {\n            bean = PetiteContainer.getPetite().getBean(name);\n        } catch (PetiteException ex) {\n            throw new PetiteException(\"Invalid bean name: \" + name, ex);\n        }\n        return bean;\n    }\n\n    public static void declared(Object bean, String name, Object value) {\n        try {\n            BeanUtil.declared.setProperty(bean, name, value);\n        } catch (Exception ex) {\n            throw new PetiteException(\"Invalid bean property: \" + name, ex);\n        }\n    }\n\n    public static void declared(Object bean, String name) {\n        try {\n            BeanUtil.declared.getProperty(bean, name);\n        } catch (Exception ex) {\n            throw new Petite"}, {"ID": 1050, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getBeanProperty(final String name) { int ndx = name.indexOf('.'); if (ndx == -1) { throw new PetiteException(\"Only bean name is specified, missing property name: \" + name); } String beanName = name.substring(0, ndx); Object bean = getBean(beanName); if (bean == null) { throw new PetiteException(\"Bean doesn't exist: \" + name); } try { return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1)); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } } \nResponse:", "ground_truth": "Returns petite bean property value.", "predict": " public Object getBeanProperty(final String name) { int ndx = name.indexOf('.'); if (ndx == -1) { throw new PetiteException(\"Only bean name is specified, missing property name: \" + name); } String beanName = name.substring(0, ndx); Object bean = getBean(beanName); if (bean == null) { throw new PetiteException(\"Bean doesn't exist: \" + name); } try { return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1)); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } } \n\n*/\n\npublic class BeanUtil {\n\t\n\tpublic static final String BEAN_PROPERTY_PREFIX = \"bean.\";\n\tpublic static final String BEAN_PROPERTY_SUFFIX = \"Property\";\n\t\n\tpublic static Object getProperty("}, {"ID": 1051, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void shutdown() { scopes.forEachValue(Scope::shutdown); externalsCache.clear(); beans.clear(); beansAlt.clear(); scopes.clear(); providers.clear(); beanCollections.clear(); } \nResponse:", "ground_truth": "Shutdowns container. After container is down, it can't be used anymore.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache"}, {"ID": 1052, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) { Class[] paramTypes; Class declaringClass; String name; if (methodOrCtor instanceof Method) { Method method = (Method) methodOrCtor; paramTypes = method.getParameterTypes(); name = method.getName(); declaringClass = method.getDeclaringClass(); } else { Constructor constructor = (Constructor) methodOrCtor; paramTypes = constructor.getParameterTypes(); declaringClass = constructor.getDeclaringClass(); name = CTOR_METHOD; } if (paramTypes.length == 0) { return MethodParameter.EMPTY_ARRAY; } InputStream stream; try { stream = ClassLoaderUtil.getClassAsStream(declaringClass); } catch (IOException ioex) { throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex); } if (stream == null) { throw new ParamoException(\"Class not found: \" + declaringClass); } try { ClassReader reader = new ClassReader(stream); MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes); reader.accept(visitor, 0); return visitor.getResolvedParameters(); } catch (IOException ioex) { throw new ParamoException(ioex); } finally { StreamUtil.close(stream); } } \nResponse:", "ground_truth": "Resolves method parameters from a method or constructor.\nReturns an empty array when target does not contain any parameter.\nNo caching is involved in this process, i.e. class bytecode\nis examined every time this method is called.", "predict": " public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor, final ClassLoader classLoader) { Class[] paramTypes; Class declaringClass; String name; if (methodOrCtor instanceof Method) { Method method = (Method) methodOrCtor; paramTypes = method.getParameterTypes(); name = method.getName(); declaringClass = method.getDeclaringClass(); } else { Constructor constructor = (Constructor) methodOrCtor; paramTypes = constructor.getParameterTypes(); declaringClass = constructor.getDeclaringClass(); name = CTOR_METHOD; } if (paramTypes.length == 0) { return MethodParameter.EMPTY_ARRAY; } InputStream stream; try { stream = ClassLoaderUtil.getClassAsStream(declaringClass, classLoader); } catch (IOException ioex) { throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex); } if (stream == null) { throw new"}, {"ID": 1053, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int doAfterBody() throws JspException { BodyContent body = getBodyContent(); JspWriter out = body.getEnclosingWriter(); String bodytext = populateForm(body.getString(), name -> value(name, pageContext)); try { out.print(bodytext); } catch (IOException ioex) { throw new JspException(ioex); } return SKIP_BODY; } \nResponse:", "ground_truth": "Performs smart form population.", "predict": " @Override public int doEndTag() throws JspException { try { return EVAL_PAGE; } catch (IOException ioex) { throw new JspException(ioex); } } \nResp @Override public int doStartTag() throws JspException { try { return EVAL_BODY_INCLUDE; } catch (IOException ioex) { throw new JspException(ioex); } } \nResp @Override public int doAfterBody() throws JspException { BodyContent body = getBodyContent(); JspWriter out = body.getEnclosingWriter(); String bodytext = populateForm(body.getString(), name -> value(name, pageContext)); try { out.print(bodytext); } catch (IOException ioex) { throw new JspException(ioex); } return SKIP_BODY; } \nResp @Override public int doEndTag() throws JspException { try { return EVAL_PAGE; } catch"}, {"ID": 1054, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getValue(final String... profiles) { if (hasMacro) { return propsData.resolveMacros(value, profiles); } return value; } \nResponse:", "ground_truth": "Returns the property value, with replaced macros.", "predict": " public String getValue(final String... profiles) { if (hasMacro) { return propsData.resolveMacros(value, profiles); } return value; } \n\n*/\n\npublic class MacroProperty extends Property {\n\t\n\tprivate String value;\n\tprivate boolean hasMacro;\n\t\n\tpublic MacroProperty(String name, String value, boolean hasMacro) {\n\t\tsuper(name);\n\t\tthis.value = value;\n\t\tthis.hasMacro = hasMacro;\n\t}\n\t\n\tpublic String getValue(String... profiles) {\n\t\tif (hasMacro) {\n\t\t\treturn propsData.resolveMacros(value, profiles);\n\t\t}\n\t\treturn value;\n\t}\n\t\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\t\n\tpublic boolean hasMacro() {\n\t\treturn hasMacro;\n\t}\n\t\n\tpublic void setValue(String value) {\n"}, {"ID": 1055, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void end() { if (parentNode != rootNode) { Node thisNode = parentNode; while (thisNode != rootNode) { if (domBuilder.config.isImpliedEndTags()) { if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) { thisNode = thisNode.getParentNode(); continue; } } error(\"Unclosed tag closed: <\" + thisNode.getNodeName() + \">\"); thisNode = thisNode.getParentNode(); } } // remove whitespaces if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } // foster if (domBuilder.config.isUseFosterRules()) { HtmlFosterRules fosterRules = new HtmlFosterRules(); fosterRules.fixFosterElements(rootNode); } // elapsed rootNode.end(); if (log.isDebugEnabled()) { log.debug(\"LagartoDom tree created in \" + rootNode.getElapsedTime() + \" ms\"); } } \nResponse:", "ground_truth": "Finishes the tree building. Closes unclosed tags.", "predict": "\n\n*/\n\npackage com.icloudmoo.weixin.controller.web;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.icloudmoo.weixin.controller.web.util.HttpUtil;\nimport com.icloudmoo.weixin.controller.web.util"}, {"ID": 1056, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Element createElementNode(final Tag tag) { boolean hasVoidTags = htmlVoidRules != null; boolean isVoid = false; boolean selfClosed = false; if (hasVoidTags) { isVoid = htmlVoidRules.isVoidTag(tag.getName()); // HTML and XHTML if (isVoid) { // it's void tag, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } } else { // XML, no voids, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } return new Element(rootNode, tag, isVoid, selfClosed); } \nResponse:", "ground_truth": "Creates new element with correct configuration.", "predict": "\n\n*/\n\npackage com.github.fge.grappa.matchers;\n\nimport com.github.fge.grappa.rules.Rule;\nimport com.github.fge.grappa.run.context.MatcherContext;\n\npublic final class Matcher\n{\n    private final Rule rule;\n    private final MatcherContext context;\n\n    public Matcher(final Rule rule, final MatcherContext context)\n    {\n        this.rule = rule;\n        this.context = context;\n    }\n\n    public Rule getRule()\n    {\n        return rule;\n    }\n\n    public MatcherContext getContext()\n    {\n        return context;\n    }\n}\n"}, {"ID": 1057, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void tag(final Tag tag) { if (!enabled) { return; } TagType tagType = tag.getType(); Element node; switch (tagType) { case START: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); if (domBuilder.config.isImpliedEndTags()) { while (true) { String parentNodeName = parentNode.getNodeName(); if (!implRules.implicitlyCloseParentTagOnNewTag(parentNodeName, node.getNodeName())) { break; } parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + node.getNodeName() + \"> \"); } } } parentNode.addChild(node); if (!node.isVoidElement()) { parentNode = node; } break; case END: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } String tagName = tag.getName().toString(); Node matchingParent = findMatchingParentOpenTag(tagName); if (matchingParent == parentNode) { // regular situation parentNode = parentNode.getParentNode(); break; } if (matchingParent == null) { // matching open tag not found, remove it error(\"Orphan closed tag ignored: </\" + tagName + \"> \" + tag.getTagPosition()); break; } // try to close it implicitly if (domBuilder.config.isImpliedEndTags()) { boolean fixed = false; while (implRules.implicitlyCloseParentTagOnTagEnd(parentNode.getNodeName(), tagName)) { parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + tagName + \">\"); } if (parentNode == matchingParent) { parentNode = matchingParent.parentNode; fixed = true; break; } } if (fixed) { break; } } // matching tag found, but it is not a regular situation // therefore close all unclosed tags in between fixUnclosedTagsUpToMatchingParent(tag, matchingParent); break; case SELF_CLOSING: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); parentNode.addChild(node); break; } } \nResponse:", "ground_truth": "Visits tags.", "predict": "\n\n*/\n"}, {"ID": 1058, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) { if (parentNode == null) { return; } Node lastChild = parentNode.getLastChild(); if (lastChild == null) { return; } if (lastChild.getNodeType() != Node.NodeType.TEXT) { return; } if (closedTag) { if (parentNode.getChildNodesCount() == 1) { return; } } Text text = (Text) lastChild; if (text.isBlank()) { lastChild.detachFromParent(); } } \nResponse:", "ground_truth": "Removes last child node if contains just empty text.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String[] code = {\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                \"<html><head><title>Hello</title></head><body><p>Hello World!</p></body></html>\",\n                "}, {"ID": 1059, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getQueryString() { if (sqlTemplate == null) { return toString(); } if (parameterValues == null) { return sqlTemplate; } final StringBuilder sb = new StringBuilder(); int qMarkCount = 0; final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', \"?\"); while (tok.hasMoreTokens()) { final String oneChunk = tok.nextToken(); sb.append(oneChunk); try { Object value = null; if (parameterValues.size() > 1 + qMarkCount) { value = parameterValues.get(1 + qMarkCount); qMarkCount++; } else { if (!tok.hasMoreTokens()) { value = \"\"; } } if (value == null) { value = \"?\"; } sb.append(value); } catch (Throwable th) { sb.append(\"--- Building query failed: \").append(th.toString()); } } return sb.toString().trim(); } \nResponse:", "ground_truth": "Returns the query string.", "predict": " public String getQueryString() { if (sqlTemplate == null) { return toString(); } if (parameterValues == null) { return sqlTemplate; } final StringBuilder sb = new StringBuilder(); int qMarkCount = 0; final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', \"?\"); while (tok.hasMoreTokens()) { final String oneChunk = tok.nextToken(); sb.append(oneChunk); try { Object value = null; if (parameterValues.size() > 1 + qMarkCount) { value = parameterValues.get(1 + qMarkCount); qMarkCount++; } else { if (!tok.hasMoreTokens()) { value = \"\"; } } if (value == null) { value = \"?\"; } sb.append(value); } catch (Throwable th) { sb.append(\"--- Building query failed: \").append(th.toString()); } } return sb.toString"}, {"ID": 1060, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String getActionClassName(final Object action) { Class clazz = action.getClass(); clazz = ProxettaUtil.resolveTargetClass(clazz); return clazz.getName(); } \nResponse:", "ground_truth": "Returns correct action class name. Detects Proxetta classes.", "predict": " Response = new Response();\nResponse.setActionClassName(getActionClassName(action));\nResponse.setActionMethodName(getActionMethodName(action));\nResponse.setActionMethodReturnType(getActionMethodReturnType(action));\nResponse.setActionMethodReturnTypeName(getActionMethodReturnTypeName(action));\nResponse.setActionMethodParameters(getActionMethodParameters(action));\nResponse.setActionMethodParametersNames(getActionMethodParametersNames(action));\nResponse.setActionMethodParametersTypes(getActionMethodParametersTypes(action));\nResponse.setActionMethodParametersTypesNames(getActionMethodParametersTypesNames(action));\nResponse.setActionMethodParametersTypesNames(getActionMethodParametersTypesNames(action));\nResponse.setActionMethodParametersTypesNames(getActionMethodParametersTypesNames(action));\nResponse.setActionMethodParametersTypesNames(getActionMethodParametersTypesNames(action));\nResponse.setActionMethodParametersTypesNames(getActionMethodParametersTypesNames(action));\n"}, {"ID": 1061, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int calculateTo(final int from, final int count, final int size) { int to = size; if (count != -1) { to = from + count; if (to > size) { to = size; } } return to; } \nResponse:", "ground_truth": "Calculates 'TO'.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        int[] array = new int[10];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = i;\n        }\n        System.out.println(Arrays.toString(array));\n        System.out.println(Arrays.toString(Arrays.copyOfRange(array, 1, array.length)));\n        System.out.println(Arrays.toString(Arrays.copyOfRange(array, 1, array.length, 2)));\n        System.out.println(Arrays.toString(Arrays.copyOfRange(array, 1, array.length, -1)));\n        System.out.println(Arrays.toString(Arrays.copyOfRange(array, 1, array.length, array.length)));\n        System.out.println(Arrays.to"}, {"ID": 1062, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); Iterator iter = collection.iterator(); int i = 0; int to = calculateTo(from, count, collection.size()); while (i < to) { Object item = iter.next(); if (i >= from) { if (status != null) { iteratorStatus.next(!iter.hasNext()); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } i++; } } \nResponse:", "ground_truth": "Iterates collection.", "predict": " public void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { iterateCollection(collection, from, count, pageContext); } \nResp public void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { iterateCollection(collection, from, count, pageContext); } \nResp public void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { iterateCollection(collection, from, count, pageContext); } \nResp public void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { iterateCollection(collection, from, count, pageContext); } \nResp public void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException"}, {"ID": 1063, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); int len = array.length; int to = calculateTo(from, count, len); int last = to - 1; for (int i = from; i < to; i++) { Object item = array[i]; if (status != null) { iteratorStatus.next(i == last); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } } \nResponse:", "ground_truth": "Iterates arrays.", "predict": "\n\n*/\n\npublic class IteratorTag extends TagSupport {\n    private static final long serialVersionUID = 1L;\n    private String var;\n    private String scope;\n    private int from = 0;\n    private int count = 0;\n    private int to = 0;\n    private int index = 0;\n    private int status = 0;\n    private int scopeStatus = 0;\n    private String statusVar;\n    private String scopeStatusVar;\n    private String statusVarName;\n    private String scopeStatusVarName;\n    private String statusVarValue;\n    private String scopeStatusVarValue;\n    private String statusVarValueName;\n    private String scopeStatusVarValueName;\n    private String statusVarValueType;\n    private String scopeStatusVarValueType;\n    private String statusVarValueTypeName;\n    private String scopeStatusVarValueTypeName;\n    private String statusVarValueTypeName;\n    private String scopeStatusVarValueTypeName"}, {"ID": 1064, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replace(final String s, final String sub, final String with) { if (sub.isEmpty()) { return s; } int c = 0; int i = s.indexOf(sub, c); if (i == -1) { return s; } int length = s.length(); StringBuilder sb = new StringBuilder(length + with.length()); do { sb.append(s, c, i); sb.append(with); c = i + sub.length(); } while ((i = s.indexOf(sub, c)) != -1); if (c < length) { sb.append(s, c, length); } return sb.toString(); } \nResponse:", "ground_truth": "Replaces all occurrences of a certain pattern in a string with a\nreplacement string. This is the fastest replace function known to author.\n\n@param s      string to be inspected\n@param sub    string pattern to be replaced\n@param with   string that should go where the pattern was", "predict": "\n\npublic static String replace(final String s, final String sub, final String with) {\n    if (sub.isEmpty()) {\n        return s;\n    }\n    int c = 0;\n    int i = s.indexOf(sub, c);\n    if (i == -1) {\n        return s;\n    }\n    int length = s.length();\n    StringBuilder sb = new StringBuilder(length + with.length());\n    do {\n        sb.append(s, c, i);\n        sb.append(with);\n        c = i + sub.length();\n    } while ((i = s.indexOf(sub, c)) != -1);\n    if (c < length) {\n        sb.append(s, c, length);\n    }\n    return sb.toString();\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String"}, {"ID": 1065, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceChar(final String s, final char sub, final char with) { int startIndex = s.indexOf(sub); if (startIndex == -1) { return s; } char[] str = s.toCharArray(); for (int i = startIndex; i < str.length; i++) { if (str[i] == sub) { str[i] = with; } } return new String(str); } \nResponse:", "ground_truth": "Replaces all occurrences of a character in a string.\n\n@param s      input string\n@param sub    character to replace\n@param with   character to replace with", "predict": "\n\npublic static String replaceChar(final String s, final char sub, final char with) {\n\tint startIndex = s.indexOf(sub);\n\tif (startIndex == -1) {\n\t\treturn s;\n\t}\n\tchar[] str = s.toCharArray();\n\tfor (int i = startIndex; i < str.length; i++) {\n\t\tif (str[i] == sub) {\n\t\t\tstr[i] = with;\n\t\t}\n\t}\n\treturn new String(str);\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.replaceChar(\"aa\", 'a', 'b'));\n    }\n    \n    public String replaceChar(String s, char c, char d) {\n        int startIndex = s.indexOf(c);\n        if (startIndex == -1"}, {"ID": 1066, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceChars(final String s, final char[] sub, final char[] with) { char[] str = s.toCharArray(); for (int i = 0; i < str.length; i++) { char c = str[i]; for (int j = 0; j < sub.length; j++) { if (c == sub[j]) { str[i] = with[j]; break; } } } return new String(str); } \nResponse:", "ground_truth": "Replaces all occurrences of a characters in a string.\n\n@param s      input string\n@param sub    characters to replace\n@param with   characters to replace with", "predict": "\n\npublic static String replaceChars(final String s, final char[] sub, final char[] with) { char[] str = s.toCharArray(); for (int i = 0; i < str.length; i++) { char c = str[i]; for (int j = 0; j < sub.length; j++) { if (c == sub[j]) { str[i] = with[j]; break; } } } return new String(str); } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        char[] sub = in.next().toCharArray();\n        char[] with = in.next().toCharArray();\n        Arrays.sort(sub);\n        Arrays.sort(with);\n        "}, {"ID": 1067, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceFirst(final String s, final String sub, final String with) { int i = s.indexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); } \nResponse:", "ground_truth": "Replaces the very first occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": "\n\npublic static String replaceFirst(final String s, final String sub, final String with) { int i = s.indexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String s = \"abcdefg\";\n        String sub = \"def\";\n        String with = \"ghi\";\n        System.out.println(s.replaceFirst(sub, with));\n    }\n}\n"}, {"ID": 1068, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceFirst(final String s, final char sub, final char with) { int index = s.indexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); } \nResponse:", "ground_truth": "Replaces the very first occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.replaceFirst(\"aa\", 'a', 'b'));\n    }\n    public String replaceFirst(String s, char sub, char with) {\n        int index = s.indexOf(sub);\n        if (index == -1) {\n            return s;\n        }\n        char[] str = s.toCharArray();\n        str[index] = with;\n        return new String(str);\n    }\n}"}, {"ID": 1069, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceLast(final String s, final String sub, final String with) { int i = s.lastIndexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); } \nResponse:", "ground_truth": "Replaces the very last occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.replaceLast(\"a\", \"b\", \"c\"));\n    }\n    public String replaceLast(String s, String sub, String with) {\n        int i = s.lastIndexOf(sub);\n        if (i == -1) {\n            return s;\n        }\n        return s.substring(0, i) + with + s.substring(i + sub.length());\n    }\n}\n"}, {"ID": 1070, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceLast(final String s, final char sub, final char with) { int index = s.lastIndexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); } \nResponse:", "ground_truth": "Replaces the very last occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.replaceLast(\"abcdefg\", 'a', 'z'));\n    }\n    \n    public String replaceLast(String s, char c, char d) {\n        int index = s.lastIndexOf(c);\n        if (index == -1) {\n            return s;\n        }\n        char[] str = s.toCharArray();\n        str[index] = d;\n        return new String(str);\n    }\n}"}, {"ID": 1071, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String remove(final String s, final String sub) { int c = 0; int sublen = sub.length(); if (sublen == 0) { return s; } int i = s.indexOf(sub, c); if (i == -1) { return s; } StringBuilder sb = new StringBuilder(s.length()); do { sb.append(s, c, i); c = i + sublen; } while ((i = s.indexOf(sub, c)) != -1); if (c < s.length()) { sb.append(s, c, s.length()); } return sb.toString(); } \nResponse:", "ground_truth": "Removes all substring occurrences from the string.\n\n@param s      source string\n@param sub    substring to remove", "predict": "\n\npublic static String remove(final String s, final String sub) { int c = 0; int sublen = sub.length(); if (sublen == 0) { return s; } int i = s.indexOf(sub, c); if (i == -1) { return s; } StringBuilder sb = new StringBuilder(s.length()); do { sb.append(s, c, i); c = i + sublen; } while ((i = s.indexOf(sub, c)) != -1); if (c < s.length()) { sb.append(s, c, s.length()); } return sb.toString(); } \n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        String s = in.next();\n        String sub"}, {"ID": 1072, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String remove(final String string, final char ch) { int stringLen = string.length(); char[] result = new char[stringLen]; int offset = 0; for (int i = 0; i < stringLen; i++) { char c = string.charAt(i); if (c == ch) { continue; } result[offset] = c; offset++; } if (offset == stringLen) { return string; // no changes } return new String(result, 0, offset); } \nResponse:", "ground_truth": "Removes a single character from string.\n\n@param string    source string\n@param ch  character to remove", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.remove(\"abcdefg\", 'a'));\n    }\n    \n    public String remove(String s, char c) {\n        int len = s.length();\n        char[] result = new char[len];\n        int offset = 0;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                continue;\n            }\n            result[offset] = s.charAt(i);\n            offset++;\n        }\n        if (offset == len) {\n            return s;\n        }\n        return new String(result, 0, offset);\n    }\n}"}, {"ID": 1073, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAllEmpty(final String... strings) { for (String string : strings) { if (!isEmpty(string)) { return false; } } return true; } \nResponse:", "ground_truth": "Determines if string array contains empty strings.\n@see #isEmpty(CharSequence)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1074, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAllBlank(final String... strings) { for (String string : strings) { if (!isBlank(string)) { return false; } } return true; } \nResponse:", "ground_truth": "Determines if string array contains just blank strings.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1075, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] toStringArray(final Object value) { if (value == null) { return new String[0]; } Class<?> type = value.getClass(); if (!type.isArray()) { return new String[] {value.toString()}; } Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { if (componentType == int.class) { return ArraysUtil.toStringArray((int[]) value); } else if (componentType == long.class) { return ArraysUtil.toStringArray((long[]) value); } else if (componentType == double.class) { return ArraysUtil.toStringArray((double[]) value); } else if (componentType == float.class) { return ArraysUtil.toStringArray((float[]) value); } else if (componentType == boolean.class) { return ArraysUtil.toStringArray((boolean[]) value); } else if (componentType == short.class) { return ArraysUtil.toStringArray((short[]) value); } else if (componentType == byte.class) { return ArraysUtil.toStringArray((byte[]) value); } else { throw new IllegalArgumentException(); } } else { return ArraysUtil.toStringArray((Object[]) value); } } \nResponse:", "ground_truth": "Converts an array object to array of strings, where every element\nof input array is converted to a string. If input is not an array,\nthe result will still be an array with one element.", "predict": " public static String[] toStringArray(final Object value) { if (value == null) { return new String[0]; } Class<?> type = value.getClass(); if (!type.isArray()) { return new String[] {value.toString()}; } Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { if (componentType == int.class) { return ArraysUtil.toStringArray((int[]) value); } else if (componentType == long.class) { return ArraysUtil.toStringArray((long[]) value); } else if (componentType == double.class) { return ArraysUtil.toStringArray((double[]) value); } else if (componentType == float.class) { return ArraysUtil.toStringArray((float[]) value); } else if (componentType == boolean.class) { return ArraysUtil.toStringArray((boolean[]) value); } else if (component"}, {"ID": 1076, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String changeFirstCharacterCase(final boolean capitalize, final String string) { int strLen = string.length(); if (strLen == 0) { return string; } char ch = string.charAt(0); char modifiedCh; if (capitalize) { modifiedCh = Character.toUpperCase(ch); } else { modifiedCh = Character.toLowerCase(ch); } if (modifiedCh == ch) { // no change, return unchanged string return string; } char[] chars = string.toCharArray(); chars[0] = modifiedCh; return new String(chars); } \nResponse:", "ground_truth": "Internal method for changing the first character case.", "predict": "\n\npublic static String changeFirstCharacterCase(final boolean capitalize, final String string) { int strLen = string.length(); if (strLen == 0) { return string; } char ch = string.charAt(0); char modifiedCh; if (capitalize) { modifiedCh = Character.toUpperCase(ch); } else { modifiedCh = Character.toLowerCase(ch); } if (modifiedCh == ch) { // no change, return unchanged string return string; } char[] chars = string.toCharArray(); chars[0] = modifiedCh; return new String(chars); }\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.changeFirstCharacterCase(\"abc\", \"ABC\"));\n    }\n    \n    public String changeFirstCharacterCase(String s, String to) {\n        if (s.length() == 0) {\n            "}, {"ID": 1077, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUtil.isWhitespace(c)) { wasWhitespace = true; } else { if (wasWhitespace) { chars[i] = Character.toUpperCase(c); } else { chars[i] = Character.toLowerCase(c); } wasWhitespace = false; } } return new String(chars); } \nResponse:", "ground_truth": "Makes a title-cased string from given input.", "predict": "\n\npublic static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUtil.isWhitespace(c)) { wasWhitespace = true; } else { if (wasWhitespace) { chars[i] = Character.toUpperCase(c); } else { chars[i] = Character.toLowerCase(c); } wasWhitespace = false; } } return new String(chars); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String s = \"public static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUt"}, {"ID": 1078, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String compressChars(final String s, final char c) { int len = s.length(); StringBuilder sb = new StringBuilder(len); boolean wasChar = false; for (int i = 0; i < len; i++) { char c1 = s.charAt(i); if (c1 == c) { if (wasChar) { continue; } wasChar = true; } else { wasChar = false; } sb.append(c1); } if (sb.length() == len) { return s; } return sb.toString(); } \nResponse:", "ground_truth": "Compress multiple occurrences of given char into one appearance.", "predict": "\n\npublic static String compressChars(final String s, final char c) {\n    int len = s.length();\n    StringBuilder sb = new StringBuilder(len);\n    boolean wasChar = false;\n    for (int i = 0; i < len; i++) {\n        char c1 = s.charAt(i);\n        if (c1 == c) {\n            if (wasChar) {\n                continue;\n            }\n            wasChar = true;\n        } else {\n            wasChar = false;\n        }\n        sb.append(c1);\n    }\n    if (sb.length() == len) {\n        return s;\n    }\n    return sb.toString();\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.compressChars(\"abcdefg\","}, {"ID": 1079, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) { String sub = subS.toLowerCase(); int sublen = sub.length(); if (startIndex + sublen > src.length()) { return false; } int j = 0; int i = startIndex; while (j < sublen) { char source = Character.toLowerCase(src.charAt(i)); if (sub.charAt(j) != source) { return false; } j++; i++; } return true; } \nResponse:", "ground_truth": "Tests if this string starts with the specified prefix with ignored case\nand with the specified prefix beginning a specified index.\n\n@param src        source string to test\n@param subS       starting substring\n@param startIndex index from where to test\n\n@return true if the character sequence represented by the argument is\na prefix of the character sequence represented by this string;\nfalse otherwise.", "predict": "\n\npublic static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) {\n\tString sub = subS.toLowerCase();\n\tint sublen = sub.length();\n\tif (startIndex + sublen > src.length()) {\n\t\treturn false;\n\t}\n\tint j = 0;\n\tint i = startIndex;\n\twhile (j < sublen) {\n\t\tchar source = Character.toLowerCase(src.charAt(i));\n\t\tif (sub.charAt(j) != source) {\n\t\t\treturn false;\n\t\t}\n\t\tj++;\n\t\ti++;\n\t}\n\treturn true;\n}\n\n*/\n\npublic static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) {\n\tString sub = subS.toLowerCase();\n\tint sublen = sub.length();\n\tif (startIndex + sublen >"}, {"ID": 1080, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean endsWithChar(final String s, final char c) { if (s.length() == 0) { return false; } return s.charAt(s.length() - 1) == c; } \nResponse:", "ground_truth": "Returns if string ends with provided character.", "predict": "\n\npublic static boolean endsWithChar(final String s, final char c) {\n    if (s.length() == 0) {\n        return false;\n    }\n    return s.charAt(s.length() - 1) == c;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test();\n    }\n\n    public void test() {\n        String s = \"abcdefg\";\n        System.out.println(endsWithChar(s, 'a'));\n    }\n\n    public boolean endsWithChar(String s, char c) {\n        if (s.length() == 0) {\n            return false;\n        }\n        return s.charAt(s.length() - 1) == c;\n    }\n}"}, {"ID": 1081, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int countIgnoreCase(final String source, final String sub) { int count = 0; int j = 0; int sublen = sub.length(); if (sublen == 0) { return 0; } while (true) { int i = indexOfIgnoreCase(source, sub, j); if (i == -1) { break; } count++; j = i + sublen; } return count; } \nResponse:", "ground_truth": "Count substring occurrences in a source string, ignoring case.\n\n@param source\tsource string\n@param sub\t\tsubstring to count\n@return\t\t\tnumber of substring occurrences", "predict": "\n\npublic static int countIgnoreCase(final String source, final String sub) { int count = 0; int j = 0; int sublen = sub.length(); if (sublen == 0) { return 0; } while (true) { int i = indexOfIgnoreCase(source, sub, j); if (i == -1) { break; } count++; j = i + sublen; } return count; }\n\npublic static int indexOfIgnoreCase(final String source, final String sub, int start) {\n\tint sourceLen = source.length();\n\tint subLen = sub.length();\n\tint max = sourceLen - subLen;\n\n\tif (subLen == 0) {\n\t\treturn 0;\n\t}\n\n\tif (start > max) {\n\t\treturn -1;\n\t}\n\n\tchar firstChar = sub.charAt(0);\n\tint i = start;\n\twhile (true) {\n\t\tboolean found"}, {"ID": 1082, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean equalsIgnoreCase(final String[] as, final String[] as1) { if (as.length != as1.length) { return false; } for (int i = 0; i < as.length; i++) { if (!as[i].equalsIgnoreCase(as1[i])) { return false; } } return true; } \nResponse:", "ground_truth": "Compares two string arrays.\n\n@param as     first string array\n@param as1    second string array\n\n@return true if all array elements matches", "predict": "\n\npublic static boolean equalsIgnoreCase(final String[] as, final String[] as1) { if (as.length != as1.length) { return false; } for (int i = 0; i < as.length; i++) { if (!as[i].equalsIgnoreCase(as1[i])) { return false; } } return true; } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.equalsIgnoreCase(new String[]{\"abc\", \"ABC\", \"def\"}, new String[]{\"abc\", \"ABC\", \"def\"}));\n        System.out.println(solution.equalsIgnoreCase(new String[]{\"abc\", \"ABC\", \"def\"}, new String[]{\"abc\","}, {"ID": 1083, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOfWhitespace(final String string, final int startindex, final int endindex) { for (int i = startindex; i < endindex; i++) { if (CharUtil.isWhitespace(string.charAt(i))) { return i; } } return -1; } \nResponse:", "ground_truth": "Returns first index of a whitespace character, starting from specified index offset.", "predict": "\n\npublic static int indexOfWhitespace(final String string, final int startindex, final int endindex) {\n\tfor (int i = startindex; i < endindex; i++) {\n\t\tif (CharUtil.isWhitespace(string.charAt(i))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n*/\n\npublic class Solution {\n    public static int indexOfWhitespace(final String string, final int startindex, final int endindex) {\n        for (int i = startindex; i < endindex; i++) {\n            if (CharUtil.isWhitespace(string.charAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}, {"ID": 1084, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripLeadingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(0) == c) { return string.substring(1); } } return string; } \nResponse:", "ground_truth": "Strips leading char if string starts with one.", "predict": "\n\npublic static String stripLeadingChar(final String string, final char c) {\n\tif (string.length() > 0) {\n\t\tif (string.charAt(0) == c) {\n\t\t\treturn string.substring(1);\n\t\t}\n\t}\n\treturn string;\n}\n\n*/\n\npublic class StripLeadingChar {\n\tpublic static void main(String[] args) {\n\t\tString string = \"abc\";\n\t\tSystem.out.println(string);\n\t\tSystem.out.println(stripLeadingChar(string, 'a'));\n\t}\n}\n"}, {"ID": 1085, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripTrailingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(string.length() - 1) == c) { return string.substring(0, string.length() - 1); } } return string; } \nResponse:", "ground_truth": "Strips trailing char if string ends with one.", "predict": "\n\npublic static String stripTrailingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(string.length() - 1) == c) { return string.substring(0, string.length() - 1); } } return string; } \n\n*/\n\nimport java.util.Scanner;\n\npublic class StripTrailingChar {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String output = input.substring(0, input.length() - 1);\n        System.out.println(output);\n    }\n}\n"}, {"ID": 1086, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripChar(final String string, final char c) { if (string.length() == 0) { return string; } if (string.length() == 1) { if (string.charAt(0) == c) { return StringPool.EMPTY; } return string; } int left = 0; int right = string.length(); if (string.charAt(left) == c) { left++; } if (string.charAt(right - 1) == c) { right--; } return string.substring(left, right); } \nResponse:", "ground_truth": "Strips leading and trailing char from given string.", "predict": "\n\npublic static String stripChar(final String string, final char c) {\n\tif (string.length() == 0) {\n\t\treturn string;\n\t}\n\tif (string.length() == 1) {\n\t\tif (string.charAt(0) == c) {\n\t\t\treturn StringPool.EMPTY;\n\t\t}\n\t\treturn string;\n\t}\n\tint left = 0;\n\tint right = string.length();\n\tif (string.charAt(left) == c) {\n\t\tleft++;\n\t}\n\tif (string.charAt(right - 1) == c) {\n\t\tright--;\n\t}\n\treturn string.substring(left, right);\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abc\";\n        char c = 'a';\n        System.out.println(stripChar(string, c));\n    }"}, {"ID": 1087, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripToChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(ndx); } \nResponse:", "ground_truth": "Strips everything up to the first appearance of given char.\nCharacter IS included in the returned string.", "predict": "\n\npublic static String stripToChar(final String string, final char c) {\n    int ndx = string.indexOf(c);\n    if (ndx == -1) {\n        return string;\n    }\n    return string.substring(ndx);\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abcdefg\";\n        char c = 'c';\n        System.out.println(stripToChar(string, c));\n    }\n}\n"}, {"ID": 1088, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripFromChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(0, ndx); } \nResponse:", "ground_truth": "Strips everything from the first appearance of given char.\nCharacter IS NOT included in the returned string.", "predict": "\n\npublic static String stripFromChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(0, ndx); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abcdefg\";\n        char c = 'c';\n        System.out.println(stripFromChar(string, c));\n    }\n    \n    public static String stripFromChar(String string, char c) {\n        int ndx = string.indexOf(c);\n        if (ndx == -1) {\n            return string;\n        }\n        return string.substring(0, ndx);\n    }\n}\n"}, {"ID": 1089, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cropAll(final String... strings) { for (int i = 0; i < strings.length; i++) { String string = strings[i]; if (string != null) { string = crop(strings[i]); } strings[i] = string; } } \nResponse:", "ground_truth": "Crops all elements of string array.", "predict": "\n\n*/\n\npublic class Crop {\n    public static void main(String[] args) {\n        String[] strings = {\"Hello\", \"World\", \"!\"};\n        for (int i = 0; i < strings.length; i++) {\n            String string = strings[i];\n            if (string != null) {\n                string = crop(strings[i]);\n            }\n            strings[i] = string;\n        }\n        for (int i = 0; i < strings.length; i++) {\n            System.out.println(strings[i]);\n        }\n    }\n\n    public static String crop(String string) {\n        return string.substring(0, string.length() - 1);\n    }\n}\n"}, {"ID": 1090, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String trimLeft(final String src) { int len = src.length(); int st = 0; while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) { st++; } return st > 0 ? src.substring(st) : src; } \nResponse:", "ground_truth": "Trim whitespaces from the left.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.trimLeft(\"   \"));\n    }\n\n    public String trimLeft(String s) {\n        int len = s.length();\n        int st = 0;\n        while ((st < len) && (CharUtil.isWhitespace(s.charAt(st)))) {\n            st++;\n        }\n        return st > 0 ? s.substring(st) : s;\n    }\n}\n"}, {"ID": 1091, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String trimRight(final String src) { int len = src.length(); int count = len; while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) { len--; } return (len < count) ? src.substring(0, len) : src; } \nResponse:", "ground_truth": "Trim whitespaces from the right.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.trimRight(\"   \"));\n    }\n\n    public String trimRight(String s) {\n        int len = s.length();\n        int count = len;\n        while ((len > 0) && (CharUtil.isWhitespace(s.charAt(len - 1)))) {\n            len--;\n        }\n        return (len < count) ? s.substring(0, len) : s;\n    }\n}\n"}, {"ID": 1092, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) { int ndx = offset; int[] res = new int[4]; ndx = string.indexOf(leftBoundary, ndx); if (ndx == -1) { return null; } res[0] = ndx; ndx += leftBoundary.length(); res[1] = ndx; ndx = string.indexOf(rightBoundary, ndx); if (ndx == -1) { return null; } res[2] = ndx; res[3] = ndx + rightBoundary.length(); return res; } \nResponse:", "ground_truth": "Returns indexes of the first region without escaping character.\n@see #indexOfRegion(String, String, String, char, int)", "predict": "\n\npublic static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) { int ndx = offset; int[] res = new int[4]; ndx = string.indexOf(leftBoundary, ndx); if (ndx == -1) { return null; } res[0] = ndx; ndx += leftBoundary.length(); res[1] = ndx; ndx = string.indexOf(rightBoundary, ndx); if (ndx == -1) { return null; } res[2] = ndx; res[3] = ndx + rightBoundary.length(); return res; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static int[] indexOfRegion(String string, String leftBoundary, String rightBoundary, int offset) {\n        int ndx = offset;"}, {"ID": 1093, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String join(final Collection collection, final char separator) { if (collection == null) { return null; } if (collection.size() == 0) { return StringPool.EMPTY; } final StringBuilder sb = new StringBuilder(collection.size() * 16); final Iterator it = collection.iterator(); for (int i = 0; i < collection.size(); i++) { if (i > 0) { sb.append(separator); } sb.append(it.next()); } return sb.toString(); } \nResponse:", "ground_truth": "Joins an collection of objects into one string with separator.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.join(Arrays.asList(new String[]{\"a\",\"b\"}), ','));\n    }\n    public String join(Collection collection, char separator) {\n        if (collection == null) {\n            return null;\n        }\n        if (collection.size() == 0) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder(collection.size() * 16);\n        Iterator it = collection.iterator();\n        for (int i = 0; i < collection.size(); i++) {\n            if (i > 0) {\n                sb.append(separator);\n            }\n            sb.append(it.next());\n        }\n        return sb.toString();\n    }\n}\n"}, {"ID": 1094, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String join(final Object[] array, final String separator) { if (array == null) { return null; } if (array.length == 0) { return StringPool.EMPTY; } if (array.length == 1) { return String.valueOf(array[0]); } final StringBuilder sb = new StringBuilder(array.length * 16); for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(separator); } sb.append(array[i]); } return sb.toString(); } \nResponse:", "ground_truth": "Joins an array of objects into one string with separator.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.join(new Object[]{1, 2, 3}, \",\"));\n    }\n\n    public String join(final Object[] array, final String separator) {\n        if (array == null) {\n            return null;\n        }\n        if (array.length == 0) {\n            return \"\";\n        }\n        if (array.length == 1) {\n            return String.valueOf(array[0]);\n        }\n        final StringBuilder sb = new StringBuilder(array.length * 16);\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                sb.append(separator);\n            }\n            sb.append(String.valueOf(array[i]));\n        }\n        return s"}, {"ID": 1095, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) { if (srcCharsetName.equals(newCharsetName)) { return source; } return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName); } \nResponse:", "ground_truth": "Converts string charset. If charset names are the same, the same string is returned.", "predict": " public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) { if (srcCharsetName.equals(newCharsetName)) { return source; } return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName); } \n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class StringUtil {\n\n\tpublic static final String DEFAULT_CHARSET = \"UTF-8\";\n\tpublic static final String DEFAULT_ENCODING = \"UTF-8\";\n\tpublic static final String DEFAULT_"}, {"ID": 1096, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) { if ((index < 0) || (index >= string.length())) { return false; } return string.charAt(index) == charToCompare; } \nResponse:", "ground_truth": "Safely compares provided char with char on given location.", "predict": "\n\n*/\n\npublic class Solution {\n    public static boolean isCharAtEqual(String string, int index, char charToCompare) {\n        if ((index < 0) || (index >= string.length())) {\n            return false;\n        }\n        return string.charAt(index) == charToCompare;\n    }\n}\n"}, {"ID": 1097, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String surround(String string, final String prefix, final String suffix) { if (!string.startsWith(prefix)) { string = prefix + string; } if (!string.endsWith(suffix)) { string += suffix; } return string; } \nResponse:", "ground_truth": "Surrounds the string with provided prefix and suffix if such missing from string.", "predict": "\n\npublic static String surround(String string, final String prefix, final String suffix) { if (!string.startsWith(prefix)) { string = prefix + string; } if (!string.endsWith(suffix)) { string += suffix; } return string; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abcdefg\";\n        String prefix = \"ab\";\n        String suffix = \"cd\";\n        System.out.println(surround(string, prefix, suffix));\n    }\n    \n    public static String surround(String string, final String prefix, final String suffix) {\n        if (!string.startsWith(prefix)) {\n            string = prefix + string;\n        }\n        if (!string.endsWith(suffix)) {\n            string += suffix;\n        }\n        return string;\n    }\n}"}, {"ID": 1098, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String prefix(String string, final String prefix) { if (!string.startsWith(prefix)) { string = prefix + string; } return string; } \nResponse:", "ground_truth": "Inserts prefix if doesn't exist.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1099, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String suffix(String string, final String suffix) { if (!string.endsWith(suffix)) { string += suffix; } return string; } \nResponse:", "ground_truth": "Appends suffix if doesn't exist.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1100, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutToIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(0, i); } return string; } \nResponse:", "ground_truth": "Cuts the string from beginning to the first index of provided substring.", "predict": "\n\npublic static String cutToIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(0, i); } return string; }\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String string = in.next();\n        String substring = in.next();\n        int index = string.indexOf(substring);\n        if (index != -1) {\n            string = string.substring(0, index);\n        }\n        System.out.println(string);\n    }\n}\n"}, {"ID": 1101, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutFromIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(i); } return string; } \nResponse:", "ground_truth": "Cuts the string from the first index of provided substring to the end.", "predict": "\n\npublic static String cutFromIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(i); } return string; }\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abcdefg\";\n        String substring = \"def\";\n        System.out.println(cutFromIndexOf(string, substring));\n    }\n    \n    public static String cutFromIndexOf(String string, final String substring) {\n        int i = string.indexOf(substring);\n        if (i != -1) {\n            string = string.substring(i);\n        }\n        return string;\n    }\n}"}, {"ID": 1102, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutPrefix(String string, final String prefix) { if (string.startsWith(prefix)) { string = string.substring(prefix.length()); } return string; } \nResponse:", "ground_truth": "Cuts prefix if exists.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1103, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutSuffix(String string, final String suffix) { if (string.endsWith(suffix)) { string = string.substring(0, string.length() - suffix.length()); } return string; } \nResponse:", "ground_truth": "Cuts sufix if exists.", "predict": "\n\npublic static String cutSuffix(String string, final String suffix) { if (string.endsWith(suffix)) { string = string.substring(0, string.length() - suffix.length()); } return string; }\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        String s = in.next();\n        String suffix = in.next();\n        String result = \"\";\n        for (int i = 0; i < n; i++) {\n            result += cutSuffix(s, suffix);\n        }\n        System.out.println(result);\n    }\n\n    public static String cutSuffix(String string, String suffix) {\n        if (string.endsWith(suffix)) {\n            string = string.substring("}, {"ID": 1104, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutSurrounding(final String string, final String prefix, final String suffix) { int start = 0; int end = string.length(); if (string.startsWith(prefix)) { start = prefix.length(); } if (string.endsWith(suffix)) { end -= suffix.length(); } if (end <= start) { return StringPool.EMPTY; } return string.substring(start, end); } \nResponse:", "ground_truth": "Removes surrounding prefix and suffixes.", "predict": "\n\npublic static String cutSurrounding(final String string, final String prefix, final String suffix) { int start = 0; int end = string.length(); if (string.startsWith(prefix)) { start = prefix.length(); } if (string.endsWith(suffix)) { end -= suffix.length(); } if (end <= start) { return StringPool.EMPTY; } return string.substring(start, end); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String string = \"abcdefg\";\n        String prefix = \"ab\";\n        String suffix = \"cd\";\n        System.out.println(cutSurrounding(string, prefix, suffix));\n    }\n    \n    public static String cutSurrounding(String string, String prefix, String suffix) {\n        int start = 0;\n        int end = string.length();\n        if (string.startsWith(prefix"}, {"ID": 1105, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String insert(final String src, final String insert, int offset) { if (offset < 0) { offset = 0; } if (offset > src.length()) { offset = src.length(); } StringBuilder sb = new StringBuilder(src); sb.insert(offset, insert); return sb.toString(); } \nResponse:", "ground_truth": "Inserts a string on provided offset.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.insertString(\"abcd\", \"efg\", 2));\n    }\n    \n    public String insertString(String s, String t, int offset) {\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (offset > s.length()) {\n            offset = s.length();\n        }\n        StringBuilder sb = new StringBuilder(s);\n        sb.insert(offset, t);\n        return sb.toString();\n    }\n}"}, {"ID": 1106, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String repeat(final String source, int count) { StringBand result = new StringBand(count); while (count > 0) { result.append(source); count--; } return result.toString(); } \nResponse:", "ground_truth": "Creates a new string that contains the provided string a number of times.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1107, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String reverse(final String s) { StringBuilder result = new StringBuilder(s.length()); for (int i = s.length() -1; i >= 0; i--) { result.append(s.charAt(i)); } return result.toString(); } \nResponse:", "ground_truth": "Reverse a string.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.reverse(\"abc\"));\n    }\n    public String reverse(String s) {\n        StringBuilder result = new StringBuilder(s.length());\n        for (int i = s.length() -1; i >= 0; i--) {\n            result.append(s.charAt(i));\n        }\n        return result.toString();\n    }\n}\n"}, {"ID": 1108, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String maxCommonPrefix(final String one, final String two) { final int minLength = Math.min(one.length(), two.length()); final StringBuilder sb = new StringBuilder(minLength); for (int pos = 0; pos < minLength; pos++) { final char currentChar = one.charAt(pos); if (currentChar != two.charAt(pos)) { break; } sb.append(currentChar); } return sb.toString(); } \nResponse:", "ground_truth": "Returns max common prefix of two strings.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String one = \"abcdefg\";\n        String two = \"abcdefg\";\n        System.out.println(maxCommonPrefix(one, two));\n    }\n    \n    public static String maxCommonPrefix(String one, String two) {\n        int minLength = Math.min(one.length(), two.length());\n        StringBuilder sb = new StringBuilder(minLength);\n        for (int pos = 0; pos < minLength; pos++) {\n            if (one.charAt(pos) != two.charAt(pos)) {\n                break;\n            }\n            sb.append(one.charAt(pos));\n        }\n        return sb.toString();\n    }\n}"}, {"ID": 1109, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String findCommonPrefix(final String... strings) { StringBuilder prefix = new StringBuilder(); int index = 0; char c = 0; loop: while (true) { for (int i = 0; i < strings.length; i++) { String s = strings[i]; if (index == s.length()) { break loop; } if (i == 0) { c = s.charAt(index); } else { if (s.charAt(index) != c) { break loop; } } } index++; prefix.append(c); } return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString(); } \nResponse:", "ground_truth": "Finds common prefix for several strings. Returns an empty string if\narguments do not have a common prefix.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String[] strings = new String[]{\"abc\", \"abcd\", \"abce\", \"abcf\"};\n        System.out.println(findCommonPrefix(strings));\n    }\n    \n    public static String findCommonPrefix(String[] strings) {\n        if (strings.length == 0) return \"\";\n        int min = strings[0].length();\n        for (int i = 1; i < strings.length; i++) {\n            min = Math.min(min, strings[i].length());\n        }\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < min; i++) {\n            char c = strings[0].charAt(i);\n            for (int j = 1; j < strings.length; j++) {\n                if (strings[j].charAt(i) != c)"}, {"ID": 1110, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String shorten(String s, int length, final String suffix) { length -= suffix.length(); if (s.length() > length) { for (int j = length; j >= 0; j--) { if (CharUtil.isWhitespace(s.charAt(j))) { length = j; break; } } String temp = s.substring(0, length); s = temp.concat(suffix); } return s; } \nResponse:", "ground_truth": "Shorten string to given length.", "predict": "\n\npublic static String shorten(String s, int length, final String suffix) { length -= suffix.length(); if (s.length() > length) { for (int j = length; j >= 0; j--) { if (CharUtil.isWhitespace(s.charAt(j))) { length = j; break; } } String temp = s.substring(0, length); s = temp.concat(suffix); } return s; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String s = \"abcdefghijklmnopqrstuvwxyz\";\n        int length = s.length();\n        String suffix = \"...\";\n        System.out.println(shorten(s, length, suffix));\n    }\n    \n    public static String shorten(String s, int length, String suffix) {\n        length -= suffix.length();\n        if (s."}, {"ID": 1111, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toUpperCase(final String s, Locale locale) { if (s == null) { return null; } StringBuilder sb = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127) { // found non-ascii char, fallback to the slow unicode detection if (locale == null) { locale = Locale.getDefault(); } return s.toUpperCase(locale); } if ((c >= 'a') && (c <= 'z')) { if (sb == null) { sb = new StringBuilder(s); } sb.setCharAt(i, (char)(c - 32)); } } if (sb == null) { return s; } return sb.toString(); } \nResponse:", "ground_truth": "Converts all of the characters in the string to upper case, based on the\nlocale.\n\n@param  s the string to convert\n@param  locale apply this locale's rules\n@return the string, converted to upper case, or null if the\nstring is null", "predict": "\n\npublic static String toUpperCase(final String s, Locale locale) { if (s == null) { return null; } StringBuilder sb = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127) { // found non-ascii char, fallback to the slow unicode detection if (locale == null) { locale = Locale.getDefault(); } return s.toUpperCase(locale); } if ((c >= 'a') && (c <= 'z')) { if (sb == null) { sb = new StringBuilder(s); } sb.setCharAt(i, (char)(c - 32)); } } if (sb == null) { return s; } return sb.toString(); } \n\n*/\n\nimport java.util.Locale;\n\npublic class Solution {\n    public static String toUpperCase("}, {"ID": 1112, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String removeQuotes(final String string) { if ( (startsWithChar(string, '\\'') && endsWithChar(string, '\\'')) || (startsWithChar(string, '\"') && endsWithChar(string, '\"')) || (startsWithChar(string, '`') && endsWithChar(string, '`')) ) { return substring(string, 1, -1); } return string; } \nResponse:", "ground_truth": "Removes starting and ending single or double quotes.", "predict": "\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RemoveQuotes {\n    public static void main(String[] args) {\n        String string = \"\\\"Hello World\\\"\";\n        System.out.println(removeQuotes(string));\n    }\n\n    public static String removeQuotes(String string) {\n        if (string.startsWith(\"\\\"\") && string.endsWith(\"\\\"\")) {\n            return string.substring(1, string.length() - 1);\n        } else if (string.startsWith(\"'\") && string.endsWith(\"'\")) {\n            return string.substring(1, string.length() - 1);\n        } else if (string.startsWith(\"`\") && string.endsWith(\"`\")) {\n            return string.substring(1, string.length() - 1);\n        }\n        return string;\n    }\n}"}, {"ID": 1113, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toHexString(final byte[] bytes) { char[] chars = new char[bytes.length * 2]; int i = 0; for (byte b : bytes) { chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4); chars[i++] = CharUtil.int2hex(b & 0x0F); } return new String(chars); } \nResponse:", "ground_truth": "Converts bytes to hex string.", "predict": "\n\npublic static String toHexString(final byte[] bytes) { char[] chars = new char[bytes.length * 2]; int i = 0; for (byte b : bytes) { chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4); chars[i++] = CharUtil.int2hex(b & 0x0F); } return new String(chars); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.toHexString(new byte[]{(byte)0x01, (byte)0x02, (byte)0x03, (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08, (byte)0x09, (byte)0x0A,"}, {"ID": 1114, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] getBytes(final String string) { try { return string.getBytes(JoddCore.encoding); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Returns String bytes using Jodds default encoding.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1115, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char detectQuoteChar(final String str) { if (str.length() < 2) { return 0; } final char c = str.charAt(0); if (c != str.charAt(str.length() - 1)) { return 0; } if (c == '\\'' || c == '\"' || c == '`') { return c; } return 0; } \nResponse:", "ground_truth": "Detects quote character or return 0.", "predict": "\n\npublic static char detectQuoteChar(final String str) {\n    if (str.length() < 2) {\n        return 0;\n    }\n    final char c = str.charAt(0);\n    if (c != str.charAt(str.length() - 1)) {\n        return 0;\n    }\n    if (c == '\\'' || c == '\"' || c == '`') {\n        return c;\n    }\n    return 0;\n}\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        String str = in.next();\n        char c = detectQuoteChar(str);\n        System.out.println(c);\n    }\n\n    public static char detectQuoteChar(String str) {\n        if (str"}, {"ID": 1116, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit(final String name, final Object value) { if (av != null) { av.visit(name, value); } } \nResponse:", "ground_truth": "Visits a primitive value of the annotation.\n\n@param name the value name.\n@param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\nCharacter}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\n{@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\nvalue can also be an array of byte, boolean, short, char, int, long, float or double values\n(this is equivalent to using {@link #visitArray} and visiting each array element in turn,\nbut is more convenient).", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1117, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitEnum(final String name, final String descriptor, final String value) { if (av != null) { av.visitEnum(name, descriptor, value); } } \nResponse:", "ground_truth": "Visits an enumeration value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the enumeration class.\n@param value the actual enumeration value.", "predict": " Resp public void visitEnd() { if (av != null) { av.visitEnd(); } } \n*/\n\npublic class EnumVisitor extends MethodVisitor {\n    private final String className;\n    private final String methodName;\n    private final String methodDesc;\n    private final String methodValue;\n    private final String methodComment;\n    private final String methodCode;\n    private final String methodNameAndDesc;\n    private final String methodNameAndValue;\n    private final String methodNameAndComment;\n    private final String methodNameAndCode;\n    private final String methodNameAndNameAndDesc;\n    private final String methodNameAndNameAndValue;\n    private final String methodNameAndNameAndComment;\n    private final String methodNameAndNameAndCode;\n    private final String methodNameAndNameAndNameAndDesc;\n    private final String methodNameAndNameAndNameAndValue;\n    private final String methodNameAndNameAndNameAndComment"}, {"ID": 1118, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String name, final String descriptor) { if (av != null) { return av.visitAnnotation(name, descriptor); } return null; } \nResponse:", "ground_truth": "Visits a nested annotation value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the nested annotation class.\n@return a visitor to visit the actual nested annotation value, or {@literal null} if this\nvisitor is not interested in visiting this nested annotation. The nested annotation\nvalue must be fully visited before calling other methods on this annotation visitor.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google"}, {"ID": 1119, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> registerType(final Class<E> type) { DbEntityDescriptor<E> ded = createDbEntityDescriptor(type); DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded); if (log.isDebugEnabled()) { log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName()); } if (existing != null) { if (ded.getType() == type) { return ded; } throw new DbOomException(\"Type already registered: \" + existing.getType()); } existing = entityNamesMap.put(ded.getEntityName(), ded); if (existing != null) { throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType()); } return ded; } \nResponse:", "ground_truth": "Registers just type and entity names. Enough for most usages.", "predict": " public <E> DbEntityDescriptor<E> registerType(final Class<E> type) { DbEntityDescriptor<E> ded = createDbEntityDescriptor(type); DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded); if (log.isDebugEnabled()) { log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName()); } if (existing != null) { if (ded.getType() == type) { return ded; } throw new DbOomException(\"Type already registered: \" + existing.getType()); } existing = entityNamesMap.put(ded.getEntityName(), ded); if (existing != null) { throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType()); } return ded; } \n\n}\n"}, {"ID": 1120, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) { if (force) { removeEntity(type); } return registerEntity(type); } \nResponse:", "ground_truth": "Registers entity. Existing entity will be removed if exist, so no exception will be thrown.", "predict": " Resp public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type) { return registerEntity(type, false); } \nResp Resp public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) { return registerEntity(type, force, null); } \nResp Resp public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final String comment) { return registerEntity(type, false, comment); } \nResp Resp public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force, final String comment) { return registerEntity(type, force, comment, null); } \nResp Resp public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final String comment, final String description) { return register"}, {"ID": 1121, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) { DbEntityDescriptor<E> ded = descriptorsMap.remove(type); if (ded == null) { ded = createDbEntityDescriptor(type); } entityNamesMap.remove(ded.getEntityName()); tableNamesMap.remove(ded.getTableName()); return ded; } \nResponse:", "ground_truth": "Removes entity and returns removed descriptor.", "predict": " Response is generated by the method.\n */\npublic class DbEntityDescriptor {\n\tprivate final String tableName;\n\tprivate final String entityName;\n\tprivate final String entityClassName;\n\tprivate final String entityClassNameLowerCase;\n\tprivate final String entityClassNameUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetter;\n\tprivate final String entityClassNameLowerCaseFirstLetterUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCaseUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCaseUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCaseUpperCaseUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCaseUpperCaseUpperCase;\n\tprivate final String entityClassNameLowerCaseFirstLetterLowerCaseUpperCaseUpperCaseUpperCase;\n\tprivate"}, {"ID": 1122, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E createEntityInstance(final Class<E> type) { try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new DbOomException(ex); } } \nResponse:", "ground_truth": "Creates new entity instances.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1123, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WrapperProxettaFactory setTargetInterface(final Class targetInterface) { if (!targetInterface.isInterface()) { throw new ProxettaException(\"Not an interface: \" + targetInterface.getName()); } this.targetInterface = targetInterface; return this; } \nResponse:", "ground_truth": "Defines the interface of the resulting class.", "predict": " public WrapperProxettaFactory setTargetInterface(final Class targetInterface) { return setTargetInterface(targetInterface); } \n\n*/\n\npublic class WrapperProxettaFactory {\n\t\n\tprivate static final Logger LOG = LoggerFactory.getLogger(WrapperProxettaFactory.class);\n\t\n\tprivate static final String PROXETTA_FACTORY_CLASS_NAME = \"org.springframework.web.servlet.view.proxetta.ProxettaViewResolver\";\n\tprivate static final String PROXETTA_FACTORY_CLASS_NAME_WITH_SPRING_WEB_MVC = \"org.springframework.web.servlet.view.proxetta.SpringProxettaViewResolver\";\n\t\n\tprivate static final String PROXETTA_FACTORY_METHOD_NAME = \"setTargetInterface\";\n\tprivate static final String PROXETTA_FACTORY_METHOD_NAME_"}, {"ID": 1124, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectTargetIntoWrapper(final Object target, final Object wrapper) { ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName); } \nResponse:", "ground_truth": "Injects target into wrapper.", "predict": "\n\npublic void injectTargetIntoWrapper(final Object target, final Object wrapper, final String targetFieldName) {\n    try {\n        final Field field = wrapper.getClass().getDeclaredField(targetFieldName);\n        field.setAccessible(true);\n        field.set(wrapper, target);\n    } catch (final Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\n*/\n\npublic class ProxettaUtil {\n\n    public static void injectTargetIntoWrapper(final Object target, final Object wrapper, final String targetFieldName) {\n        try {\n            final Field field = wrapper.getClass().getDeclaredField(targetFieldName);\n            field.setAccessible(true);\n            field.set(wrapper, target);\n        } catch (final Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"}, {"ID": 1125, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) { PropertyDescriptor[] properties = annotatedProperties.get(type); if (properties != null) { return properties; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); List<PropertyDescriptor> list = new ArrayList<>(); for (PropertyDescriptor propertyDescriptor : allProperties) { Annotation ann = null; if (propertyDescriptor.getFieldDescriptor() != null) { ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) { ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) { ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann != null) { list.add(propertyDescriptor); } } if (list.isEmpty()) { properties = EMPTY; } else { properties = list.toArray(new PropertyDescriptor[0]); } annotatedProperties.put(type, properties); return properties; } \nResponse:", "ground_truth": "Lookups for annotated properties. Caches all annotated properties on the first\naction class scan.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonView;\n\n@Component\npublic class Response {\n\t\n\t@Autowired\n\tprivate PropertyDescriptor[] properties;\n\t\n\t@JsonProperty(\"properties\")\n\t@JsonView(Views.All.class)\n\tpublic PropertyDescriptor[] getProperties() {\n\t\treturn properties;\n\t}\n\t\n\t@JsonProperty(\"properties\")\n\tpublic void setProperties(PropertyDescriptor"}, {"ID": 1126, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) { cp.init(); final Connection connection = cp.getConnection(); final DbServer dbServer = detectDatabase(connection); cp.closeConnection(connection); dbServer.accept(dbOomConfig); return dbServer; } \nResponse:", "ground_truth": "Detects database and configure DbOom engine.", "predict": " public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) { cp.init(); final Connection connection = cp.getConnection(); final DbServer dbServer = detectDatabase(connection); cp.closeConnection(connection); dbServer.accept(dbOomConfig); return dbServer; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class DbServer {\n\n\tprivate final String name;\n\tprivate final String description;\n\tprivate final List<DbOomConfig> dbO"}, {"ID": 1127, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void close() throws IOException { if (closed) { return; } if (gzipstream != null) { flushToGZip(); gzipstream.close(); gzipstream = null; } else { if (bufferCount > 0) { output.write(buffer, 0, bufferCount); bufferCount = 0; } } output.close(); closed = true; } \nResponse:", "ground_truth": "Closes this output stream, causing any buffered data to be flushed and any\nfurther output data to throw an IOException.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class GZipOutputStream extends OutputStream {\n    private final GZIPOutputStream gzipstream;\n    private final byte[] buffer;\n    private int bufferCount;\n\n    public GZipOutputStream(OutputStream out) throws IOException {\n        gzipstream = new GZIPOutputStream(out);\n        buffer = new byte[1024];\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        bufferCount++;\n        if (bufferCount == buffer.length) {\n            flushToGZip();\n        }\n        buffer[bufferCount] = (byte) b;\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        int count = 0;\n        while (count <"}, {"ID": 1128, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void write(final int b) throws IOException { if (closed) { throw new IOException(\"Cannot write to a closed output stream\"); } if (bufferCount >= buffer.length) { flushToGZip(); } buffer[bufferCount++] = (byte) b; } \nResponse:", "ground_truth": "Writes the specified byte to our output stream.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class GZIPOutputStream extends OutputStream {\n    private final GZIPOutputStream gzipos;\n    private final byte[] buffer;\n    private int bufferCount;\n\n    public GZIPOutputStream(final OutputStream out) throws IOException {\n        gzipos = new GZIPOutputStream(out);\n        buffer = new byte[1024];\n    }\n\n    @Override\n    public void write(final int b) throws IOException {\n        if (closed) {\n            throw new IOException(\"Cannot write to a closed output stream\");\n        }\n        if (bufferCount >= buffer.length) {\n            flushToGZip();\n        }\n        buffer[bufferCount++] = (byte) b;\n    }\n\n    @Override\n    public void write(final"}, {"ID": 1129, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; if (isRequestedSessionIdFromURL(httpRequest)) { HttpSession session = httpRequest.getSession(false); if (session != null) { session.invalidate(); // clear session if session id in URL } } // wrap response to remove URL encoding HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) { @Override public String encodeRedirectUrl(final String url) { return url; } @Override public String encodeRedirectURL(final String url) { return url; } @Override public String encodeUrl(final String url) { return url; } @Override public String encodeURL(final String url) { return url; } }; chain.doFilter(request, wrappedResponse); } \nResponse:", "ground_truth": "Filters requests to remove URL-based session identifiers.", "predict": "\n\n@Override\npublic void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\tif (isRequestedSessionIdFromURL(httpRequest)) {\n\t\tHttpSession session = httpRequest.getSession(false);\n\t\tif (session != null) {\n\t\t\tsession.invalidate();\n\t\t}\n\t}\n\tchain.doFilter(request, response);\n}\n\nprivate boolean isRequestedSessionIdFromURL(final HttpServletRequest httpRequest) {\n\tString requestURI = httpRequest.getRequestURI();\n\treturn requestURI.endsWith(\"/session\") && httpRequest.getQueryString() != null && httpRequest.getQueryString().contains(\"jsessionid\");\n}\n\n@Override\npublic void"}, {"ID": 1130, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getEncodedName() { if (name == null) { return null; } try { return MimeUtility.encodeText(name); } catch (final UnsupportedEncodingException ueex) { throw new MailException(ueex); } } \nResponse:", "ground_truth": "Returns encoded attachment name.\n\n@return encoded attachment name. Value may be {@code null}.", "predict": "\n\n*/\n\npublic class EncodedName {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString name = \"test\";\n\t\t\n\t\ttry {\n\t\t\tname = MimeUtility.encodeText(name);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tSystem.out.println(name);\n\t\t\n\t}\n\n}\n"}, {"ID": 1131, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] toByteArray() { final FastByteArrayOutputStream out; if (size != -1) { out = new FastByteArrayOutputStream(size); } else { out = new FastByteArrayOutputStream(); } writeToStream(out); return out.toByteArray(); } \nResponse:", "ground_truth": "Returns byte content of the attachment.\n\n@return byte array with content of the attachment.", "predict": " Response = new Response(out.toByteArray());\n\n*/\n\npublic class Response {\n\tprivate byte[] data;\n\t\n\tpublic Response(byte[] data) {\n\t\tthis.data = data;\n\t}\n\t\n\tpublic byte[] getData() {\n\t\treturn data;\n\t}\n}\n"}, {"ID": 1132, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeToFile(final File destination) { InputStream input = null; final OutputStream output; try { input = getDataSource().getInputStream(); output = new FileOutputStream(destination); StreamUtil.copy(input, output); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } } \nResponse:", "ground_truth": "Saves attachment to a file.\n\n@param destination The destination file to be written.", "predict": "\n\n*/\n\npublic class FileWriter {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(FileWriter.class);\n\t\n\tprivate final File file;\n\tprivate final String content;\n\t\n\tpublic FileWriter(final File file, final String content) {\n\t\tthis.file = file;\n\t\tthis.content = content;\n\t}\n\t\n\tpublic void writeToFile() {\n\t\ttry {\n\t\t\tfinal FileOutputStream output = new FileOutputStream(file);\n\t\t\ttry {\n\t\t\t\toutput.write(content.getBytes());\n\t\t\t} finally {\n\t\t\t\tStreamUtil.close(output);\n\t\t\t}\n\t\t} catch (final IOException ioex) {\n\t\t\tthrow new MailException(ioex);\n\t\t}\n\t}\n\t\n}\n"}, {"ID": 1133, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeToStream(final OutputStream out) { InputStream input = null; try { input = getDataSource().getInputStream(); StreamUtil.copy(input, out); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } } \nResponse:", "ground_truth": "Saves attachment to the output stream.\n\n@param out OutputStream where attachment should be copied to.", "predict": " Response is generated by the method.\n */\n\npublic class StreamUtil {\n    public static void copy(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[8192];\n        int bytesRead = -1;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n    }\n}\n"}, {"ID": 1134, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String appendArgument(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx) + type + desc.substring(ndx); } \nResponse:", "ground_truth": "Appends argument to the existing description.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1135, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); } \nResponse:", "ground_truth": "Prepends argument to the existing description.", "predict": "\n\npublic static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String desc = \"public static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); }\";\n        System.out.println(prependArgument(desc, \"String\"));\n    }\n    \n    public static String prependArgument(String desc, String type) {\n        int ndx = desc.indexOf('(');\n        return desc.substring(0, ndx) + type + desc.substring(ndx"}, {"ID": 1136, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; } \nResponse:", "ground_truth": "Changes return type.", "predict": "\n\npublic static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String desc = \"public static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; } \";\n        String type = \"String\";\n        System.out.println(changeReturnType(desc, type));\n    }\n    \n    public static String changeReturnType(String desc, String type) {\n        int ndx = desc.indexOf(')');\n        return desc.substring(0, ndx + 1) + type;\n    }\n}\n"}, {"ID": 1137, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void text(final CharSequence text) { if (!strip) { super.text(text); return; } int textLength = text.length(); char[] dest = new char[textLength]; int ndx = 0; boolean regularChar = true; for (int i = 0; i < textLength; i++) { char c = text.charAt(i); if (CharUtil.isWhitespace(c)) { if (regularChar) { regularChar = false; c = ' '; } else { continue; } } else { regularChar = true; } dest[ndx] = c; ndx++; } if (regularChar || (ndx != 1)) { super.text(CharBuffer.wrap(dest, 0, ndx)); strippedCharsCount += textLength - ndx; } else { strippedCharsCount += textLength; } } \nResponse:", "ground_truth": "Cleans unnecessary whitespaces.", "predict": "\n\npublic void text(final CharSequence text) {\n    if (!strip) {\n        super.text(text);\n        return;\n    }\n    int textLength = text.length();\n    char[] dest = new char[textLength];\n    int ndx = 0;\n    boolean regularChar = true;\n    for (int i = 0; i < textLength; i++) {\n        char c = text.charAt(i);\n        if (CharUtil.isWhitespace(c)) {\n            if (regularChar) {\n                regularChar = false;\n                c = ' ';\n            } else {\n                continue;\n            }\n        } else {\n            regularChar = true;\n        }\n        dest[ndx] = c;\n        ndx++;\n    }\n    if (regularChar || (ndx != 1)) {\n        super.text(CharBuffer.wrap(dest, 0, n"}, {"ID": 1138, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) { converters.put(type, typeConverter); } \nResponse:", "ground_truth": "Registers a converter for specified type.\nUser must register converter for all super-classes as well.\n\n@param type\t\tclass that converter is for\n@param typeConverter\tconverter for provided class", "predict": " Resp public <T> TypeConverter<T> getConverter(final Class<T> type) { return converters.get(type); } \nResp Resp public <T> TypeConverter<T> getConverter(final Class<T> type, final TypeConverter<T> defaultConverter) { return converters.get(type, defaultConverter); } \nResp Resp public <T> TypeConverter<T> getConverter(final Class<T> type, final TypeConverter<T> defaultConverter, final TypeConverter<T> fallbackConverter) { return converters.get(type, defaultConverter, fallbackConverter); } \nResp Resp public <T> TypeConverter<T> getConverter(final Class<T> type, final TypeConverter<T> defaultConverter, final TypeConverter"}, {"ID": 1139, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); } \nResponse:", "ground_truth": "Retrieves converter for provided type. Only registered types are matched,\ntherefore subclasses must be also registered.\n\n@return founded converter or null", "predict": " Resp public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); } \n\n*/\n\npublic class TypeConverter<T> {\n\tprivate final Class<T> type;\n\tprivate final TypeConverter<T> parent;\n\tprivate final Map<Class<?>, TypeConverter<T>> children;\n\t\n\tpublic TypeConverter(final Class<T> type, final TypeConverter<T> parent) {\n\t\tthis.type = type;\n\t\tthis.parent = parent;\n\t\tthis.children = new HashMap<Class<?>, TypeConverter<T>>();\n\t}\n\t\n\tpublic TypeConverter(final Class<T> type) {\n\t\tthis(type, null);\n\t}\n\t\n\tpublic Class<T> getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic TypeConverter"}, {"ID": 1140, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Node> select(final String query) { Collection<List<CssSelector>> selectorsCollection = CSSelly.parse(query); return select(selectorsCollection); } \nResponse:", "ground_truth": "Selects nodes using CSS3 selector query.", "predict": " public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { return CSSelly.select(selectorsCollection); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\n\npublic class CSSelly {\n\n\tpublic static List<Node> select(final Collection<List<CssSelector>> selectorsCollection) {\n\t\tList<Node> nodes = new ArrayList<Node>();\n\t\tfor (List<CssSelector> selectors : selectorsCollection) {\n\t\t\tnodes.add(new Node(selectors));\n\t\t}\n\t\treturn nodes;\n\t}\n\n\tpublic static List<CssSelector> parse(final String query) {\n\t\tList<CssSelector>"}, {"ID": 1141, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { List<Node> results = new ArrayList<>(); for (List<CssSelector> selectors : selectorsCollection) { processSelectors(results, selectors); } return results; } \nResponse:", "ground_truth": "Selected nodes using pre-parsed CSS selectors. Take in consideration\ncollection type for results grouping order.", "predict": " public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { List<Node> results = new ArrayList<>(); for (List<CssSelector> selectors : selectorsCollection) { processSelectors(results, selectors); } return results; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CssSelector {\n\tprivate String selector;\n\tprivate List<CssSelector> children;\n\t\n\tpublic CssSelector(String selector) {\n\t\tthis.selector = selector;\n\t\tchildren = new ArrayList<>();\n\t}\n\t\n\tpublic void addChild(CssSelector child) {\n\t\tchildren.add(child);\n\t}\n\t\n\tpublic String getSelector() {\n\t\treturn selector;\n\t}\n\t\n\tpublic List<CssSelector> getChildren() {\n\t\treturn children"}, {"ID": 1142, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) { List<Node> selectedNodes = select(rootNode, selectors); for (Node selectedNode : selectedNodes) { if (!results.contains(selectedNode)) { results.add(selectedNode); } } } \nResponse:", "ground_truth": "Process selectors and keep adding results.", "predict": " Response = new Response(results);\n\n*/\n\npublic class Selector {\n\t\n\tprivate final String selector;\n\tprivate final String[] parts;\n\tprivate final String[] parts2;\n\tprivate final String[] parts3;\n\tprivate final String[] parts4;\n\tprivate final String[] parts5;\n\tprivate final String[] parts6;\n\tprivate final String[] parts7;\n\tprivate final String[] parts8;\n\tprivate final String[] parts9;\n\tprivate final String[] parts10;\n\tprivate final String[] parts11;\n\tprivate final String[] parts12;\n\tprivate final String[] parts13;\n\tprivate final String[] parts14;\n\tprivate final String[] parts15;\n\tprivate final String[] parts16;\n\tprivate final String[] parts17;\n\tprivate final String[] parts18;\n\tprivate final String[] parts19;\n\tprivate final String[] parts20;\n\tprivate final String[] parts21;\n\t"}, {"ID": 1143, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node selectFirst(final String query) { List<Node> selectedNodes = select(query); if (selectedNodes.isEmpty()) { return null; } return selectedNodes.get(0); } \nResponse:", "ground_truth": "Selects nodes using CSS3 selector query and returns the very first one.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1144, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void walkDescendantsIteratively(final LinkedList<Node> nodes, final CssSelector cssSelector, final List<Node> result) { while (!nodes.isEmpty()) { Node node = nodes.removeFirst(); selectAndAdd(node, cssSelector, result); // append children in walking order to be processed right after this node int childCount = node.getChildNodesCount(); for (int i = childCount - 1; i >= 0; i--) { nodes.addFirst(node.getChild(i)); } } } \nResponse:", "ground_truth": "Walks over the child notes, maintaining the tree order and not using recursion.", "predict": "\n\n*/\n\npublic class Solution {\n    public List<Node> findLeaves(Node root) {\n        List<Node> result = new ArrayList<Node>();\n        findLeaves(root, result);\n        return result;\n    }\n    \n    private void findLeaves(Node node, List<Node> result) {\n        if (node.getChildNodesCount() == 0) {\n            result.add(node);\n        }\n        for (int i = 0; i < node.getChildNodesCount(); i++) {\n            findLeaves(node.getChild(i), result);\n        }\n    }\n}\n"}, {"ID": 1145, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void walk(final Node rootNode, final CssSelector cssSelector, final List<Node> result) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector.getPrevCssSelector(); Combinator combinator = previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT; switch (combinator) { case DESCENDANT: LinkedList<Node> nodes = new LinkedList<>(); int childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { nodes.add(rootNode.getChild(i)); // recursive // selectAndAdd(node, cssSelector, result); // walk(node, cssSelector, result); } walkDescendantsIteratively(nodes, cssSelector, result); break; case CHILD: childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node node = rootNode.getChild(i); selectAndAdd(node, cssSelector, result); } break; case ADJACENT_SIBLING: Node node = rootNode.getNextSiblingElement(); if (node != null) { selectAndAdd(node, cssSelector, result); } break; case GENERAL_SIBLING: node = rootNode; while (true) { node = node.getNextSiblingElement(); if (node == null) { break; } selectAndAdd(node, cssSelector, result); } break; } } \nResponse:", "ground_truth": "Finds nodes in the tree that matches single selector.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.selectAndAdd(new Node(\"root\"), new CssSelector(\"a\"), new ArrayList<Node>());\n    }\n\n    public void selectAndAdd(Node rootNode, CssSelector cssSelector, List<Node> result) {\n        if (rootNode == null) {\n            return;\n        }\n        if (rootNode.getChildNodesCount() == 0) {\n            if (cssSelector.getCombinator() == Combinator.DESCENDANT) {\n                result.add(rootNode);\n            }\n            return;\n        }\n        if (cssSelector.getCombinator() == Combinator.DESCENDANT) {\n            selectAndAddDescendants(rootNode"}, {"ID": 1146, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void selectAndAdd(final Node node, final CssSelector cssSelector, final List<Node> result) { // ignore all nodes that are not elements if (node.getNodeType() != Node.NodeType.ELEMENT) { return; } boolean matched = cssSelector.accept(node); if (matched) { // check for duplicates if (result.contains(node)) { return; } // no duplicate found, add it to the results result.add(node); } } \nResponse:", "ground_truth": "Selects single node for single selector and appends it to the results.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static void main(String[] args) {\n        String input = \"div.class1 div.class2 div.class3\";\n        String regex = \"\\\\.class(\\\\w+)\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n        List<String> result = new ArrayList<>();\n        while (matcher.find()) {\n            result.add(matcher.group(1));\n        }\n        for (String s : result) {\n            System.out.println(s);\n        }\n    }\n}\n"}, {"ID": 1147, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean filter(final List<Node> currentResults, final Node node, final CssSelector cssSelector, final int index) { return cssSelector.accept(currentResults, node, index); } \nResponse:", "ground_truth": "Filter nodes.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1148, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static char [] zzUnpackCMap(final String packed) { char [] map = new char[0x110000]; int i = 0; /* index in packed string */ int j = 0; /* index in unpacked array */ while (i < 128) { int count = packed.charAt(i++); char value = packed.charAt(i++); do map[j++] = value; while (--count > 0); } return map; } \nResponse:", "ground_truth": "Unpacks the compressed character translation table.\n\n@param packed   the packed character translation table\n@return         the unpacked character translation table", "predict": "\n\npublic static class Response {\n    public static class Response {\n        public static class Response {\n            public static class Response {\n                public static class Response {\n                    public static class Response {\n                        public static class Response {\n                            public static class Response {\n                                public static class Response {\n                                    public static class Response {\n                                        public static class Response {\n                                            public static class Response {\n                                                public static class Response {\n                                                    public static class Response {\n                                                        public static class Response {\n                                                            public static class Response {\n                                                                public static class Response {\n                                                                    public static class Response {\n                                                                        public static class Response {\n                                                                            public static class Response {\n                                                                                public static class Response {\n                                                                                    public static class Response {\n                                                                                        public static class Response {\n"}, {"ID": 1149, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean zzRefill() { if (zzBuffer == null) { zzBuffer = zzChars; zzEndRead += zzChars.length; return false; } return true; } \nResponse:", "ground_truth": "Refills the input buffer.\n\n@return      false, iff there was new input.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.lucene.analysis.Analyzer;\nimport org.apache.lucene.analysis.TokenStream;\nimport org.apache.lucene.analysis.standard.StandardAnalyzer;\nimport org.apache.lucene.analysis.tokenattributes.CharTermAttribute;\nimport org.apache.lucene.analysis.tokenattributes.OffsetAttribute;\nimport org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;\nimport org.apache.lucene.analysis.tokenattributes.TypeAttribute;\nimport org.apache.luc"}, {"ID": 1150, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <T> PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) { if (sortColumnName != null) { sql = buildOrderSql(sql, sortColumnName, ascending); } int from = (page - 1) * pageSize; String pageSql = buildPageSql(sql, from, pageSize); DbSqlBuilder dbsql = sql(pageSql); DbOomQuery query = query(dbsql); query.setMaxRows(pageSize); query.setFetchSize(pageSize); query.setMap(params); List<T> list = query.list(pageSize, target); query.close(); String countSql = buildCountSql(sql); dbsql = sql(countSql); query = query(dbsql); query.setMap(params); long count = query.executeCount(); query.close(); return new PageData<>(page, (int) count, pageSize, list); } \nResponse:", "ground_truth": "Pages given page.\n\n@param sql sql query that lists all items\n@param params map of SQL parameters\n@param page current page to show\n@param pageSize number of items to show\n@param sortColumnName name of sorting column, null for no sorting\n@param ascending true for ascending order\n@param target db entities for mapping (sa usual in DbOom)", "predict": "\n\npublic PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) { if (sortColumnName != null) { sql = buildOrderSql(sql, sortColumnName, ascending); } int from = (page - 1) * pageSize; String pageSql = buildPageSql(sql, from, pageSize); DbSqlBuilder dbsql = sql(pageSql); DbOomQuery query = query(dbsql); query.setMaxRows(pageSize); query.setFetchSize(pageSize); query.setMap(params); List<T> list = query.list(pageSize, target); query.close(); String countSql = buildCountSql(sql); dbsql = sql(countSql); query = query(dbsql); query.setMap(params); long count = query.executeCount(); query"}, {"ID": 1151, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeSelect(String sql) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"select\"); if (ndx != -1) { sql = sql.substring(ndx + 6); // select.length() } return sql; } \nResponse:", "ground_truth": "Removes the first 'select' from the sql query.", "predict": "\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tString sql = \"select * from table where id = ?\";\n\t\tString sql2 = \"select * from table where id = ?\";\n\t\tString sql3 = \"select * from table where id = ?\";\n\t\tString sql4 = \"select * from table where id = ?\";\n\t\tString sql5 = \"select * from table where id = ?\";\n\t\tString sql6 = \"select * from table where id = ?\";\n\t\tString sql7 = \"select * from table where id = ?\";\n\t\tString sql8 = \"select * from table where id = ?\";\n\t\tString sql9 = \"select * from table where id = ?\";\n\t\tString sql10 = \"select * from table where id = ?\";\n\t\tString sql11 = \"select * from table where id = ?\";\n\t\tString sql12 = \"select * from table where"}, {"ID": 1152, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeToFrom(String sql) { int from = 0; int fromCount = 1; int selectCount = 0; int lastNdx = 0; while (true) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from); if (ndx == -1) { break; } // count selects in left part String left = sql.substring(lastNdx, ndx); selectCount += StringUtil.countIgnoreCase(left, \"select\"); if (fromCount >= selectCount) { sql = sql.substring(ndx); break; } // find next 'from' lastNdx = ndx; from = ndx + 4; fromCount++; } return sql; } \nResponse:", "ground_truth": "Removes the first part of the sql up to the relevant 'from'.\nTries to detect sub-queries in the 'select' part.", "predict": "\n\npublic String removeToFrom(String sql) { int from = 0; int fromCount = 1; int selectCount = 0; int lastNdx = 0; while (true) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from); if (ndx == -1) { break; } // count selects in left part String left = sql.substring(lastNdx, ndx); selectCount += StringUtil.countIgnoreCase(left, \"select\"); if (fromCount >= selectCount) { sql = sql.substring(ndx); break; } // find next 'from' lastNdx = ndx; from = ndx + 4; fromCount++; } return sql; } \n\n*/\n\npublic class Solution {\n    public String removeToFrom(String sql) {\n        int from = 0;\n        int fromCount = 1;\n        int selectCount = 0;\n        int lastNdx = 0;"}, {"ID": 1153, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeLastOrderBy(String sql) { int ndx = StringUtil.lastIndexOfIgnoreCase(sql, \"order by\"); if (ndx != -1) { int ndx2 = sql.lastIndexOf(sql, ')'); if (ndx > ndx2) { sql = sql.substring(0, ndx); } } return sql; } \nResponse:", "ground_truth": "Removes everything from last \"order by\".", "predict": "\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tString sql = \"select * from test where id = ? order by id desc\";\n\t\tString sql2 = \"select * from test where id = ? order by id asc\";\n\t\tString sql3 = \"select * from test where id = ? order by id desc\";\n\t\tString sql4 = \"select * from test where id = ? order by id asc\";\n\t\tString sql5 = \"select * from test where id = ? order by id desc\";\n\t\tString sql6 = \"select * from test where id = ? order by id asc\";\n\t\tString sql7 = \"select * from test where id = ? order by id desc\";\n\t\tString sql8 = \"select * from test where id = ? order by id asc\";\n\t\tString sql9 = \"select * from test where id = ? order by id desc\";\n\t\tString sql10 = \"select * from test where id = ? order by id asc"}, {"ID": 1154, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(final String html) { int ndx = html.indexOf('&'); if (ndx == -1) { return html; } StringBuilder result = new StringBuilder(html.length()); int lastIndex = 0; int len = html.length(); mainloop: while (ndx != -1) { result.append(html.substring(lastIndex, ndx)); lastIndex = ndx; while (html.charAt(lastIndex) != ';') { lastIndex++; if (lastIndex == len) { lastIndex = ndx; break mainloop; } } if (html.charAt(ndx + 1) == '#') { // decimal/hex char c = html.charAt(ndx + 2); int radix; if ((c == 'x') || (c == 'X')) { radix = 16; ndx += 3; } else { radix = 10; ndx += 2; } String number = html.substring(ndx, lastIndex); int i = Integer.parseInt(number, radix); result.append((char) i); lastIndex++; } else { // token String encodeToken = html.substring(ndx + 1, lastIndex); char[] replacement = ENTITY_MAP.get(encodeToken); if (replacement == null) { result.append('&'); lastIndex = ndx + 1; } else { result.append(replacement); lastIndex++; } } ndx = html.indexOf('&', lastIndex); } result.append(html.substring(lastIndex)); return result.toString(); } \nResponse:", "ground_truth": "Decodes HTML text. Assumes that all character references are properly closed with semi-colon.", "predict": "\n\npublic static String decode(final String html) { int ndx = html.indexOf('&'); if (ndx == -1) { return html; } StringBuilder result = new StringBuilder(html.length()); int lastIndex = 0; int len = html.length(); mainloop: while (ndx != -1) { result.append(html.substring(lastIndex, ndx)); lastIndex = ndx; while (html.charAt(lastIndex) != ';') { lastIndex++; if (lastIndex == len) { lastIndex = ndx; break mainloop; } } if (html.charAt(ndx + 1) == '#') { // decimal/hex char c = html.charAt(ndx + 2); int radix; if ((c == 'x') || (c == 'X')) { radix = 16; ndx += 3; } else { radix = 10; ndx += 2; } String number = html.sub"}, {"ID": 1155, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String detectName(final char[] input, int ndx) { final Ptr ptr = new Ptr(); int firstIndex = 0; int lastIndex = ENTITY_NAMES.length - 1; int len = input.length; char[] lastName = null; final BinarySearchBase binarySearch = new BinarySearchBase() { @Override protected int compare(final int index) { char[] name = ENTITY_NAMES[index]; if (ptr.offset >= name.length) { return -1; } return name[ptr.offset] - ptr.c; } }; while (true) { ptr.c = input[ndx]; if (!CharUtil.isAlphaOrDigit(ptr.c)) { return lastName != null ? new String(lastName) : null; } firstIndex = binarySearch.findFirst(firstIndex, lastIndex); if (firstIndex < 0) { return lastName != null ? new String(lastName) : null; } char[] element = ENTITY_NAMES[firstIndex]; if (element.length == ptr.offset + 1) { // total match, remember position, continue for finding the longer name lastName = ENTITY_NAMES[firstIndex]; } lastIndex = binarySearch.findLast(firstIndex, lastIndex); if (firstIndex == lastIndex) { // only one element found, check the rest for (int i = ptr.offset; i < element.length; i++) { if (element[i] != input[ndx]) { return lastName != null ? new String(lastName) : null; } ndx++; } return new String(element); } ptr.offset++; ndx++; if (ndx == len) { return lastName != null ? new String(lastName) : null; } } } \nResponse:", "ground_truth": "Detects the longest character reference name on given position in char array.", "predict": "\npublic static String detectName(final char[] input, int ndx) { final Ptr ptr = new Ptr(); int firstIndex = 0; int lastIndex = ENTITY_NAMES.length - 1; int len = input.length; char[] lastName = null; final BinarySearchBase binarySearch = new BinarySearchBase() { @Override protected int compare(final int index) { char[] name = ENTITY_NAMES[index]; if (ptr.offset >= name.length) { return -1; } return name[ptr.offset] - ptr.c; } }; while (true) { ptr.c = input[ndx]; if (!CharUtil.isAlphaOrDigit(ptr.c)) { return lastName != null ? new String(lastName) : null; } firstIndex = binarySearch.findFirst(firstIndex, lastIndex); if (firstIndex < 0) { return lastName != null ? new String(lastName) : null; } char[] element ="}, {"ID": 1156, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String buildOrderSql(String sql, final String column, final boolean ascending) { sql += \" order by \" + column; if (!ascending) { sql += \" desc\"; } return sql; } \nResponse:", "ground_truth": "Appends ORDER BY keyword.", "predict": "\n\n@Override\nprotected String buildOrderSql(String sql, final String column, final boolean ascending) {\n\tsql += \" order by \" + column; if (!ascending) { sql += \" desc\"; } return sql;\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\n\npublic class OrderByBuilder {\n\t\n\tprivate static final String ORDER_BY_SEPARATOR = \" order by \";\n\tprivate static final String ASCENDING_ORDER = \" asc\";\n\tprivate static final String DESCENDING_ORDER = \" desc\";\n\t\n\tprivate static final String ORDER_BY_SEPARATOR_REGEX = \"\\\\s*order\\\\s*by\\\\s*\";\n\tprivate static final String ASCENDING_ORDER_REGEX = \"\\\\"}, {"ID": 1157, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String buildPageSql(String sql, final int from, final int pageSize) { sql = removeSelect(sql); return \"select LIMIT \" + from + ' ' + pageSize + sql; } \nResponse:", "ground_truth": "Builds page sql using LIMIT keyword after the SELECT.", "predict": "\n\n@Override\nprotected String buildPageSql(String sql, final int from, final int pageSize) {\n\tsql = removeSelect(sql);\n\treturn \"select LIMIT \" + from + ' ' + pageSize + sql;\n}\n\n@Override\nprotected String buildPageSql(String sql, final int from, final int pageSize, final int offset) {\n\tsql = removeSelect(sql);\n\treturn \"select LIMIT \" + from + ' ' + pageSize + ' ' + offset + sql;\n}\n\n@Override\nprotected String buildPageSql(String sql, final int from, final int pageSize, final int offset, final int count) {\n\tsql = removeSelect(sql);\n\treturn \"select LIMIT \" + from + ' ' + pageSize + ' ' + offset + ' ' + count + sql;\n}\n\n@Override\nprotected String buildPageSql(String sql, final int from, final int pageSize,"}, {"ID": 1158, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void resolveColumnsAndProperties(final Class type) { PropertyDescriptor[] allProperties = ClassIntrospector.get().lookup(type).getAllPropertyDescriptors(); List<DbEntityColumnDescriptor> decList = new ArrayList<>(allProperties.length); int idcount = 0; HashSet<String> names = new HashSet<>(allProperties.length); for (PropertyDescriptor propertyDescriptor : allProperties) { DbEntityColumnDescriptor dec = DbMetaUtil.resolveColumnDescriptors(this, propertyDescriptor, isAnnotated, columnNamingStrategy); if (dec != null) { if (!names.add(dec.getColumnName())) { throw new DbOomException(\"Duplicate column name: \" + dec.getColumnName()); } decList.add(dec); if (dec.isId) { idcount++; } } } if (decList.isEmpty()) { throw new DbOomException(\"No column mappings in entity: \" + type); } columnDescriptors = decList.toArray(new DbEntityColumnDescriptor[0]); Arrays.sort(columnDescriptors); // extract ids from sorted list if (idcount > 0) { idColumnDescriptors = new DbEntityColumnDescriptor[idcount]; idcount = 0; for (DbEntityColumnDescriptor dec : columnDescriptors) { if (dec.isId) { idColumnDescriptors[idcount++] = dec; } } } } \nResponse:", "ground_truth": "Resolves list of all columns and properties.", "predict": "\n\n*/\n\npackage com.github.dannil.scbjavaclient.model;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameter;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport static org.junit.Assert.assertEquals;\n\nimport com.github.dannil.scbjavaclient.test.extensions.Suite;\n\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ColumnDescriptorTest.class,\n        ColumnDescriptorTest.class\n})\npublic class ColumnDescriptorTest {\n\n    @Parameter\n    public String columnDescriptor;\n\n    @Parameters\n    public static Collection"}, {"ID": 1159, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityColumnDescriptor findByColumnName(final String columnName) { if (columnName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.columnName.equalsIgnoreCase(columnName)) { return columnDescriptor; } } return null; } \nResponse:", "ground_truth": "Finds column descriptor by column name. Case is ignored.", "predict": " Response = Response.ok().build();\n\n*/\n\npackage com.jivesoftware.os.upena.deployable.profiler.service.interceptor;\n\nimport com.jivesoftware.os.upena.deployable.profiler.service.ProfilerService;\nimport com.jivesoftware.os.upena.deployable.profiler.service.ProfilerService.FindByColumnName;\nimport com.jivesoftware.os.upena.deployable.profiler.service.ProfilerService.FindByColumnNameResponse;\nimport com.jivesoftware.os.upena.deployable.profiler.service.ProfilerService.FindByColumnNameResponse.FindByColumnNameResponseRow;\nimport com.jivesoftware.os.upena.deployable.profiler.service.ProfilerService.FindByColumnNameResponse.FindByColumnNameResponseRow.FindByColumnNameResponse"}, {"ID": 1160, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityColumnDescriptor findByPropertyName(final String propertyName) { if (propertyName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.propertyName.equals(propertyName)) { return columnDescriptor; } } return null; } \nResponse:", "ground_truth": "Finds column descriptor by property name.", "predict": " ResponseEntity<List<DbEntityColumnDescriptor>> findByPropertyName(final String propertyName);\n\n@RequestMapping(value = \"/{id}/columns\", method = RequestMethod.GET)\n@ResponseBody\npublic List<DbEntityColumnDescriptor> findColumnDescriptorsByEntityId(@PathVariable(\"id\") final Long id) {\n\treturn entityColumnDescriptorRepository.findByEntityId(id);\n}\n\n@RequestMapping(value = \"/{id}/columns\", method = RequestMethod.POST)\n@ResponseBody\npublic ResponseEntity<List<DbEntityColumnDescriptor>> createColumnDescriptors(@PathVariable(\"id\") final Long id, @RequestBody final List<DbEntityColumnDescriptor> columnDescriptors) {\n\tfinal List<DbEntityColumnDescriptor> createdColumnDescriptors = entityColumnDescriptorRepository.save(columnDescriptors);\n\treturn new Response"}, {"ID": 1161, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPropertyName(final String columnName) { DbEntityColumnDescriptor dec = findByColumnName(columnName); return dec == null ? null : dec.propertyName; } \nResponse:", "ground_truth": "Returns property name for specified column name.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1162, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getColumnName(final String propertyName) { DbEntityColumnDescriptor dec = findByPropertyName(propertyName); return dec == null ? null : dec.columnName; } \nResponse:", "ground_truth": "Returns column name for specified property name..", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1163, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getIdValue(final E object) { final String propertyName = getIdPropertyName(); return BeanUtil.declared.getProperty(object, propertyName); } \nResponse:", "ground_truth": "Returns ID value for given entity instance.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1164, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setIdValue(final E object, final Object value) { final String propertyName = getIdPropertyName(); BeanUtil.declared.setProperty(object, propertyName, value); } \nResponse:", "ground_truth": "Sets ID value for given entity.", "predict": " Response is generated by the method.\n */\npublic class BeanUtil {\n\t\n\tpublic static void declared(final Object object, final String propertyName, final Object value) {\n\t\ttry {\n\t\t\tfinal Field declaredField = object.getClass().getDeclaredField(propertyName);\n\t\t\tdeclaredField.setAccessible(true);\n\t\t\tdeclaredField.set(object, value);\n\t\t} catch (final Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tpublic static void declared(final Object object, final String propertyName, final Object value, final boolean isAccessible) {\n\t\ttry {\n\t\t\tfinal Field declaredField = object.getClass().getDeclaredField(propertyName);\n\t\t\tdeclaredField.setAccessible(isAccessible);\n\t\t\tdeclaredField.set(object, value);\n\t\t} catch (final Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}"}, {"ID": 1165, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getKeyValue(final E object) { Object idValue = getIdValue(object); String idValueString = idValue == null ? StringPool.NULL : idValue.toString(); return type.getName().concat(StringPool.COLON).concat(idValueString); } \nResponse:", "ground_truth": "Returns unique key for this entity. Returned key\nis built from entity class and id value.", "predict": " Response is generated by the method getKeyValue(final E object) in the class KeyValueGenerator.\n\n*/\n\npublic class KeyValueGenerator {\n\tpublic static String getKeyValue(final E object) {\n\t\tObject idValue = getIdValue(object);\n\t\tString idValueString = idValue == null ? StringPool.NULL : idValue.toString();\n\t\treturn type.getName().concat(StringPool.COLON).concat(idValueString);\n\t}\n}"}, {"ID": 1166, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; } \nResponse:", "ground_truth": "Appends a string.", "predict": " public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; } \nResp public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; } \nResp public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; } \nResp public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity"}, {"ID": 1167, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setIndex(final int newIndex) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { String[] newArray = new String[newIndex]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } if (newIndex > index) { for (int i = index; i < newIndex; i++) { array[i] = StringPool.EMPTY; } } else if (newIndex < index) { for (int i = newIndex; i < index; i++) { array[i] = null; } } index = newIndex; length = calculateLength(); } \nResponse:", "ground_truth": "Specifies the new index.", "predict": " public void setIndex(final int newIndex, final String[] newArray) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { System.arraycopy(newArray, 0, array, 0, newIndex); } if (newIndex > index) { for (int i = index; i < newIndex; i++) { array[i] = StringPool.EMPTY; } } else if (newIndex < index) { for (int i = newIndex; i < index; i++) { array[i] = null; } } index = newIndex; length = calculateLength(); } \nResp public void setIndex(final int newIndex, final String[] newArray, final int newArrayLength) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { System.arraycopy(newArray, 0,"}, {"ID": 1168, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void expandCapacity() { String[] newArray = new String[array.length << 1]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } \nResponse:", "ground_truth": "Expands internal string array by multiplying its size by 2.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        int[] nums = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums2 = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums3 = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums4 = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums5 = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums6 = {1,2,3,4,5,6,7,8,9,"}, {"ID": 1169, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int calculateLength() { int len = 0; for (int i = 0; i < index; i++) { len += array[i].length(); } return len; } \nResponse:", "ground_truth": "Calculates string length.", "predict": "\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[128];\n        int max = 0;\n        int start = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (map[s.charAt(i)] == 0) {\n                start = i;\n            }\n            map[s.charAt(i)]++;\n            max = Math.max(max, i - start + 1);\n        }\n        return max;\n    }\n}\n\n*/\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[128];\n        int max = 0;\n        int start = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (map[s.charAt(i)] == 0) {\n"}, {"ID": 1170, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createMixingMessage(final BeanDefinition targetBeanDefinition, final BeanDefinition refBeanDefinition) { return \"Scopes mixing detected: \" + refBeanDefinition.name + \"@\" + refBeanDefinition.scope.getClass().getSimpleName() + \" -> \" + targetBeanDefinition.name + \"@\" + targetBeanDefinition.scope.getClass().getSimpleName(); } \nResponse:", "ground_truth": "Creates mixed scope message.", "predict": "\n\n*/\n\npackage org.springframework.beans.factory.support;\n\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.beans.factory.config.Scope;\nimport org.springframework.beans.factory.config.TypedStringValue;\nimport org.springframework.util.Assert;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * {@link Scope} implementation that simply stores a reference to a target scope.\n *\n * <p>This {@link Scope} implementation is typically used as a placeholder for a\n * {@link org.springframework.beans.factory.config.SingletonBeanReg"}, {"ID": 1171, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object createScopedProxyBean(final PetiteContainer petiteContainer, final BeanDefinition refBeanDefinition) { Class beanType = refBeanDefinition.type; Class proxyClass = proxyClasses.get(beanType); if (proxyClass == null) { // create proxy class only once if (refBeanDefinition instanceof ProxettaBeanDefinition) { // special case, double proxy! ProxettaBeanDefinition pbd = (ProxettaBeanDefinition) refBeanDefinition; ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspects(ArraysUtil.insert(pbd.proxyAspects, aspect, 0)); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(pbd.originalTarget); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } else { ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspect(aspect); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(beanType); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } } Object proxy; try { proxy = ClassUtil.newInstance(proxyClass); Field field = proxyClass.getField(\"$__petiteContainer$0\"); field.set(proxy, petiteContainer); field = proxyClass.getField(\"$__name$0\"); field.set(proxy, refBeanDefinition.name); } catch (Exception ex) { throw new PetiteException(ex); } return proxy; } \nResponse:", "ground_truth": "Creates scoped proxy bean for given bean definition.", "predict": "\n\n*/\n\npackage org.petite.proxetta.asm;\n\nimport org.petite.proxetta.ProxyAspect;\nimport org.petite.proxetta.ProxyAspectUtil;\nimport org.petite.proxetta.ProxyTarget;\nimport org.petite.proxetta.asm.util.AsmUtil;\nimport org.petite.proxetta.asm.util.AsmUtil.ClassWriterCallback;\nimport org.petite.proxetta.asm.util.AsmUtil.ClassWriterCallbackAdapter;\nimport org.petite.proxetta.asm.util.AsmUtil.ClassWriterCallbackAdapter.ClassVisitorAdapter;\nimport org.petite.proxetta.asm.util.AsmUtil.ClassWriterCallbackAdapter.FieldVisitorAdapter;\nimport org.petite.proxetta.asm.util.AsmUtil.ClassWriterCallback"}, {"ID": 1172, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void loopBody() throws JspException { JspFragment body = getJspBody(); if (body == null) { return; } LoopIterator loopIterator = new LoopIterator(start, end, step, modulus); if (status != null) { getJspContext().setAttribute(status, loopIterator); } while (loopIterator.next()) { TagUtil.invokeBody(body); } if (status != null) { getJspContext().removeAttribute(status); } } \nResponse:", "ground_truth": "Loops body.", "predict": " public void doTag() throws JspException, IOException { if (getJspBody() == null) { return; } LoopIterator loopIterator = (LoopIterator) getJspContext().getAttribute(status); if (loopIterator == null) { return; } try { loopBody(); } catch (JspException e) { throw e; } } \n\n}\n"}, {"ID": 1173, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void init() { File[] filesArray = dir.listFiles(); filesCount = 0; if (filesArray != null) { filesCount = filesArray.length; for (File file : filesArray) { if (!acceptFile(file)) { continue; } map.put(file, new MutableLong(file.lastModified())); } } } \nResponse:", "ground_truth": "Initializes dir watcher by reading all files\nfrom watched folder.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class FileSystem {\n    private static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n    private static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n    private static final String FILE_SEPARATOR_STRING = FILE_SEPARATOR;\n    private static final String LINE_SEPARATOR_STRING = LINE_SEPARATOR;\n    private static final String FILE_SEPARATOR_STRING_LENGTH = FILE_SEPARATOR_STRING.length();\n    private static final String LINE_SEPARATOR_STRING_LENGTH = LINE_SEPARATOR_STRING.length();\n    private static final String FILE_SEPARATOR_STRING_LENGTH_MINUS_ONE = FILE_SEPAR"}, {"ID": 1174, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean acceptFile(final File file) { if (!file.isFile()) { return false; // ignore non-files } String fileName = file.getName(); if (ignoreDotFiles) { if (fileName.startsWith(StringPool.DOT)) { return false; // ignore hidden files } } if (patterns == null) { return true; } return Wildcard.matchOne(fileName, patterns) != -1; } \nResponse:", "ground_truth": "Accepts if a file is going to be watched.", "predict": "\n\n*/\n\npackage com.liferay.portal.kernel.util;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\n\nimport com.liferay.portal.kernel.log.Log;\nimport com.liferay.portal.kernel.log.LogFactoryUtil;\nimport com.liferay.portal.kernel.util.PropsUtil;\nimport com.liferay.portal.kernel.util.StringPool;\nimport com.liferay.portal.kernel.util.StringUtil;\nimport com.liferay.portal.kernel.util.Validator;\n\n/**\n * @author Brian Wing Shun Chan\n * @author Raymond Aug\u00e9\n */\npublic class FileUtil {\n\n\tpublic static final String[] DEFAULT_IGNORE_P"}, {"ID": 1175, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirWatcher useWatchFile(final String name) { watchFile = new File(dir, name); if (!watchFile.isFile() || !watchFile.exists()) { try { FileUtil.touch(watchFile); } catch (IOException ioex) { throw new DirWatcherException(\"Invalid watch file: \" + name, ioex); } } watchFileLastAccessTime = watchFile.lastModified(); return this; } \nResponse:", "ground_truth": "Enables usage of provided watch file.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.SuffixFileFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.apache.commons.lang3.time.DateUtils;\nimport org.apache.commons.lang3.time.DateUtils.DateFormatter;\nimport org.apache.commons.lang3.time.DateUtils.TimeZoneDateFormatter;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport"}, {"ID": 1176, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final long pollingInterval) { if (timer == null) { if (!startBlank) { init(); } timer = new Timer(true); timer.schedule(new WatchTask(), 0, pollingInterval); } } \nResponse:", "ground_truth": "Starts the watcher.", "predict": " public void stop() { if (timer != null) { timer.cancel(); timer = null; } } \nResp public void stop(final long timeout) { if (timer != null) { timer.cancel(); timer = null; } } \nResp public void stop(final long timeout, final boolean force) { if (timer != null) { timer.cancel(); timer = null; } } \nResp public void stop(final long timeout, final boolean force, final boolean blank) { if (timer != null) { timer.cancel(); timer = null; } } \nResp public void stop(final long timeout, final boolean force, final boolean blank, final boolean startBlank) { if (timer != null) { timer.cancel(); timer = null; } } \nResp public void stop(final long timeout, final boolean force, final boolean blank, final boolean startBlank, final long pollingInterval) { if (timer != null) { timer.c"}, {"ID": 1177, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onChange(final DirWatcherEvent.Type type, final File file) { listeners.accept(new DirWatcherEvent(type, file)); } \nResponse:", "ground_truth": "Triggers listeners on file change.", "predict": " void\n*/\n\npublic class DirWatcherEvent {\n\tpublic enum Type {\n\t\tCREATE, DELETE, MODIFY\n\t}\n\n\tprivate final Type type;\n\tprivate final File file;\n\n\tpublic DirWatcherEvent(final Type type, final File file) {\n\t\tthis.type = type;\n\t\tthis.file = file;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic File getFile() {\n\t\treturn file;\n\t}\n}\n"}, {"ID": 1178, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Enumeration<T> enumeration) { if (allEnumerations.contains(enumeration)) { throw new IllegalArgumentException(\"Duplicate enumeration\"); } allEnumerations.add(enumeration); } \nResponse:", "ground_truth": "Adds an enumeration to this composite.", "predict": " Resp public void add(final Enumeration<T> enumeration) { if (allEnumerations.contains(enumeration)) { throw new IllegalArgumentException(\"Duplicate enumeration\"); } allEnumerations.add(enumeration); } \n\n*/\n\npublic class EnumerationTest {\n\tpublic static void main(String[] args) {\n\t\tEnumeration<String> enumeration = new Enumeration<String>() {\n\t\t\t@Override\n\t\t\tpublic boolean hasMoreElements() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String nextElement() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tSystem.out.println(enumeration.hasMoreElements());\n\t\tSystem.out.println(enumeration.nextElement());\n\t\t\n\t\tEnumeration<Integer> enumeration2 = new Enumeration<Integer>() {\n\t\t\t@Override\n\t\t\tpublic boolean hasMoreE"}, {"ID": 1179, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int computeFieldInfoSize() { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { // ConstantValue attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE); size += 8; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) { // Synthetic attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { // Signature attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { // Deprecated attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (lastRuntimeVisibleAnnotation != null) { size += lastRuntimeVisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_ANNOTATIONS); } if (lastRuntimeInvisibleAnnotation != null) { size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_ANNOTATIONS); } if (lastRuntimeVisibleTypeAnnotation != null) { size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS); } if (lastRuntimeInvisibleTypeAnnotation != null) { size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS); } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; } \nResponse:", "ground_truth": "Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure.", "predict": "\n\npublic static int computeFieldInfoSize(final int access, final String name, final String descriptor, final String signature, final int index) {\n\tint size = 8;\n\tif (signature != null) {\n\t\tsize += 8;\n\t}\n\tif (index != 0) {\n\t\tsize += 4;\n\t}\n\treturn size;\n}\n\npublic static int computeMethodInfoSize(final int access, final String name, final String descriptor, final String signature, final int index) {\n\tint size = 8;\n\tif (signature != null) {\n\t\tsize += 8;\n\t}\n\tif (index != 0) {\n\t\tsize += 4;\n\t}\n\treturn size;\n}\n\npublic static int computeAttributesSize(final List attributes) {\n\tint size = 0;\n\tfor (int i = 0; i < attributes.size(); ++i) {\n\t\tAttribute attribute = (Attribute) attributes.get("}, {"ID": 1180, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putFieldInfo(final ByteVector output) { boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0; output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex); // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0; if (constantValueIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { ++attributesCount; } if (signatureIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { ++attributesCount; } if (lastRuntimeVisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeVisibleTypeAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleTypeAnnotation != null) { ++attributesCount; } if (firstAttribute != null) { attributesCount += firstAttribute.getAttributeCount(); } output.putShort(attributesCount); // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)) .putInt(2) .putShort(constantValueIndex); } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0); } if (signatureIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)) .putInt(2) .putShort(signatureIndex); } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0); } if (lastRuntimeVisibleAnnotation != null) { lastRuntimeVisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output); } if (lastRuntimeInvisibleAnnotation != null) { lastRuntimeInvisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output); } if (lastRuntimeVisibleTypeAnnotation != null) { lastRuntimeVisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output); } if (lastRuntimeInvisibleTypeAnnotation != null) { lastRuntimeInvisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output); } if (firstAttribute != null) { firstAttribute.putAttributes(symbolTable, output); } } \nResponse:", "ground_truth": "Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        ByteVector out = new ByteVector();\n        try {\n            ClassWriter cw = new ClassWriter(0);\n            MethodVisitor mv;\n            {\n                cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"Test\", null, \"java/lang/Object\", null);\n                cw.visitSource(\"Test.java\", null);\n                {\n                    mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n                    mv.visitCode();\n                    mv.visitVarInsn(ALOAD, 0);\n                    mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n                    mv.visitInsn(RETURN);\n                    mv."}, {"ID": 1181, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Target ofValue(final Object value, final ScopeData scopeData) { return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResponse:", "ground_truth": "Creates a common target over a value, with known scope data.", "predict": " Response(final Object value, final ScopeData scopeData) { return new Response(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResp Response(final Object value, final ScopeData scopeData) { return new Response(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResp Response(final Object value, final ScopeData scopeData) { return new Response(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResp Response(final Object value, final ScopeData scopeData) { return new Response(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResp Response(final Object value, final ScopeData scopeData) { return new Response(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResp Response(final Object value, final ScopeData scopeData) { return new Response"}, {"ID": 1182, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeValue(final InjectionPoint injectionPoint, final Object propertyValue, final boolean silent) { writeValue(injectionPoint.targetName(), propertyValue, silent); } \nResponse:", "ground_truth": "Writes value to this target. Depending on a flag, writing the value can be\ncompletely silent, when no exception is thrown and with top performances.\nOtherwise, an exception is thrown on a failure.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1183, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void decorate(final Writer writer, final char[] pageContent, final char[] decoraContent) throws IOException { DecoraTag[] decoraTags = parseDecorator(decoraContent); parsePage(pageContent, decoraTags); writeDecoratedPage(writer, decoraContent, pageContent, decoraTags); } \nResponse:", "ground_truth": "Decorates page content with decorator template and outputs the result.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.velocity.Template;\nimport org.apache.velocity.VelocityContext;\nimport org.apache.velocity.app.VelocityEngine;\nimport org.apache.velocity.runtime.RuntimeConstants;\nimport org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;\nimport org.apache.velocity.runtime.resource.loader.JarResourceLoader;\nimport org.apache.velocity.runtime.resource.loader.ResourceLoader;\n\npublic class Decorator {\n\t\n\tprivate static VelocityEngine velocityEngine = new VelocityEngine();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tvelocityEngine.setProperty(RuntimeConstants.RESOURCE_LOADER, \"classpath, jar"}, {"ID": 1184, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void parsePage(final char[] pageContent, final DecoraTag[] decoraTags) { LagartoParser lagartoParser = new LagartoParser(pageContent); PageRegionExtractor writer = new PageRegionExtractor(decoraTags); lagartoParser.parse(writer); } \nResponse:", "ground_truth": "Parses target page and extracts Decora regions for replacements.", "predict": "\n\n*/\n\npackage com.decora.samples.decoratetags;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.math.NumberUtils;\nimport org.apache.log4j.Logger;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionMapping;\nimport org.apache.struts.actions"}, {"ID": 1185, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException { int ndx = 0; for (DecoraTag decoraTag : decoraTags) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag.getStartIndex() - ndx; if (decoratorLen <= 0) { continue; } out.write(decoratorContent, ndx, decoratorLen); ndx = decoraTag.getEndIndex(); // [2] now write region at the place of Decora tag int regionLen = decoraTag.getRegionLength(); if (regionLen == 0) { if (decoraTag.hasDefaultValue()) { out.write(decoratorContent, decoraTag.getDefaultValueStart(), decoraTag.getDefaultValueLength()); } } else { writeRegion(out, pageContent, decoraTag, decoraTags); } } // write remaining content out.write(decoratorContent, ndx, decoratorContent.length - ndx); } \nResponse:", "ground_truth": "Writes decorated content.", "predict": "\n\npublic void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException { int ndx = 0; for (DecoraTag decoraTag : decoraTags) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag.getStartIndex() - ndx; if (decoratorLen <= 0) { continue; } out.write(decoratorContent, ndx, decoratorLen); ndx = decoraTag.getEndIndex(); // [2] now write region at the place of Decora tag int regionLen = decoraTag.getRegionLength(); if (regionLen == 0) { if (decoraTag.hasDefaultValue()) { out.write(decoratorContent, decoraTag.getDefaultValueStart(), decoraTag.getDefaultValueLength()); } } else { writeRegion(out, pageContent, decoraTag"}, {"ID": 1186, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void writeRegion(final Writer out, final char[] pageContent, final DecoraTag decoraTag, final DecoraTag[] decoraTags) throws IOException { int regionStart = decoraTag.getRegionStart(); int regionLen = decoraTag.getRegionLength(); int regionEnd = regionStart + regionLen; for (DecoraTag innerDecoraTag : decoraTags) { if (decoraTag == innerDecoraTag) { continue; } if (decoraTag.isRegionUndefined()) { continue; } if (innerDecoraTag.isInsideOtherTagRegion(decoraTag)) { // write everything from region start to the inner Decora tag out.write(pageContent, regionStart, innerDecoraTag.getRegionTagStart() - regionStart); regionStart = innerDecoraTag.getRegionTagEnd(); } } // write remaining content of the region out.write(pageContent, regionStart, regionEnd - regionStart); } \nResponse:", "ground_truth": "Writes region to output, but extracts all inner regions.", "predict": "\n\n*/\n\npublic class DecoraTag {\n    private int regionStart;\n    private int regionLength;\n    private int regionTagStart;\n    private int regionTagEnd;\n    private int regionTagLength;\n    private int regionTagType;\n    private int regionTagTypeLength;\n    private int regionTagTypeStart;\n    private int regionTagTypeEnd;\n    private int regionTagTypeLength;\n    private int regionTagTypeType;\n    private int regionTagTypeTypeLength;\n    private int regionTagTypeTypeStart;\n    private int regionTagTypeTypeEnd;\n    private int regionTagTypeTypeLength;\n    private int regionTagTypeTypeType;\n    private int regionTagTypeTypeTypeLength;\n    private int regionTagTypeTypeTypeStart;\n    private int regionTagTypeTypeTypeEnd;\n    private int regionTagTypeTypeTypeLength;\n    private int regionTagTypeTypeTypeType;\n    private int regionTagTypeTypeType"}, {"ID": 1187, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() throws IOException { serverSocket = new ServerSocket(listenPort, socketBacklog); serverSocket.setReuseAddress(true); executorService = Executors.newFixedThreadPool(threadPoolSize); running = true; while (running) { Socket socket = serverSocket.accept(); socket.setKeepAlive(false); executorService.execute(onSocketConnection(socket)); } executorService.shutdown(); } \nResponse:", "ground_truth": "Starts HTTP tunnel. Method ends when the tunnel is stopped.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Server {\n\tpublic static void main(String[] args) throws IOException {\n\t\tint listenPort = Integer.parseInt(args[0]);\n\t\tint threadPoolSize = Integer.parseInt(args[1]);\n\t\tServerSocket serverSocket = new ServerSocket(listenPort, socketBacklog);\n\t\tserverSocket.setReuseAddress(true);\n\t\tExecutorService executorService = Executors.newFixedThreadPool(threadPoolSize);\n\t\twhile (true) {\n\t\t\tSocket socket = serverSocket.accept();\n\t\t\tsocket.setKeepAlive(false);\n\t\t\texecutorService.execute(onSocketConnection(socket));\n\t\t}\n\t}\n}\n"}, {"ID": 1188, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProcessResult run(final Process process) throws InterruptedException { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX); final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX); outputGobbler.start(); errorGobbler.start(); final int result = process.waitFor(); outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessResult(result, baos.toString()); } \nResponse:", "ground_truth": "Executes a process and returns the process output and exit code.", "predict": "\n\n*/\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpClient client = HttpClientBuilder.create().build();\n\t\tHttpGet request = new HttpGet(\"http://www.google.com\");\n\t\tHttpResponse response = client.execute(request);\n\t\tBufferedReader r"}, {"ID": 1189, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected IMAPSSLStore getStore(final Session session) { SimpleAuthenticator simpleAuthenticator = (SimpleAuthenticator) authenticator; final URLName url; if (simpleAuthenticator == null) { url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, null, null); } else { final PasswordAuthentication pa = simpleAuthenticator.getPasswordAuthentication(); url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, pa.getUserName(), pa.getPassword()); } return new IMAPSSLStore(session, url); } \nResponse:", "ground_truth": "Returns email store.\n\n@param session {@link Session}\n@return {@link com.sun.mail.imap.IMAPSSLStore}", "predict": "\n\n*/\n\npublic class IMAPSSLStore extends IMAPStore {\n\n    public IMAPSSLStore(Session session, URLName url) {\n        super(session, url);\n    }\n\n    @Override\n    protected IMAPSSLStore getStore(final Session session) {\n        return new IMAPSSLStore(session, getURLName());\n    }\n}\n"}, {"ID": 1190, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ServletOutputStream createOutputStream() throws IOException { GzipResponseStream gzstream = new GzipResponseStream(origResponse); gzstream.setBuffer(threshold); return gzstream; } \nResponse:", "ground_truth": "Creates and returns a ServletOutputStream to write the content associated\nwith this Response.", "predict": " public ServletOutputStream createOutputStream() throws IOException { GzipResponseStream gzstream = new GzipResponseStream(origResponse); gzstream.setBuffer(threshold); return gzstream; } \n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class GzipResponseStream extends ServletOutputStream {\n    private final GZIPOutputStream gzipStream;\n    private final OutputStream origStream;\n    private final int threshold;\n\n    public GzipResponseStream(OutputStream out) throws IOException {\n        this(out, Deflater.DEFAULT_COMPRESSION);\n    }\n\n    public GzipResponseStream(OutputStream out, int threshold) throws IOException {\n        this.origStream = out;\n        this.gzipStream = new GZIPOutputStream(out);\n        this.threshold = threshold;\n"}, {"ID": 1191, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final TemplateData templateData) { super.init(templateData); if (hint != null) { templateData.incrementHintsCount(); } } \nResponse:", "ground_truth": "Counts actual real hints.", "predict": " Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp Response = new Response(); if (hint != null) { templateData.incrementHintsCount(); } \nResp"}, {"ID": 1192, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendAlias(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { final ColumnAliasType columnAliasType = templateData.getColumnAliasType(); if (columnAliasType == null || columnAliasType == ColumnAliasType.TABLE_REFERENCE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnNameForQuery(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(columnName); } else if (columnAliasType == ColumnAliasType.COLUMN_CODE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnName(); final String code = templateData.registerColumnDataForColumnCode(tableName, columnName); query.append(code); } else if (columnAliasType == ColumnAliasType.TABLE_NAME) { final String tableName = ded.getTableNameForQuery(); final String columnName = dec.getColumnNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(columnName); } } \nResponse:", "ground_truth": "Appends alias.", "predict": " Response = Response.ok(query.toString());\n\n*/\n\npublic class ColumnAliasType {\n\tpublic static final ColumnAliasType TABLE_REFERENCE = new ColumnAliasType(\"TABLE_REFERENCE\");\n\tpublic static final ColumnAliasType COLUMN_CODE = new ColumnAliasType(\"COLUMN_CODE\");\n\tpublic static final ColumnAliasType TABLE_NAME = new ColumnAliasType(\"TABLE_NAME\");\n\t\n\tprivate final String name;\n\t\n\tprivate ColumnAliasType(final String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic static ColumnAliasType getColumnAliasType(final String name) {\n\t\tif (TABLE_REFERENCE.getName().equals(name)) {\n\t\t\treturn TABLE_REFERENCE;\n\t\t} else if (COLUMN_CODE.getName().equals(name)) {"}, {"ID": 1193, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendColumnName(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName()); if (templateData.getColumnAliasType() != null) { // create column aliases query.append(AS); switch (templateData.getColumnAliasType()) { case TABLE_NAME: { final String tableName = ded.getTableNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case TABLE_REFERENCE: { final String tableName = ded.getTableName(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case COLUMN_CODE: { final String tableName = ded.getTableName(); final String code = templateData.registerColumnDataForColumnCode(tableName, dec.getColumnName()); query.append(code); break; } } } } \nResponse:", "ground_truth": "Simply appends column name with optional table reference and alias.", "predict": "\n\n*/\n\npublic class ColumnAliasGenerator extends AbstractTemplateGenerator {\n\n\tpublic ColumnAliasGenerator(TemplateData templateData) {\n\t\tsuper(templateData);\n\t}\n\n\t@Override\n\tpublic String generate() {\n\t\tfinal StringBuilder query = new StringBuilder();\n\t\tfinal DbEntityDescriptor ded = templateData.getDbEntityDescriptor();\n\t\tfinal DbEntityColumnDescriptor dec = templateData.getDbEntityColumnDescriptor();\n\t\tquery.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName());\n\t\tif (templateData.getColumnAliasType() != null) {\n\t\t\tswitch (templateData.getColumnAliasType()) {\n\t\t\tcase TABLE_NAME:\n\t\t\t\tfinal String tableName = ded.getTableNameForQuery();\n\t\t\t\tquery.append(columnAliasSeparator).append(dec.getColumnNameForQuery());\n\t\t\t\tbreak;\n\t\t\tcase TABLE_"}, {"ID": 1194, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addRule(final D ruleDefinition, final boolean include) { if (rules == null) { rules = new ArrayList<>(); } if (include) { includesCount++; } else { excludesCount++; } Rule<R> newRule = new Rule<>(makeRule(ruleDefinition), include); if (rules.contains(newRule)) { return; } rules.add(newRule); } \nResponse:", "ground_truth": "Adds a rule. Duplicates are not allowed and will be ignored.", "predict": "\n\n*/\n\npublic class Rule {\n    private final RuleDefinition ruleDefinition;\n    private final boolean include;\n\n    public Rule(final RuleDefinition ruleDefinition, final boolean include) {\n        this.ruleDefinition = ruleDefinition;\n        this.include = include;\n    }\n\n    public RuleDefinition getRuleDefinition() {\n        return ruleDefinition;\n    }\n\n    public boolean isInclude() {\n        return include;\n    }\n}\n"}, {"ID": 1195, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean apply(final V value, final boolean blacklist, boolean flag) { if (rules == null) { return flag; } if (blacklist) { flag = processExcludes(value, flag); flag = processIncludes(value, flag); } else { flag = processIncludes(value, flag); flag = processExcludes(value, flag); } return flag; } \nResponse:", "ground_truth": "Applies rules on given flag. Flag is only changed if at least one rule\nmatched. Otherwise, the same value is returned. This way you can\nchain several rules and have the rule engine change the flag\nonly when a rule is matched.", "predict": " public boolean apply(final V value, final boolean blacklist, boolean flag) { if (rules == null) { return flag; } if (blacklist) { flag = processExcludes(value, flag); flag = processIncludes(value, flag); } else { flag = processIncludes(value, flag); flag = processExcludes(value, flag); } return flag; } \n\n*/\n\npublic class Rule {\n\t\n\tprivate String rule;\n\tprivate String description;\n\tprivate String method;\n\tprivate String methodDescription;\n\tprivate String methodName;\n\tprivate String methodType;\n\tprivate String methodReturnType;\n\tprivate String methodParameters;\n\tprivate String methodParametersDescription;\n\tprivate String methodParametersType;\n\tprivate String methodParametersReturnType;\n\tprivate String methodParametersReturnDescription;\n\tprivate String methodParametersReturnTypeDescription;\n\tprivate String methodParametersReturnDescriptionType;\n\tprivate String methodParametersReturnDescriptionTypeDescription;\n\tprivate String methodParameters"}, {"ID": 1196, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean processIncludes(final V value, boolean include) { if (includesCount > 0) { if (!include) { for (Rule<R> rule : rules) { if (!rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, true)) { include = true; break; } } } } return include; } \nResponse:", "ground_truth": "Process includes rules.", "predict": "\n\n*/\n\npublic class Rule<R extends Rule<R>> {\n    protected boolean include;\n    protected R value;\n    protected int includesCount;\n\n    public Rule(R value) {\n        this.value = value;\n        this.includesCount = 0;\n    }\n\n    public Rule(R value, boolean include) {\n        this.value = value;\n        this.includesCount = 0;\n        this.include = include;\n    }\n\n    public boolean include() {\n        return include;\n    }\n\n    public R value() {\n        return value;\n    }\n\n    public int includesCount() {\n        return includesCount;\n    }\n\n    public void include(boolean include) {\n        this.include = include;\n    }\n\n    public void value(R value) {\n        this.value = value;\n    }\n\n    public void includesCount(int includesCount) {\n        this.includesCount = includesCount;"}, {"ID": 1197, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean processExcludes(final V value, boolean include) { if (excludesCount > 0) { if (include) { for (Rule<R> rule : rules) { if (rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, false)) { include = false; break; } } } } return include; } \nResponse:", "ground_truth": "Process excludes rules.", "predict": "\n\n*/\n\npublic class Rule<R> {\n    public R value;\n    public boolean include;\n    public int excludesCount;\n\n    public Rule(R value, boolean include) {\n        this.value = value;\n        this.include = include;\n        this.excludesCount = 0;\n    }\n\n    public Rule(R value, boolean include, int excludesCount) {\n        this.value = value;\n        this.include = include;\n        this.excludesCount = excludesCount;\n    }\n}\n"}, {"ID": 1198, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPseudoClassName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; } \nResponse:", "ground_truth": "Returns pseudo-class name from simple class name.", "predict": "\n\n*/\n\npublic class PseudoClassName {\n\tpublic static void main(String[] args) {\n\t\tString name = getPseudoClassName();\n\t\tSystem.out.println(name);\n\t}\n\t\n\tpublic static String getPseudoClassName() {\n\t\tString name = getClass().getSimpleName().toLowerCase();\n\t\tname = name.replace('_', '-');\n\t\treturn name;\n\t}\n}\n"}, {"ID": 1199, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean addAll(final Collection<? extends E> c) { Iterator<? extends E> i = c.iterator(); boolean changed = false; while (i.hasNext()) { boolean ret = add(i.next()); if (!changed) { changed = ret; } } return changed; } \nResponse:", "ground_truth": "Add all of the elements in the given collection to this list.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1200, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int findInsertionPoint(final E o, int low, int high) { while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(get(mid), o); if (delta > 0) { high = mid - 1; } else { low = mid + 1; } } return low; } \nResponse:", "ground_truth": "Conducts a binary search to find the index where Object\nshould be inserted.", "predict": "\n\npublic int findInsertionPoint(final E o, int low, int high) { while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(get(mid), o); if (delta > 0) { high = mid - 1; } else { low = mid + 1; } } return low; }\n\n*/\n\npublic class Solution {\n    public int findInsertionPoint(final int[] nums, final int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = (low + high) >>> 1;\n            int delta = compare(nums[mid], target);\n            if (delta > 0) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    \n    private int compare(final"}, {"ID": 1201, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void bindAnnotationConfig(final Class<? extends Annotation> annotationType, final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass); actionConfigs.put(annotationType, actionConfig); for (final AnnotationParser annotationParser : annotationParsers) { if (annotationType.equals(annotationParser.getAnnotationType())) { // parser already exists return; } } annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class)); } \nResponse:", "ground_truth": "Binds action annotation and the action config. This can overwrite the default annotation\nconfiguration of an annotation.", "predict": "\n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils.Type;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariable;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariableMap;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariable"}, {"ID": 1202, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionConfig registerNewActionConfiguration(final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig newActionConfig = createActionConfig(actionConfigClass); actionConfigs.put(actionConfigClass, newActionConfig); return newActionConfig; } \nResponse:", "ground_truth": "Registers action configuration for given type.", "predict": " Response to the client.\n\n*/\n\npublic class ActionConfigRegisterAction extends Action {\n\t\n\tpublic ActionConfigRegisterAction(ActionConfigRegisterActionConfig config) {\n\t\tsuper(config);\n\t}\n\t\n\t@Override\n\tpublic void execute() throws Exception {\n\t\t\n\t\t// Get the action config class\n\t\tfinal Class<? extends ActionConfig> actionConfigClass = config.getActionConfigClass();\n\t\t\n\t\t// Create the action config\n\t\tfinal ActionConfig actionConfig = createActionConfig(actionConfigClass);\n\t\t\n\t\t// Register the action config\n\t\tconfig.getActionConfigManager().registerActionConfig(actionConfig);\n\t\t\n\t\t// Return the response\n\t\treturnResponse(actionConfig);\n\t}\n\t\n\tprivate ActionConfig createActionConfig(final Class<? extends ActionConfig> actionConfigClass) {\n\t\t\n\t\t// Create the action config\n\t\tfinal ActionConfig actionConfig = createActionConfigInstance(actionConfigClass);\n\t\t\n\t\t// Set the"}, {"ID": 1203, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionConfig lookup(final Class actionTypeOrAnnotationType) { final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType); if (actionConfig == null) { throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName()); } return actionConfig; } \nResponse:", "ground_truth": "Lookup for the action configuration. Typically, the input argument is either the action type or annotation type.", "predict": " public ActionConfig lookup(final Class actionTypeOrAnnotationType) { final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType); if (actionConfig == null) { throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName()); } return actionConfig; } \n\n*/\n\npublic class ActionConfigLookup {\n\n\tprivate final Map<Class, ActionConfig> actionConfigs;\n\n\tpublic ActionConfigLookup(final Map<Class, ActionConfig> actionConfigs) {\n\t\tthis.actionConfigs = actionConfigs;\n\t}\n\n\tpublic ActionConfig lookup(final Class actionTypeOrAnnotationType) {\n\t\treturn actionConfigs.get(actionTypeOrAnnotationType);\n\t}\n}\n"}, {"ID": 1204, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) { final T actionConfig = (T) lookup(actionConfigType); actionConfigConsumer.accept(actionConfig); } \nResponse:", "ground_truth": "Fetch some action config and consumes it.", "predict": " public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) { final T actionConfig = (T) lookup(actionConfigType); actionConfigConsumer.accept(actionConfig); } \n\n*/\n\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class ActionConfig {\n    private final String name;\n    private final Supplier<String> description;\n    private final Function<String, String> action;\n    private final Consumer<String> actionConsumer;\n\n    public ActionConfig(final String name, final Supplier<String> description, final Function<String, String> action, final Consumer<String> actionConsumer) {\n        this.name = name;\n        this.description = description;\n        this.action = action;\n        this.actionConsumer = actionConsumer;\n    }\n\n    public String getName"}, {"ID": 1205, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static void setupSystemMailProperties() { System.setProperty(\"mail.mime.encodefilename\", Boolean.valueOf(Defaults.mailMimeEncodefilename).toString()); System.setProperty(\"mail.mime.decodefilename\", Boolean.valueOf(Defaults.mailMimeDecodefilename).toString()); } \nResponse:", "ground_truth": "Setups the system email properties.", "predict": "\n\n*/\n\npackage com.bitdubai.fermat_dmp_plugin.layer.middleware.wallet_language.developer.bitdubai.version_1.structure.database;\n\nimport com.bitdubai.fermat_api.layer.all_definition.enums.Plugins;\nimport com.bitdubai.fermat_api.layer.all_definition.enums.WalletType;\nimport com.bitdubai.fermat_api.layer.all_definition.money.CryptoAddress;\nimport com.bitdubai.fermat_api.layer.dmp_middleware.wallet_language.enums.LanguageStatus;\nimport com.bitdubai.fermat_api.layer.dmp_middleware.wallet_language.enums.WalletLanguage;\nimport com.bitdubai.fermat_api.layer.dmp_middleware.wallet_language."}, {"ID": 1206, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void validateWithin(final ValidationContext vctx, final Object value) { vtor.validate(vctx, value, name); } \nResponse:", "ground_truth": "Validates provided context and value withing this constraint content.", "predict": " Response is generated by the framework. It is not a must to return a response for every request. \n\n*/\n\npackage com.ebay.marketplace.resolution.v1.services;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlType;\n\n\n/**\n * \n * \n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n * \t  \t  \t  \t  \t\n *"}, {"ID": 1207, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Element findLastTable(final Node node) { Node tableNode = node; while (tableNode != null) { if (tableNode.getNodeType() == Node.NodeType.ELEMENT) { String tableNodeName = tableNode.getNodeName().toLowerCase(); if (tableNodeName.equals(\"table\")) { break; } } tableNode = tableNode.getParentNode(); } return (Element) tableNode; } \nResponse:", "ground_truth": "Finds the last table in stack of open elements.", "predict": "\n\n*/\n\npublic class FindLastTable {\n\tpublic static void main(String[] args) {\n\t\tString xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><root><table><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></table><table><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></table></root>\";\n\t\tDocument doc = XmlUtil.parse(xml);\n\t\tElement root = doc.getRootElement();\n\t\tElement table = root.findLastTable(root);\n\t\tSystem.out.println(table.getNodeName());\n\t}\n}\n"}, {"ID": 1208, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void fixElements() { for (Element fosterElement : fosterElements) { // find parent table Element lastTable = findLastTable(fosterElement); Node fosterElementParent = fosterElement.getParentNode(); // filter our foster element Node[] fosterChilds = fosterElement.getChildNodes(); for (Node fosterChild : fosterChilds) { if (fosterChild.getNodeType() == Node.NodeType.ELEMENT) { if (isOneOfTableElements((Element) fosterChild)) { // move all child table elements outside // the foster element fosterChild.detachFromParent(); fosterElementParent.insertBefore(fosterChild, fosterElement); } } } // finally, move foster element above the table fosterElement.detachFromParent(); lastTable.getParentNode().insertBefore(fosterElement, lastTable); } } \nResponse:", "ground_truth": "Performs the fix for elements.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.ui.Select;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\npublic class TableFixer {\n\t\n\tprivate WebDriver driver;\n\tprivate WebDriverWait wait;\n\t\n\tpublic TableFixer(WebDriver driver) {\n\t\tthis.driver = driver;\n\t\tthis.wait = new WebDriverWait(driver, 10);\n\t}\n\t\n\tpublic void fixTable(WebElement table) {\n\t\tList<WebElement> rows = table.findElements(By.tagName(\"tr\"));\n\t\tList<WebElement> cells = new ArrayList<WebElement>();\n\t\tfor"}, {"ID": 1209, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Map<String, BeanData> registerSessionBeans(final HttpSession httpSession) { SessionBeans sessionBeans = new SessionBeans(); httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans); return sessionBeans.getBeanMap(); } \nResponse:", "ground_truth": "Registers new session destroy callback if not already registered.", "predict": "\n\n*/\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Date;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java"}, {"ID": 1210, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Map<String, BeanData> getSessionMap(final HttpSession session) { SessionBeans sessionBeans = (SessionBeans) session.getAttribute(SESSION_BEANS_NAME); if (sessionBeans == null) { return null; } return sessionBeans.getBeanMap(); } \nResponse:", "ground_truth": "", "predict": " Response\n\n*/\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Date;\nimport java.util.Calendar;\nimport java.util.Calendar;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport java.util.Properties;\nimport"}, {"ID": 1211, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(String name, final String superName, final String suffix, final String reqProxyClassName) { int lastSlash = name.lastIndexOf('/'); this.targetPackage = lastSlash == -1 ? StringPool.EMPTY : name.substring(0, lastSlash).replace('/', '.'); this.targetClassname = name.substring(lastSlash + 1); this.nextSupername = superName; this.superName = name; // create proxy name if (reqProxyClassName != null) { if (reqProxyClassName.startsWith(DOT)) { name = name.substring(0, lastSlash) + '/' + reqProxyClassName.substring(1); } else if (reqProxyClassName.endsWith(DOT)) { name = reqProxyClassName.replace('.', '/') + this.targetClassname; } else { name = reqProxyClassName.replace('.', '/'); } } // add optional suffix if (suffix != null) { name += suffix; } this.thisReference = name; this.superReference = this.superName; } \nResponse:", "ground_truth": "Work data initialization.", "predict": "\n\n*/\n\npublic class ProxyGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString targetPackage = \"com.example.test\";\n\t\tString targetClassname = \"Test\";\n\t\tString nextSupername = \"com.example.test.Test\";\n\t\tString superName = \"com.example.test.Test\";\n\t\tString suffix = \"\";\n\t\tString reqProxyClassName = null;\n\t\t\n\t\tif (args.length > 0) {\n\t\t\ttargetPackage = args[0];\n\t\t}\n\t\tif (args.length > 1) {\n\t\t\ttargetClassname = args[1];\n\t\t}\n\t\tif (args.length > 2) {\n\t\t\tnextSupername = args[2];\n\t\t}\n\t\tif (args.length > 3) {\n\t\t\tsuperName = args[3];\n\t\t}\n\t\tif (args.length > 4) {\n\t\t\tsuffix = args[4];\n\t\t"}, {"ID": 1212, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void addAdviceInitMethod(final String name) { if (adviceInits == null) { adviceInits = new ArrayList<>(); } adviceInits.add(name); } \nResponse:", "ground_truth": "Saves used constructors of advices.", "predict": " void addAdviceInitMethod(final String name) { if (adviceInits == null) { adviceInits = new ArrayList<>(); } adviceInits.add(name); } \n\n*/\n\npublic class AdviceInitMethod {\n\t\n\tprivate String adviceInitMethodName;\n\tprivate List<String> adviceInits;\n\t\n\tpublic AdviceInitMethod(String adviceInitMethodName, List<String> adviceInits) {\n\t\tthis.adviceInitMethodName = adviceInitMethodName;\n\t\tthis.adviceInits = adviceInits;\n\t}\n\t\n\tpublic String getAdviceInitMethodName() {\n\t\treturn adviceInitMethodName;\n\t}\n\t\n\tpublic List<String> getAdviceInits() {\n\t\treturn adviceInits;\n\t}\n\t\n\tpublic void setAdviceInits(List<String> adviceInits) {\n\t\tthis.adviceInits = adviceInits;"}, {"ID": 1213, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void end() { if (newAction) { bundleId = bundlesManager.registerBundle(contextPath, actionPath, bundleId, bundleContentType, sources); } } \nResponse:", "ground_truth": "Called on end of parsing.", "predict": "\n\n*/\n\npackage com.epam.jdi.uitests.mobile.appium.elements.apiInteract;\n\nimport com.epam.jdi.uitests.core.interfaces.base.IAvatar;\nimport com.epam.jdi.uitests.mobile.appium.elements.BaseElement;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.SearchContext;\nimport org.openqa.selenium.WebElement;\n\nimport java.util.List;\n\nimport static com.epam.jdi.uitests.core.settings.JDISettings.exception;\nimport static com.epam.jdi.uitests.mobile.appium.driver.AppiumDriver.getByLocator;\nimport static com.epam.jdi.uitests.mobile.appium.driver.AppiumDriver.getWebElement;\nimport static com.ep"}, {"ID": 1214, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void add( final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) { // ignore lines without : or = if (key == null) { return; } String fullKey = key; if (section != null) { if (fullKey.length() != 0) { fullKey = section + '.' + fullKey; } else { fullKey = section; } } String v = value.toString(); if (trim) { if (valueTrimLeft && valueTrimRight) { v = v.trim(); } else if (valueTrimLeft) { v = StringUtil.trimLeft(v); } else { v = StringUtil.trimRight(v); } } if (v.length() == 0 && skipEmptyProps) { return; } extractProfilesAndAdd(fullKey, v, operator); } \nResponse:", "ground_truth": "Adds accumulated value to key and current section.", "predict": " public void add( final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) { // ignore lines without : or = if (key == null) { return; } String fullKey = key; if (section != null) { if (fullKey.length() != 0) { fullKey = section + '.' + fullKey; } else { fullKey = section; } } String v = value.toString(); if (trim) { if (valueTrimLeft && valueTrimRight) { v = v.trim(); } else if (valueTrimLeft) { v = StringUtil.trimLeft(v); } else { v = StringUtil.trimRight(v); } } if (v.length() == 0 && skipEmptyProps) { return; } extractProfilesAndAdd(fullKey, v, operator); } \nResp public void add( final String section, final String key, final StringBuilder value, final boolean"}, {"ID": 1215, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void extractProfilesAndAdd(final String key, final String value, final Operator operator) { String fullKey = key; int ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { justAdd(fullKey, value, null, operator); return; } // extract profiles ArrayList<String> keyProfiles = new ArrayList<>(); while (true) { ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { break; } final int len = fullKey.length(); int ndx2 = fullKey.indexOf(PROFILE_RIGHT, ndx + 1); if (ndx2 == -1) { ndx2 = len; } // remember profile final String profile = fullKey.substring(ndx + 1, ndx2); keyProfiles.add(profile); // extract profile from key ndx2++; final String right = (ndx2 == len) ? StringPool.EMPTY : fullKey.substring(ndx2); fullKey = fullKey.substring(0, ndx) + right; } if (fullKey.startsWith(StringPool.DOT)) { // check for special case when only profile is defined in section fullKey = fullKey.substring(1); } // add value to extracted profiles justAdd(fullKey, value, keyProfiles, operator); } \nResponse:", "ground_truth": "Extracts profiles from the key name and adds key-value to them.", "predict": "\n\n*/\n\npublic class Profile {\n    public static final String PROFILE_LEFT = \"{\";\n    public static final String PROFILE_RIGHT = \"}\";\n    public static final String PROFILE_SEPARATOR = \",\";\n    public static final String PROFILE_SEPARATOR_STRING = \",\";\n    public static final String PROFILE_SEPARATOR_STRING_LEN = \",\".length();\n    public static final String PROFILE_SEPARATOR_STRING_LEN_MAX = \",\".length() + 1;\n    public static final String PROFILE_SEPARATOR_STRING_LEN_MIN = \",\".length() - 1;\n    public static final String PROFILE_SEPARATOR_STRING_MAX = \",\".substring(PROFILE_SEPARATOR_STRING_LEN_MAX);\n    public static final String PROFILE_SEPARATOR_STRING_MIN = \",\"."}, {"ID": 1216, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void justAdd(final String key, final String value, final ArrayList<String> keyProfiles, final Operator operator) { if (operator == Operator.COPY) { HashMap<String,Object> target = new HashMap<>(); String[] profiles = null; if (keyProfiles != null) { profiles = keyProfiles.toArray(new String[0]); } String[] sources = StringUtil.splitc(value, ','); for (String source : sources) { source = source.trim(); // try to extract profile for parsing String[] lookupProfiles = profiles; String lookupProfilesString = null; int leftIndex = source.indexOf('<'); if (leftIndex != -1) { int rightIndex = source.indexOf('>'); lookupProfilesString = source.substring(leftIndex + 1, rightIndex); source = source.substring(0, leftIndex).concat(source.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(lookupProfilesString, ','); StringUtil.trimAll(lookupProfiles); } String[] wildcards = new String[] {source + \".*\"}; propsData.extract(target, lookupProfiles, wildcards, null); for (Map.Entry<String, Object> entry : target.entrySet()) { String entryKey = entry.getKey(); String suffix = entryKey.substring(source.length()); String newKey = key + suffix; String newValue = \"${\" + entryKey; if (lookupProfilesString != null) { newValue += \"<\" + lookupProfilesString + \">\"; } newValue += \"}\"; if (profiles == null) { propsData.putBaseProperty(newKey, newValue, false); } else { for (final String p : profiles) { propsData.putProfileProperty(newKey, newValue, p, false); } } } } return; } boolean append = operator == Operator.QUICK_APPEND; if (keyProfiles == null) { propsData.putBaseProperty(key, value, append); return; } for (final String p : keyProfiles) { propsData.putProfileProperty(key, value, p, append); } } \nResponse:", "ground_truth": "Core key-value addition.", "predict": "\n\n*/\n\npackage com.intellij.execution.process.mediator.rpc;\n\nimport com.intellij.execution.process.mediator.rpc.ProcessMediatorHost;\nimport com.intellij.execution.process.mediator.rpc.ProcessMediatorHosts;\nimport com.intellij.execution.process.mediator.rpc.ProcessMediatorUtils;\nimport com.intellij.openapi.util.NlsSafe;\nimport com.intellij.util.containers.ContainerUtil;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ProcessMediatorHost"}, {"ID": 1217, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typedesc2ClassName(final String desc) { String className = desc; switch (desc.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': if (desc.length() != 1) { throw new IllegalArgumentException(INVALID_BASE_TYPE + desc); } break; case 'L': className = className.substring(1, className.length() - 1); break; case '[': // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. className = className.replace('/', '.'); break; default: throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } return className; } \nResponse:", "ground_truth": "Converts bytecode-like description to java class name that can be loaded\nwith a classloader. Uses less-known feature of class loaders for loading\narray classes.\n\n@see #typedescToSignature(String, jodd.mutable.MutableInteger)", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String input = \"public static String typedesc2ClassName(final String desc) { String className = desc; switch (desc.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': if (desc.length() != 1) { throw new IllegalArgumentException(INVALID_BASE_TYPE + desc); } break; case 'L': className = className.substring(1, className.length() - 1); break; case '[': // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. class"}, {"ID": 1218, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typeref2Name(final String desc) { if (desc.charAt(0) != TYPE_REFERENCE) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } String name = desc.substring(1, desc.length() - 1); return name.replace('/', '.'); } \nResponse:", "ground_truth": "Converts type reference to java-name.", "predict": "\n\n*/\n\npublic class TypeRef2Name {\n\tpublic static String typeref2Name(String desc) {\n\t\tif (desc.charAt(0) != TYPE_REFERENCE) {\n\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t}\n\t\tString name = desc.substring(1, desc.length() - 1);\n\t\treturn name.replace('/', '.');\n\t}\n}\n"}, {"ID": 1219, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typedescToSignature(final String desc, final MutableInteger from) { int fromIndex = from.get(); from.value++; // default usage for most cases switch (desc.charAt(fromIndex)) { case 'B': return \"byte\"; case 'C': return \"char\"; case 'D': return \"double\"; case 'F': return \"float\"; case 'I': return \"int\"; case 'J': return \"long\"; case 'S': return \"short\"; case 'Z': return \"boolean\"; case 'V': return \"void\"; case 'L': int index = desc.indexOf(';', fromIndex); if (index < 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } from.set(index + 1); String str = desc.substring(fromIndex + 1, index); return str.replace('/', '.'); case 'T': return desc.substring(from.value); case '[': StringBuilder brackets = new StringBuilder(); int n = fromIndex; while (desc.charAt(n) == '[') { // count opening brackets brackets.append(\"[]\"); n++; } from.value = n; String type = typedescToSignature(desc, from); // the rest of the string denotes a `<field_type>' return type + brackets; default: if (from.value == 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } // generics! return desc.substring(from.value); } } \nResponse:", "ground_truth": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n{@code\n ::= \n      ::= ||\n       ::= B|C|D|F|I|J|S|Z\n     ::= L;\n      ::= [\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL; ... an object of the given class\nS short signed short\nZ boolean true or false\n[ ... array\n}\n\nThis method converts this string into a Java type declaration such as\nString[].", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add(\"m\");\n        list.add(\"n\");\n        list.add(\"o\");\n        list.add(\"p\");\n        list.add(\"q\");\n        list.add(\"r\");\n        list.add(\"s\");\n        list.add(\"t\");\n        list"}, {"ID": 1220, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typeToTyperef(final Class type) { if (!type.isArray()) { if (!type.isPrimitive()) { return 'L' + typeToSignature(type) + ';'; } if (type == int.class) { return \"I\"; } if (type == long.class) { return \"J\"; } if (type == boolean.class) { return \"Z\"; } if (type == double.class) { return \"D\"; } if (type == float.class) { return \"F\"; } if (type == short.class) { return \"S\"; } if (type == void.class) { return \"V\"; } if (type == byte.class) { return \"B\"; } if (type == char.class) { return \"C\"; } } return type.getName(); } \nResponse:", "ground_truth": "Converts type to byteccode type ref.", "predict": "\n\npublic static String typeToTyperef(final Class type) {\n\tif (!type.isArray()) {\n\t\tif (!type.isPrimitive()) {\n\t\t\treturn 'L' + typeToSignature(type) + ';';\n\t\t}\n\t\tif (type == int.class) {\n\t\t\treturn \"I\";\n\t\t}\n\t\tif (type == long.class) {\n\t\t\treturn \"J\";\n\t\t}\n\t\tif (type == boolean.class) {\n\t\t\treturn \"Z\";\n\t\t}\n\t\tif (type == double.class) {\n\t\t\treturn \"D\";\n\t\t}\n\t\tif (type == float.class) {\n\t\t\treturn \"F\";\n\t\t}\n\t\tif (type == short.class) {\n\t\t\treturn \"S\";\n\t\t}\n\t\tif (type == void.class) {\n\t\t\treturn \"V\";\n\t\t}\n\t\tif (type == byte.class) {\n\t\t\treturn \"B\";\n\t\t"}, {"ID": 1221, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Consumers<T> addAll(final Consumer<T>... consumers) { Collections.addAll(consumerList, consumers); return this; } \nResponse:", "ground_truth": "Registers additional consumers.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1222, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Collection<T> createCollection(final int length) { if (collectionType.isInterface()) { if (collectionType == List.class) { if (length > 0) { return new ArrayList<>(length); } else { return new ArrayList<>(); } } if (collectionType == Set.class) { if (length > 0) { return new HashSet<>(length); } else { return new HashSet<>(); } } throw new TypeConversionException(\"Unknown collection: \" + collectionType.getName()); } if (length > 0) { try { Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class); return ctor.newInstance(Integer.valueOf(length)); } catch (Exception ex) { // ignore exception } } try { return collectionType.getDeclaredConstructor().newInstance(); } catch (Exception ex) { throw new TypeConversionException(ex); } } \nResponse:", "ground_truth": "Creates new collection of target component type.\nDefault implementation uses reflection to create\nan collection of target type. Override it for better performances.", "predict": "\n\n*/\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CollectionGenerator {\n\n    public static void main(String[] args) {\n        Collection<String> collection = createCollection(10);\n        System.out.println(collection);\n    }\n\n    public static <T> Collection<T> createCollection(int length) {\n        if (length > 0) {\n            try {\n                Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class);\n                return ctor.newInstance(Integer.valueOf(length));\n            } catch (Exception ex) {\n                throw new TypeConversionException(ex);\n            }\n        } else {\n            try {\n                Constructor<Collection<T>> ctor = (Construct"}, {"ID": 1223, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertToSingleElementCollection(final Object value) { Collection<T> collection = createCollection(0); //noinspection unchecked collection.add((T) value); return collection; } \nResponse:", "ground_truth": "Creates a collection with single element.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1224, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertValueToCollection(Object value) { if (value instanceof Iterable) { Iterable iterable = (Iterable) value; Collection<T> collection = createCollection(0); for (Object element : iterable) { collection.add(convertType(element)); } return collection; } if (value instanceof CharSequence) { value = CsvUtil.toStringArray(value.toString()); } Class type = value.getClass(); if (type.isArray()) { // convert arrays Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { return convertPrimitiveArrayToCollection(value, componentType); } else { Object[] array = (Object[]) value; Collection<T> result = createCollection(array.length); for (Object a : array) { result.add(convertType(a)); } return result; } } // everything else: return convertToSingleElementCollection(value); } \nResponse:", "ground_truth": "Converts non-collection value to collection.", "predict": " public Collection<T> convertValueToCollection(Object value) { if (value instanceof Iterable) { Iterable iterable = (Iterable) value; Collection<T> collection = createCollection(0); for (Object element : iterable) { collection.add(convertType(element)); } return collection; } if (value instanceof CharSequence) { value = CsvUtil.toStringArray(value.toString()); } Class type = value.getClass(); if (type.isArray()) { // convert arrays Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { return convertPrimitiveArrayToCollection(value, componentType); } else { Object[] array = (Object[]) value; Collection<T> result = createCollection(array.length); for (Object a : array) { result.add(convertType(a)); } return result; } } // everything else: return convertToSingleElementCollection(value); } \n\n*/"}, {"ID": 1225, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertCollectionToCollection(final Collection value) { Collection<T> collection = createCollection(value.size()); for (Object v : value) { collection.add(convertType(v)); } return collection; } \nResponse:", "ground_truth": "Converts collection value to target collection.\nEach element is converted to target component type.", "predict": " Response<T> convertCollectionToCollection(final Collection value) { Response<T> response = createResponse(value.size()); for (Object v : value) { response.add(convertType(v)); } return response; } \nResp Response<T> convertCollectionToCollection(final Collection value, final int start, final int end) { Response<T> response = createResponse(end - start); for (int i = start; i < end; i++) { response.add(convertType(value.get(i))); } return response; } \nResp Response<T> convertCollectionToCollection(final Collection value, final int start) { Response<T> response = createResponse(value.size() - start); for (int i = start; i < value.size(); i++) { response.add(convertType(value.get(i))); } return response; } \nResp Response<T> convertCollectionToCollection(final Collection value, final int"}, {"ID": 1226, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"AutoBoxing\") protected Collection<T> convertPrimitiveArrayToCollection(final Object value, final Class primitiveComponentType) { Collection<T> result = null; if (primitiveComponentType == int.class) { int[] array = (int[]) value; result = createCollection(array.length); for (int a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == long.class) { long[] array = (long[]) value; result = createCollection(array.length); for (long a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == float.class) { float[] array = (float[]) value; result = createCollection(array.length); for (float a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == double.class) { double[] array = (double[]) value; result = createCollection(array.length); for (double a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == short.class) { short[] array = (short[]) value; result = createCollection(array.length); for (short a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == byte.class) { byte[] array = (byte[]) value; result = createCollection(array.length); for (byte a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == char.class) { char[] array = (char[]) value; result = createCollection(array.length); for (char a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == boolean.class) { boolean[] array = (boolean[]) value; result = createCollection(array.length); for (boolean a : array) { result.add(convertType(a)); } } return result; } \nResponse:", "ground_truth": "Converts primitive array to target collection.", "predict": " Response = new Response(); Response.setStatus(Status.OK); Response.setEntity(convertPrimitiveArrayToCollection(value, primitiveComponentType)); return Response; }\n\npublic static class Response {\n\tprivate Status status;\n\tprivate Object entity;\n\n\tpublic Status getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic void setStatus(Status status) {\n\t\tthis.status = status;\n\t}\n\n\tpublic Object getEntity() {\n\t\treturn entity;\n\t}\n\n\tpublic void setEntity(Object entity) {\n\t\tthis.entity = entity;\n\t}\n}\n"}, {"ID": 1227, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void addLineNumber(final int lineNumber) { if (this.lineNumber == 0) { this.lineNumber = (short) lineNumber; } else { if (otherLineNumbers == null) { otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]; } int otherLineNumberIndex = ++otherLineNumbers[0]; if (otherLineNumberIndex >= otherLineNumbers.length) { int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]; System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length); otherLineNumbers = newLineNumbers; } otherLineNumbers[otherLineNumberIndex] = lineNumber; } } \nResponse:", "ground_truth": "Adds a source line number corresponding to this label.\n\n@param lineNumber a source line number (which should be strictly positive).", "predict": " void\n*/\npublic class LineNumberTable {\n    private int[] lineNumberTable;\n    private int[] otherLineNumbers;\n    private int lineNumberTableLength;\n    private int otherLineNumbersLength;\n\n    public LineNumberTable(int lineNumberTableLength, int otherLineNumbersLength) {\n        this.lineNumberTableLength = lineNumberTableLength;\n        this.otherLineNumbersLength = otherLineNumbersLength;\n        lineNumberTable = new int[lineNumberTableLength];\n        otherLineNumbers = new int[otherLineNumbersLength];\n    }\n\n    public int getLineNumber(int index) {\n        return lineNumberTable[index];\n    }\n\n    public int getLineNumber(int index, int otherLineNumberIndex) {\n        return otherLineNumbers[otherLineNumberIndex];\n    }\n\n    public int getLineNumberTableLength() {\n        return lineNumberTableLength;\n    }\n\n    public int getOtherLineNumbersLength() {\n"}, {"ID": 1228, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) { methodVisitor.visitLabel(this); if (visitLineNumbers && lineNumber != 0) { methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this); if (otherLineNumbers != null) { for (int i = 1; i <= otherLineNumbers[0]; ++i) { methodVisitor.visitLineNumber(otherLineNumbers[i], this); } } } } \nResponse:", "ground_truth": "Makes the given visitor visit this label and its source line numbers, if applicable.\n\n@param methodVisitor a method visitor.\n@param visitLineNumbers whether to visit of the label's source line numbers, if any.", "predict": " Response is generated by the method-level comment.\n */\npublic class MethodComment extends AbstractInstruction {\n    private int lineNumber;\n    private int[] otherLineNumbers;\n\n    public MethodComment(int lineNumber, int[] otherLineNumbers) {\n        this.lineNumber = lineNumber;\n        this.otherLineNumbers = otherLineNumbers;\n    }\n\n    public int getLineNumber() {\n        return lineNumber;\n    }\n\n    public int[] getOtherLineNumbers() {\n        return otherLineNumbers;\n    }\n\n    public void accept(MethodVisitor mv) {\n        mv.visitLabel(this);\n        if (lineNumber != 0) {\n            mv.visitLineNumber(lineNumber & 0xFFFF, this);\n            if (otherLineNumbers != null) {\n                for (int i = 1; i <= otherLineNumbers[0]; ++i) {\n                    mv.visitLineNumber(otherLine"}, {"ID": 1229, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void put( final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) { if ((flags & FLAG_RESOLVED) == 0) { if (wideReference) { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length); code.putInt(-1); } else { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length); code.putShort(-1); } } else { if (wideReference) { code.putInt(bytecodeOffset - sourceInsnBytecodeOffset); } else { code.putShort(bytecodeOffset - sourceInsnBytecodeOffset); } } } \nResponse:", "ground_truth": "Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\nis known, the relative bytecode offset between the label and the instruction referencing it is\ncomputed and written directly. Otherwise, a null relative offset is written and a new forward\nreference is declared for this label.\n\n@param code the bytecode of the method. This is where the reference is appended.\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference to be appended.\n@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).", "predict": "\n\n*/\n\npublic class Bytecode {\n    public static final int FLAG_RESOLVED = 1;\n    public static final int FLAG_RESOLVED_WIDE = 2;\n    public static final int FLAG_RESOLVED_SHORT = 4;\n    public static final int FLAG_RESOLVED_UNRESOLVED = 8;\n    public static final int FLAG_RESOLVED_UNRESOLVED_WIDE = 16;\n    public static final int FLAG_RESOLVED_UNRESOLVED_SHORT = 32;\n    public static final int FLAG_RESOLVED_UNRESOLVED_WIDE_SHORT = 64;\n    public static final int FLAG_RESOLVED_UNRESOLVED_SHORT_WIDE = 128;\n    public static final int FLAG_RESOLVED_UNRESOLVED_WIDE_SH"}, {"ID": 1230, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addForwardReference( final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) { if (forwardReferences == null) { forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]; } int lastElementIndex = forwardReferences[0]; if (lastElementIndex + 2 >= forwardReferences.length) { int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]; System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length); forwardReferences = newValues; } forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset; forwardReferences[++lastElementIndex] = referenceType | referenceHandle; forwardReferences[0] = lastElementIndex; } \nResponse:", "ground_truth": "Adds a forward reference to this label. This method must be called only for a true forward\nreference, i.e. only if this label is not resolved yet. For backward references, the relative\nbytecode offset of the reference can be, and must be, computed and stored directly.\n\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference stored at referenceHandle.\n@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n#FORWARD_REFERENCE_TYPE_WIDE}.\n@param referenceHandle the offset in the bytecode where the forward reference value must be\nstored.", "predict": "\n\n*/\n\npublic class ForwardReferences {\n\tprivate int[] forwardReferences;\n\tprivate int size;\n\t\n\tpublic ForwardReferences() {\n\t\tforwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\n\t\tsize = 0;\n\t}\n\t\n\tpublic void addForwardReference(int sourceInsnBytecodeOffset, int referenceType, int referenceHandle) {\n\t\tif (forwardReferences == null) {\n\t\t\tforwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\n\t\t}\n\t\tint lastElementIndex = forwardReferences[0];\n\t\tif (lastElementIndex + 2 >= forwardReferences.length) {\n\t\t\tint[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\n\t\t\tSystem.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);\n\t\t\tforwardReferences ="}, {"ID": 1231, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final boolean resolve(final byte[] code, final int bytecodeOffset) { this.flags |= FLAG_RESOLVED; this.bytecodeOffset = bytecodeOffset; if (forwardReferences == null) { return false; } boolean hasAsmInstructions = false; for (int i = forwardReferences[0]; i > 0; i -= 2) { final int sourceInsnBytecodeOffset = forwardReferences[i - 1]; final int reference = forwardReferences[i]; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK; if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) { if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to // 65535, which is sufficient since the size of a method is limited to 65535 bytes). int opcode = code[sourceInsnBytecodeOffset] & 0xFF; if (opcode < Opcodes.IFNULL) { // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA); } else { // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA); } hasAsmInstructions = true; } code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } else { code[handle++] = (byte) (relativeOffset >>> 24); code[handle++] = (byte) (relativeOffset >>> 16); code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } } return hasAsmInstructions; } \nResponse:", "ground_truth": "Sets the bytecode offset of this label to the given value and resolves the forward references\nto this label, if any. This method must be called when this label is added to the bytecode of\nthe method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\nwhere left in the bytecode by each forward reference previously added to this label.\n\n@param code the bytecode of the method.\n@param bytecodeOffset the bytecode offset of this label.\n@return {@literal true} if a blank that was left for this label was too small to store the\noffset. In such a case the corresponding jump instruction is replaced with an equivalent\nASM specific instruction using an unsigned two bytes offset. These ASM specific\ninstructions are later replaced with standard bytecode instructions with wider offsets (4\nbytes instead of 2), in ClassReader.", "predict": "\n\npublic final boolean resolve(final byte[] code, final int bytecodeOffset) { this.flags |= FLAG_RESOLVED; this.bytecodeOffset = bytecodeOffset; if (forwardReferences == null) { return false; } boolean hasAsmInstructions = false; for (int i = forwardReferences[0]; i > 0; i -= 2) { final int sourceInsnBytecodeOffset = forwardReferences[i - 1]; final int reference = forwardReferences[i]; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK; if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) { if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader"}, {"ID": 1232, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void markSubroutine(final short subroutineId) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = listOfBlocksToProcess.nextListElement; basicBlock.nextListElement = null; // If it is not already marked as belonging to a subroutine, mark it as belonging to // subroutineId and add its successors to the list of blocks to process (unless already done). if (basicBlock.subroutineId == 0) { basicBlock.subroutineId = subroutineId; listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } } } \nResponse:", "ground_truth": "Finds the basic blocks that belong to the subroutine starting with the basic block\ncorresponding to this label, and marks these blocks as belonging to this subroutine. This\nmethod follows the control flow graph to find all the blocks that are reachable from the\ncurrent basic block WITHOUT following any jsr target.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineId the id of the subroutine starting with the basic block corresponding to\nthis label.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<BasicBlock> listOfBlocksToProcess = new ArrayList<>();\n        listOfBlocksToProcess.add(new BasicBlock(0, new ArrayList<>()));\n        while (listOfBlocksToProcess.size() != 0) {\n            BasicBlock basicBlock = listOfBlocksToProcess.remove(0);\n            if (basicBlock.subroutineId == 0) {\n                basicBlock.subroutineId = 1;\n                basicBlock.pushSuccessors(listOfBlocksToProcess);\n            }\n        }\n    }\n}\n"}, {"ID": 1233, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void addSubroutineRetSuccessors(final Label subroutineCaller) { // Data flow algorithm: put this basic block in a list blocks to process (which are blocks // belonging to a subroutine starting with this label) and, while there are blocks to process, // remove one from the list, put it in a list of blocks that have been processed, add a return // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks // in the control flow graph to the list of blocks to process (if not already done). Label listOfProcessedBlocks = EMPTY_LIST; Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Move a basic block from the list of blocks to process to the list of processed blocks. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = basicBlock.nextListElement; basicBlock.nextListElement = listOfProcessedBlocks; listOfProcessedBlocks = basicBlock; // Add an edge from this block to the successor of the caller basic block, if this block is // the end of a subroutine and if this block and subroutineCaller do not belong to the same // subroutine. if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) { basicBlock.outgoingEdges = new Edge( basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr // instruction leads to the jsr continuation block, i.e. where execution continues // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}). subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges); } // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does // not push basic blocks which are already in a list. Here this means either in the list of // blocks to process, or in the list of already processed blocks. This second list is // important to make sure we don't reprocess an already processed block. listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null, // so that this method can be called again with a different subroutine or subroutine caller. while (listOfProcessedBlocks != EMPTY_LIST) { Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement; listOfProcessedBlocks.nextListElement = null; listOfProcessedBlocks = newListOfProcessedBlocks; } } \nResponse:", "ground_truth": "Finds the basic blocks that end a subroutine starting with the basic block corresponding to\nthis label and, for each one of them, adds an outgoing edge to the basic block following the\ngiven subroutine call. In other words, completes the control flow graph by adding the edges\ncorresponding to the return from this subroutine, when called from the given caller basic\nblock.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\nthis label. This label is supposed to correspond to the start of a subroutine.", "predict": "\n\n*/\n"}, {"ID": 1234, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int[] compareDigits(final String str1, int ndx1, final String str2, int ndx2) { // iterate all digits in the first string int zeroCount1 = 0; while (charAt(str1, ndx1) == '0') { zeroCount1++; ndx1++; } int len1 = 0; while (true) { final char char1 = charAt(str1, ndx1); final boolean isDigitChar1 = CharUtil.isDigit(char1); if (!isDigitChar1) { break; } len1++; ndx1++; } // iterate all digits in the second string and compare with the first int zeroCount2 = 0; while (charAt(str2, ndx2) == '0') { zeroCount2++; ndx2++; } int len2 = 0; int ndx1_new = ndx1 - len1; int equalNumbers = 0; while (true) { final char char2 = charAt(str2, ndx2); final boolean isDigitChar2 = CharUtil.isDigit(char2); if (!isDigitChar2) { break; } if (equalNumbers == 0 && (ndx1_new < ndx1)) { equalNumbers = charAt(str1, ndx1_new++) - char2; } len2++; ndx2++; } // compare if (len1 != len2) { // numbers are not equals size return new int[] {len1 - len2}; } if (equalNumbers != 0) { return new int[] {equalNumbers}; } // numbers are equal, but number of zeros is different return new int[] {0, zeroCount1 - zeroCount2, ndx1, ndx2}; } \nResponse:", "ground_truth": "Compare digits at certain position in two strings.\nThe longest run of digits wins. That aside, the greatest\nvalue wins.\n@return if numbers are different, only 1 element is returned.", "predict": "\n\npublic int[] compareDigits(final String str1, int ndx1, final String str2, int ndx2) {\n    int[] result = new int[3];\n    int zeroCount1 = 0;\n    while (charAt(str1, ndx1) == '0') {\n        zeroCount1++;\n        ndx1++;\n    }\n    int len1 = 0;\n    while (true) {\n        final char char1 = charAt(str1, ndx1);\n        final boolean isDigitChar1 = CharUtil.isDigit(char1);\n        if (!isDigitChar1) {\n            break;\n        }\n        len1++;\n        ndx1++;\n    }\n    int zeroCount2 = 0;\n    while (charAt(str2, ndx2) == '0') {\n        zeroCount2++;\n        ndx2++;\n    }\n    int len"}, {"ID": 1235, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private char fixAccent(final char c) { for (int i = 0; i < ACCENT_CHARS.length; i+=2) { final char accentChar = ACCENT_CHARS[i]; if (accentChar == c) { return ACCENT_CHARS[i + 1]; } } return c; } \nResponse:", "ground_truth": "Fixes accent char.", "predict": "\n\npublic class FixAccent {\n    private char fixAccent(final char c) {\n        for (int i = 0; i < ACCENT_CHARS.length; i+=2) {\n            final char accentChar = ACCENT_CHARS[i];\n            if (accentChar == c) {\n                return ACCENT_CHARS[i + 1];\n            }\n        }\n        return c;\n    }\n}\n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.fixAccents(\"\\u00e9\"));\n    }\n\n    public char fixAccents(String s) {\n        char[] chars = s.toCharArray();\n        Map<Character, Character> map = new Hash"}, {"ID": 1236, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putByte(final int byteValue) { int currentLength = length; if (currentLength + 1 > data.length) { enlarge(1); } data[currentLength++] = (byte) byteValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue a byte.\n@return this byte vector.", "predict": " Resp public ByteVector putByte(final int byteValue) { int currentLength = length; if (currentLength + 1 > data.length) { enlarge(1); } data[currentLength++] = (byte) byteValue; length = currentLength; return this; } \n\n*/\n\npublic class ByteVector {\n\tprivate byte[] data;\n\tprivate int length;\n\t\n\tpublic ByteVector(int size) {\n\t\tdata = new byte[size];\n\t\tlength = 0;\n\t}\n\t\n\tpublic ByteVector(byte[] data) {\n\t\tthis.data = data;\n\t\tlength = data.length;\n\t}\n\t\n\tpublic ByteVector(byte[] data, int length) {\n\t\tthis.data = data;\n\t\tthis.length = length;\n\t}\n\t\n\tpublic int length() {\n\t\treturn length;\n\t}\n\t\n\tpublic byte[] data() {\n\t\treturn data;\n\t}\n"}, {"ID": 1237, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put11(final int byteValue1, final int byteValue2) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@return this byte vector.", "predict": "\n\n*/\n\npublic class ByteVector {\n    private byte[] data;\n    private int length;\n\n    public ByteVector(int size) {\n        data = new byte[size];\n        length = 0;\n    }\n\n    public ByteVector(byte[] data) {\n        this.data = data;\n        length = data.length;\n    }\n\n    public void put(byte b) {\n        if (length + 1 > data.length) {\n            enlarge(1);\n        }\n        data[length++] = b;\n    }\n\n    public void put(byte[] b) {\n        if (length + b.length > data.length) {\n            enlarge(b.length);\n        }\n        System.arraycopy(b, 0, data, length, b.length);\n        length += b.length;\n    }\n\n    public void put(byte[] b, int off, int len) {\n        if ("}, {"ID": 1238, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putShort(final int shortValue) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param shortValue a short.\n@return this byte vector.", "predict": "\n\n*/\n\npublic class ByteVector {\n    private byte[] data;\n    private int length;\n\n    public ByteVector(int size) {\n        data = new byte[size];\n        length = 0;\n    }\n\n    public ByteVector(byte[] data) {\n        this.data = data;\n        length = data.length;\n    }\n\n    public void putShort(int shortValue) {\n        int currentLength = length;\n        if (currentLength + 2 > data.length) {\n            enlarge(2);\n        }\n        byte[] currentData = data;\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\n        currentData[currentLength++] = (byte) shortValue;\n        length = currentLength;\n    }\n\n    public void putInt(int intValue) {\n        int currentLength = length;\n        if (currentLength + 4 > data.length) {\n            en"}, {"ID": 1239, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put12(final int byteValue, final int shortValue) { int currentLength = length; if (currentLength + 3 > data.length) { enlarge(3); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue a byte.\n@param shortValue a short.\n@return this byte vector.", "predict": "\n\n*/\n\npublic class Test {\n    public static void main(String[] args) {\n        ByteVector bv = new ByteVector();\n        bv.put12(0x42, 0x42);\n        System.out.println(bv.toString());\n    }\n}\n"}, {"ID": 1240, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@param shortValue a short.\n@return this byte vector.", "predict": "\n\n*/\n\npublic class Test {\n    public static void main(String[] args) {\n        ByteVector bv = new ByteVector();\n        bv.put112(1, 2, 3);\n        System.out.println(bv.toString());\n    }\n}\n"}, {"ID": 1241, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putInt(final int intValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param intValue an int.\n@return this byte vector.", "predict": " public ByteVector putInt(final int intValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \n\n*/\n\npublic class ByteVector {\n\tprivate byte[] data;\n\tprivate int length;\n\t\n\tpublic ByteVector(int size) {\n\t\tdata = new byte[size];\n\t\tlength = 0;\n\t}\n\t\n\tpublic ByteVector(byte[] data) {\n\t\tthis.data = data;\n\t\tlength = data.length;\n\t}\n\t\n\tpublic void putInt(int intValue) {"}, {"ID": 1242, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) { int currentLength = length; if (currentLength + 5 > data.length) { enlarge(5); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue1 >>> 8); currentData[currentLength++] = (byte) shortValue1; currentData[currentLength++] = (byte) (shortValue2 >>> 8); currentData[currentLength++] = (byte) shortValue2; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\nif necessary.\n\n@param byteValue a byte.\n@param shortValue1 a short.\n@param shortValue2 another short.\n@return this byte vector.", "predict": "\n\n*/\n\npublic class Test {\n    public static void main(String[] args) {\n        final ByteVector byteVector = new ByteVector();\n        byteVector.put122(1, 2, 3);\n        System.out.println(byteVector.toString());\n    }\n}\n"}, {"ID": 1243, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putLong(final long longValue) { int currentLength = length; if (currentLength + 8 > data.length) { enlarge(8); } byte[] currentData = data; int intValue = (int) (longValue >>> 32); currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; intValue = (int) longValue; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param longValue a long.\n@return this byte vector.", "predict": " public ByteVector putLong(final long longValue) { int currentLength = length; if (currentLength + 8 > data.length) { enlarge(8); } byte[] currentData = data; int intValue = (int) (longValue >>> 32); currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; intValue = (int) longValue; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \n\n}\n"}, {"ID": 1244, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; } \nResponse:", "ground_truth": "Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\nbytes into this byte vector.\n@param byteOffset index of the first byte of byteArrayValue that must be copied.\n@param byteLength number of bytes of byteArrayValue that must be copied.\n@return this byte vector.", "predict": " public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; } \nResp public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength, final int maxByteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; } \nResp public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength, final int maxByteLength, final int maxLength) { if (length +"}, {"ID": 1245, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void enlarge(final int size) { int doubleCapacity = 2 * data.length; int minimalCapacity = length + size; byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity]; System.arraycopy(data, 0, newData, 0, length); data = newData; } \nResponse:", "ground_truth": "Enlarges this byte vector so that it can receive 'size' more bytes.\n\n@param size number of additional bytes that this byte vector should be able to receive.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9,10};\n        int[] nums2 = new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,"}, {"ID": 1246, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaHttpSession(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final UserSession<T> userSession = UserSession.get(servletRequest); if (userSession == null) { return null; } final T authToken = userSession.getAuthToken(); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); if (newAuthToken != authToken) { final UserSession<T> newUserSesion = new UserSession<>(newAuthToken, userAuth().tokenValue(newAuthToken)); newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse()); } return newAuthToken; } \nResponse:", "ground_truth": "Tries to authenticate user via HTTP session. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\npublic class UserSession<T> {\n\n\tprivate final T authToken;\n\tprivate final String tokenValue;\n\tprivate final List<String> roles;\n\tprivate final String userName;\n\tprivate final String userId;\n\tprivate final String userEmail;\n\tprivate final String userFirstName;\n\tprivate final String userLastName;\n\tprivate final String userPhone;\n\tprivate final String userAddress;\n\tprivate final String userCity;\n\tprivate final String userState;\n\t"}, {"ID": 1247, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaToken(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); // then try the auth token final String token = ServletUtil.resolveAuthBearerToken(servletRequest); if (token == null) { return null; } final T authToken = userAuth().validateToken(token); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken)); return newAuthToken; } \nResponse:", "ground_truth": "Tries to authenticate user via token. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc"}, {"ID": 1248, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaBasicAuth(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); final T authToken = userAuth().login(username, password); if (authToken == null) { return null; } return authToken; } \nResponse:", "ground_truth": "Tires to authenticate user via the basic authentication. Returns the token if user is authenticated.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView.TransformedCollectionView;\nimport com.google.common.collect.Sets.SetView.TransformedSetView;"}, {"ID": 1249, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String findDefaultMessage(final Locale locale, final String key) { String indexedKey = calcIndexKey(key); String msg = getMessage(fallbackBundlename, locale, key, indexedKey); if (msg != null) { return msg; } for (String bname : defaultBundles) { msg = getMessage(bname, locale, key, indexedKey); if (msg != null) { return msg; } } return null; } \nResponse:", "ground_truth": "Finds message in default bundles only, starting from fallback bundlename.", "predict": "\n\npublic String findDefaultMessage(final Locale locale, final String key) {\n    String indexedKey = calcIndexKey(key);\n    String msg = getMessage(fallbackBundlename, locale, key, indexedKey);\n    if (msg != null) {\n        return msg;\n    }\n    for (String bname : defaultBundles) {\n        msg = getMessage(bname, locale, key, indexedKey);\n        if (msg != null) {\n            return msg;\n        }\n    }\n    return null;\n}\n\npublic String findDefaultMessage(final Locale locale, final String key, final Object[] args) {\n    String indexedKey = calcIndexKey(key);\n    String msg = getMessage(fallbackBundlename, locale, key, indexedKey);\n    if (msg != null) {\n        return msg;\n    }\n    for (String bname : defaultBundles) {\n"}, {"ID": 1250, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ResourceBundle getBundle(final String bundleName, final Locale locale, final ClassLoader classLoader) { return ResourceBundle.getBundle(bundleName, locale, classLoader); } \nResponse:", "ground_truth": "Returns specified bundle. Invoked every time if cache is disabled.\nInput arguments are always valid.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1251, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected K get(final K[] array, final int index) { return (K) Array.get(array, index); } \nResponse:", "ground_truth": "Returns array's element at given index.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.generateBinaryTree(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84"}, {"ID": 1252, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <E, ID> void setEntityId(final DbEntityDescriptor<E> ded, final E entity, final ID newIdValue) { ded.setIdValue(entity, newIdValue); } \nResponse:", "ground_truth": "Sets new ID value for entity.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1253, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void save(final Object entity) { final DbQuery q = query(dbOom.entities().insert(entity)); q.autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Simply inserts object into the database.", "predict": "\n\n<pre>\npublic void save(final Object entity) {\n    final DbQuery q = query(dbOom.entities().insert(entity));\n    q.autoClose().executeUpdate();\n}\n</pre>\n\n*/\npackage org.dbmaintain.script.executedscriptinfo.h2;\n"}, {"ID": 1254, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void update(final Object entity) { query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Updates single entity.", "predict": " Response = dbOom.entities().updateAll(entity);\n\n*/\n\npackage com.github.dannil.scbjavaclient.client.financialmarkets.balanceofpayments;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport com.github.dannil.scbjavaclient.client.AbstractClient;\nimport com.github.dannil.scbjavaclient.communication.URLEndpoint;\nimport com.github.dannil.scbjavaclient.constants.APIConstants;\nimport com.github.dannil.scbjavaclient.model.ResponseModel;\n\n/**\n * <p>Client which handles financial markets balance of payments data fetching.</p>\n *\n * @since 0.4.0\n */\npublic class"}, {"ID": 1255, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E updateProperty(final E entity, final String name, final Object newValue) { query(dbOom.entities().updateColumn(entity, name, newValue)).autoClose().executeUpdate(); BeanUtil.declared.setProperty(entity, name, newValue); return entity; } \nResponse:", "ground_truth": "Updates single property in database and in the bean.", "predict": " Response = query(dbOom.entities().updateColumn(entity, name, newValue)).autoClose().executeUpdate(); return Response; } \n\n*/\n\npackage com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport com.github.dannil.scbjavaclient.client.AbstractClient;\nimport com.github.dannil.scbjavaclient.communication.URLEndpoint;\nimport com.github.dannil.scbjavaclient.constants.APIConstants;\nimport com.github.dannil.scbjavaclient.model.ResponseModel;\n\n/**\n * <p>Client which handles business activities industrial complexes data fetching.</p>"}, {"ID": 1256, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E updateProperty(final E entity, final String name) { Object value = BeanUtil.declared.getProperty(entity, name); query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate(); return entity; } \nResponse:", "ground_truth": "Updates property in the database by storing the current property value.", "predict": "\n\n*/\n\npackage com.github.javafaker;\n\nimport com.github.javafaker.service.RandomService;\nimport com.github.javafaker.service.RandomServiceImpl;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RandomServiceTest {\n\n    @Test\n    public void testGetRandomString() {\n        RandomService randomService = new RandomServiceImpl();\n        assertEquals(\"test\", randomService.getRandomString(4));\n    }\n}\n"}, {"ID": 1257, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E, ID> E findById(final Class<E> entityType, final ID id) { return query(dbOom.entities().findById(entityType, id)).autoClose().find(entityType); } \nResponse:", "ground_truth": "Finds single entity by its id.", "predict": "\n\n*/\n\npackage com.github.javafaker;\n\nimport com.github.javafaker.service.RandomService;\nimport com.github.javafaker.service.RandomServiceImpl;\nimport com.github.javafaker.service.RandomServiceImpl2;\nimport com.github.javafaker.service.RandomServiceImpl3;\nimport com.github.javafaker.service.RandomServiceImpl4;\nimport com.github.javafaker.service.RandomServiceImpl5;\nimport com.github.javafaker.service.RandomServiceImpl6;\nimport com.github.javafaker.service.RandomServiceImpl7;\nimport com.github.javafaker.service.RandomServiceImpl8;\nimport com.github.javafaker.service.RandomServiceImpl9;\nimport com.github.javafaker.service.RandomServiceImpl10;\nimport com.github"}, {"ID": 1258, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) { return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType); } \nResponse:", "ground_truth": "Finds single entity by matching property.", "predict": "\n\npublic <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) { return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType); } \n\n*/\n\npublic class FindByProperty {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new OOM instance.\n\t\tOOM oom = new OOM();\n\t\t\n\t\t// Create a new EntityManagerFactory.\n\t\tEntityManagerFactory emf = oom.getEntityManagerFactory();\n\t\t\n\t\t// Create a new EntityManager.\n\t\tEntityManager em = emf.createEntityManager();\n\t\t\n\t\t// Create a new EntityTransaction.\n\t\tEntityTransaction tx = em.getTransaction();\n\t\t\n\t\t// Start the transaction.\n\t\ttx.begin();\n\t\t\n\t\t// Create a new EntityManager.\n\t\tEntityManager em2 = emf."}, {"ID": 1259, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public <E> E findOne(final Object criteria) { return (E) query(dbOom.entities().find(criteria)).autoClose().find(criteria.getClass()); } \nResponse:", "ground_truth": "Finds one entity for given criteria.", "predict": "\n\n*/\n\npackage com.github.javafaker;\n\nimport com.github.javafaker.service.RandomService;\nimport com.github.javafaker.service.RandomServiceImpl;\nimport com.github.javafaker.service.RandomServiceImpl2;\nimport com.github.javafaker.service.RandomServiceImpl3;\nimport com.github.javafaker.service.RandomServiceImpl4;\nimport com.github.javafaker.service.RandomServiceImpl5;\nimport com.github.javafaker.service.RandomServiceImpl6;\nimport com.github.javafaker.service.RandomServiceImpl7;\nimport com.github.javafaker.service.RandomServiceImpl8;\nimport com.github.javafaker.service.RandomServiceImpl9;\nimport com.github.javafaker.service.RandomServiceImpl10;\nimport com.github"}, {"ID": 1260, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void deleteById(final Class entityType, final ID id) { query(dbOom.entities().deleteById(entityType, id)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Deleted single entity by its id.", "predict": " Response is generated by the method.\n */\npublic class DeleteById {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 1261, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void deleteById(final Object entity) { if (entity != null) { int result = query(dbOom.entities().deleteById(entity)).autoClose().executeUpdate(); if (result != 0) { // now reset the ID value Class type = entity.getClass(); DbEntityDescriptor ded = dbOom.entityManager().lookupType(type); setEntityId(ded, entity, 0); } } } \nResponse:", "ground_truth": "Delete single object by its id. Resets ID value.", "predict": "\n\n*/\n\npackage com.github.javafaker;\n\nimport com.github.javafaker.service.RandomService;\nimport com.github.javafaker.service.RandomServiceImpl;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RandomServiceTest {\n\n    @Test\n    public void testRandomService() {\n        RandomService randomService = new RandomServiceImpl();\n        List<String> randomStrings = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            randomStrings.add(randomService.randomString(10));\n        }\n        assertEquals(10, randomStrings.size());\n    }\n}\n"}, {"ID": 1262, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long count(final Class entityType) { return query(dbOom.entities().count(entityType)).autoClose().executeCount(); } \nResponse:", "ground_truth": "Counts number of all entities.", "predict": " Response = dbOom.entities().count(entityType);\n\n*/\n\npackage com.github.javafaker;\n\nimport com.github.javafaker.service.RandomService;\nimport com.github.javafaker.service.RandomServiceImpl;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class RandomServiceTest {\n\n    @Test\n    public void testGetRandomNumber() {\n        RandomService randomService = new RandomServiceImpl();\n        assertEquals(randomService.getRandomNumber(1), 1);\n        assertEquals(randomService.getRandomNumber(2), 2);\n        assertEquals(randomService.getRandomNumber(3), 3);\n        assertEquals(randomService.getRandomNumber(4), 4);\n        assertEquals(randomService.getRandomNumber(5), 5);\n        assertEquals(randomService."}, {"ID": 1263, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void increaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, true)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Increases a property.", "predict": "\n\n*/\n\npublic class IncreaseProperty extends AbstractJavaMethod {\n\n\tpublic static final String NAME = \"increaseProperty\";\n\n\tpublic IncreaseProperty(final OomphContext context) {\n\t\tsuper(NAME, context);\n\t}\n\n\t@Override\n\tpublic void execute() {\n\n\t\tfinal String entityType = getEntityType();\n\t\tfinal String id = getId();\n\t\tfinal String name = getName();\n\t\tfinal Number delta = getDelta();\n\n\t\tfinal StringBuilder javaCode = new StringBuilder();\n\t\tjavaCode.append(\"public \");\n\t\tjavaCode.append(entityType);\n\t\tjavaCode.append(\" \");\n\t\tjavaCode.append(NAME);\n\t\tjavaCode.append(\"(\");\n\t\tjavaCode.append(entityType);\n\t\tjavaCode.append(\" \");\n\t\tjavaCode.append(entityType);\n\t\tjavaCode.append(\", \");\n\t\tjavaCode.append(id);\n\t\tjavaCode.append(\","}, {"ID": 1264, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void decreaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, false)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Decreases a property.", "predict": "\n\n*/\n\npackage com.dslplatform.client.generated.types.Decimal;\n\nimport com.dslplatform.client.JsonSerialization;\nimport com.dslplatform.patterns.Bytes;\nimport java.io.IOException;\n\npublic class DecreaseByOne implements Bytes {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate final String value;\n\n\tpublic DecreaseByOne(String value) {\n\t\tthis.value = value;\n\t}\n\n\t@Override\n\tpublic void serialize(JsonSerialization jsonSerialization) throws IOException {\n\t\tjsonSerialization.writeString(value);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tstringBuilder.append(\"\\\"decreaseByOne\\\"\");\n\t\treturn stringBuilder.toString();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn"}, {"ID": 1265, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> List<E> findRelated(final Class<E> target, final Object source) { return query(dbOom.entities().findForeign(target, source)).autoClose().list(target); } \nResponse:", "ground_truth": "Finds related entity.", "predict": "\n\npublic class <E> List<E> findRelated(final Class<E> target, final Object source) {\n    return query(dbOom.entities().findForeign(target, source)).autoClose().list(target);\n}\n\n*/\n\npackage com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport com.github.dannil.scbjavaclient.client.AbstractClient;\nimport com.github.dannil.scbjavaclient.communication.URLEndpoint;\nimport com.github.dannil.scbjavaclient.constants.APIConstants;\nimport com.github.dannil.scbjavaclient.model.ResponseModel"}, {"ID": 1266, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> List<E> listAll(final Class<E> target) { return query(dbOom.entities().from(target)).autoClose().list(target); } \nResponse:", "ground_truth": "List all entities.", "predict": "\n\npublic class <E> List<E> listAll(final Class<E> target) {\n    return query(dbOom.entities().from(target)).autoClose().list(target);\n}\n\n*/\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser."}, {"ID": 1267, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void clear() { entries = null; Iterator<String> keys = getAttributeNames(); while (keys.hasNext()) { removeAttribute(keys.next()); } } \nResponse:", "ground_truth": "Removes all attributes from the request as well as clears entries in this map.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1268, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Set<Entry<String, Object>> entrySet() { if (entries == null) { entries = new HashSet<>(); Iterator<String> iterator = getAttributeNames(); while (iterator.hasNext()) { final String key = iterator.next(); final Object value = getAttribute(key); entries.add(new Entry<String, Object>() { @Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (this.getClass() != obj.getClass()) { return false; } Entry entry = (Entry) obj; return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue())); } @Override public int hashCode() { return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode()); } @Override public String getKey() { return key; } @Override public Object getValue() { return value; } @Override public Object setValue(final Object obj) { setAttribute(key, obj); return value; } }); } } return entries; } \nResponse:", "ground_truth": "", "predict": " Response = new Response() { @Override public int getStatus() { return status; } @Override public void setStatus(final int status) { this.status = status; } @Override public String getEntity() { return entity; } @Override public void setEntity(final String entity) { this.entity = entity; } @Override public void setEntity(final Object entity) { this.entity = entity.toString(); } @Override public void setEntity(final byte[] entity) { this.entity = new String(entity); } @Override public void setEntity(final InputStream entity) { this.entity = new String(toByteArray(entity)); } @Override public void setEntity(final Reader entity) { this.entity = new String(toByteArray(entity)); } @Override public void setEntity(final Map<String, Object> entity) { this.entity = new Gson().toJson(entity); } @Override public void setEntity(final Object entity) { this.entity = new G"}, {"ID": 1269, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object put(final String key, final Object value) { entries = null; Object previous = get(key); setAttribute(key, value); return previous; } \nResponse:", "ground_truth": "Saves an attribute in the request.", "predict": " @Override public Object remove(final Object key) { entries = null; Object previous = get(key); setAttribute(key, null); return previous; } \nResp @Override public void putAll(final Map<? extends String, ? extends Object> m) { entries = null; super.putAll(m); } \nResp @Override public void clear() { entries = null; super.clear(); } \nResp @Override public Set<String> keySet() { entries = null; return super.keySet(); } \nResp @Override public Collection<Object> values() { entries = null; return super.values(); } \nResp @Override public Set<java.util.Map.Entry<String, Object>> entrySet() { entries = null; return super.entrySet(); } \nResp @Override public boolean equals(final Object o) { entries = null; return super.equals(o); } \nResp @Override public int hashCode() { entries"}, {"ID": 1270, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object remove(final Object key) { entries = null; Object value = get(key); removeAttribute(key.toString()); return value; } \nResponse:", "ground_truth": "Removes the specified request attribute.", "predict": " @Override public Object remove(final Object key) { entries = null; Object value = get(key); removeAttribute(key.toString()); return value; } \n\n*/\n\npublic class RemoveAttribute extends AbstractJavaMethod {\n\t\n\tpublic RemoveAttribute(final String className, final String methodName, final String methodSignature, final String[] exceptions) {\n\t\tsuper(className, methodName, methodSignature, exceptions);\n\t}\n\t\n\t@Override\n\tpublic String generateCode() {\n\t\t\n\t\tfinal StringBuilder builder = new StringBuilder();\n\t\t\n\t\tbuilder.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\"}, {"ID": 1271, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"ThrowCaughtLocally\"}) public static StackTraceElement[] getCurrentStackTrace() { StackTraceElement[] ste = new Exception().getStackTrace(); if (ste.length > 1) { StackTraceElement[] result = new StackTraceElement[ste.length - 1]; System.arraycopy(ste, 1, result, 0, ste.length - 1); return result; } else { return ste; } } \nResponse:", "ground_truth": "Returns current stack trace in form of array of stack trace elements.\nFirst stack trace element is removed.\nSince an exception is thrown internally, this method is slow.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<StackTraceElement> stackTraceElements = Arrays.asList(new Exception().getStackTrace());\n        System.out.println(stackTraceElements.stream().collect(Collectors.joining(\"\\n\")));\n    }\n}\n"}, {"ID": 1272, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) { StackTraceElement[] st = t.getStackTrace(); ArrayList<StackTraceElement> result = new ArrayList<>(st.length); elementLoop: for (StackTraceElement element : st) { String className = element.getClassName(); if (allow != null) { boolean validElemenet = false; for (String filter : allow) { if (className.contains(filter)) { validElemenet = true; break; } } if (!validElemenet) { continue; } } if (deny != null) { for (String filter : deny) { if (className.contains(filter)) { continue elementLoop; } } } result.add(element); } st = new StackTraceElement[result.size()]; return result.toArray(st); } \nResponse:", "ground_truth": "Returns stack trace filtered by class names.", "predict": " public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) { StackTraceElement[] st = t.getStackTrace(); ArrayList<StackTraceElement> result = new ArrayList<>(st.length); elementLoop: for (StackTraceElement element : st) { String className = element.getClassName(); if (allow != null) { boolean validElemenet = false; for (String filter : allow) { if (className.contains(filter)) { validElemenet = true; break; } } if (!validElemenet) { continue; } } if (deny != null) { for (String filter : deny) { if (className.contains(filter)) { continue elementLoop; } } } result.add(element); } st = new StackTraceElement[result.size()]; return result.toArray(st); } \n\n*/\n\nimport java.util."}, {"ID": 1273, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) { ArrayList<StackTraceElement[]> result = new ArrayList<>(); while (t != null) { StackTraceElement[] stack = getStackTrace(t, allow, deny); result.add(stack); t = t.getCause(); } StackTraceElement[][] allStacks = new StackTraceElement[result.size()][]; for (int i = 0; i < allStacks.length; i++) { allStacks[i] = result.get(i); } return allStacks; } \nResponse:", "ground_truth": "Returns stack trace chain filtered by class names.", "predict": " public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) { ArrayList<StackTraceElement[]> result = new ArrayList<>(); while (t != null) { StackTraceElement[] stack = getStackTrace(t, allow, deny); result.add(stack); t = t.getCause(); } StackTraceElement[][] allStacks = new StackTraceElement[result.size()][]; for (int i = 0; i < allStacks.length; i++) { allStacks[i] = result.get(i); } return allStacks; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.get"}, {"ID": 1274, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Throwable[] getExceptionChain(Throwable throwable) { ArrayList<Throwable> list = new ArrayList<>(); list.add(throwable); while ((throwable = throwable.getCause()) != null) { list.add(throwable); } Throwable[] result = new Throwable[list.size()]; return list.toArray(result); } \nResponse:", "ground_truth": "Returns exception chain starting from top up to root cause.", "predict": " public static Throwable[] getExceptionChain(Throwable throwable) { ArrayList<Throwable> list = new ArrayList<>(); list.add(throwable); while ((throwable = throwable.getCause()) != null) { list.add(throwable); } Throwable[] result = new Throwable[list.size()]; return list.toArray(result); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ExceptionChain {\n    public static Throwable[] getExceptionChain(Throwable throwable) {\n        List<Throwable> list = new ArrayList<>();\n        while (throwable != null) {\n            list.add(throwable);\n            throwable = throwable.getCause();\n        }\n        return list.toArray(new Throwable[list.size()]);\n    }\n}\n"}, {"ID": 1275, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String exceptionStackTraceToString(final Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); } \nResponse:", "ground_truth": "Prints stack trace into a String.", "predict": "\n\npublic static String exceptionStackTraceToString(final Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    StreamUtil.close(pw);\n    StreamUtil.close(sw);\n    return sw.toString();\n}\n\n*/\n\npublic static String exceptionStackTraceToString(final Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    StreamUtil.close(pw);\n    StreamUtil.close(sw);\n    return sw.toString();\n}\n\n}\n"}, {"ID": 1276, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String exceptionChainToString(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); while (t != null) { t.printStackTrace(pw); t = t.getCause(); } StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); } \nResponse:", "ground_truth": "Prints full exception stack trace, from top to root cause, into a String.", "predict": " public static String exceptionChainToString(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); while (t != null) { t.printStackTrace(pw); t = t.getCause(); } StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); } \n\n*/\n\npublic class ExceptionChainToString {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tthrow new Exception(\"Exception\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Exception: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tthrow new Exception(\"Exception\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Exception: \" + e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tthrow new"}, {"ID": 1277, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String buildMessage(final String message, Throwable cause) { if (cause != null) { cause = getRootCause(cause); StringBuilder buf = new StringBuilder(); if (message != null) { buf.append(message).append(\"; \"); } buf.append(\"<--- \").append(cause); return buf.toString(); } else { return message; } } \nResponse:", "ground_truth": "Build a message for the given base message and its cause.", "predict": " public static String buildMessage(final String message, Throwable cause) { if (cause != null) { cause = getRootCause(cause); StringBuilder buf = new StringBuilder(); if (message != null) { buf.append(message).append(\"; \"); } buf.append(\"<--- \").append(cause); return buf.toString(); } else { return message; } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j"}, {"ID": 1278, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Throwable unwrapThrowable(final Throwable wrappedThrowable) { Throwable unwrapped = wrappedThrowable; while (true) { if (unwrapped instanceof InvocationTargetException) { unwrapped = ((InvocationTargetException) unwrapped).getTargetException(); } else if (unwrapped instanceof UndeclaredThrowableException) { unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable(); } else { return unwrapped; } } } \nResponse:", "ground_truth": "Unwraps invocation and undeclared exceptions to real cause.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1279, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerAsConsumer(final ClassScanner classScanner) { classScanner.registerEntryConsumer(classPathEntry -> { final String entryName = classPathEntry.name(); if (entryName.endsWith(actionClassSuffix)) { try { acceptActionClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc action, ignoring: \" + entryName); } } else if (classPathEntry.isTypeSignatureInUse(MADVOC_COMPONENT_ANNOTATION)) { try { acceptMadvocComponentClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc component ignoring: {}\" + entryName); } } }); } \nResponse:", "ground_truth": "Parses class name that matches madvoc-related names.", "predict": "\n\n*/\n\npackage org.springframework.web.servlet.mvc.method.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n/**\n * Annotation for mapping a Madvoc component class to a Spring MVC controller.\n *\n * <p>The annotated class must be a Madvoc component class.\n *\n * <p>The annotated class must have a method with the signature\n * {@code public void acceptMadvocComponentClass(Class<?> componentClass)}.\n *\n * <p>The method must be public, static and not throw any exceptions.\n *\n * <p>The method must be annotated with"}, {"ID": 1280, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void acceptMadvocComponentClass(final Class componentClass) { if (componentClass == null) { return; } if (!checkClass(componentClass)) { return; } madvocComponents.add(() -> madvocContainer.registerComponent(componentClass)); } \nResponse:", "ground_truth": "Registers new Madvoc component.", "predict": " public void acceptMadvocComponentClass(final Class componentClass) { if (componentClass == null) { return; } if (!checkClass(componentClass)) { return; } madvocComponents.add(() -> madvocContainer.registerComponent(componentClass)); } \n\n//----------------------------------------------------------------------------------------------------------------------\n\npublic class MadvocComponentClass {\n\tpublic static void main(String[] args) {\n\t\tfinal MadvocContainer madvocContainer = new MadvocContainer();\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmadvocContainer.registerComponentClass(new MadvocComponentClass());\n\t\tmad"}, {"ID": 1281, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClassLoader getSystemClassLoader() { if (System.getSecurityManager() == null) { return ClassLoader.getSystemClassLoader(); } else { return AccessController.doPrivileged( (PrivilegedAction<ClassLoader>) ClassLoader::getSystemClassLoader); } } \nResponse:", "ground_truth": "Returns system class loader.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Class<?>> classes = Arrays.stream(ClassLoader.class.getDeclaredMethods())\n                .filter(method -> Modifier.isStatic(method.getModifiers()))\n                .filter(method -> method.getName().equals(\"getSystemClassLoader\"))\n                .map(method -> method.getReturnType())\n                .collect(Collectors.toList());\n\n        System.out.println(classes);\n    }\n}\n"}, {"ID": 1282, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { return url.openStream(); } return null; } \nResponse:", "ground_truth": "Opens a resource of the specified name for reading.\n@see #getResourceUrl(String, ClassLoader)", "predict": " Response = Response.ok().entity(getResourceAsStream(resourceName, callingClass)).build();\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport org.glassfish.jersey.media.multipart.FormDataBodyPart;\nimport org.glassfish.jersey.media.multipart.FormDataMultiPart;\nimport org.glassfish.jersey.media.multipart.MultiPart;\nimport org.glassfish.jersey.media.multipart.file.FileDataBodyPart;\n\nimport com.google.gson."}, {"ID": 1283, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { URLConnection urlConnection = url.openConnection(); urlConnection.setUseCaches(useCache); return urlConnection.getInputStream(); } return null; } \nResponse:", "ground_truth": "Opens a resource of the specified name for reading. Controls caching,\nthat is important when the same jar is reloaded using custom classloader.", "predict": " public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { URLConnection urlConnection = url.openConnection(); urlConnection.setUseCaches(useCache); return urlConnection.getInputStream(); } return null; } \n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class ResourceUtil {\n\n\tpublic static List<String> getResourceList(String resourceName, ClassLoader classLoader) {\n\t\tList<String> resourceList = new ArrayList<String>();\n"}, {"ID": 1284, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getClassAsStream(final Class clazz) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(clazz), clazz.getClassLoader()); } \nResponse:", "ground_truth": "Opens a class of the specified name for reading using class classloader.\n@see #getResourceAsStream(String, ClassLoader)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1285, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getClassAsStream(final String className, final ClassLoader classLoader) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader); } \nResponse:", "ground_truth": "Opens a class of the specified name for reading using provided class loader.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1286, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; } \nResponse:", "ground_truth": "Adds a new child to the tree.", "predict": " public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; } \nResp public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; } \nResp public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else"}, {"ID": 1287, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RouteChunk findOrCreateChild(final String value) { if (children != null) { for (RouteChunk child : children) { if (child.get().equals(value)) { return child; } } } return add(value); } \nResponse:", "ground_truth": "Finds existing chunk or creates a new one if does not exist.", "predict": " public RouteChunk findOrCreateChild(final String value) { if (children != null) { for (RouteChunk child : children) { if (child.get().equals(value)) { return child; } } } return add(value); } \n */\n\npublic class RouteChunk {\n\tprivate String value;\n\tprivate List<RouteChunk> children;\n\t\n\tpublic RouteChunk(String value) {\n\t\tthis.value = value;\n\t\tthis.children = new ArrayList<RouteChunk>();\n\t}\n\t\n\tpublic RouteChunk(String value, List<RouteChunk> children) {\n\t\tthis.value = value;\n\t\tthis.children = children;\n\t}\n\t\n\tpublic String get() {\n\t\treturn value;\n\t}\n\t\n\tpublic void add(RouteChunk child) {\n\t\tchildren.add(child);\n\t}\n\t\n\tpublic List<RouteChunk> get"}, {"ID": 1288, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parseRequest() throws IOException { if (ServletUtil.isMultipartRequest(request)) { parseRequestStream(request.getInputStream(), characterEncoding); } else { Enumeration names = request.getParameterNames(); while (names.hasMoreElements()) { String paramName = (String) names.nextElement(); String[] values = request.getParameterValues(paramName); putParameters(paramName, values); } } } \nResponse:", "ground_truth": "Checks if request if multi-part and parse it. If request is not multi-part it\ncopies all parameters, to make usage the same in both cases.\n\n@see MultipartRequestWrapper", "predict": " public void parseResponse() throws IOException { if (ServletUtil.isMultipartRequest(request)) { parseResponseStream(response.getOutputStream(), characterEncoding); } else { Enumeration names = request.getParameterNames(); while (names.hasMoreElements()) { String paramName = (String) names.nextElement(); String[] values = request.getParameterValues(paramName); putParameters(paramName, values); } } } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServ"}, {"ID": 1289, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Object convertToCollection(final Object value, final Class destinationType, final Class componentType) { return typeConverterManager.convertToCollection(value, destinationType, componentType); } \nResponse:", "ground_truth": "Converter to collection.", "predict": " Response = typeConverterManager.convertToCollection(value, destinationType, componentType);\n\n*/\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class TypeConverterManager {\n\n\tprivate final Map<Class<?>, TypeConverter<?>> typeConverters = Maps.newHashMap();\n\n\tpublic TypeConverterManager"}, {"ID": 1290, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeSetter(final Setter setter, final BeanProperty bp, Object value) { try { final MapperFunction setterMapperFunction = setter.getMapperFunction(); if (setterMapperFunction != null) { value = setterMapperFunction.apply(value); } final Class type = setter.getSetterRawType(); if (ClassUtil.isTypeOf(type, Collection.class)) { Class componentType = setter.getSetterRawComponentType(); value = convertToCollection(value, type, componentType); } else { // no collections value = convertType(value, type); } setter.invokeSetter(bp.bean, value); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Setter failed: \" + setter, ex); } return value; } \nResponse:", "ground_truth": "Invokes setter, but first converts type to match the setter type.", "predict": "\n\n*/\n\npublic class BeanProperty {\n    private final String name;\n    private final Class type;\n    private final Class componentType;\n    private final boolean isCollection;\n    private final boolean isArray;\n    private final boolean isMap;\n    private final boolean isPrimitive;\n    private final boolean isEnum;\n    private final boolean isInterface;\n    private final boolean isFinal;\n    private final boolean isStatic;\n    private final boolean isPrivate;\n    private final boolean isProtected;\n    private final boolean isPublic;\n    private final boolean isAbstract;\n    private final boolean isSettable;\n    private final boolean isMutable;\n    private final boolean isReadable;\n    private final boolean isWritable;\n    private final boolean isAnnotationPresent;\n    private final boolean isAnnotationPresentOnField;\n    private final boolean isAnnotationPresentOnMethod;\n    private final boolean isAnnotationPresentOnParameter;\n    "}, {"ID": 1291, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void arrayForcedSet(final BeanProperty bp, Object array, final int index, Object value) { Class componentType = array.getClass().getComponentType(); array = ensureArraySize(bp, array, componentType, index); value = convertType(value, componentType); Array.set(array, index, value); } \nResponse:", "ground_truth": "Sets the array element forced. If index is greater then arrays length, array will be expanded to the index.\nIf speed is critical, it is better to allocate an array with proper size before using this method.", "predict": "\n\n*/\n\npublic class ArrayForcedSet {\n\tpublic static void main(String[] args) {\n\t\tfinal BeanProperty bp = new BeanProperty();\n\t\tfinal Object array = new Object[10];\n\t\tfinal int index = 5;\n\t\tfinal Object value = new Object();\n\t\t\n\t\tbp.setName(\"array\");\n\t\tbp.setType(Object.class);\n\t\tbp.setValue(array);\n\t\t\n\t\tbp.setGetter(\"getArray\");\n\t\tbp.setSetter(\"setArray\");\n\t\t\n\t\tbp.setIndex(index);\n\t\tbp.setValue(value);\n\t\t\n\t\tbp.setGetter(\"getArray\");\n\t\tbp.setSetter(\"setArray\");\n\t\t\n\t\tbp.setGetter(\"getArray\");\n\t\tbp.setSetter(\"setArray\");\n\t\t\n\t\tbp.setGetter(\"getArray\");\n\t\tbp.setSetter(\"setArray\");\n\t\t\n\t\tbp"}, {"ID": 1292, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object createBeanProperty(final BeanProperty bp) { Setter setter = bp.getSetter(true); if (setter == null) { return null; } Class type = setter.getSetterRawType(); Object newInstance; try { newInstance = ClassUtil.newInstance(type); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Invalid property: \" + bp.name, bp, ex); } newInstance = invokeSetter(setter, bp, newInstance); return newInstance; } \nResponse:", "ground_truth": "Creates new instance for current property name through its setter.\nIt uses default constructor!", "predict": "\n\n*/\n\npublic class BeanProperty {\n\tprivate String name;\n\tprivate String type;\n\tprivate String setter;\n\tprivate String getter;\n\tprivate String description;\n\tprivate boolean isCollection;\n\tprivate boolean isArray;\n\tprivate boolean isMap;\n\tprivate boolean isPrimitive;\n\tprivate boolean isReadOnly;\n\tprivate boolean isWriteOnly;\n\tprivate boolean isHidden;\n\tprivate boolean isTransient;\n\tprivate boolean isStatic;\n\tprivate boolean isFinal;\n\tprivate boolean isPrivate;\n\tprivate boolean isProtected;\n\tprivate boolean isPublic;\n\tprivate boolean isAbstract;\n\tprivate boolean isFinal;\n\tprivate boolean isStatic;\n\tprivate boolean isAbstract;\n\tprivate boolean isFinal;\n\tprivate boolean isStatic;\n\tprivate boolean isAbstract;\n\tprivate boolean isFinal;\n\tprivate boolean isStatic;\n\tprivate boolean isAbstract;\n\tprivate boolean isFinal;\n"}, {"ID": 1293, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class extractType(final BeanProperty bp) { Getter getter = bp.getGetter(isDeclared); if (getter != null) { if (bp.index != null) { Class type = getter.getGetterRawComponentType(); return type == null ? Object.class : type; } return getter.getGetterRawType(); } return null; // this should not happens } \nResponse:", "ground_truth": "Extracts type of current property.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\n\npublic class JavaCodeGenerator {\n\n\tprivate static final String JAVA_CODE_PREFIX = \"public class \";\n\tprivate static final String JAVA_CODE_SUFFIX = \" { \";\n\tprivate static final String JAVA_CODE_END = \" } \";\n\tprivate static final String JAVA_CODE_IMPORT = \"import java.util.List;\\n\";\n\tprivate static final String JAVA_CODE_IMPORT_END = \"}\";\n\tprivate static final String JAVA"}, {"ID": 1294, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void stop(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { final HttpSession httpSession = servletRequest.getSession(false); if (httpSession != null) { httpSession.removeAttribute(AUTH_SESSION_NAME); } final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME); if (cookie == null) { return; } cookie.setMaxAge(0); cookie.setPath(\"/\"); servletResponse.addCookie(cookie); } \nResponse:", "ground_truth": "", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.gson.Gson;\n\npublic class AuthServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\tresp.setContentType(\"application/json\");\n\t\tresp.setCharacterEncoding(\"UTF-8\");\n\t\t\n\t\tString path = req.getRequestURI"}, {"ID": 1295, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) { final HttpSession httpSession = httpServletRequest.getSession(true); httpSession.setAttribute(AUTH_SESSION_NAME, this); final Cookie cookie = new Cookie(AUTH_COOKIE_NAME, authTokenValue); //cookie.setDomain(SSORealm.SSO_DOMAIN); cookie.setMaxAge(cookieMaxAge); cookie.setPath(\"/\"); httpServletResponse.addCookie(cookie); } \nResponse:", "ground_truth": "Starts new user session.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.time.DateUtils;\nimport org.apache.commons.lang3.time.DateUtils.DateToken;\nimport org.apache.commons.lang3.time.DateUtils.TimeZoneRule;\nimport org.apache.commons.lang3.time.Fast"}, {"ID": 1296, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Date toDate(final LocalDate localDate) { return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant()); } \nResponse:", "ground_truth": "Converts local date to Date.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1297, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Calendar toCalendar(final LocalDateTime localDateTime) { return GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault())); } \nResponse:", "ground_truth": "Converts local date time to Calendar.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1298, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class defineProxy(final Class target) { ProxyProxettaFactory builder = proxetta.proxy(); builder.setTarget(target); return builder.define(); } \nResponse:", "ground_truth": "Generates new class.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1299, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Check check) { String name = check.getName(); List<Check> list = map.computeIfAbsent(name, k -> new ArrayList<>()); list.add(check); } \nResponse:", "ground_truth": "Adds validation checks.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution.main(null);\n    }\n\n    public static void main(String[] args) {\n        List<String> names = Stream.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\","}, {"ID": 1300, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ValidationContext resolveFor(final Class<?> target) { ValidationContext vc = new ValidationContext(); vc.addClassChecks(target); return vc; } \nResponse:", "ground_truth": "Resolve validation context for provided target class.\n@see #addClassChecks(Class)", "predict": " Response is generated by the following java Code. Code: public static Response resolveFor(final Class<?> target) { Response r = new Response(); r.addClassChecks(target); return r; } \n\n*/\n\npublic class ValidationContext {\n\t\n\tprivate List<Class<?>> classChecks = new ArrayList<Class<?>>();\n\t\n\tpublic void addClassChecks(Class<?> clazz) {\n\t\tclassChecks.add(clazz);\n\t}\n\t\n\tpublic List<Class<?>> getClassChecks() {\n\t\treturn classChecks;\n\t}\n\t\n\tpublic void setClassChecks(List<Class<?>> classChecks) {\n\t\tthis.classChecks = classChecks;\n\t}\n\t\n\tpublic void addClassChecks(List<Class<?>> classChecks) {\n\t\tthis.classChecks.addAll(classChecks);\n\t}\n\t\n\tpublic void"}, {"ID": 1301, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addClassChecks(final Class target) { final List<Check> list = cache.get(target, () -> { final List<Check> newList = new ArrayList<>(); final ClassDescriptor cd = ClassIntrospector.get().lookup(target); final PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { collectPropertyAnnotationChecks(newList, propertyDescriptor); } return newList; }); addAll(list); } \nResponse:", "ground_truth": "Parses class annotations and adds all checks.\n@see #resolveFor(Class)", "predict": " public void addClassChecks(final Class target) { final List<Check> list = cache.get(target, () -> { final List<Check> newList = new ArrayList<>(); final ClassDescriptor cd = ClassIntrospector.get().lookup(target); final PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { collectPropertyAnnotationChecks(newList, propertyDescriptor); } return newList; }); addAll(list); } \n */\n\npublic class ClassChecks {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ClassChecks.class);\n\n    private static final String CLASS_CHECKS_PACKAGE = \"org.springframework.boot.autoconfigure.condition.scan.checks\";\n\n    private static final String CLASS_CHECKS_PACKAGE_PREFIX = CLASS_CHECKS_"}, {"ID": 1302, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectPropertyAnnotationChecks(final List<Check> annChecks, final PropertyDescriptor propertyDescriptor) { FieldDescriptor fd = propertyDescriptor.getFieldDescriptor(); if (fd != null) { Annotation[] annotations = fd.getField().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } MethodDescriptor md = propertyDescriptor.getReadMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } md = propertyDescriptor.getWriteMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } } \nResponse:", "ground_truth": "Process all annotations of provided properties.", "predict": "\n\n*/\n\npackage com.google.gwt.user.client.rpc.core.java.lang;\n\nimport com.google.gwt.user.client.rpc.SerializationException;\nimport com.google.gwt.user.client.rpc.SerializationStreamReader;\nimport com.google.gwt.user.client.rpc.SerializationStreamWriter;\nimport com.google.gwt.user.client.rpc.impl.ReflectionHelper;\n\n@SuppressWarnings(\"deprecation\")\npublic class PropertyDescriptor_FieldSerializer {\n  public static void deserialize(SerializationStreamReader streamReader, PropertyDescriptor instance) throws SerializationException {\n    String value = streamReader.readString();\n    instance.setField(value);\n  }\n  \n  public static PropertyDescriptor instantiate(SerializationStreamReader streamReader) throws SerializationException {\n    PropertyDescript"}, {"ID": 1303, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected void collectAnnotationChecks(final List<Check> annChecks, final Class targetType, final String targetName, final Annotation[] annotations) { for (Annotation annotation : annotations) { Constraint c = annotation.annotationType().getAnnotation(Constraint.class); Class<? extends ValidationConstraint> constraintClass; if (c == null) { // if constraint is not available, try lookup String constraintClassName = annotation.annotationType().getName() + \"Constraint\"; try { constraintClass = ClassLoaderUtil.loadClass(constraintClassName, this.getClass().getClassLoader()); } catch (ClassNotFoundException ingore) { continue; } } else { constraintClass = c.value(); } ValidationConstraint vc; try { vc = newConstraint(constraintClass, targetType); } catch (Exception ex) { throw new VtorException(\"Invalid constraint: \" + constraintClass.getClass().getName(), ex); } vc.configure(annotation); Check check = new Check(targetName, vc); copyDefaultCheckProperties(check, annotation); annChecks.add(check); } } \nResponse:", "ground_truth": "Collect annotations for some target.", "predict": "\n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.validation.Constraint;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport javax.validation.Payload;\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org"}, {"ID": 1304, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void copyDefaultCheckProperties(final Check destCheck, final Annotation annotation) { Integer severity = (Integer) ClassUtil.readAnnotationValue(annotation, ANN_SEVERITY); destCheck.setSeverity(severity.intValue()); String[] profiles = (String[]) ClassUtil.readAnnotationValue(annotation, ANN_PROFILES); destCheck.setProfiles(profiles); String message = (String) ClassUtil.readAnnotationValue(annotation, ANN_MESSAGE); destCheck.setMessage(message); } \nResponse:", "ground_truth": "Copies default properties from annotation to the check.", "predict": "\n\n*/\n\npublic class Check {\n\tprivate String id;\n\tprivate String name;\n\tprivate String description;\n\tprivate String severity;\n\tprivate String[] profiles;\n\tprivate String message;\n\t\n\tpublic Check() {\n\t\t\n\t}\n\t\n\tpublic Check(String id, String name, String description, String severity, String[] profiles, String message) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.description = description;\n\t\tthis.severity = severity;\n\t\tthis.profiles = profiles;\n\t\tthis.message = message;\n\t}\n\t\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t"}, {"ID": 1305, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String encodeUriComponent(final String source, final String encoding, final URIPart uriPart) { if (source == null) { return null; } byte[] bytes = encodeBytes(StringUtil.getBytes(source, encoding), uriPart); char[] chars = new char[bytes.length]; for (int i = 0; i < bytes.length; i++) { chars[i] = (char) bytes[i]; } return new String(chars); } \nResponse:", "ground_truth": "Encodes single URI component.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class EncodeUriComponent {\n\n    public static void main(String[] args) {\n        String source = \"http://www.baidu.com/\";\n        String encoding = \"utf-8\";\n        URIPart uriPart = URIPart.QUERY;\n        String result = encodeUriComponent(source, encoding, uriPart);\n        System.out.println(result);\n    }\n\n    public static String encodeUriComponent(String source, String encoding, URIPart uriPart) {\n        if (source == null) {\n            return null;\n        }\n        byte[] bytes = null;\n        try {\n            bytes = source.getBytes(encoding);\n        } catch (UnsupportedEncodingException e"}, {"ID": 1306, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encode(final String string, final String encoding) { return encodeUriComponent(string, encoding, URIPart.UNRESERVED); } \nResponse:", "ground_truth": "Encodes string using default RFCP rules.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1307, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeScheme(final String scheme, final String encoding) { return encodeUriComponent(scheme, encoding, URIPart.SCHEME); } \nResponse:", "ground_truth": "Encodes the given URI scheme with the given encoding.", "predict": " public static String decodeScheme(final String scheme, final String encoding) { return decodeUriComponent(scheme, encoding, URIPart.SCHEME); } \n\n*/\n\npublic class UriEncoder {\n\t\n\tpublic static String encodeUriComponent(final String scheme, final String encoding, final URIPart uriPart) {\n\t\t\n\t\tString result = null;\n\t\t\n\t\tif (scheme != null && encoding != null) {\n\t\t\t\n\t\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tsb.append(scheme);\n\t\t\tsb.append(\"://\");\n\t\t\tsb.append(uriPart.getValue());\n\t\t\t\n\t\t\tresult = sb.toString();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tpublic static String decodeUriComponent(final String scheme, final String encoding, final URIPart uriPart) {\n\t\t\n\t\tString result = null;\n\t\t\n\t\t"}, {"ID": 1308, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeHost(final String host, final String encoding) { return encodeUriComponent(host, encoding, URIPart.HOST); } \nResponse:", "ground_truth": "Encodes the given URI host with the given encoding.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1309, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodePort(final String port, final String encoding) { return encodeUriComponent(port, encoding, URIPart.PORT); } \nResponse:", "ground_truth": "Encodes the given URI port with the given encoding.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1310, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodePath(final String path, final String encoding) { return encodeUriComponent(path, encoding, URIPart.PATH); } \nResponse:", "ground_truth": "Encodes the given URI path with the given encoding.", "predict": " Response.ok().build();\n\n*/\n\npackage com.google.code.magja.model.product;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.google.code.magja.model.BaseMagentoModel;\n\n/**\n * @author andre\n * \n */\npublic class ProductAttribute extends BaseMagentoModel {\n\n  private static final long serialVersionUID = -8285555555555555555L;\n\n  private String name;\n\n  private String type;\n\n  private String value;\n\n  private List<ProductAttributeValue> values = new ArrayList<ProductAttributeValue>();\n\n  public ProductAttribute() {\n    super();\n  }\n\n  public ProductAttribute(Long id) {\n    super(id);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;"}, {"ID": 1311, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeQuery(final String query, final String encoding) { return encodeUriComponent(query, encoding, URIPart.QUERY); } \nResponse:", "ground_truth": "Encodes the given URI query with the given encoding.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1312, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeQueryParam(final String queryParam, final String encoding) { return encodeUriComponent(queryParam, encoding, URIPart.QUERY_PARAM); } \nResponse:", "ground_truth": "Encodes the given URI query parameter with the given encoding.", "predict": " Response.ok().entity(encodeQueryParam(queryParam, encoding)).build();\n\n*/\n\npublic class UriEncoder {\n    public static String encodeUriComponent(final String queryParam, final String encoding, final URIPart uriPart) {\n        String encodedQueryParam = null;\n        try {\n            encodedQueryParam = URLEncoder.encode(queryParam, encoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n        return encodedQueryParam;\n    }\n}\n"}, {"ID": 1313, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeFragment(final String fragment, final String encoding) { return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT); } \nResponse:", "ground_truth": "Encodes the given URI fragment with the given encoding.", "predict": " Response.ok().build();\n\n*/\n\npublic class UriEncoder {\n    public static String encodeFragment(final String fragment, final String encoding) {\n        return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT);\n    }\n\n    public static String encodePath(final String path, final String encoding) {\n        return encodeUriComponent(path, encoding, URIPart.PATH);\n    }\n\n    public static String encodeQuery(final String query, final String encoding) {\n        return encodeUriComponent(query, encoding, URIPart.QUERY);\n    }\n\n    public static String encodeFragment(final String fragment, final String encoding, final URIPart uriPart) {\n        return encodeUriComponent(fragment, encoding, uriPart);\n    }\n\n    public static String encodePath(final String path, final String encoding, final URIPart uriPart) {\n        return encodeUriComponent"}, {"ID": 1314, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected HashMap<String, PropertyDescriptor> inspectProperties() { boolean scanAccessible = classDescriptor.isScanAccessible(); Class type = classDescriptor.getType(); HashMap<String, PropertyDescriptor> map = new HashMap<>(); Method[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type); for (int iteration = 0; iteration < 2; iteration++) { // first find the getters, and then the setters! for (Method method : methods) { if (Modifier.isStatic(method.getModifiers())) { continue; // ignore static methods } boolean add = false; boolean issetter = false; String propertyName; if (iteration == 0) { propertyName = ClassUtil.getBeanPropertyGetterName(method); if (propertyName != null) { add = true; issetter = false; } } else { propertyName = ClassUtil.getBeanPropertySetterName(method); if (propertyName != null) { add = true; issetter = true; } } if (add) { MethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true); addProperty(map, propertyName, methodDescriptor, issetter); } } } if (classDescriptor.isIncludeFieldsAsProperties()) { FieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors(); String[] prefix = classDescriptor.getPropertyFieldPrefix(); for (FieldDescriptor fieldDescriptor : fieldDescriptors) { Field field = fieldDescriptor.getField(); if (Modifier.isStatic(field.getModifiers())) { continue; // ignore static fields } String name = field.getName(); if (prefix != null) { for (String p : prefix) { if (!name.startsWith(p)) { continue; } name = name.substring(p.length()); break; } } if (!map.containsKey(name)) { // add missing field as a potential property map.put(name, createPropertyDescriptor(name, fieldDescriptor)); } } } return map; } \nResponse:", "ground_truth": "Inspects all properties of target type.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\n\npublic class ClassDescriptor {\n\n\tprivate final Class<?> type;\n\tprivate final String name;\n\tprivate final String packageName;\n\tprivate final String simpleName;\n\tprivate final String fullName;\n\tprivate final"}, {"ID": 1315, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyDescriptor[] getAllPropertyDescriptors() { if (allProperties == null) { PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()]; int index = 0; for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) { allProperties[index] = propertyDescriptor; index++; } Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() { @Override public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) { return pd1.getName().compareTo(pd2.getName()); } }); this.allProperties = allProperties; } return allProperties; } \nResponse:", "ground_truth": "Returns all property descriptors.\nProperties are sorted by name.", "predict": " public PropertyDescriptor[] getAllPropertyDescriptors() { return allProperties; }\n\n*/\n\npublic class PropertyDescriptorTest {\n    public static void main(String[] args) {\n        PropertyDescriptorTest test = new PropertyDescriptorTest();\n        test.test();\n    }\n\n    public void test() {\n        PropertyDescriptor[] allProperties = new PropertyDescriptor[]{\n                new PropertyDescriptor(\"name\", String.class),\n                new PropertyDescriptor(\"age\", int.class),\n                new PropertyDescriptor(\"address\", String.class),\n                new PropertyDescriptor(\"address\", String.class, null, null),\n                new PropertyDescriptor(\"address\", String.class, null, null, null, null),\n                new PropertyDescriptor(\"address\", String.class, null, null, null, null, null),\n                new PropertyDescriptor(\"address\", String.class, null"}, {"ID": 1316, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Cookie[] cookies() { List<String> newCookies = headers(\"set-cookie\"); if (newCookies == null) { return new Cookie[0]; } List<Cookie> cookieList = new ArrayList<>(newCookies.size()); for (String cookieValue : newCookies) { try { Cookie cookie = new Cookie(cookieValue); cookieList.add(cookie); } catch (Exception ex) { // ignore } } return cookieList.toArray(new Cookie[0]); } \nResponse:", "ground_truth": "Returns list of valid cookies sent from server.\nIf no cookie found, returns an empty array. Invalid cookies are ignored.", "predict": " public Cookie[] cookies() { List<String> newCookies = headers(\"set-cookie\"); if (newCookies == null) { return new Cookie[0]; } List<Cookie> cookieList = new ArrayList<>(newCookies.size()); for (String cookieValue : newCookies) { try { Cookie cookie = new Cookie(cookieValue); cookieList.add(cookie); } catch (Exception ex) { // ignore } } return cookieList.toArray(new Cookie[0]); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client."}, {"ID": 1317, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse unzip() { String contentEncoding = contentEncoding(); if (contentEncoding != null && contentEncoding().equals(\"gzip\")) { if (body != null) { headerRemove(HEADER_CONTENT_ENCODING); try { ByteArrayInputStream in = new ByteArrayInputStream(body.getBytes(StringPool.ISO_8859_1)); GZIPInputStream gzipInputStream = new GZIPInputStream(in); ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamUtil.copy(gzipInputStream, out); body(out.toString(StringPool.ISO_8859_1)); } catch (IOException ioex) { throw new HttpException(ioex); } } } return this; } \nResponse:", "ground_truth": "Unzips GZip-ed body content, removes the content-encoding header\nand sets the new content-length value.", "predict": "\n\n*/\n\npublic class Response {\n    private String contentEncoding;\n    private String contentType;\n    private String contentTypeCharset;\n    private String contentTypeParams;\n    private String contentTypeVersion;\n    private String contentTypeVersionCharset;\n    private String contentTypeVersionParams;\n    private String contentTypeVersionVersion;\n    private String contentTypeVersionVersionCharset;\n    private String contentTypeVersionVersionParams;\n    private String contentTypeVersionVersionVersion;\n    private String contentTypeVersionVersionVersionCharset;\n    private String contentTypeVersionVersionVersionParams;\n    private String contentTypeVersionVersionVersionVersion;\n    private String contentTypeVersionVersionVersionVersionCharset;\n    private String contentTypeVersionVersionVersionVersionParams;\n    private String contentTypeVersionVersionVersionVersionVersionCharset;\n    private String contentTypeVersionVersionVersionVersionVersionParams;\n    private String contentTypeVersionVersionVersionVersion"}, {"ID": 1318, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse close() { HttpConnection httpConnection = httpRequest.httpConnection; if (httpConnection != null) { httpConnection.close(); httpRequest.httpConnection = null; } return this; } \nResponse:", "ground_truth": "Closes requests connection if it was open.\nShould be called when using keep-alive connections.\nOtherwise, connection will be already closed.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1319, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final Scope referenceScope) { Class<? extends Scope> refScopeType = referenceScope.getClass(); if (refScopeType == ProtoScope.class) { return true; } if (refScopeType == SingletonScope.class) { return true; } if (refScopeType == ThreadLocalScope.class) { return true; } return false; } \nResponse:", "ground_truth": "Defines allowed referenced scopes that can be injected into the\nthread-local scoped bean.", "predict": " Response.Builder builder = Response.newBuilder(); builder.setStatus(Response.Status.OK); return builder.build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.Descriptors.FieldDescriptor;\nimport com.google.protobuf.Descriptors.FieldDescriptor.JavaType;\nimport com.google.protobuf.Descriptors.FieldDescriptor.Type;\nimport com.google.protobuf.Descriptors.FieldDescriptor.Type.EnumType;\nimport com.google.protobuf.Descriptors.FieldDescriptor.Type.MessageType;\nimport com.google.protobuf.Descriptors.FieldDescriptor.Type.ScalarType;\nimport com.google.protobuf.Descriptors.FieldDescriptor"}, {"ID": 1320, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void printRoutes(final int width) { final ActionsManager actionsManager = webApp.madvocContainer().lookupComponent(ActionsManager.class); final List<ActionRuntime> actions = actionsManager.getAllActionRuntimes(); final Map<String, String> aliases = actionsManager.getAllAliases(); if (actions.isEmpty()) { return; } final Print print = new Print(); print.line(\"Routes\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionMethod = ar.getActionMethod(); print.out(Chalk256.chalk().yellow(), actionMethod == null ? \"*\" : actionMethod, 7); print.space(); final String signature = ClassUtil.getShortClassName( ProxettaUtil.resolveTargetClass(ar.getActionClass()), 2) + '#' + ar.getActionClassMethod().getName(); print.outLeftRightNewLine( Chalk256.chalk().green(), ar.getActionPath(), Chalk256.chalk().blue(), signature, width - 7 - 1 ); }); if (!aliases.isEmpty()) { print.line(\"Aliases\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionPath = ar.getActionPath(); for (final Map.Entry<String, String> entry : aliases.entrySet()) { if (entry.getValue().equals(actionPath)) { print.space(8); print.outLeftRightNewLine( Chalk256.chalk().green(), entry.getValue(), Chalk256.chalk().blue(), entry.getKey(), width - 8 ); } } }); } print.line(width); } \nResponse:", "ground_truth": "Prints routes to console.", "predict": "\n\nRoutes:\n\n* /actions/Action1#action1\n* /actions/Action2#action2\n\nAliases:\n\n/actions/Action1 -> /actions/Action2\n\n*/\n"}, {"ID": 1321, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] encrypt(final byte[] content) { FastByteBuffer fbb = new FastByteBuffer(); int length = content.length + 1; int blockCount = length / blockSizeInBytes; int remaining = length; int offset = 0; for (int i = 0; i < blockCount; i++) { if (remaining == blockSizeInBytes) { break; } byte[] encrypted = encryptBlock(content, offset); fbb.append(encrypted); offset += blockSizeInBytes; remaining -= blockSizeInBytes; } if (remaining != 0) { // process remaining bytes byte[] block = new byte[blockSizeInBytes]; System.arraycopy(content, offset, block, 0, remaining - 1); block[remaining - 1] = TERMINATOR; byte[] encrypted = encryptBlock(block, 0); fbb.append(encrypted); } return fbb.toArray(); } \nResponse:", "ground_truth": "Encrypts complete content, block by block.", "predict": " public byte[] encrypt(final byte[] content) { return encrypt(content, 0); } \n*/\n\npublic class Encrypt {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString plaintext = \"Hello World\";\n\t\t\n\t\tbyte[] key = new byte[16];\n\t\t\n\t\tfor (int i = 0; i < key.length; i++) {\n\t\t\tkey[i] = (byte) i;\n\t\t}\n\t\t\n\t\tbyte[] iv = new byte[16];\n\t\t\n\t\tfor (int i = 0; i < iv.length; i++) {\n\t\t\tiv[i] = (byte) i;\n\t\t}\n\t\t\n\t\tbyte[] ciphertext = encrypt(plaintext.getBytes(), key, iv);\n\t\t\n\t\tSystem.out.println(\"Ciphertext: \" + new String(ciphertext));\n\t\t\n\t\tbyte[] decrypted = decrypt(ciphertext, key, iv);\n\t\t"}, {"ID": 1322, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] decrypt(final byte[] encryptedContent) { FastByteBuffer fbb = new FastByteBuffer(); int length = encryptedContent.length; int blockCount = length / blockSizeInBytes; int offset = 0; for (int i = 0; i < blockCount - 1; i++) { byte[] decrypted = decryptBlock(encryptedContent, offset); fbb.append(decrypted); offset += blockSizeInBytes; } // process last block byte[] decrypted = decryptBlock(encryptedContent, offset); // find terminator int ndx = blockSizeInBytes - 1; while (ndx >= 0) { if (decrypted[ndx] == TERMINATOR) { break; } ndx--; } fbb.append(decrypted, 0, ndx); return fbb.toArray(); } \nResponse:", "ground_truth": "Decrypts the whole content, block by block.", "predict": "\n\n*/\n\npublic class AES {\n    public static final int KEY_SIZE = 128;\n    public static final int BLOCK_SIZE = 16;\n    public static final int TERMINATOR = 0x00;\n\n    public static byte[] encrypt(byte[] plaintext, byte[] key) {\n        byte[] ciphertext = new byte[plaintext.length];\n        byte[] iv = new byte[BLOCK_SIZE];\n        for (int i = 0; i < iv.length; i++) {\n            iv[i] = (byte) i;\n        }\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(iv);\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);\n            c"}, {"ID": 1323, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object map2bean(final Map map, Class targetType) { Object target = null; // create targets type String className = (String) map.get(classMetadataName); if (className == null) { if (targetType == null) { // nothing to do, no information about target type found target = map; } } else { checkClassName(jsonParser.classnameWhitelist, className); try { targetType = ClassLoaderUtil.loadClass(className); } catch (ClassNotFoundException cnfex) { throw new JsonException(cnfex); } } if (target == null) { target = jsonParser.newObjectInstance(targetType); } ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); boolean targetIsMap = target instanceof Map; for (Object key : map.keySet()) { String keyName = key.toString(); if (classMetadataName != null) { if (keyName.equals(classMetadataName)) { continue; } } PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared); if (!targetIsMap && pd == null) { // target property does not exist, continue continue; } // value is one of JSON basic types, like Number, Map, List... Object value = map.get(key); Class propertyType = pd == null ? null : pd.getType(); Class componentType = pd == null ? null : pd.resolveComponentType(true); if (value != null) { if (value instanceof List) { if (componentType != null && componentType != String.class) { value = generifyList((List) value, componentType); } } else if (value instanceof Map) { // if the value we want to inject is a Map... if (!ClassUtil.isTypeOf(propertyType, Map.class)) { // ... and if target is NOT a map value = map2bean((Map) value, propertyType); } else { // target is also a Map, but we might need to generify it Class keyType = pd == null ? null : pd.resolveKeyType(true); if (keyType != String.class || componentType != String.class) { // generify value = generifyMap((Map) value, keyType, componentType); } } } } if (targetIsMap) { ((Map)target).put(keyName, value); } else { try { setValue(target, pd, value); } catch (Exception ignore) { ignore.printStackTrace(); } } } return target; } \nResponse:", "ground_truth": "Converts map to target type.", "predict": "\n\npublic Object map2bean(final Map map, Class targetType) {\n\tObject target = null;\n\tString className = (String) map.get(classMetadataName);\n\tif (className == null) {\n\t\tif (targetType == null) {\n\t\t\ttarget = map;\n\t\t}\n\t} else {\n\t\tcheckClassName(jsonParser.classnameWhitelist, className);\n\t\ttry {\n\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\tthrow new JsonException(cnfex);\n\t\t}\n\t\tif (target == null) {\n\t\t\ttarget = jsonParser.newObjectInstance(targetType);\n\t\t}\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n\t\tboolean targetIsMap = target instanceof Map;\n\t\tfor (Object key : map.key"}, {"ID": 1324, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object generifyList(final List list, final Class componentType) { for (int i = 0; i < list.size(); i++) { Object element = list.get(i); if (element != null) { if (element instanceof Map) { Object bean = map2bean((Map) element, componentType); list.set(i, bean); } else { Object value = convert(element, componentType); list.set(i, value); } } } return list; } \nResponse:", "ground_truth": "Converts type of all list elements to match the component type.", "predict": "\n\n*/\n\npublic class GenerifyList {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<String>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add(\"m\");\n        list.add(\"n\");\n        list.add(\"o\");\n        list.add(\"p\");\n        list.add(\"q\");\n        list.add(\"r\");\n        list.add(\"s\");\n        list.add(\"t\");\n        list.add(\"u\");\n        list.add(\"v\");\n        "}, {"ID": 1325, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException { Class propertyType; Setter setter = pd.getSetter(true); if (setter != null) { if (value != null) { propertyType = setter.getSetterRawType(); value = jsonParser.convertType(value, propertyType); } setter.invokeSetter(target, value); } } \nResponse:", "ground_truth": "Sets the property value.", "predict": " Response is generated by the following java Code. Code: public Response getResponse(final Object target, final PropertyDescriptor pd, final Object value) throws InvocationTargetException, IllegalAccessException { Class propertyType; Getter getter = pd.getGetter(true); if (getter != null) { if (value != null) { propertyType = getter.getGetterRawType(); value = jsonParser.convertType(value, propertyType); } return getter.invokeGetter(target, value); } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.faster"}, {"ID": 1326, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) { if (keyType == String.class) { // only value type is changed, we can make value replacements for (Map.Entry<Object, Object> entry : map.entrySet()) { Object value = entry.getValue(); Object newValue = convert(value, valueType); if (value != newValue) { entry.setValue(newValue); } } return (Map<K, V>) map; } // key is changed too, we need a new map Map<K, V> newMap = new HashMap<>(map.size()); for (Map.Entry<Object, Object> entry : map.entrySet()) { Object key = entry.getKey(); Object newKey = convert(key, keyType); Object value = entry.getValue(); Object newValue = convert(value, valueType); newMap.put((K)newKey, (V)newValue); } return newMap; } \nResponse:", "ground_truth": "Change map elements to match key and value types.", "predict": "\n\npublic class GenerifyMap {\n    public static void main(String[] args) {\n        Map<String, String> map = new HashMap<>();\n        map.put(\"a\", \"1\");\n        map.put(\"b\", \"2\");\n        map.put(\"c\", \"3\");\n        map.put(\"d\", \"4\");\n        map.put(\"e\", \"5\");\n        map.put(\"f\", \"6\");\n        map.put(\"g\", \"7\");\n        map.put(\"h\", \"8\");\n        map.put(\"i\", \"9\");\n        map.put(\"j\", \"10\");\n        map.put(\"k\", \"11\");\n        map.put(\"l\", \"12\");\n        map.put(\"m\", \"13\");\n        map.put(\"n\", \"14\");\n        map.put(\"o\", \"15\");\n        map.put(\"p\", \"16\");\n        map."}, {"ID": 1327, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int compareTo(final Object o) { DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o; if (this.isId != that.isId) { return this.isId ? -1 : 1; // IDs should be the first in the array } return this.columnName.compareTo(that.columnName); } \nResponse:", "ground_truth": "Compares two column descriptors. Identity columns should be the first on the list.\nEach group then will be sorted by column name.", "predict": "\n\n*/\n\npublic class DbEntityColumnDescriptor {\n\tprivate String columnName;\n\tprivate boolean isId;\n\t\n\tpublic DbEntityColumnDescriptor(String columnName, boolean isId) {\n\t\tthis.columnName = columnName;\n\t\tthis.isId = isId;\n\t}\n\t\n\tpublic String getColumnName() {\n\t\treturn columnName;\n\t}\n\t\n\tpublic boolean isId() {\n\t\treturn isId;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"DbEntityColumnDescriptor [columnName=\" + columnName + \", isId=\" + isId + \"]\";\n\t}\n}\n"}, {"ID": 1328, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResponse:", "ground_truth": "Adds default header to all requests.", "predict": " public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResp"}, {"ID": 1329, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse sendRequest(HttpRequest httpRequest) { elapsedTime = System.currentTimeMillis(); // send request httpRequest.followRedirects(false); while (true) { this.httpRequest = httpRequest; HttpResponse previousResponse = this.httpResponse; this.httpResponse = null; addDefaultHeaders(httpRequest); addCookies(httpRequest); // send request if (catchTransportExceptions) { try { this.httpResponse = _sendRequest(httpRequest, previousResponse); } catch (HttpException httpException) { httpResponse = new HttpResponse(); httpResponse.assignHttpRequest(httpRequest); httpResponse.statusCode(503); httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException)); } } else { this.httpResponse =_sendRequest(httpRequest, previousResponse); } readCookies(httpResponse); int statusCode = httpResponse.statusCode(); // 301: moved permanently if (statusCode == 301) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 302: redirect, 303: see other if (statusCode == 302 || statusCode == 303) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 307: temporary redirect, 308: permanent redirect if (statusCode == 307 || statusCode == 308) { String newPath = httpResponse.location(); if (newPath == null) { break; } String originalMethod = httpRequest.method(); httpRequest = new HttpRequest() .method(originalMethod) .set(newPath); continue; } break; } elapsedTime = System.currentTimeMillis() - elapsedTime; return this.httpResponse; } \nResponse:", "ground_truth": "Sends new request as a browser. Before sending,\nall browser cookies are added to the request.\nAfter sending, the cookies are read from the response.\nMoreover, status codes 301 and 302 are automatically\nhandled. Returns very last response.", "predict": " Generate the method-level comment for the following java Code. Code: public HttpResponse sendRequest(HttpRequest httpRequest) { elapsedTime = System.currentTimeMillis(); // send request httpRequest.followRedirects(false); while (true) { this.httpRequest = httpRequest; HttpResponse previousResponse = this.httpResponse; this.httpResponse = null; addDefaultHeaders(httpRequest); addCookies(httpRequest); // send request if (catchTransportExceptions) { try { this.httpResponse = _sendRequest(httpRequest, previousResponse); } catch (HttpException httpException) { httpResponse = new HttpResponse(); httpResponse.assignHttpRequest(httpRequest); httpResponse.statusCode(503); httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException)); } } else { this.httpResponse =_sendRequest(httpRequest, previousResponse); } readCookies(httpResponse); int statusCode = httpResponse"}, {"ID": 1330, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) { if (!keepAlive) { httpRequest.open(httpConnectionProvider); } else { // keeping alive if (previouseResponse == null) { httpRequest.open(httpConnectionProvider).connectionKeepAlive(true); } else { httpRequest.keepAlive(previouseResponse, true); } } return httpRequest.send(); } \nResponse:", "ground_truth": "Opens connection and sends a response.", "predict": " public HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) { if (!keepAlive) { httpRequest.open(httpConnectionProvider); } else { // keeping alive if (previouseResponse == null) { httpRequest.open(httpConnectionProvider).connectionKeepAlive(true); } else { httpRequest.keepAlive(previouseResponse, true); } } return httpRequest.send(); } \n\n// End of user code\n\n}\n"}, {"ID": 1331, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addDefaultHeaders(final HttpRequest httpRequest) { for (Map.Entry<String, String> entry : defaultHeaders.entries()) { String name = entry.getKey(); if (!httpRequest.headers.contains(name)) { httpRequest.headers.add(name, entry.getValue()); } } } \nResponse:", "ground_truth": "Add default headers to the request. If request already has a header set,\ndefault header will be ignored.", "predict": " Generate the method-level comment for the following java Code. Code: protected void addDefaultHeaders(final HttpRequest httpRequest) { for (Map.Entry<String, String> entry : defaultHeaders.entries()) { String name = entry.getKey(); if (!httpRequest.headers.contains(name)) { httpRequest.headers.add(name, entry.getValue()); } } } \n */\n\npublic class DefaultHeaders {\n    private static final Map<String, String> defaultHeaders = new HashMap<String, String>();\n    static {\n        defaultHeaders.put(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n        defaultHeaders.put(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.3\");\n        defaultHeaders.put(\""}, {"ID": 1332, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void readCookies(final HttpResponse httpResponse) { Cookie[] newCookies = httpResponse.cookies(); for (Cookie cookie : newCookies) { cookies.add(cookie.getName(), cookie); } } \nResponse:", "ground_truth": "Reads cookies from response and adds to cookies list.", "predict": " Response = new Response(); cookies = new ArrayList<Cookie>(); \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String[] cookies = new String[]{\"a=b\", \"c=d\"};\n        String[] cookies2 = new String[]{\"e=f\", \"g=h\"};\n        \n        List<Cookie> cookiesList = new ArrayList<Cookie>();\n        cookiesList.add(new Cookie(\"a\", \"b\"));\n        cookiesList.add(new Cookie(\"c\", \"d\"));\n        \n        List<Cookie> cookiesList2 = new ArrayList<Cookie>();\n        cookiesList2.add(new Cookie(\"e\", \"f\"));\n        cookiesList2.add(new Cookie(\"g\", \"h\"));\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"}, {"ID": 1333, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addCookies(final HttpRequest httpRequest) { // prepare all cookies List<Cookie> cookiesList = new ArrayList<>(); if (!cookies.isEmpty()) { for (Map.Entry<String, Cookie> cookieEntry : cookies) { cookiesList.add(cookieEntry.getValue()); } httpRequest.cookies(cookiesList.toArray(new Cookie[0])); } } \nResponse:", "ground_truth": "Add cookies to the request.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Cookie {\n    private String name;\n    private String value;\n    private String domain;\n    private String path;\n    private int maxAge;\n    private boolean secure;\n    private boolean httpOnly;\n\n    public Cookie(String name, String value, String domain, String path, int maxAge, boolean secure, boolean httpOnly) {\n        this.name = name;\n        this.value = value;\n        this.domain = domain;\n        this.path = path;\n        this.maxAge = maxAge;\n        this.secure = secure;\n        this.httpOnly = httpOnly;\n    }\n\n    public Cookie(String name, String value, String domain, String path, int maxAge) {\n        this(name, value, domain, path, maxAge, false, false);\n    }\n\n    public Cookie(String name, String"}, {"ID": 1334, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String sendMail(final Email email) { try { final MimeMessage msg = createMessage(email); getService().sendMessage(msg, msg.getAllRecipients()); return msg.getMessageID(); } catch (final MessagingException msgexc) { throw new MailException(\"Failed to send email: \" + email, msgexc); } } \nResponse:", "ground_truth": "Prepares message and sends it. Returns Message ID of sent email.\n\n@param email {@link Email} to send.\n@return String representing message ID.", "predict": "\n\n*/\n\nimport java.util.Properties;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class SendMail {\n    public static void main(String[] args) {\n        Properties props = new Properties();\n        props.put(\"mail.smtp.host\", \"smtp.gmail.com\");\n        props.put(\"mail.smtp.socketFactory.port\", \"465\");\n        props.put(\"mail.smtp.socketFactory.class\", \"jav"}, {"ID": 1335, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setSubject(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { if (emailWithData.subjectEncoding() != null) { msgToSet.setSubject(emailWithData.subject(), emailWithData.subjectEncoding()); } else { msgToSet.setSubject(emailWithData.subject()); } } \nResponse:", "ground_truth": "Sets subject in msgToSet from subject in emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport javax.activation.DataHandler;\nimport javax.activation.FileDataSource;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class Email {\n\t\n\tprivate String subject;\n\tprivate String subjectEncoding;\n\tprivate String from;\n\tprivate String to;\n\tprivate String cc;\n\tprivate String bcc;\n\tprivate String body;\n\tprivate String bodyEncoding;\n\tprivate String attachment;\n\tprivate String attachmentEncoding;\n\tprivate String attachmentName;\n\tprivate String attachmentContentType;\n\tprivate String attachmentContentId;\n\tprivate"}, {"ID": 1336, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setSentDate(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { Date date = emailWithData.sentDate(); if (date == null) { date = new Date(); } msgToSet.setSentDate(date); } \nResponse:", "ground_truth": "Sets sent date in msgToSet with sent date from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.util.Properties;\nimport javax.mail.Address;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class Email {\n    private String to;\n    private String from;\n    private String cc;\n    private String bcc;\n    private String subject;\n    private String body;\n    private String htmlBody;\n    private Date sentDate;\n    private String attachment;\n    private String attachmentName;\n    "}, {"ID": 1337, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setHeaders(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final Map<String, String> headers = emailWithData.headers(); if (headers != null) { for (final Map.Entry<String, String> entry : headers.entrySet()) { msgToSet.setHeader(entry.getKey(), entry.getValue()); } } } \nResponse:", "ground_truth": "Sets headers in msgToSet with headers from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Response with status code: 200 and content: \"Email sent successfully.\"\n*/\n\nimport java.util.Map;\nimport java.util.Properties;\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeMessage;\n\npublic class Email {\n    private final String from;\n    private final String to;\n    private final String cc;\n    private final String bcc;\n    private final String subject;\n    private final String text;\n    private final Map<String, String> headers;\n\n    public Email(String from, String to, String cc, String bcc, String subject, String text, Map<String, String> headers) {\n        this.from = from;\n        this.to = to;\n        this.cc = cc;\n        this.bcc = bcc;\n        this.subject = subject;\n        this.text = text;\n        this.headers = headers;\n    }\n\n"}, {"ID": 1338, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { msgToSet.setFrom(emailWithData.from().toInternetAddress()); msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo())); setRecipients(emailWithData, msgToSet); } \nResponse:", "ground_truth": "Sets FROM, REPLY-TO and recipients.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Strings;\n\nimport de.dktk.dd.rpb.core.domain.Identifiable;\nimport de.dktk.dd.rpb.core.domain.IdentifiableHashBuilder;\nimport de.dktk.dd.rpb.core.domain."}, {"ID": 1339, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setRecipients(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { // TO final InternetAddress[] to = EmailAddress.convert(emailWithData.to()); if (to.length > 0) { msgToSet.setRecipients(RecipientType.TO, to); } // CC final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc()); if (cc.length > 0) { msgToSet.setRecipients(RecipientType.CC, cc); } // BCC final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc()); if (bcc.length > 0) { msgToSet.setRecipients(RecipientType.BCC, bcc); } } \nResponse:", "ground_truth": "Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\npublic class Email {\n\t\n\tprivate String from;\n\tprivate String to;\n\tprivate String cc;\n\tprivate String bcc;\n\tprivate String subject;\n\tprivate String content;\n\tprivate List<InternetAddress> toList;\n\tprivate List<InternetAddress> ccList;\n\tprivate List<InternetAddress> bccList;\n\t\n\tpublic Email() {\n\t\ttoList = new ArrayList<InternetAddress>();\n\t\tccList = new ArrayList<InternetAddress>();\n\t\tbccList = new ArrayList<InternetAddress>();\n\t}\n\t\n\tpublic Email(String from, String to, String cc, String bcc, String subject, String content"}, {"ID": 1340, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addBodyData(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final List<EmailMessage> messages = emailWithData.messages(); final int totalMessages = messages.size(); // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List final List<EmailAttachment<? extends DataSource>> attachments = new ArrayList<>(emailWithData.attachments()); if (attachments.isEmpty() && totalMessages == 1) { // special case: no attachments and just one content setContent(messages.get(0), msgToSet); } else { final MimeMultipart multipart = new MimeMultipart(); final MimeMultipart msgMultipart = new MimeMultipart(ALTERNATIVE); multipart.addBodyPart(getBaseBodyPart(msgMultipart)); for (final EmailMessage emailMessage : messages) { msgMultipart.addBodyPart(getBodyPart(emailMessage, attachments)); } addAnyAttachments(attachments, multipart); msgToSet.setContent(multipart); } } \nResponse:", "ground_truth": "Adds message data and attachments.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\nimport javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.activation.FileDataSource;\nimport javax.mail.BodyPart;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport javax.mail.internet.MimePart;\nimport javax.mail.internet.MimePartDataSource;\nimport javax.mail.internet.MimeUtility;\n\npublic class Email {\n\t"}, {"ID": 1341, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setContent(final EmailMessage emailWithData, final Part partToSet) throws MessagingException { partToSet.setContent(emailWithData.getContent(), emailWithData.getMimeType() + CHARSET + emailWithData.getEncoding()); } \nResponse:", "ground_truth": "Sets emailWithData content into msgToSet.\n\n@param emailWithData {@link EmailMessage} with data.\n@param partToSet     {@link Part} to set data into.\n@throws MessagingException if there is a failure.", "predict": "\n\n*/\n\npublic class EmailMessage {\n\tprivate String subject;\n\tprivate String content;\n\tprivate String mimeType;\n\tprivate String encoding;\n\t\n\tpublic EmailMessage(String subject, String content, String mimeType, String encoding) {\n\t\tthis.subject = subject;\n\t\tthis.content = content;\n\t\tthis.mimeType = mimeType;\n\t\tthis.encoding = encoding;\n\t}\n\t\n\tpublic String getSubject() {\n\t\treturn subject;\n\t}\n\t\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\t\n\tpublic String getMimeType() {\n\t\treturn mimeType;\n\t}\n\t\n\tpublic String getEncoding() {\n\t\treturn encoding;\n\t}\n}\n"}, {"ID": 1342, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MimeBodyPart createAttachmentBodyPart(final EmailAttachment<? extends DataSource> attachment) throws MessagingException { final MimeBodyPart part = new MimeBodyPart(); final String attachmentName = attachment.getEncodedName(); if (attachmentName != null) { part.setFileName(attachmentName); } part.setDataHandler(new DataHandler(attachment.getDataSource())); if (attachment.getContentId() != null) { part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV); } if (attachment.isInline()) { part.setDisposition(INLINE); } return part; } \nResponse:", "ground_truth": "Creates attachment body part. Handles regular and inline attachments.\n\n@param attachment Body part {@link EmailAttachment}.\n@return {@link MimeBodyPart} which represents body part attachment.\n@throws MessagingException if there is a failure.", "predict": " ResponseEntity<byte[]> sendEmail(final Email email) { final String emailId = email.getEmailId(); final String to = email.getTo(); final String from = email.getFrom(); final String cc = email.getCc(); final String bcc = email.getBcc(); final String subject = email.getSubject(); final String body = email.getBody(); final String htmlBody = email.getHtmlBody(); final String htmlTemplate = email.getHtmlTemplate(); final String template = email.getTemplate(); final String templateName = email.getTemplateName(); final String templateType = email.getTemplateType(); final String templateContext = email.getTemplateContext(); final String templateContextName = email.getTemplateContextName(); final String templateContextType = email.getTemplateContextType(); final String templateContextValue = email.getTemplateContextValue(); final String templateContextValueName = email.getTemplateContextValueName(); final String templateContextValueType = email.getTemplateContextValueType"}, {"ID": 1343, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String getContentType(final String dataHeader) { String token = \"Content-Type:\"; int start = dataHeader.indexOf(token); if (start == -1) { return StringPool.EMPTY; } start += token.length(); return dataHeader.substring(start).trim(); } \nResponse:", "ground_truth": "Strips content type information from requests data header.\n@param dataHeader data header string\n@return content type or an empty string if no content type defined", "predict": "\n\n*/\n\npublic class ContentType {\n\tpublic static String getContentType(String dataHeader) {\n\t\tString token = \"Content-Type:\";\n\t\tint start = dataHeader.indexOf(token);\n\t\tif (start == -1) {\n\t\t\treturn StringPool.EMPTY;\n\t\t}\n\t\tstart += token.length();\n\t\treturn dataHeader.substring(start).trim();\n\t}\n}\n"}, {"ID": 1344, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void saveResultSet(final ResultSet rs) { if (resultSets == null) { resultSets = new HashSet<>(); } resultSets.add(rs); } \nResponse:", "ground_truth": "Stores result set.", "predict": "\n\n*/\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Set;\n\npublic class ResultSetTest {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            connection = ConnectionHelper.getConnection();\n            statement = connection.createStatement();\n            resultSet = statement.executeQuery(\"SELECT * FROM Employees\");\n            while (resultSet.next()) {\n                System.out.println(resultSet.getString(\"name\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            ConnectionHelper.close(connection, statement, resultSet);\n        }\n    }\n}\n"}, {"ID": 1345, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q closeAllResultSets() { final SQLException sex = closeQueryResultSets(); if (sex != null) { throw new DbSqlException(\"Close associated ResultSets error\", sex); } return _this(); } \nResponse:", "ground_truth": "Closes all result sets created by this query. Query remains active.", "predict": " Response is generated by the method closeAllResultSets().\n*/\n\npublic class DbSqlException extends DbException {\n    private static final long serialVersionUID = -8283798427515371809L;\n\n    public DbSqlException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public DbSqlException(String message) {\n        super(message);\n    }\n\n    public DbSqlException(Throwable cause) {\n        super(cause);\n    }\n\n}\n"}, {"ID": 1346, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SQLException closeQuery() { SQLException sqlException = closeQueryResultSets(); if (statement != null) { try { statement.close(); } catch (SQLException sex) { if (sqlException == null) { sqlException = sex; } else { sqlException.setNextException(sex); } } statement = null; } query = null; queryState = CLOSED; return sqlException; } \nResponse:", "ground_truth": "Closes all assigned result sets and then closes the query. Query becomes closed.", "predict": "\n\n*/\n\npublic class Query {\n\tprivate String query;\n\tprivate Statement statement;\n\tprivate int queryState;\n\tprivate SQLException sqlException;\n\t\n\tpublic Query(String query) {\n\t\tthis.query = query;\n\t\tthis.queryState = OPEN;\n\t}\n\t\n\tpublic void close() {\n\t\tif (queryState == OPEN) {\n\t\t\ttry {\n\t\t\t\tstatement.close();\n\t\t\t} catch (SQLException sex) {\n\t\t\t\tif (sqlException == null) {\n\t\t\t\t\tsqlException = sex;\n\t\t\t\t} else {\n\t\t\t\t\tsqlException.setNextException(sex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatement = null;\n\t\t\tqueryState = CLOSED;\n\t\t}\n\t}\n\t\n\tpublic void execute() {\n\t\tif (queryState == OPEN) {\n\t\t\ttry {\n\t\t\t\tstatement.execute(query);\n\t\t\t} catch (SQLException sex) {\n\t\t\t\t"}, {"ID": 1347, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings({\"ClassReferencesSubclass\"}) public void close() { final SQLException sqlException = closeQuery(); connection = null; if (this.session != null) { this.session.detachQuery(this); } if (sqlException != null) { throw new DbSqlException(\"Close query error\", sqlException); } } \nResponse:", "ground_truth": "Closes the query and all created results sets and detaches itself from the session.", "predict": " Response = new Response(this.session, this.query, this.query.getQueryString(), this.query.getQueryParameters(), this.query.getQueryResult(), this.query.getQueryResult().getResultSet(), this.query.getQueryResult().getResultSet().getResultSetMetaData(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData().getColumnCount(), this.query.getQueryResult().getResultSet().getResultSetMetaData"}, {"ID": 1348, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setFetchSize(final int rows) { checkNotClosed(); this.fetchSize = rows; if (statement != null) { try { statement.setFetchSize(fetchSize); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex); } } return _this(); } \nResponse:", "ground_truth": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when\nmore rows are needed. The number of rows specified affects only result sets created using this statement.\nIf the value specified is zero, then the hint is ignored. The default value is zero.\n@see Statement#setFetchSize(int)", "predict": " public Q setFetchSize(final int rows) { checkNotClosed(); this.fetchSize = rows; if (statement != null) { try { statement.setFetchSize(fetchSize); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex); } } return _this(); } \nResp public Q setMaxRows(final int maxRows) { checkNotClosed(); this.maxRows = maxRows; if (statement != null) { try { statement.setMaxRows(maxRows); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex); } } return _this(); } \nResp public Q setMaxFieldSize(final int maxFieldSize) { checkNotClosed(); this.maxFieldSize = maxField"}, {"ID": 1349, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setMaxRows(final int maxRows) { checkNotClosed(); this.maxRows = maxRows; if (statement != null) { try { statement.setMaxRows(maxRows); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex); } } return _this(); } \nResponse:", "ground_truth": "Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.\nIf the limit is exceeded, the excess rows are silently dropped. Zero means there is no limit.\n@see Statement#setMaxRows(int)", "predict": "\n\n*/\n\npublic class DbSqlException extends DbException {\n    private static final long serialVersionUID = -8283798427515371809L;\n\n    public DbSqlException(final DbSqlException e) {\n        super(e);\n    }\n\n    public DbSqlException(final DbException e) {\n        super(e);\n    }\n\n    public DbSqlException(final String message) {\n        super(message);\n    }\n\n    public DbSqlException(final String message, final Throwable cause) {\n        super(message, cause);\n    }\n\n    public DbSqlException(final Throwable cause) {\n        super(cause);\n    }\n}\n"}, {"ID": 1350, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int executeUpdate(final boolean closeQuery) { start = System.currentTimeMillis(); init(); final int result; if (log.isDebugEnabled()) { log.debug(\"Executing update: \" + getQueryString()); } try { if (preparedStatement == null) { if (generatedColumns != null) { if (generatedColumns.length == 0) { result = statement.executeUpdate(query.sql, Statement.RETURN_GENERATED_KEYS); } else { result = statement.executeUpdate(query.sql, generatedColumns); } } else { result = statement.executeUpdate(query.sql); } } else { result = preparedStatement.executeUpdate(); } } catch (SQLException sex) { throw new DbSqlException(this, \"Query execution failed\", sex); } if (closeQuery) { close(); } elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return result; } \nResponse:", "ground_truth": "Executes UPDATE, INSERT or DELETE queries and optionally closes the query.\n@see Statement#executeUpdate(String)", "predict": "\n\n*/\n\npackage com.j256.ormlite.stmt.query;\n\nimport com.j256.ormlite.db.DatabaseType;\nimport com.j256.ormlite.field.FieldType;\nimport com.j256.ormlite.stmt.ArgumentHolder;\nimport com.j256.ormlite.stmt.Where;\nimport com.j256.ormlite.support.DatabaseResults;\n\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * Created by ganymed on 03/11/14.\n */\npublic class Update<T, ID> extends Where<T, ID> {\n\n  public Update(DatabaseType databaseType, FieldType idFieldType, String tableName) {\n    super(databaseType, idFieldType, tableName);\n  }\n\n  public Update(DatabaseType databaseType, FieldType idFieldType, String tableName, String whereCl"}, {"ID": 1351, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected long executeCount(final boolean close) { start = System.currentTimeMillis(); init(); ResultSet rs = null; if (log.isDebugEnabled()) { log.debug(\"Executing prepared count: \" + getQueryString()); } try { if (preparedStatement == null) { rs = statement.executeQuery(query.sql); } else { rs = preparedStatement.executeQuery(); } final long firstLong = DbUtil.getFirstLong(rs); elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return firstLong; } catch (SQLException sex) { throw new DbSqlException(this, \"Count query failed\", sex); } finally { DbUtil.close(rs); if (close) { close(); } } } \nResponse:", "ground_truth": "Executes count queries and optionally closes query afterwards.", "predict": "\n\npublic long executeCount(final boolean close) { start = System.currentTimeMillis(); init(); ResultSet rs = null; if (log.isDebugEnabled()) { log.debug(\"Executing prepared count: \" + getQueryString()); } try { if (preparedStatement == null) { rs = statement.executeQuery(query.sql); } else { rs = preparedStatement.executeQuery(); } final long firstLong = DbUtil.getFirstLong(rs); elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return firstLong; } catch (SQLException sex) { throw new DbSqlException(this, \"Count query failed\", sex); } finally { DbUtil.close(rs); if (close) { close(); } } } \n\n*/\n"}, {"ID": 1352, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResultSet getGeneratedColumns() { checkInitialized(); if (generatedColumns == null) { throw new DbSqlException(this, \"No column is specified as auto-generated\"); } final ResultSet rs; try { rs = statement.getGeneratedKeys(); } catch (SQLException sex) { throw new DbSqlException(this, \"No generated keys\", sex); } saveResultSet(rs); totalOpenResultSetCount++; return rs; } \nResponse:", "ground_truth": "Returns generated columns.", "predict": "\n\n*/\n\npublic class DbSqlException extends Exception {\n    private static final long serialVersionUID = 1L;\n    private final String sql;\n    private final SQLException sqlException;\n\n    public DbSqlException(String sql, SQLException sqlException) {\n        super(sql + \": \" + sqlException.getMessage());\n        this.sql = sql;\n        this.sqlException = sqlException;\n    }\n\n    public String getSql() {\n        return sql;\n    }\n\n    public SQLException getSqlException() {\n        return sqlException;\n    }\n}\n"}, {"ID": 1353, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getQueryString() { if (debug) { if ((callableStatement != null)) { if (preparedStatement instanceof LoggableCallableStatement) { return ((LoggableCallableStatement) callableStatement).getQueryString(); } } if (preparedStatement != null) { if (preparedStatement instanceof LoggablePreparedStatement) { return ((LoggablePreparedStatement) preparedStatement).getQueryString(); } } } if (query != null) { return query.sql; } return sqlString; } \nResponse:", "ground_truth": "Returns query SQL string. For prepared statements, returned sql string with quick-and-dirty replaced values.", "predict": "\n\n*/\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\n\npublic class Query {\n\tprivate static final Logger logger = Logger.getLogger(Query.class);\n\tprivate String sqlString;\n\tprivate String queryString;\n\tprivate String queryStringWithParameters;\n\tprivate String queryStringWithParametersAndValues;\n\tprivate String queryStringWithParametersAndValuesAndValues;\n\tprivate String queryStringWithParametersAndValuesAndValuesAndValues;\n\t"}, {"ID": 1354, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> T proxyOf(final T target, final Class<? extends Aspect> aspectClass) { final Aspect aspect; try { aspect = ClassUtil.newInstance(aspectClass, target); } catch (Exception e) { throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e); } return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces()); } \nResponse:", "ground_truth": "Creates a proxy of given target and the aspect.", "predict": "\n\n*/\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyGenerator {\n    public static void main(String[] args) {\n        // Generate the proxy class\n        Class proxyClass = ProxyGenerator.generateProxyClass(args[0]);\n\n        // Generate the proxy instance\n        Object proxy = ProxyGenerator.generateProxyInstance(proxyClass, args[1]);\n\n        // Invoke the proxy instance\n        System.out.println(\"Invoking the proxy instance...\");\n        System.out.println(proxy.toString());\n    }\n\n    public static Class generateProxyClass(String className) {\n        // Generate the proxy class\n        Class proxyClass = null;\n        try {\n            proxyClass = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStack"}, {"ID": 1355, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Collection<T> collectionOf(final Iterator<? extends T> iterator) { final List<T> list = new ArrayList<>(); while (iterator.hasNext()) { list.add(iterator.next()); } return list; } \nResponse:", "ground_truth": "Returns a collection containing all elements of the iterator.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1356, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Stream<T> streamOf(final Iterator<T> iterator) { return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false); } \nResponse:", "ground_truth": "Converts iterator to a stream.", "predict": "\n\npublic static <T> Stream<T> streamOf(final Iterator<T> iterator) { return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\npublic class StreamOf {\n\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add(\"m\");\n        "}, {"ID": 1357, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int compare(final T o1, final T o2) { for (Comparator<T> comparator : comparators) { int result = comparator.compare(o1, o2); if (result != 0) { return result; } } return 0; } \nResponse:", "ground_truth": "Compares two objects starting with first comparator; if they are equals\nproceeds to the next comparator and so on.", "predict": " @Override public int compare(final T o1, final T o2) { for (Comparator<T> comparator : comparators) { int result = comparator.compare(o1, o2); if (result != 0) { return result; } } return 0; } \n */\n\npublic class Solution {\n    public List<Comparator<T>> getComparators(final List<Comparator<T>> comparators) {\n        final List<Comparator<T>> result = new ArrayList<Comparator<T>>();\n        for (Comparator<T> comparator : comparators) {\n            if (comparator instanceof ComparatorChain) {\n                final ComparatorChain<T> chain = (ComparatorChain<T>) comparator;\n                final List<Comparator<T>> chainComparators = getComparators(chain.getComparators());\n                result.add(new ComparatorChain<T>(chainComparators));\n            } else {"}, {"ID": 1358, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PetiteConfig setDefaultWiringMode(final WiringMode defaultWiringMode) { if ((defaultWiringMode == null) || (defaultWiringMode == WiringMode.DEFAULT)) { throw new PetiteException(\"Invalid default wiring mode: \" + defaultWiringMode); } this.defaultWiringMode = defaultWiringMode; return this; } \nResponse:", "ground_truth": "Specifies default wiring mode.", "predict": " public PetiteResponse setDefaultResponse(final Response defaultResponse) { if ((defaultResponse == null) || (defaultResponse == Response.DEFAULT)) { throw new PetiteException(\"Invalid default resp \" + defaultResponse); } this.defaultResponse = defaultResponse; return this; } \nResp public PetiteResponse setDefaultResponse(final String defaultResponse) { if ((defaultResponse == null) || (defaultResponse.length() == 0)) { throw new PetiteException(\"Invalid default resp \" + defaultResponse); } this.defaultResponse = Response.valueOf(defaultResponse); return this; } \nResp public PetiteResponse setDefaultResponse(final Enum defaultResponse) { if ((defaultResponse == null) || (defaultResponse == Response.DEFAULT)) { throw new PetiteException(\"Invalid default resp \" + defaultResponse); } this.defaultResponse = defaultResponse; return this; } \nResp public PetiteResponse setDefaultResponse(final int defaultResponse) { if ((defaultResponse"}, {"ID": 1359, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void print(final Level level, final String message, final Throwable throwable) { if (!isEnabled(level)) { return; } StringBuilder msg = new StringBuilder() .append(slf.getElapsedTime()).append(' ').append('[') .append(level).append(']').append(' ') .append(getCallerClass()).append(' ').append('-') .append(' ').append(message); System.out.println(msg.toString()); if (throwable != null) { throwable.printStackTrace(System.out); } } \nResponse:", "ground_truth": "Prints error message if level is enabled.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution.print(Level.INFO, \"Hello World\", null);\n    }\n\n    public static void print(final Level level, final String message, final Throwable throwable) {\n        if (!isEnabled(level)) {\n            return;\n        }\n        StringBuilder msg = new StringBuilder()\n                .append(System.currentTimeMillis()).append(' ')\n                .append('[')\n                .append(level)\n                .append(']')\n                .append(' ')\n                .append(getCallerClass())\n                .append(' ')\n                .append(message);\n        System.out.println(msg.toString());\n        if (throwable != null) {\n            throwable.printStackTrace(System.out);\n        }\n    }\n\n    private static String getCallerClass() {\n        StackTr"}, {"ID": 1360, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String getCallerClass() { Exception exception = new Exception(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { String className = stackTraceElement.getClassName(); if (className.equals(SimpleLoggerProvider.class.getName())) { continue; } if (className.equals(SimpleLogger.class.getName())) { continue; } if (className.equals(Logger.class.getName())) { continue; } return shortenClassName(className) + '.' + stackTraceElement.getMethodName() + ':' + stackTraceElement.getLineNumber(); } return \"N/A\"; } \nResponse:", "ground_truth": "Returns called class.", "predict": " public String getCallerClass() { return shortenClassName(getClass().getName()) + '.' + getMethodName() + ':' + getLineNumber(); } \n\n*/\n\npublic class SimpleLoggerProvider {\n\t\n\tpublic static final String LOGGER_NAME = \"SimpleLogger\";\n\t\n\tpublic static final String LOGGER_PACKAGE = \"com.javarush.test.level05.lesson06.task05\";\n\t\n\tpublic static final String LOGGER_FULL_NAME = LOGGER_PACKAGE + \".\" + LOGGER_NAME;\n\t\n\tpublic static final String LOGGER_SHORT_NAME = LOGGER_NAME;\n\t\n\tpublic static final String LOGGER_FULL_NAME_WITH_PACKAGE = LOGGER_PACKAGE + \".\" + LOGGER_NAME;\n\t\n\tpublic static final String LOGGER_SHORT_NAME_WITH_PACKAGE = LOG"}, {"ID": 1361, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String shortenClassName(final String className) { int lastDotIndex = className.lastIndexOf('.'); if (lastDotIndex == -1) { return className; } StringBuilder shortClassName = new StringBuilder(className.length()); int start = 0; while(true) { shortClassName.append(className.charAt(start)); int next = className.indexOf('.', start); if (next == lastDotIndex) { break; } start = next + 1; shortClassName.append('.'); } shortClassName.append(className.substring(lastDotIndex)); return shortClassName.toString(); } \nResponse:", "ground_truth": "Returns shorten class name.", "predict": "\n\n*/\n\npublic class Solution {\n    public String shortenClassName(String className) {\n        int lastDotIndex = className.lastIndexOf('.');\n        if (lastDotIndex == -1) {\n            return className;\n        }\n        StringBuilder shortClassName = new StringBuilder(className.length());\n        int start = 0;\n        while (true) {\n            shortClassName.append(className.charAt(start));\n            int next = className.indexOf('.', start);\n            if (next == lastDotIndex) {\n                break;\n            }\n            start = next + 1;\n            shortClassName.append('.');\n        }\n        shortClassName.append(className.substring(lastDotIndex));\n        return shortClassName.toString();\n    }\n}\n"}, {"ID": 1362, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonSerializer excludeTypes(final Class... types) { if (excludedTypes == null) { excludedTypes = types; } else { excludedTypes = ArraysUtil.join(excludedTypes, types); } return this; } \nResponse:", "ground_truth": "Excludes types. Supports interfaces and subclasses as well.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1363, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void serialize(final Object source, final Appendable target) { JsonContext jsonContext = createJsonContext(target); jsonContext.serialize(source); } \nResponse:", "ground_truth": "Serializes object into provided appendable.", "predict": " Response.ok(jsonContext.getJson(), MediaType.APPLICATION_JSON_TYPE); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\npublic Response get(@PathVariable(\"id\") final String id) { return Response.ok(new JsonContext().getJson(), MediaType.APPLICATION_JSON_TYPE); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\npublic Response put(@PathVariable(\"id\") final String id, final Object source) { return Response.ok(new JsonContext().getJson(), MediaType.APPLICATION_JSON_TYPE); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.POST)\npublic Response post(@PathVariable(\"id\") final String id, final Object source) { return Response.ok(new JsonContext().getJson(), MediaType.APPLICATION_JSON"}, {"ID": 1364, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String serialize(final Object source) { FastCharBuffer fastCharBuffer = new FastCharBuffer(); serialize(source, fastCharBuffer); return fastCharBuffer.toString(); } \nResponse:", "ground_truth": "Serializes object into source.", "predict": " Response = new Response(fastCharBuffer.toString());\n\n*/\n\npublic class Serialize {\n\tpublic static void main(String[] args) {\n\t\tString source = \"Hello World\";\n\t\tFastCharBuffer fastCharBuffer = new FastCharBuffer();\n\t\tserialize(source, fastCharBuffer);\n\t\tSystem.out.println(fastCharBuffer.toString());\n\t}\n\n\tpublic static void serialize(final Object source, final FastCharBuffer fastCharBuffer) {\n\t\tfastCharBuffer.append(\"public String serialize(final Object source) { \");\n\t\tfastCharBuffer.append(\"FastCharBuffer fastCharBuffer = new FastCharBuffer(); \");\n\t\tserialize(source, fastCharBuffer);\n\t\tfastCharBuffer.append(\"return fastCharBuffer.toString(); } \");\n\t}\n\n\tpublic static void serialize(final Object source, final FastCharBuffer fastCharBuffer) {\n\t\tfastCharBuffer.append(\"FastCharBuffer fastChar"}, {"ID": 1365, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream out = null; ObjectInputStream in = null; Object objCopy = null; try { out = new ObjectOutputStream(bos); out.writeObject(obj); out.flush(); byte[] bytes = bos.toByteArray(); in = new ObjectInputStream(new ByteArrayInputStream(bytes)); objCopy = in.readObject(); } finally { StreamUtil.close(out); StreamUtil.close(in); } return (T) objCopy; } \nResponse:", "ground_truth": "Create object copy using serialization mechanism.", "predict": "\n\n*/\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CloneViaSerialization {\n\n    public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream out = null;\n        ObjectInputStream in = null;\n        Object objCopy = null;\n        try {\n            out = new ObjectOutputStream(bos);\n            out.writeObject(obj);\n            out.flush();\n            byte[] bytes = bos.toByteArray();\n            in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n            objCopy = in.readObject();\n        } finally {\n"}, {"ID": 1366, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeObject(final File dest, final Object object) throws IOException { FileOutputStream fos = null; BufferedOutputStream bos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(dest); bos = new BufferedOutputStream(fos); oos = new ObjectOutputStream(bos); oos.writeObject(object); } finally { StreamUtil.close(oos); StreamUtil.close(bos); StreamUtil.close(fos); } } \nResponse:", "ground_truth": "Writes serializable object to a file. Existing file will be overwritten.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WriteObject {\n\n    public static void main(String[] args) throws IOException {\n        File dest = new File(\"src/test/resources/WriteObject.java\");\n        List<Object> objects = new ArrayList<>();\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects.add(new Object());\n        objects."}, {"ID": 1367, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object readObject(final File source) throws IOException, ClassNotFoundException { Object result = null; FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; try { fis = new FileInputStream(source); bis = new BufferedInputStream(fis); ois = new ObjectInputStream(bis); result = ois.readObject(); } finally { StreamUtil.close(ois); StreamUtil.close(bis); StreamUtil.close(fis); } return result; } \nResponse:", "ground_truth": "Reads serialized object from the file.", "predict": " Response = Response.ok().entity(readObject(source)).build();\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core."}, {"ID": 1368, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] objectToByteArray(final Object obj) throws IOException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(bos); oos.writeObject(obj); } finally { StreamUtil.close(oos); } return bos.toByteArray(); } \nResponse:", "ground_truth": "Serialize an object to byte array.", "predict": " Response = new Response(Status.OK, \"application/octet-stream\", new ByteArrayInputStream(objectToByteArray(obj)));\n\n*/\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3"}, {"ID": 1369, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException { Object retObj = null; ByteArrayInputStream bais = new ByteArrayInputStream(data); ObjectInputStream ois = null; try { ois = new ObjectInputStream(bais); retObj = ois.readObject(); } finally { StreamUtil.close(ois); } return retObj; } \nResponse:", "ground_truth": "De-serialize an object from byte array.", "predict": " Response = new Response(Response.OK, \"Successfully converted the byte array to an object.\");\n\n*/\n\npublic class ByteArrayToObject {\n\tpublic static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException {\n\t\tObject retObj = null;\n\t\tByteArrayInputStream bais = new ByteArrayInputStream(data);\n\t\tObjectInputStream ois = null;\n\t\ttry {\n\t\t\tois = new ObjectInputStream(bais);\n\t\t\tretObj = ois.readObject();\n\t\t} finally {\n\t\t\tStreamUtil.close(ois);\n\t\t}\n\t\treturn retObj;\n\t}\n}\n"}, {"ID": 1370, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[][] resolveMappedTypesTableNames(final Class[] types) { if (cachedMappedNames == null) { String[][] names = new String[types.length][]; for (int i = 0; i < types.length; i++) { Class type = types[i]; if (type != null) { DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded != null) { Class[] mappedTypes = ded.getMappedTypes(); if (mappedTypes != null) { names[i] = createTypesTableNames(mappedTypes); } } } } cachedMappedNames = names; } return cachedMappedNames; } \nResponse:", "ground_truth": "Resolved mapped type names for each type.", "predict": "\npublic String[][] resolveMappedTypesTableNames(final Class[] types) {\n\treturn cachedMappedNames;\n}\n\n*/\n"}, {"ID": 1371, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] createTypesTableNames(final Class[] types) { String[] names = new String[types.length]; for (int i = 0; i < types.length; i++) { if (types[i] == null) { names[i] = null; continue; } DbEntityDescriptor ded = dbEntityManager.lookupType(types[i]); if (ded != null) { String tableName = ded.getTableName(); tableName = tableName.toUpperCase(); names[i] = tableName; } } return names; } \nResponse:", "ground_truth": "Creates table names for given types.", "predict": "\n\n*/\n\npublic class CreateTableCommand extends AbstractCommand {\n\n    public CreateTableCommand(String name, String tableName, String[] columnNames, String[] columnTypes, String[] columnDefinitions, String[] primaryKeyColumns, String[] primaryKeyColumnNames, String[] primaryKeyColumnTypes, String[] foreignKeyColumns, String[] foreignKeyColumnNames, String[] foreignKeyColumnTypes, String[] indexColumns, String[] indexColumnNames, String[] indexColumnTypes, String[] uniqueColumns, String[] uniqueColumnNames, String[] uniqueColumnTypes, String[] checkColumns, String[] checkColumnNames, String[] checkColumnTypes, String[] indexColumnsToCreate, String[] indexColumnNamesToCreate, String[] indexColumnTypesToCreate, String[] uniqueColumnsToCreate, String[] uniqueColumnNamesToCreate, String[] uniqueColumnTypesToCreate, String[] checkColumnsToCreate, String[] checkColumnNamesToCreate, String[] checkColumnTypesToCreate, String[] foreignKey"}, {"ID": 1372, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected Object readColumnValue(final int colNdx, final Class destinationType, final Class<? extends SqlType> sqlTypeClass, final int columnDbSqlType) { if (colNdx != cachedColumnNdx) { try { SqlType sqlType; if (sqlTypeClass != null) { sqlType = SqlTypeManager.get().lookupSqlType(sqlTypeClass); } else { sqlType = SqlTypeManager.get().lookup(destinationType); } if (sqlType != null) { cachedColumnValue = sqlType.readValue(resultSet, colNdx + 1, destinationType, columnDbSqlType); } else { cachedColumnValue = resultSet.getObject(colNdx + 1); cachedColumnValue = TypeConverterManager.get().convertType(cachedColumnValue, destinationType); } } catch (SQLException sex) { throw new DbOomException(dbOomQuery, \"Invalid value for column #\" + (colNdx + 1), sex); } cachedColumnNdx = colNdx; } return cachedColumnValue; } \nResponse:", "ground_truth": "Reads column value from result set. Since this method may be called more then once for\nthe same column, it caches column values.", "predict": "\n\n*/\n\npackage com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex;\n\nimport java.util.Locale;\n\nimport com.github.dannil.scbjavaclient.client.AbstractContainerClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.economicindicators.BusinessActivitiesIndustrialComplexEconomicIndicatorsClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.industrialcomplex.BusinessActivitiesIndustrialComplexIndustrialComplexClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.industrialcomplex.BusinessActivitiesIndustrialComplexIndustrialComplexCollectionClient;\nimport com.github.dannil.scbjavaclient.communication.URLEndpoint;\n\n/**\n * <p"}, {"ID": 1373, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void cacheResultSetEntities(final Object[] result) { if (entitiesCache == null) { entitiesCache = new HashMap<>(); } for (int i = 0; i < result.length; i++) { Object object = result[i]; if (object == null) { continue; } DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded == null) { // not a type, continue continue; } // calculate key Object key; if (ded.hasIdColumn()) { //noinspection unchecked key = ded.getKeyValue(object); } else { key = object; } Object cachedObject = entitiesCache.get(key); if (cachedObject == null) { // object is not in the cache, add it entitiesCache.put(key, object); } else { // object is in the cache, replace it result[i] = cachedObject; } } } \nResponse:", "ground_truth": "Caches returned entities. Replaces new instances with existing ones.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Cache {\n    private static final Map<Object, Object> entitiesCache = new ConcurrentHashMap<>();\n\n    public static void cacheResultSetEntities(Object[] result) {\n        if (entitiesCache == null) {\n            entitiesCache = new ConcurrentHashMap<>();\n        }\n        for (int i = 0; i < result.length; i++) {\n            Object object = result[i];\n            if (object == null) {\n                continue;\n            }\n            DbEntityDescriptor ded = cachedDbEntityDescriptors[i];\n            if (ded == null) {\n                // not a type, continue\n                continue;\n            }\n            // calculate key\n            Object key;\n            if (ded."}, {"ID": 1374, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProviderDefinition[] resolve(final Class type, final String name) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor[] methods = cd.getAllMethodDescriptors(); List<ProviderDefinition> list = new ArrayList<>(); for (MethodDescriptor methodDescriptor : methods) { Method method = methodDescriptor.getMethod(); PetiteProvider petiteProvider = method.getAnnotation(PetiteProvider.class); if (petiteProvider == null) { continue; } String providerName = petiteProvider.value(); if (StringUtil.isBlank(providerName)) { // default provider name providerName = method.getName(); if (providerName.endsWith(\"Provider\")) { providerName = StringUtil.substring(providerName, 0, -8); } } ProviderDefinition providerDefinition; if (Modifier.isStatic(method.getModifiers())) { providerDefinition = new ProviderDefinition(providerName, method); } else { providerDefinition = new ProviderDefinition(providerName, name, method); } list.add(providerDefinition); } ProviderDefinition[] providers; if (list.isEmpty()) { providers = ProviderDefinition.EMPTY; } else { providers = list.toArray(new ProviderDefinition[0]); } return providers; } \nResponse:", "ground_truth": "Resolves all providers in the class", "predict": " public ProviderDefinition[] resolve(final Class type, final String name) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor[] methods = cd.getAllMethodDescriptors(); List<ProviderDefinition> list = new ArrayList<>(); for (MethodDescriptor methodDescriptor : methods) { Method method = methodDescriptor.getMethod(); PetiteProvider petiteProvider = method.getAnnotation(PetiteProvider.class); if (petiteProvider == null) { continue; } String providerName = petiteProvider.value(); if (StringUtil.isBlank(providerName)) { // default provider name providerName = method.getName(); if (providerName.endsWith(\"Provider\")) { providerName = StringUtil.substring(providerName, 0, -8); } } ProviderDefinition providerDefinition; if (Modifier.isStatic(method.getModifiers())) { providerDefinition = new ProviderDefinition"}, {"ID": 1375, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String applyToTableName(final String tableName) { String entityName = convertTableNameToEntityName(tableName); return convertEntityNameToTableName(entityName); } \nResponse:", "ground_truth": "Applies table naming strategy to given table name hint.\nReturns full table name.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1376, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isConnectionValid(final ConnectionData connectionData, final long now) { if (!validateConnection) { return true; } if (now < connectionData.lastUsed + validationTimeout) { return true; } Connection conn = connectionData.connection; if (validationQuery == null) { try { return !conn.isClosed(); } catch (SQLException sex) { return false; } } boolean valid = true; Statement st = null; try { st = conn.createStatement(); st.execute(validationQuery); } catch (SQLException sex) { valid = false; } finally { if (st != null) { try { st.close(); } catch (SQLException ignore) { } } } return valid; } \nResponse:", "ground_truth": "Checks if existing connection is valid and available. It may happens\nthat if connection is not used for a while it becomes inactive,\nalthough not technically closed.", "predict": "\n\n*/\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.RemovalListener;\nimport com.google.common.cache.RemovalNotification;\n\npublic class ConnectionPool {\n\tprivate static final Logger LOGGER = Logger.getLogger(ConnectionPool.class);\n\tprivate static final int MAX_CONNECTIONS = 10;\n\tprivate static final int MAX_IDLE_CONNECTIONS = 5;\n\tprivate static final int MAX_CONNECTION_AGE = 10;\n\tprivate static final int VALIDATION_TIMEOUT = 10;\n\tprivate"}, {"ID": 1377, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void renderView(final ActionRequest actionRequest, final String target) throws Exception { HttpServletRequest request = actionRequest.getHttpServletRequest(); HttpServletResponse response = actionRequest.getHttpServletResponse(); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if (dispatcher == null) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + target); // should never happened return; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if (DispatcherUtil.isPageIncluded(request, response)) { dispatcher.include(request, response); } else { dispatcher.forward(request, response); } } \nResponse:", "ground_truth": "Renders the view by dispatching to the target JSP.", "predict": " Generate the method-level comment for the following java Code. Code: @Override protected void renderView(final ActionRequest actionRequest, final String target) throws Exception { HttpServletRequest request = actionRequest.getHttpServletRequest(); HttpServletResponse response = actionRequest.getHttpServletResponse(); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if (dispatcher == null) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + target); // should never happened return; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if (DispatcherUtil.isPageIncluded(request, response)) { dispatcher.include(request, response); } else { dispatcher.forward(request, response); } } \nResp Generate the method-level comment for the following java Code. Code: @Override protected void renderView(final Action"}, {"ID": 1378, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String locateTarget(final ActionRequest actionRequest, String path) { String target; if (path.endsWith(StringPool.SLASH)) { path = path + defaultViewPageName; } for (final String ext : defaultViewExtensions) { target = path + ext; if (targetExists(actionRequest, target)) { return target; } } return null; } \nResponse:", "ground_truth": "Locates target using path with various extensions appended.", "predict": " @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path) { return null; } \nResp @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path, final String viewName) { return null; } \nResp @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path, final String viewName, final String extension) { return null; } \nResp @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path, final String viewName, final String extension, final String queryString) { return null; } \nResp @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path, final String viewName, final String extension, final String queryString, final String anchor) { return null; } \nResp @Override protected Response<String> doAction(final ActionRequest actionRequest, final String path, final String viewName,"}, {"ID": 1379, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResponse:", "ground_truth": "Returns buffered writer if buffering is enabled,\notherwise returns the original writer.", "predict": " @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @"}, {"ID": 1380, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public ServletOutputStream getOutputStream() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getOutputStream(); } return buffer.getOutputStream(); } \nResponse:", "ground_truth": "Returns buffered output stream if buffering is enabled,\notherwise returns the original stream.", "predict": " @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResp @Override public ServletResponse getResponse() { return response; } \nResp @Override public void setResponse(ServletResponse response) { this.response = response; } \nResp @Override public void setResponse(ServletResponse response, boolean buffer) { this.response = response; this.buffer = buffer; } \nResp @Override public void setResponse(ServletResponse response, boolean buffer, boolean autoFlush) { this.response = response; this.buffer = buffer; } \nResp @Override public void setBufferSize(int size) { buffer = size; } \nResp @Override public int getBufferSize() { return buffer; } \nResp @Override public void flushBuffer() throws IOException { if (buffer != null) { buffer.flush();"}, {"ID": 1381, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeContentToResponse(final char[] content) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUtil.toByteArray(content)); } else { outputStream.write(CharUtil.toByteArray(content, encoding)); } outputStream.flush(); } else { Writer out = getResponse().getWriter(); out.write(content); out.flush(); } } \nResponse:", "ground_truth": "Writes content to original output stream, using either output stream or writer, depending\non how the content was buffered. It is assumed that provided content is a modified\nwrapped content.", "predict": " public void writeContentToResponse(final char[] content) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUtil.toByteArray(content)); } else { outputStream.write(CharUtil.toByteArray(content, encoding)); } outputStream.flush(); } else { Writer out = getResponse().getWriter(); out.write(content); out.flush(); } } \nResp public void writeContentToResponse(final char[] content, final int offset, final int length) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUt"}, {"ID": 1382, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void setContentType(final String type) { super.setContentType(type); contentTypeResolver = new ContentTypeHeaderResolver(type); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } } \nResponse:", "ground_truth": "Sets the content type and enables or disables buffering.", "predict": "\n\n@Override public void setContentType(final String type) { super.setContentType(type); contentTypeResolver = new ContentTypeHeaderResolver(type); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } } \n\n@Override public void setContentType(final String type, final String charset) { super.setContentType(type, charset); contentTypeResolver = new ContentTypeHeaderResolver(type, charset); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } } \n\n@Override public void setContentType(final String type, final String charset, final String contentTypeCharset) { super.setContentType(type, charset, contentTypeCharset);"}, {"ID": 1383, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void print(final String string) throws IOException { if (isBufferStreamBased()) { String encoding = getContentTypeEncoding(); byte[] bytes; if (encoding == null) { bytes = string.getBytes(); } else { bytes = string.getBytes(encoding); } buffer.getOutputStream().write(bytes); return; } // make sure at least writer is initialized buffer.getWriter().write(string); } \nResponse:", "ground_truth": "Appends string to the buffer.", "predict": " public void print(final String string) throws IOException { if (isBufferStreamBased()) { String encoding = getContentTypeEncoding(); byte[] bytes; if (encoding == null) { bytes = string.getBytes(); } else { bytes = string.getBytes(encoding); } buffer.getOutputStream().write(bytes); return; } // make sure at least writer is initialized buffer.getWriter().write(string); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Locale;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Response {\n\tprivate HttpServletResponse response;\n\tprivate PrintWriter writer;\n\tprivate ServletOutputStream outputStream;\n\tprivate String contentType;\n\tprivate String contentTypeEncoding;\n\t"}, {"ID": 1384, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult login() { T authToken; authToken = loginViaBasicAuth(servletRequest); if (authToken == null) { authToken = loginViaRequestParams(servletRequest); } if (authToken == null) { log.warn(\"Login failed.\"); return JsonResult.of(HttpStatus.error401().unauthorized(\"Login failed.\")); } log.info(\"login OK!\"); final UserSession<T> userSession = new UserSession<>(authToken, userAuth.tokenValue(authToken)); userSession.start(servletRequest, servletResponse); // return token return tokenAsJson(authToken); } \nResponse:", "ground_truth": "Authenticate user and start user session.", "predict": "\n\n*/\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.BaseEncoding;\nimport com.google.common.net.HttpHeaders;\nimport com.google.common.net.MediaType;\nimport com.google.common.net.PercentEscaper;\nimport com.google.common.primitives.Ints;\nimport com.google.common.primitives.Longs;\nimport com.google.common.primitives.Shorts;\nimport com.google.common.primitives.UnsignedBytes;\nimport com.google.common.primitives.UnsignedInts;\nimport com.google."}, {"ID": 1385, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult tokenAsJson(final T authToken) { final JsonObject jsonObject = new JsonObject(); jsonObject.put(\"token\", userAuth.tokenValue(authToken)); return JsonResult.of(jsonObject); } \nResponse:", "ground_truth": "Prepares the JSON payload that carries on the token value.", "predict": "\n\n*/\n\npackage com.example.mydemo.http.token;\n\nimport com.example.mydemo.http.HttpResult;\nimport com.example.mydemo.http.HttpResultType;\nimport com.example.mydemo.http.HttpResultUtil;\nimport com.example.mydemo.http.HttpResultUtil.HttpResultCallback;\nimport com.example.mydemo.http.HttpResultUtil.HttpResultCallback.HttpResultCallbackType;\nimport com.example.mydemo.http.HttpResultUtil.HttpResultCallback.HttpResultCallbackType.HttpResultCallbackTypeType;\nimport com.example.mydemo.http.HttpResultUtil.HttpResultCallback.HttpResultCallbackType.HttpResultCallbackTypeType.HttpResultCallbackTypeTypeType;\nimport com.example.mydemo.http.HttpResultUtil.HttpResultCallback.HttpResultCallbackType.HttpResultCallbackTypeType"}, {"ID": 1386, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T loginViaBasicAuth(final HttpServletRequest servletRequest) { final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); return userAuth.login(username, password); } \nResponse:", "ground_truth": "Tries to login user with basic authentication.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.AbstractController;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\nimport io."}, {"ID": 1387, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult logout() { log.debug(\"logout user\"); UserSession.stop(servletRequest, servletResponse); return JsonResult.of(HttpStatus.ok()); } \nResponse:", "ground_truth": "Logout hook.", "predict": "\n\n<pre>{@code\n{\n    \"status\": \"ok\",\n    \"message\": \"logout user\"\n}\n}</pre>\n\n*/\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonPropertyOrder;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeName;\nimport com.fasterxml.jackson.annotation.JsonValue;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.annotation.ObjectIdResolver;\nimport com.f"}, {"ID": 1388, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File toContainerFile(final URL url) { String protocol = url.getProtocol(); if (protocol.equals(FILE_PROTOCOL)) { return toFile(url); } String path = url.getPath(); return new File(URI.create( path.substring(ZERO, path.lastIndexOf(\"!/\")))); } \nResponse:", "ground_truth": "Returns a file of either a folder or a containing archive.", "predict": " Generate the method-level comment for the following java Code. Code: public static File toContainerFile(final URL url) { String protocol = url.getProtocol(); if (protocol.equals(FILE_PROTOCOL)) { return toFile(url); } String path = url.getPath(); return new File(URI.create( path.substring(ZERO, path.lastIndexOf(\"!/\")))); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class JavaCodeGenerator {\n\n    private static final String FILE_PROTOCOL = \"file\";\n    private static final String FILE_PROTOCOL_PREFIX = \""}, {"ID": 1389, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File mkdirs(final File dirs) throws IOException { if (dirs.exists()) { checkIsDirectory(dirs); return dirs; } return checkCreateDirectory(dirs); } \nResponse:", "ground_truth": "Creates all directories at once.\n\n@param dirs Directories to make.\n@throws IOException if cannot create directory.", "predict": "\n\npublic static File mkdirs(final File dirs) throws IOException {\n    if (dirs.exists()) {\n        checkIsDirectory(dirs);\n        return dirs;\n    }\n    return checkCreateDirectory(dirs);\n}\n\npublic static File checkCreateDirectory(final File dirs) throws IOException {\n    if (dirs.exists()) {\n        checkIsDirectory(dirs);\n        return dirs;\n    }\n    if (!dirs.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + dirs);\n    }\n    return dirs;\n}\n\npublic static void checkIsDirectory(final File dirs) throws IOException {\n    if (!dirs.isDirectory()) {\n        throw new IOException(\"Not a directory: \" + dirs);\n    }\n}\n\npublic static void checkIsFile(final File dirs) throws IOException {\n    "}, {"ID": 1390, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File mkdir(final File dir) throws IOException { if (dir.exists()) { checkIsDirectory(dir); return dir; } return checkCreateDirectory(dir); } \nResponse:", "ground_truth": "Creates single directory.\n\n@throws IOException if cannot create directory.", "predict": "\n\npublic static File mkdir(final File dir) throws IOException {\n    if (dir.exists()) {\n        checkIsDirectory(dir);\n        return dir;\n    }\n    return checkCreateDirectory(dir);\n}\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n    private static final String JAVA_FILE_EXTENSION = \".java\";\n    private static final String JAVA_FILE_PREFIX = \"File\";\n    private static final String JAVA_FILE_SUFFIX = \"File\";\n    private static final String JAVA_FILE_PACKAGE = \"java.io\";\n    private static final String JAVA_FILE_CLASS_NAME = \"File\";\n    private static final String JAVA_FILE_METHOD_NAME = \"mkdir"}, {"ID": 1391, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void _copyFile(final File srcFile, final File destFile) throws IOException { if (destFile.exists()) { if (destFile.isDirectory()) { throw new IOException(\"Destination '\" + destFile + \"' is a directory\"); } } // do copy file FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(srcFile); output = new FileOutputStream(destFile, false); StreamUtil.copy(input, output); } finally { StreamUtil.close(output); StreamUtil.close(input); } // done if (srcFile.length() != destFile.length()) { throw new IOException(\"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\"); } destFile.setLastModified(srcFile.lastModified()); } \nResponse:", "ground_truth": "Internal file copy when most of the pre-checking has passed.\n\n@param srcFile  Source {@link File}.\n@param destFile Destination {@link File}.\n@throws IOException if cannot copy", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Date;\nimport java.util.Properties;\n\npublic class FileCopy {\n\n    public static void main(String[] args) {\n        try {\n            Properties properties = new Properties();\n            properties.load(FileCopy.class.getClassLoader().getResourceAsStream(\"filecopy.properties\"));\n            String srcFile = properties.getProperty(\"srcFile\");\n            String destFile = properties.getProperty(\"destFile\");\n            File src = new File(srcFile);\n            File dest = new File(destFile);\n            if (src.exists()) {\n                if (src.isDirectory()) {\n                    throw new IOException(\"Source '\" + src"}, {"ID": 1392, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copyDir(final File srcDir, final File destDir) throws IOException { checkDirCopy(srcDir, destDir); _copyDirectory(srcDir, destDir); } \nResponse:", "ground_truth": "Copies directory with specified copy params.\n\n@see #_copyDirectory(File, File)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1393, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File moveFileToDir(final File srcFile, final File destDir) throws IOException { checkExistsAndDirectory(destDir); return moveFile(srcFile, file(destDir, srcFile.getName())); } \nResponse:", "ground_truth": "Moves a file to a directory.\n\n@param srcFile Source {@link File}.\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": " public static File moveFileToDir(final File srcFile, final File destDir) throws IOException { checkExistsAndDirectory(destDir); return moveFile(srcFile, file(destDir, srcFile.getName())); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.apache.commons.io.filefilter.WildcardFileFilter;\n\npublic"}, {"ID": 1394, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void _moveDirectory(final File srcDest, File destDir) throws IOException { if (destDir.exists()) { checkIsDirectory(destDir); destDir = file(destDir, destDir.getName()); destDir.mkdir(); } final boolean rename = srcDest.renameTo(destDir); if (!rename) { _copyDirectory(srcDest, destDir); deleteDir(srcDest); } } \nResponse:", "ground_truth": "Moves a directory.\n\n@param srcDest Source directory\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MoveDirectory {\n    public static void main(String[] args) throws IOException {\n        File srcDir = new File(args[0]);\n        File destDir = new File(args[1]);\n        if (!srcDir.exists()) {\n            System.out.println(\"Source directory does not exist.\");\n            return;\n        }\n        if (!srcDir.isDirectory()) {\n            System.out.println(\"Source is not a directory.\");\n            return;\n        }\n        if (!destDir.exists()) {\n            System.out.println(\"Destination directory does not exist.\");\n            return;\n        }\n        if (!destDir.isDirectory()) {\n            System.out.println(\"Destination"}, {"ID": 1395, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cleanDir(final File destDir) throws IOException { checkExists(destDir); checkIsDirectory(destDir); File[] files = destDir.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of: \" + destDir); } IOException exception = null; for (File file : files) { try { if (file.isDirectory()) { deleteDir(file); } else { file.delete(); } } catch (IOException ioex) { exception = ioex; continue; } } if (exception != null) { throw exception; } } \nResponse:", "ground_truth": "Cleans a directory without deleting it.\n\n@param destDir destination to clean.\n@throws IOException if something went wrong.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File destDir = new File(\"src/main/java/com/example/test\");\n        File[] files = destDir.listFiles();\n        if (files == null) {\n            throw new IOException(\"Failed to list contents of: \" + destDir);\n        }\n        List<File> fileList = new ArrayList<File>(Arrays.asList(files));\n        for (File file : fileList) {\n            if (file.isDirectory()) {\n                deleteDir(file);\n            } else {\n                file.delete();\n            }\n        }\n    }\n\n    private static void deleteDir(File dir) throws IO"}, {"ID": 1396, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] readUTFChars(final File file) throws IOException { checkExists(file); checkIsFile(file); UnicodeInputStream in = unicodeInputStreamOf(file); try { return StreamUtil.readChars(in, detectEncoding(in)); } finally { StreamUtil.close(in); } } \nResponse:", "ground_truth": "Reads UTF file content as char array.\n\n@param file {@link File} to read.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " Response = Response.ok(new String(readUTFChars(file), detectEncoding(in)));\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.text.StrBuilder;\nimport org.apache.commons.lang3.text.StrSub"}, {"ID": 1397, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] readChars(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file, encoding); try { return StreamUtil.readChars(in, encoding); } finally { StreamUtil.close(in); } } \nResponse:", "ground_truth": "Reads file content as char array.\n\n@param file     {@link File} to read.\n@param encoding Encoding to use.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " public static String readString(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file, encoding); try { return StreamUtil.readString(in, encoding); } finally { StreamUtil.close(in); } } \nResp public static byte[] readBytes(final File file) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file); try { return StreamUtil.readBytes(in); } finally { StreamUtil.close(in); } } \nResp public static InputStream streamOf(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); return streamOf(file, encoding); } \nResp public static InputStream streamOf(final File file) throws IOException { checkExists(file); checkIsFile(file); return streamOf(file); } "}, {"ID": 1398, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeChars(final File dest, final char[] data, final String encoding) throws IOException { outChars(dest, data, encoding, false); } \nResponse:", "ground_truth": "Write characters. append = false\n\n@see #outChars(File, char[], String, boolean)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1399, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, false); } \nResponse:", "ground_truth": "Writes String. append = false\n\n@see #outString(File, String, String, boolean)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1400, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void appendString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, true); } \nResponse:", "ground_truth": "Appends String. append = true\n\n@see #outString(File, String, String, boolean)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1401, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] readBytes(final File file, final int count) throws IOException { checkExists(file); checkIsFile(file); long numToRead = file.length(); if (numToRead >= Integer.MAX_VALUE) { throw new IOException(\"File is larger then max array size\"); } if (count > NEGATIVE_ONE && count < numToRead) { numToRead = count; } byte[] bytes = new byte[(int) numToRead]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; } \nResponse:", "ground_truth": "Read file and returns byte array with contents.\n\n@param file  {@link File} to read\n@param count number of bytes to read\n@return byte array from {@link File} contents.\n@throws IOException if not a {@link File} or {@link File} does not exist or file size is\nlarger than {@link Integer#MAX_VALUE}.", "predict": " public static byte[] readBytes(final File file, final int count) throws IOException { checkExists(file); checkIsFile(file); long numToRead = file.length(); if (numToRead >= Integer.MAX_VALUE) { throw new IOException(\"File is larger then max array size\"); } if (count > NEGATIVE_ONE && count < numToRead) { numToRead = count; } byte[] bytes = new byte[(int) numToRead]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileUtils {\n\t\n\tpublic static void checkExists(File file) throws IOException {\n\t\tif (!file.exists())"}, {"ID": 1402, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, false); } \nResponse:", "ground_truth": "Write bytes. append = false\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1403, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void appendBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, true); } \nResponse:", "ground_truth": "Appends bytes. append = true\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1404, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copy(final File src, final File dest) throws IOException { if (src.isDirectory()) { copyDir(src, dest); return; } if (dest.isDirectory()) { copyFileToDir(src, dest); return; } copyFile(src, dest); } \nResponse:", "ground_truth": "Smart copy. If source is a directory, copy it to destination.\nOtherwise, if destination is directory, copy source file to it.\nOtherwise, try to copy source file to destination file.\n\n@param src  source {@link File}\n@param dest destination {@link File}\n@throws IOException if there is an error copying.\n@see #copyDir(File, File)\n@see #copyFileToDir(File, File)\n@see #copyFile(File, File)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CopyFile {\n\n\tpublic static void copyFile(File src, File dest) throws IOException {\n\t\tif (src.isDirectory()) {\n\t\t\tcopyDir(src, dest);\n\t\t} else {\n\t\t\tcopyFileToDir(src, dest);\n\t\t}\n\t}\n\n\tprivate static void copyFileToDir(File src, File dest) throws IOException {\n\t\tFile destFile = new File(dest, src.getName());\n\t\tif (destFile.exists()) {\n\t\t\tdestFile.delete();\n\t\t}\n\t\tFileUtils.copyFile(src, destFile);\n\t}\n\n\tprivate static void copyDir(File src, File dest) throws IOException {\n\t\tif (!dest.exists()) {\n\t\t\tdest.mkdirs();\n\t\t"}, {"ID": 1405, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void delete(final File dest) throws IOException { if (dest.isDirectory()) { deleteDir(dest); return; } deleteFile(dest); } \nResponse:", "ground_truth": "Smart delete of destination file or directory.\n\n@throws IOException if there is an issue deleting the file/directory.\n@see #deleteFile(File)\n@see #deleteDir(File)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1406, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File createTempDirectory(final String prefix, final String suffix, final File tempDir) throws IOException { File file = createTempFile(prefix, suffix, tempDir); file.delete(); file.mkdir(); return file; } \nResponse:", "ground_truth": "Creates temporary directory.\n\n@see #createTempFile(String, String, File)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1407, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isBinary(final File file) throws IOException { byte[] bytes = readBytes(file, 128); for (byte b : bytes) { if (b < 32 && b != 9 && b != 10 && b != 13) { return true; } } return false; } \nResponse:", "ground_truth": "Checks the start of the file for ASCII control characters\n\n@param file {@link File}\n@return true if the the start of the {@link File} is ASCII control characters.", "predict": "\n\npublic static boolean isBinary(final File file) throws IOException {\n    byte[] bytes = readBytes(file, 128);\n    for (byte b : bytes) {\n        if (b < 32 && b != 9 && b != 10 && b != 13) {\n            return true;\n        }\n    }\n    return false;\n}\n\npublic static byte[] readBytes(final File file, final int length) throws IOException {\n    byte[] bytes = new byte[length];\n    FileInputStream fis = new FileInputStream(file);\n    int read = fis.read(bytes);\n    fis.close();\n    if (read != length) {\n        throw new IOException(\"Could not read all bytes from file\");\n    }\n    return bytes;\n}\n\npublic static void main(String[] args) throws IOException {\n    File file = new File(\"/home/jason/Desktop/test.txt\");\n    "}, {"ID": 1408, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void checkDirCopy(final File srcDir, final File destDir) throws IOException { checkExists(srcDir); checkIsDirectory(srcDir); if (equals(srcDir, destDir)) { throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\"); } } \nResponse:", "ground_truth": "Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.\n\n@param srcDir  Source directory\n@param destDir Destination directory\n@throws IOException if any of the above conditions are not true.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        File srcDir = new File(args[0]);\n        File destDir = new File(args[1]);\n        checkDirCopy(srcDir, destDir);\n    }\n\n    private static void checkDirCopy(File srcDir, File destDir) throws IOException {\n        if (!srcDir.exists()) {\n            throw new IOException(\"Source '\" + srcDir + \"' does not exist\");\n        }\n        if (!srcDir.isDirectory()) {\n            throw new IOException(\"Source '\" + srcDir + \"' is not a directory\");\n        }\n        if (destDir.exists()) {\n            throw new IOException(\"Dest"}, {"ID": 1409, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void checkFileCopy(final File srcFile, final File destFile) throws IOException { checkExists(srcFile); checkIsFile(srcFile); if (equals(srcFile, destFile)) { throw new IOException(\"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\"); } File destParent = destFile.getParentFile(); if (destParent != null && !destParent.exists()) { checkCreateDirectory(destParent); } } \nResponse:", "ground_truth": "Checks that file copy can occur.\n\n@param srcFile  Source {@link File}\n@param destFile Destination {@link File}\n@throws IOException if srcFile does not exist or is not a file or\nsrcFile and destFile are equal or cannot create ancestor directories.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileCopy {\n    public static void main(String[] args) throws IOException {\n        File srcFile = new File(\"src\");\n        File destFile = new File(\"dest\");\n        checkFileCopy(srcFile, destFile);\n    }\n}\n"}, {"ID": 1410, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void printUsage(final String commandName) { final StringBuilder usage = new StringBuilder(commandName); for (final Option option : options) { if (option.shortName != null) { usage.append(\" [-\").append(option.shortName).append(\"]\"); } else if (option.longName != null) { usage.append(\" [--\").append(option.longName).append(\"]\"); } } for (final Param param : params) { usage.append(\" \").append(param.label); } System.out.println(usage); } \nResponse:", "ground_truth": "Prints the usage line.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CommandLine {\n    private final List<Option> options = new ArrayList<>();\n    private final List<Param> params = new ArrayList<>();\n\n    public void addOption(final Option option) {\n        options.add(option);\n    }\n\n    public void addParam(final Param param) {\n        params.add(param);\n    }\n\n    public void printUsage() {\n        final StringBuilder usage = new StringBuilder();\n        for (final Option option : options) {\n            if (option.shortName != null) {\n                usage.append(\" [-\").append(option.shortName).append(\"]\");\n            } else if (option.longName != null) {\n                usage.append(\" [--\").append(option.longName).append(\"]\");\n            }\n        }\n        for (final Param param : params"}, {"ID": 1411, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Method resolveActionMethod(final Class<?> actionClass, final String methodName) { MethodDescriptor methodDescriptor = ClassIntrospector.get().lookup(actionClass).getMethodDescriptor(methodName, false); if (methodDescriptor == null) { throw new MadvocException(\"Public method not found: \" + actionClass.getSimpleName() + \"#\" + methodName); } return methodDescriptor.getMethod(); } \nResponse:", "ground_truth": "Resolves action method for given action class ane method name.", "predict": " public Response resolveActionMethod(final Class<?> actionClass, final String methodName) { return null; } \n\n*/\n\n/**\n * @author Ivar Conradi \u00d8sthus\n */\npublic class MethodDescriptor {\n\n\tprivate final Class<?> actionClass;\n\tprivate final String methodName;\n\tprivate final Method method;\n\n\tpublic MethodDescriptor(Class<?> actionClass, String methodName, Method method) {\n\t\tthis.actionClass = actionClass;\n\t\tthis.methodName = methodName;\n\t\tthis.method = method;\n\t}\n\n\tpublic Class<?> getActionClass() {\n\t\treturn actionClass;\n\t}\n\n\tpublic String getMethodName() {\n\t\treturn methodName;\n\t}\n\n\tpublic Method getMethod() {\n\t\treturn method;\n\t}\n}\n"}, {"ID": 1412, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime registerAction(final Class actionClass, final String actionMethodName, final ActionDefinition actionDefinition) { Method actionMethod = resolveActionMethod(actionClass, actionMethodName); return registerAction(actionClass, actionMethod, actionDefinition); } \nResponse:", "ground_truth": "Registers action with provided action class and method name.\n@see #registerAction(Class, Method, ActionDefinition)", "predict": " public ActionRuntime registerAction(final Class actionClass, final Method actionMethod, final ActionDefinition actionDefinition) { return registerAction(actionClass, actionMethod, actionDefinition, null); } \nResp public ActionRuntime registerAction(final Class actionClass, final Method actionMethod, final ActionDefinition actionDefinition, final ActionRuntime actionRuntime) { return registerAction(actionClass, actionMethod, actionDefinition, actionRuntime, null); } \nResp public ActionRuntime registerAction(final Class actionClass, final Method actionMethod, final ActionDefinition actionDefinition, final ActionRuntime actionRuntime, final String actionName) { return registerAction(actionClass, actionMethod, actionDefinition, actionRuntime, actionName, null); } \nResp public ActionRuntime registerAction(final Class actionClass, final Method actionMethod, final ActionDefinition actionDefinition, final ActionRuntime actionRuntime, final String actionName, final String actionDescription) { return registerAction(actionClass, actionMethod, actionDefinition, actionRuntime, actionName, actionDescription,"}, {"ID": 1413, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPathAlias(final String alias, final String path) { final String existing = pathAliases.put(alias, path); if (existing != null) { throw new MadvocException(\"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing); } } \nResponse:", "ground_truth": "Registers new path alias.", "predict": "\n\n*/\n\npackage madvoc.sample.service;\n\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport org.springframework.stereotype.Service;\n\nimport madvoc.sample.service.impl.PathAliasServiceImpl;\n\n/**\n * @author mariotaku\n */\n@Service\npublic class PathAliasService {\n\n\t@Inject\n\tprivate PathAliasServiceImpl impl;\n\n\tpublic void registerPathAlias(final String alias, final String path) {\n\t\timpl.registerPathAlias(alias, path);\n\t}\n\n\tpublic Map<String, String> getPathAliases() {\n\t\treturn impl.getPathAliases();\n\t}\n\n}\n"}, {"ID": 1414, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean next() { if (!looping) { return false; } if (last) { return false; } if (count == 0) { value = start; first = true; } else { value += step; first = false; } count++; last = isLastIteration(value + step); return true; } \nResponse:", "ground_truth": "Iterates to next value at the beginning of the loop.", "predict": "\n\n*/\n\npublic class Solution {\n    public int[] nextPermutation(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums;\n        }\n        int i = n - 1;\n        while (i > 0 && nums[i] >= nums[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return nums;\n        }\n        int j = n - 1;\n        while (j > 0 && nums[j] <= nums[i - 1]) {\n            j--;\n        }\n        if (j == 0) {\n            return nums;\n        }\n        int tmp = nums[i - 1];\n        nums[i - 1] = nums[j - 1];\n        nums[j - 1] = tmp;\n        i--;\n        j"}, {"ID": 1415, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CharArraySequence from(final char[] value, final int offset, final int len) { final char[] buffer = new char[value.length]; System.arraycopy(value, offset, buffer, 0, len); return new CharArraySequence(buffer); } \nResponse:", "ground_truth": "Static constructor that creates a char sequence by making a copy of provided char array.", "predict": " public static CharSequence from(final char[] value, final int offset, final int len) { final char[] buffer = new char[value.length]; System.arraycopy(value, offset, buffer, 0, len); return new CharSequence(buffer); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.generate(\"abcdefg\", 3));\n    }\n    \n    public String generate(final String s, final int numRows) {\n        if (numRows == 1) return s;\n        \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < numRows; i++) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n}"}, {"ID": 1416, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object execute() throws Exception { String methodName = ProxyTarget.targetMethodName(); Class[] argTypes = ProxyTarget.createArgumentsClassArray(); Object[] args = ProxyTarget.createArgumentsArray(); // lookup method on target object class (and not #targetClass!() Class type = _target.getClass(); Method method = type.getMethod(methodName, argTypes); // remember context classloader ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Object result; try { // change class loader Thread.currentThread().setContextClassLoader(type.getClassLoader()); // invoke result = method.invoke(_target, args); } finally { // return context classloader Thread.currentThread().setContextClassLoader(contextClassLoader); } return ProxyTarget.returnValue(result); } \nResponse:", "ground_truth": "Looks up for method in target object and invokes it using reflection.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils.Type;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariable;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariableMap;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariableMapVisitor;\nimport org.apache.commons.lang3.reflect.TypeUtils.TypeVariableVisitor;\nimport org.apache.commons.lang3.reflect.TypeUtils.Visibility;\n"}, {"ID": 1417, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final boolean matchUpperCase(final char[] uppercaseTarget) { if (ndx + uppercaseTarget.length > total) { return false; } int j = ndx; for (int i = 0; i < uppercaseTarget.length; i++, j++) { final char c = CharUtil.toUpperAscii(input[j]); if (c != uppercaseTarget[i]) { return false; } } return true; } \nResponse:", "ground_truth": "Matches char buffer given in uppercase with content at current location, that will\nbe converted to upper case to make case-insensitive matching.", "predict": "\n\npublic final boolean matchUpperCase(final char[] uppercaseTarget) {\n\tif (ndx + uppercaseTarget.length > total) {\n\t\treturn false;\n\t}\n\tint j = ndx;\n\tfor (int i = 0; i < uppercaseTarget.length; i++, j++) {\n\t\tfinal char c = CharUtil.toUpperAscii(input[j]);\n\t\tif (c != uppercaseTarget[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n*/\n\npublic static final boolean matchUpperCase(final char[] uppercaseTarget, final char[] input, final int ndx) {\n\tif (ndx + uppercaseTarget.length > input.length) {\n\t\treturn false;\n\t}\n\tint j = ndx;\n\tfor (int i = 0; i < uppercaseTarget.length; i"}, {"ID": 1418, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final CharSequence charSequence(final int from, final int to) { if (from == to) { return CharArraySequence.EMPTY; } return CharArraySequence.of(input, from, to - from); } \nResponse:", "ground_truth": "Creates char sub-sequence from the input.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.charSequence(0, 0));\n    }\n\n    public CharSequence charSequence(int from, int to) {\n        if (from == to) {\n            return CharSequence.EMPTY;\n        }\n        return CharSequence.of(input, from, to - from);\n    }\n}\n"}, {"ID": 1419, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { URLClassLoader urlClassLoader = (URLClassLoader) classLoader; URL[] allURLS = urlClassLoader.getURLs(); Collections.addAll(urls, allURLS); break; } URL classUrl = classModuleUrl(classLoader, clazz); if (classUrl != null) { urls.add(classUrl); } classUrl = classModuleUrl(classLoader, ClassPathURLs.class); if (classUrl != null) { urls.add(classUrl); } ModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor(); if (moduleDescriptor != null) { moduleDescriptor.requires().forEach(req -> { ModuleLayer.boot() .findModule(req.name()) .ifPresent(mod -> { ClassLoader moduleClassLoader = mod.getClassLoader(); if (moduleClassLoader != null) { URL url = moduleClassLoader.getResource(MANIFEST); if (url != null) { url = fixManifestUrl(url); urls.add(url); } } }); }); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); } \nResponse:", "ground_truth": "Returns urls for the classloader.\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": "\n\n*/\n\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class ClassPathURLs {\n    public static URL[] of(ClassLoader classLoader, Class clazz) {\n        if (clazz == null) {\n            clazz = ClassPathURLs.class;\n        }\n        if (classLoader == null) {\n            classLoader = clazz.getClassLoader();\n        }\n        return Stream.concat(Stream.of(classModuleUrl(classLoader, clazz)), Stream.of(classModuleUrl(classLoader, ClassPathURLs.class)))\n                .collect(Collectors.toSet()).to"}, {"ID": 1420, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Email bcc(final EmailAddress... bccs) { this.bcc = ArraysUtil.join(this.bcc, valueOrEmptyArray(bccs)); return _this(); } \nResponse:", "ground_truth": "Appends one or more BCC addresses.\n\n@param bccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " public Email bcc(final EmailAddress... bccs) { return bcc(bccs); } \n*/\n\npublic class Email {\n\tprivate String to;\n\tprivate String cc;\n\tprivate String bcc;\n\tprivate String subject;\n\tprivate String body;\n\tprivate String from;\n\tprivate String replyTo;\n\tprivate String charset;\n\tprivate String contentType;\n\tprivate String contentTransferEncoding;\n\tprivate String[] attachments;\n\tprivate String[] headers;\n\tprivate String[] headersTo;\n\tprivate String[] headersNotTo;\n\tprivate String[] headersNotToRegex;\n\tprivate String[] headersNotToRegexCaseInsensitive;\n\tprivate String[] headersNotToRegexNotCaseInsensitive;\n\tprivate String[] headersNotToRegexNotCaseInsensitiveCaseSensitive;\n\tprivate String[] headersNotToRegexNotCaseInsensitiveCaseSensitiveNotCaseInsensitive;\n\tprivate String[] headers"}, {"ID": 1421, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void register(final Class type, final TypeJsonSerializer typeJsonSerializer) { map.put(type, typeJsonSerializer); cache.clear(); } \nResponse:", "ground_truth": "Registers new serializer.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1422, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeJsonSerializer lookupSerializer(final Class type) { TypeJsonSerializer tjs = map.get(type); if (tjs == null) { if (defaultSerializerMap != null) { tjs = defaultSerializerMap.map.get(type); } } return tjs; } \nResponse:", "ground_truth": "Get type serializer from map. First the current map is used.\nIf element is missing, default map will be used, if exist.", "predict": " Response = new Response(status, headers, data); \n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonSerializationContext;\nimport com.google.gson.JsonSerializer;\n\npublic class GsonSerializer implements JsonSerializer<Object> {\n\n\tprivate Gson gson;\n\t\n\tpublic GsonSerializer() {\n\t\tgson = new Gson();\n\t}\n\t\n\t@Override\n\tpublic JsonElement serialize(Object src, Type typeOfSrc, JsonSerializationContext context) {\n\t\tJson"}, {"ID": 1423, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parseRequestStream(final InputStream inputStream, final String encoding) throws IOException { setParsed(); MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream); input.readBoundary(); while (true) { FileUploadHeader header = input.readDataHeader(encoding); if (header == null) { break; } if (header.isFile) { String fileName = header.fileName; if (fileName.length() > 0) { if (header.contentType.indexOf(\"application/x-macbinary\") > 0) { input.skipBytes(128); } } FileUpload newFile = fileUploadFactory.create(input); newFile.processStream(); if (fileName.length() == 0) { // file was specified, but no name was provided, therefore it was not uploaded if (newFile.getSize() == 0) { newFile.size = -1; } } putFile(header.formFieldName, newFile); } else { // no file, therefore it is regular form parameter. FastByteArrayOutputStream fbos = new FastByteArrayOutputStream(); input.copyAll(fbos); String value = encoding != null ? new String(fbos.toByteArray(), encoding) : new String(fbos.toByteArray()); putParameter(header.formFieldName, value); } input.skipBytes(1); input.mark(1); // read byte, but may be end of stream int nextByte = input.read(); if (nextByte == -1 || nextByte == '-') { input.reset(); break; } input.reset(); } } \nResponse:", "ground_truth": "Extracts uploaded files and parameters from the request data.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.ResponseHandler;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class MultipartRequestInput"}, {"ID": 1424, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getParameter(final String paramName) { if (requestParameters == null) { return null; } String[] values = requestParameters.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \nResponse:", "ground_truth": "Returns single value of a parameter. If parameter name is used for\nmore then one parameter, only the first one will be returned.\n\n@return parameter value, or null if not found", "predict": " public String getParameter(final String paramName) { if (responseParameters == null) { return null; } String[] values = responseParameters.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String JAVA_FILE_EXTENSION = \".java\";\n\tprivate static final String JAVA_FILE_PREFIX = \"JavaCodeGenerator\";\n\tprivate static final String JAVA_FILE_SUFFIX = \"\";\n\tprivate static final String JAVA_FILE_EXTENSION_WITH_DATE = JAVA_FILE_EXTENSION + \"-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date());\n\tprivate static final String JAVA_FILE_PREFIX_WITH_DATE = JAVA_FILE_PREFIX +"}, {"ID": 1425, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getParameterValues(final String paramName) { if (requestParameters == null) { return null; } return requestParameters.get(paramName); } \nResponse:", "ground_truth": "Returns all values all of the values the given request parameter has.", "predict": " public String[] getParameterValues(final String paramName) { if (responseParameters == null) { return null; } return responseParameters.get(paramName); } \n\n*/\n\npublic class RequestResponseParameters {\n\t\n\tprivate Map<String, String[]> requestParameters;\n\tprivate Map<String, String[]> responseParameters;\n\t\n\tpublic RequestResponseParameters() {\n\t\trequestParameters = new HashMap<String, String[]>();\n\t\tresponseParameters = new HashMap<String, String[]>();\n\t}\n\t\n\tpublic void addRequestParameter(String paramName, String[] paramValues) {\n\t\trequestParameters.put(paramName, paramValues);\n\t}\n\t\n\tpublic void addResponseParameter(String paramName, String[] paramValues) {\n\t\tresponseParameters.put(paramName, paramValues);\n\t}\n\t\n\tpublic String[] getRequestParameterValues(String paramName) {\n\t\treturn requestParameters.get(param"}, {"ID": 1426, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FileUpload getFile(final String paramName) { if (requestFiles == null) { return null; } FileUpload[] values = requestFiles.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \nResponse:", "ground_truth": "Returns uploaded file.\n@param paramName parameter name of the uploaded file\n@return uploaded file or null if parameter name not found", "predict": " public FileUpload getFile(final String paramName) { if (requestFiles == null) { return null; } FileUpload[] values = requestFiles.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class FileUpload {\n\n\tprivate String fileName;\n\tprivate String contentType;\n\tprivate byte[] content;\n\tprivate String contentId;\n\tprivate String contentDisposition;\n\tprivate String contentTransferEnc"}, {"ID": 1427, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FileUpload[] getFiles(final String paramName) { if (requestFiles == null) { return null; } return requestFiles.get(paramName); } \nResponse:", "ground_truth": "Returns all uploaded files the given request parameter has.", "predict": " public void setFiles(final String paramName, final FileUpload[] files) { if (requestFiles == null) { requestFiles = new HashMap<String, FileUpload[]>(); } requestFiles.put(paramName, files); } \n\n*/\n\npublic class FileUpload {\n\tprivate String fileName;\n\tprivate String contentType;\n\tprivate byte[] content;\n\t\n\tpublic FileUpload(String fileName, String contentType, byte[] content) {\n\t\tthis.fileName = fileName;\n\t\tthis.contentType = contentType;\n\t\tthis.content = content;\n\t}\n\t\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\t\n\tpublic String getContentType() {\n\t\treturn contentType;\n\t}\n\t\n\tpublic byte[] getContent() {\n\t\treturn content;\n\t}\n}\n"}, {"ID": 1428, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final FilterConfig filterConfig) { this.filterConfig = filterConfig; this.encoding = filterConfig.getInitParameter(\"encoding\"); if (this.encoding == null) { this.encoding = JoddCore.encoding; } this.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true); } \nResponse:", "ground_truth": "Place this filter into service.\n\n@param filterConfig The filter configuration object", "predict": "\n\n@Override\npublic void init(final FilterConfig filterConfig) {\n\tthis.filterConfig = filterConfig;\n\tthis.encoding = filterConfig.getInitParameter(\"encoding\");\n\tif (this.encoding == null) {\n\t\tthis.encoding = JoddCore.encoding;\n\t}\n\tthis.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true);\n}\n\n@Override\npublic void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n\tfinal HttpServletRequest httpRequest = (HttpServletRequest) request;\n\tfinal HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n\tfinal String encoding = httpRequest.getCharacterEncoding();\n\tfinal String contentType = httpRequest.getContentType();\n\tfinal String method = httpRequest.getMethod();\n\t"}, {"ID": 1429, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parse(final DbSqlBuilder sqlBuilder, final String template) { int length = template.length(); int last = 0; while (true) { int mark = template.indexOf('$', last); if (mark == -1) { if (last < length) { sqlBuilder.appendRaw(template.substring(last)); } break; } int escapesCount = countEscapes(template, mark); // check if escaped if (escapesCount > 0) { boolean isEscaped = escapesCount % 2 != 0; int escapesToAdd = escapesCount >> 1; sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$'); if (isEscaped) { last = mark + 1; continue; } } else { sqlBuilder.appendRaw(template.substring(last, mark)); } int end; if (template.startsWith(MACRO_TABLE, mark)) { mark += MACRO_TABLE.length(); end = findMacroEnd(template, mark); onTable(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_COLUMN, mark)) { mark += MACRO_COLUMN.length(); end = findMacroEnd(template, mark); onColumn(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_MATCH, mark)) { mark += MACRO_MATCH.length(); end = findMacroEnd(template, mark); onMatch(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_VALUE, mark)) { mark += MACRO_VALUE.length(); end = findMacroEnd(template, mark); onValue(sqlBuilder, template.substring(mark, end)); } else { mark++; // reference found end = mark; // find macro end while (end < length) { if (!isReferenceChar(template, end)) { break; } end++; } onReference(sqlBuilder, template.substring(mark, end)); end--; } end++; last = end; } } \nResponse:", "ground_truth": "Parses template and returns generated sql builder.", "predict": "\n\npublic void parse(final DbSqlBuilder sqlBuilder, final String template) { int length = template.length(); int last = 0; while (true) { int mark = template.indexOf('$', last); if (mark == -1) { if (last < length) { sqlBuilder.appendRaw(template.substring(last)); } break; } int escapesCount = countEscapes(template, mark); // check if escaped if (escapesCount > 0) { boolean isEscaped = escapesCount % 2 != 0; int escapesToAdd = escapesCount >> 1; sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$'); if (isEscaped) { last = mark + 1; continue; } } else { sqlBuilder.appendRaw(template.substring(last, mark)); } int end; if (template.startsWith(MACRO_TABLE, mark)) { mark += MACRO_TABLE.length"}, {"ID": 1430, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int findMacroEnd(final String template, final int fromIndex) { int endIndex = template.indexOf('}', fromIndex); if (endIndex == -1) { throw new DbSqlBuilderException(\"Template syntax error, some macros are not closed. Error at: '...\" + template.substring(fromIndex)); } return endIndex; } \nResponse:", "ground_truth": "Finds macros end.", "predict": "\n\npublic class DbSqlBuilderException extends RuntimeException {\n    public DbSqlBuilderException(final String message) {\n        super(message);\n    }\n}\n\n*/\n\npublic class DbSqlBuilderException extends RuntimeException {\n    public DbSqlBuilderException(final String message) {\n        super(message);\n    }\n}\n"}, {"ID": 1431, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int countEscapes(final String template, int macroIndex) { macroIndex--; int escapeCount = 0; while (macroIndex >= 0) { if (template.charAt(macroIndex) != ESCAPE_CHARACTER) { break; } escapeCount++; macroIndex--; } return escapeCount; } \nResponse:", "ground_truth": "Count escapes to the left.", "predict": "\n\n*/\n\npublic class Solution {\n    public int countEscapes(String template, int macroIndex) {\n        int escapeCount = 0;\n        while (macroIndex >= 0) {\n            if (template.charAt(macroIndex) != ESCAPE_CHARACTER) {\n                break;\n            }\n            escapeCount++;\n            macroIndex--;\n        }\n        return escapeCount;\n    }\n}\n"}, {"ID": 1432, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) { if (queryMap.isEmpty()) { return StringPool.EMPTY; } int queryMapSize = queryMap.size(); StringBand query = new StringBand(queryMapSize * 4); int count = 0; for (Map.Entry<String, ?> entry : queryMap) { String key = entry.getKey(); key = URLCoder.encodeQueryParam(key, encoding); Object value = entry.getValue(); if (value == null) { if (count != 0) { query.append('&'); } query.append(key); count++; } else { if (count != 0) { query.append('&'); } query.append(key); count++; query.append('='); String valueString = URLCoder.encodeQueryParam(value.toString(), encoding); query.append(valueString); } } return query.toString(); } \nResponse:", "ground_truth": "Builds a query string from given query map.", "predict": " public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) { if (queryMap.isEmpty()) { return StringPool.EMPTY; } int queryMapSize = queryMap.size(); StringBand query = new StringBand(queryMapSize * 4); int count = 0; for (Map.Entry<String, ?> entry : queryMap) { String key = entry.getKey(); key = URLCoder.encodeQueryParam(key, encoding); Object value = entry.getValue(); if (value == null) { if (count != 0) { query.append('&'); } query.append(key); count++; } else { if (count != 0) { query.append('&'); } query.append(key); count++; query.append('='); String valueString = URLCoder.encodeQueryParam(value.toString(), encoding); query.append(valueString); } } return query.toString(); } \n\n}\n"}, {"ID": 1433, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) { final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap(); if (StringUtil.isBlank(query)) { return queryMap; } int lastNdx = 0; while (lastNdx < query.length()) { int ndx = query.indexOf('&', lastNdx); if (ndx == -1) { ndx = query.length(); } final String paramAndValue = query.substring(lastNdx, ndx); ndx = paramAndValue.indexOf('='); if (ndx == -1) { queryMap.add(paramAndValue, null); } else { String name = paramAndValue.substring(0, ndx); if (decode) { name = URLDecoder.decodeQuery(name); } String value = paramAndValue.substring(ndx + 1); if (decode) { value = URLDecoder.decodeQuery(value); } queryMap.add(name, value); } lastNdx += paramAndValue.length() + 1; } return queryMap; } \nResponse:", "ground_truth": "Parses query from give query string. Values are optionally decoded.", "predict": " public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) { final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap(); if (StringUtil.isBlank(query)) { return queryMap; } int lastNdx = 0; while (lastNdx < query.length()) { int ndx = query.indexOf('&', lastNdx); if (ndx == -1) { ndx = query.length(); } final String paramAndValue = query.substring(lastNdx, ndx); ndx = paramAndValue.indexOf('='); if (ndx == -1) { queryMap.add(paramAndValue, null); } else { String name = paramAndValue.substring(0, ndx); if (decode) { name = URLDecoder.decodeQuery(name); } String value = paramAndValue.substring(ndx + 1); if (dec"}, {"ID": 1434, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); } \nResponse:", "ground_truth": "Makes nice header names.", "predict": " public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); } \n\n}\n"}, {"ID": 1435, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String extractMediaType(final String contentType) { int index = contentType.indexOf(';'); if (index == -1) { return contentType; } return contentType.substring(0, index); } \nResponse:", "ground_truth": "Extracts media-type from value of \"Content Type\" header.", "predict": " Response.ok().entity(extractMediaType(contentType)).build();\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ExtractMediaType {\n\n    public static void main(String[] args) {\n        String contentType = \"text/html; charset=utf-8\";\n        String mediaType = extractMediaType(contentType);\n        System.out.println(mediaType);\n    }\n\n    public static String extractMediaType(String contentType) {\n        Pattern pattern = Pattern.compile(\"(?<=;)\\\\s*(?=\\\\s*\\\\w)\");\n        Matcher matcher = pattern.matcher(contentType);\n        if (matcher.find()) {\n            return matcher.group();\n        }\n        return contentType;\n    }\n}\n"}, {"ID": 1436, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String toHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visit(renderer); return appendable.toString(); } \nResponse:", "ground_truth": "Renders node to appendable.", "predict": " public String toHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visit(renderer); return appendable.toString(); } \n\n*/\n\npublic class NodeVisitor {\n\t\n\tprivate final Appendable appendable;\n\t\n\tpublic NodeVisitor(Appendable appendable) {\n\t\tthis.appendable = appendable;\n\t}\n\t\n\tpublic void visit(Node node) {\n\t\tnode.accept(this);\n\t}\n\t\n\tpublic void visit(Node.Block node) {\n\t\tappendable.append(\"{\");\n\t\tnode.getNodes().forEach(this::visit);\n\t\tappendable.append(\"}\");\n\t}\n\t\n\tpublic void visit(Node.If node) {\n\t\tappendable.append(\"if (\");\n\t\tnode.getCondition().accept(this);\n\t\tappendable.append"}, {"ID": 1437, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String toInnerHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visitChildren(renderer); return appendable.toString(); } \nResponse:", "ground_truth": "Renders node children to appendable.", "predict": " public String toInnerHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visitChildren(renderer); return appendable.toString(); } \n\n*/\n\npublic class NodeVisitor {\n    private final Appendable appendable;\n\n    public NodeVisitor(Appendable appendable) {\n        this.appendable = appendable;\n    }\n\n    public void visit(Node node) {\n        node.accept(this);\n    }\n\n    public void visit(Node.Comment node) {\n        appendable.append(\"<!-- \").append(node.getContent()).append(\" -->\");\n    }\n\n    public void visit(Node.Text node) {\n        appendable.append(node.getContent());\n    }\n\n    public void visit(Node.Declaration node) {\n        appendable.append(\"<![CDATA[\");\n        append"}, {"ID": 1438, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void configureWith(final ServletContext servletContext) { webAppClassName = servletContext.getInitParameter(PARAM_MADVOC_WEBAPP); paramsFiles = Converter.get().toStringArray(servletContext.getInitParameter(PARAM_MADVOC_PARAMS)); madvocConfiguratorClassName = servletContext.getInitParameter(PARAM_MADVOC_CONFIGURATOR); } \nResponse:", "ground_truth": "Configures Madvoc by reading context init parameters.", "predict": "\n\n*/\n\npackage madvoc.config;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletContext;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport madvoc.MadvocException;\nimport madvoc.config.Configurator.ConfiguratorType;\nimport madvoc.config.Configurator.Param;\nimport madvoc.config.Configurator.ParamValue;\nimport madvoc.config.Configurator.ParamValue.ValueType;\nimport madvoc.config.Configurator.ParamValue.ValueType.ValueTypeEnum;\nimport madvoc.config.Configurator.ParamValue.ValueType.ValueTypeEnum.ValueTypeEnumEnum;\nimport madvoc.config.Configurator.ParamValue.ValueType.ValueTypeEnum.ValueTypeEnumEnum.ValueTypeEnumEnum"}, {"ID": 1439, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void reset() { this.ndx = 0; this.textLen = 0; this.path = new Path(); this.notFirstObject = false; if (useAltPaths) { path.altPath = new Path(); } if (classMetadataName != null) { mapToBean = createMapToBean(classMetadataName); } } \nResponse:", "ground_truth": "Resets JSON parser, so it can be reused.", "predict": " void\n*/\n\npublic class Path {\n\tprivate String path;\n\tprivate String altPath;\n\tprivate boolean notFirstObject;\n\tprivate boolean useAltPaths;\n\tprivate Map<String, Object> mapToBean;\n\t\n\tpublic Path() {\n\t\tthis.path = \"\";\n\t\tthis.altPath = \"\";\n\t\tthis.notFirstObject = false;\n\t\tthis.useAltPaths = false;\n\t\tthis.mapToBean = new HashMap<String, Object>();\n\t}\n\t\n\tpublic Path(String path) {\n\t\tthis.path = path;\n\t\tthis.altPath = \"\";\n\t\tthis.notFirstObject = false;\n\t\tthis.useAltPaths = false;\n\t\tthis.mapToBean = new HashMap<String, Object>();\n\t}\n\t\n\tpublic Path(String path, String altPath) {\n\t\tthis.path = path;\n\t\tthis"}, {"ID": 1440, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonParser lazy(final boolean lazy) { this.lazy = lazy; this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER; this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER; return this; } \nResponse:", "ground_truth": "Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\nIn the lazy mode, not everything is parsed, but some things are left lazy.\nThis way we gain performance, especially on partial usage of the whole JSON.\nHowever, be aware that parser holds the input memory until the returned\nobjects are disposed.", "predict": " Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this.lazy); } \nResp Response { return new Response(this.mapSupplier, this.listSupplier, this."}, {"ID": 1441, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class replaceWithMappedTypeForPath(final Class target) { if (mappings == null) { return target; } Class newType; // first try alt paths Path altPath = path.getAltPath(); if (altPath != null) { if (!altPath.equals(path)) { newType = mappings.get(altPath); if (newType != null) { return newType; } } } // now check regular paths newType = mappings.get(path); if (newType != null) { return newType; } return target; } \nResponse:", "ground_truth": "Replaces type with mapped type for current path.", "predict": "\n\n*/\n\npublic class Mappings {\n    private Map<Path, Class> mappings = new HashMap<Path, Class>();\n\n    public Mappings(final Map<Path, Class> mappings) {\n        this.mappings = mappings;\n    }\n\n    public Class get(final Path path) {\n        return mappings.get(path);\n    }\n}\n"}, {"ID": 1442, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> List<T> parseAsList(final String string, final Class<T> componentType) { return new JsonParser() .map(JsonParser.VALUES, componentType) .parse(string); } \nResponse:", "ground_truth": "Parses input JSON to a list with specified component type.", "predict": "\n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.reflect.TypeToken;\n\npublic class JsonParser {\n\n\tpublic static final String VALUES = \"values\";\n\tpublic static final String KEY = \"key\";\n\tpublic static final String VALUE = \"value\";\n\tpublic static final String TYPE = \"type\";\n\tpublic static final String STRING = \"string\";\n\tpublic static final String NUMBER ="}, {"ID": 1443, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <K, V> Map<K, V> parseAsMap( final String string, final Class<K> keyType, final Class<V> valueType) { return new JsonParser() .map(JsonParser.KEYS, keyType) .map(JsonParser.VALUES, valueType) .parse(string); } \nResponse:", "ground_truth": "Parses input JSON to a list with specified key and value types.", "predict": "\n\n*/\n\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class JsonParser {\n    public static final String KEYS = \"keys\";\n    public static final String VALUES = \"values\";\n\n    public static <K, V> Map<K, V> map(final String key, final Class<K> keyType, final Class<V> valueType) {\n        return map(key, keyType, valueType, null);\n    }\n\n    public static <K, V> Map<K, V> map(final String key, final Class<K> keyType, final Class<V> valueType, final Function<String, V> valueParser) {\n        return map(key, keyType, valueType, valueParser, null);\n    }\n\n    public static <K, V> Map<K, V> map(final String key, final Class<K> keyType, final Class<V> valueType,"}, {"ID": 1444, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object resolveLazyValue(Object value) { if (value instanceof Supplier) { value = ((Supplier)value).get(); } return value; } \nResponse:", "ground_truth": "Resolves lazy value during the parsing runtime.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1445, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void skipObject() { int bracketCount = 1; boolean insideString = false; while (ndx < total) { final char c = input[ndx]; if (insideString) { if (c == '\\\"' && notPrecededByEvenNumberOfBackslashes()) { insideString = false; } } else if (c == '\\\"') { insideString = true; } else if (c == '{') { bracketCount++; } else if (c == '}') { bracketCount--; if (bracketCount == 0) { ndx++; return; } } ndx++; } } \nResponse:", "ground_truth": "Skips over complete object. It is not parsed, just skipped. It will be\nparsed later, but only if required.", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int[] result = new int[k];\n        int[] count = new int[k];\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < k; j++){\n                if(arr[i] == j){\n                    count[j]++;\n                    if(count[j] > max){\n                        max = count[j];\n                    }\n                }\n            }\n        "}, {"ID": 1446, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); } \nResponse:", "ground_truth": "Parses a string.", "predict": " Generate the method-level comment for the following java Code. Code: protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); } \nResp Generate the method-level comment for the following java Code. Code: protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); } \nResp Generate the method-level comment for the following java Code. Code: protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0)"}, {"ID": 1447, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseStringContent(final char quote) { final int startNdx = ndx; // roll-out until the end of the string or the escape char while (true) { final char c = input[ndx]; if (c == quote) { // no escapes found, just use existing string ndx++; return new String(input, startNdx, ndx - 1 - startNdx); } if (c == '\\\\') { break; } ndx++; } // escapes found, proceed differently textLen = ndx - startNdx; growEmpty(); // for (int i = startNdx, j = 0; j < textLen; i++, j++) { // text[j] = input[i]; // } System.arraycopy(input, startNdx, text, 0, textLen); // escape char, process everything until the end while (true) { char c = input[ndx]; if (c == quote) { // done ndx++; final String str = new String(text, 0, textLen); textLen = 0; return str; } if (c == '\\\\') { // escape char found ndx++; c = input[ndx]; switch (c) { case '\\\"' : c = '\\\"'; break; case '\\\\' : c = '\\\\'; break; case '/' : c = '/'; break; case 'b' : c = '\\b'; break; case 'f' : c = '\\f'; break; case 'n' : c = '\\n'; break; case 'r' : c = '\\r'; break; case 't' : c = '\\t'; break; case 'u' : ndx++; c = parseUnicode(); break; default: if (looseMode) { if (c != '\\'') { c = '\\\\'; ndx--; } } else { syntaxError(\"Invalid escape char: \" + c); } } } text[textLen] = c; textLen++; growAndCopy(); ndx++; } } \nResponse:", "ground_truth": "Parses string content, once when starting quote has been consumed.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        String s = \"\\\"\\\\/\\b\\f\\n\\r\\t\\u00A0\\u2028\\u2029\\\"\";\n        System.out.println(s);\n        System.out.println(parseStringContent(s.charAt(0)));\n    }\n\n    public static String parseStringContent(char quote) {\n        StringBuilder sb = new StringBuilder();\n        while (true) {\n            char c = input[ndx];\n            if (c == quote) {\n                sb.append(c);\n                ndx++;\n                return sb.toString();\n            }\n            if (c == '\\\\') {\n                sb.append(c);\n                ndx++;\n                c = input[ndx];\n                switch (c) {\n                    case '\\\"' : c = '\\\"'; break;"}, {"ID": 1448, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected char parseUnicode() { int i0 = CharUtil.hex2int(input[ndx++]); int i1 = CharUtil.hex2int(input[ndx++]); int i2 = CharUtil.hex2int(input[ndx++]); int i3 = CharUtil.hex2int(input[ndx]); return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3); } \nResponse:", "ground_truth": "Parses 4 characters and returns unicode character.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(parseUnicode());\n    }\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n        }\n        int[] result = new int[n];\n        for(int i = 0; i < n; i++) {\n            result[i] = parseUnicode(arr[i]);\n        }\n        for(int i = 0; i < n; i++) {\n            System.out.print(result[i]);\n        }\n    }\n\n    private static int parseUnicode(int code)"}, {"ID": 1449, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseUnquotedStringContent() { final int startNdx = ndx; while (true) { final char c = input[ndx]; if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) { final int currentNdx = ndx; // done skipWhiteSpaces(); return new String(input, startNdx, currentNdx - startNdx); } ndx++; } } \nResponse:", "ground_truth": "Parses un-quoted string content.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.parseUnquotedStringContent());\n    }\n\n    public String parseUnquotedStringContent() {\n        final int startNdx = ndx;\n        while (true) {\n            final char c = input[ndx];\n            if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) {\n                final int currentNdx = ndx;\n                // done skipWhiteSpaces();\n                return new String(input, startNdx, currentNdx - startNdx);\n            }\n            ndx++;\n        }\n    }\n}\n"}, {"ID": 1450, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Number parseNumber() { final int startIndex = ndx; char c = input[ndx]; boolean isDouble = false; boolean isExp = false; if (c == '-') { ndx++; } while (true) { if (isEOF()) { break; } c = input[ndx]; if (c >= '0' && c <= '9') { ndx++; continue; } if (c <= 32) { // white space break; } if (c == ',' || c == '}' || c == ']') { // delimiter break; } if (c == '.') { isDouble = true; } else if (c == 'e' || c == 'E') { isExp = true; } ndx++; } final String value = new String(input, startIndex, ndx - startIndex); if (isDouble) { return Double.valueOf(value); } long longNumber; if (isExp) { longNumber = Double.valueOf(value).longValue(); } else { if (value.length() >= 19) { // if string is 19 chars and longer, it can be over the limit BigInteger bigInteger = new BigInteger(value); if (isGreaterThanLong(bigInteger)) { return bigInteger; } longNumber = bigInteger.longValue(); } else { longNumber = Long.parseLong(value); } } if ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) { return (int) longNumber; } return longNumber; } \nResponse:", "ground_truth": "Parses JSON numbers.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        final String input = \"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96"}, {"ID": 1451, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object parseArrayContent(Class targetType, Class componentType) { // detect special case if (targetType == Object.class) { targetType = List.class; } // continue targetType = replaceWithMappedTypeForPath(targetType); if (componentType == null && targetType != null && targetType.isArray()) { componentType = targetType.getComponentType(); } path.push(VALUES); componentType = replaceWithMappedTypeForPath(componentType); Collection<Object> target = newArrayInstance(targetType); boolean koma = false; mainloop: while (true) { skipWhiteSpaces(); char c = input[ndx]; if (c == ']') { if (koma) { syntaxError(\"Trailing comma\"); } ndx++; path.pop(); return target; } Object value = parseValue(componentType, null, null); target.add(value); skipWhiteSpaces(); c = input[ndx]; switch (c) { case ']': ndx++; break mainloop; case ',': ndx++; koma = true; break; default: syntaxError(\"Invalid char: expected ] or ,\"); } } path.pop(); if (targetType != null) { return convertType(target, targetType); } return target; } \nResponse:", "ground_truth": "Parses arrays, once when open bracket has been consumed.", "predict": " public Object parseArrayContent(Class targetType, Class componentType) { // detect special case if (targetType == Object.class) { targetType = List.class; } // continue targetType = replaceWithMappedTypeForPath(targetType); if (componentType == null && targetType != null && targetType.isArray()) { componentType = targetType.getComponentType(); } path.push(VALUES); componentType = replaceWithMappedTypeForPath(componentType); Collection<Object> target = newArrayInstance(targetType); boolean koma = false; mainloop: while (true) { skipWhiteSpaces(); char c = input[ndx]; if (c == ']') { if (koma) { syntaxError(\"Trailing comma\"); } ndx++; path.pop(); return target; } Object value = parseValue(componentType, null, null); target.add(value); skipWhiteSpaces(); c = input[ndx]; switch (c) { case ']"}, {"ID": 1452, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createEmptyCtor() { final MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC, INIT, \"()V\", null, null); mv.visitCode(); mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitMethodInsn( Opcodes.INVOKESPECIAL, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT, INIT, \"()V\", false); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); } \nResponse:", "ground_truth": "Created empty default constructor.", "predict": "\n\npublic class Test {\n    protected void createEmptyCtor() {\n        final MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC, INIT, \"()V\", null, null);\n        mv.visitCode();\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\n        mv.visitMethodInsn( Opcodes.INVOKESPECIAL, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT, INIT, \"()V\", false);\n        mv.visitInsn(Opcodes.RETURN);\n        mv.visitMaxs(1, 1);\n        mv.visitEnd();\n    }\n}\n\n*/\n"}, {"ID": 1453, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createSimpleMethodWrapper(final MethodSignatureVisitor msign) { int access = msign.getAccessFlags(); access &= ~ACC_ABSTRACT; access &= ~ACC_NATIVE; MethodVisitor mv = wd.dest.visitMethod( access, msign.getMethodName(), msign.getDescription(), msign.getAsmMethodSignature(), msign.getExceptions()); mv.visitCode(); mv.visitVarInsn(ALOAD, 0); mv.visitFieldInsn(GETFIELD, wd.thisReference, wd.wrapperRef, wd.wrapperType); loadVirtualMethodArguments(mv, msign); if (wd.wrapInterface) { mv.visitMethodInsn( INVOKEINTERFACE, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), true); } else { mv.visitMethodInsn( INVOKEVIRTUAL, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), false); } ProxettaAsmUtil.prepareReturnValue(mv, msign, 0); visitReturn(mv, msign, true); mv.visitMaxs(0, 0); mv.visitEnd(); } \nResponse:", "ground_truth": "Creates simple method wrapper without proxy.", "predict": "\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n\npublic class Wrapper"}, {"ID": 1454, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String resolveRawTypeName(String typeName) { if (typeName == null) { return null; } boolean isArray = typeName.startsWith(StringPool.LEFT_SQ_BRACKET); if (isArray) { typeName = typeName.substring(1); } String rawTypeName; if (generics.containsKey(typeName)) { rawTypeName = generics.get(typeName); } else { rawTypeName = declaredTypeGeneric.getOrDefault(typeName, typeName); } if (isArray) { rawTypeName = '[' + rawTypeName; } return rawTypeName; } \nResponse:", "ground_truth": "Resolves raw type name using the generics information from the class\nor method information.", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> generics = new HashMap<>();\n        generics.put(\"java.lang.String\", \"String\");\n        generics.put(\"java.lang.Integer\", \"Integer\");\n        generics.put(\"java.lang.Long\", \"Long\");\n        generics.put(\"java.lang.Float\", \"Float\");\n        generics.put(\"java.lang.Double\", \"Double\");\n        generics.put(\"java.lang.Short\", \"Short\");\n        generics.put(\"java.lang.Character\", \"Character\");\n        generics.put(\"java.lang.Byte\", \"Byte\");\n        generics.put(\"java.lang."}, {"ID": 1455, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) { BeanReferences references; if (refName == null || refName.isEmpty()) { references = buildDefaultReference(propertyDescriptor); } else { references = BeanReferences.of(refName); } references = references.removeDuplicateNames(); return references; } \nResponse:", "ground_truth": "Resolves reference from given values. Returns bean reference of given value or defaults\nif given name is blank.", "predict": " public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) { BeanReferences references; if (refName == null || refName.isEmpty()) { references = buildDefaultReference(propertyDescriptor); } else { references = BeanReferences.of(refName); } references = references.removeDuplicateNames(); return references; } \n\n*/\n\npublic class BeanReferences {\n\t\n\tprivate static final String DEFAULT_REFERENCE_NAME = \"default\";\n\t\n\tprivate final List<String> names;\n\t\n\tpublic BeanReferences(final List<String> names) {\n\t\tthis.names = names;\n\t}\n\t\n\tpublic BeanReferences(final String name) {\n\t\tthis.names = Arrays.asList(name);\n\t}\n\t\n\tpublic BeanReferences(final String... names) {\n\t\tthis.names = Arrays.asList(names);\n\t}\n\t\n\t"}, {"ID": 1456, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) { BeanReferences[] references = convertRefToReferences(parameterReferences); if (references == null || references.length == 0) { references = buildDefaultReferences(methodOrCtor); } if (methodOrCtor.getParameterTypes().length != references.length) { throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName()); } removeAllDuplicateNames(references); return references; } \nResponse:", "ground_truth": "Takes given parameters references and returns reference set for given method or constructor.", "predict": " public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) { BeanReferences[] references = convertRefToReferences(parameterReferences); if (references == null || references.length == 0) { references = buildDefaultReferences(methodOrCtor); } if (methodOrCtor.getParameterTypes().length != references.length) { throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName()); } removeAllDuplicateNames(references); return references; } \n\n*/\n"}, {"ID": 1457, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) { PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class); final Parameter[] parameters = methodOrCtor.getParameters(); BeanReferences[] references; final boolean hasAnnotationOnMethodOrCtor; if (petiteInject != null) { references = convertAnnValueToReferences(petiteInject.value()); hasAnnotationOnMethodOrCtor = true; } else { references = new BeanReferences[parameters.length]; hasAnnotationOnMethodOrCtor = false; } int parametersWithAnnotationCount = 0; for (int i = 0; i < parameters.length; i++) { Parameter parameter = parameters[i]; petiteInject = parameter.getAnnotation(PetiteInject.class); if (petiteInject == null) { // no annotation on argument continue; } // there is annotation on argument, override values String annotationValue = readAnnotationValue(petiteInject); if (annotationValue != null) { references[i] = BeanReferences.of(annotationValue); } parametersWithAnnotationCount++; } if (!hasAnnotationOnMethodOrCtor) { if (parametersWithAnnotationCount == 0) { return null; } if (parametersWithAnnotationCount != parameters.length) { throw new PetiteException(\"All arguments must be annotated with PetiteInject\"); } } references = updateReferencesWithDefaultsIfNeeded(methodOrCtor, references); removeAllDuplicateNames(references); return references; } \nResponse:", "ground_truth": "Extracts references from method or constructor annotation.", "predict": " public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) { PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class); final Parameter[] parameters = methodOrCtor.getParameters(); BeanReferences[] references; final boolean hasAnnotationOnMethodOrCtor; if (petiteInject != null) { references = convertAnnValueToReferences(petiteInject.value()); hasAnnotationOnMethodOrCtor = true; } else { references = new BeanReferences[parameters.length]; hasAnnotationOnMethodOrCtor = false; } int parametersWithAnnotationCount = 0; for (int i = 0; i < parameters.length; i++) { Parameter parameter = parameters[i]; petiteInject = parameter.getAnnotation(PetiteInject.class); if (petiteInject == null) { // no annotation on argument continue; } // there is annotation on argument, override values String"}, {"ID": 1458, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] buildDefaultReferences(final Executable methodOrCtor) { final boolean useParamo = petiteConfig.getUseParamo(); final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); MethodParameter[] methodParameters = null; if (useParamo) { methodParameters = Paramo.resolveParameters(methodOrCtor); } final Class[] paramTypes = methodOrCtor.getParameterTypes(); final BeanReferences[] references = new BeanReferences[paramTypes.length]; for (int j = 0; j < paramTypes.length; j++) { String[] ref = new String[lookupReferences.length]; references[j] = BeanReferences.of(ref); for (int i = 0; i < ref.length; i++) { switch (lookupReferences[i]) { case NAME: ref[i] = methodParameters != null ? methodParameters[j].getName() : null; break; case TYPE_SHORT_NAME: ref[i] = StringUtil.uncapitalize(paramTypes[j].getSimpleName()); break; case TYPE_FULL_NAME: ref[i] = paramTypes[j].getName(); break; } } } return references; } \nResponse:", "ground_truth": "Builds default method references.", "predict": "\n\n*/\n\npackage org.petite.petite.web;\n\nimport org.petite.petite.PetiteContainer;\nimport org.petite.petite.util.BeanReferences;\nimport org.petite.petite.util.BeanReferencesBuilder;\nimport org.petite.petite.util.BeanReferencesBuilderException;\nimport org.petite.petite.util.BeanReferencesBuilderFactory;\nimport org.petite.petite.util.BeanReferencesBuilderFactoryException;\nimport org.petite.petite.util.BeanReferencesBuilderFactoryRegistry;\nimport org.petite.petite.util.BeanReferencesBuilderFactoryRegistryException;\nimport org.petite.petite.util.BeanReferencesBuilderRegistry;\nimport org.petite.petite.util.BeanReferencesBuilderRegistryException;\nimport org.petite.petite.util.BeanReferencesRegistry"}, {"ID": 1459, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences buildDefaultReference(final PropertyDescriptor propertyDescriptor) { final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); final String[] references = new String[lookupReferences.length]; for (int i = 0; i < references.length; i++) { switch (lookupReferences[i]) { case NAME: references[i] = propertyDescriptor.getName(); break; case TYPE_SHORT_NAME: references[i] = StringUtil.uncapitalize(propertyDescriptor.getType().getSimpleName()); break; case TYPE_FULL_NAME: references[i] = propertyDescriptor.getType().getName(); break; } } return BeanReferences.of(references); } \nResponse:", "ground_truth": "Builds default field references.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\n\nimport io.oasp.gastronomy.restaurant.general.common.api.constants.PermissionConstants;\nimport io.oasp.gastronomy.restaurant.general.common.api.constants.RoleConstants;\nimport io.oasp.gastronomy.restaurant.general.common.api.exception.Il"}, {"ID": 1460, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeAllDuplicateNames(final BeanReferences[] allBeanReferences) { for (int i = 0; i < allBeanReferences.length; i++) { BeanReferences references = allBeanReferences[i]; allBeanReferences[i] = references.removeDuplicateNames(); } } \nResponse:", "ground_truth": "Removes duplicate names from bean references.", "predict": " void\n*/\n\npublic class RemoveDuplicateNames {\n\tpublic static void main(String[] args) {\n\t\tBeanReferences[] allBeanReferences = new BeanReferences[3];\n\t\tallBeanReferences[0] = new BeanReferences(\"Bean1\", \"Bean2\", \"Bean3\");\n\t\tallBeanReferences[1] = new BeanReferences(\"Bean1\", \"Bean2\", \"Bean3\");\n\t\tallBeanReferences[2] = new BeanReferences(\"Bean1\", \"Bean2\", \"Bean3\");\n\t\tallBeanReferences[0].removeDuplicateNames();\n\t\tallBeanReferences[1].removeDuplicateNames();\n\t\tallBeanReferences[2].removeDuplicateNames();\n\t\tfor (int i = 0; i < allBeanReferences.length; i++) {\n\t\t\tSystem.out.println(allBeanReferences[i]);\n\t\t}\n\t}\n}\n"}, {"ID": 1461, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] convertRefToReferences(final String[] references) { if (references == null) { return null; } BeanReferences[] ref = new BeanReferences[references.length]; for (int i = 0; i < references.length; i++) { ref[i] = BeanReferences.of(references[i]); } return ref; } \nResponse:", "ground_truth": "Converts single string array to an array of bean references.", "predict": " ResponseEntity<BeanReferences[]> convertRefToReferences(final String[] references) { if (references == null) { return null; } BeanReferences[] ref = new BeanReferences[references.length]; for (int i = 0; i < references.length; i++) { ref[i] = BeanReferences.of(references[i]); } return ResponseEntity.ok(ref); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n"}, {"ID": 1462, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] convertAnnValueToReferences(String value) { if (value == null) { return null; } value = value.trim(); if (value.length() == 0) { return null; } String[] refNames = Converter.get().toStringArray(value); BeanReferences[] references = new BeanReferences[refNames.length]; for (int i = 0; i < refNames.length; i++) { references[i] = BeanReferences.of(refNames[i].trim()); } return references; } \nResponse:", "ground_truth": "Converts comma-separated string into array of Bean references.", "predict": " private String convertReferencesToAnnValue(BeanReferences[] references) { if (references == null) { return null; } StringBuilder sb = new StringBuilder(); for (int i = 0; i < references.length; i++) { if (i > 0) { sb.append(\",\"); } sb.append(references[i].getName()); } return sb.toString(); } \n*/\n\npublic class BeanReferences {\n\tprivate String name;\n\t\n\tpublic BeanReferences(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic static BeanReferences of(String name) {\n\t\treturn new BeanReferences(name);\n\t}\n\t\n\tpublic static BeanReferences[] of(String[] names) {\n\t\tBeanReferences[] references = new BeanReferences[names.length];\n\t\tfor (int i = 0; i < names"}, {"ID": 1463, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void runJoy(final Consumer<JoddJoyRuntime> consumer) { final JoddJoy joddJoy = new JoddJoy(); final JoddJoyRuntime joyRuntime = joddJoy.startOnlyBackend(); joddJoy.withDb(joyDb -> setJtxManager(joyRuntime.getJtxManager())); final JtxTransaction tx = startRwTx(); final Print print = new Print(); try { print.line(\"START\", 80); print.newLine(); consumer.accept(joyRuntime); print.newLine(); print.line(\"END\", 80); if (tx != null) { tx.commit(); } } catch (Throwable throwable) { throwable.printStackTrace(); if (tx != null) { tx.rollback(); } } joddJoy.stop(); } \nResponse:", "ground_truth": "Runs JOY in standalone mode, with only backend.", "predict": "\n\n*/\n\npackage jodd.joy.jtx;\n\nimport jodd.joy.jtx.JtxTransaction;\nimport jodd.joy.jtx.JtxTransactionManager;\nimport jodd.joy.jtx.JtxTransactionManagerProvider;\nimport jodd.joy.jtx.JtxTransactionStatus;\nimport jodd.joy.jtx.JtxTransactionStatusManager;\nimport jodd.joy.jtx.JtxTransactionStatusManagerProvider;\nimport jodd.joy.jtx.JtxTransactionType;\nimport jodd.joy.jtx.JtxTransactionTypeManager;\nimport jodd.joy.jtx.JtxTransactionTypeManagerProvider;\nimport jodd.joy.jtx.JtxTransactionUtil;\nimport jodd.joy.jtx.JtxTransactionUtilProvider;\nimport jodd.joy.jtx.JtxTransactionWrapper;\nimport jodd.joy.jtx.J"}, {"ID": 1464, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method findMethod(final Class c, final String methodName) { return findDeclaredMethod(c, methodName, true); } \nResponse:", "ground_truth": "Returns method from an object, matched by name. This may be considered as\na slow operation, since methods are matched one by one.\nReturns only accessible methods.\nOnly first method is matched.\n\n@param c          class to examine\n@param methodName Full name of the method.\n@return null if method not found", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.methodA();\n    }\n\n    public void methodA() {\n        System.out.println(\"Hello World\");\n    }\n\n    public void methodB() {\n        System.out.println(\"Hello World\");\n    }\n}\n"}, {"ID": 1465, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; } \nResponse:", "ground_truth": "Finds constructor with given parameter types. First matched ctor is returned.", "predict": "\n\npublic static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; }\n\npublic static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; }\n\npublic static"}, {"ID": 1466, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class[] resolveAllInterfaces(final Class type) { Set<Class> bag = new LinkedHashSet<>(); _resolveAllInterfaces(type, bag); return bag.toArray(new Class[0]); } \nResponse:", "ground_truth": "Resolves all interfaces of a type. No duplicates are returned.\nDirect interfaces are prior the interfaces of subclasses in\nthe returned array.", "predict": " public static Class[] resolveAllInterfaces(final Class type) { Set<Class> bag = new LinkedHashSet<>(); _resolveAllInterfaces(type, bag); return bag.toArray(new Class[0]); } \n\n*/\n\npublic class InterfaceResolver {\n\tpublic static void main(String[] args) {\n\t\tClass[] interfaces = new Class[] {\n\t\t\t\tInterfaceA.class,\n\t\t\t\tInterfaceB.class,\n\t\t\t\tInterfaceC.class,\n\t\t\t\tInterfaceD.class,\n\t\t\t\tInterfaceE.class,\n\t\t\t\tInterfaceF.class,\n\t\t\t\tInterfaceG.class,\n\t\t\t\tInterfaceH.class,\n\t\t\t\tInterfaceI.class,\n\t\t\t\tInterfaceJ.class,\n\t\t\t\tInterfaceK.class,\n\t\t\t\tInterfaceL.class,\n\t\t\t\tInterfaceM.class,\n\t\t\t\tInterfaceN.class,\n\t\t\t\tInterfaceO.class,\n\t\t\t\tInterfaceP.class,\n\t\t\t\tInterfaceQ.class,\n\t\t\t\tInterfaceR.class,\n\t\t\t\tInterfaceS."}, {"ID": 1467, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean compareParameters(final Class[] first, final Class[] second) { if (first.length != second.length) { return false; } for (int i = 0; i < first.length; i++) { if (first[i] != second[i]) { return false; } } return true; } \nResponse:", "ground_truth": "Compares classes, usually method or ctor parameters.", "predict": "\n\npublic static boolean compareParameters(final Class[] first, final Class[] second) {\n\tif (first.length != second.length) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < first.length; i++) {\n\t\tif (first[i] != second[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test(args);\n    }\n\n    public void test(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n"}, {"ID": 1468, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void forceAccess(final AccessibleObject accObject) { try { if (System.getSecurityManager() == null) accObject.setAccessible(true); else { AccessController.doPrivileged((PrivilegedAction) () -> { accObject.setAccessible(true); return null; }); } } catch (SecurityException sex) { // ignore } } \nResponse:", "ground_truth": "Suppress access check against a reflection object. SecurityException is silently ignored.\nChecks first if the object is already accessible.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> methods = Arrays.stream(Main.class.getDeclaredMethods())\n                .filter(method -> Modifier.isPublic(method.getModifiers()) && Modifier.isStatic(method.getModifiers()))\n                .map(method -> method.getName() + \"(\" + method.getParameterTypes().stream().map(Class::getName).collect(Collectors.joining(\", \")) + \")\")\n                .collect(Collectors.toList());\n\n        System.out.println(\"public static void forceAccess(final AccessibleObject accObject) {\");\n        "}, {"ID": 1469, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> T newInstance(final Class<T> clazz, final Object... params) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException { if (params.length == 0) { return newInstance(clazz); } final Class<?>[] paramTypes = getClasses(params); final Constructor<?> constructor = findConstructor(clazz, paramTypes); if (constructor == null) { throw new InstantiationException(\"No constructor matched parameter types.\"); } return (T) constructor.newInstance(params); } \nResponse:", "ground_truth": "Creates new instance of given class with given optional arguments.", "predict": "\n\n*/\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ReflectionUtils {\n\n    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPE_MAP = new HashMap<Class<?>, Class<?>>();\n\n    static {\n        PRIMITIVE_TYPE_MAP.put(boolean.class, Boolean.class);\n        PRIMITIVE_TYPE_MAP.put(byte.class, Byte.class);\n        PRIMITIVE_TYPE_MAP.put(char.class, Character.class);\n        PRIMITIVE_TYPE_MAP.put(double.class, Double.class);\n        PRIMITIVE_TYPE_MAP"}, {"ID": 1470, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class[] getSuperclasses(final Class type) { int i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { i++; } Class[] result = new Class[i]; i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { result[i] = x; i++; } return result; } \nResponse:", "ground_truth": "Returns all superclasses.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.getSuperclasses(Object.class));\n    }\n\n    public Class[] getSuperclasses(Class type) {\n        int i = 0;\n        for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) {\n            i++;\n        }\n        Class[] result = new Class[i];\n        i = 0;\n        for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) {\n            result[i] = x;\n            i++;\n        }\n        return result;\n    }\n}\n"}, {"ID": 1471, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class<?> childClassOf(final Class<?> parentClass, final Object instance) { if (instance == null || instance == Object.class) { return null; } if (parentClass != null) { if (parentClass.isInterface()) { return null; } } Class<?> childClass = instance.getClass(); while (true) { Class<?> parent = childClass.getSuperclass(); if (parent == parentClass) { return childClass; } if (parent == null) { return null; } childClass = parent; } } \nResponse:", "ground_truth": "Returns the class of the immediate subclass of the given parent class for\nthe given object instance; or null if such immediate subclass cannot be\nuniquely identified for the given object instance.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.childClassOf(Object.class, null));\n    }\n\n    public Class<?> childClassOf(Class<?> parentClass, Object instance) {\n        if (instance == null || instance == Object.class) {\n            return null;\n        }\n        if (parentClass != null) {\n            if (parentClass.isInterface()) {\n                return null;\n            }\n        }\n        Class<?> childClass = instance.getClass();\n        while (true) {\n            Class<?> parent = childClass.getSuperclass();\n            if (parent == parentClass) {\n                return childClass;\n            }\n            if (parent == null) {\n                return null;\n            }\n            childClass = parent;\n        }\n    }\n}\n"}, {"ID": 1472, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JarFile jarFileOf(final Class<?> klass) { URL url = klass.getResource( \"/\" + klass.getName().replace('.', '/') + \".class\"); if (url == null) { return null; } String s = url.getFile(); int beginIndex = s.indexOf(\"file:\") + \"file:\".length(); int endIndex = s.indexOf(\".jar!\"); if (endIndex == -1) { return null; } endIndex += \".jar\".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, \"UTF-8\"); File file = new File(f); try { return file.exists() ? new JarFile(file) : null; } catch (IOException e) { throw new IllegalStateException(e); } } \nResponse:", "ground_truth": "Returns the jar file from which the given class is loaded; or null\nif no such jar file can be located.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] tokens = input.split(\" \");\n        String jarFileName = tokens[0];\n        String className = tokens[1];\n        String jarFilePath = jarFileName.replace(\".\", \"/\");\n        String classPath = jarFile"}, {"ID": 1473, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void sleep(final long ms) { try { Thread.sleep(ms); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Puts a thread to sleep, without throwing an InterruptedException.\n\n@param ms     the length of time to sleep in milliseconds", "predict": "\n\n*/\n\npublic class Sleep {\n    public static void main(String[] args) {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException iex) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n"}, {"ID": 1474, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void sleep() { try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Puts a thread to sleep forever.", "predict": "\n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Sleep {\n    public static void main(String[] args) throws InterruptedException {\n        long startTime = System.nanoTime();\n        TimeUnit.SECONDS.sleep(10);\n        long endTime = System.nanoTime();\n        long duration = endTime - startTime;\n        System.out.println(\"Duration: \" + duration);\n    }\n}\n"}, {"ID": 1475, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void wait(final Object obj) { synchronized (obj) { try { obj.wait(); } catch (InterruptedException inex) { Thread.currentThread().interrupt(); } } } \nResponse:", "ground_truth": "Waits for a object for synchronization purposes.", "predict": "\n\n*/\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Solution {\n    public static void main(String[] args) {\n        final Lock lock = new ReentrantLock();\n        final Condition condition = lock.newCondition();\n        final Object obj = new Object();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                lock.lock();\n                try {\n                    System.out.println(\"Thread 1 is waiting\");\n                    condition.await();\n                    System.out.println(\"Thread 1 is woken up\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }"}, {"ID": 1476, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ThreadFactory daemonThreadFactory(final String name, final int priority) { return new ThreadFactory() { private AtomicInteger count = new AtomicInteger(); @Override public Thread newThread(final Runnable r) { Thread thread = new Thread(r); thread.setName(name + '-' + count.incrementAndGet()); thread.setDaemon(true); thread.setPriority(priority); return thread; } }; } \nResponse:", "ground_truth": "Creates new daemon thread factory.", "predict": "\n\n*/\n\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    public static ThreadFactory daemonThreadFactory(final String name, final int priority) {\n        return new ThreadFactory() {\n            private AtomicInteger count = new AtomicInteger();\n\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread thread = new Thread(r);\n                thread.setName(name + '-' + count.incrementAndGet());\n                thread.setDaemon(true);\n                thread.setPriority(priority);\n                return thread;\n            }\n        };\n    }\n}\n"}, {"ID": 1477, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public T get() { if (!initialized) { synchronized (this) { if (!initialized) { final T t = supplier.get(); value = t; initialized = true; supplier = null; return t; } } } return value; } \nResponse:", "ground_truth": "Returns the value. Value will be computed on first call.", "predict": " @Override public T get() { if (!initialized) { synchronized (this) { if (!initialized) { final T t = supplier.get(); value = t; initialized = true; supplier = null; return t; } } } return value; } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.generate(\"abc\"));\n    }\n    \n    public String generate(String prefix) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"public class \" + prefix + \" {\");\n        sb.append(\"\\n\");\n        sb.append(\"    private \" + prefix + \"() {}\");\n        sb.append(\"\\n\");\n        sb.append(\"    public static \" + prefix + \" getInstance() {\");\n        sb.append(\"\\n\");\n        sb.append(\"        return new \" + prefix + \"();\");"}, {"ID": 1478, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitParameter(final String name, final int access) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitParameter(name, access); } } \nResponse:", "ground_truth": "Visits a parameter of this method.\n\n@param name parameter name or null if none is provided.\n@param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\nor/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\npublic class MethodVisitor extends MethodNode {\n\t\n\tprivate final List<AbstractInsnNode> instructions = new ArrayList<AbstractInsnNode>();\n\t\n\tpublic MethodVisitor(int access, String name, String desc, String signature, String[] exceptions) {\n"}, {"ID": 1479, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of this method.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "\n\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n    if (mv != null) {\n        return mv.visitAnnotation(descriptor, visible);\n    }\n    return null;\n}\n\n*/\n\npublic class AnnotationVisitorTest {\n\n    public static void main(String[] args) {\n        AnnotationVisitorTest avt = new AnnotationVisitorTest();\n        avt.run();\n    }\n\n    public void run() {\n        String[] testCases = {\n                \"public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; }\",\n                \"public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor"}, {"ID": 1480, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitTypeAnnotation( final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation on a type in the method signature.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\nTypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\nTypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\nTypeReference#THROWS}. See {@link TypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "\n\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (api < Opcodes.ASM5) {\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n        return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n    }\n    return null;\n}\n\n*/\n"}, {"ID": 1481, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitParameterAnnotation( final int parameter, final String descriptor, final boolean visible) { if (mv != null) { return mv.visitParameterAnnotation(parameter, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of a parameter this method.\n\n@param parameter the parameter index. This index must be strictly smaller than the number of\nparameters in the method descriptor, and strictly smaller than the parameter count\nspecified in {@link #visitAnnotableParameterCount}. Important note: a parameter index i\nis not required to correspond to the i'th parameter descriptor in the method\ndescriptor", "predict": " public AnnotationVisitor visitAnnotation( final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; } \nResp public AnnotationVisitor visitTypeAnnotation( final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) { if (mv != null) { return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible); } return null; } \nResp public AnnotationVisitor visitAnnotationDefault() { if (mv != null) { return mv.visitAnnotationDefault(); } return null; } \nResp public AnnotationVisitor visitAttribute( final Attribute attr) { if (mv != null) { return mv.visitAttribute(attr); } return null; } \nResp public void visitCode() { if (mv != null) { mv.visit"}, {"ID": 1482, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitFieldInsn( final int opcode, final String owner, final String name, final String descriptor) { if (mv != null) { mv.visitFieldInsn(opcode, owner, name, descriptor); } } \nResponse:", "ground_truth": "Visits a field instruction. A field instruction is an instruction that loads or stores the\nvalue of a field of an object.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nGETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n@param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).", "predict": "\n\n*/\n\npublic class MethodVisitor extends org.objectweb.asm.MethodVisitor {\n    public static final String METHOD_NAME = \"visitFieldInsn\";\n    public static final String METHOD_DESC = \"()V\";\n    public static final String METHOD_SIGNATURE = \"()V\";\n    public static final String METHOD_RETURN = \"void\";\n    public static final String METHOD_RETURN_DESC = \"()V\";\n    public static final String METHOD_RETURN_SIGNATURE = \"()V\";\n    public static final String METHOD_RETURN_TYPE = \"void\";\n    public static final String METHOD_RETURN_TYPE_DESC = \"()V\";\n    public static final String METHOD_RETURN_TYPE_SIGNATURE = \"()V\";\n    public static final String METHOD_RETURN_TYPE_NAME = \"void\";\n    public static final String METHOD_RETURN_TYPE"}, {"ID": 1483, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitMethodInsn( final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) { if (api < Opcodes.ASM5) { if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) { throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\"); } visitMethodInsn(opcode, owner, name, descriptor); return; } if (mv != null) { mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface); } } \nResponse:", "ground_truth": "Visits a method instruction. A method instruction is an instruction that invokes a method.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nINVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n@param owner the internal name of the method's owner class (see {@link\nType#getInternalName()}).\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param isInterface if the method's owner class is an interface.", "predict": "\n\n*/\n\npublic class MethodVisitor extends MethodVisitor {\n    public MethodVisitor(final int api, final MethodVisitor mv) {\n        super(api, mv);\n    }\n\n    public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        if (api < Opcodes.ASM5) {\n            if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {\n                throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\");\n            }\n            visitMethodInsn(opcode, owner, name, descriptor);\n            return;\n        }\n        if (mv != null) {\n            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n        }\n    }\n}\n"}, {"ID": 1484, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitInvokeDynamicInsn( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments); } } \nResponse:", "ground_truth": "Visits an invokedynamic instruction.\n\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param bootstrapMethodHandle the bootstrap method.\n@param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\nan {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\nType}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\nthe content of the array so a caller should expect that this array may change.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.IntInsnNode;\nimport org.objectweb.asm.tree.InvokeDynamicInsnNode;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.TypeInsnNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\npublic class MethodVisitor extends MethodNode {\n\t\n\tprivate List<AbstractInsnNode> instructions = new Array"}, {"ID": 1485, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } } \nResponse:", "ground_truth": "Visits a jump instruction. A jump instruction is an instruction that may jump to another\ninstruction.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\nIFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\nIF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n@param label the operand of the instruction to be visited. This operand is a label that\ndesignates the instruction to which the jump instruction may jump.", "predict": "\n\n*/\n\npublic class CodeGenerator {\n    private static final String JAVA_CODE_PREFIX = \"public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } }\";\n    private static final String JAVA_CODE_SUFFIX = \"}\";\n\n    public static String generate(final String className, final String methodName, final String methodDesc, final String[] code) {\n        final StringBuilder javaCode = new StringBuilder();\n        javaCode.append(JAVA_CODE_PREFIX);\n        javaCode.append(\"\\n\");\n        javaCode.append(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"}, {"ID": 1486, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) { if (mv != null) { mv.visitMultiANewArrayInsn(descriptor, numDimensions); } } \nResponse:", "ground_truth": "Visits a MULTIANEWARRAY instruction.\n\n@param descriptor an array type descriptor (see {@link Type}).\n@param numDimensions the number of dimensions of the array to allocate.", "predict": "\n\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n    if (mv != null) {\n        mv.visitMultiANewArrayInsn(descriptor, numDimensions);\n    }\n}\n\n*/\n\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n    if (mv != null) {\n        mv.visitMultiANewArrayInsn(descriptor, numDimensions);\n    }\n}\n\n/*\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    if (mv != null) {\n        mv.visitTryCatchBlock(start, end, handler, type);\n    }\n}\n*/\n\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {"}, {"ID": 1487, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitTryCatchBlock( final Label start, final Label end, final Label handler, final String type) { if (mv != null) { mv.visitTryCatchBlock(start, end, handler, type); } } \nResponse:", "ground_truth": "Visits a try catch block.\n\n@param start the beginning of the exception handler's scope (inclusive).\n@param end the end of the exception handler's scope (exclusive).\n@param handler the beginning of the exception handler's code.\n@param type the internal name of the type of exceptions handled by the handler, or {@literal\nnull} to catch any exceptions (for \"finally\" blocks).\n@throws IllegalArgumentException if one of the labels has already been visited by this visitor\n(by the {@link #visitLabel} method).", "predict": "\n\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\n    if (mv != null) {\n        mv.visitTryCatchBlock(start, end, handler, type);\n    }\n}\n\n*/\n\npublic class TryCatchBlockGenerator extends MethodVisitor {\n    private final String className;\n    private final String methodName;\n    private final String methodDesc;\n    private final StringBuilder sb = new StringBuilder();\n\n    public TryCatchBlockGenerator(final String className, final String methodName, final String methodDesc, final ClassVisitor cv) {\n        super(Opcodes.ASM5, cv.visitMethod(Opcodes.ACC_PUBLIC, methodName, methodDesc, null, null));\n        this.className = className;\n        this.methodName = methodName;\n        this.methodDesc = method"}, {"ID": 1488, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitLocalVariableAnnotation( final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitLocalVariableAnnotation( typeRef, typePath, start, end, index, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation on a local variable type.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\nTypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param start the fist instructions corresponding to the continuous ranges that make the scope\nof this local variable (inclusive).\n@param end the last instructions corresponding to the continuous ranges that make the scope of\nthis local variable (exclusive). This array must have the same size as the 'start' array.\n@param index the local variable's index in each range. This array must have the same size as\nthe 'start' array.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "\n\npublic AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\n    if (api < Opcodes.ASM5) {\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n        return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n    }\n    return null;\n}\n\n*/\n"}, {"ID": 1489, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException { final BufferedWriter bw = getBufferedWriter(writer); writeBaseAndProfileProperties(bw, properties, profiles); writeProfilePropertiesThatAreNotInTheBase(bw, properties, profiles); bw.flush(); } \nResponse:", "ground_truth": "Convert Java Properties to Jodd Props format\n\n@param writer     Writer to write Props formatted file content to\n@param properties Properties to convert to Props format\n@param profiles   Properties per profile to convert and add to the Props format\n@throws IOException On any I/O error when writing to the writer", "predict": " void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException { final BufferedWriter bw = getBufferedWriter(writer); writeBaseAndProfileProperties(bw, properties, profiles); writeProfilePropertiesThatAreNotInTheBase(bw, properties, profiles); bw.flush(); } \n\n*/\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class GenerateJavaFile {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tProperties baseProperties = new Properties();\n\t\t\tbaseProperties.load(new File(\"base.properties\"));\n\t\t\tProperties profileProperties = new Properties();\n\t\t\tprofileProperties.load(new File(\"profile.properties\"));\n\t\t\t\n\t\t\tFile baseFile = new"}, {"ID": 1490, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void processStream() throws IOException { FastByteArrayOutputStream out = new FastByteArrayOutputStream(); size = 0; if (maxFileSize == -1) { size += input.copyAll(out); } else { size += input.copyMax(out, maxFileSize + 1); // one more byte to detect larger files if (size > maxFileSize) { fileTooBig = true; valid = false; input.skipToBoundary(); return; } } data = out.toByteArray(); size = data.length; valid = true; } \nResponse:", "ground_truth": "Reads data from input stream into byte array and stores file size.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StreamProcessor {\n    private static final int BUFFER_SIZE = 1024;\n    private static final int MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1 GB\n\n    private final InputStream input;\n    private final OutputStream output;\n    private final List<String> lines = new ArrayList<>();\n    private final List<String> headers = new ArrayList<>();\n    private final List<String> footers = new ArrayList<>();\n    private final List<String> data = new ArrayList<>();\n    private boolean valid = false;\n    private boolean fileTooBig = false;\n\n    public StreamProcessor(InputStream input, OutputStream output) {\n        this.input = input;\n        this"}, {"ID": 1491, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public T next() { if (hasNext == null) { hasNext = Boolean.valueOf(moveToNext()); } if (hasNext == false) { throw new NoSuchElementException(); } if (!entityAwareMode) { hasNext = null; return newElement; } count++; T result = previousElement; previousElement = newElement; hasNext = null; return result; } \nResponse:", "ground_truth": "Returns next mapped object.", "predict": " @Override public void remove() { throw new UnsupportedOperationException(); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int k = in.nextInt();\n        int[] result = new int[k];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(arr[i] == 0){\n                continue;\n            }\n            for(int j = 0; j < k; j++){\n                result[j] = arr[i];\n            }\n            count++;\n        }\n        System.out.println(count);\n        for("}, {"ID": 1492, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean moveToNext() { if (last) { // last has been set to true, so no more rows to iterate - close everything if (closeOnEnd) { query.close(); } else { query.closeResultSet(resultSetMapper.getResultSet()); } return false; } while (true) { if (!resultSetMapper.next()) { // no more rows, no more parsing, previousElement is the last one to iterate last = true; return entityAwareMode; } // parse row Object[] objects = resultSetMapper.parseObjects(types); Object row = query.resolveRowResults(objects); newElement = (T) row; if (entityAwareMode) { if (count == 0 && previousElement == null) { previousElement = newElement; continue; } if (previousElement != null && newElement != null) { boolean equals; if (newElement.getClass().isArray()) { equals = Arrays.equals((Object[]) previousElement, (Object[]) newElement); } else { equals = previousElement.equals(newElement); } if (equals) { continue; } } } break; } return true; } \nResponse:", "ground_truth": "Moves to next element.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\npublic class Query<T> {\n\n\tprivate final String query;\n\tprivate final Map<String, Object> parameters;\n\tprivate final Class<T> clazz;\n\tprivate final List<String> types;\n\tprivate final boolean entityAwareMode;\n\tprivate final boolean closeOnEnd;\n\tprivate final boolean closeOnError;\n\tprivate final boolean closeOnSuccess;\n\tprivate final"}, {"ID": 1493, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(T[]... arrays) { Class<T> componentType = (Class<T>) arrays.getClass().getComponentType().getComponentType(); return join(componentType, arrays); } \nResponse:", "ground_truth": "Joins arrays. Component type is resolved from the array argument.", "predict": " @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(Class<T> componentType, T[]... arrays) { T[] result = (T[]) Array.newInstance(componentType, arrays.length); for (int i = 0; i < arrays.length; i++) { result[i] = arrays[i][0]; for (int j = 1; j < arrays[i].length; j++) { result[i] = join(result[i], arrays[i][j]); } } return result; } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(list.stream().collect(Collectors.joining(\", \""}, {"ID": 1494, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(Class<T> componentType, T[][] arrays) { if (arrays.length == 1) { return arrays[0]; } int length = 0; for (T[] array : arrays) { length += array.length; } T[] result = (T[]) Array.newInstance(componentType, length); length = 0; for (T[] array : arrays) { System.arraycopy(array, 0, result, length, array.length); length += array.length; } return result; } \nResponse:", "ground_truth": "Joins arrays using provided component type.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list2 = Arrays.asList(\"d\", \"e\", \"f\");\n        List<String> list3 = Arrays.asList(\"g\", \"h\", \"i\");\n        List<String> list4 = Arrays.asList(\"j\", \"k\", \"l\");\n        List<String> list5 = Arrays.asList(\"m\", \"n\", \"o\");\n        List<String> list6 = Arrays.asList(\"p\", \"q\", \"r\", \"s\");\n        List<String> list7 = Arrays.asList(\"t\", \"u\", \"v\", \"w\");"}, {"ID": 1495, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T[] resize(T[] buffer, int newSize) { Class<T> componentType = (Class<T>) buffer.getClass().getComponentType(); T[] temp = (T[]) Array.newInstance(componentType, newSize); System.arraycopy(buffer, 0, temp, 0, buffer.length >= newSize ? newSize : buffer.length); return temp; } \nResponse:", "ground_truth": "Resizes an array.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        int[] nums = {1,2,3,4,5,6,7,8,9,10};\n        int[] res = s.resize(nums, 3);\n        for (int i = 0; i < res.length; i++) {\n            System.out.print(res[i] + \" \");\n        }\n    }\n    \n    public int[] resize(int[] nums, int newSize) {\n        int[] res = new int[newSize];\n        int[] temp = new int[nums.length];\n        int i = 0;\n        int j = 0;\n        while (i < nums.length) {\n            if (i + newSize <= nums.length) {\n                for (int k = 0; k < newSize; k++) {"}, {"ID": 1496, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T[] append(T[] buffer, T newElement) { T[] t = resize(buffer, buffer.length + 1); t[buffer.length] = newElement; return t; } \nResponse:", "ground_truth": "Appends an element to array.", "predict": "\n\npublic static <T> T[] append(T[] buffer, T newElement) {\n\tT[] t = resize(buffer, buffer.length + 1);\n\tt[buffer.length] = newElement;\n\treturn t;\n}\n\n*/\n\npublic class Solution {\n    public static <T> T[] append(T[] buffer, T newElement) {\n        T[] t = resize(buffer, buffer.length + 1);\n        t[buffer.length] = newElement;\n        return t;\n    }\n\n    private static <T> T[] resize(T[] buffer, int newSize) {\n        T[] t = (T[]) new Object[newSize];\n        System.arraycopy(buffer, 0, t, 0, buffer.length);\n        return t;\n    }\n}\n"}, {"ID": 1497, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] remove(T[] buffer, int offset, int length, Class<T> componentType) { int len2 = buffer.length - length; T[] temp = (T[]) Array.newInstance(componentType, len2); System.arraycopy(buffer, 0, temp, 0, offset); System.arraycopy(buffer, offset + length, temp, offset, len2 - offset); return temp; } \nResponse:", "ground_truth": "Removes sub-array.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());\n    }\n}\n"}, {"ID": 1498, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(char[] array, char value) { for (int i = 0; i < array.length; i++) { if (array[i] == value) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds the first occurrence of an element in an array.", "predict": "\n\npublic static int indexOf(char[] array, char value) {\n    int index = -1;\n    for (int i = 0; i < array.length; i++) {\n        if (array[i] == value) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        char[] array = new char[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = in.next().charAt(0);\n        }\n        int index = indexOf(array, in.next().charAt(0));\n        System.out.println(index);\n    }\n\n    public static int index"}, {"ID": 1499, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(Object[] array, Object value) { for (int i = 0; i < array.length; i++) { if (array[i].equals(value)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds the first occurrence in an array.", "predict": "\n\npublic static int indexOf(Object[] array, Object value) {\n    for (int i = 0; i < array.length; i++) {\n        if (array[i].equals(value)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public static int indexOf(Object[] array, Object value) {\n        for (int i = 0; i < array.length; i++) {\n            if (array[i].equals(value)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        int[] nums = {1, 2, 2, 1};\n        System.out.println(Arrays.toString(s.indexOf"}, {"ID": 1500, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(byte[] array, byte[] sub, int startIndex) { return indexOf(array, sub, startIndex, array.length); } \nResponse:", "ground_truth": "Finds the first occurrence in an array from specified given position.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        byte[] array = new byte[n];\n        for(int i = 0; i < n; i++){\n            array[i] = (byte) in.nextInt();\n        }\n        byte[] sub = new byte[k];\n        for(int i = 0; i < k; i++){\n            sub[i] = (byte) in.nextInt();\n        }\n        int result = Arrays.binarySearch(array, sub, 0, k);\n        if(result < 0){\n            result = -result - 1;\n        }\n        System.out.println(result);\n    }"}, {"ID": 1501, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LagartoDOMBuilder enableXhtmlMode() { config.ignoreWhitespacesBetweenTags = false; // collect all whitespaces config.setCaseSensitive(true); // XHTML is case sensitive config.setEnableRawTextModes(false); // all tags are parsed in the same way config.enabledVoidTags = true; // list of void tags config.selfCloseVoidTags = true; // self close void tags config.impliedEndTags = false; // no implied tag ends config.setEnableConditionalComments(false); // don't enable IE conditional comments config.setParseXmlTags(false); // enable XML mode in parsing return this; } \nResponse:", "ground_truth": "Enables XHTML mode.", "predict": "\n\n*/\n\npackage com.lagarto.dom;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.lagarto.dom.html.Document;\nimport com.lagarto.dom.html.Tag;\nimport com.lagarto.dom.html.TagType;\nimport com.lagarto.dom.html.Text;\nimport com.lagarto.dom.html.impl.DocumentImpl;\nimport com.lagarto.dom.html.impl.TagImpl;\nimport com.lagarto.dom.html.impl.TextImpl;\n\npublic class TestLagartoDOMBuilder {\n\t@Test\n\tpublic void test() {\n\t\tLagartoDOMBuilder builder = new LagartoDOMBuilder();\n\t\tDocument document = builder.parse(\"<html><head><title>Test</title></head><body><p"}, {"ID": 1502, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Document parse(final char[] content) { LagartoParser lagartoParser = new LagartoParser(content); return doParse(lagartoParser); } \nResponse:", "ground_truth": "Creates DOM tree from provided content.", "predict": "\n\n*/\n\npackage com.lagarto.adapter.html.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n *\n * @author jdowling\n */\npublic class HtmlTag {\n    private String name;\n    private List<HtmlAttribute> attributes = new ArrayList<HtmlAttribute>();\n    private List<HtmlTag> children = new ArrayList<HtmlTag>();\n    private String content;\n    private String text;\n    private String closeTag;\n    private String closeTagText;\n    private String openTag;\n    private String openTagText;\n    private String closeTagTextEscaped;\n    private String openTagTextEscaped;\n    private String openTagEscaped;\n    private String closeTagEscaped;\n    private String openTagEscapedText;\n    private String closeTagEscapedText;\n    private String openTagEscapedTextEscaped"}, {"ID": 1503, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Document doParse(final LagartoParser lagartoParser) { lagartoParser.setConfig(config); LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this); lagartoParser.parse(domBuilderTagVisitor); return domBuilderTagVisitor.getDocument(); } \nResponse:", "ground_truth": "Parses the content using provided lagarto parser.", "predict": " Response = new Response();\n\npublic class Response {\n    public Document doParse(final LagartoParser lagartoParser) { lagartoParser.setConfig(config); LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this); lagartoParser.parse(domBuilderTagVisitor); return domBuilderTagVisitor.getDocument(); } \n\n}\n"}, {"ID": 1504, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void endCurrentBasicBlockWithNoSuccessor() { if (compute == COMPUTE_ALL_FRAMES) { Label nextBasicBlock = new Label(); nextBasicBlock.frame = new Frame(nextBasicBlock); nextBasicBlock.resolve(code.data, code.length); lastBasicBlock.nextBasicBlock = nextBasicBlock; lastBasicBlock = nextBasicBlock; currentBasicBlock = null; } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) { currentBasicBlock.outputStackMax = (short) maxRelativeStackSize; currentBasicBlock = null; } } \nResponse:", "ground_truth": "Ends the current basic block. This method must be used in the case where the current basic\nblock does not have any successor.\n\nWARNING: this method must be called after the currently visited instruction has been put in\n{@link #code} (if frames are computed, this method inserts a new Label to start a new basic\nblock after the current instruction).", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            ClassFileReader classFileReader = new ClassFileReader(\"Test\");\n            classFileReader.read();\n            classFileReader.print();\n            classFileReader.printInstructions();\n            classFileReader.printInstructions(true);\n            classFileReader.printInstructions(false);\n            classFileReader.printInstructions(true, true);\n            classFileReader.printInstructions(false, true);\n            classFileReader.printInstructions(true, false);\n            classFileReader.printInstructions(false, false);\n            classFileReader.printInstructions(true, true, true);\n            classFileReader.printInstructions(false, true, true);\n            classFileReader.printInstructions(true, false, true);\n            classFileReader.printInstructions(false, false, true);\n            classFileReader"}, {"ID": 1505, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void collectAttributePrototypes(final Attribute.Set attributePrototypes) { attributePrototypes.addAttributes(firstAttribute); attributePrototypes.addAttributes(firstCodeAttribute); } \nResponse:", "ground_truth": "Collects the attributes of this method into the given set of attribute prototypes.\n\n@param attributePrototypes a set of attribute prototypes.", "predict": "\n\n*/\n\npublic class AttributeCollector {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new class called \"AttributeCollector\" that contains a method called \"collectAttributePrototypes\" that takes a \"Attribute.Set\" as an argument.\n\t\t\n\t\t// TODO: Create a new class called \"AttributeCollector\" that contains a method called \"collectAttributePrototypes\" that takes a \"Attribute.Set\" as an argument.\n\t\t\n\t\t// TODO: Create a new class called \"AttributeCollector\" that contains a method called \"collectAttributePrototypes\" that takes a \"Attribute.Set\" as an argument.\n\t\t\n\t\t// TODO: Create a new class called \"AttributeCollector\" that contains a method called \"collectAttributePrototypes\" that takes a \"Attribute.Set\" as an argument.\n\t\t\n\t\t// TODO: Create a new class called \"AttributeCollector\" that contains a method called \"collectAttribute"}, {"ID": 1506, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectContext(final Object targetObject) { final Class targetType = targetObject.getClass(); final ScopeData scopeData = scopeDataInspector.inspectClassScopesWithCache(targetType); final Targets targets = new Targets(targetObject, scopeData); // inject no context scopeResolver.forEachScope(madvocScope -> madvocScope.inject(targets)); // inject special case scopeResolver.forScope(ParamsScope.class, scope -> scope.inject(targets)); // inject servlet context final ServletContext servletContext = madvocController.getApplicationContext(); if (servletContext != null) { scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); } } \nResponse:", "ground_truth": "Inject context into target.", "predict": "\n\n*/\n\npackage org.springframework.web.servlet.view.tiles3;\n\nimport org.springframework.web.servlet.view.tiles3.TilesConfigurer;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * @author Juergen Hoeller\n * @since 2.5\n */\npublic class TilesConfigurerSupport implements TilesConfigurer {\n\n\tprivate ServletContext servletContext;\n\n\n\tpublic void setServletContext(ServletContext serv"}, {"ID": 1507, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerPseudoClass(final Class<? extends PseudoClass> pseudoClassType) { PseudoClass pseudoClass; try { pseudoClass = ClassUtil.newInstance(pseudoClassType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass); } \nResponse:", "ground_truth": "Registers pseudo class.", "predict": "\n\n*/\n\npublic class PseudoClassRegistry {\n\t\n\tprivate static final Map<String, PseudoClass> PSEUDO_CLASS_MAP = new HashMap<String, PseudoClass>();\n\t\n\tpublic static PseudoClass getPseudoClass(String pseudoClassName) {\n\t\treturn PSEUDO_CLASS_MAP.get(pseudoClassName);\n\t}\n\t\n\tpublic static void registerPseudoClass(PseudoClass pseudoClass) {\n\t\tPSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass);\n\t}\n\t\n\tpublic static void registerPseudoClass(String pseudoClassName, PseudoClass pseudoClass) {\n\t\tPSEUDO_CLASS_MAP.put(pseudoClassName, pseudoClass);\n\t}\n\t\n\tpublic static PseudoClass getPseudoClass(String pseudoClassName, PseudoClass defaultP"}, {"ID": 1508, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static PseudoClass lookupPseudoClass(final String pseudoClassName) { PseudoClass pseudoClass = PSEUDO_CLASS_MAP.get(pseudoClassName); if (pseudoClass == null) { throw new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName); } return pseudoClass; } \nResponse:", "ground_truth": "Lookups pseudo class for given pseudo class name.", "predict": "\n\n*/\n\npublic class PseudoClassLookup {\n\t\n\tpublic static PseudoClass lookupPseudoClass(final String pseudoClassName) {\n\t\tPseudoClass pseudoClass = PseudoClass.lookupPseudoClass(pseudoClassName);\n\t\tif (pseudoClass == null) {\n\t\t\tthrow new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName);\n\t\t}\n\t\treturn pseudoClass;\n\t}\n\t\n}\n"}, {"ID": 1509, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void invoke(final ActionRequest actionRequest) { if (executorService == null) { throw new MadvocException(\"No action is marked as async!\"); } final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); log.debug(() -> \"Async call to: \" + actionRequest); final AsyncContext asyncContext = servletRequest.startAsync(); executorService.submit(() -> { try { actionRequest.invoke(); } catch (Exception ex) { log.error(\"Invoking async action path failed: \" , ExceptionUtil.unwrapThrowable(ex)); } finally { asyncContext.complete(); } }); } \nResponse:", "ground_truth": "Invokes an action asynchronously by submitting it to the thread pool.", "predict": "\n\n@Controller\npublic class AsyncAction {\n\t@Autowired\n\tprivate ExecutorService executorService;\n\n\t@RequestMapping(\"/async\")\n\tpublic void invoke(final ActionRequest actionRequest) {\n\t\tif (executorService == null) {\n\t\t\tthrow new MadvocException(\"No action is marked as async!\");\n\t\t}\n\t\tfinal HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\n\t\tfinal AsyncContext asyncContext = servletRequest.startAsync();\n\t\texecutorService.submit(() -> {\n\t\t\ttry {\n\t\t\t\tactionRequest.invoke();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.error(\"Invoking async action path failed: \" , ExceptionUtil.unwrapThrowable(ex));\n\t\t\t} finally {\n\t\t\t\tasyncContext.complete();\n\t\t\t}\n\t\t});\n\t}\n}\n\n@Controller\npublic class AsyncAction2 {\n\t@Autow"}, {"ID": 1510, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] getAllBeanPropertyNames(final Class type, final boolean declared) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); ArrayList<String> names = new ArrayList<>(propertyDescriptors.length); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { MethodDescriptor getter = propertyDescriptor.getReadMethodDescriptor(); if (getter != null) { if (getter.matchDeclared(declared)) { names.add(propertyDescriptor.getName()); } } else if (includeFields) { FieldDescriptor field = propertyDescriptor.getFieldDescriptor(); if (field != null) { if (field.matchDeclared(declared)) { names.add(field.getName()); } } } } return names.toArray(new String[0]); } \nResponse:", "ground_truth": "Returns all bean property names.", "predict": " public String[] getAllBeanPropertyNames(final Class type, final boolean declared) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); ArrayList<String> names = new ArrayList<>(propertyDescriptors.length); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { MethodDescriptor getter = propertyDescriptor.getReadMethodDescriptor(); if (getter != null) { if (getter.matchDeclared(declared)) { names.add(propertyDescriptor.getName()); } } else if (includeFields) { FieldDescriptor field = propertyDescriptor.getFieldDescriptor(); if (field != null) { if (field.matchDeclared(declared)) { names.add(field.getName()); } } } } return names.toArray("}, {"ID": 1511, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit() { String[] properties = resolveProperties(source, declared); for (String name : properties) { if (name == null) { continue; } if (!rules.match(name, blacklist)) { continue; } Object value; String propertyName = name; if (isSourceMap) { propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } if (declared) { value = BeanUtil.declared.getProperty(source, propertyName); } else { value = BeanUtil.pojo.getProperty(source, propertyName); } if (value == null && ignoreNullValues) { continue; } if (value instanceof String && StringUtil.isEmpty((String) value)) { continue; } visitProperty(name, value); } } \nResponse:", "ground_truth": "Starts visiting properties.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class BeanUtil {\n\n\tprivate static final String LEFT_SQ_BRACKET = \"(\";\n\tprivate static final String RIGHT_SQ_BRACKET = \")\";\n\tprivate static final String COMMA = \",\";\n\tprivate static final String COLON = \":\";\n\tprivate"}, {"ID": 1512, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final String propertyName, final String rule, final boolean include) { return propertyName.equals(rule); } \nResponse:", "ground_truth": "Compares property name to the rules.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1513, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MethodInjectionPoint[] resolve(final Class type) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method)) { // ignore setters continue; } if (method.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjectionPoints; if (list.isEmpty()) { methodInjectionPoints = MethodInjectionPoint.EMPTY; } else { methodInjectionPoints = list.toArray(new MethodInjectionPoint[0]); } return methodInjectionPoints; } \nResponse:", "ground_truth": "Resolve method injection points in given class.", "predict": " public void inject(final Object target, final Method method, final Object[] args) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method1 = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method1)) { // ignore setters continue; } if (method1.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method1); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method1, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjection"}, {"ID": 1514, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void readFilterConfigParameters(final FilterConfig filterConfig, final Object target, final String... parameters) { for (String parameter : parameters) { String value = filterConfig.getInitParameter(parameter); if (value != null) { BeanUtil.declared.setProperty(target, parameter, value); } } } \nResponse:", "ground_truth": "Reads filter config parameters and set into destination target.", "predict": " Response\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.BeanUtilsBean;\nimport org.apache.commons.beanutils.ConvertUtils;\nimport org.apache.commons.beanutils.ConvertUtilsBean;\nimport org.apache"}, {"ID": 1515, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void sendBundleFile(final HttpServletResponse resp, final File bundleFile) throws IOException { OutputStream out = resp.getOutputStream(); FileInputStream fileInputStream = new FileInputStream(bundleFile); try { StreamUtil.copy(fileInputStream, out); } finally { StreamUtil.close(fileInputStream); } } \nResponse:", "ground_truth": "Outputs bundle file to the response.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.time.DateFormatUtils;\nimport org.apache.commons.lang3.time.DateUtils;\nimport org."}, {"ID": 1516, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public File lookupBundleFile(String bundleId) { if ((mirrors != null) && (!mirrors.isEmpty())) { String realBundleId = mirrors.remove(bundleId); if (realBundleId != null) { bundleId = realBundleId; } } return createBundleFile(bundleId); } \nResponse:", "ground_truth": "Lookups for bundle file.", "predict": " public File lookupBundleFile(String bundleId) { if ((mirrors != null) && (!mirrors.isEmpty())) { String realBundleId = mirrors.remove(bundleId); if (realBundleId != null) { bundleId = realBundleId; } } return createBundleFile(bundleId); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n"}, {"ID": 1517, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public File lookupGzipBundleFile(final File file) throws IOException { String path = file.getPath() + ZipUtil.GZIP_EXT; File gzipFile = new File(path); if (!gzipFile.exists()) { if (log.isDebugEnabled()) { log.debug(\"gzip bundle to \" + path); } ZipUtil.gzip(file); } return gzipFile; } \nResponse:", "ground_truth": "Locates gzipped version of bundle file. If gzip file\ndoes not exist, it will be created.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.GZIPInputStream;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleBuilder;\nimport org.apache.commons.lang3."}, {"ID": 1518, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) { if (tempBundleId == null || sources.isEmpty()) { if (strategy == Strategy.ACTION_MANAGED) { // page does not include any resource source file actionBundles.put(actionPath, StringPool.EMPTY); } return null; } // create unique digest from the collected sources String[] sourcesArray = sources.toArray(new String[0]); for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) { sourcesArray[i] = sourcesArray[i].trim().toLowerCase(); } if (sortResources) { Arrays.sort(sourcesArray); } StringBand sb = new StringBand(sourcesArray.length); for (String src : sourcesArray) { sb.append(src); } String sourcesString = sb.toString(); String bundleId = createDigest(sourcesString); bundleId += '.' + bundleContentType; // bundle appears for the first time, create the bundle if (strategy == Strategy.ACTION_MANAGED) { actionBundles.put(actionPath, bundleId); mirrors.put(tempBundleId, bundleId); } try { createBundle(contextPath, actionPath, bundleId, sources); } catch (IOException ioex) { throw new HtmlStaplerException(\"Can't create bundle\", ioex); } return bundleId; } \nResponse:", "ground_truth": "Registers new bundle that consist of provided list of source paths.\nReturns the real bundle id, as provided one is just a temporary bundle id.", "predict": " Generate the method-level comment for the following java Code. Code: public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) { if (tempBundleId == null || sources.isEmpty()) { if (strategy == Strategy.ACTION_MANAGED) { // page does not include any resource source file actionBundles.put(actionPath, StringPool.EMPTY); } return null; } // create unique digest from the collected sources String[] sourcesArray = sources.toArray(new String[0]); for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) { sourcesArray[i] = sourcesArray[i].trim().toLowerCase(); } if (sortResources) { Arrays.sort(sourcesArray); } StringBand sb = new StringBand(sourcesArray.length); for (String src : sources"}, {"ID": 1519, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createDigest(final String source) { final DigestEngine digestEngine = DigestEngine.sha256(); final byte[] bytes = digestEngine.digest(CharUtil.toSimpleByteArray(source)); String digest = Base32.encode(bytes); if (uniqueDigestKey != null) { digest += uniqueDigestKey; } return digest; } \nResponse:", "ground_truth": "Creates digest i.e. bundle id from given string.\nReturned digest must be filename safe, for all platforms.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleComparator;\nimport org.apache.commons.lang3.tuple.TripleImpl;\nimport org.apache.commons.lang3.tuple.TripleImpl.TripleImplComparator;\nimport org.apache.commons.lang3.tuple.TripleImpl.Tri"}, {"ID": 1520, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException { final File bundleFile = createBundleFile(bundleId); if (bundleFile.exists()) { return; } StringBand sb = new StringBand(sources.size() * 2); for (String src : sources) { if (sb.length() != 0) { sb.append(StringPool.NEWLINE); } String content; if (isExternalResource(src)) { content = downloadString(src); } else { if (!downloadLocal) { // load local resource from file system String localFile = webRoot; if (src.startsWith(contextPath + '/')) { src = src.substring(contextPath.length()); } if (src.startsWith(StringPool.SLASH)) { // absolute path localFile += src; } else { // relative path localFile += '/' + FileNameUtil.getPathNoEndSeparator(actionPath) + '/' + src; } // trim link parameters, if any int qmndx = localFile.indexOf('?'); if (qmndx != -1) { localFile = localFile.substring(0, qmndx); } try { content = FileUtil.readString(localFile); } catch (IOException ioex) { if (notFoundExceptionEnabled) { throw ioex; } if (log.isWarnEnabled()) { log.warn(ioex.getMessage()); } content = null; } } else { // download local resource String localUrl = localAddressAndPort; if (src.startsWith(StringPool.SLASH)) { localUrl += contextPath + src; } else { localUrl += contextPath + FileNameUtil.getPath(actionPath) + '/' + src; } content = downloadString(localUrl); } if (content != null) { if (isCssResource(src)) { content = fixCssRelativeUrls(content, src); } } } if (content != null) { content = onResourceContent(content); sb.append(content); } } FileUtil.writeString(bundleFile, sb.toString()); if (log.isInfoEnabled()) { log.info(\"Bundle created: \" + bundleId); } } \nResponse:", "ground_truth": "Creates bundle file by loading resource files content. If bundle file already\nexist it will not be recreated!", "predict": " Generate the method-level comment for the following java Code. Code: protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException { final File bundleFile = createBundleFile(bundleId); if (bundleFile.exists()) { return; } StringBand sb = new StringBand(sources.size() * 2); for (String src : sources) { if (sb.length() != 0) { sb.append(StringPool.NEWLINE); } String content; if (isExternalResource(src)) { content = downloadString(src); } else { if (!downloadLocal) { // load local resource from file system String localFile = webRoot; if (src.startsWith(contextPath + '/')) { src = src.substring(contextPath.length()); } if (src.startsWith(StringPool.SLASH)) { // absolute path localFile += src; }"}, {"ID": 1521, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized void reset() { if (strategy == Strategy.ACTION_MANAGED) { actionBundles.clear(); mirrors.clear(); } final FindFile ff = new FindFile(); ff.includeDirs(false); ff.searchPath(new File(bundleFolder, staplerPath)); File f; int count = 0; while ((f = ff.nextFile()) != null) { f.delete(); count++; } if (log.isInfoEnabled()) { log.info(\"reset: \" + count + \" bundle files deleted.\"); } } \nResponse:", "ground_truth": "Clears all settings and removes all created bundle files from file system.", "predict": "\n\n*/\n\npublic class BundleManager {\n    private static final Logger log = Logger.getLogger(BundleManager.class.getName());\n    private static final String staplerPath = \"stapler\";\n    private static final String bundleFolder = \"bundles\";\n    private static final String bundleFolderPath = bundleFolder + \"/\";\n    private static final String bundleFolderName = bundleFolder + \"/\";\n    private static final String bundleFolderPathName = bundleFolderPath + \"/\";\n    private static final String bundleFolderNameName = bundleFolderName + \"/\";\n    private static final String bundleFolderPathNameName = bundleFolderPathName + \"/\";\n    private static final String bundleFolderNameNameName = bundleFolderNameName + \"/\";\n    private static final String bundleFolderPathNameNameName = bundleFolderPathNameName + \"/\";\n    private static final String bundleFolderNameNameNameName = bundleFolderNameNameName + \"/\";\n    private static final String bundleFolder"}, {"ID": 1522, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String fixCssRelativeUrls(final String content, final String src) { final String path = FileNameUtil.getPath(src); final Matcher matcher = CSS_URL_PATTERN.matcher(content); final StringBuilder sb = new StringBuilder(content.length()); int start = 0; while (matcher.find()) { sb.append(content, start, matcher.start()); final String matchedUrl = StringUtil.removeChars(matcher.group(1), \"'\\\"\"); final String url; if (matchedUrl.startsWith(\"https://\") || matchedUrl.startsWith(\"http://\") || matchedUrl.startsWith(\"data:\")) { url = \"url('\" + matchedUrl + \"')\"; } else { url = fixRelativeUrl(matchedUrl, path); } sb.append(url); start = matcher.end(); } sb.append(content.substring(start)); return sb.toString(); } \nResponse:", "ground_truth": "Returns the content with all relative URLs fixed.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        final String content = \"body { background-image: url('../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../"}, {"ID": 1523, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbSqlBuilder updateColumn(final Object entity, final String columnRef) { final Object value = BeanUtil.pojo.getProperty(entity, columnRef); return updateColumn(entity, columnRef, value); } \nResponse:", "ground_truth": "Reads property value and updates the DB.", "predict": " Response = updateColumn(entity, columnRef, value);\n\n*/\n\npublic class UpdateColumn extends UpdateColumnBase {\n\n    public UpdateColumn(final String tableName, final String columnRef, final Object value) {\n        super(tableName, columnRef, value);\n    }\n\n    public UpdateColumn(final String tableName, final String columnRef, final Object value, final String comment) {\n        super(tableName, columnRef, value, comment);\n    }\n\n    public UpdateColumn(final String tableName, final String columnRef, final Object value, final String comment, final String commentBefore) {\n        super(tableName, columnRef, value, comment, commentBefore);\n    }\n\n    public UpdateColumn(final String tableName, final String columnRef, final Object value, final String comment, final String commentBefore, final String commentAfter) {\n        super(tableName, columnRef, value, comment, commentBefore, commentAfter);\n    }\n\n    public Update"}, {"ID": 1524, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String createTableRefName(final Object entity) { Class type = entity.getClass(); type = (type == Class.class ? (Class) entity : type); return (type.getSimpleName() + '_'); } \nResponse:", "ground_truth": "Creates table reference name from entity type.\nAlways appends an underscore to reference name in order\nto circumvent SQL compatibility issues when entity class name\nequals to a reserved word.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1525, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public DbSession getDbSession() { log.debug(\"Requesting db TX manager session\"); final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction(); if (jtx == null) { throw new DbSqlException( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\"); } return jtx.requestResource(); } \nResponse:", "ground_truth": "Returns session from JTX transaction manager and started transaction.", "predict": " Response is generated by the following java Code. Code: @Override public Response getResponse() { log.debug(\"Requesting db TX manager response\"); final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction(); if (jtx == null) { throw new DbSqlException( \"No transaction is in progress and Response can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\"); } return jtx.requestResource(); } \n\n*/\n\npackage com.javadeobfuscator.deobfuscator.transformers.general.matcher;\n\nimport com.javadeobfuscator.deobfuscator.transformers.Transformer;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.helpers.ClassMatcher;\nimport com.javadeobfuscator.deobfuscator.transformers.general.matcher.help"}, {"ID": 1526, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T[] convertToSingleElementArray(final Object value) { T[] singleElementArray = createArray(1); singleElementArray[0] = convertType(value); return singleElementArray; } \nResponse:", "ground_truth": "Creates an array with single element.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1527, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) { if (signature == null) { return Collections.emptyMap(); } final Map<String, String> genericsMap = new HashMap<>(); SignatureReader sr = new SignatureReader(signature); StringBuilder sb = new StringBuilder(); TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) { String genericName; @Override public void visitFormalTypeParameter(final String name) { genericName = name; super.visitFormalTypeParameter(name); } @Override public void visitClassType(final String name) { if (genericName != null) { genericsMap.put(genericName, 'L' + name + ';'); genericName = null; } super.visitClassType(name); } }; sr.accept(v); return genericsMap; } \nResponse:", "ground_truth": "Parses signature for generic information and returns a map where key is generic name\nand value is raw type. Returns an empty map if signature does not define any generics.", "predict": " public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) { if (signature == null) { return Collections.emptyMap(); } final Map<String, String> genericsMap = new HashMap<>(); SignatureReader sr = new SignatureReader(signature); StringBuilder sb = new StringBuilder(); TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) { String genericName; @Override public void visitFormalTypeParameter(final String name) { genericName = name; super.visitFormalTypeParameter(name); } @Override public void visitClassType(final String name) { if (genericName != null) { genericsMap.put(genericName, 'L' + name + ';'); genericName = null; } super.visitClassType(name); } }; sr.acceptType(v); return genericsMap; } \n\n}\n"}, {"ID": 1528, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SetInjectionPoint[] resolve(final Class type, final boolean autowire) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<SetInjectionPoint> list = new ArrayList<>(); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { if (propertyDescriptor.isGetterOnly()) { continue; } Class propertyType = propertyDescriptor.getType(); if (!ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } MethodDescriptor writeMethodDescriptor = propertyDescriptor.getWriteMethodDescriptor(); FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); PetiteInject ref = null; if (writeMethodDescriptor != null) { ref = writeMethodDescriptor.getMethod().getAnnotation(PetiteInject.class); } if (ref == null && fieldDescriptor != null) { ref = fieldDescriptor.getField().getAnnotation(PetiteInject.class); } if ((!autowire) && (ref == null)) { continue; } list.add(new SetInjectionPoint(propertyDescriptor)); } SetInjectionPoint[] fields; if (list.isEmpty()) { fields = SetInjectionPoint.EMPTY; } else { fields = list.toArray(new SetInjectionPoint[0]); } return fields; } \nResponse:", "ground_truth": "Resolves all collections for given type.", "predict": " public SetInjectionPoint[] resolve(final Class type, final boolean autowire) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<SetInjectionPoint> list = new ArrayList<>(); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { if (propertyDescriptor.isGetterOnly()) { continue; } Class propertyType = propertyDescriptor.getType(); if (!ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } MethodDescriptor writeMethodDescriptor = propertyDescriptor.getWriteMethodDescriptor(); FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); PetiteInject ref = null; if (writeMethodDescriptor != null) { ref = writeMethodDescriptor.getMethod().getAnnotation(PetiteInject"}, {"ID": 1529, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) { if (!include) { return false; } if (propertyType != null) { if (!jsonSerializer.deep) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector.get().lookup(propertyType); if (propertyTypeClassDescriptor.isArray()) { return false; } if (propertyTypeClassDescriptor.isCollection()) { return false; } if (excludeMaps) { if (propertyTypeClassDescriptor.isMap()) { return false; } } } // still not excluded, continue with excluded types and type names // + excluded types if (jsonSerializer.excludedTypes != null) { for (Class excludedType : jsonSerializer.excludedTypes) { if (ClassUtil.isTypeOf(propertyType, excludedType)) { return false; } } } // + exclude type names final String propertyTypeName = propertyType.getName(); if (jsonSerializer.excludedTypeNames != null) { for (String excludedTypeName : jsonSerializer.excludedTypeNames) { if (Wildcard.match(propertyTypeName, excludedTypeName)) { return false; } } } } return true; } \nResponse:", "ground_truth": "Matches property types that are ignored by default.", "predict": " public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) { if (!include) { return false; } if (propertyType != null) { if (!jsonSerializer.deep) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector.get().lookup(propertyType); if (propertyTypeClassDescriptor.isArray()) { return false; } if (propertyTypeClassDescriptor.isCollection()) { return false; } if (excludeMaps) { if (propertyTypeClassDescriptor.isMap()) { return false; } } } // still not excluded, continue with excluded types and type names // + excluded types if (jsonSerializer.excludedTypes != null) { for (Class excludedType : jsonSerializer.excludedTypes) { if (ClassUtil.isTypeOf(propertyType, excludedType)) { return false; } } } // + exclude type names final String propertyTypeName = propertyType.get"}, {"ID": 1530, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void openConnectionForQuery() { if (connection == null) { connection = connectionProvider.getConnection(); txActive = false; // txAction should already be false try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Failed to open non-TX connection\", sex); } } } \nResponse:", "ground_truth": "Opens connection in auto-commit mode, if already not opened.", "predict": " Response is generated by the method.\n*/\n\npublic class DbSqlException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String sql;\n\tprivate String message;\n\tprivate Throwable cause;\n\t\n\tpublic DbSqlException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t\tthis.message = message;\n\t\tthis.cause = cause;\n\t}\n\t\n\tpublic DbSqlException(String message) {\n\t\tsuper(message);\n\t\tthis.message = message;\n\t}\n\t\n\tpublic DbSqlException(String sql, String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t\tthis.sql = sql;\n\t\tthis.message = message;\n\t\tthis.cause = cause;\n\t}\n\t\n\tpublic DbSqlException(String sql, String message) {\n\t\tsuper(message);\n\t\tthis."}, {"ID": 1531, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void openTx() { if (connection == null) { connection = connectionProvider.getConnection(); } txActive = true; try { connection.setAutoCommit(false); if (txMode.getIsolation() != DbTransactionMode.ISOLATION_DEFAULT) { connection.setTransactionIsolation(txMode.getIsolation()); } connection.setReadOnly(txMode.isReadOnly()); } catch (SQLException sex) { throw new DbSqlException(\"Open TX failed\", sex); } } \nResponse:", "ground_truth": "Opens a transaction.", "predict": "\n\n*/\n\npublic class DbTransactionMode {\n\tprivate String isolation;\n\tprivate boolean readOnly;\n\t\n\tpublic DbTransactionMode(String isolation, boolean readOnly) {\n\t\tthis.isolation = isolation;\n\t\tthis.readOnly = readOnly;\n\t}\n\t\n\tpublic String getIsolation() {\n\t\treturn isolation;\n\t}\n\t\n\tpublic boolean isReadOnly() {\n\t\treturn readOnly;\n\t}\n\t\n\tpublic static DbTransactionMode ISOLATION_DEFAULT = new DbTransactionMode(\"ISOLATION_DEFAULT\", false);\n\tpublic static DbTransactionMode ISOLATION_READ_COMMITTED = new DbTransactionMode(\"ISOLATION_READ_COMMITTED\", false);\n\tpublic static DbTransactionMode ISOLATION_READ_UNCOMMITTED = new DbTransactionMode(\"ISOLATION_READ_UNCOMMITTED\", false);\n\t"}, {"ID": 1532, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void closeTx() { txActive = false; try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Close TX failed\", sex); } } \nResponse:", "ground_truth": "Closes current transaction.", "predict": " void\n*/\n\npublic class DbSqlException extends Exception {\n    private static final long serialVersionUID = 1L;\n\n    public DbSqlException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n"}, {"ID": 1533, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commitTransaction() { log.debug(\"Committing transaction\"); assertTxIsActive(); try { connection.commit(); } catch (SQLException sex) { throw new DbSqlException(\"Commit TX failed\", sex); } finally { closeTx(); } } \nResponse:", "ground_truth": "Commit the current transaction, writing any unflushed changes to the database.\nTransaction mode is closed.", "predict": "\n\n*/\n\npublic class DbSqlException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String sql;\n\tprivate SQLException sqlException;\n\t\n\tpublic DbSqlException(String message, SQLException sqlException) {\n\t\tsuper(message);\n\t\tthis.sqlException = sqlException;\n\t}\n\t\n\tpublic DbSqlException(String message, String sql, SQLException sqlException) {\n\t\tsuper(message);\n\t\tthis.sql = sql;\n\t\tthis.sqlException = sqlException;\n\t}\n\t\n\tpublic String getSql() {\n\t\treturn sql;\n\t}\n\t\n\tpublic SQLException getSqlException() {\n\t\treturn sqlException;\n\t}\n}\n"}, {"ID": 1534, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void rollbackTransaction() { log.debug(\"Rolling-back transaction\"); assertTxIsActive(); try { connection.rollback(); } catch (SQLException sex) { throw new DbSqlException(\"Rollback TX failed\", sex); } finally { closeTx(); } } \nResponse:", "ground_truth": "Roll back the current transaction. Transaction mode is closed.", "predict": "\n\n*/\n\npublic class DbSqlException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String sql;\n\tprivate Throwable cause;\n\t\n\tpublic DbSqlException(String message, Throwable cause) {\n\t\tsuper(message);\n\t\tthis.cause = cause;\n\t}\n\t\n\tpublic DbSqlException(String message) {\n\t\tsuper(message);\n\t}\n\t\n\tpublic DbSqlException(Throwable cause) {\n\t\tthis.cause = cause;\n\t}\n\t\n\tpublic String getSql() {\n\t\treturn sql;\n\t}\n\t\n\tpublic Throwable getCause() {\n\t\treturn cause;\n\t}\n}\n"}, {"ID": 1535, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromFile(final File file) throws IOException { Properties prop = new Properties(); loadFromFile(prop, file); return prop; } \nResponse:", "ground_truth": "Create properties from the file.\n\n@param file properties file to load", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1536, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromString(final String data) throws IOException { Properties p = new Properties(); loadFromString(p, data); return p; } \nResponse:", "ground_truth": "Creates properties from string.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1537, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadFromString(final Properties p, final String data) throws IOException { try (ByteArrayInputStream is = new ByteArrayInputStream(data.getBytes(StringPool.ISO_8859_1))) { p.load(is); } } \nResponse:", "ground_truth": "Loads properties from string.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1538, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties subset(final Properties p, String prefix, final boolean stripPrefix) { if (StringUtil.isBlank(prefix)) { return p; } if (!prefix.endsWith(StringPool.DOT)) { prefix += '.'; } Properties result = new Properties(); int baseLen = prefix.length(); for (Object o : p.keySet()) { String key = (String) o; if (key.startsWith(prefix)) { result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key)); } } return result; } \nResponse:", "ground_truth": "Creates new Properties object from the original one, by copying\nthose properties that have specified first part of the key name.\nPrefix may be optionally stripped during this process.\n\n@param p         source properties, from which new object will be created\n@param prefix    key names prefix\n\n@return subset properties", "predict": "\n\npublic static Properties subset(final Properties p, String prefix, final boolean stripPrefix) { if (StringUtil.isBlank(prefix)) { return p; } if (!prefix.endsWith(StringPool.DOT)) { prefix += '.'; } Properties result = new Properties(); int baseLen = prefix.length(); for (Object o : p.keySet()) { String key = (String) o; if (key.startsWith(prefix)) { result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key)); } } return result; } \n\n*/\n\npublic class PropertiesSubset {\n\tpublic static void main(String[] args) {\n\t\tProperties p = new Properties();\n\t\tp.setProperty(\"a.b.c\", \"d\");\n\t\tp.setProperty(\"a.b.d\", \"e\");\n\t\tp.setProperty(\"a.b.e\", \"f\");"}, {"ID": 1539, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromClasspath(final String... rootTemplate) { Properties p = new Properties(); return loadFromClasspath(p, rootTemplate); } \nResponse:", "ground_truth": "Creates properties from classpath.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1540, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getProperty(final Map map, final String key, final String defaultValue) { Object val = map.get(key); return (val instanceof String) ? (String) val : defaultValue; } \nResponse:", "ground_truth": "Returns String property from a map.\n@see #getProperty(java.util.Map, String)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1541, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void resolveAllVariables(final Properties prop) { for (Object o : prop.keySet()) { String key = (String) o; String value = resolveProperty(prop, key); prop.setProperty(key, value); } } \nResponse:", "ground_truth": "Resolves all variables.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Properties prop = new Properties();\n        prop.setProperty(\"a\", \"1\");\n        prop.setProperty(\"b\", \"2\");\n        prop.setProperty(\"c\", \"3\");\n        prop.setProperty(\"d\", \"4\");\n        prop.setProperty(\"e\", \"5\");\n        prop.setProperty(\"f\", \"6\");\n        prop.setProperty(\"g\", \"7\");\n        prop.setProperty(\"h\", \"8\");\n        prop.setProperty(\"i\", \"9\");\n        prop.setProperty(\"j\", \"10\");\n        prop.setProperty(\"k\", \"11\");\n        prop.setProperty(\"l\", \"12\");\n        prop.setProperty(\"m\", \"13\");\n        prop.setProperty(\"n\", \"14\");\n        prop.setProperty(\"o\", \"15\");\n        prop.setProperty"}, {"ID": 1542, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveProperty(final Map map, final String key) { String value = getProperty(map, key); if (value == null) { return null; } value = stp.parse(value, macroName -> getProperty(map, macroName)); return value; } \nResponse:", "ground_truth": "Returns property with resolved variables.", "predict": "\n\n*/\n\npublic class PropertyResolver {\n\t\n\tpublic static String resolveProperty(final Map map, final String key) {\n\t\tString value = getProperty(map, key);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvalue = stp.parse(value, macroName -> getProperty(map, macroName));\n\t\treturn value;\n\t}\n\t\n\tprivate static String getProperty(final Map map, final String key) {\n\t\treturn (String) map.get(key);\n\t}\n\t\n}\n"}, {"ID": 1543, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveScope(final Class type, final String methodName) { if (scopePattern == null) { return null; } String ctx = scopePattern; ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_CLASS, type.getName()); ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_METHOD, methodName); return ctx; } \nResponse:", "ground_truth": "Resolves tx scope from scope pattern.", "predict": "\n\n*/\n\npublic class JTXCTX_PATTERN_CLASS {\n    public static final String JTXCTX_PATTERN_CLASS = \"JTXCTX_PATTERN_CLASS\";\n}\n"}, {"ID": 1544, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) { String signature = type.getName() + '#' + methodName + '%' + unique; JtxTransactionMode txMode = txmap.get(signature); if (txMode == null) { if (!txmap.containsKey(signature)) { final Method m; try { m = type.getMethod(methodName, methodArgTypes); } catch (NoSuchMethodException nsmex) { throw new ProxettaException(nsmex); } final TransactionAnnotationValues txAnn = readTransactionAnnotation(m); if (txAnn != null) { txMode = new JtxTransactionMode( txAnn.propagation(), txAnn.isolation(), txAnn.readOnly(), txAnn.timeout() ); } else { txMode = defaultTransactionMode; } txmap.put(signature, txMode); } } return txMode; } \nResponse:", "ground_truth": "Reads transaction mode from method annotation. Annotations are cached for better performances.\n@param type target class\n@param methodName target method name over which the transaction should be wrapped\n@param methodArgTypes types of arguments, used to find the method\n@param unique unique method fingerprint that contains return and arguments type information", "predict": " public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) { return getTxMode(type, methodName, methodArgTypes, unique); }\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.transaction.Transaction;\nimport javax.transaction.TransactionManager;\nimport javax.transaction.TransactionSynchronizationRegistry;\nimport javax.transaction.UserTransaction;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport com.ibm.tx.jta.TransactionManagerFactory;\nimport com.ibm.tx.jta.TransactionSynchronizationRegistryFactory;\nimport com.ibm.tx.jta.ut.util.XAR"}, {"ID": 1545, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings( {\"unchecked\"}) public void registerAnnotations(final Class<? extends Annotation>[] annotations) { this.annotations = annotations; this.annotationParsers = new AnnotationParser[annotations.length]; for (int i = 0; i < annotations.length; i++) { annotationParsers[i] = TransactionAnnotationValues.parserFor(annotations[i]); } } \nResponse:", "ground_truth": "Registers new TX annotations.", "predict": " void\n*/\n\npublic class TransactionAnnotationValues {\n    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionAnnotationValues.class);\n\n    private final Class<? extends Annotation>[] annotations;\n    private final AnnotationParser[] annotationParsers;\n\n    public TransactionAnnotationValues(final Class<? extends Annotation>[] annotations, final AnnotationParser[] annotationParsers) {\n        this.annotations = annotations;\n        this.annotationParsers = annotationParsers;\n    }\n\n    public static TransactionAnnotationValues parserFor(final Class<? extends Annotation> annotation) {\n        final AnnotationParser annotationParser = AnnotationParser.parserFor(annotation);\n        return new TransactionAnnotationValues(annotationParser.getAnnotations(), new AnnotationParser[] { annotationParser });\n    }\n\n    public static TransactionAnnotationValues parserFor(final Class<? extends Annotation>[] annotations) {\n        final AnnotationParser"}, {"ID": 1546, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TransactionAnnotationValues readTransactionAnnotation(final Method method) { for (AnnotationParser annotationParser : annotationParsers) { TransactionAnnotationValues tad = TransactionAnnotationValues.of(annotationParser, method); if (tad != null) { return tad; } } return null; } \nResponse:", "ground_truth": "Finds TX annotation.", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\n\n@Path(\"/\")\npublic class TransactionAnnotationValues {\n\n\tprivate static final Joiner JOINER = Joiner.on(\", \");\n\n\tprivate final List<AnnotationParser> annotationParsers;\n\n\tpublic TransactionAnnotationValues(final List<AnnotationParser> annotationParsers) {\n\t\tthis.annotationParsers = annotationParsers;\n\t}\n\n\t@GET\n\t@Path(\"/\")\n\t@Produces("}, {"ID": 1547, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final Node node) { // match element name with node name if (!matchElement(node)) { return false; } // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case ATTRIBUTE: if (!((AttributeSelector) selector).accept(node)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(node)) { return false; } break; case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(node)) { return false; } break; } } return true; } \nResponse:", "ground_truth": "Accepts single node.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.w3c.dom.Node;\n\npublic class NodeSelector {\n\t\n\tprivate List<Selector> selectors;\n\t\n\tpublic NodeSelector() {\n\t\tselectors = new ArrayList<Selector>();\n\t}\n\t\n\tpublic void addSelector(Selector selector) {\n\t\tselectors.add(selector);\n\t}\n\t\n\tpublic boolean accept(Node node) {\n\t\tfor (Selector selector : selectors) {\n\t\t\tif (!selector.accept(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic int selectorsCount() {\n\t\treturn selectors.size();\n\t}\n\t\n\tpublic Selector getSelector(int index) {\n\t\treturn selectors.get(index);\n\t}\n\t"}, {"ID": 1548, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean matchElement(final Node node) { if (node.getNodeType() != Node.NodeType.ELEMENT) { return false; } String element = getElement(); String nodeName = node.getNodeName(); return element.equals(StringPool.STAR) || element.equals(nodeName); } \nResponse:", "ground_truth": "Matches element to css selector. All non-element types are ignored.", "predict": " Generate the method-level comment for the following java Code. Code: protected boolean matchElement(final Node node) { if (node.getNodeType() != Node.NodeType.ELEMENT) { return false; } String element = getElement(); String nodeName = node.getNodeName(); return element.equals(StringPool.STAR) || element.equals(nodeName); } \n\n*/\n\npublic class ElementMatcher {\n\t\n\tprivate String element;\n\t\n\tpublic ElementMatcher(String element) {\n\t\tthis.element = element;\n\t}\n\t\n\tpublic boolean matchElement(Node node) {\n\t\tif (node.getNodeType() != Node.NodeType.ELEMENT) {\n\t\t\treturn false;\n\t\t}\n\t\tString nodeName = node.getNodeName();\n\t\treturn element.equals(StringPool.STAR) || element.equals(nodeName);\n\t}\n\t\n}\n"}, {"ID": 1549, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean accept(final List<Node> currentResults, final Node node, final int index) { // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(currentResults, node, index)) { return false; } break; default: } } return true; } \nResponse:", "ground_truth": "Accepts node within current results.", "predict": " public boolean accept(final List<Node> currentResults, final Node node, final int index) { // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(currentResults, node, index)) { return false; } break; default: } } return true; } \n\n}\n"}, {"ID": 1550, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String unescape(final String value) { if (value.indexOf('\\\\') == -1) { return value; } return StringUtil.remove(value, '\\\\'); } \nResponse:", "ground_truth": "Unescapes CSS string by removing all backslash characters from it.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.unescape(\"\\\\u0041\\\\u0042\\\\u0043\"));\n    }\n\n    public String unescape(String str) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (c == '\\\\') {\n                if (i + 1 < str.length()) {\n                    char c2 = str.charAt(i + 1);\n                    if (c2 == 'u') {\n                        if (i + 5 < str.length()) {\n                            char c3 = str.charAt(i + 2);\n                            char c4 = str.charAt(i + 3);\n                            char c5 = str.charAt(i +"}, {"ID": 1551, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String[] buildJrePackages(final int javaVersionNumber) { final ArrayList<String> packages = new ArrayList<>(); switch (javaVersionNumber) { case 9: case 8: case 7: case 6: case 5: // in Java1.5, the apache stuff moved packages.add(\"com.sun.org.apache\"); // fall through... case 4: if (javaVersionNumber == 4) { packages.add(\"org.apache.crimson\"); packages.add(\"org.apache.xalan\"); packages.add(\"org.apache.xml\"); packages.add(\"org.apache.xpath\"); } packages.add(\"org.ietf.jgss\"); packages.add(\"org.w3c.dom\"); packages.add(\"org.xml.sax\"); // fall through... case 3: packages.add(\"org.omg\"); packages.add(\"com.sun.corba\"); packages.add(\"com.sun.jndi\"); packages.add(\"com.sun.media\"); packages.add(\"com.sun.naming\"); packages.add(\"com.sun.org.omg\"); packages.add(\"com.sun.rmi\"); packages.add(\"sunw.io\"); packages.add(\"sunw.util\"); // fall through... case 2: packages.add(\"com.sun.java\"); packages.add(\"com.sun.image\"); // fall through... case 1: default: // core stuff packages.add(\"sun\"); packages.add(\"java\"); packages.add(\"javax\"); break; } return packages.toArray(new String[0]); } \nResponse:", "ground_truth": "Builds a set of java core packages.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Java9 {\n\n    public static void main(String[] args) {\n        List<String> packages = new ArrayList<>();\n        packages.add(\"sun\");\n        packages.add(\"java\");\n        packages.add(\"javax\");\n        packages.add(\"com.sun.java\");\n        packages.add(\"com.sun.image\");\n        packages.add(\"sunw.io\");\n        packages.add(\"sunw.util\");\n        packages.add(\"sunw.util.concurrent\");\n        packages.add(\"sunw.util.concurrent.atomic\");\n        packages.add(\"sunw.util.concurrent.locks\");\n        packages.add(\"sunw.util.concurrent.locks.reentrant\");\n        packages.add(\"sunw.util.concurrent.locks"}, {"ID": 1552, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <T extends Node> T cloneTo(final T dest) { // dest.nodeValue = nodeValue; // already in clone implementations! dest.parentNode = parentNode; if (attributes != null) { dest.attributes = new ArrayList<>(attributes.size()); for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) { Attribute attr = attributes.get(i); dest.attributes.add(attr.clone()); } } if (childNodes != null) { dest.childNodes = new ArrayList<>(childNodes.size()); for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node child = childNodes.get(i); Node childClone = child.clone(); childClone.parentNode = dest; // fix parent! dest.childNodes.add(childClone); } } return dest; } \nResponse:", "ground_truth": "Copies all non-final values to the empty cloned object.\nCache-related values are not copied.", "predict": " public <T extends Node> T cloneTo(final T dest) { // dest.nodeValue = nodeValue; // already in clone implementations! dest.parentNode = parentNode; if (attributes != null) { dest.attributes = new ArrayList<>(attributes.size()); for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) { Attribute attr = attributes.get(i); dest.attributes.add(attr.clone()); } } if (childNodes != null) { dest.childNodes = new ArrayList<>(childNodes.size()); for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node child = childNodes.get(i); Node childClone = child.clone(); childClone.parentNode = dest; // fix parent! dest.childNodes.add(childClone); } } return dest; } \n\n}"}, {"ID": 1553, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void detachFromParent() { if (parentNode == null) { return; } if (parentNode.childNodes != null) { parentNode.childNodes.remove(siblingIndex); parentNode.reindexChildren(); } parentNode = null; } \nResponse:", "ground_truth": "Removes this node from DOM tree.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.detachFromParent();\n    }\n    \n    public void detachFromParent() {\n        if (parentNode == null) {\n            return;\n        }\n        if (parentNode.childNodes != null) {\n            parentNode.childNodes.remove(siblingIndex);\n            parentNode.reindexChildren();\n        }\n        parentNode = null;\n    }\n}\n"}, {"ID": 1554, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addChild(final Node... nodes) { if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode = this; initChildNodes(node); childNodes.add(node); } reindexChildrenOnAdd(nodes.length); } \nResponse:", "ground_truth": "Appends several child nodes at once.\nReindex is done only once, after all children are added.", "predict": " public void addChild(final Node... nodes) { if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode = this; initChildNodes(node); childNodes.add(node); } reindexChildrenOnAdd(nodes.length); } \n\n*/\n\npublic class AddChild extends AbstractJavaMethod {\n\tpublic static final String METHOD_NAME = \"addChild\";\n\t\n\tpublic AddChild(final String className, final String methodName, final String methodSignature, final String[] exceptions) {\n\t\tsuper(METHOD_NAME, className, methodName, methodSignature, exceptions);\n\t}\n\t\n\t@Override\n\tpublic String getMethodBody() {\n\t\treturn \"if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode"}, {"ID": 1555, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertChild(final Node node, final int index) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); } \nResponse:", "ground_truth": "Inserts node at given index.", "predict": " public void insertChild(final Node node, final int index) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); } \nResp public void insertChild(final Node node, final int index, final boolean replace) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); } \nResp public void insertChild(final Node node, final int index, final boolean replace, final boolean clone) { node.detachFromParent(); node.parentNode = this; try { initChildNodes"}, {"ID": 1556, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertBefore(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChild, siblingIndex); } \nResponse:", "ground_truth": "Inserts node before provided node.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n        root.left.left.left = new Node(8);\n        root.left.left.right = new Node(9);\n        root.left.right.left = new Node(10);\n        root.left.right.right = new Node(11);\n        root.right.left.left = new Node(12);\n        root.right.left.right = new Node(13);\n        root.right.right.left = new Node(14);\n        root.right."}, {"ID": 1557, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertBefore(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChilds, siblingIndex); } \nResponse:", "ground_truth": "Inserts several child nodes before provided node.", "predict": "\n\n*/\n\npublic class InsertBefore {\n\tpublic static void main(String[] args) {\n\t\tNode[] newChilds = new Node[3];\n\t\tnewChilds[0] = new Node(\"a\");\n\t\tnewChilds[1] = new Node(\"b\");\n\t\tnewChilds[2] = new Node(\"c\");\n\t\tNode refChild = new Node(\"d\");\n\t\tNode parentNode = new Node(\"e\");\n\t\tparentNode.insertChild(newChilds, 0);\n\t\tSystem.out.println(parentNode.toString());\n\t}\n}\n"}, {"ID": 1558, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertAfter(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChild); } else { refChild.parentNode.insertChild(newChild, siblingIndex); } } \nResponse:", "ground_truth": "Inserts node after provided node.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n        root.left.left.left = new Node(8);\n        root.left.left.right = new Node(9);\n        root.left.right.left = new Node(10);\n        root.left.right.right = new Node(11);\n        root.right.left.left = new Node(12);\n        root.right.left.right = new Node(13);\n        root.right.right.left = new Node(14);\n        root.right."}, {"ID": 1559, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertAfter(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChilds); } else { refChild.parentNode.insertChild(newChilds, siblingIndex); } } \nResponse:", "ground_truth": "Inserts several child nodes after referent node.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n        root.left.left.left = new Node(8);\n        root.left.left.right = new Node(9);\n        root.left.right.left = new Node(10);\n        root.left.right.right = new Node(11);\n        root.right.left.left = new Node(12);\n        root.right.left.right = new Node(13);\n        root.right.right.left = new Node(14);\n        root.right."}, {"ID": 1560, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeAllChilds() { List<Node> removedNodes = childNodes; childNodes = null; childElementNodes = null; childElementNodesCount = 0; if (removedNodes != null) { for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) { Node removedNode = removedNodes.get(i); removedNode.detachFromParent(); } } } \nResponse:", "ground_truth": "Removes all child nodes. Each child node will be detached from this parent.", "predict": "\n\n*/\n\npublic class RemoveAllChilds extends AbstractJavaMethod {\n\n\tpublic String getMethodName() {\n\t\treturn \"removeAllChilds\";\n\t}\n\n\tpublic String getMethodDescription() {\n\t\treturn \"Generate the method-level comment for the following java Code. Code: public void removeAllChilds() { List<Node> removedNodes = childNodes; childNodes = null; childElementNodes = null; childElementNodesCount = 0; if (removedNodes != null) { for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) { Node removedNode = removedNodes.get(i); removedNode.detachFromParent(); } } } \";\n\t}\n\n\tpublic String getMethodReturnType() {\n\t\treturn \"void\";\n\t}\n\n\tpublic String getMethodParams() {\n\t\treturn \"\";\n\t}\n\n\tpublic String getMethodBody"}, {"ID": 1561, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node findChildNodeWithName(final String name) { if (childNodes == null) { return null; } for (final Node childNode : childNodes) { if (childNode.getNodeName().equals(name)) { return childNode; } } return null; } \nResponse:", "ground_truth": "Finds the first child node with given node name.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1562, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node[] filterChildNodes(final Predicate<Node> nodePredicate) { if (childNodes == null) { return new Node[0]; } return childNodes.stream() .filter(nodePredicate) .toArray(Node[]::new); } \nResponse:", "ground_truth": "Filters child nodes.", "predict": "\n\npublic Node[] filterChildNodes(final Predicate<Node> nodePredicate) {\n    if (childNodes == null) {\n        return new Node[0];\n    }\n    return childNodes.stream()\n        .filter(nodePredicate)\n        .toArray(Node[]::new);\n}\n\n*/\n\npublic class FilterChildNodes {\n\n    public static void main(String[] args) {\n        Node[] nodes = new Node[] {\n            new Node(\"1\"),\n            new Node(\"2\"),\n            new Node(\"3\"),\n            new Node(\"4\"),\n            new Node(\"5\"),\n            new Node(\"6\"),\n            new Node(\"7\"),\n            new Node(\"8\"),\n            new Node(\"9\"),\n            new Node(\"10\"),\n            new Node(\"11\"),\n            new Node(\"12\"),\n            new Node(\"13\"),\n            new Node(\"14\"),\n            new Node(\"15\"),\n            new"}, {"ID": 1563, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean check() { if (childNodes == null) { return true; } // children int siblingElementIndex = 0; for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); if (childNode.siblingIndex != i) { return false; } if (childNode.getNodeType() == NodeType.ELEMENT) { if (childNode.siblingElementIndex != siblingElementIndex) { return false; } siblingElementIndex++; } } if (childElementNodesCount != siblingElementIndex) { return false; } // child element nodes if (childElementNodes != null) { if (childElementNodes.length != childElementNodesCount) { return false; } int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { if (childElementNodes[child.siblingElementIndex] != child) { return false; } } } } // sibling names if (siblingNameIndex != -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { if (sibling.siblingNameIndex != index++) { return false; } } } } // process children for (Node childNode : childNodes) { if (!childNode.check()) { return false; } } return true; } \nResponse:", "ground_truth": "Checks the health of child nodes. Useful during complex tree manipulation,\nto check if everything is OK. Not optimized for speed, should be used just\nfor testing purposes.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test();\n    }\n\n    public void test() {\n        Node root = new Node(\"root\");\n        root.addChild(new Node(\"child1\"));\n        root.addChild(new Node(\"child2\"));\n        root.addChild(new Node(\"child3\"));\n        root.addChild(new Node(\"child4\"));\n        root.addChild(new Node(\"child5\"));\n        root.addChild(new Node(\"child6\"));\n        root.addChild(new Node(\"child7\"));\n        root.addChild(new Node(\"child8\"));\n        root.addChild(new Node(\"child9\"));\n        root.addChild(new Node(\"child10\"));\n        "}, {"ID": 1564, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initChildElementNodes() { if (childElementNodes == null) { childElementNodes = new Element[childElementNodesCount]; int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { childElementNodes[child.siblingElementIndex] = (Element) child; } } } } \nResponse:", "ground_truth": "Initializes list of child elements.", "predict": " Response is generated by the following java Code. Code: public class Response { private String response; private String responseCode; private String responseMessage; private String responseMessageCode; private String responseMessageSubCode; private String responseMessageSubCodeValue; private String responseMessageSubCodeDescription; private String responseMessageCode; private String responseMessageCodeValue; private String responseMessageCodeDescription; private String responseMessageSubCode; private String responseMessageSubCodeValue; private String responseMessageSubCodeDescription; private String responseMessage; private String responseMessageCodeValue; private String responseMessageCodeDescription; private String responseMessageSubCodeValue; private String responseMessageSubCodeDescription; private String responseMessageValue; private String responseMessageCodeValue; private String responseMessageCodeDescription; private String responseMessageValue; private String responseMessageCodeDescription; private String responseMessageValue; private String responseMessageCodeDescription; private String responseMessageValue; private String responseMessageCodeDescription; private String responseMessageValue; private String responseMessageCodeDescription; private String responseMessageValue; private String"}, {"ID": 1565, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initSiblingNames() { if (siblingNameIndex == -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { sibling.siblingNameIndex = index++; } } } } \nResponse:", "ground_truth": "Initializes siblings elements of the same name.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Node root = s.generateTrees(3);\n        s.printTree(root);\n    }\n\n    public Node generateTrees(int n) {\n        if (n == 0) return null;\n        return generateTrees(1, n);\n    }\n\n    public Node generateTrees(int start, int end) {\n        if (start > end) return null;\n        if (start == end) return new Node(start);\n        Node left = generateTrees(start, (end + 1) / 2);\n        Node right = generateTrees((end + 1) / 2 + 1, end);\n        Node root = new Node(start);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n\n    public void printTree(Node root) {"}, {"ID": 1566, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initChildNodes(final Node newNode) { if (childNodes == null) { childNodes = new ArrayList<>(); } if (ownerDocument != null) { if (newNode.ownerDocument != ownerDocument) { changeOwnerDocument(newNode, ownerDocument); } } } \nResponse:", "ground_truth": "Initializes child nodes list when needed.\nAlso fix owner document for new node, if needed.", "predict": " Response = newNode.getResponse(); \n\n*/\n\npublic class Node extends NodeImpl {\n\t\n\tpublic Node(String name, String value) {\n\t\tsuper(name, value);\n\t}\n\t\n\tpublic Node(String name, String value, String type) {\n\t\tsuper(name, value, type);\n\t}\n\t\n\tpublic Node(String name, String value, String type, String content) {\n\t\tsuper(name, value, type, content);\n\t}\n\t\n\tpublic Node(String name, String value, String type, String content, String contentType) {\n\t\tsuper(name, value, type, content, contentType);\n\t}\n\t\n\tpublic Node(String name, String value, String type, String content, String contentType, String contentEncoding) {\n\t\tsuper(name, value, type, content, contentType, contentEncoding);\n\t}\n\t\n\tpublic Node(String name, String value"}, {"ID": 1567, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void changeOwnerDocument(final Node node, final Document ownerDocument) { node.ownerDocument = ownerDocument; int childCount = node.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = node.getChild(i); changeOwnerDocument(child, ownerDocument); } } \nResponse:", "ground_truth": "Changes owner document for given node and all its children.", "predict": " Response = new Response(Response.OK, null, null);\n\n*/\n\npublic class ChangeOwnerDocument extends AbstractJavaMethod {\n\t\n\tpublic static final String NAME = \"changeOwnerDocument\";\n\t\n\tpublic ChangeOwnerDocument(final String className, final String methodName, final String returnType, final String parameterName, final String parameterType) {\n\t\tsuper(NAME, className, methodName, returnType, parameterName, parameterType);\n\t}\n\t\n\t@Override\n\tpublic String getMethod() {\n\t\treturn \"protected void changeOwnerDocument(final Node node, final Document ownerDocument) { node.ownerDocument = ownerDocument; int childCount = node.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = node.getChild(i); changeOwnerDocument(child, ownerDocument); } }\";\n\t}\n\t\n\t@Override\n\tpublic String getParameterName() {\n\t\treturn \"owner"}, {"ID": 1568, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node getPreviousSiblingName() { if (nodeName == null) { return null; } initSiblingNames(); int index = siblingNameIndex -1; for (int i = siblingIndex; i >= 0; i--) { Node sibling = parentNode.childNodes.get(i); if ((index == sibling.siblingNameIndex) && nodeName.equals(sibling.getNodeName())) { return sibling; } } return null; } \nResponse:", "ground_truth": "Returns this node's previous sibling element with the same name.", "predict": "\n\n*/\n\npublic class Node {\n\tprivate String nodeName;\n\tprivate int siblingNameIndex;\n\tprivate int siblingIndex;\n\tprivate Node parentNode;\n\tprivate List<Node> childNodes;\n\t\n\tpublic Node(String nodeName, int siblingNameIndex, int siblingIndex, Node parentNode) {\n\t\tthis.nodeName = nodeName;\n\t\tthis.siblingNameIndex = siblingNameIndex;\n\t\tthis.siblingIndex = siblingIndex;\n\t\tthis.parentNode = parentNode;\n\t\tthis.childNodes = new ArrayList<Node>();\n\t}\n\t\n\tpublic String getNodeName() {\n\t\treturn nodeName;\n\t}\n\t\n\tpublic int getSiblingNameIndex() {\n\t\treturn siblingNameIndex;\n\t}\n\t\n\tpublic int getSiblingIndex() {\n\t\treturn siblingIndex;\n\t}\n\t\n\tpublic Node getParentNode() {\n\t\treturn parentNode"}, {"ID": 1569, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getTextContent() { StringBuilder sb = new StringBuilder(getChildNodesCount() + 1); appendTextContent(sb); return sb.toString(); } \nResponse:", "ground_truth": "Returns the text content of this node and its descendants.\n@see #appendTextContent(Appendable)", "predict": " Response is generated by the following java Code. Code: public String getTextContent() { StringBuilder sb = new StringBuilder(getChildNodesCount() + 1); appendTextContent(sb); return sb.toString(); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        Node root = new Node();\n        root.appendChild(new Node(\"1\"));\n        root.appendChild(new Node(\"2\"));\n        root.appendChild(new Node(\"3\"));\n        root.appendChild(new Node(\"4\"));\n        root.appendChild(new Node(\"5\"));\n        root.appendChild(new Node(\"6\"));\n        root.appendChild(new Node(\"7\"));\n        root.appendChild(new Node(\"8\"));\n        root.appendChild(new"}, {"ID": 1570, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toHtml(this, new StringBuilder()); } \nResponse:", "ground_truth": "Generates HTML.", "predict": " public String getHtml() { return getHtml(new StringBuilder()); } \nResp public String getHtml(StringBuilder output) { return getHtml(output, new StringBuilder()); } \nResp public String getHtml(StringBuilder output, StringBuilder temp) { return getHtml(output, temp, new StringBuilder()); } \nResp public String getHtml(StringBuilder output, StringBuilder temp, StringBuilder temp2) { return getHtml(output, temp, temp2, new StringBuilder()); } \nResp public String getHtml(StringBuilder output, StringBuilder temp, StringBuilder temp2, StringBuilder temp3) { return getHtml(output, temp, temp2, temp3, new StringBuilder()); } \nResp public String getHtml(StringBuilder output, StringBuilder temp, StringBuilder temp2, StringBuilder temp3, StringBuilder temp4) { return getHtml(output, temp, temp2, temp3,"}, {"ID": 1571, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getInnerHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toInnerHtml(this, new StringBuilder()); } \nResponse:", "ground_truth": "Generates inner HTML.", "predict": " public String getInnerHtml() { return getInnerHtml(new StringBuilder()); } \nResp public String getInnerHtml(StringBuilder buffer) { return getInnerHtml(buffer, null); } \nResp public String getInnerHtml(StringBuilder buffer, StringBuilder openTag) { return getInnerHtml(buffer, openTag, null); } \nResp public String getInnerHtml(StringBuilder buffer, StringBuilder openTag, StringBuilder closeTag) { return getInnerHtml(buffer, openTag, closeTag, null); } \nResp public String getInnerHtml(StringBuilder buffer, StringBuilder openTag, StringBuilder closeTag, StringBuilder openCloseTag) { return getInnerHtml(buffer, openTag, closeTag, openCloseTag, null); } \nResp public String getInnerHtml(StringBuilder buffer, StringBuilder openTag, StringBuilder closeTag, StringBuilder open"}, {"ID": 1572, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void visitChildren(final NodeVisitor nodeVisitor) { if (childNodes != null) { for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); childNode.visit(nodeVisitor); } } } \nResponse:", "ground_truth": "Visits children nodes.", "predict": " Response = new Response(this.getClass().getSimpleName(), this.getName(), this.getDescription(), this.getType(), this.getStatus(), this.getStatusCode(), this.getStatusMessage(), this.getRequest(), this.getResponse(), this.getRequestMethod(), this.getRequestUrl(), this.getRequestUrlParameters(), this.getRequestUrlParametersEncoded(), this.getRequestBody(), this.getRequestBodyEncoded(), this.getRequestHeaders(), this.getRequestHeadersEncoded(), this.getResponseHeaders(), this.getResponseHeadersEncoded(), this.getResponseBody(), this.getResponseBodyEncoded(), this.getResponseBodyFile(), this.getResponseBodyFileName(), this.getResponseBodyFileContentType(), this.getResponseBodyFileContentEncoding(), this.getResponseBodyFileLength(), this.getResponseBodyFileLastModified(), this.getResponseBodyFileLastModifiedBy(), this.getResponseBodyFileLastModified"}, {"ID": 1573, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getCssPath() { StringBuilder path = new StringBuilder(); Node node = this; while (node != null) { String nodeName = node.getNodeName(); if (nodeName != null) { StringBuilder sb = new StringBuilder(); sb.append(' ').append(nodeName); String id = node.getAttribute(\"id\"); if (id != null) { sb.append('#').append(id); } path.insert(0, sb); } node = node.getParentNode(); } if (path.charAt(0) == ' ') { return path.substring(1); } return path.toString(); } \nResponse:", "ground_truth": "Returns CSS path to this node from document root.", "predict": "\n\n*/\n\npublic class Solution {\n    public String getCssPath(Node node) {\n        StringBuilder path = new StringBuilder();\n        Node parent = node.getParentNode();\n        while (parent != null) {\n            String nodeName = parent.getNodeName();\n            if (nodeName != null) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(' ').append(nodeName);\n                String id = parent.getAttribute(\"id\");\n                if (id != null) {\n                    sb.append('#').append(id);\n                }\n                path.insert(0, sb);\n            }\n            parent = parent.getParentNode();\n        }\n        if (path.charAt(0) == ' ') {\n            return path.substring(1);\n        }\n        return path.toString();\n    }\n}\n"}, {"ID": 1574, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onDecoraTag(final Tag tag) { String tagName = tag.getName().toString(); if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); return; } // closed tag type decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); decoraTagDefaultValueEnd = tag.getTagPosition(); defineDecoraTag(); } \nResponse:", "ground_truth": "Handle Decora tags.", "predict": "\n\n*/\n\npublic class DecoraTag {\n\tpublic static final int TAG_TYPE_SELF_CLOSING = 0;\n\tpublic static final int TAG_TYPE_START = 1;\n\tpublic static final int TAG_TYPE_END = 2;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE = 3;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_END = 4;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_START = 5;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_START_END = 6;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_START_START = 7;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_START_START_END = 8;\n\tpublic static final int TAG_TYPE_DEFAULT_VALUE_START_START_START = 9;\n\tpublic static final"}, {"ID": 1575, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onIdAttrStart(final Tag tag) { String id = tag.getId().toString().substring(7); String tagName; String idName; int dashIndex = id.indexOf('-'); if (dashIndex == -1) { tagName = id; idName = null; } else { tagName = id.substring(0, dashIndex); idName = id.substring(dashIndex + 1); } if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); closingTagName = tag.getName().toString(); closingTagDeepLevel = tag.getDeepLevel(); } } \nResponse:", "ground_truth": "Handle open and empty ID attribute tags.", "predict": " public void onIdAttrEnd(final Tag tag) { if (tag.getType() == TagType.END) { if (tag.getName().toString().equals(decoraTagName)) { decoraTagEnd = tag.getTagPosition(); } } } \nResp public void onIdAttrValue(final Tag tag) { if (tag.getType() == TagType.SELF_CLOSING) { decoraTagDefaultValueEnd = tag.getTagPosition(); } } \nResp public void onIdAttrValue(final Tag tag, final String value) { if (tag.getType() == TagType.SELF_CLOSING) { decoraTagDefaultValueEnd = tag.getTagPosition(); } } \nResp public void onIdAttrValue(final Tag tag, final String value, final int valueLength) { if (tag.getType() == TagType.SELF_CLOSING) { decoraTagDefaultValue"}, {"ID": 1576, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void defineDecoraTag() { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd) : new DecoraTag( decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd, decoraTagDefaultValueStart, decoraTagDefaultValueEnd - decoraTagDefaultValueStart); decoraTags.add(decoraTag); decoraTagName = null; decoraIdName = null; closingTagName = null; decoraTagDefaultValueStart = 0; } \nResponse:", "ground_truth": "Defines Decora tag position inside decorator content.\nResets current Decora tag tracking.", "predict": "\n\n*/\n\npublic class DecoraTag {\n\tprivate String decoraTagName;\n\tprivate String decoraIdName;\n\tprivate int decoraTagStart;\n\tprivate int decoraTagEnd;\n\tprivate int decoraTagDefaultValueStart;\n\tprivate int decoraTagDefaultValueEnd;\n\t\n\tpublic DecoraTag(String decoraTagName, String decoraIdName, int decoraTagStart, int decoraTagEnd) {\n\t\tthis.decoraTagName = decoraTagName;\n\t\tthis.decoraIdName = decoraIdName;\n\t\tthis.decoraTagStart = decoraTagStart;\n\t\tthis.decoraTagEnd = decoraTagEnd;\n\t}\n\t\n\tpublic DecoraTag(String decoraTagName, String decoraIdName, int decoraTagStart, int decoraTagEnd, int decoraTagDefaultValueStart, int decoraTagDefaultValueEnd) {\n\t\tthis."}, {"ID": 1577, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; } \nResponse:", "ground_truth": "Adds a proxy aspect.", "predict": " @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect, final String... proxyAspectClasses) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; } \nResp @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect, final Class<?>... proxyAspectClasses) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; } \nResp @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect, final Class<?> proxyAspectClass) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; } \nResp @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect, final Class<?> proxyAspectClass, final String... proxyAspectClasses"}, {"ID": 1578, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addRootPackage(final String rootPackage, String mapping) { if (packages == null) { packages = new String[0]; } if (mappings == null) { mappings = new String[0]; } // fix mapping if (mapping.length() > 0) { // mapping must start with the slash if (!mapping.startsWith(StringPool.SLASH)) { mapping = StringPool.SLASH + mapping; } // mapping must NOT end with the slash if (mapping.endsWith(StringPool.SLASH)) { mapping = StringUtil.substring(mapping, 0, -1); } } // detect duplicates for (int i = 0; i < packages.length; i++) { if (packages[i].equals(rootPackage)) { if (mappings[i].equals(mapping)) { // both package and the mappings are the same return; } throw new MadvocException(\"Different mappings for the same root package: \" + rootPackage); } } packages = ArraysUtil.append(packages, rootPackage); mappings = ArraysUtil.append(mappings, mapping); } \nResponse:", "ground_truth": "Adds root package and its path mapping. Duplicate root packages\nare ignored, if mapping path is equals, otherwise exception is thrown.", "predict": "\n\n*/\npackage com.manydesigns.portofino.actions.admin.app;\n\nimport com.manydesigns.elements.annotations.Label;\nimport com.manydesigns.elements.annotations.Updatable;\nimport com.manydesigns.elements.util.MimeTypes;\nimport com.manydesigns.portofino.buttons.annotations.Button;\nimport com.manydesigns.portofino.di.Injections;\nimport com.manydesigns.portofino.model.Model;\nimport com.manydesigns.portofino.model.ModelObject;\nimport com.manydesigns.portofino.model.ModelObjectUtils;\nimport com.manydesigns.portofino.model.ModelObjectVisitor;\nimport com.manydesigns.portofino."}, {"ID": 1579, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addRootPackageOf(final Class actionClass, final String mapping) { addRootPackage(actionClass.getPackage().getName(), mapping); } \nResponse:", "ground_truth": "Sets root package to package of given class.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1580, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String findRootPackageForActionPath(final String actionPath) { if (mappings == null) { return null; } int ndx = -1; int delta = Integer.MAX_VALUE; for (int i = 0; i < mappings.length; i++) { String mapping = mappings[i]; boolean found = false; if (actionPath.equals(mapping)) { found = true; } else { mapping += StringPool.SLASH; if (actionPath.startsWith(mapping)) { found = true; } } if (found) { int distance = actionPath.length() - mapping.length(); if (distance < delta) { ndx = i; delta = distance; } } } if (ndx == -1) { return null; } return packages[ndx]; } \nResponse:", "ground_truth": "Finds closest root package for the given action path.", "predict": "\n\n*/\n\npublic class ActionMapping {\n\t\n\tprivate String actionPath;\n\tprivate String packageName;\n\tprivate String packagePath;\n\tprivate String packagePathWithSlash;\n\tprivate String packagePathWithSlashAndAction;\n\tprivate String packagePathWithSlashAndActionAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethodAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethodAndMethodAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethodAndMethodAndMethodAndMethodAndMethod;\n\tprivate String packagePathWithSlashAndActionAndMethodAndMethodAndMethodAndMethodAnd"}, {"ID": 1581, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveValidationMessage(final HttpServletRequest request, final Violation violation) { ValidationConstraint vc = violation.getConstraint(); String key = vc != null ? vc.getClass().getName() : violation.getName(); String msg = LocalizationUtil.findMessage(request, key); if (msg != null) { return beanTemplateParser.parseWithBean(msg, violation); } return null; } \nResponse:", "ground_truth": "Prepares validation messages.\nKey is either validation constraint class name or violation name.", "predict": "\n\n*/\n\npublic class BeanTemplateParser {\n\n    private static final String TEMPLATE_PREFIX = \"beanTemplate\";\n    private static final String TEMPLATE_SUFFIX = \".vm\";\n\n    public static String parseWithBean(final String template, final Object bean) {\n        String templateName = TEMPLATE_PREFIX + bean.getClass().getSimpleName() + TEMPLATE_SUFFIX;\n        return parse(template, templateName, bean);\n    }\n\n    public static String parse(final String template, final String templateName, final Object bean) {\n        StringWriter writer = new StringWriter();\n        try {\n            Velocity.init();\n            Velocity.evaluate(writer, null, templateName, template);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return writer.toString();\n    }\n}\n"}, {"ID": 1582, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences removeDuplicateNames() { if (names.length < 2) { return this; } int nullCount = 0; for (int i = 1; i < names.length; i++) { String thisRef = names[i]; if (thisRef == null) { nullCount++; continue; } for (int j = 0; j < i; j++) { if (names[j] == null) { continue; } if (thisRef.equals(names[j])) { names[i] = null; break; } } } if (nullCount == 0) { return this; } String[] newRefs = new String[names.length - nullCount]; int ndx = 0; for (String name : names) { if (name == null) { continue; } newRefs[ndx] = name; ndx++; } return new BeanReferences(newRefs); } \nResponse:", "ground_truth": "Removes later duplicated references in an array.\nReturns new instance of BeanReferences if there was changes,\notherwise returns the same instance.", "predict": " public BeanReferences removeDuplicateNames() { return removeDuplicateNames(this); }\n\npublic BeanReferences removeDuplicateNames(BeanReferences that) {\n\tif (that == null) {\n\t\treturn this;\n\t}\n\tif (that.names == null) {\n\t\treturn that;\n\t}\n\tif (this.names == null) {\n\t\treturn this;\n\t}\n\tif (this.names.length != that.names.length) {\n\t\treturn that;\n\t}\n\tint nullCount = 0;\n\tfor (int i = 0; i < this.names.length; i++) {\n\t\tString thisRef = this.names[i];\n\t\tif (thisRef == null) {\n\t\t\tnullCount++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < that.names.length; j++) {\n\t\t\tString thatRef = that.names[j];\n\t\t\tif (that"}, {"ID": 1583, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public JoyProps addPropsFile(final String namePattern) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); return this; } \nResponse:", "ground_truth": "Adds props files or patterns.", "predict": " @Override public JoyProps addPropsFile(final String namePattern, final String fileName) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); this.propsFileNames.add(fileName); return this; } \nResp @Override public JoyProps addPropsFile(final String namePattern, final String fileName, final String comment) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); this.propsFileNames.add(fileName); this.propsComments.add(comment); return this; } \nResp @Override public JoyProps addPropsFile(final String namePattern, final String fileName, final String comment, final String description) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); this.propsFileNames.add(fileName); this.propsComments.add(comment); this.pro"}, {"ID": 1584, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTarget(final Consumer<Target> targetConsumer) { for (final Target target : targets) { targetConsumer.accept(target); } } \nResponse:", "ground_truth": "Iterates all targets.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1585, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.in() == null) { continue; } for (final InjectionPoint in : scopeData.in()) { if (in.scope() != scope) { continue; } biConsumer.accept(target, in); } } } \nResponse:", "ground_truth": "Iterates all targets and for each target iterates all IN injection points of given scope.", "predict": "\npublic void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.in() == null) { continue; } for (final InjectionPoint in : scopeData.in()) { if (in.scope() != scope) { continue; } biConsumer.accept(target, in); } } }\n\n*/\n\npublic class TargetMethod {\n\n\tprivate final Target target;\n\tprivate final Method method;\n\tprivate final MadvocScope scope;\n\tprivate final InjectionPoint[] injectionPoints;\n\n\tpublic TargetMethod(Target target, Method method, MadvocScope scope, InjectionPoint[] injectionPoints) {\n\t\tthis.target = target;\n\t\tthis.method = method;\n\t\tthis.scope = scope;\n\t\tthis.injectionPoints = injectionPoints;\n\t}\n\n\tpublic Target getTarget()"}, {"ID": 1586, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.out() == null) { continue; } for (final InjectionPoint out : scopeData.out()) { if (out.scope() != scope) { continue; } biConsumer.accept(target, out); } } } \nResponse:", "ground_truth": "Iterates all targets and for each target iterates all OUT injection points of given scope.", "predict": " public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.out() == null) { continue; } for (final InjectionPoint out : scopeData.out()) { if (out.scope() != scope) { continue; } biConsumer.accept(target, out); } } } \n\n*/\n\npublic class Target {\n\tprivate final String name;\n\tprivate final ScopeData scopeData;\n\t\n\tpublic Target(String name, ScopeData scopeData) {\n\t\tthis.name = name;\n\t\tthis.scopeData = scopeData;\n\t}\n\t\n\tpublic String name() {\n\t\treturn name;\n\t}\n\t\n\tpublic ScopeData scopeData() {\n\t\treturn scopeData;\n\t}\n}\n"}, {"ID": 1587, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object[] extractParametersValues() { final Object[] values = new Object[targets.length - 1]; for (int i = 1; i < targets.length; i++) { values[i - 1] = targets[i].value(); } return values; } \nResponse:", "ground_truth": "Collects all parameters from target into an array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1588, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Target[] makeTargets(final Target actionTarget, final MethodParam[] methodParams) { if (methodParams == null) { // action does not have method parameters, so there is just one target return new Target[]{actionTarget}; } // action has method arguments, so there is more then one target final Target[] target = new Target[methodParams.length + 1]; target[0] = actionTarget; final Object action = actionTarget.value(); for (int i = 0; i < methodParams.length; i++) { final MethodParam methodParam = methodParams[i]; final Class paramType = methodParam.type(); final Target paramTarget; if (methodParam.annotationType() == null) { // parameter is NOT annotated, create new value for the target // the class itself will be a base class, and should be scanned final ScopeData newScopeData = methodParam.scopeData().inspector().inspectClassScopesWithCache(paramType); paramTarget = Target.ofValue(createActionMethodArgument(paramType, action), newScopeData); } else if (methodParam.annotationType() == Out.class) { // parameter is annotated with *only* OUT annotation // create the output value now AND to save the type paramTarget = Target.ofMethodParam(methodParam, createActionMethodArgument(paramType, action)); } else { // parameter is annotated with any IN annotation // create target with NO value, as the value will be created later paramTarget = Target.ofMethodParam(methodParam, type -> createActionMethodArgument(type, action)); } target[i + 1] = paramTarget; } return target; } \nResponse:", "ground_truth": "Joins action and parameters into one single array of Targets.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons."}, {"ID": 1589, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodArgument(final Class type, final Object action) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) { // regular or static class return ClassUtil.newInstance(type); } else { // member class Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass()); ctor.setAccessible(true); return ctor.newInstance(action); } } catch (Exception ex) { throw new MadvocException(ex); } } \nResponse:", "ground_truth": "Creates action method arguments.", "predict": " @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodResult(final Class type, final Object action) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) { // regular or static class return ClassUtil.newInstance(type); } else { // member class Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass()); ctor.setAccessible(true); return ctor.newInstance(action); } } catch (Exception ex) { throw new MadvocException(ex); } } \nResp @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodResult(final Class type, final Object action, final Object[] args) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers()"}, {"ID": 1590, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void sessionCreated(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.putIfAbsent(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionCreated(httpSessionEvent); } } \nResponse:", "ground_truth": "Stores session in map and broadcasts event to registered listeners.", "predict": " @Override public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(session.getId()); for (HttpSessionListener listener : listeners) { listener.sessionDestroyed(httpSessionEvent); } } \n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpSessionEventListener implements HttpSessionListener {\n\n    private Map<String, HttpSession> sessionMap = new HashMap<>();\n\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) {\n        HttpSession session = httpSessionEvent.getSession();\n        sessionMap.putIfAbsent(session.getId(), session);\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n        HttpSession session = httpSessionEvent.getSession();\n        sessionMap.remove(session.getId());"}, {"ID": 1591, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(session.getId()); for (HttpSessionListener listener : listeners) { listener.sessionDestroyed(httpSessionEvent); } } \nResponse:", "ground_truth": "Removes session from a map and broadcasts event to registered listeners.", "predict": " @Override public void sessionCreated(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.put(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionCreated(httpSessionEvent); } } \nResp @Override public void sessionIdChanged(final HttpSessionEvent httpSessionEvent, final String oldSessionId) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(oldSessionId); sessionMap.put(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionIdChanged(httpSessionEvent, oldSessionId); } } \nResp @Override public void attributeAdded(final HttpSessionBindingEvent httpSessionBindingEvent) { HttpSession session = httpSessionBindingEvent.getSession(); sessionMap.put(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.attributeAdded(http"}, {"ID": 1592, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonArray add(Object value) { Objects.requireNonNull(value); value = JsonObject.resolveValue(value); list.add(value); return this; } \nResponse:", "ground_truth": "Adds an object to the JSON array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1593, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonArray addAll(final JsonArray array) { Objects.requireNonNull(array); list.addAll(array.list); return this; } \nResponse:", "ground_truth": "Appends all of the elements in the specified array to the end of this JSON array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1594, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object remove(final int pos) { Object removed = list.remove(pos); if (removed instanceof Map) { return new JsonObject((Map) removed); } if (removed instanceof ArrayList) { return new JsonArray((List) removed); } return removed; } \nResponse:", "ground_truth": "Removes the value at the specified position in the JSON array.", "predict": "\n\n*/\n\npublic class JsonObject {\n\tprivate Map<String, Object> map;\n\t\n\tpublic JsonObject(Map<String, Object> map) {\n\t\tthis.map = map;\n\t}\n\t\n\tpublic JsonObject(List<Object> list) {\n\t\tthis.map = new HashMap<String, Object>();\n\t\tfor (Object o : list) {\n\t\t\tthis.map.put(o.toString(), o);\n\t\t}\n\t}\n\t\n\tpublic Object get(String key) {\n\t\treturn map.get(key);\n\t}\n\t\n\tpublic Object remove(int pos) {\n\t\treturn map.remove(pos);\n\t}\n\t\n\tpublic Object remove(String key) {\n\t\treturn map.remove(key);\n\t}\n\t\n\tpublic Object put(String key, Object value) {\n\t\treturn map.put(key, value);\n\t}\n\t"}, {"ID": 1595, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveTarget(final ActionRequest actionRequest, final String resultValue) { String resultBasePath = actionRequest.getActionRuntime().getResultBasePath(); ResultPath resultPath = resultMapper.resolveResultPath(resultBasePath, resultValue); String actionPath = resultPath.path(); String path = actionPath; String value = resultPath.value(); if (StringUtil.isEmpty(value)) { value = null; } String target; while (true) { // variant #1: with value if (value != null) { if (path == null) { // only value remains int lastSlashNdx = actionPath.lastIndexOf('/'); if (lastSlashNdx != -1) { target = actionPath.substring(0, lastSlashNdx + 1) + value; } else { target = '/' + value; } } else { target = path + '.' + value; } target = locateTarget(actionRequest, target); if (target != null) { break; } } if (path != null) { // variant #2: without value target = locateTarget(actionRequest, path); if (target != null) { break; } } // continue if (path == null) { // path not found return null; } int dotNdx = MadvocUtil.lastIndexOfDotAfterSlash(path); if (dotNdx == -1) { path = null; } else { path = path.substring(0, dotNdx); } } return target; } \nResponse:", "ground_truth": "Locates the target file from action path and the result value.", "predict": "\n\n@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\npublic class MyController {\n\t@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\n\tpublic String get(@PathVariable(\"path\") String path) {\n\t\treturn \"path: \" + path;\n\t}\n}\n\n@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\npublic class MyController {\n\t@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\n\tpublic String get(@PathVariable(\"path\") String path) {\n\t\treturn \"path: \" + path;\n\t}\n}\n\n@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\npublic class MyController {\n\t@RequestMapping(value = \"/{path}\", method = RequestMethod.GET)\n\tpublic String get(@PathVariable(\""}, {"ID": 1596, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void targetNotFound(final ActionRequest actionRequest, final String actionAndResultPath) throws IOException { final HttpServletResponse response = actionRequest.getHttpServletResponse(); if (!response.isCommitted()) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath); } } \nResponse:", "ground_truth": "Called when target not found. By default sends 404 to the response.", "predict": "\n\npublic class ActionResult {\n\tpublic static final String ACTION_RESULT_PATH = \"actionResultPath\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED = \"actionResultPathResolved\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED_RESULT = \"actionResultPathResolvedResult\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED_RESULT_RESULT = \"actionResultPathResolvedResultResult\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED_RESULT_RESULT_RESULT = \"actionResultPathResolvedResultResultResult\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED_RESULT_RESULT_RESULT_RESULT = \"actionResultPathResolvedResultResultResultResult\";\n\tpublic static final String ACTION_RESULT_PATH_RESOLVED_RESULT_RESULT_RESULT"}, {"ID": 1597, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String valueToString(final String name, final Object valueObject) { if (!valueObject.getClass().isArray()) { return valueObject.toString(); } // array String[] array = (String[]) valueObject; if (valueNameIndexes == null) { valueNameIndexes = new HashMap<>(); } MutableInteger index = valueNameIndexes.get(name); if (index == null) { index = new MutableInteger(0); valueNameIndexes.put(name, index); } if (index.value >= array.length) { return null; } String result = array[index.value]; index.value++; return result; } \nResponse:", "ground_truth": "Converts value to a string.", "predict": " public String valueToString(final String name, final Object valueObject) { if (!valueObject.getClass().isArray()) { return valueObject.toString(); } // array String[] array = (String[]) valueObject; if (valueNameIndexes == null) { valueNameIndexes = new HashMap<>(); } MutableInteger index = valueNameIndexes.get(name); if (index == null) { index = new MutableInteger(0); valueNameIndexes.put(name, index); } if (index.value >= array.length) { return null; } String result = array[index.value]; index.value++; return result; } \n\n}\n"}, {"ID": 1598, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) { filtersManager.resolve(actionFilterClass); return this; } \nResponse:", "ground_truth": "Returns action filter instance for further configuration.", "predict": "\n\n@SuppressWarnings(\"unchecked\") public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) { filtersManager.resolve(actionFilterClass); return this; } \n\n*/\n\npublic class ActionFilterManager {\n\n\tprivate final Map<Class<? extends ActionFilter>, ActionFilter> filters = new HashMap<Class<? extends ActionFilter>, ActionFilter>();\n\n\tpublic ActionFilterManager() {\n\t\tfilters.put(ActionFilter.class, new ActionFilter());\n\t}\n\n\tpublic ActionFilterManager(ActionFilter actionFilter) {\n\t\tfilters.put(ActionFilter.class, actionFilter);\n\t}\n\n\tpublic ActionFilterManager(ActionFilter actionFilter, ActionFilter... actionFilters) {\n\t\tfilters.put(ActionFilter.class, actionFilter);\n\t\tfor (ActionFilter actionFilter2 : actionFilters) {\n\t\t\tfilters.put(actionFilter2.getClass(), actionFilter"}, {"ID": 1599, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPseudoFunctionName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; } \nResponse:", "ground_truth": "Returns pseudo-function name.", "predict": "\n\n*/\n\npublic class PseudoFunction {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t\n\t\t// TODO: Create a pseudo-function that returns the name of the class.\n\t\t"}, {"ID": 1600, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyInjectionPoint[] resolve(Class type, final boolean autowire) { final List<PropertyInjectionPoint> list = new ArrayList<>(); final Set<String> usedPropertyNames = new HashSet<>(); // lookup fields while (type != Object.class) { final ClassDescriptor cd = ClassIntrospector.get().lookup(type); final PropertyDescriptor[] allPropertyDescriptors = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allPropertyDescriptors) { if (propertyDescriptor.isGetterOnly()) { continue; } if (usedPropertyNames.contains(propertyDescriptor.getName())) { continue; } Class propertyType = propertyDescriptor.getType(); if (ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } BeanReferences reference = referencesResolver.readReferenceFromAnnotation(propertyDescriptor); if (reference == null) { if (!autowire) { continue; } else { reference = referencesResolver.buildDefaultReference(propertyDescriptor); } } list.add(new PropertyInjectionPoint(propertyDescriptor, reference)); usedPropertyNames.add(propertyDescriptor.getName()); } // go to the supertype type = type.getSuperclass(); } final PropertyInjectionPoint[] fields; if (list.isEmpty()) { fields = PropertyInjectionPoint.EMPTY; } else { fields = list.toArray(new PropertyInjectionPoint[0]); } return fields; } \nResponse:", "ground_truth": "Resolves all properties for given type.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.enterprise.context.RequestScoped;\nimport javax.enterprise.inject.spi.BeanManager;\nimport javax.enterprise.inject.spi.CDI;\nimport javax.enterprise.inject.spi.InjectionPoint;\nimport javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\n@Path(\"/\")\n@RequestScoped\npublic class Resource {\n\n    @Inject\n    private BeanManager beanManager;\n\n    @GET\n    @Path(\"/\")"}, {"ID": 1601, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Socket createSocks4ProxySocket(final String host, final int port) { Socket socket = null; final String proxyHost = proxy.getProxyAddress(); final int proxyPort = proxy.getProxyPort(); final String user = proxy.getProxyUsername(); try { socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout); final InputStream in = socket.getInputStream(); final OutputStream out = socket.getOutputStream(); socket.setTcpNoDelay(true); byte[] buf = new byte[1024]; // 1) CONNECT int index = 0; buf[index++] = 4; buf[index++] = 1; buf[index++] = (byte) (port >>> 8); buf[index++] = (byte) (port & 0xff); InetAddress addr = InetAddress.getByName(host); byte[] byteAddress = addr.getAddress(); for (byte byteAddres : byteAddress) { buf[index++] = byteAddres; } if (user != null) { System.arraycopy(user.getBytes(), 0, buf, index, user.length()); index += user.length(); } buf[index++] = 0; out.write(buf, 0, index); // 2) RESPONSE int len = 6; int s = 0; while (s < len) { int i = in.read(buf, s, len - s); if (i <= 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"stream is closed\"); } s += i; } if (buf[0] != 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned VN \" + buf[0]); } if (buf[1] != 90) { try { socket.close(); } catch (Exception ignore) { } throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned CD \" + buf[1]); } byte[] temp = new byte[2]; in.read(temp, 0, 2); return socket; } catch (RuntimeException rtex) { closeSocket(socket); throw rtex; } catch (Exception ex) { closeSocket(socket); throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex); } } \nResponse:", "ground_truth": "Connects to the SOCKS4 proxy and returns proxified socket.", "predict": "\n\npublic class Socks4ProxySocket extends Socket {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate final Proxy proxy;\n\tprivate final Socket socket;\n\tprivate final InputStream in;\n\tprivate final OutputStream out;\n\tprivate final int port;\n\tprivate final String host;\n\tprivate final String user;\n\tprivate final int connectionTimeout;\n\tprivate final int readTimeout;\n\tprivate final int writeTimeout;\n\tprivate final int localPort;\n\tprivate final InetAddress localAddress;\n\tprivate final String localHost;\n\tprivate final String remoteHost;\n\tprivate final int remotePort;\n\tprivate final InetAddress remoteAddress;\n\tprivate final String remoteHostAddress;\n\tprivate final int localPortAddress;\n\tprivate final String localHostAddress;\n\tprivate final String remoteHostAddress2;\n\tprivate final int localPortAddress2;\n\tprivate final String localHostAddress2;\n\tprivate final String remoteHost"}, {"ID": 1602, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final int getAttributeCount() { int count = 0; Attribute attribute = this; while (attribute != null) { count += 1; attribute = attribute.nextAttribute; } return count; } \nResponse:", "ground_truth": "Returns the number of attributes of the attribute list that begins with this attribute.\n\n@return the number of attributes of the attribute list that begins with this attribute.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1603, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<ActionResult> getAllActionResults() { final Set<ActionResult> set = new HashSet<>(allResults.size()); allResults.forEachValue(set::add); return set; } \nResponse:", "ground_truth": "Returns all action results as new set.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1604, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean equalsOne(final char c, final CharSequence match) { for (int i = 0; i < match.length(); i++) { char aMatch = match.charAt(i); if (c == aMatch) { return true; } } return false; } \nResponse:", "ground_truth": "Match if one character equals to any of the given character.\n\n@return true if characters match any character from given array,\notherwise false", "predict": "\n\npublic static boolean equalsOne(final char c, final CharSequence match) {\n    for (int i = 0; i < match.length(); i++) {\n        char aMatch = match.charAt(i);\n        if (c == aMatch) {\n            return true;\n        }\n    }\n    return false;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(in.next());\n        }\n        String s = sb.toString();\n        int k = in.nextInt();\n        StringBuilder sb2 = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            sb2"}, {"ID": 1605, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) { for (int i = index; i < source.length(); i++) { if (equalsOne(source.charAt(i), match)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given charsequence the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "\n\npublic static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) {\n    int i = index;\n    for (; i < source.length(); i++) {\n        if (equalsOne(source.charAt(i), match)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\npublic static boolean equalsOne(final char c, final CharSequence match) {\n    return match.length() == 1 && match.charAt(0) == c;\n}\n\npublic static boolean equalsOne(final char c, final char match) {\n    return match == c;\n}\n\npublic static boolean equalsOne(final char c, final char match, final char match2) {\n    return match == c || match2 == c;\n}\n\npublic static boolean equalsOne(final char c, final char match, final char match2, final char match3) {\n"}, {"ID": 1606, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstEqual(final char[] source, final int index, final char match) { for (int i = index; i < source.length; i++) { if (source[i] == match) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given array the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "\n\npublic static int findFirstEqual(final char[] source, final int index, final char match) {\n    int i = index;\n    for (; i < source.length; i++) {\n        if (source[i] == match) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n*/\n\npublic class Solution {\n    public static int findFirstEqual(final char[] source, final int index, final char match) {\n        int i = index;\n        for (; i < source.length; i++) {\n            if (source[i] == match) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"}, {"ID": 1607, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CommandLine args(final String... arguments) { if (arguments != null && arguments.length > 0) { Collections.addAll(cmdLine, arguments); } return this; } \nResponse:", "ground_truth": "Adds several arguments.", "predict": " Response = new Response(); if (cmdLine.size() > 0) { Response.setCommandLine(cmdLine); } return Response; }\n\n@Override\npublic String toString() {\n\treturn \"CommandLine [cmdLine=\" + cmdLine + \"]\";\n}\n}\n"}, {"ID": 1608, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CommandLine env(final String key, final String value) { if (env == null) { env = new HashMap<>(); } env.put(key, value); return this; } \nResponse:", "ground_truth": "Sets environment variable.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1609, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProcessRunner.ProcessResult run() { ByteArrayOutputStream baos = new ByteArrayOutputStream(); out = err = baos; try { baos.write(StringUtil.join(cmdLine, ' ').getBytes()); baos.write(StringPool.BYTES_NEW_LINE); } catch (IOException ignore) { } ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(cmdLine); if (cleanEnvironment) { processBuilder.environment().clear(); } if (env != null) { processBuilder.environment().putAll(env); } processBuilder.directory(workingDirectory); Process process = null; try { process = processBuilder.start(); } catch (IOException ioex) { return writeException(baos, ioex); } StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix); StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix); outputGobbler.start(); errorGobbler.start(); int result; try { result = process.waitFor(); } catch (InterruptedException iex) { return writeException(baos, iex); } outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessRunner.ProcessResult(result, baos.toString()); } \nResponse:", "ground_truth": "Runs command and returns process result.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.commons.lang3.time.DurationFormatUtils;\nimport org.apache.commons.lang3.time.StopWatch;\nimport org.apache.commons.lang3.time.Duration;\nimport org.apache.commons.lang3.time.DurationFormatUtils;\nimport org.apache.commons.lang3.time.StopWatch;\nimport org.apache.commons.lang3.time"}, {"ID": 1610, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void invoke(final Object listener, final Class listenerType) { if (listenerType == Init.class) { ((Init) listener).init(); return; } if (listenerType == Start.class) { ((Start) listener).start(); return; } if (listenerType == Ready.class) { ((Ready) listener).ready(); return; } if (listenerType == Stop.class) { ((Stop) listener).stop(); return; } throw new MadvocException(\"Invalid listener\"); } \nResponse:", "ground_truth": "Invoke the listener based on type.\nNot very OOP, but works.", "predict": " public static void invoke(final Object listener, final Class listenerType) { if (listenerType == Init.class) { ((Init) listener).init(); return; } if (listenerType == Start.class) { ((Start) listener).start(); return; } if (listenerType == Ready.class) { ((Ready) listener).ready(); return; } if (listenerType == Stop.class) { ((Stop) listener).stop(); return; } throw new MadvocException(\"Invalid listener\"); } \n\n*/\n\npublic class MethodComment {\n\n\tprivate final String methodName;\n\tprivate final String methodComment;\n\n\tpublic MethodComment(String methodName, String methodComment) {\n\t\tthis.methodName = methodName;\n\t\tthis.methodComment = methodComment;\n\t}\n\n\tpublic String getMethodName() {\n\t\treturn methodName;\n\t}\n\n\tpublic String getMethodComment() {\n\t\treturn methodComment;\n\t}\n}\n"}, {"ID": 1611, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void copyFrom(final Frame frame) { inputLocals = frame.inputLocals; inputStack = frame.inputStack; outputStackStart = 0; outputLocals = frame.outputLocals; outputStack = frame.outputStack; outputStackTop = frame.outputStackTop; initializationCount = frame.initializationCount; initializations = frame.initializations; } \nResponse:", "ground_truth": "Sets this frame to the value of the given frame.\n\nWARNING: after this method is called the two frames share the same data structures. It is\nrecommended to discard the given frame to avoid unexpected side effects.\n\n@param frame The new frame value.", "predict": "\n\n*/\n\npublic class Frame {\n    int inputLocals;\n    int inputStack;\n    int outputStackStart;\n    int outputLocals;\n    int outputStack;\n    int outputStackTop;\n    int initializationCount;\n    Object[] initializations;\n    \n    public Frame(int inputLocals, int inputStack, int outputStackStart, int outputLocals, int outputStack, int outputStackTop, int initializationCount, Object[] initializations) {\n        this.inputLocals = inputLocals;\n        this.inputStack = inputStack;\n        this.outputStackStart = outputStackStart;\n        this.outputLocals = outputLocals;\n        this.outputStack = outputStack;\n        this.outputStackTop = outputStackTop;\n        this.initializationCount = initializationCount;\n        this.initializations = initializations;\n    }\n}\n"}, {"ID": 1612, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) { if (type instanceof Integer) { return CONSTANT_KIND | ((Integer) type).intValue(); } else if (type instanceof String) { String descriptor = Type.getObjectType((String) type).getDescriptor(); return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0); } else { return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset); } } \nResponse:", "ground_truth": "Returns the abstract type corresponding to the given public API frame element type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param type a frame element type described using the same format as in {@link\nMethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\nOpcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n{@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\na NEW instruction (for uninitialized types).\n@return the abstract type corresponding to the given frame element type.", "predict": " Generate the method-level comment for the following java Code. Code: static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String descriptor, final int index) { int result = 0; if (descriptor.charAt(index) == 'L') { result = getAbstractTypeFromDescriptor(symbolTable, descriptor, index + 1); } else if (descriptor.charAt(index) == '[') { result = getAbstractTypeFromDescriptor(symbolTable, descriptor, index + 1); } else { result = CONSTANT_KIND | symbolTable.addConstant(descriptor.substring(index)); } return result; } \nResp Generate the method-level comment for the following java Code. Code: static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String descriptor, final int index) { int result = 0; if (descriptor.charAt(index) == 'L') {"}, {"ID": 1613, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getAbstractTypeFromDescriptor( final SymbolTable symbolTable, final String buffer, final int offset) { String internalName; switch (buffer.charAt(offset)) { case 'V': return 0; case 'Z': case 'C': case 'B': case 'S': case 'I': return INTEGER; case 'F': return FLOAT; case 'J': return LONG; case 'D': return DOUBLE; case 'L': internalName = buffer.substring(offset + 1, buffer.length() - 1); return REFERENCE_KIND | symbolTable.addType(internalName); case '[': int elementDescriptorOffset = offset + 1; while (buffer.charAt(elementDescriptorOffset) == '[') { ++elementDescriptorOffset; } int typeValue; switch (buffer.charAt(elementDescriptorOffset)) { case 'Z': typeValue = BOOLEAN; break; case 'C': typeValue = CHAR; break; case 'B': typeValue = BYTE; break; case 'S': typeValue = SHORT; break; case 'I': typeValue = INTEGER; break; case 'F': typeValue = FLOAT; break; case 'J': typeValue = LONG; break; case 'D': typeValue = DOUBLE; break; case 'L': internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1); typeValue = REFERENCE_KIND | symbolTable.addType(internalName); break; default: throw new IllegalArgumentException(); } return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue; default: throw new IllegalArgumentException(); } } \nResponse:", "ground_truth": "Returns the abstract type corresponding to the given type descriptor.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param buffer a string ending with a type descriptor.\n@param offset the start offset of the type descriptor in buffer.\n@return the abstract type corresponding to the given type descriptor.", "predict": "\n\npublic static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String buffer, final int offset) {\n\tint descriptorOffset = offset;\n\tint descriptorLength = buffer.length();\n\tint dimension = 0;\n\tint typeValue = 0;\n\twhile (descriptorOffset < descriptorLength && buffer.charAt(descriptorOffset) == '[') {\n\t\t++descriptorOffset;\n\t\t++dimension;\n\t}\n\tswitch (buffer.charAt(descriptorOffset)) {\n\t\tcase 'V':\n\t\t\treturn 0;\n\t\tcase 'Z':\n\t\tcase 'C':\n\t\tcase 'B':\n\t\tcase 'S':\n\t\tcase 'I':\n\t\t\ttypeValue = INTEGER;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttypeValue = FLOAT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\ttypeValue = LONG;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t"}, {"ID": 1614, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < numLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int numStackTop = 0; for (int i = 0; i < numStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++numStackTop; } } inputStack = new int[numStack + numStackTop]; int inputStackIndex = 0; for (int i = 0; i < numStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; } \nResponse:", "ground_truth": "Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param numLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param numStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}.", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            ClassFileReader classFileReader = new ClassFileReader(\"Test\");\n            classFileReader.read();\n            ClassFile classFile = classFileReader.getClassFile();\n            MethodInfo methodInfo = classFile.getMethod(0);\n            MethodVisitor methodVisitor = new MethodVisitor(methodInfo, classFileReader.getClassName());\n            methodVisitor.visitCode();\n            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, \"Test\", \"setInputFrameFromApiFormat\", \"(Ljava/lang/SymbolTable;II[Ljava/lang/Object;[Ljava/lang/Object;[Ljava/lang/Object;)V\");\n            methodVisitor.visitInsn(Opcodes.RETURN);\n            methodVisitor.visitMaxs("}, {"ID": 1615, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getLocal(final int localIndex) { if (outputLocals == null || localIndex >= outputLocals.length) { // If this local has never been assigned in this basic block, it is still equal to its value // in the input frame. return LOCAL_KIND | localIndex; } else { int abstractType = outputLocals[localIndex]; if (abstractType == 0) { // If this local has never been assigned in this basic block, so it is still equal to its // value in the input frame. abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex; } return abstractType; } } \nResponse:", "ground_truth": "Returns the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the local variable whose value must be returned.\n@return the abstract type stored at the given local variable index in the output frame.", "predict": "\n\n*/\n\npublic class Solution {\n    public int[] getLocalVariable(int[] inputLocals, int[] inputStack, int[] outputLocals, int[] outputStack) {\n        int[] locals = new int[inputLocals.length];\n        int[] stack = new int[inputStack.length];\n        int[] localsCopy = new int[inputLocals.length];\n        int[] stackCopy = new int[inputStack.length];\n        for (int i = 0; i < inputLocals.length; i++) {\n            locals[i] = inputLocals[i];\n            localsCopy[i] = inputLocals[i];\n        }\n        for (int i = 0; i < inputStack.length; i++) {\n            stack[i] = inputStack[i];\n            stackCopy[i] = inputStack[i];\n        }\n        int[] result = new int[outputLocals.length];\n"}, {"ID": 1616, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setLocal(final int localIndex, final int abstractType) { // Create and/or resize the output local variables array if necessary. if (outputLocals == null) { outputLocals = new int[10]; } int outputLocalsLength = outputLocals.length; if (localIndex >= outputLocalsLength) { int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)]; System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength); outputLocals = newOutputLocals; } // Set the local variable. outputLocals[localIndex] = abstractType; } \nResponse:", "ground_truth": "Replaces the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the output frame local variable that must be set.\n@param abstractType the value that must be set.", "predict": "\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] input = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output = new int[10];\n        int[] outputLocals = new int[10];\n        int outputLocalsLength = outputLocals.length;\n        int[] inputLocals = new int[10];\n        int inputLocalsLength = inputLocals.length;\n        int[] inputStack = new int[10];\n        int inputStackLength = inputStack.length;\n        int[] outputStack = new int[10];\n        int outputStackLength = outputStack.length;\n        int[] outputStackTop = new int[10];\n        int outputStackTopLength = outputStackTop.length;\n        int[] input"}, {"ID": 1617, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void push(final int abstractType) { // Create and/or resize the output stack array if necessary. if (outputStack == null) { outputStack = new int[10]; } int outputStackLength = outputStack.length; if (outputStackTop >= outputStackLength) { int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)]; System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength); outputStack = newOutputStack; } // Pushes the abstract type on the output stack. outputStack[outputStackTop++] = abstractType; // Updates the maximum size reached by the output stack, if needed (note that this size is // relative to the input stack size, which is not known yet). short outputStackSize = (short) (outputStackStart + outputStackTop); if (outputStackSize > owner.outputStackMax) { owner.outputStackMax = outputStackSize; } } \nResponse:", "ground_truth": "Pushes the given abstract type on the output frame stack.\n\n@param abstractType an abstract type.", "predict": " void\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] inputStack = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] outputStack = new int[10];\n        int outputStackTop = 0;\n        int outputStackStart = 0;\n        int outputStackMax = 0;\n        int inputStackTop = 0;\n        int inputStackStart = 0;\n        int inputStackMax = 0;\n        int[] inputStack = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] outputStack = new int[10];\n        int outputStackTop = 0;\n        int outputStackStart = 0;\n        int outputStackMax = 0;\n        int input"}, {"ID": 1618, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void push(final SymbolTable symbolTable, final String descriptor) { int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0; int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset); if (abstractType != 0) { push(abstractType); if (abstractType == LONG || abstractType == DOUBLE) { push(TOP); } } } \nResponse:", "ground_truth": "Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param descriptor a type or method descriptor (in which case its return type is pushed).", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        String descriptor = \"Ljava/lang/String;\";\n        int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0;\n        int abstractType = getAbstractTypeFromDescriptor(null, descriptor, typeDescriptorOffset);\n        if (abstractType != 0) {\n            System.out.println(\"abstractType = \" + abstractType);\n        }\n    }\n}\n"}, {"ID": 1619, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pop(final int elements) { if (outputStackTop >= elements) { outputStackTop -= elements; } else { // If the number of elements to be popped is greater than the number of elements in the output // stack, clear it, and pop the remaining elements from the input stack. outputStackStart -= elements - outputStackTop; outputStackTop = 0; } } \nResponse:", "ground_truth": "Pops the given number of abstract types from the output frame stack.\n\n@param elements the number of abstract types that must be popped.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] input = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output5 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] output"}, {"ID": 1620, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pop(final String descriptor) { char firstDescriptorChar = descriptor.charAt(0); if (firstDescriptorChar == '(') { pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1); } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') { pop(2); } else { pop(1); } } \nResponse:", "ground_truth": "Pops as many abstract types from the output frame stack as described by the given descriptor.\n\n@param descriptor a type or method descriptor (in which case its argument types are popped).", "predict": "\n\n*/\n\npublic class Pop {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n"}, {"ID": 1621, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addInitializedType(final int abstractType) { // Create and/or resize the initializations array if necessary. if (initializations == null) { initializations = new int[2]; } int initializationsLength = initializations.length; if (initializationCount >= initializationsLength) { int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)]; System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength); initializations = newInitializations; } // Store the abstract type. initializations[initializationCount++] = abstractType; } \nResponse:", "ground_truth": "Adds an abstract type to the list of types on which a constructor is invoked in the basic\nblock.\n\n@param abstractType an abstract type on a which a constructor is invoked.", "predict": "\n\n*/\n\npublic class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int[] result = new int[2];\n        int[] index = new int[numbers.length];\n        for (int i = 0; i < numbers.length; i++) {\n            index[i] = i;\n        }\n        Arrays.sort(index);\n        for (int i = 0; i < numbers.length; i++) {\n            for (int j = i + 1; j < numbers.length; j++) {\n                if (numbers[i] + numbers[j] == target) {\n                    result[0] = i + 1;\n                    result[1] = j + 1;\n                    return result;\n                }\n            }\n        }\n        return result;\n    }\n}\n"}, {"ID": 1622, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getInitializedType(final SymbolTable symbolTable, final int abstractType) { if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) { for (int i = 0; i < initializationCount; ++i) { int initializedType = initializations[i]; int dim = initializedType & DIM_MASK; int kind = initializedType & KIND_MASK; int value = initializedType & VALUE_MASK; if (kind == LOCAL_KIND) { initializedType = dim + inputLocals[value]; } else if (kind == STACK_KIND) { initializedType = dim + inputStack[inputStack.length - value]; } if (abstractType == initializedType) { if (abstractType == UNINITIALIZED_THIS) { return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName()); } else { return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value); } } } } return abstractType; } \nResponse:", "ground_truth": "Returns the \"initialized\" abstract type corresponding to the given abstract type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type.\n@return the REFERENCE_KIND abstract type corresponding to abstractType if it is\nUNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\nconstructor is invoked in the basic block. Otherwise returns abstractType.", "predict": "\n\npublic int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n\tif (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n\t\tfor (int i = 0; i < initializationCount; ++i) {\n\t\t\tint initializedType = initializations[i];\n\t\t\tint dim = initializedType & DIM_MASK;\n\t\t\tint kind = initializedType & KIND_MASK;\n\t\t\tint value = initializedType & VALUE_MASK;\n\t\t\tif (kind == LOCAL_KIND) {\n\t\t\t\tinitializedType = dim + inputLocals[value];\n\t\t\t} else if (kind == STACK_KIND) {\n\t\t\t\tinitializedType = dim + inputStack[inputStack.length - value];\n\t\t\t}\n\t\t\tif (abstractType == initializedType) {\n\t\t\t\tif (ab"}, {"ID": 1623, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static void putAbstractType( final SymbolTable symbolTable, final int abstractType, final ByteVector output) { int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT; if (arrayDimensions == 0) { int typeValue = abstractType & VALUE_MASK; switch (abstractType & KIND_MASK) { case CONSTANT_KIND: output.putByte(typeValue); break; case REFERENCE_KIND: output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index); break; case UNINITIALIZED_KIND: output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data); break; default: throw new AssertionError(); } } else { // Case of an array type, we need to build its descriptor first. StringBuilder typeDescriptor = new StringBuilder(); while (arrayDimensions-- > 0) { typeDescriptor.append('['); } if ((abstractType & KIND_MASK) == REFERENCE_KIND) { typeDescriptor .append('L') .append(symbolTable.getType(abstractType & VALUE_MASK).value) .append(';'); } else { switch (abstractType & VALUE_MASK) { case Frame.ITEM_ASM_BOOLEAN: typeDescriptor.append('Z'); break; case Frame.ITEM_ASM_BYTE: typeDescriptor.append('B'); break; case Frame.ITEM_ASM_CHAR: typeDescriptor.append('C'); break; case Frame.ITEM_ASM_SHORT: typeDescriptor.append('S'); break; case Frame.ITEM_INTEGER: typeDescriptor.append('I'); break; case Frame.ITEM_FLOAT: typeDescriptor.append('F'); break; case Frame.ITEM_LONG: typeDescriptor.append('J'); break; case Frame.ITEM_DOUBLE: typeDescriptor.append('D'); break; default: throw new AssertionError(); } } output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index); } } \nResponse:", "ground_truth": "Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\nformat used in StackMapTable attributes.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\nFrame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n@param output where the abstract type must be put.\n@see JVMS\n4.7.4", "predict": " Generate the method-level comment for the following java Code. Code: static void putInterfaceMethod( final SymbolTable symbolTable, final int interfaceMethod, final ByteVector output) { int methodAttribute = interfaceMethod & ACC_METHOD_MASK; if (methodAttribute == ACC_ABSTRACT) { output.putByte(METHOD_ABSTRACT); } else if (methodAttribute == ACC_STATIC) { output.putByte(METHOD_STATIC); } else if (methodAttribute == ACC_FINAL) { output.putByte(METHOD_FINAL); } else { output.putByte(METHOD_NATIVE); } output .putShort(symbolTable.addConstantInterfaceMethod(interfaceMethod & VALUE_MASK, interfaceMethod & VALUE_MASK).index); } \nResp Generate the method-level comment for the following java Code. Code: static void putMethod( final SymbolTable symbolTable, final int method, final ByteVector output) { int methodAttribute = method"}, {"ID": 1624, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected int pruneCache() { int count = 0; Iterator<CacheObject<K,V>> values = cacheMap.values().iterator(); while (values.hasNext()) { CacheObject co = values.next(); if (co.isExpired()) { values.remove(); count++; } } return count; } \nResponse:", "ground_truth": "Prunes expired elements from the cache. Returns the number of removed objects.", "predict": " @Override protected int pruneCache() { int count = 0; Iterator<CacheObject<K,V>> values = cacheMap.values().iterator(); while (values.hasNext()) { CacheObject co = values.next(); if (co.isExpired()) { values.remove(); count++; } } return count; } \n */\n\npublic class Solution {\n    public int pruneCache(int n) {\n        int count = 0;\n        Iterator<CacheObject<Integer,Integer>> values = cacheMap.values().iterator();\n        while (values.hasNext()) {\n            CacheObject<Integer,Integer> co = values.next();\n            if (co.isExpired()) {\n                values.remove();\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\nclass CacheObject<K,V> {\n    private K key;\n    private V value;\n    private long expirationTime;\n    \n    public Cache"}, {"ID": 1625, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void schedulePrune(final long delay) { if (pruneTimer != null) { pruneTimer.cancel(); } pruneTimer = new Timer(); pruneTimer.schedule( new TimerTask() { @Override public void run() { prune(); } }, delay, delay ); } \nResponse:", "ground_truth": "Schedules prune.", "predict": "\n\n*/\n\npublic class PruneTimer {\n\tprivate static final Logger LOGGER = Logger.getLogger(PruneTimer.class);\n\tprivate static final long DEFAULT_DELAY = 1000;\n\tprivate static final long DEFAULT_PERIOD = 1000;\n\tprivate static final long DEFAULT_DELAY_IN_SECONDS = 1;\n\tprivate static final long DEFAULT_PERIOD_IN_SECONDS = 1;\n\tprivate static final long DEFAULT_DELAY_IN_MILLIS = 1000;\n\tprivate static final long DEFAULT_PERIOD_IN_MILLIS = 1000;\n\tprivate static final long DEFAULT_DELAY_IN_MICROS = 1000;\n\tprivate static final long DEFAULT_PERIOD_IN_MICROS = 1000;\n\tprivate static final long DEFAULT_DELAY_IN_NANOS = 1000;\n\tprivate static final"}, {"ID": 1626, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ModuleVisitor visitModule(final String name, final int access, final String version) { if (api < Opcodes.ASM6) { throw new UnsupportedOperationException(\"This feature requires ASM6\"); } if (cv != null) { return cv.visitModule(name, access, version); } return null; } \nResponse:", "ground_truth": "Visit the module corresponding to the class.\n\n@param name the fully qualified name (using dots) of the module.\n@param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\nACC_MANDATED}.\n@param version the module version, or {@literal null}.\n@return a visitor to visit the module values, or {@literal null} if this visitor is not\ninterested in visiting this module.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\n\npublic class ModuleVisitor extends ClassVisitor {\n\tprivate List<String> methods = new ArrayList<String>();\n\tprivate String className;\n\tprivate String methodName;\n\tprivate String methodDesc;\n\tprivate int api;\n\tprivate ClassVisitor cv;\n\n\tpublic ModuleVisitor(int api, ClassVisitor cv) {\n\t\tsuper(api, cv);\n\t\tthis.api = api;\n\t\tthis.cv = cv;\n\t}\n\n\tpublic ModuleVisitor(int api) {\n\t\tsuper(api);\n\t\tthis.api = api;\n\t}\n\n\tpublic ModuleVisitor() {\n\t\tsuper(Opcodes.AS"}, {"ID": 1627, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitNestHost(final String nestHost) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestHost(nestHost); } } \nResponse:", "ground_truth": "Visits the nest host class of the class. A nest is a set of classes of the same package that\nshare access to their private members. One of these classes, called the host, lists the other\nmembers of the nest, which in turn should link to the host of their nest. This method must be\ncalled only once and only if the visited class is a non-host member of a nest. A class is\nimplicitly its own nest, so it's invalid to call this method with the visited class name as\nargument.\n\n@param nestHost the internal name of the host class of the nest.", "predict": " public void visitNestHost(final String nestHost) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestHost(nestHost); } } \n */\n\npublic class NestHostVisitor extends MethodVisitor {\n    private final String nestHost;\n    private final int api;\n    private final ClassVisitor cv;\n\n    public NestHostVisitor(final int api, final ClassVisitor cv, final String nestHost) {\n        super(Opcodes.ASM5, cv);\n        this.nestHost = nestHost;\n        this.api = api;\n        this.cv = cv;\n    }\n\n    @Override\n    public void visitNestHost(final String nestHost) {\n        if (api < Opcodes.ASM7) {\n            throw new UnsupportedOperationException(\""}, {"ID": 1628, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitOuterClass(final String owner, final String name, final String descriptor) { if (cv != null) { cv.visitOuterClass(owner, name, descriptor); } } \nResponse:", "ground_truth": "Visits the enclosing class of the class. This method must be called only if the class has an\nenclosing class.\n\n@param owner internal name of the enclosing class of the class.\n@param name the name of the method that contains the class, or {@literal null} if the class is\nnot enclosed in a method of its enclosing class.\n@param descriptor the descriptor of the method that contains the class, or {@literal null} if\nthe class is not enclosed in a method of its enclosing class.", "predict": "\n\n*/\n\npublic class OuterClassVisitor extends ClassVisitor {\n    private final String owner;\n    private final String name;\n    private final String descriptor;\n    private final ClassVisitor cv;\n\n    public OuterClassVisitor(final ClassVisitor cv, final String owner, final String name, final String descriptor) {\n        super(Opcodes.ASM5, cv);\n        this.owner = owner;\n        this.name = name;\n        this.descriptor = descriptor;\n        this.cv = cv;\n    }\n\n    @Override\n    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    @Override\n    public void visitSource(final String source, final String debug) {\n        cv.visitSource("}, {"ID": 1629, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (cv != null) { return cv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of the class.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "\n\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n    if (cv != null) {\n        return cv.visitAnnotation(descriptor, visible);\n    }\n    return null;\n}\n\n*/\n\npublic class AnnotationVisitorGenerator {\n    public static void main(String[] args) {\n        String className = \"AnnotationVisitor\";\n        String methodName = \"visitAnnotation\";\n        String methodDesc = \"(Ljava/lang/String;Z)Ljavax/annotation/AnnotationVisitor;\";\n        String className2 = \"AnnotationVisitor\";\n        String methodName2 = \"visitAnnotation\";\n        String methodDesc2 = \"(Ljava/lang/String;Z)Ljavax/annotation/AnnotationVisitor;\";\n        String className3 = \"AnnotationVisitor\";\n        String methodName3 = \"visit"}, {"ID": 1630, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitNestMember(final String nestMember) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestMember(nestMember); } } \nResponse:", "ground_truth": "Visits a member of the nest. A nest is a set of classes of the same package that share access\nto their private members. One of these classes, called the host, lists the other members of the\nnest, which in turn should link to the host of their nest. This method must be called only if\nthe visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\nit's invalid to call this method with the visited class name as argument.\n\n@param nestMember the internal name of a nest member.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\n\npublic class NestMemberVisitor extends ClassVisitor {\n\tprivate final List<String> nestMembers = new ArrayList<String>();\n\tprivate final ClassVisitor cv;\n\n\tpublic NestMemberVisitor(final ClassVisitor cv) {\n\t\tsuper(Opcodes.ASM5, cv);\n\t\tthis.cv = cv;\n\t}\n\n\t@Override\n\tpublic MethodVisitor visitMethod(final int access, final String name,\n\t\t\tfinal String desc, final String signature, final String[] exceptions) {\n\t\tfinal MethodVisitor mv = cv.visitMethod(access, name, desc, signature,\n\t\t\t\texceptions);\n\t\treturn new Nest"}, {"ID": 1631, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitInnerClass( final String name, final String outerName, final String innerName, final int access) { if (cv != null) { cv.visitInnerClass(name, outerName, innerName, access); } } \nResponse:", "ground_truth": "Visits information about an inner class. This inner class is not necessarily a member of the\nclass being visited.\n\n@param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@param outerName the internal name of the class to which the inner class belongs (see {@link\nType#getInternalName()}). May be {@literal null} for not member classes.\n@param innerName the (simple) name of the inner class inside its enclosing class. May be\n{@literal null} for anonymous inner classes.\n@param access the access flags of the inner class as originally declared in the enclosing\nclass.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@XmlRootElement(name = \"method\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class Method {\n\t@XmlElement(name = \"name\")\n\tprivate String name;\n\t@XmlElement(name = \"access\")\n\tprivate int access;\n\t@XmlElement(name = \"code\")\n\tprivate List<Code> code = new ArrayList<Code>();\n\t@XmlElement(name = \"exceptions\")\n\tprivate List<Exception> exceptions = new ArrayList"}, {"ID": 1632, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldVisitor visitField( final int access, final String name, final String descriptor, final String signature, final Object value) { if (cv != null) { return cv.visitField(access, name, descriptor, signature, value); } return null; } \nResponse:", "ground_truth": "Visits a field of the class.\n\n@param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\nthe field is synthetic and/or deprecated.\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).\n@param signature the field's signature. May be {@literal null} if the field's type does not use\ngeneric types.\n@param value the field's initial value. This parameter, which may be {@literal null} if the\nfield does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\nLong}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\nor {@code String} fields respectively). This parameter is only used for static\nfields. Its value is ignored for non static fields, which must be initialized through\nbytecode instructions in constructors or methods.\n@return a visitor to visit field annotations and attributes, or {@literal null} if this class\nvisitor is not interested in visiting these annotations and attributes.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.FieldNode;\n\npublic class FieldVisitor extends MethodVisitor {\n\t\n\tprivate List<FieldNode> fields = new ArrayList<FieldNode>();\n\t\n\tpublic FieldVisitor(int access, String name, String desc, String signature, String[] exceptions) {\n\t\tsuper(Opcodes.ASM5, new MethodNode(Opcodes.ASM5, access, name, desc, signature, exceptions));\n\t}\n\t\n\tpublic FieldVisitor(int access, String name, String desc, String signature, String[] exceptions, String[] cvParam) {\n\t\tsuper(Opcodes.ASM5, new MethodNode(Opcodes.ASM5, access, name, desc"}, {"ID": 1633, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbThreadSession getThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session == null) { session = new DbThreadSession(); } return session; } \nResponse:", "ground_truth": "Returns existing thread session, or new one if already not exist. If session doesn't exist, it will be created\nusing default connection provider.", "predict": " public static DbThreadSession getThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session == null) { session = new DbThreadSession(); } return session; } \n\n*/\n\npublic class DbThreadSession {\n\t\n\tprivate static final Logger logger = Logger.getLogger(DbThreadSession.class);\n\t\n\tprivate static final String SESSION_NAME = \"DbThreadSession\";\n\t\n\tprivate static final String SESSION_KEY = \"DbThreadSession\";\n\t\n\tprivate static final String SESSION_KEY_PREFIX = \"DbThreadSession.\";\n\t\n\tprivate static final String SESSION_KEY_SUFFIX = \".DbThreadSession\";\n\t\n\tprivate static final String SESSION_KEY_PREFIX_PATTERN = \"DbThreadSession.\";\n\t\n\tprivate static final String SESSION_KEY_SUFFIX_PATTERN ="}, {"ID": 1634, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void closeThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session != null) { session.closeSession(); } } \nResponse:", "ground_truth": "Closes thread session.", "predict": "\n\n*/\n\npublic class CloseThreadSession extends AbstractJavaMethod {\n\n\tpublic CloseThreadSession(String className, String methodName, String desc) {\n\t\tsuper(className, methodName, desc);\n\t}\n\n\t@Override\n\tpublic void generate() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"public static void closeThreadSession() {\\n\");\n\t\tsb.append(\"\\tDbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get();\\n\");\n\t\tsb.append(\"\\tif (session != null) {\\n\");\n\t\tsb.append(\"\\t\\tsession.closeSession();\\n\");\n\t\tsb.append(\"\\t}\\n\");\n\t\tsb.append(\"}\\n\");\n\t\tthis.javadoc = sb.toString();\n\t\tthis.javacode = sb.toString();\n\t}\n\n}\n"}, {"ID": 1635, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionWrapper[] createExecutionArray() { int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0); int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0); ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1]; // filters int index = 0; if (totalFilters > 0) { System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters); index += totalFilters; } // result is executed AFTER the action AND interceptors executionArray[index++] = actionRequest -> { Object actionResult = actionRequest.invoke(); ActionRequest.this.madvocController.render(ActionRequest.this, actionResult); return actionResult; }; // interceptors if (totalInterceptors > 0) { System.arraycopy(actionRuntime.getInterceptors(), 0, executionArray, index, totalInterceptors); index += totalInterceptors; } // action executionArray[index] = actionRequest -> { actionResult = invokeActionMethod(); return actionResult; }; return executionArray; } \nResponse:", "ground_truth": "Creates execution array that will invoke all filters, actions and results\nin correct order.", "predict": " public ActionWrapper[] createExecutionArray() { int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0); int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0); ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1]; // filters int index = 0; if (totalFilters > 0) { System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters); index += totalFilters; } // result is executed AFTER the action AND interceptors executionArray[index++] = actionRequest -> { Object actionResult = actionRequest.invoke(); ActionRequest.this.madvocController.render(ActionRequest.this, actionResult); return actionResult; }; // interceptors if (totalInterceptors > 0) { System."}, {"ID": 1636, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeActionMethod() throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return null; } final Object[] params = targets.extractParametersValues(); try { return actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } } \nResponse:", "ground_truth": "Invokes action method after starting all interceptors.\nAfter method invocation, all interceptors will finish, in opposite order.", "predict": " public void executeAction(Action action) throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return; } final Object[] params = targets.extractParametersValues(); try { actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } } \nResp public void executeAction(Action action, Object... params) throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return; } try { actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } } \nResp public void executeAction(Action action, Map<String, Object> params) throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime."}, {"ID": 1637, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String readRequestBody() { if (requestBody == null) { try { requestBody = ServletUtil.readRequestBodyFromStream(getHttpServletRequest()); } catch (IOException ioex) { requestBody = StringPool.EMPTY; } } return requestBody; } \nResponse:", "ground_truth": "Reads request body only once and returns it to user.", "predict": " public void writeResponseBody(String responseBody) { ServletUtil.writeResponseBodyToStream(getHttpServletResponse(), responseBody); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.serv"}, {"ID": 1638, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) { if (total == 0) { return 0; } if (page < 1) { page = 1; } int first = (page - 1) * pageSize; if (first >= total) { first = ((total - 1) / pageSize) * pageSize; // first item on the last page } return first; } \nResponse:", "ground_truth": "Calculates the first item index of requested page.", "predict": "\n\n*/\n\npublic class Solution {\n    public int firstUniqChar(String s) {\n        int[] map = new int[128];\n        for (int i = 0; i < s.length(); i++) {\n            map[s.charAt(i)]++;\n        }\n        int count = 0;\n        for (int i = 0; i < 128; i++) {\n            if (map[i] > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"}, {"ID": 1639, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int calcFirstItemIndexOfPage(final PageRequest pageRequest, final int total) { return calcFirstItemIndexOfPage(pageRequest.getPage(), pageRequest.getSize(), total); } \nResponse:", "ground_truth": "Calculates first item index of the page.", "predict": "\n\npublic static int calcFirstItemIndexOfPage(final int page, final int size, final int total) {\n\treturn (page - 1) * size;\n}\n\n*/\n\npublic class PageRequest {\n\tprivate int page;\n\tprivate int size;\n\t\n\tpublic PageRequest(int page, int size) {\n\t\tthis.page = page;\n\t\tthis.size = size;\n\t}\n\t\n\tpublic int getPage() {\n\t\treturn page;\n\t}\n\t\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\t\n\tpublic int getTotal() {\n\t\treturn size * page;\n\t}\n\t\n\tpublic int getTotalPages() {\n\t\treturn (int)Math.ceil(getTotal() / (double)size);\n\t}\n\t\n\tpublic int getFirstItemIndexOfPage(int total) {\n\t\treturn (page - 1) * size;\n\t}\n"}, {"ID": 1640, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean match(final int value) { if (a == 0) { return value == b; } if (a > 0) { if (value < b) { return false; } return (value - b) % a == 0; } if (value > b) { return false; } return (b - value) % (-a) == 0; } \nResponse:", "ground_truth": "Matches expression with the value.", "predict": "\n\n*/\n\npublic class Solution {\n    public boolean match(int a, int b) {\n        if (a == 0) {\n            return b == 0;\n        }\n        if (a > 0) {\n            if (b < 0) {\n                return false;\n            }\n            return (b - a) % a == 0;\n        }\n        if (b > 0) {\n            return (a - b) % (-a) == 0;\n        }\n        return false;\n    }\n}\n"}, {"ID": 1641, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] toRawByteArray(final char[] carr) { byte[] barr = new byte[carr.length << 1]; for (int i = 0, bpos = 0; i < carr.length; i++) { char c = carr[i]; barr[bpos++] = (byte) ((c & 0xFF00) >> 8); barr[bpos++] = (byte) (c & 0x00FF); } return barr; } \nResponse:", "ground_truth": "Converts char array into byte array by replacing each character with two bytes.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.byteArrayToHexStr(s.byteArrayToHexStr(s.byteArrayToHexStr(\"abcd\".toCharArray()))));\n    }\n\n    public String byteArrayToHexStr(String str) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : str.getBytes()) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n}\n"}, {"ID": 1642, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstDiff(final char[] source, final int index, final char[] match) { for (int i = index; i < source.length; i++) { if (!equalsOne(source[i], match)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given array the differs from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "\n\npublic static int findFirstDiff(final char[] source, final int index, final char[] match) {\n    int i = index;\n    int j = 0;\n    int count = 0;\n    while (i < source.length && j < match.length) {\n        if (source[i] != match[j]) {\n            if (count == 0) {\n                return i;\n            } else {\n                count--;\n            }\n        }\n        i++;\n        j++;\n    }\n    return -1;\n}\n\n*/\n\npublic class Solution {\n    public int findFirstDiff(final char[] source, final int index, final char[] match) {\n        int i = index;\n        int j = 0;\n        int count = 0;\n        while (i < source.length && j < match.length) {\n            if (source[i] != match[j]) {\n                if (count == 0"}, {"ID": 1643, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; } \nResponse:", "ground_truth": "Renders node name.", "predict": " Generate the method-level comment for the following java Code. Code: protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; } \nResp Generate the method-level comment for the following java Code. Code: protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; } \nResp Generate the method-level comment for the following java Code. Code: protected"}, {"ID": 1644, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveAttributeName(final Node node, final Attribute attribute) { switch (attributeCase) { case DEFAULT: return attribute.getName(); case RAW: return attribute.getRawName(); case LOWERCASE: return attribute.getRawName().toLowerCase(); case UPPERCASE: return attribute.getRawName().toUpperCase(); } return null; } \nResponse:", "ground_truth": "Renders attribute name.", "predict": " public String resolveAttributeName(final Node node, final Attribute attribute) { switch (attributeCase) { case DEFAULT: return attribute.getName(); case RAW: return attribute.getRawName(); case LOWERCASE: return attribute.getRawName().toLowerCase(); case UPPERCASE: return attribute.getRawName().toUpperCase(); } return null; } \n\n// End of user code\n\n}\n"}, {"ID": 1645, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDoubleQuoted(value)); appendable.append('\\\"'); } } \nResponse:", "ground_truth": "Renders attribute.", "predict": " Generate the method-level comment for the following java Code. Code: protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDoubleQuoted(value)); appendable.append('\\\"'); } } \nResp Generate the method-level comment for the following java Code. Code: protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDouble"}, {"ID": 1646, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final File file) throws IOException { final String extension = FileNameUtil.getExtension(file.getAbsolutePath()); final String data; if (extension.equalsIgnoreCase(\"properties\")) { data = FileUtil.readString(file, StringPool.ISO_8859_1); } else { data = FileUtil.readString(file); } parse(data); return this; } \nResponse:", "ground_truth": "Loads props from the file. Assumes UTF8 encoding unless\nthe file ends with '.properties', than it uses ISO 8859-1.", "predict": " public Props load(final File file) throws IOException { return load(file, null); } \nResp public Props load(final File file, final String encoding) throws IOException { return load(file, encoding, null); } \nResp public Props load(final File file, final String encoding, final String comment) throws IOException { return load(file, encoding, comment, null); } \nResp public Props load(final File file, final String encoding, final String comment, final String lineSeparator) throws IOException { return load(file, encoding, comment, lineSeparator, null); } \nResp public Props load(final File file, final String encoding, final String comment, final String lineSeparator, final String keyValueSeparator) throws IOException { return load(file, encoding, comment, lineSeparator, keyValueSeparator, null); } \nResp public Props load(final File file, final String"}, {"ID": 1647, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final File file, final String encoding) throws IOException { parse(FileUtil.readString(file, encoding)); return this; } \nResponse:", "ground_truth": "Loads properties from the file in provided encoding.", "predict": " public Props load(final File file, final String encoding) throws IOException { parse(FileUtil.readString(file, encoding)); return this; } \n\n*/\n\npublic class Props {\n\t\n\tprivate static final String PROPS_FILE_EXTENSION = \".properties\";\n\tprivate static final String PROPS_FILE_EXTENSION_REGEX = \"\\\\.properties$\";\n\t\n\tprivate static final String PROPS_FILE_PREFIX = \"props\";\n\tprivate static final String PROPS_FILE_PREFIX_REGEX = \"^props\";\n\t\n\tprivate static final String PROPS_FILE_SUFFIX = \"Props\";\n\tprivate static final String PROPS_FILE_SUFFIX_REGEX = \"Props$\";\n\t\n\tprivate static final String PROPS_FILE_PREFIX_REGEX_WITH_SUFFIX = PROPS_FILE_PREFIX_REGEX +"}, {"ID": 1648, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final InputStream in) throws IOException { final Writer out = new FastCharArrayWriter(); StreamUtil.copy(in, out); parse(out.toString()); return this; } \nResponse:", "ground_truth": "Loads properties from input stream. Stream is not closed at the end.", "predict": " public Props load(final InputStream in) throws IOException { final Writer out = new FastCharArrayWriter(); StreamUtil.copy(in, out); parse(out.toString()); return this; } \n\n*/\n\npublic class Props {\n\tprivate static final String PROPS_FILE = \"props.txt\";\n\tprivate static final String PROPS_FILE_PATH = \"src/main/resources/\";\n\tprivate static final String PROPS_FILE_PATH_RELATIVE = \"src/main/resources/\";\n\tprivate static final String PROPS_FILE_PATH_RELATIVE_LAST = \"src/main/resources/\";\n\tprivate static final String PROPS_FILE_PATH_RELATIVE_LAST_LAST = \"src/main/resources/\";\n\tprivate static final String PROPS_FILE_PATH_RELATIVE_LAST_LAST_LAST = \"src/main/resources/\";\n\tprivate static final String PROPS"}, {"ID": 1649, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final Map<?, ?> p) { for (final Map.Entry<?, ?> entry : p.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(name, value.toString(), false); } return this; } \nResponse:", "ground_truth": "Loads base properties from the provided java properties.\nNull values are ignored.", "predict": " public Props load(final Map<?, ?> p) { for (final Map.Entry<?, ?> entry : p.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(name, value.toString(), false); } return this; } \n\n*/\n\npublic class Props {\n\tprivate final Map<String, String> data = new HashMap<String, String>();\n\t\n\tpublic Props() {\n\t\t\n\t}\n\t\n\tpublic Props(final Map<String, String> data) {\n\t\tthis.data.putAll(data);\n\t}\n\t\n\tpublic Props(final String[] args) {\n\t\tfor (final String arg : args) {\n\t\t\tfinal String[] parts = arg.split(\"=\");\n\t\t\tif (parts.length == 2) {\n\t\t\t\tdata.put("}, {"ID": 1650, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Props load(final Map<?, ?> map, final String prefix) { String realPrefix = prefix; realPrefix += '.'; for (final Map.Entry entry : map.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(realPrefix + name, value.toString(), false); } return this; } \nResponse:", "ground_truth": "Loads base properties from java Map using provided prefix.\nNull values are ignored.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1651, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props loadFromClasspath(final String... patterns) { ClassScanner.create() .registerEntryConsumer(entryData -> { String usedEncoding = JoddCore.encoding; if (StringUtil.endsWithIgnoreCase(entryData.name(), \".properties\")) { usedEncoding = StringPool.ISO_8859_1; } final String encoding = usedEncoding; UncheckedException.runAndWrapException(() -> load(entryData.openInputStream(), encoding)); }) .includeResources(true) .ignoreException(true) .excludeCommonJars() .excludeAllEntries(true) .includeEntries(patterns) .scanDefaultClasspath() .start(); return this; } \nResponse:", "ground_truth": "Loads props and properties from the classpath.", "predict": " public Props load(final InputStream inputStream, final String encoding) { return load(inputStream, encoding, null); } \nResp public Props load(final InputStream inputStream, final String encoding, final String fileName) { return load(inputStream, encoding, fileName, null); } \nResp public Props load(final InputStream inputStream, final String encoding, final String fileName, final String comment) { return load(inputStream, encoding, fileName, comment, null); } \nResp public Props load(final InputStream inputStream, final String encoding, final String fileName, final String comment, final String propertyName) { return load(inputStream, encoding, fileName, comment, propertyName, null); } \nResp public Props load(final InputStream inputStream, final String encoding, final String fileName, final String comment, final String propertyName, final String propertyValue) { return load(inputStream, encoding, fileName, comment,"}, {"ID": 1652, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; } \nResponse:", "ground_truth": "Returns value of property, using active profiles or default value if not found.", "predict": " public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; } \nResp public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; } \nResp public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; } \nResp public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; }"}, {"ID": 1653, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setValue(final String key, final String value, final String profile) { if (profile == null) { data.putBaseProperty(key, value, false); } else { data.putProfileProperty(key, value, profile, false); } initialized = false; } \nResponse:", "ground_truth": "Sets value on some profile.", "predict": " Response is generated by the method.\n\n*/\n\npublic class SetProperty extends AbstractJavaMethod {\n\t\n\tpublic SetProperty(String name, String value, String profile) {\n\t\tsuper(name, value, profile);\n\t}\n\t\n\t@Override\n\tpublic String generate() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"public void setValue(final String key, final String value, final String profile) {\\n\");\n\t\tsb.append(\"if (profile == null) {\\n\");\n\t\tsb.append(\"data.putBaseProperty(key, value, false);\\n\");\n\t\tsb.append(\"} else {\\n\");\n\t\tsb.append(\"data.putProfileProperty(key, value, profile, false);\\n\");\n\t\tsb.append(\"}\\n\");\n\t\tsb.append(\"initialized = false;\\n\");\n\t\tsb.append(\"}\\n\");\n\t\treturn sb.toString();\n\t}\n"}, {"ID": 1654, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractProps(final Map target) { initialize(); data.extract(target, activeProfiles, null, null); } \nResponse:", "ground_truth": "Extracts props belonging to active profiles.", "predict": " Response = new Response();\nResponse.setStatus(Response.Status.OK);\nResponse.setEntity(data.extract(target, activeProfiles, null, null));\n}\n\n}\n"}, {"ID": 1655, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractProps(final Map target, final String... profiles) { initialize(); data.extract(target, profiles, null, null); } \nResponse:", "ground_truth": "Extract props of given profiles.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1656, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractSubProps(final Map target, final String... wildcardPatterns) { initialize(); data.extract(target, activeProfiles, wildcardPatterns, null); } \nResponse:", "ground_truth": "Extracts subset of properties that matches given wildcards.", "predict": " Response = new Response();\nResponse.setStatus(Response.Status.OK);\nResponse.setEntity(data.getExtractedProperties());\nResponse.setMetadata(data.getExtractedPropertiesMetadata());\nreturn Response;\n}\n\n@PUT\n@Path(\"/{id}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic Response update(@PathParam(\"id\") final String id, final String json) {\nfinal Data data = new Data();\ndata.setId(id);\ndata.setJson(json);\ndata.setActiveProfiles(activeProfiles);\ndata.setWildcardPatterns(wildcardPatterns);\ndata.setExtractedProperties(extractedProperties);\ndata.setExtractedPropertiesMetadata(extractedPropertiesMetadata);\ndata.setExtractedPropertiesMetadata(extractedPropertiesMetadata);"}, {"ID": 1657, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Map<String, Object> innerMap(final String prefix) { initialize(); return data.extract(null, activeProfiles, null, prefix); } \nResponse:", "ground_truth": "Returns inner map from the props with given prefix. Keys in returned map\nwill not have the prefix.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1658, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } for (Map.Entry<?, ?> entry : map.entrySet()) { String key = entry.getKey().toString(); key = prefix + key; setValue(key, entry.getValue().toString(), profile); } } \nResponse:", "ground_truth": "Adds child map to the props on given prefix.", "predict": "\n\n*/\n\npublic class MapUtil {\n\t\n\tpublic static void addInnerMap(String prefix, final Map<?, ?> map, final String profile) {\n\t\tif (!StringUtil.endsWithChar(prefix, '.')) {\n\t\t\tprefix += StringPool.DOT;\n\t\t}\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tString key = entry.getKey().toString();\n\t\t\tkey = prefix + key;\n\t\t\tsetValue(key, entry.getValue().toString(), profile);\n\t\t}\n\t}\n\t\n\tpublic static void setValue(String key, String value, String profile) {\n\t\tif (profile != null) {\n\t\t\tkey = key + \".\" + profile;\n\t\t}\n\t\t\n\t\tif (key.contains(\".\")) {\n\t\t\tString[] parts = key.split(\"\\\\.\");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t"}, {"ID": 1659, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void resolveActiveProfiles() { if (activeProfilesProp == null) { activeProfiles = null; return; } final PropsEntry pv = data.getBaseProperty(activeProfilesProp); if (pv == null) { // no active profile set as the property, exit return; } final String value = pv.getValue(); if (StringUtil.isBlank(value)) { activeProfiles = null; return; } activeProfiles = StringUtil.splitc(value, ','); StringUtil.trimAll(activeProfiles); } \nResponse:", "ground_truth": "Resolves active profiles from special property.\nThis property can be only a base property!\nIf default active property is not defined, nothing happens.\nOtherwise, it will replace currently active profiles.", "predict": "\n\n*/\n\npackage com.intuit.tank.harness.functions;\n\n/*\n * #%L\n * Intuit Tank Agent (apiharness)\n * %%\n * Copyright (C) 2011 - 2015 Intuit Inc.\n * %%\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n * #L%\n */\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.intuit.tank.harness.data.HDScript;\nimport com.intuit.tank.harness.data.HDScriptGroup;\nimport com.intuit.tank.harness.data.HDScriptUseCase;\nimport com.intuit.tank.harness.data.HDScriptUseCaseStep;"}, {"ID": 1660, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getAllProfiles() { String[] profiles = new String[data.profileProperties.size()]; int index = 0; for (String profileName : data.profileProperties.keySet()) { profiles[index] = profileName; index++; } return profiles; } \nResponse:", "ground_truth": "Returns all profiles names.", "predict": " public String[] getAllProfiles() { String[] profiles = new String[data.profileProperties.size()]; int index = 0; for (String profileName : data.profileProperties.keySet()) { profiles[index] = profileName; index++; } return profiles; } \n\n*/\n\npublic class ProfileProperty {\n\tprivate String name;\n\tprivate String value;\n\t\n\tpublic ProfileProperty(String name, String value) {\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n}\n"}, {"ID": 1661, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getProfilesFor(final String propKeyNameWildcard) { HashSet<String> profiles = new HashSet<>(); profile: for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) { String profileName = entries.getKey(); Map<String, PropsEntry> value = entries.getValue(); for (String propKeyName : value.keySet()) { if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) { profiles.add(profileName); continue profile; } } } return profiles.toArray(new String[0]); } \nResponse:", "ground_truth": "Returns all the profiles that define certain prop's key name.\nKey name is given as a wildcard, or it can be matched fully.", "predict": " public String[] getProfilesFor(final String propKeyNameWildcard) { HashSet<String> profiles = new HashSet<>(); profile: for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) { String profileName = entries.getKey(); Map<String, PropsEntry> value = entries.getValue(); for (String propKeyName : value.keySet()) { if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) { profiles.add(profileName); continue profile; } } } return profiles.toArray(new String[0]); } \n\n*/\n"}, {"ID": 1662, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addPropertyInjectionPoint(final PropertyInjectionPoint pip) { if (properties == null) { properties = new PropertyInjectionPoint[1]; properties[0] = pip; } else { properties = ArraysUtil.append(properties, pip); } } \nResponse:", "ground_truth": "Adds property injection point.", "predict": " void\n*/\n\npublic class PropertyInjectionPoint {\n    private String name;\n    private String value;\n    private String type;\n    private String scope;\n    private String description;\n    private String defaultValue;\n    private String method;\n    private String target;\n    private String targetType;\n    private String injectionPointType;\n    private String injectionPointName;\n    private String beanName;\n    private String beanClassName;\n    private String beanScope;\n    private String beanType;\n    private String beanQualifier;\n    private String beanNameOrId;\n    private String beanId;\n    private String beanTarget;\n    private String beanTargetType;\n    private String beanTargetQualifier;\n    private String beanTargetNameOrId;\n    private String beanTargetId;\n    private String beanTargetScope;\n    private String beanTargetTypeName;\n    private String beanTargetQualifierName;\n    private String beanTargetName;\n    "}, {"ID": 1663, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addSetInjectionPoint(final SetInjectionPoint sip) { if (sets == null) { sets = new SetInjectionPoint[1]; sets[0] = sip; } else { sets = ArraysUtil.append(sets, sip); } } \nResponse:", "ground_truth": "Adds set injection point.", "predict": " void\nExceptions:  IllegalArgumentException\n    */\n    public void addSetInjectionPoint(final SetInjectionPoint sip) throws IllegalArgumentException {\n        if (sets == null) {\n            sets = new SetInjectionPoint[1];\n            sets[0] = sip;\n        } else {\n            sets = ArraysUtil.append(sets, sip);\n        }\n    }\n\n    /**\n     * @return Returns the sets.\n     */\n    public SetInjectionPoint[] getSets() {\n        return sets;\n    }\n\n    /**\n     * @param sets The sets to set.\n     */\n    public void setSets(final SetInjectionPoint[] sets) {\n        this.sets = sets;\n    }\n\n    /**\n     * @return Returns the sets.\n     */\n    public SetInjectionPoint getSetInjectionPoint() {\n        return sets[0];\n    }\n\n    /**"}, {"ID": 1664, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addMethodInjectionPoint(final MethodInjectionPoint mip) { if (methods == null) { methods = new MethodInjectionPoint[1]; methods[0] = mip; } else { methods = ArraysUtil.append(methods, mip); } } \nResponse:", "ground_truth": "Adds method injection point.", "predict": "\n\n*/\n\npublic class MethodInjectionPoint {\n    private final String methodName;\n    private final String className;\n    private final String methodSignature;\n    private final String methodDescription;\n    private final String methodReturnType;\n    private final String methodReturnDescription;\n    private final String methodReturnTypeName;\n    private final String methodReturnDescriptionName;\n    private final String methodReturnTypeNameWithParameters;\n    private final String methodReturnDescriptionNameWithParameters;\n    private final String methodReturnTypeNameWithParametersAndReturnDescription;\n    private final String methodReturnDescriptionNameWithParametersAndReturnDescription;\n    private final String methodReturnTypeNameWithParametersAndReturnDescriptionAndReturnDescription;\n    private final String methodReturnDescriptionNameWithParametersAndReturnDescriptionAndReturnDescription;\n    private final String methodReturnTypeNameWithParametersAndReturnDescriptionAndReturnDescriptionAndReturnDescription;\n    private final String methodReturnDescriptionNameWithParametersAndReturnDescriptionAndReturnDescriptionAndReturnDescription;\n"}, {"ID": 1665, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addInitMethodPoints(final InitMethodPoint[] methods) { if (initMethods == null) { initMethods = methods; } else { initMethods = ArraysUtil.join(initMethods, methods); } } \nResponse:", "ground_truth": "Adds init methods.", "predict": "\n\n*/\n\npublic class InitMethodPoint {\n\tpublic static final String INIT_METHOD_POINT_CLASS = \"org.eclipse.jdt.internal.core.ClassFile\";\n\tpublic static final String INIT_METHOD_POINT_METHOD = \"addInitMethodPoints\";\n\tpublic static final String INIT_METHOD_POINT_METHOD_SIGNATURE = \"([Lorg/eclipse/jdt/internal/core/ClassFile;)V\";\n\tpublic static final String INIT_METHOD_POINT_METHOD_NAME = \"addInitMethodPoints\";\n\tpublic static final String INIT_METHOD_POINT_METHOD_SIGNATURE_NAME = \"addInitMethodPoints\";\n\tpublic static final String INIT_METHOD_POINT_METHOD_RETURN_TYPE = \"void\";\n\tpublic static final String INIT_METHOD_POINT_METHOD_RETURN_TYPE_NAME = \"void\";\n\tpublic static final String INIT_METHOD"}, {"ID": 1666, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addDestroyMethodPoints(final DestroyMethodPoint[] methods) { if (destroyMethods == null) { destroyMethods = methods; } else { destroyMethods = ArraysUtil.join(destroyMethods, methods); } } \nResponse:", "ground_truth": "Adds destroy methods.", "predict": " void\n*/\n\npublic class DestroyMethodPoint {\n\tprivate String methodName;\n\tprivate String methodSignature;\n\tprivate String methodDescription;\n\tprivate String methodReturnType;\n\tprivate String methodReturnDescription;\n\tprivate String methodReturnTypeName;\n\tprivate String methodReturnDescriptionName;\n\tprivate String methodReturnTypeQualifiedName;\n\tprivate String methodReturnDescriptionQualifiedName;\n\tprivate String methodReturnTypeQualifiedNameWithParameters;\n\tprivate String methodReturnDescriptionQualifiedNameWithParameters;\n\tprivate String methodReturnTypeQualifiedNameWithParametersAndReturnDescription;\n\tprivate String methodReturnDescriptionQualifiedNameWithParametersAndReturnDescription;\n\tprivate String methodReturnTypeQualifiedNameWithParametersAndReturnDescriptionAndReturnDescription;\n\tprivate String methodReturnDescriptionQualifiedNameWithParametersAndReturnDescriptionAndReturnDescription;\n\tprivate String methodReturnTypeQualifiedNameWithParametersAndReturnDescriptionAndReturnDescriptionAndReturnDescription;\n\tprivate String methodReturnDescriptionQualified"}, {"ID": 1667, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class resolveTargetClass(final Class proxy) { final String name = proxy.getName(); if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) { return proxy.getSuperclass(); } if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) { return getTargetWrapperType(proxy); } return proxy; } \nResponse:", "ground_truth": "Returns target class if proxetta applied on given class.\nIf not, returns given class as result.", "predict": "\n\n*/\n\npublic class ProxyClassGenerator {\n\n    private static final String PROXY_CLASS_NAME_SUFFIX = \"Proxy\";\n    private static final String WRAPPER_CLASS_NAME_SUFFIX = \"Wrapper\";\n    private static final String PROXY_CLASS_NAME_PREFIX = \"Proxetta\";\n    private static final String WRAPPER_CLASS_NAME_PREFIX = \"Proxetta\";\n\n    private static final String PROXY_CLASS_NAME_SUFFIX_STRING = \"Proxy\";\n    private static final String WRAPPER_CLASS_NAME_SUFFIX_STRING = \"Wrapper\";\n    private static final String PROXY_CLASS_NAME_PREFIX_STRING = \"Proxetta\";\n    private static final String WRAPPER_CLASS_NAME_PREFIX_STRING = \"Proxetta\";\n\n    private static final String PROXY_CLASS_NAME_SUFFIX_STR"}, {"ID": 1668, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void injectTargetIntoWrapper(final Object target, final Object wrapper) { injectTargetIntoWrapper(target, wrapper, ProxettaNames.wrapperTargetFieldName); } \nResponse:", "ground_truth": "Injects target instance into proxy using default target field name.\n@see #injectTargetIntoWrapper(Object, Object, String)", "predict": "\n\npublic static void injectTargetIntoWrapper(final Object target, final Object wrapper, final String wrapperTargetFieldName) {\n    try {\n        final Field wrapperTargetField = wrapper.getClass().getDeclaredField(wrapperTargetFieldName);\n        wrapperTargetField.setAccessible(true);\n        wrapperTargetField.set(wrapper, target);\n    } catch (final Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\n*/\n\npublic class WrapperTargetFieldNameGenerator implements FieldNameGenerator {\n\n    private final String wrapperTargetFieldName;\n\n    public WrapperTargetFieldNameGenerator(final String wrapperTargetFieldName) {\n        this.wrapperTargetFieldName = wrapperTargetFieldName;\n    }\n\n    @Override\n    public String generateFieldName(final Field field) {\n        return wrapperTargetFieldName;\n    }\n}\n"}, {"ID": 1669, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class getTargetWrapperType(final Class wrapperClass) { try { final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName); return field.getType(); } catch (NoSuchFieldException nsfex) { throw new ProxettaException(nsfex); } } \nResponse:", "ground_truth": "Returns wrapper target type.", "predict": "\n\npublic static Class getTargetWrapperType(final Class wrapperClass) {\n    try {\n        final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName);\n        return field.getType();\n    } catch (NoSuchFieldException nsfex) {\n        throw new ProxettaException(nsfex);\n    }\n}\n\n*/\n\npublic static class WrapperClass {\n    public static Class getTargetWrapperType(final Class wrapperClass) {\n        try {\n            final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName);\n            return field.getType();\n        } catch (NoSuchFieldException nsfex) {\n            throw new ProxettaException(nsfex);\n        }\n    }\n}\n"}, {"ID": 1670, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected FieldDescriptor findField(final String fieldName) { FieldDescriptor fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } // field descriptor not found in this class // try to locate it in the superclasses Class[] superclasses = classDescriptor.getAllSuperclasses(); for (Class superclass : superclasses) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(superclass); fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } } // nothing found return null; } \nResponse:", "ground_truth": "Locates property field. Field is being searched also in all\nsuperclasses of current class.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\npublic class FieldDescriptor {\n\n\tprivate final String fieldName;\n\tprivate final Class<?> fieldType;\n\tprivate final boolean isStatic;\n\tprivate final boolean isFinal;\n\tprivate final boolean isTransient;\n\tprivate final boolean isVolatile;\n\tprivate final boolean isEnum;\n\tprivate final boolean isSynthetic;\n\tprivate final boolean isSyntheticEnum;\n\tprivate final boolean isEnumConstant;\n\tprivate final boolean isEnumOrd"}, {"ID": 1671, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class getType() { if (type == null) { if (fieldDescriptor != null) { type = fieldDescriptor.getRawType(); } else if (readMethodDescriptor != null) { type = getGetter(true).getGetterRawType(); //type = readMethodDescriptor.getGetterRawType(); } else if (writeMethodDescriptor != null) { type = getSetter(true).getSetterRawType(); //type = writeMethodDescriptor.getSetterRawType(); } } return type; } \nResponse:", "ground_truth": "Returns property type. Raw types are detected.", "predict": " public Class getType() { return type; } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString className = \"Test\";\n\t\tString packageName = \"com.example.test\";\n\t\tString classNameWithPackage = packageName + \".\" + className;\n\t\t\n\t\tString classNameWithPackageWithDot = packageName + \".\" + className;\n\t\t\n\t\tString classNameWithPackageWithDotWithDot = packageName + \".\" + className + \".\";\n\t\t\n\t\tString classNameWithPackageWithDotWithDotWithDot = packageName + \".\" + className + \".\" + \"Test\";\n\t\t\n\t\tString classNameWithPackageWithDotWithDotWithDotWithDot = packageName + \".\" + className + \".\" + \"Test\" + \".\";\n\t\t\n\t\tString classNameWithPackageWithDotWith"}, {"ID": 1672, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class resolveKeyType(final boolean declared) { Class keyType = null; Getter getter = getGetter(declared); if (getter != null) { keyType = getter.getGetterRawKeyComponentType(); } if (keyType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { keyType = fieldDescriptor.getRawKeyComponentType(); } } return keyType; } \nResponse:", "ground_truth": "Resolves key type for given property descriptor.", "predict": " public Class resolveValueType(final boolean declared) { Class valueType = null; Getter getter = getGetter(declared); if (getter != null) { valueType = getter.getGetterRawValueComponentType(); } if (valueType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { valueType = fieldDescriptor.getRawValueComponentType(); } } return valueType; } \n\n*/\n\npublic class Getter {\n\tprivate final String name;\n\tprivate final String type;\n\tprivate final boolean declared;\n\t\n\tpublic Getter(String name, String type, boolean declared) {\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.declared = declared;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getType() {\n\t\treturn type"}, {"ID": 1673, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class resolveComponentType(final boolean declared) { Class componentType = null; Getter getter = getGetter(declared); if (getter != null) { componentType = getter.getGetterRawComponentType(); } if (componentType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { componentType = fieldDescriptor.getRawComponentType(); } } return componentType; } \nResponse:", "ground_truth": "Resolves component type for given property descriptor.", "predict": " public Class resolveComponentType(final boolean declared) { Class componentType = null; Getter getter = getGetter(declared); if (getter != null) { componentType = getter.getGetterRawComponentType(); } if (componentType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { componentType = fieldDescriptor.getRawComponentType(); } } return componentType; } \n\n*/\n\npublic class Getter {\n\tprivate final String name;\n\tprivate final String type;\n\tprivate final boolean declared;\n\tprivate final boolean isStatic;\n\tprivate final boolean isFinal;\n\tprivate final boolean isPrivate;\n\tprivate final boolean isProtected;\n\tprivate final boolean isPublic;\n\tprivate final boolean isAbstract;\n\tprivate final boolean isNative;\n\tprivate final boolean isSynchronized;\n\tprivate final boolean isTransient;\n\tprivate final"}, {"ID": 1674, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonResult of(final Object object) { final String json = JsonSerializer.create().deep(true).serialize(object); return new JsonResult(json); } \nResponse:", "ground_truth": "Creates JSON result from given object. The object will be serialized to JSON.", "predict": " Response of the following java Code. Code: public static JsonResult of(final Object object) { final String json = JsonSerializer.create().deep(true).serialize(object); return new JsonResult(json); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger."}, {"ID": 1675, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonResult of(final Exception exception) { final HashMap<String, Object> errorMap = new HashMap<>(); errorMap.put(\"message\", ExceptionUtil.message(exception)); errorMap.put(\"error\", exception.getClass().getName()); errorMap.put(\"cause\", exception.getCause() != null ? exception.getCause().getClass().getName() : null); final ArrayList<String> details = new ArrayList<>(); final StackTraceElement[] ste = ExceptionUtil.getStackTrace(exception, null, null); for (StackTraceElement stackTraceElement : ste) { details.add(stackTraceElement.toString()); } errorMap.put(\"details\", details); final String json = JsonSerializer.create().deep(true).serialize(errorMap); return new JsonResult(json).status(HttpStatus.error500().internalError()); } \nResponse:", "ground_truth": "Creates a JSON response from an exception. Response body will have information about the\nexception and response status will be set to 500.", "predict": "\n\n*/\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.TextNode;\nimport com.fasterxml.jackson.databind.node.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.node.ValueNode;\nimport com.fasterxml.jackson.databind.util.JSONPObject;\nimport com.fasterxml.jackson.databind.util.JSONWrappedObject;\nimport com.fasterxml.jackson.databind.util.TreeTraversingParser;\nimport com.fasterxml.jackson.databind.util.UnmodifiableMap;\nimport com"}, {"ID": 1676, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveHttpMethodFromMethodName(final String methodName) { int i = 0; while (i < methodName.length()) { if (CharUtil.isUppercaseAlpha(methodName.charAt(i))) { break; } i++; } final String name = methodName.substring(0, i).toUpperCase(); for (final HttpMethod httpMethod : HttpMethod.values()) { if (httpMethod.equalsName(name)) { return httpMethod.name(); } } return null; } \nResponse:", "ground_truth": "Resolves HTTP method name from method name.\nIf method name or first camel-case word of a method equals to\na HTTP method, it will be used as that HTTP methods.", "predict": " public ResponseEntity<String> resolveHttpMethodFromMethodName(final String methodName) { return resolveHttpMethodFromMethodName(methodName); }\n\n*/\n\npublic class HttpMethod {\n    public static final HttpMethod GET = new HttpMethod(\"GET\");\n    public static final HttpMethod POST = new HttpMethod(\"POST\");\n    public static final HttpMethod PUT = new HttpMethod(\"PUT\");\n    public static final HttpMethod DELETE = new HttpMethod(\"DELETE\");\n    public static final HttpMethod HEAD = new HttpMethod(\"HEAD\");\n    public static final HttpMethod OPTIONS = new HttpMethod(\"OPTIONS\");\n    public static final HttpMethod TRACE = new HttpMethod(\"TRACE\");\n    public static final HttpMethod PATCH = new HttpMethod(\"PATCH\");\n    public static final HttpMethod CONNECT = new HttpMethod(\"CONNECT\");\n    public static final Http"}, {"ID": 1677, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) { int pLen = pattern.length(); if (pLen == 1) { if (pattern.charAt(0) == '*') { // speed-up return true; } } int sLen = string.length(); boolean nextIsNotWildcard = false; while (true) { // check if end of string and/or pattern occurred if ((sNdx >= sLen)) { // end of string still may have pending '*' in pattern while ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) { pNdx++; } return pNdx >= pLen; } if (pNdx >= pLen) { // end of pattern, but not end of the string return false; } char p = pattern.charAt(pNdx); // pattern char // perform logic if (!nextIsNotWildcard) { if (p == '\\\\') { pNdx++; nextIsNotWildcard = true; continue; } if (p == '?') { sNdx++; pNdx++; continue; } if (p == '*') { char pNext = 0; // next pattern char if (pNdx + 1 < pLen) { pNext = pattern.charAt(pNdx + 1); } if (pNext == '*') { // double '*' have the same effect as one '*' pNdx++; continue; } int i; pNdx++; // find recursively if there is any substring from the end of the // line that matches the rest of the pattern !!! for (i = string.length(); i >= sNdx; i--) { if (match(string, pattern, i, pNdx)) { return true; } } return false; } } else { nextIsNotWildcard = false; } // check if pattern char and string char are equals if (p != string.charAt(sNdx)) { return false; } // everything matches for now, continue sNdx++; pNdx++; } } \nResponse:", "ground_truth": "Internal matching recursive function.", "predict": "\n\npublic static boolean match(final CharSequence string, final CharSequence pattern) {\n\treturn match(string, pattern, 0, 0);\n}\n\npublic static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\n\tint pLen = pattern.length();\n\tif (pLen == 1) {\n\t\tif (pattern.charAt(0) == '*') {\n\t\t\t// speed-up return true;\n\t\t}\n\t}\n\tint sLen = string.length();\n\tboolean nextIsNotWildcard = false;\n\twhile (true) {\n\t\t// check if end of string and/or pattern occurred\n\t\tif ((sNdx >= sLen)) {\n\t\t\t// end of string still may have pending '*' in pattern while ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) {\n\t\t\t// pN"}, {"ID": 1678, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Loading resolveLoading(final boolean parentFirstStrategy, final String className) { boolean withParent = true; boolean withLoader = true; if (parentFirstStrategy) { if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } else if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } } else { if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } else if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } } return new Loading(withParent, withLoader); } \nResponse:", "ground_truth": "Resolves loading rules.", "predict": "\n\n*/\n\npublic class Loading {\n    private boolean withParent;\n    private boolean withLoader;\n\n    public Loading(boolean withParent, boolean withLoader) {\n        this.withParent = withParent;\n        this.withLoader = withLoader;\n    }\n\n    public boolean isWithParent() {\n        return withParent;\n    }\n\n    public boolean isWithLoader() {\n        return withLoader;\n    }\n}\n"}, {"ID": 1679, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Loading resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) { if (matchResourcesAsPackages) { resourceName = StringUtil.replaceChar(resourceName, '/', '.'); } return resolveLoading(parentFirstStrategy, resourceName); } \nResponse:", "ground_truth": "Resolves resources.", "predict": " public Response resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) { if (matchResourcesAsPackages) { resourceName = StringUtil.replaceChar(resourceName, '/', '.'); } return resolveLoading(parentFirstStrategy, resourceName); } \n\n// Generated code\n\npublic Response resolveLoading(final boolean parentFirstStrategy, String resourceName) {\n\treturn null;\n}\n\n}\n"}, {"ID": 1680, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException { // check first if the class has already been loaded Class<?> c = findLoadedClass(className); if (c != null) { if (resolve) { resolveClass(c); } return c; } // class not loaded yet Loading loading = resolveLoading(parentFirst, className); if (parentFirst) { // PARENT FIRST if (loading.withParent) { try { c = parentClassLoader.loadClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withLoader) { c = this.findClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } else { // THIS FIRST if (loading.withLoader) { try { c = this.findClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withParent) { c = parentClassLoader.loadClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } if (resolve) { resolveClass(c); } return c; } \nResponse:", "ground_truth": "Loads class using parent-first or parent-last strategy.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] split = input.split(\" \");\n        String className = split[0];\n        String methodName = split[1];\n        String[] args = Arrays.copyOfRange(split,"}, {"ID": 1681, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public URL getResource(final String resourceName) { URL url = null; Loading loading = resolveResourceLoading(parentFirst, resourceName); if (parentFirst) { // PARENT FIRST if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } if (url == null) { if (loading.withLoader) { url = this.findResource(resourceName); } } } else { // THIS FIRST if (loading.withLoader) { url = this.findResource(resourceName); } if (url == null) { if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } } } return url; } \nResponse:", "ground_truth": "Returns a resource using parent-first or parent-last strategy.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.ResourceBundle;\n\npublic class ResourceBundleLoader {\n\n    private static final String PROPERTIES_FILE_NAME = \"resource.properties\";\n    private static final String PROPERTIES_FILE_NAME_WITH_PREFIX = \"resource_\";\n    private static final String PROPERTIES_FILE_NAME_WITH_SUFFIX = \".properties\";\n    private static final String PROPERTIES_FILE_NAME_WITH_PREFIX_AND_SUFFIX = \"resource_\";\n    private static final String PROPERTIES_FILE_NAME_WITH_PREFIX_AND_SUFFIX_WITH_EXTENSION = \".properties"}, {"ID": 1682, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void waitFor() { try { synchronized (lock) { if (!end) { lock.wait(); } } } catch (InterruptedException ignore) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Waits for gobbler to end.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.waitFor();\n    }\n\n    public void waitFor() {\n        try {\n            synchronized (lock) {\n                while (!end) {\n                    lock.wait();\n                }\n            }\n        } catch (InterruptedException ignore) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n"}, {"ID": 1683, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) { for (final Annotation annotation : annotations) { if (annotation instanceof In) { return annotation.annotationType(); } else if (annotation instanceof Out) { return annotation.annotationType(); } } return null; } \nResponse:", "ground_truth": "Scans annotation and returns type of Madvoc annotations.", "predict": " public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) { for (final Annotation annotation : annotations) { if (annotation instanceof In) { return annotation.annotationType(); } else if (annotation instanceof Out) { return annotation.annotationType(); } } return null; } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class AnnotationDetector {\n\n    public static void main(String[] args) {\n        List<Class<? extends Annotation>> annotationTypes = Arrays.asList(In.class, Out.class);\n        for (Class<? extends Annotation> annotationType : annotationTypes) {\n            System.out.println(\"Annotation type: \" + annotationType.getSimpleName());\n            System.out.println(\"Method: \" + annotationType.getSimple"}, {"ID": 1684, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected InjectionPoint buildInjectionPoint( final String annotationValue, final String propertyName, final Class propertyType, final Class<? extends MadvocScope> scope) { final String value = annotationValue.trim(); final String name, targetName; if (StringUtil.isNotBlank(value)) { name = value; targetName = propertyName; } else { name = propertyName; targetName = null; } return new InjectionPoint(propertyType, name, targetName, scopeResolver.defaultOrScopeType(scope)); } \nResponse:", "ground_truth": "Builds injection point.", "predict": " public Response buildResponse( final String contentType, final String content, final int statusCode) { return new Response(contentType, content, statusCode); } \nResp public Response buildResponse( final String contentType, final String content, final int statusCode, final Map<String, Object> headers) { return new Response(contentType, content, statusCode, headers); } \nResp public Response buildResponse( final String contentType, final String content, final int statusCode, final Map<String, Object> headers, final Map<String, Object> cookies) { return new Response(contentType, content, statusCode, headers, cookies); } \nResp public Response buildResponse( final String contentType, final String content, final int statusCode, final Map<String, Object> headers, final Map<String, Object> cookies, final Map<String, Object> params) { return new Response(contentType, content, statusCode, headers, cookies, params); } \nResp public Response"}, {"ID": 1685, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit() { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); if (classMetadataName != null) { // process first 'meta' fields 'class' onProperty(classMetadataName, null, false); } PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { String propertyName = propertyDescriptor.getName(); boolean isTransient = false; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); if (fieldDescriptor != null) { isTransient = Modifier.isTransient(fieldDescriptor.getField().getModifiers()); } onProperty(propertyName, propertyDescriptor, isTransient); } } } \nResponse:", "ground_truth": "Visits a type.", "predict": " Response = new Response(); if (classMetadataName != null) { // process first 'meta' fields 'class' onProperty(classMetadataName, null, false); } PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { String propertyName = propertyDescriptor.getName(); boolean isTransient = false; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); if (fieldDescriptor != null) { isTransient = Modifier.isTransient(fieldDescriptor.getField().getModifiers()); } onProperty(propertyName, propertyDescriptor, isTransient); } } \n}\n\npublic void onProperty(String propertyName, PropertyDescriptor property"}, {"ID": 1686, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { final URLClassLoader urlClassLoader = (URLClassLoader) classLoader; return urlClassLoader.getURLs(); } final URL url = classModuleUrl(classLoader, clazz); if (url != null) { urls.add(url); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); } \nResponse:", "ground_truth": "Returns urls for the classloader\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": " public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { final URLClassLoader urlClassLoader = (URLClassLoader) classLoader; return urlClassLoader.getURLs(); } final URL url = classModuleUrl(classLoader, clazz); if (url != null) { urls.add(url); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); } \n\n*/\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassPathURLs {\n    public static URL[] of(ClassLoader"}, {"ID": 1687, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setBean(final Object bean) { this.bean = bean; this.cd = (bean == null ? null : introspector.lookup(bean.getClass())); this.first = false; this.updateProperty = true; } \nResponse:", "ground_truth": "Sets new bean instance.", "predict": "\n\n*/\n\npublic class BeanPropertySetter {\n\t\n\tprivate static final String PROPERTY_SETTER_PREFIX = \"set\";\n\tprivate static final String PROPERTY_SETTER_SUFFIX = \"Property\";\n\tprivate static final String PROPERTY_SETTER_PREFIX_WITH_BEAN = \"setBean\";\n\tprivate static final String PROPERTY_SETTER_SUFFIX_WITH_BEAN = \"Property\";\n\t\n\tprivate static final String PROPERTY_SETTER_PREFIX_WITH_BEAN_AND_CD = \"setBean\";\n\tprivate static final String PROPERTY_SETTER_SUFFIX_WITH_BEAN_AND_CD = \"Property\";\n\t\n\tprivate static final String PROPERTY_SETTER_PREFIX_WITH_BEAN_AND_CD_AND_UPDATE_PROPERTY = \"setBean\";\n\t"}, {"ID": 1688, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void updateBean(final Object bean) { this.setBean(bean); if (this.cd != null && this.cd.isSupplier()) { final Object newBean = ((Supplier)this.bean).get(); setBean(newBean); } } \nResponse:", "ground_truth": "Updates the bean. Detects special case of suppliers.", "predict": " Response = Response.ok().build();\n\n*/\n\npublic class BeanProperty {\n\t\n\tprivate String name;\n\tprivate String type;\n\tprivate String description;\n\tprivate String methodName;\n\tprivate String methodDescription;\n\tprivate String methodReturnType;\n\tprivate String methodReturnDescription;\n\tprivate String methodReturnTypeName;\n\tprivate String methodReturnDescriptionName;\n\tprivate String methodReturnTypeNameDescription;\n\tprivate String methodReturnTypeNameDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeNameDescriptionDescriptionDescriptionDescriptionDescriptionDescriptionDescription;\n\tprivate String methodReturnTypeName"}, {"ID": 1689, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void loadPropertyDescriptor() { if (updateProperty) { if (cd == null) { propertyDescriptor = null; } else { propertyDescriptor = cd.getPropertyDescriptor(name, true); } updateProperty = false; } } \nResponse:", "ground_truth": "Loads property descriptor, if property was updated.", "predict": "\n\n*/\n\npublic class PropertyDescriptorTest {\n    public static void main(String[] args) {\n        PropertyDescriptorTest test = new PropertyDescriptorTest();\n        test.run();\n    }\n\n    public void run() {\n        PropertyDescriptorTest.class.getName();\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out.println(\"PropertyDescriptorTest.class.getName()\");\n        System.out."}, {"ID": 1690, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; } \nResponse:", "ground_truth": "Returns getter.", "predict": " public Getter getGetter() { return getGetter(true); } \nResp public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; } \nResp public Getter getGetter() { return getGetter(true); } \nResp public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; } \nResp public Getter getGetter() { return getGetter(true); } \nResp public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; } \nResp public Getter getGetter() { return getGetter(true); } \n"}, {"ID": 1691, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Setter getSetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getSetter(declared) : null; } \nResponse:", "ground_truth": "Returns setter.", "predict": " Response is generated by the following java Code. Code: public Response getResponse() { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getResponse() : null; } \n\n*/\n\npublic class SetterGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString className = \"SetterGenerator\";\n\t\t\n\t\tString packageName = \"com.github.javaparser.ast.body.constructor\";\n\t\t\n\t\tString className1 = \"SetterGenerator\";\n\t\t\n\t\tString packageName1 = \"com.github.javaparser.ast.body.constructor\";\n\t\t\n\t\tString className2 = \"SetterGenerator\";\n\t\t\n\t\tString packageName2 = \"com.github.javaparser.ast.body.constructor\";\n\t\t\n\t\tString className3 = \"SetterGenerator\";\n\t\t\n\t\tString packageName3 = \""}, {"ID": 1692, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbOom connect() { connectionProvider.init(); final DbDetector dbDetector = new DbDetector(); dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig); return this; } \nResponse:", "ground_truth": "Initializes the DbOom by connecting to the database. Database will be detected\nand DbOom will be configured to match it.", "predict": "\n\n*/\n\npackage com.github.shyykoserhiy.gfm.editor;\n\nimport com.github.shyykoserhiy.gfm.editor.actions.Action;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext.ActionContextBuilder;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext.ActionContextBuilderFactory;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext.ActionContextType;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext.ActionContextType;\nimport com.github.shyykoserhiy.gfm.editor.actions.ActionContext.ActionContextType.ActionContextTypeBuilder;\nimport com.github.sh"}, {"ID": 1693, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Iterator<T> iterator) { if (allIterators.contains(iterator)) { throw new IllegalArgumentException(\"Duplicate iterator\"); } allIterators.add(iterator); } \nResponse:", "ground_truth": "Adds an iterator to this composite.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1694, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void printLogo() { System.out.println(Chalk256.chalk().yellow().on(Jodd.JODD)); } \nResponse:", "ground_truth": "Prints a logo.", "predict": "\n\n<pre>\n<code>\npackage com.jodd.petite.tst;\n\nimport com.jodd.petite.meta.PetiteBean;\nimport com.jodd.petite.meta.PetiteInject;\n\n@PetiteBean\npublic class HelloWorld {\n\n\t@PetiteInject\n\tprivate Chalk256 chalk;\n\n\tpublic void printLogo() {\n\t\tSystem.out.println(chalk.yellow().on(Jodd.JODD));\n\t}\n}\n</code>\n</pre>\n\n*/\n\npackage com.jodd.petite.meta;"}, {"ID": 1695, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop() { joyProps.stop(); try { joyDb.stop(); joyPetite.stop(); } catch (Exception ignore) { } if (log != null) { log.info(\"Joy is down. Bye, bye!\"); } } \nResponse:", "ground_truth": "Stops the Joy.", "predict": "\n\n<pre>\npublic void stop() {\n    joyProps.stop();\n    try {\n        joyDb.stop();\n    } catch (Exception ignore) {\n    }\n    joyPetite.stop();\n    if (log != null) {\n        log.info(\"Joy is down. Bye, bye!\");\n    }\n}\n</pre>\n\n@author <a href=\"http://www.async.e.net/\">Igor A. Lastovka</a>\n@version $Id$\n@since 1.0\n*/\npublic class Stop extends AbstractJavaMethod {\n    \n    /**\n     * Constructor for Stop.\n     * @param context\n     * @param method\n     */\n    public Stop(Context context, Method method) {\n        super(context, method);\n    }\n\n    /**\n     * @see org.directwebremoting.extend.Method#execute(java.lang.Object[])"}, {"ID": 1696, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Socket createSocket(final String host, final int port, final int connectionTimeout) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, false, false, connectionTimeout); if (connectionTimeout < 0) { return socketFactory.createSocket(host, port); } else { // creates unconnected socket Socket socket = socketFactory.createSocket(); socket.connect(new InetSocketAddress(host, port), connectionTimeout); return socket; } } \nResponse:", "ground_truth": "Creates a socket using socket factory.", "predict": " Generate the method-level comment for the following java Code. Code: protected HttpEntity execute(final HttpUriRequest request) throws IOException { final HttpResponse response = execute(request, (HttpContext) null); return response.getEntity(); } \nResp Generate the method-level comment for the following java Code. Code: protected HttpEntity execute(final HttpUriRequest request, final HttpContext context) throws IOException { final HttpResponse response = execute(request, context, null); return response.getEntity(); } \nResp Generate the method-level comment for the following java Code. Code: protected HttpEntity execute(final HttpUriRequest request, final HttpContext context, final ProgressListener listener) throws IOException { final HttpResponse response = execute(request, context, listener); return response.getEntity(); } \nResp Generate the method-level comment for the following java Code. Code: protected HttpEntity execute(final H"}, {"ID": 1697, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SSLSocket createSSLSocket( final String host, final int port, final int connectionTimeout, final boolean trustAll, final boolean verifyHttpsHost) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll, connectionTimeout); final Socket socket; if (connectionTimeout < 0) { socket = socketFactory.createSocket(host, port); } else { // creates unconnected socket // unfortunately, this does not work always // sslSocket = (SSLSocket) socketFactory.createSocket(); // sslSocket.connect(new InetSocketAddress(host, port), connectionTimeout); // // Note: SSLSocketFactory has several create() methods. // Those that take arguments all connect immediately // and have no options for specifying a connection timeout. // // So, we have to create a socket and connect it (with a // connection timeout), then have the SSLSocketFactory wrap // the already-connected socket. // socket = Sockets.connect(host, port, connectionTimeout); //sock.setSoTimeout(readTimeout); //socket.connect(new InetSocketAddress(host, port), connectionTimeout); // continue to wrap this plain socket with ssl socket... } // wrap plain socket in an SSL socket SSLSocket sslSocket; if (socket instanceof SSLSocket) { sslSocket = (SSLSocket) socket; } else { if (socketFactory instanceof SSLSocketFactory) { sslSocket = (SSLSocket) ((SSLSocketFactory)socketFactory).createSocket(socket, host, port, true); } else { sslSocket = (SSLSocket) (getDefaultSSLSocketFactory(trustAll)).createSocket(socket, host, port, true); } } // sslSocket is now ready if (secureEnabledProtocols != null) { final String[] values = StringUtil.splitc(secureEnabledProtocols, ','); StringUtil.trimAll(values); sslSocket.setEnabledProtocols(values); } // set SSL parameters to allow host name verifier if (verifyHttpsHost) { final SSLParameters sslParams = new SSLParameters(); sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\"); sslSocket.setSSLParameters(sslParams); } return sslSocket; } \nResponse:", "ground_truth": "Creates a SSL socket. Enables default secure enabled protocols if specified.", "predict": "\n\n*/\n"}, {"ID": 1698, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SSLSocketFactory getDefaultSSLSocketFactory(final boolean trustAllCertificates) throws IOException { if (trustAllCertificates) { try { SSLContext sc = SSLContext.getInstance(sslProtocol); sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom()); return sc.getSocketFactory(); } catch (NoSuchAlgorithmException | KeyManagementException e) { throw new IOException(e); } } else { return (SSLSocketFactory) SSLSocketFactory.getDefault(); } } \nResponse:", "ground_truth": "Returns default SSL socket factory allowing setting trust managers.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class SSLSocketFactoryFactory {\n\t\n\tprivate static final String[] sslProtocols = new String[] { \"TLSv1.2\","}, {"ID": 1699, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SocketFactory getSocketFactory( final ProxyInfo proxy, final boolean ssl, final boolean trustAllCertificates, final int connectionTimeout) throws IOException { switch (proxy.getProxyType()) { case NONE: if (ssl) { return getDefaultSSLSocketFactory(trustAllCertificates); } else { return SocketFactory.getDefault(); } case HTTP: return new HTTPProxySocketFactory(proxy, connectionTimeout); case SOCKS4: return new Socks4ProxySocketFactory(proxy, connectionTimeout); case SOCKS5: return new Socks5ProxySocketFactory(proxy, connectionTimeout); default: return null; } } \nResponse:", "ground_truth": "Returns socket factory based on proxy type and SSL requirements.", "predict": " Generate the method-level comment for the following java Code. Code: public static String getResponseMessage(final int statusCode) { switch (statusCode) { case 200: return \"OK\"; case 404: return \"Not Found\"; case 503: return \"Service Unavailable\"; default: return \"Unknown\"; } } \nResp Generate the method-level comment for the following java Code. Code: public static String getResponseMessage(final int statusCode, final String reasonPhrase) { switch (statusCode) { case 200: return \"OK\"; case 404: return \"Not Found\"; case 503: return \"Service Unavailable\"; default: return reasonPhrase; } } \nResp Generate the method-level comment for the following java Code. Code: public static String getResponseMessage(final int statusCode, final Throwable t) { switch (statusCode) { case 200: return \"OK\"; case 404: return \"Not Found\"; case 503: return \"Service Unavailable\"; default: return t.get"}, {"ID": 1700, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String random(int count, final char[] chars) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; while (count-- > 0) { result[count] = chars[rnd.nextInt(chars.length)]; } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the set of characters specified.", "predict": "\n\n*/\n\npublic class Solution {\n    public String randomString(int length) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            sb.append(rnd.nextInt(26));\n        }\n        return sb.toString();\n    }\n}\n"}, {"ID": 1701, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String random(int count, final char start, final char end) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; final int len = end - start + 1; while (count-- > 0) { result[count] = (char) (rnd.nextInt(len) + start); } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the provided range.", "predict": "\n\npublic String random(int count, final char start, final char end) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; final int len = end - start + 1; while (count-- > 0) { result[count] = (char) (rnd.nextInt(len) + start); } return new String(result); }\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        int count = rnd.nextInt(100) + 1;\n        char start = (char) (rnd.nextInt(26) + 'a');\n        char end = (char) (rnd.nextInt(26) + 'a');\n        System.out.println(String.format(\"public String random(int count, final char start, final"}, {"ID": 1702, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String randomRanges(int count, final char... ranges) { if (count == 0) { return StringPool.EMPTY; } int i = 0; int len = 0; final int[] lens = new int[ranges.length]; while (i < ranges.length) { int gap = ranges[i + 1] - ranges[i] + 1; len += gap; lens[i] = len; i += 2; } final char[] result = new char[count]; while (count-- > 0) { char c = 0; int r = rnd.nextInt(len); for (i = 0; i < ranges.length; i += 2) { if (r < lens[i]) { r += ranges[i]; if (i != 0) { r -= lens[i - 2]; } c = (char) r; break; } } result[count] = c; } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the multiple sets defined by range pairs.\nAll ranges must be in acceding order.", "predict": "\n\npublic String randomRanges(int count, final char... ranges) { if (count == 0) { return StringPool.EMPTY; } int i = 0; int len = 0; final int[] lens = new int[ranges.length]; while (i < ranges.length) { int gap = ranges[i + 1] - ranges[i] + 1; len += gap; lens[i] = len; i += 2; } final char[] result = new char[count]; while (count-- > 0) { char c = 0; int r = rnd.nextInt(len); for (i = 0; i < ranges.length; i += 2) { if (r < lens[i]) { r += ranges[i]; if (i != 0) { r -= lens[i - 2]; } c = (char) r; break; } } result[count] = c; } return new String(result); } \n\n*/\n\nimport java.util."}, {"ID": 1703, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Collection<Object> newArrayInstance(final Class targetType) { if (targetType == null || targetType == List.class || targetType == Collection.class || targetType.isArray()) { return listSupplier.get(); } if (targetType == Set.class) { return new HashSet<>(); } try { return (Collection<Object>) targetType.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new JsonException(e); } } \nResponse:", "ground_truth": "Creates new type for JSON array objects.\nIt returns a collection.\nLater, the collection will be converted into the target type.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\npublic class SuppressWarnings {\n\n    public static void main(String[] args) {\n        List<Object> list = new ArrayList<>();\n        Set<Object> set = new HashSet<>();\n        Supplier<List<Object>> listSupplier = () -> list;\n        Supplier<Set<Object>> setSupplier = () -> set;\n    }\n}\n"}, {"ID": 1704, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) { Object convertedValue = value; if (value != null) { Class targetClass = pd.getType(); convertedValue = convertType(value, targetClass); } try { Setter setter = pd.getSetter(true); if (setter != null) { setter.invokeSetter(target, convertedValue); } } catch (Exception ex) { throw new JsonException(ex); } } \nResponse:", "ground_truth": "Injects value into the targets property.", "predict": "\n\n*/\n\npublic class JsonPropertyInjector extends AbstractJsonPropertyInjector {\n\n    public JsonPropertyInjector(final String propertyName, final String propertyType, final String propertyValue) {\n        super(propertyName, propertyType, propertyValue);\n    }\n\n    @Override\n    public void injectIntoObject(final Object target, final PropertyDescriptor pd) {\n        try {\n            final Method setter = pd.getSetter(true);\n            if (setter != null) {\n                final Object convertedValue = convertType(propertyValue, pd.getType());\n                setter.invoke(target, convertedValue);\n            }\n        } catch (Exception ex) {\n            throw new JsonException(ex);\n        }\n    }\n}\n"}, {"ID": 1705, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object convertType(final Object value, final Class targetType) { final Class valueClass = value.getClass(); if (valueClass == targetType) { return value; } try { return TypeConverterManager.get().convertType(value, targetType); } catch (Exception ex) { if (!strictTypes) { return null; } throw new JsonException(\"Type conversion failed\", ex); } } \nResponse:", "ground_truth": "Converts type of the given value.", "predict": " Response<T>\n\n*/\n\npublic class TypeConverterManager {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TypeConverterManager.class);\n\n    private static final Map<Class, TypeConverter> TYPE_CONVERTERS = new HashMap<>();\n\n    static {\n        register(new StringToStringTypeConverter());\n        register(new StringToBooleanTypeConverter());\n        register(new StringToIntegerTypeConverter());\n        register(new StringToLongTypeConverter());\n        register(new StringToFloatTypeConverter());\n        register(new StringToDoubleTypeConverter());\n        register(new StringToBigDecimalTypeConverter());\n        register(new StringToBigIntegerTypeConverter());\n        register(new StringToDateTypeConverter());\n        register(new StringToCalendarTypeConverter());\n        register(new StringToByte"}, {"ID": 1706, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitProvide(final String service, final String... providers) { if (mv != null) { mv.visitProvide(service, providers); } } \nResponse:", "ground_truth": "Visit an implementation of a service.\n\n@param service the internal name of the service.\n@param providers the internal names of the implementations of the service (there is at least\none provider).", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1707, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); } \nResponse:", "ground_truth": "Creates default implementation of the type cache.", "predict": " Response.ok(Defaults.implementation.get());\n\n@SuppressWarnings(\"unchecked\")\npublic static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); } \nResp Response.ok(Defaults.implementation.get());\n\n@SuppressWarnings(\"unchecked\")\npublic static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); } \nResp Response.ok(Defaults.implementation.get());\n\n@SuppressWarnings(\"unchecked\")\npublic static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); } \nResp Response.ok(Defaults.implementation.get());\n\n@SuppressWarnings(\"unchecked\")\npublic static <A> TypeCache<A> createDefault() {"}, {"ID": 1708, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T put(final Class<?> type, final T value) { return map.put(type, value); } \nResponse:", "ground_truth": "Add values to the map.", "predict": " Resp public T put(final Class<?> type, final T value) { return map.put(type, value); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n    \n    public void test() {\n        Map<Class<?>, Object> map = new HashMap<Class<?>, Object>();\n        map.put(String.class, \"Hello\");\n        map.put(Integer.class, 1);\n        map.put(Long.class, 2L);\n        map.put(Float.class, 3.0f);\n        map.put(Double.class, 4.0);\n        map.put(Boolean.class, true);\n        map.put(Character.class, 'a');\n        map.put(Byte.class, (byte)1);\n        map.put(Short.class, (short"}, {"ID": 1709, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MethodDescriptor[] getAllMethodDescriptors() { if (allMethods == null) { final List<MethodDescriptor> allMethodsList = new ArrayList<>(); for (MethodDescriptor[] methodDescriptors : methodsMap.values()) { Collections.addAll(allMethodsList, methodDescriptors); } final MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]); Arrays.sort(allMethods, Comparator.comparing(md -> md.getMethod().getName())); this.allMethods = allMethods; } return allMethods; } \nResponse:", "ground_truth": "Returns all methods. Cached. Lazy.", "predict": " public MethodDescriptor[] getAllMethodDescriptors() { return allMethods; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class MethodDescriptor {\n    private String methodName;\n    private String methodDescriptor;\n    private String methodSignature;\n    private String methodReturnType;\n    private String methodReturnTypeDescriptor;\n    private String methodReturnTypeSignature;\n    private String methodReturnTypeSignatureDescriptor;\n    private String methodReturnTypeSignatureDescriptor2;\n    private String methodReturnTypeSignatureDescriptor3;\n    private String methodReturnTypeSignatureDescriptor4;\n    private String methodReturnTypeSignatureDescriptor5;\n    private String methodReturnTypeSignatureDescriptor6;\n    private String methodReturnTypeSignatureDescriptor7;"}, {"ID": 1710, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveIpAddress(final String hostname) { try { InetAddress netAddress; if (hostname == null || hostname.equalsIgnoreCase(LOCAL_HOST)) { netAddress = InetAddress.getLocalHost(); } else { netAddress = Inet4Address.getByName(hostname); } return netAddress.getHostAddress(); } catch (UnknownHostException ignore) { return null; } } \nResponse:", "ground_truth": "Resolves IP address from a hostname.", "predict": "\n\n*/\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class IpAddress {\n    public static String resolveIpAddress(String hostname) {\n        try {\n            InetAddress netAddress;\n            if (hostname == null || hostname.equalsIgnoreCase(\"LOCAL_HOST\")) {\n                netAddress = InetAddress.getLocalHost();\n            } else {\n                netAddress = Inet4Address.getByName(hostname);\n            }\n            return netAddress.getHostAddress();\n        } catch (UnknownHostException ignore) {\n            return null;\n        }\n    }\n}\n"}, {"ID": 1711, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int getIpAsInt(final String ipAddress) { int ipIntValue = 0; String[] tokens = StringUtil.splitc(ipAddress, '.'); for (String token : tokens) { if (ipIntValue > 0) { ipIntValue <<= 8; } ipIntValue += Integer.parseInt(token); } return ipIntValue; } \nResponse:", "ground_truth": "Returns IP address as integer.", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] ip = new int[4];\n        for (int i = 0; i < n; i++) {\n            ip[i] = in.nextInt();\n        }\n        int ipIntValue = 0;\n        for (int i = 0; i < n; i++) {\n            ipIntValue <<= 8;\n            ipIntValue += ip[i];\n        }\n        System.out.println(ipIntValue);\n    }\n}\n"}, {"ID": 1712, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validateAgaintIPAdressV4Format(final String input) { if (input == null) { return false; } int hitDots = 0; char[] data = input.toCharArray(); for (int i = 0; i < data.length; i++) { char c = data[i]; int b = 0; do { if (c < '0' || c > '9') { return false; } b = (b * 10 + c) - 48; if (++i >= data.length) { break; } c = data[i]; } while (c != '.'); if (b > 255) { return false; } hitDots++; } return hitDots == 4; } \nResponse:", "ground_truth": "Checks given string against IP address v4 format.\n\n@param input an ip address - may be null\n@return true if param has a valid ip v4 format false otherwise\n@see ip address v4", "predict": "\n\npublic static boolean validateAgaintIPAdressV4Format(final String input) {\n    if (input == null) {\n        return false;\n    }\n    int hitDots = 0;\n    char[] data = input.toCharArray();\n    for (int i = 0; i < data.length; i++) {\n        char c = data[i];\n        int b = 0;\n        do {\n            if (c < '0' || c > '9') {\n                return false;\n            }\n            b = (b * 10 + c) - 48;\n            if (++i >= data.length) {\n                break;\n            }\n            c = data[i];\n        } while (c != '.');\n        if (b > 255) {\n            return false;\n        }\n        hitDots++;\n    }\n    return hitDots == 4;\n}\n\n*/\n"}, {"ID": 1713, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveHostName(final byte[] ip) { try { InetAddress address = InetAddress.getByAddress(ip); return address.getHostName(); } catch (UnknownHostException ignore) { return null; } } \nResponse:", "ground_truth": "Resolves host name from IP address bytes.", "predict": "\n\npublic static String resolveHostName(final byte[] ip) {\ntry {\n    InetAddress address = InetAddress.getByAddress(ip);\n    return address.getHostName();\n} catch (UnknownHostException ignore) {\n    return null;\n}\n}\n\n*/\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class HostName {\n    public static void main(String[] args) {\n        byte[] ip = {(byte) 192, (byte) 168, (byte) 1, (byte) 1};\n        try {\n            InetAddress address = InetAddress.getByAddress(ip);\n            System.out.println(address.getHostName());\n        } catch (UnknownHostException ignore) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n}\n"}, {"ID": 1714, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] downloadBytes(final String url) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return StreamUtil.readBytes(inputStream); } } \nResponse:", "ground_truth": "Downloads resource as byte array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1715, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String downloadString(final String url, final String encoding) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return new String(StreamUtil.readChars(inputStream, encoding)); } } \nResponse:", "ground_truth": "Downloads resource as String.", "predict": " Response<String> downloadString(final String url, final String encoding) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return Response.success(new String(StreamUtil.readChars(inputStream, encoding))); } } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://www.baidu.com\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        connection.setRequestProperty(\"Accept\", \""}, {"ID": 1716, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void downloadFile(final String url, final File file) throws IOException { try ( InputStream inputStream = new URL(url).openStream(); ReadableByteChannel rbc = Channels.newChannel(inputStream); FileChannel fileChannel = FileChannel.open( file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE) ) { fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE); } } \nResponse:", "ground_truth": "Downloads resource to a file, potentially very efficiently.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scanner = new Scanner(System.in);\n        String url = scanner.nextLine();\n        String fileName = scanner.nextLine();\n        String filePath = scanner.nextLine();\n        String fileExtension = scanner.nextLine();\n        String fileNameWithoutExtension = scanner.nextLine();\n        String filePathWithoutExtension = scanner.nextLine();\n        String fileNameWithoutExtensionWithoutExtension = scanner.nextLine();\n        String"}, {"ID": 1717, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void inject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(actionRequest, targets)); } \nResponse:", "ground_truth": "Performs injection.", "predict": " Generate the method-level comment for the following java Code. Code: protected void render(final ActionRequest actionRequest, final ActionResponse actionResponse) throws Exception { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.render(servletContext, targets, actionResponse)); scopeResolver.forEachScope(madvocScope -> madvocScope.render(actionRequest, targets, actionResponse)); } \nResp Generate the method-level comment for the following java Code. Code: protected void render(final ActionRequest actionRequest, final ActionResponse actionResponse) throws Exception { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.render(servlet"}, {"ID": 1718, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void outject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets)); } \nResponse:", "ground_truth": "Performs outjection.", "predict": " public void outject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets)); } \n\n*/\npackage madvoc.scope;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Marks a method as scope-aware.\n * <p>\n * The method must be declared in a class annotated with {@link MadvocController}\n * and it must be public.\n * <p>\n * The method must return {@link ActionRequest} or {@link ActionResponse}\n * and it must have no parameters.\n * <p>\n * The method must be declared in a class"}, {"ID": 1719, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Socket connect(final String hostname, final int port) throws IOException { final Socket socket = new Socket(); socket.connect(new InetSocketAddress(hostname, port)); return socket; } \nResponse:", "ground_truth": "Creates a socket.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1720, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException { final Socket socket = new Socket(); if (connectionTimeout <= 0) { socket.connect(new InetSocketAddress(hostname, port)); } else { socket.connect(new InetSocketAddress(hostname, port), connectionTimeout); } return socket; } \nResponse:", "ground_truth": "Creates a socket with a timeout.", "predict": " public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException { final Socket socket = new Socket(); if (connectionTimeout <= 0) { socket.connect(new InetSocketAddress(hostname, port)); } else { socket.connect(new InetSocketAddress(hostname, port), connectionTimeout); } return socket; } \n\n*/\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class SocketClient {\n    public static void main(String[] args) throws UnknownHostException, IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        System.out.println(\"Socket connected\");\n        socket.close();\n    }\n}\n"}, {"ID": 1721, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getPrimitiveClassNameIndex(final String className) { int dotIndex = className.indexOf('.'); if (dotIndex != -1) { return -1; } return Arrays.binarySearch(PRIMITIVE_TYPE_NAMES, className); } \nResponse:", "ground_truth": "Detects if provided class name is a primitive type.\nReturns >= 0 number if so.", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getPrimitiveClassNameIndex(\"java.lang.String\"));\n    }\n}\n"}, {"ID": 1722, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Class loadClass(final String className, final ClassLoader classLoader) throws ClassNotFoundException { String arrayClassName = prepareArrayClassnameForLoading(className); if ((className.indexOf('.') == -1) && (arrayClassName == null)) { // maybe a primitive int primitiveNdx = getPrimitiveClassNameIndex(className); if (primitiveNdx >= 0) { return PRIMITIVE_TYPES[primitiveNdx]; } } // try #1 - using provided class loader if (classLoader != null) { Class klass = loadClass(className, arrayClassName, classLoader); if (klass != null) { return klass; } } // try #2 - using thread class loader ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader(); if ((currentThreadClassLoader != null) && (currentThreadClassLoader != classLoader)) { Class klass = loadClass(className, arrayClassName, currentThreadClassLoader); if (klass != null) { return klass; } } // try #3 - using caller classloader, similar as Class.forName() //Class callerClass = ReflectUtil.getCallerClass(2); Class callerClass = ClassUtil.getCallerClass(); ClassLoader callerClassLoader = callerClass.getClassLoader(); if ((callerClassLoader != classLoader) && (callerClassLoader != currentThreadClassLoader)) { Class klass = loadClass(className, arrayClassName, callerClassLoader); if (klass != null) { return klass; } } // try #4 - everything failed, try alternative array loader if (arrayClassName != null) { try { return loadArrayClassByComponentType(className, classLoader); } catch (ClassNotFoundException ignore) { } } throw new ClassNotFoundException(\"Class not found: \" + className); } \nResponse:", "ground_truth": "Loads class by name.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ClassUtil {\n\n    private static final Map<String, Class> primitiveClasses = new HashMap<String, Class>();\n\n    static {\n        primitiveClasses.put(\"boolean\", boolean.class);\n        primitiveClasses.put(\"byte\", byte.class);\n        primitiveClasses.put(\"char\", char.class);\n        primitiveClasses.put(\"double\", double.class);\n        primitiveClasses.put(\"float\", float.class);\n        primitiveClasses.put(\"int\", int.class);\n        primitiveClasses.put(\"long\", long.class);\n        primitiveClasses.put(\"short\", short.class);\n        primitiveClasses.put"}, {"ID": 1723, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class loadArrayClassByComponentType(final String className, final ClassLoader classLoader) throws ClassNotFoundException { int ndx = className.indexOf('['); int multi = StringUtil.count(className, '['); String componentTypeName = className.substring(0, ndx); Class componentType = loadClass(componentTypeName, classLoader); if (multi == 1) { return Array.newInstance(componentType, 0).getClass(); } int[] multiSizes; if (multi == 2) { multiSizes = new int[] {0, 0}; } else if (multi == 3) { multiSizes = new int[] {0, 0, 0}; } else { multiSizes = (int[]) Array.newInstance(int.class, multi); } return Array.newInstance(componentType, multiSizes).getClass(); } \nResponse:", "ground_truth": "Loads array class using component type.", "predict": "\n\n*/\n\npublic class ArrayClassByComponentType {\n    public static void main(String[] args) {\n        try {\n            ClassLoader classLoader = ArrayClassByComponentType.class.getClassLoader();\n            Class componentType = classLoader.loadClass(\"java.lang.String\");\n            Class arrayClass = classLoader.loadArrayClassByComponentType(\"java.lang.String\", classLoader);\n            System.out.println(arrayClass);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}, {"ID": 1724, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); } \nResponse:", "ground_truth": "Iterate all beans and invokes registered destroy methods.", "predict": " @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); } \n */\n\npublic class Shutdown {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Add code to shutdown the bean data instances.\n\t\t\n\t}\n\n}\n"}, {"ID": 1725, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Comparable> BinarySearch<T> forArray(final T[] array) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return array[index].compareTo(element); } @Override protected int getLastIndex() { return array.length - 1; } }; } \nResponse:", "ground_truth": "Creates binary search wrapper over an array.", "predict": "\n\n*/\n\npublic class BinarySearch {\n    public static <T extends Comparable> BinarySearch<T> forArray(final T[] array) {\n        return new BinarySearch<T>() {\n            @Override\n            protected int compare(final int index, final T element) {\n                return array[index].compareTo(element);\n            }\n\n            @Override\n            protected int getLastIndex() {\n                return array.length - 1;\n            }\n        };\n    }\n}\n"}, {"ID": 1726, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return comparator.compare(array[index], element); } @Override protected int getLastIndex() { return array.length - 1; } }; } \nResponse:", "ground_truth": "Creates binary search wrapper over an array with given comparator.", "predict": "\n\npublic static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) { return new BinarySearch<T>() { @Override protected int compare(final int index, final T element) { return comparator.compare(array[index], element); } @Override protected int getLastIndex() { return array.length - 1; } }; } \n\n*/\n\npublic class BinarySearch {\n    public static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) {\n        return new BinarySearch<T>() {\n            @Override\n            protected int compare(final int index, final T element) {\n                return comparator.compare(array[index], element);\n            }\n\n            @Override\n            protected int getLastIndex() {\n                return array.length - 1;\n            }\n        };\n    }\n}\n"}, {"ID": 1727, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T exclude(final String... excludes) { for (String ex : excludes) { rules.exclude(ex); } return _this(); } \nResponse:", "ground_truth": "Defines excluded property names.", "predict": " Response<T> exclude(final String... excludes) { return _this().exclude(excludes); } \n*/\n\npublic class ExcludeRule extends Rule {\n\t\n\tpublic ExcludeRule(String name, String description) {\n\t\tsuper(name, description);\n\t}\n\t\n\tpublic Response<T> exclude(final String... excludes) {\n\t\treturn _this().exclude(excludes);\n\t}\n\t\n\tpublic Response<T> exclude(final List<String> excludes) {\n\t\treturn _this().exclude(excludes);\n\t}\n\t\n\tpublic Response<T> exclude(final String exclude) {\n\t\treturn _this().exclude(exclude);\n\t}\n\t\n\tpublic Response<T> exclude(final List<String> excludes, final List<String> includes) {\n\t\treturn _this().exclude(excludes, includes);\n\t}\n\t\n\tpublic Response<T> exclude(final String"}, {"ID": 1728, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T include(final String... includes) { for (String in : includes) { rules.include(in); } return _this(); } \nResponse:", "ground_truth": "Defines included property names.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1729, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T includeAs(final Class template) { blacklist = false; String[] properties = getAllBeanPropertyNames(template, false); include(properties); return _this(); } \nResponse:", "ground_truth": "Defines included property names as public properties\nof given template class. Sets to black list mode.", "predict": " public T includeAs(final Class template) { blacklist = false; String[] properties = getAllBeanPropertyNames(template, false); include(properties); return _this(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonView;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.annotation.JsonView;\nimport com.fasterxml.jackson.databind.ser.std.ToStringSerial"}, {"ID": 1730, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final int startIndex) { this.tagStartIndex = startIndex; this.name = null; this.idNdx = -1; this.attributesCount = 0; this.tagLength = 0; this.modified = false; this.type = TagType.START; this.rawTag = false; } \nResponse:", "ground_truth": "Starts the tag with the index of first '<'.\nResets all tag data.", "predict": "\npublic void start(final int startIndex) { this.tagStartIndex = startIndex; this.name = null; this.idNdx = -1; this.attributesCount = 0; this.tagLength = 0; this.modified = false; this.type = TagType.START; this.rawTag = false; } \n\n*/\n\npublic class Tag {\n\tpublic static final int TAG_TYPE_START = 0;\n\tpublic static final int TAG_TYPE_END = 1;\n\tpublic static final int TAG_TYPE_META = 2;\n\tpublic static final int TAG_TYPE_RAW = 3;\n\tpublic static final int TAG_TYPE_RESPONSE = 4;\n\tpublic static final int TAG_TYPE_RESPONSE_META = 5;\n\tpublic static final int TAG_TYPE_RESPONSE_RAW = 6;\n\tpublic static final int TAG_TYPE_RESPONSE_RAW_M"}, {"ID": 1731, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> void registerComponent(final String name, final Class<T> component, final Consumer<T> consumer) { log.debug(() -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component.getName()); madpc.removeBean(name); madpc.registerPetiteBean(component, name, null, null, false, consumer); } \nResponse:", "ground_truth": "Registers Madvoc component with given name.", "predict": "\n\n*/\n\nimport org.springframework.web.context.request.WebRequest;\nimport org.springframework.web.context.request.WebRequestInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Map;\n\n/**\n * @author Ivar Conradi \u00d8sthus\n */\npublic class MadvocWebRequestInterceptor implements WebRequestInterceptor {\n\n    private MadvocController madvocController;\n\n    public MadvocWebRequestInterceptor(MadvocController madvocController) {\n        this.madvocController = madvocController;\n    }\n\n    public void afterCompletion(WebRequest webRequest, Exception e) throws Exception {\n    }\n\n    public void postHandle(WebRequest webRequest, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n        if (web"}, {"ID": 1732, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void resolveColumnDbSqlType(final Connection connection, final DbEntityColumnDescriptor dec) { if (dec.dbSqlType != SqlType.DB_SQLTYPE_UNKNOWN) { return; } ResultSet rs = null; DbEntityDescriptor ded = dec.getDbEntityDescriptor(); try { DatabaseMetaData dmd = connection.getMetaData(); rs = dmd.getColumns(null, ded.getSchemaName(), ded.getTableName(), dec.getColumnName()); if (rs.next()) { dec.dbSqlType = rs.getInt(\"DATA_TYPE\"); } else { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not available: \" + ded.toString() + '.' + dec.getColumnName()); } } } catch (SQLException sex) { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not resolved: \" + ded.toString() + '.' + dec.getColumnName(), sex); } } finally { DbUtil.close(rs); } } \nResponse:", "ground_truth": "Resolves column db sql type and populates it in column descriptor if missing.", "predict": "\n\n*/\n\npackage com.diamondq.common.model.generic;\n\nimport com.diamondq.common.model.generic.PersistenceLayer;\nimport com.diamondq.common.model.generic.PersistenceLayerFactory;\nimport com.diamondq.common.model.generic.PersistenceLayerFactoryContext;\nimport com.diamondq.common.model.generic.PersistenceLayerFactoryContext.PersistenceLayerFactoryContextBuilder;\nimport com.diamondq.common.model.generic.PersistenceLayerFactoryContext.PersistenceLayerFactoryContextBuilder;\nimport com.diamondq.common.model.generic.PersistenceLayerFactoryContext.PersistenceLayerFactoryContextBuilder.PersistenceLayerFactoryContextBuilderFactory;\nimport com.diamondq.common.model.generic.PersistenceLayerFactoryContext.PersistenceLayerFactoryContextBuilder.PersistenceLayerFactoryContextBuilderFactory.PersistenceLayerFactoryContextBuilderFactoryBuilder;\nimport com.diamondq"}, {"ID": 1733, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String preprocessSql(String sqlString) { // detects callable statement if (sqlString.charAt(0) == '{') { return sqlString; } // quickly detect if SQL string is a key if (!CharUtil.isAlpha(sqlString.charAt(0))) { sqlString = sqlString.substring(1); } else if (sqlString.indexOf(' ') != -1) { return sqlString; } final String sqlFromMap = dbOom.queryMap().getQuery(sqlString); if (sqlFromMap != null) { sqlString = sqlFromMap.trim(); } return sqlString; } \nResponse:", "ground_truth": "Pre-process SQL before using it. If string starts with a non-ascii char\nor it has no spaces, it will be loaded from the query map.", "predict": "\n\n*/\n\npackage com.app.wms.engine.db.dao.spring;\n\nimport com.app.wms.engine.db.dao.FishDao;\nimport com.app.wms.engine.db.dto.Fish;\nimport java.util.List;\nimport javax.sql.DataSource;\nimport java.util.Map;\nimport org.springframework.jdbc.core.simple.SimpleJdbcTemplate;\nimport org.springframework.jdbc.core.simple.ParameterizedRowMapper;\nimport org.springframework.transaction.annotation.Transactional;\n\npublic class FishDaoImpl extends AbstractDAO implements ParameterizedRowMapper<Fish>, FishDao {\n\n    protected SimpleJdbcTemplate jdbcTemplate;\n\n    protected DataSource dataSource;\n\n    public void setDataSource(DataSource dataSource) {\n        this.dataSource = data"}, {"ID": 1734, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ResultSetMapper createResultSetMapper(final ResultSet resultSet) { final Map<String, ColumnData> columnAliases = sqlgen != null ? sqlgen.getColumnData() : null; return new DefaultResultSetMapper(dbOom, resultSet, columnAliases, cacheEntities, this); } \nResponse:", "ground_truth": "Factory for result sets mapper.", "predict": " Response is generated by the method createResultSetMapper(final ResultSet resultSet) \n*/\n\npublic class DefaultResultSetMapper implements ResultSetMapper {\n\t\n\tprotected final DbOomManager dbOom;\n\tprotected final ResultSet resultSet;\n\tprotected final Map<String, ColumnData> columnAliases;\n\tprotected final boolean cacheEntities;\n\tprotected final ResultSetMapperFactory factory;\n\t\n\tpublic DefaultResultSetMapper(final DbOomManager dbOom, final ResultSet resultSet, final Map<String, ColumnData> columnAliases, final boolean cacheEntities, final ResultSetMapperFactory factory) {\n\t\tthis.dbOom = dbOom;\n\t\tthis.resultSet = resultSet;\n\t\tthis.columnAliases = columnAliases;\n\t\tthis.cacheEntities = cacheEntities;\n\t\tthis.factory = factory;\n\t}\n\n\t@Override\n\tpublic Object map"}, {"ID": 1735, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T findGeneratedKey(final Class<T> type) { return find(new Class[] {type}, false, getGeneratedColumns()); } \nResponse:", "ground_truth": "Finds generated key column of given type.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1736, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void populateGeneratedKeys(final Object entity) { final String[] generatedColumns = getGeneratedColumnNames(); if (generatedColumns == null) { return; } DbEntityDescriptor ded = dbOom.entityManager().lookupType(entity.getClass()); // prepare key types Class[] keyTypes = new Class[generatedColumns.length]; String[] properties = new String[generatedColumns.length]; for (int i = 0; i < generatedColumns.length; i++) { String column = generatedColumns[i]; DbEntityColumnDescriptor decd = ded.findByColumnName(column); if (decd != null) { keyTypes[i] = decd.getPropertyType(); properties[i] = decd.getPropertyName(); } } final Object keyValues = findGeneratedColumns(keyTypes); if (!keyValues.getClass().isArray()) { BeanUtil.declared.setProperty(entity, properties[0], keyValues); } else { for (int i = 0; i < properties.length; i++) { BeanUtil.declared.setProperty(entity, properties[i], ((Object[]) keyValues)[i]); } } } \nResponse:", "ground_truth": "Populates entity with generated column values from executed query.", "predict": "\n\n*/\n\npackage com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex;\n\nimport java.util.Locale;\n\nimport com.github.dannil.scbjavaclient.client.AbstractContainerClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.economicindicators.BusinessActivitiesIndustrialComplexEconomicIndicatorsClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.industrialcomplex.BusinessActivitiesIndustrialComplexIndustrialComplexClient;\nimport com.github.dannil.scbjavaclient.client.businessactivities.industrialcomplex.industrialcomplex.BusinessActivitiesIndustrialComplexIndustrialComplexCollectionClient;\nimport com.github.dannil.scbjavaclient.communication.URLEndpoint;\n\n/**\n * <p"}, {"ID": 1737, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \nResponse:", "ground_truth": "Acquires interceptor from Petite container.", "predict": " @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \n\n*/\n\npackage com.petebevin.markdown.client.action;\n\nimport com.petebevin.markdown.client.Markdown;\nimport com.petebevin.markdown.client.MarkdownException;\nimport com.petebevin.markdown.client.MarkdownResponse;\nimport com.petebevin.markdown.client.MarkdownResponse.Status;\nimport com.petebevin.markdown.client.MarkdownResponse.Status.Type;\nimport com.petebevin.markdown.client.MarkdownResponse.Status.Type.Method;\nimport com.petebevin.markdown.client.MarkdownResponse.Status.Type.Response;\nimport com.petebevin.markdown.client."}, {"ID": 1738, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p.name; if (paramName.startsWith(beanNamePrefix)) { final String propertyName = paramName.substring(beanNamePrefix.length()); if (BeanUtil.declared.hasRootProperty(bean, propertyName)) { final Object value = BeanUtil.declared.getProperty(bean, propertyName); setObject(paramName, value); } } }); return _this(); } \nResponse:", "ground_truth": "Sets bean parameters from bean. Non-existing bean properties are ignored.", "predict": " public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p.name; if (paramName.startsWith(beanNamePrefix)) { final String propertyName = paramName.substring(beanNamePrefix.length()); if (BeanUtil.declared.hasRootProperty(bean, propertyName)) { final Object value = BeanUtil.declared.getProperty(bean, propertyName); setObject(paramName, value); } } }); return _this(); } \nResp public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p."}, {"ID": 1739, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setMap(final Map parameters) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName = p.name; setObject(paramName, parameters.get(paramName)); }); return _this(); } \nResponse:", "ground_truth": "Sets properties from the map.", "predict": " public Q setMap(final Map parameters) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName = p.name; setObject(paramName, parameters.get(paramName)); }); return _this(); } \nResp public Q setMap(final Map parameters, final String paramName) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName1 = p.name; setObject(paramName1, parameters.get(paramName1)); }); return _this(); } \nResp public Q setMap(final Map parameters, final String paramName, final String paramName1) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName2 = p.name; setObject(paramName2, parameters.get(paramName2));"}, {"ID": 1740, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setObjects(final Object... objects) { int index = 1; for (final Object object : objects) { setObject(index++, object); } return _this(); } \nResponse:", "ground_truth": "Sets an array of objects parameters in given order.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1741, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertChunkAfter(final SqlChunk previous) { SqlChunk next = previous.nextChunk; previous.nextChunk = this; this.previousChunk = previous; if (next != null) { next.previousChunk = this; this.nextChunk = next; } } \nResponse:", "ground_truth": "Appends chunk to previous one and maintains the double-linked list of the previous chunk.\nCurrent surrounding connections of this chunk will be cut-off.", "predict": " Insert the chunk after the previous chunk.\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.insertChunkAfter(null);\n    }\n\n    public void insertChunkAfter(SqlChunk previous) {\n        if (previous == null) {\n            return;\n        }\n\n        SqlChunk next = previous.nextChunk;\n        previous.nextChunk = this;\n        this.previousChunk = previous;\n        if (next != null) {\n            next.previousChunk = this;\n        }\n    }\n}\n"}, {"ID": 1742, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor lookupType(final Class entity) { final DbEntityDescriptor ded = dbEntityManager.lookupType(entity); if (ded == null) { throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName()); } return ded; } \nResponse:", "ground_truth": "Lookups for entity name and throws an exception if entity type is invalid.", "predict": " Response\n\n*/\n\npublic class DbEntityDescriptorLookupType extends DbEntityDescriptorLookupTypeBase\n{\n  public static final String NAME = \"lookupType\";\n\n  public DbEntityDescriptorLookupType()\n  {\n    super(NAME);\n  }\n\n  public DbEntityDescriptorLookupType(Configuration configuration)\n  {\n    super(NAME, configuration);\n  }\n\n  protected String getEntityName(Object entity)\n  {\n    return ((DbEntityDescriptor)entity).getName();\n  }\n\n  protected String getEntityName(Object entity, Object entityId)\n  {\n    return ((DbEntityDescriptor)entity).getName();\n  }\n\n  protected String getEntityName(Object entity, Object entityId, Object entityVersion)\n  {\n    return ((DbEntityDescriptor)entity).getName();\n  }\n\n  protected String getEntityName(Object entity"}, {"ID": 1743, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor findColumnRef(final String columnRef) { DbEntityDescriptor ded = templateData.findTableDescriptorByColumnRef(columnRef); if (ded == null) { throw new DbSqlBuilderException(\"Invalid column reference: [\" + columnRef + \"]\"); } return ded; } \nResponse:", "ground_truth": "Finds a table that contains given column.", "predict": " Response\n\n*/\n\npublic class DbEntityDescriptor {\n\tprivate String tableName;\n\tprivate String tableAlias;\n\tprivate String tableNameWithAlias;\n\tprivate String tableNameWithAliasCapitalized;\n\tprivate String tableNameWithAliasCapitalizedFirstLetter;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterLowerCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterUpperCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterLowerCaseUpperCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterLowerCaseLowerCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterUpperCaseLowerCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterLowerCaseUpperCaseLowerCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterLowerCaseLowerCaseUpperCase;\n\tprivate String tableNameWithAliasCapitalizedFirstLetterUpperCaseLowerCaseLowerCaseUpperCase;\n\tprivate String tableNameWith"}, {"ID": 1744, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveTable(final String tableRef, final DbEntityDescriptor ded) { String tableAlias = templateData.getTableAlias(tableRef); if (tableAlias != null) { return tableAlias; } return ded.getTableNameForQuery(); } \nResponse:", "ground_truth": "Resolves table name or alias that will be used in the query.", "predict": "\n\n*/\n\npublic class DbEntityDescriptor {\n\tprivate String tableName;\n\tprivate String tableAlias;\n\tprivate String tableNameForQuery;\n\tprivate String tableNameForQueryWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQueryWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAliasWithAlias;\n\tprivate String tableNameForQuery"}, {"ID": 1745, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static Class resolveClass(final Object object) { Class type = object.getClass(); return type == Class.class ? (Class) object : type; } \nResponse:", "ground_truth": "Resolves object to a class.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1746, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendMissingSpace(final StringBuilder out) { int len = out.length(); if (len == 0) { return; } len--; if (!CharUtil.isWhitespace(out.charAt(len))) { out.append(' '); } } \nResponse:", "ground_truth": "Appends missing space if the output doesn't end with whitespace.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello World\");\n        sb.append(\"Hello"}, {"ID": 1747, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Enumeration<String> getFileParameterNames() { if (mreq == null) { return null; } return Collections.enumeration(mreq.getFileParameterNames()); } \nResponse:", "ground_truth": "Get an enumeration of the parameter names for uploaded files", "predict": " Response is generated by the method getFileParameterNames().\n*/\n\npublic class FileParameterNames {\n\tpublic static void main(String[] args) {\n\t\tFileParameterNames fp = new FileParameterNames();\n\t\tfp.getFileParameterNames();\n\t}\n\t\n\tpublic Enumeration<String> getFileParameterNames() {\n\t\tif (mreq == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn Collections.enumeration(mreq.getFileParameterNames());\n\t}\n}\n"}, {"ID": 1748, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException { RequestDispatcher dispatcher = request.getRequestDispatcher(page); if (dispatcher != null) { dispatcher.include(request, response); return true; } return false; } \nResponse:", "ground_truth": "Include page which path is relative to the current HTTP request.", "predict": " public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException { RequestDispatcher dispatcher = request.getRequestDispatcher(page); if (dispatcher != null) { dispatcher.include(request, response); return true; } return false; } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Servlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final String PAGE = \"page"}, {"ID": 1749, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getUrl(final HttpServletRequest request) { String servletPath = request.getServletPath(); String query = request.getQueryString(); if ((query != null) && (query.length() != 0)) { servletPath += '?' + query; } return servletPath; } \nResponse:", "ground_truth": "Returns url, without context path, convenient for request dispatcher.", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\n\n@Path(\"/\")\npublic class HelloWorld {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(HelloWorld.class);\n\t\n\t@GET\n\t@Path(\"/hello\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic String getHelloWorld() {\n\t\tLOGGER.info(\"HelloWorld\");\n\t\treturn new Gson().toJson(new ArrayList<String>());\n\t}\n}\n"}, {"ID": 1750, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; } \nResponse:", "ground_truth": "Get current request uri.", "predict": " public static String getResponseUri(final HttpServletResponse response) { String result = getIncludeResponseUri(response); if (result == null) { result = response.getRequestURI(); } return result; } \nRequest: public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; } \nResp public static String getResponseUri(final HttpServletResponse response) { String result = getIncludeResponseUri(response); if (result == null) { result = response.getRequestURI(); } return result; } \nRequest: public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; } \nResp public static String get"}, {"ID": 1751, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] resolveParamNames(final Method actionClassMethod) { MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); String[] names = new String[methodParameters.length]; for (int i = 0; i < methodParameters.length; i++) { names[i] = methodParameters[i].getName(); } return names; } \nResponse:", "ground_truth": "Returns method parameter names.", "predict": " public String[] resolveParamNames(final Method actionClassMethod) { MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); String[] names = new String[methodParameters.length]; for (int i = 0; i < methodParameters.length; i++) { names[i] = methodParameters[i].getName(); } return names; } \n\n*/\n\npublic class Paramo {\n\t\n\tpublic static MethodParameter[] resolveParameters(final Method actionClassMethod) {\n\t\t\n\t\tfinal Class<?>[] parameterTypes = actionClassMethod.getParameterTypes();\n\t\tfinal Annotation[][] parameterAnnotations = actionClassMethod.getParameterAnnotations();\n\t\t\n\t\tfinal MethodParameter[] methodParameters = new MethodParameter[parameterTypes.length];\n\t\t\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\n\t\t\tfinal Class<?> parameterType = parameterTypes[i];\n\t\t\tfinal Annotation[] parameterAnnotation"}, {"ID": 1752, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void start() { initLogger(); log.info(\"PETITE start ----------\"); petiteContainer = createPetiteContainer(); if (externalsCache) { petiteContainer.setExternalsCache(TypeCache.createDefault()); } log.info(\"Web application? \" + isWebApplication); if (!isWebApplication) { // make session scope to act as singleton scope // if this is not a web application (and http session is not available). petiteContainer.registerScope(SessionScope.class, new SingletonScope(petiteContainer)); } // load parameters from properties files petiteContainer.defineParameters(joyPropsSupplier.get().getProps()); // automagic configuration if (autoConfiguration) { final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator(petiteContainer); automagicPetiteConfigurator.registerAsConsumer(joyScannerSupplier.get().getClassScanner()); } petiteContainerConsumers.accept(this.petiteContainer); log.info(\"PETITE OK!\"); } \nResponse:", "ground_truth": "Creates and initializes Petite container.\nIt will be auto-magically configured by scanning the classpath.", "predict": "\n\n*/\n\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation"}, {"ID": 1753, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void stop() { if (log != null) { log.info(\"PETITE stop\"); } if (petiteContainer != null) { petiteContainer.shutdown(); } petiteContainer = null; } \nResponse:", "ground_truth": "Stops Petite container.", "predict": " @Override public void start() { if (log != null) { log.info(\"PETITE start\"); } petiteContainer = new PetiteContainer(); petiteContainer.registerPetiteBean(PetiteBean.class); petiteContainer.registerPetiteBean(PetiteBean2.class); petiteContainer.registerPetiteBean(PetiteBean3.class); petiteContainer.registerPetiteBean(PetiteBean4.class); petiteContainer.registerPetiteBean(PetiteBean5.class); petiteContainer.registerPetiteBean(PetiteBean6.class); petiteContainer.registerPetiteBean(PetiteBean7.class); petiteContainer.registerPetiteBean(PetiteBean8.class); petiteContainer.registerPetiteBean(PetiteBean9.class); petiteContainer.registerPetiteBean(PetiteBean10.class); petiteContainer.register"}, {"ID": 1754, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter subject(final String subject) { final SearchTerm subjectTerm = new SubjectTerm(subject); concat(subjectTerm); return this; } \nResponse:", "ground_truth": "Defines filter for SUBJECT field.\n\n@param subject The SUBJECT.\n@return this", "predict": " Resp public EmailFilter subject(final String subject) { final SearchTerm subjectTerm = new SubjectTerm(subject); concat(subjectTerm); return this; } \n\n*/\n\npublic class EmailFilter {\n\t\n\tprivate SearchTerm subjectTerm;\n\tprivate SearchTerm fromTerm;\n\tprivate SearchTerm toTerm;\n\tprivate SearchTerm ccTerm;\n\tprivate SearchTerm bccTerm;\n\tprivate SearchTerm dateTerm;\n\tprivate SearchTerm sizeTerm;\n\tprivate SearchTerm attachmentTerm;\n\tprivate SearchTerm headerTerm;\n\tprivate SearchTerm bodyTerm;\n\tprivate SearchTerm bodyContentTerm;\n\tprivate SearchTerm bodyContentTypeTerm;\n\tprivate SearchTerm bodyContentEncodingTerm;\n\tprivate SearchTerm bodyContentCharsetTerm;\n\tprivate SearchTerm bodyContentLanguageTerm;\n\tprivate SearchTerm bodyContentLanguageEncodingTerm;\n\tprivate SearchTerm bodyContentLanguageCharsetTerm;\n\tprivate SearchTerm bodyContentLanguageLanguageTerm;"}, {"ID": 1755, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter messageId(final String messageId) { final SearchTerm msgIdTerm = new MessageIDTerm(messageId); concat(msgIdTerm); return this; } \nResponse:", "ground_truth": "Defines filter for message id.\n\n@param messageId The message ID.\n@return this", "predict": " Response is generated by the following java Code. Code: public EmailFilter messageId(final String messageId) { final SearchTerm msgIdTerm = new MessageIDTerm(messageId); concat(msgIdTerm); return this; } \n\n*/\n\npublic class EmailFilter {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new instance of the EmailFilter class.\n\t\tEmailFilter emailFilter = new EmailFilter();\n\t\t\n\t\t// TODO: Set the messageId property to the value of the messageId property of the EmailFilter instance.\n\t\temailFilter.setMessageId(\"messageId\");\n\t\t\n\t\t// TODO: Set the messageId property to the value of the messageId property of the EmailFilter instance.\n\t\temailFilter.setMessageId(\"messageId\");\n\t\t\n\t\t// TODO: Return the EmailFilter instance.\n\t\treturn emailFilter;\n\t}\n\t\n\tprivate String messageId;\n\t\n"}, {"ID": 1756, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter from(final String fromAddress) { final SearchTerm fromTerm = new FromStringTerm(fromAddress); concat(fromTerm); return this; } \nResponse:", "ground_truth": "Defines filter for FROM field.\n\n@param fromAddress The FROM address\n@return this", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1757, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter to(final String toAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, toAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for TO field.\n\n@param toAddress The TO address.\n@return this", "predict": " Response is generated by the method.\n\n*/\n\npublic class EmailFilter {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new EmailFilter object.\n\t\tEmailFilter filter = new EmailFilter();\n\t\t\n\t\t// Create a new SearchTerm object.\n\t\tSearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, \"test@test.com\");\n\t\t\n\t\t// Add the SearchTerm to the EmailFilter.\n\t\tfilter.addTerm(toTerm);\n\t\t\n\t\t// Print the EmailFilter.\n\t\tSystem.out.println(filter);\n\t\t\n\t}\n\t\n\t// Add a SearchTerm to the EmailFilter.\n\tpublic void addTerm(SearchTerm term) {\n\t\t\n\t\t// Create a new SearchTerm object.\n\t\tSearchTerm newTerm = new RecipientStringTerm(RecipientType.TO, \"test@test.com\");\n\t\t\n\t\t// Add the SearchTerm to the Email"}, {"ID": 1758, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter cc(final String ccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.CC, ccAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for CC field.\n\n@param ccAddress CC addreses.\n@return this", "predict": " Response is generated by the method.\n\n*/\n\npublic class EmailFilter {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new EmailFilter object.\n\t\tEmailFilter emailFilter = new EmailFilter();\n\t\t\n\t\t// TODO: Create a new SearchTerm object.\n\t\tSearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, \"test@test.com\");\n\t\t\n\t\t// TODO: Create a new SearchTerm object.\n\t\tSearchTerm ccTerm = new RecipientStringTerm(RecipientType.CC, \"test@test.com\");\n\t\t\n\t\t// TODO: Create a new SearchTerm object.\n\t\tSearchTerm bccTerm = new RecipientStringTerm(RecipientType.BCC, \"test@test.com\");\n\t\t\n\t\t// TODO: Create a new SearchTerm object.\n\t\tSearchTerm subjectTerm = new SubjectTerm(\"test\");\n\t\t\n\t\t// TOD"}, {"ID": 1759, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter bcc(final String bccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.BCC, bccAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for BCC field.\n\n@param bccAddress BCC address.\n@return this", "predict": " Response is generated by the method.\n\n*/\n\npublic class EmailFilter {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tEmailFilter emailFilter = new EmailFilter();\n\t\temailFilter.bcc(\"test@test.com\");\n\t\t\n\t}\n\t\n\tpublic EmailFilter() {\n\t\t\n\t\tSystem.out.println(\"EmailFilter\");\n\t\t\n\t}\n\t\n\tpublic EmailFilter bcc(final String bccAddress) {\n\t\t\n\t\tSystem.out.println(\"bcc\");\n\t\t\n\t\treturn this;\n\t\t\n\t}\n\t\n}\n"}, {"ID": 1760, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter flags(final Flags flags, final boolean value) { final SearchTerm flagTerm = new FlagTerm(flags, value); concat(flagTerm); return this; } \nResponse:", "ground_truth": "Defines filter for many flags at once.\n\n@param flags The {@link Flags} to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " public EmailFilter flags(final Flags flags, final boolean value) { final SearchTerm flagTerm = new FlagTerm(flags, value); concat(flagTerm); return this; } \n\n*/\n\npublic class EmailFilter extends Filter {\n\t\n\tprivate SearchTerm flagTerm;\n\t\n\tpublic EmailFilter(final SearchTerm flagTerm) {\n\t\tthis.flagTerm = flagTerm;\n\t}\n\t\n\tpublic EmailFilter(final Flags flags, final boolean value) {\n\t\tthis.flagTerm = new FlagTerm(flags, value);\n\t}\n\t\n\tpublic EmailFilter(final Flags flags, final String value) {\n\t\tthis.flagTerm = new FlagTerm(flags, value);\n\t}\n\t\n\tpublic EmailFilter(final Flags flags, final int value) {\n\t\tthis.flagTerm = new FlagTerm(flags, value);\n\t}\n\t\n\tpublic EmailFilter(final Flags flags, final long value) {\n\t\tthis.flag"}, {"ID": 1761, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter flag(final Flag flag, final boolean value) { final Flags flags = new Flags(); flags.add(flag); return flags(flags, value); } \nResponse:", "ground_truth": "Defines filter for single flag.\n\n@param flag  The flag to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1762, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter receivedDate(final Operator operator, final long milliseconds) { final SearchTerm term = new ReceivedDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for received date.\n\n@return this", "predict": " No response.\n*/\n\npublic class EmailFilter extends Filter {\n    private final SearchTerm term;\n\n    public EmailFilter(final SearchTerm term) {\n        this.term = term;\n    }\n\n    @Override\n    public String toString() {\n        return \"EmailFilter{\" +\n                \"term=\" + term +\n                '}';\n    }\n}\n"}, {"ID": 1763, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter sentDate(final Operator operator, final long milliseconds) { final SearchTerm term = new SentDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for sent date.\n\n@param operator     {@link Operator} to use.\n@param milliseconds the milliseconds since January 1, 1970, 00:00:00 GMT.\n@return this", "predict": " No response.\n*/\n\npublic class EmailFilter extends Filter {\n    private final SearchTerm term;\n\n    public EmailFilter(final SearchTerm term) {\n        this.term = term;\n    }\n\n    @Override\n    public String toString() {\n        return \"EmailFilter{\" +\n                \"term=\" + term +\n                '}';\n    }\n}\n"}, {"ID": 1764, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter size(final Operator comparison, final int size) { final SearchTerm term = new SizeTerm(comparison.value, size); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for message size.\n\n@param comparison {@link Operator}.\n@param size       size of message.\n@return this", "predict": "\n\npublic EmailFilter size(final Operator comparison, final int size) {\n    final SearchTerm term = new SizeTerm(comparison.value, size);\n    concat(term);\n    return this;\n}\n\n*/\n\npublic class EmailFilter extends Filter {\n    private final Operator operator;\n    private final int size;\n\n    public EmailFilter(Operator operator, int size) {\n        this.operator = operator;\n        this.size = size;\n    }\n\n    @Override\n    public String toString() {\n        return \"EmailFilter{\" +\n                \"operator=\" + operator +\n                \", size=\" + size +\n                '}';\n    }\n\n    @Override\n    public String getJavaCode() {\n        return \"public EmailFilter size(\" + operator.getJavaCode() + \", \" + size + \");\";\n    }\n}\n"}, {"ID": 1765, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter and(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new AndTerm(searchTerms)); return this; } \nResponse:", "ground_truth": "Defines AND group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to AND.\n@return this", "predict": " public EmailFilter and(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new AndTerm(searchTerms)); return this; } \n\n*/\n\npublic class EmailFilter {\n\tprivate SearchTerm searchTerm;\n\t\n\tpublic EmailFilter(String searchTerm) {\n\t\tthis.searchTerm = new SearchTerm(searchTerm);\n\t}\n\t\n\tpublic EmailFilter and(EmailFilter... emailFilters) {\n\t\tSearchTerm[] searchTerms = new SearchTerm[emailFilters.length];\n\t\tfor (int i = 0; i < emailFilters.length; i++) {\n\t\t\tsearchTerms[i] = emailFilters[i].searchTerm;\n\t\t}\n\t\t\n\t\tsearchTerm.and"}, {"ID": 1766, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter or(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new OrTerm(searchTerms)); return this; } \nResponse:", "ground_truth": "Defines OR group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to OR.\n@return this", "predict": " public EmailFilter or(final EmailFilter... emailFilters) { return or(emailFilters); }\n\n*/\n\npublic class EmailFilter {\n\tprivate SearchTerm searchTerm;\n\t\n\tpublic EmailFilter(SearchTerm searchTerm) {\n\t\tthis.searchTerm = searchTerm;\n\t}\n\t\n\tpublic EmailFilter or(final EmailFilter... emailFilters) {\n\t\tfinal SearchTerm[] searchTerms = new SearchTerm[emailFilters.length];\n\t\tfor (int i = 0; i < emailFilters.length; i++) {\n\t\t\tsearchTerms[i] = emailFilters[i].searchTerm;\n\t\t}\n\t\t\n\t\treturn new EmailFilter(new OrTerm(searchTerms));\n\t}\n\t\n\tpublic EmailFilter concat(final SearchTerm searchTerm) {\n\t\treturn new EmailFilter(new ConcatTerm(this.searchTerm, searchTerm));\n\t}\n\t\n\tpublic EmailFilter concat("}, {"ID": 1767, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter not(final EmailFilter emailFilter) { final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm); concat(searchTerm); return this; } \nResponse:", "ground_truth": "Appends single filter as NOT.\n\n@param emailFilter {@link EmailFilter} to append.\n@return this", "predict": " Response is generated by the following java Code. Code: public EmailFilter not(final EmailFilter emailFilter) { final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm); concat(searchTerm); return this; } \n */\n\npublic class EmailFilter extends Filter {\n\t\n\tprivate SearchTerm searchTerm;\n\t\n\tpublic EmailFilter(SearchTerm searchTerm) {\n\t\tthis.searchTerm = searchTerm;\n\t}\n\t\n\tpublic EmailFilter(String searchTerm) {\n\t\tthis.searchTerm = new SearchTerm(searchTerm);\n\t}\n\t\n\tpublic EmailFilter(String searchTerm, String field) {\n\t\tthis.searchTerm = new SearchTerm(searchTerm, field);\n\t}\n\t\n\tpublic EmailFilter(String searchTerm, String field, String operator) {\n\t\tthis.searchTerm = new SearchTerm(searchTerm, field, operator);\n\t}\n\t\n\tpublic EmailFilter(String searchTerm, String"}, {"ID": 1768, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void concat(SearchTerm searchTerm) { if (nextIsNot) { searchTerm = new NotTerm(searchTerm); nextIsNot = false; } if (operatorAnd) { and(searchTerm); } else { or(searchTerm); } } \nResponse:", "ground_truth": "Concatenates last search term with new one.\n\n@param searchTerm searchTerm {@link SearchTerm} concatenate.\n@see #and(SearchTerm)\n@see #or(SearchTerm)", "predict": " Response = new Response(searchTerm);\n\n*/\n\npublic class SearchTerm {\n\tprivate String field;\n\tprivate String value;\n\tprivate boolean nextIsNot;\n\tprivate boolean operatorAnd;\n\t\n\tpublic SearchTerm(String field, String value) {\n\t\tthis.field = field;\n\t\tthis.value = value;\n\t}\n\t\n\tpublic void and(SearchTerm searchTerm) {\n\t\tif (nextIsNot) {\n\t\t\tsearchTerm = new NotTerm(searchTerm);\n\t\t\tnextIsNot = false;\n\t\t}\n\t\toperatorAnd = true;\n\t\tthis.value = searchTerm.value;\n\t}\n\t\n\tpublic void or(SearchTerm searchTerm) {\n\t\tif (nextIsNot) {\n\t\t\tsearchTerm = new NotTerm(searchTerm);\n\t\t\tnextIsNot = false;\n\t\t}\n\t\toperatorAnd = false;\n\t\tthis.value = searchTerm.value;\n\t}\n\t\n"}, {"ID": 1769, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encode(final byte[] bytes) { StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i < bytes.length) { // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] & 255; base32.append(CHARS[currByte >> 3]); digit = (currByte & 7) << 2; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 6)]); base32.append(CHARS[(currByte >> 1) & 31]); digit = (currByte & 1) << 4; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 4)]); digit = (currByte & 15) << 1; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 7)]); base32.append(CHARS[(currByte >> 2) & 31]); digit = (currByte & 3) << 3; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 5)]); base32.append(CHARS[currByte & 31]); } return base32.toString(); } \nResponse:", "ground_truth": "Encode an array of binary bytes into a Base32 string.", "predict": "\n\npublic static String decode(final String base32) { byte[] bytes = new byte[base32.length() * 5 / 8]; int i = 0; for (int j = 0; j < base32.length(); j++) { char c = base32.charAt(j); if (c == ' ') { continue; } // skip whitespace\nbyte b = (byte) (CHARS.indexOf(c) << 3); if (j + 1 < base32.length()) { c = base32.charAt(++j); b |= (byte) ((CHARS.indexOf(c) & 0x3) << 6); } else { b |= (byte) (CHARS.indexOf(c) << 6); break; } // skip whitespace\nif (j + 2 < base32.length()) { c = base32.charAt(++j); b |= (byte) ((CHARS.indexOf(c) & 0x3) <<"}, {"ID": 1770, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected byte[] convertValueToArray(final Object value) { if (value instanceof Blob) { final Blob blob = (Blob) value; try { final long length = blob.length(); if (length > Integer.MAX_VALUE) { throw new TypeConversionException(\"Blob is too big.\"); } return blob.getBytes(1, (int) length); } catch (SQLException sex) { throw new TypeConversionException(value, sex); } } if (value instanceof File) { try { return FileUtil.readBytes((File) value); } catch (IOException ioex) { throw new TypeConversionException(value, ioex); } } if (value instanceof Collection) { final Collection collection = (Collection) value; final byte[] target = new byte[collection.size()]; int i = 0; for (final Object element : collection) { target[i] = convertType(element); i++; } return target; } if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final ArrayList<Byte> byteArrayList = new ArrayList<>(); for (final Object element : iterable) { final byte convertedValue = convertType(element); byteArrayList.add(Byte.valueOf(convertedValue)); } final byte[] array = new byte[byteArrayList.size()]; for (int i = 0; i < byteArrayList.size(); i++) { final Byte b = byteArrayList.get(i); array[i] = b.byteValue(); } return array; } if (value instanceof CharSequence) { final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS); return convertArrayToArray(strings); } // everything else: return convertToSingleElementArray(value); } \nResponse:", "ground_truth": "Converts non-array value to array. Detects various\ntypes and collections, iterates them to make conversion\nand to create target array.", "predict": " public static byte[] convertToSingleElementArray(final Object value) { if (value instanceof Blob) { final Blob blob = (Blob) value; try { final long length = blob.length(); if (length > Integer.MAX_VALUE) { throw new TypeConversionException(\"Blob is too big.\"); } return blob.getBytes(1, (int) length); } catch (SQLException sex) { throw new TypeConversionException(value, sex); } } if (value instanceof File) { try { return FileUtil.readBytes((File) value); } catch (IOException ioex) { throw new TypeConversionException(value, ioex); } } if (value instanceof Collection) { final Collection collection = (Collection) value; final byte[] target = new byte[collection.size()]; int i = 0; for (final Object element : collection) { target[i] = convertType(element); i++; } return target; } if ("}, {"ID": 1771, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean isGzipEligible(final HttpServletRequest request) { // request parameter name if (requestParameterName.length() != 0) { String forceGzipString = request.getParameter(requestParameterName); if (forceGzipString != null) { return Converter.get().toBooleanValue(forceGzipString, false); } } // extract uri String uri = request.getRequestURI(); if (uri == null) { return false; } uri = uri.toLowerCase(); boolean result = false; // check uri if (matches == null) { // match == * if (extensions == null) { // extensions == * return true; } // extension String extension = FileNameUtil.getExtension(uri); if (extension.length() > 0) { extension = extension.toLowerCase(); if (StringUtil.equalsOne(extension, extensions) != -1) { result = true; } } } else { if (wildcards) { result = Wildcard.matchPathOne(uri, matches) != -1; } else { for (String match : matches) { if (uri.contains(match)) { result = true; break; } } } } if ((result) && (excludes != null)) { if (wildcards) { if (Wildcard.matchPathOne(uri, excludes) != -1) { result = false; } } else { for (String exclude : excludes) { if (uri.contains(exclude)) { result = false; // excludes founded break; } } } } return result; } \nResponse:", "ground_truth": "Determine if request is eligible for GZipping.", "predict": "\n\n*/\n\npackage com.google.code.gsonrmi.transport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.google.code.gsonrmi.transport.json.JsonReader;\nimport com.google.code.gsonrmi.transport.json.JsonWriter;\n\npublic class GzipStreamTransport extends StreamTransport {\n\n\tprivate final GZIPOutputStream gzipOutputStream;\n\tprivate final GZIPInputStream gzipInputStream;\n\tprivate final JsonWriter jsonWriter;\n\tprivate final JsonReader jsonReader;\n\tprivate final OutputStream outputStream;\n\tprivate final InputStream inputStream;\n\t\n\tpublic GzipStreamTransport(OutputStream outputStream"}, {"ID": 1772, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Violation> validate(final Object target) { return validate(ValidationContext.resolveFor(target.getClass()), target); } \nResponse:", "ground_truth": "Validate object using context from the annotations.", "predict": " Response.ok().build();\n\n@Path(\"/validate\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class ValidationResource {\n\n    @GET\n    @Path(\"/{target}\")\n    public Response validate(@PathParam(\"target\") final String target) {\n        return Response.ok().build();\n    }\n}\n"}, {"ID": 1773, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) { for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) { String name = entry.getKey(); Object value = BeanUtil.declaredSilent.getProperty(target, name); String valueName = targetName != null ? (targetName + '.' + name) : name; // move up ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName); for (Check check : entry.getValue()) { String[] checkProfiles = check.getProfiles(); if (!matchProfiles(checkProfiles)) { continue; } if (check.getSeverity() < severity) { continue; } ValidationConstraint constraint = check.getConstraint(); if (!constraint.isValid(vcc, value)) { addViolation(new Violation(valueName, target, value, check)); } } } return getViolations(); } \nResponse:", "ground_truth": "Performs validation of provided validation context and appends violations.", "predict": " public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) { for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) { String name = entry.getKey(); Object value = BeanUtil.declaredSilent.getProperty(target, name); String valueName = targetName != null ? (targetName + '.' + name) : name; // move up ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName); for (Check check : entry.getValue()) { String[] checkProfiles = check.getProfiles(); if (!matchProfiles(checkProfiles)) { continue; } if (check.getSeverity() < severity) { continue; } ValidationConstraint constraint = check.getConstraint(); if (!constraint.isValid(vcc, value)) { addViolation(new Violation(valueName,"}, {"ID": 1774, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useProfile(final String profile) { if (profile == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } this.enabledProfiles.add(profile); } \nResponse:", "ground_truth": "Enables single profile.", "predict": "\n\n*/\n\nimport java.util.Set;\n\npublic class Profile {\n    private Set<String> enabledProfiles;\n\n    public Profile() {\n        this.enabledProfiles = new HashSet<>();\n    }\n\n    public Set<String> getEnabledProfiles() {\n        return enabledProfiles;\n    }\n\n    public void setEnabledProfiles(Set<String> enabledProfiles) {\n        this.enabledProfiles = enabledProfiles;\n    }\n}\n"}, {"ID": 1775, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useProfiles(final String... enabledProfiles) { if (enabledProfiles == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } Collections.addAll(this.enabledProfiles, enabledProfiles); } \nResponse:", "ground_truth": "Enables list of profiles.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Profiles {\n\n    private List<String> enabledProfiles;\n\n    public Profiles() {\n        this.enabledProfiles = new ArrayList<>();\n    }\n\n    public void useProfiles(final String... enabledProfiles) {\n        if (enabledProfiles == null) {\n            return;\n        }\n        if (this.enabledProfiles == null) {\n            this.enabledProfiles = new ArrayList<>();\n        }\n        Collections.addAll(this.enabledProfiles, enabledProfiles);\n    }\n\n    public List<String> getEnabledProfiles() {\n        return enabledProfiles;\n    }\n}\n"}, {"ID": 1776, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean matchProfiles(final String[] checkProfiles) { // test for all profiles if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) { return true; } if (enabledProfiles == null || enabledProfiles.isEmpty()) { if (validateAllProfilesByDefault) { return true; // all profiles are considered as enabled } // only default profile is enabled if ((checkProfiles == null) || (checkProfiles.length == 0)) { return true; } for (String profile : checkProfiles) { if (StringUtil.isEmpty(profile)) { return true; // default profile } if (profile.equals(DEFAULT_PROFILE)) { return true; } } return false; } // there are enabled profiles if ((checkProfiles == null) || (checkProfiles.length == 0)) { return enabledProfiles.contains(DEFAULT_PROFILE); } boolean result = false; for (String profile : checkProfiles) { boolean b = true; boolean must = false; if (StringUtil.isEmpty(profile)) { profile = DEFAULT_PROFILE; } else if (profile.charAt(0) == '-') { profile = profile.substring(1); b = false; } else if (profile.charAt(0) == '+') { profile = profile.substring(1); must = true; } if (enabledProfiles.contains(profile)) { if (!b) { return false; } result = true; } else { if (must) { return false; } } } return result; } \nResponse:", "ground_truth": "Determine if any of checks profiles is among enabled profiles.", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Type;\n\npublic final class Primitives {\n    private Primitives() {\n    }\n\n    public static final Type BOOLEAN_TYPE = boolean.class;\n    public static final Type BYTE_TYPE = byte.class;\n    public static final Type SHORT_TYPE = short.class;\n    public static final Type INTEGER_TYPE = int.class;\n    public static final Type LONG_TYPE = long.class;\n    public static final Type CHARACTER_TYPE = char.class;\n    public static final Type FLOAT_TYPE = float.class;\n    public static final Type DOUBLE_TYPE = double.class;\n    public static final Type VOID_TYPE = void.class;\n}\n"}, {"ID": 1777, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object parseRequestBody(final String body, final Class targetType) { return JsonParser.create().parse(body, targetType); } \nResponse:", "ground_truth": "Parses request body into the target type.", "predict": " ResponseEntity<Object> response(final Object body, final HttpStatus status) { return new ResponseEntity<Object>(body, status); } \nResp ResponseEntity<Object> response(final Object body, final HttpStatus status, final HttpHeaders headers) { return new ResponseEntity<Object>(body, status, headers, null); } \nResp ResponseEntity<Object> response(final Object body, final HttpStatus status, final HttpHeaders headers, final HttpStatus... statusVariants) { return new ResponseEntity<Object>(body, status, headers, statusVariants); } \nResp ResponseEntity<Object> response(final Object body, final HttpStatus status, final HttpHeaders headers, final Locale locale, final MediaType contentType) { return new ResponseEntity<Object>(body, status, headers, locale, contentType); } \nResp ResponseEntity<Object> response(final Object body, final HttpStatus status, final HttpHeaders"}, {"ID": 1778, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long toMilliseconds() { double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY; then += (integer - JD_1970.integer) * MILLIS_IN_DAY; then += then > 0 ? 1.0e-6 : -1.0e-6; return (long) then; } \nResponse:", "ground_truth": "Converts to milliseconds.", "predict": "\n\n*/\n\npublic class Solution {\n    public long toMilliseconds(double fraction, int integer) {\n        double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY;\n        then += (integer - JD_1970.integer) * MILLIS_IN_DAY;\n        then += then > 0 ? 1.0e-6 : -1.0e-6;\n        return (long) then;\n    }\n}\n"}, {"ID": 1779, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JulianDate add(final JulianDate jds) { int i = this.integer + jds.integer; double f = this.fraction + jds.fraction; return new JulianDate(i, f); } \nResponse:", "ground_truth": "Adds a JD to current instance.", "predict": "\n\n*/\n\npublic class JulianDate {\n    private int integer;\n    private double fraction;\n\n    public JulianDate(int integer, double fraction) {\n        this.integer = integer;\n        this.fraction = fraction;\n    }\n\n    public int getInteger() {\n        return integer;\n    }\n\n    public double getFraction() {\n        return fraction;\n    }\n\n    public void setInteger(int integer) {\n        this.integer = integer;\n    }\n\n    public void setFraction(double fraction) {\n        this.fraction = fraction;\n    }\n\n    public String toString() {\n        return \"JulianDate{\" +\n                \"integer=\" + integer +\n                \", fraction=\" + fraction +\n                '}';\n    }\n}\n"}, {"ID": 1780, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JulianDate sub(final JulianDate jds) { int i = this.integer - jds.integer; double f = this.fraction -jds.fraction; return new JulianDate(i, f); } \nResponse:", "ground_truth": "Subtracts a JD from current instance.", "predict": "\n\n*/\n\npublic class JulianDate {\n    private int integer;\n    private double fraction;\n\n    public JulianDate(int integer, double fraction) {\n        this.integer = integer;\n        this.fraction = fraction;\n    }\n\n    public int getInteger() {\n        return integer;\n    }\n\n    public double getFraction() {\n        return fraction;\n    }\n\n    public void setInteger(int integer) {\n        this.integer = integer;\n    }\n\n    public void setFraction(double fraction) {\n        this.fraction = fraction;\n    }\n\n    public String toString() {\n        return \"JulianDate{\" +\n                \"integer=\" + integer +\n                \", fraction=\" + fraction +\n                '}';\n    }\n}\n"}, {"ID": 1781, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void set(final int i, double f) { integer = i; int fi = (int) f; f -= fi; integer += fi; if (f < 0) { f += 1; integer--; } this.fraction = f; } \nResponse:", "ground_truth": "Sets integer and fractional part with normalization.\nNormalization means that if double is out of range,\nvalues will be correctly fixed.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int n = 0;\n        double f = 0.0;\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        f = in.nextDouble();\n        System.out.println(n + \" \" + f);\n    }\n}\n"}, {"ID": 1782, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void initialize(final char[] input) { super.initialize(input); this.tag = new ParsedTag(); this.doctype = new ParsedDoctype(); this.text = new char[1024]; this.textLen = 0; this.parsingTime = -1; } \nResponse:", "ground_truth": "Initializes parser.", "predict": "\n\n*/\n\npublic class ParsedTag extends ParsedTagBase {\n\tpublic ParsedTag() {\n\t\tsuper();\n\t}\n\t\n\tpublic ParsedTag(final String tagName, final String tagValue) {\n\t\tsuper(tagName, tagValue);\n\t}\n\t\n\tpublic ParsedTag(final String tagName, final String tagValue, final String tagType) {\n\t\tsuper(tagName, tagValue, tagType);\n\t}\n\t\n\tpublic ParsedTag(final String tagName, final String tagValue, final String tagType, final String tagTypeValue) {\n\t\tsuper(tagName, tagValue, tagType, tagTypeValue);\n\t}\n\t\n\tpublic ParsedTag(final String tagName, final String tagValue, final String tagType, final String tagTypeValue, final String tagValue2) {\n\t\tsuper(tagName, tagValue, tagType, tagTypeValue, tagValue2);\n\t"}, {"ID": 1783, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void emitComment(final int from, final int to) { if (config.enableConditionalComments) { // CC: downlevel-hidden starting if (match(CC_IF, from)) { int endBracketNdx = find(']', from + 3, to); CharSequence expression = charSequence(from + 1, endBracketNdx); ndx = endBracketNdx + 1; char c = input[ndx]; if (c != '>') { errorInvalidToken(); } visitor.condComment(expression, true, true, false); state = DATA_STATE; return; } if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) { // CC: downlevel-hidden ending visitor.condComment(_ENDIF, false, true, true); state = DATA_STATE; return; } } CharSequence comment = charSequence(from, to); visitor.comment(comment); commentStart = -1; } \nResponse:", "ground_truth": "Emits a comment. Also checks for conditional comments!", "predict": " public void emitComment(final int from, final int to) { if (config.enableConditionalComments) { // CC: downlevel-hidden starting if (match(CC_IF, from)) { int endBracketNdx = find(']', from + 3, to); CharSequence expression = charSequence(from + 1, endBracketNdx); ndx = endBracketNdx + 1; char c = input[ndx]; if (c != '>') { errorInvalidToken(); } visitor.condComment(expression, true, true, false); state = DATA_STATE; return; } if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) { // CC: downlevel-hidden ending visitor.condComment(_ENDIF, false, true, true); state = DATA_STATE; return; } } CharSequence comment = charSequence(from, to); visitor.comment(comment); comment"}, {"ID": 1784, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void _error(String message) { if (config.calculatePosition) { Position currentPosition = position(ndx); message = message .concat(StringPool.SPACE) .concat(currentPosition.toString()); } else { message = message .concat(\" [@\") .concat(Integer.toString(ndx)) .concat(StringPool.RIGHT_SQ_BRACKET); } visitor.error(message); } \nResponse:", "ground_truth": "Prepares error message and reports it to the visitor.", "predict": "\n\n*/\n\npublic class Error {\n    public static void _error(String message) {\n        if (config.calculatePosition) {\n            Position currentPosition = position(ndx);\n            message = message .concat(StringPool.SPACE) .concat(currentPosition.toString());\n        } else {\n            message = message .concat(\" [@\") .concat(Integer.toString(ndx)) .concat(StringPool.RIGHT_SQ_BRACKET);\n        }\n        visitor.error(message);\n    }\n}\n"}, {"ID": 1785, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String createHash(final char[] password) { // Generate a random salt SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltBytes]; random.nextBytes(salt); // Hash the password byte[] hash = pbkdf2(password, salt, pbkdf2Iterations, hashBytes); // format iterations:salt:hash return pbkdf2Iterations + \":\" + StringUtil.toHexString(salt) + \":\" + StringUtil.toHexString(hash); } \nResponse:", "ground_truth": "Returns a salted PBKDF2 hash of the password.\n\n@param password the password to hash\n@return a salted PBKDF2 hash of the password", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class Hash {\n    public static void main(String[] args) {\n        String salt = \"\";\n        String hash = \"\";\n        int iterations = 0;\n        int hashBytes = 0;\n        String password = \"\";\n        String passwordHash = \"\";\n        String passwordSalt = \"\";\n        String passwordHashSalt = \"\";\n        String passwordHashSaltBase64 = \"\";\n        String passwordHashSaltHex = \"\";\n        String passwordHashSaltHexBase64 = \"\";\n        String passwordHashSaltHexBase64Url = \"\";\n        String passwordHashSaltHexBase64UrlEnc = \"\";\n        String passwordHashSaltHexBase64UrlEncUrl = \"\";\n        String passwordHashSaltHexBase64UrlEncUrlEnc = \"\";\n"}, {"ID": 1786, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] pbkdf2(final char[] password, final byte[] salt, final int iterations, final int bytes) { PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8); try { SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM); return skf.generateSecret(spec).getEncoded(); } catch (NoSuchAlgorithmException ignore) { return null; } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } } \nResponse:", "ground_truth": "Computes the PBKDF2 hash of a password.\n\n@param password the password to hash.\n@param salt the salt\n@param iterations the iteration count (slowness factor)\n@param bytes the length of the hash to compute in bytes\n@return the PBDKF2 hash of the password", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Base64;\n\npublic class PBKDF2 {\n    public static byte[] pbkdf2(char[] password, byte[] salt, int iterations, int bytes) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(salt);\n            byte[] key = digest.digest(password);\n            for (int i = 1; i < iterations; i++) {\n                digest.reset();\n                digest.update(key);\n                key = digest.digest(key);\n            }\n            byte[] result = new byte[bytes];\n            System.arraycopy(key, 0, result, 0,"}, {"ID": 1787, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] fromHex(final String hex) { final byte[] binary = new byte[hex.length() / 2]; for (int i = 0; i < binary.length; i++) { binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16); } return binary; } \nResponse:", "ground_truth": "Converts a string of hexadecimal characters into a byte array.\n\n@param hex the hex string\n@return the hex string decoded into a byte array", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] a = new int[n];\n        for(int a_i=0; a_i < n; a_i++){\n            a[a_i] = in.nextInt();\n        }\n        int[] b = new int[n];\n        for(int b_i=0; b_i < n; b_i++){\n            b[b_i] = in.nextInt();\n        }\n        int[] c = new int[n];\n        for(int c_i=0; c_i < n; c_i++){\n            c[c_i] = in.nextInt();\n        }\n"}, {"ID": 1788, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProviderDefinition[] resolveProviderDefinitions(final Class type, final String name) { return providerResolver.resolve(type, name); } \nResponse:", "ground_truth": "Resolves provider definition defined in a bean.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1789, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailAttachmentBuilder name(final String name) { if (name != null && !name.trim().isEmpty()) { this.name = name; } return this; } \nResponse:", "ground_truth": "Sets file name.\n\n@param name File name to set.\n@return this", "predict": " Response is generated by the method.\n\n*/\n\npublic class EmailAttachmentBuilder {\n    private String name;\n\n    public EmailAttachmentBuilder name(final String name) {\n        this.name = name;\n        return this;\n    }\n\n    public EmailAttachment build() {\n        return new EmailAttachment(name);\n    }\n}\n"}, {"ID": 1790, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected EmailAttachmentBuilder setContentIdFromNameIfMissing() { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; } \nResponse:", "ground_truth": "Set content ID if it is missing.\n\n@return this\n@see #contentId(String)", "predict": " ResponseBuilder<EmailAttachmentBuilder> setContentIdFromNameIfMissing(String name) { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; } \nResp ResponseBuilder<EmailAttachmentBuilder> setContentIdFromNameIfMissing(String name, String fileName) { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; } \nResp ResponseBuilder<EmailAttachmentBuilder> setContentIdFromNameIfMissing(String name, String fileName, String contentType) { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; } \nResp"}, {"ID": 1791, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveContentType(final String contentType) { if (contentType != null) { return contentType; } if (name == null) { return MimeTypes.MIME_APPLICATION_OCTET_STREAM; } final String extension = FileNameUtil.getExtension(name); return MimeTypes.getMimeType(extension); } \nResponse:", "ground_truth": "Resolves content type from all data.\n\n@param contentType Content type if we know it. {@code null} is fine to use.\n@return content type", "predict": " public Response<T> execute(final Request request) { return null; } \nResp public Response<T> execute(final Request request, final Response.ErrorListener listener) { return null; } \nResp public Response<T> execute(final Request request, final Response.ErrorListener listener, final Response.Listener<T> listener) { return null; } \nResp public Response<T> execute(final Request request, final Response.Listener<T> listener) { return null; } \nResp public Response<T> execute(final Request request, final Response.Listener<T> listener, final Response.ErrorListener errorListener) { return null; } \nResp public Response<T> execute(final Request request, final Response.Listener<T> listener, final Response.ErrorListener errorListener, final Response.ProgressListener progressListener) { return null; } \nResp public Response<T> execute(final Request request, final Response.Listener<T> listener, final Response"}, {"ID": 1792, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int computeAttributesSize() { symbolTable.addConstantUtf8(Constants.MODULE); // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; if (packageCount > 0) { symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES); // 6 attribute header bytes, and 2 bytes for package_count. size += 8 + packageIndex.length; } if (mainClassIndex > 0) { symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS); // 6 attribute header bytes, and 2 bytes for main_class_index. size += 8; } return size; } \nResponse:", "ground_truth": "Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\nModuleWriter. Also add the names of these attributes in the constant pool.\n\n@return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Module {\n    private final String name;\n    private final List<Requires> requires;\n    private final List<Exports> exports;\n    private final List<Opens> opens;\n    private final List<Uses> uses;\n    private final List<Provides> provides;\n    private final List<Package> packages;\n    private final int mainClassIndex;\n    private final int packageCount;\n    private final List<Integer> packageIndex;\n\n    public Module(String name, List<Requires> requires, List<Exports> exports, List<Opens> opens, List<Uses> uses, List<Provides> provides, List<Package> packages, int mainClassIndex, int packageCount, List<Integer> packageIndex) {\n        this.name = name;\n        this.requires = requires;\n        this.exports = exports;"}, {"ID": 1793, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putAttributes(final ByteVector output) { // 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; output .putShort(symbolTable.addConstantUtf8(Constants.MODULE)) .putInt(moduleAttributeLength) .putShort(moduleNameIndex) .putShort(moduleFlags) .putShort(moduleVersionIndex) .putShort(requiresCount) .putByteArray(requires.data, 0, requires.length) .putShort(exportsCount) .putByteArray(exports.data, 0, exports.length) .putShort(opensCount) .putByteArray(opens.data, 0, opens.length) .putShort(usesCount) .putByteArray(usesIndex.data, 0, usesIndex.length) .putShort(providesCount) .putByteArray(provides.data, 0, provides.length); if (packageCount > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)) .putInt(2 + packageIndex.length) .putShort(packageCount) .putByteArray(packageIndex.data, 0, packageIndex.length); } if (mainClassIndex > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)) .putInt(2) .putShort(mainClassIndex); } } \nResponse:", "ground_truth": "Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\nin the given ByteVector.\n\n@param output where the attributes must be put.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.analysis.Analyzer;\nimport org.objectweb.asm.tree.analysis.AnalyzerException;\nimport org.objectweb.asm.tree.analysis.BasicInterpreter;\nimport org.objectweb.asm.tree.analysis.BasicValue;\nimport org.objectweb.asm.tree.analysis.Frame;\nimport org.objectweb.asm.tree.analysis.Value;\n"}, {"ID": 1794, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(final String source, final String encoding) { return decode(source, encoding, false); } \nResponse:", "ground_truth": "Decodes URL elements. This method may be used for all\nparts of URL, except for the query parts, since it does\nnot decode the '+' character.\n@see #decodeQuery(String, String)", "predict": " Resp public static String decode(final String source, final String encoding, final boolean ignoreErrors) { \n\tif (source == null) { return null; }\n\tif (encoding == null) { return source; }\n\ttry { return new String(source.getBytes(\"ISO-8859-1\"), encoding); } catch (final UnsupportedEncodingException e) { return source; }\n} \n*/\n\npublic class Decode {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(decode(\"abcdefg\", \"UTF-8\"));\n\t\tSystem.out.println(decode(\"abcdefg\", \"UTF-8\", true));\n\t}\n}\n"}, {"ID": 1795, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decodeQuery(final String source, final String encoding) { return decode(source, encoding, true); } \nResponse:", "ground_truth": "Decodes query name or value.", "predict": " public static String decodeQuery(final String source, final String encoding) { return decode(source, encoding, false); } \n\n*/\n\npublic class DecodeQuery {\n\tpublic static void main(String[] args) {\n\t\tString source = \"http://www.google.com/search?q=java\";\n\t\tString encoding = \"UTF-8\";\n\t\tString result = decode(source, encoding, true);\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static String decode(String source, String encoding, boolean decode) {\n\t\tString result = \"\";\n\t\ttry {\n\t\t\tif (source == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (encoding == null) {\n\t\t\t\treturn source;\n\t\t\t}\n\t\t\tif (decode) {\n\t\t\t\tresult = URLDecoder.decode(source, encoding);\n\t\t\t} else {\n\t\t\t\tresult = URLEncoder.encode(source, encoding);\n\t\t\t"}, {"ID": 1796, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings(\"unchecked\") public void start() { initLogger(); if (!databaseEnabled) { log.info(\"DB not enabled.\"); return; } log.info(\"DB start ----------\"); final PetiteContainer petiteContainer = joyPetiteSupplier.get().getPetiteContainer(); // connection pool connectionProvider = createConnectionProviderIfNotSupplied(); petiteContainer.addBean(beanNamePrefix() + \"pool\", connectionProvider); if (connectionProvider instanceof CoreConnectionPool) { final CoreConnectionPool pool = (CoreConnectionPool) connectionProvider; if (pool.getDriver() == null) { databaseEnabled = false; log.warn(\"DB configuration not set (\" + beanNamePrefix() + \"pool.*). DB will be disabled.\"); return; } } connectionProvider.init(); checkConnectionProvider(); // transactions manager jtxManager = createJtxTransactionManager(connectionProvider); jtxManager.setValidateExistingTransaction(true); final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager(new LeanJtxWorker(jtxManager), jtxScopePattern); AnnotationTxAdviceSupport.manager = annTxAdviceManager; // create proxy joyProxettaSupplier.get().getProxetta().withAspect(createTxProxyAspects(annTxAdviceManager.getAnnotations())); final DbSessionProvider sessionProvider = new DbJtxSessionProvider(jtxManager); // querymap final long startTime = System.currentTimeMillis(); final QueryMap queryMap = new DbPropsQueryMap(); log.debug(\"Queries loaded in \" + (System.currentTimeMillis() - startTime) + \"ms.\"); log.debug(\"Total queries: \" + queryMap.size()); // dboom dbOom = DbOom.create() .withConnectionProvider(connectionProvider) .withSessionProvider(sessionProvider) .withQueryMap(queryMap) .get(); dbOom.connect(); final DbEntityManager dbEntityManager = dbOom.entityManager(); dbEntityManager.reset(); petiteContainer.addBean(beanNamePrefix() + \"query\", dbOom.queryConfig()); petiteContainer.addBean(beanNamePrefix() + \"oom\", dbOom.config()); // automatic configuration if (autoConfiguration) { final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator(dbEntityManager, true); automagicDbOomConfigurator.registerAsConsumer( joyScannerSupplier.get().getClassScanner()); } dbEntityManagerConsumers.accept(dbEntityManager); log.info(\"DB OK!\"); } \nResponse:", "ground_truth": "Initializes database. First, creates connection pool.\nand transaction manager. Then, Jodds DbEntityManager is\nconfigured. It is also configured automagically, by scanning\nthe class path for entities.", "predict": "\n\n*/\n\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.concurrent.ThreadSafe;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.persistence.EntityManager;\nimport javax.pers"}, {"ID": 1797, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void checkConnectionProvider() { final Connection connection = connectionProvider.getConnection(); try { final DatabaseMetaData databaseMetaData = connection.getMetaData(); String name = databaseMetaData.getDatabaseProductName(); String version = databaseMetaData.getDatabaseProductVersion(); if (log.isInfoEnabled()) { log.info(\"Connected to database: \" + name + \" v\" + version); } } catch (SQLException sex) { log.error(\"DB connection failed: \", sex); } finally { connectionProvider.closeConnection(connection); } } \nResponse:", "ground_truth": "Checks if connection provider can return a connection.", "predict": "\n\n*/\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class CheckConnectionProvider {\n\n    private static final Logger log = Logger.getLogger(CheckConnectionProvider.class.getName());\n\n    private ConnectionProvider connectionProvider;\n\n    public CheckConnectionProvider(ConnectionProvider connectionProvider) {\n        this.connectionProvider = connectionProvider;\n    }\n\n    public void checkConnection() {\n        Connection connection = connectionProvider.getConnection();\n        try {\n            DatabaseMetaData databaseMetaData = connection.getMetaData();\n            String name = databaseMetaData.getDatabaseProductName();\n            String version = databaseMetaData.getDatabaseProductVersion();\n            if (log.isInfoEnabled()) {\n                log.info(\"Connected to database: \" + name +"}, {"ID": 1798, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { // if ((access & AsmUtil.ACC_FINAL) != 0) { // return null; // skip finals // } MethodSignatureVisitor msign = createMethodSignature(access, name, desc, signature, exceptions, thisReference, this.generics); String key = ProxettaAsmUtil.createMethodSignaturesKey(access, name, desc, thisReference); methodSignatures.put(key, msign); allMethodSignatures.add(msign.getCleanSignature()); return new MethodAnnotationReader(msign); } \nResponse:", "ground_truth": "Stores method signature for target method.", "predict": "\n\n*/\n\npublic class MethodAnnotationReader extends MethodVisitor {\n\n    private final String methodSignature;\n    private final String cleanSignature;\n    private final String methodName;\n    private final String className;\n    private final String methodDesc;\n    private final String thisReference;\n    private final String[] generics;\n    private final Map<String, MethodSignatureVisitor> methodSignatures;\n    private final List<String> allMethodSignatures;\n\n    public MethodAnnotationReader(final MethodSignatureVisitor msign) {\n        super(Opcodes.ASM5);\n        this.methodSignature = msign.getCleanSignature();\n        this.cleanSignature = msign.getCleanSignature();\n        this.methodName = msign.getMethodName();\n        this.className = msign.getClassName();\n        this.methodDesc = msign.getMethodDesc();\n        this.thisReference"}, {"ID": 1799, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visitEnd() { // prepare class annotations if (classAnnotations != null) { annotations = classAnnotations.toArray(new AnnotationInfo[0]); classAnnotations = null; } List<String> superList = new ArrayList<>(); Set<String> allInterfaces = new HashSet<>(); if (nextInterfaces != null) { allInterfaces.addAll(nextInterfaces); } // check all public super methods that are not overridden in superclass while (nextSupername != null) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex); } finally { StreamUtil.close(inputStream); } superList.add(nextSupername); superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { Collections.addAll(allInterfaces, cr.getInterfaces()); } } superClasses = superList.toArray(new String[0]); // check all interface methods that are not overridden in super-interface Set<String> todoInterfaces = new HashSet<>(allInterfaces); Set<String> newCollectedInterfaces = new HashSet<>(); while (true) { for (String next : todoInterfaces) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(next, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super interface: \" + next, ioex); } finally { StreamUtil.close(inputStream); } superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { for (String newInterface : cr.getInterfaces()) { if (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) { // new interface found newCollectedInterfaces.add(newInterface); } } } } // perform collection allInterfaces.addAll(todoInterfaces); if (newCollectedInterfaces.isEmpty()) { // no new interface found break; } todoInterfaces.clear(); todoInterfaces.addAll(newCollectedInterfaces); newCollectedInterfaces.clear(); } } \nResponse:", "ground_truth": "Stores signatures for all super public methods not already overridden by target class.\nAll this methods will be accepted for proxyfication.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.CtNewMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.bytecode.BadBytecode;\nimport javassist.bytecode.CodeAttribute;\nimport javassist.bytecode.CodeIterator;\nimport javassist.bytecode.ConstPool;\nimport javassist.bytecode.Descriptor;\nimport javassist.bytecode.MethodInfo;\nimport javassist.bytecode.Opcode;"}, {"ID": 1800, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MethodSignatureVisitor createMethodSignature( final int access, final String methodName, final String description, final String signature, final String[] exceptions, final String classname, final Map<String, String> declaredTypeGenerics) { MethodSignatureVisitor v = new MethodSignatureVisitor(methodName, access, classname, description, exceptions, signature, declaredTypeGenerics, this); new SignatureReader(signature != null ? signature : description).accept(v); return v; } \nResponse:", "ground_truth": "Creates method signature from method name.", "predict": " Response.ok(new JSONObject(v.getDeclaredTypeGenerics()), MediaType.APPLICATION_JSON_TYPE);\n\n}\n"}, {"ID": 1801, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toCsvString(final Object... elements) { StringBuilder line = new StringBuilder(); int last = elements.length -1; for (int i = 0; i < elements.length; i++) { if (elements[i] == null) { if (i != last) { line.append(FIELD_SEPARATOR); } continue; } String field = elements[i].toString(); // check for special cases int ndx = field.indexOf(FIELD_SEPARATOR); if (ndx == -1) { ndx = field.indexOf(FIELD_QUOTE); } if (ndx == -1) { if (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) { ndx = 1; } } if (ndx == -1) { ndx = StringUtil.indexOfChars(field, SPECIAL_CHARS); } // add field if (ndx != -1) { line.append(FIELD_QUOTE); } field = StringUtil.replace(field, StringPool.QUOTE, DOUBLE_QUOTE); line.append(field); if (ndx != -1) { line.append(FIELD_QUOTE); } // last if (i != last) { line.append(FIELD_SEPARATOR); } } return line.toString(); } \nResponse:", "ground_truth": "Parse fields as csv string,", "predict": "\n\npublic static String toCsvString(final Object... elements) {\n\tStringBuilder line = new StringBuilder();\n\tint last = elements.length -1;\n\tfor (int i = 0; i < elements.length; i++) {\n\t\tif (elements[i] == null) {\n\t\t\tif (i != last) {\n\t\t\t\tline.append(FIELD_SEPARATOR);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tString field = elements[i].toString();\n\t\tint ndx = field.indexOf(FIELD_SEPARATOR);\n\t\tif (ndx == -1) {\n\t\t\tndx = field.indexOf(FIELD_QUOTE);\n\t\t}\n\t\tif (ndx == -1) {\n\t\t\tif (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) {\n\t\t\t\tndx = 1;\n\t\t\t}\n\t\t}\n\t\tif (ndx"}, {"ID": 1802, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] toStringArray(final String line) { List<String> row = new ArrayList<>(); boolean inQuotedField = false; int fieldStart = 0; final int len = line.length(); for (int i = 0; i < len; i++) { char c = line.charAt(i); if (c == FIELD_SEPARATOR) { if (!inQuotedField) { // ignore we are quoting addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 1; } } else if (c == FIELD_QUOTE) { if (inQuotedField) { if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) { // we are already quoting - peek to see if this is the end of the field addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 2; i++; // and skip the comma inQuotedField = false; } } else if (fieldStart == i) { inQuotedField = true; // this is a beginning of a quote fieldStart++; // move field start } } } // add last field - but only if string was not empty if (len > 0 && fieldStart <= len) { addField(row, line, fieldStart, len, inQuotedField); } return row.toArray(new String[0]); } \nResponse:", "ground_truth": "Converts CSV line to string array.", "predict": "\npublic static String[] toStringArray(final String line) { List<String> row = new ArrayList<>(); boolean inQuotedField = false; int fieldStart = 0; final int len = line.length(); for (int i = 0; i < len; i++) { char c = line.charAt(i); if (c == FIELD_SEPARATOR) { if (!inQuotedField) { // ignore we are quoting addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 1; } } else if (c == FIELD_QUOTE) { if (inQuotedField) { if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) { // we are already quoting - peek to see if this is the end of the field addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 2; i++; // and skip the"}, {"ID": 1803, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor); if (ctorReferences == null) { continue; } if (foundedCtor != null) { throw new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName()); } foundedCtor = ctor; references = ctorReferences; } if (foundedCtor == null) { // there is no annotated constructor if (allCtors.length == 1) { foundedCtor = allCtors[0].getConstructor(); } else { foundedCtor = defaultCtor; } if (foundedCtor == null) { // no matching ctor found // still this is not an error if bean is already instantiated. return CtorInjectionPoint.EMPTY; } references = referencesResolver.readAllReferencesFromAnnotation(foundedCtor); if (references == null) { references = new BeanReferences[0]; } } return new CtorInjectionPoint(foundedCtor, references); } \nResponse:", "ground_truth": "Resolves constructor injection point from type. Looks for single annotated constructor.\nIf no annotated constructors found, the total number of constructors will be checked.\nIf there is only one constructor, that one will be used as injection point. If more\nconstructors exist, the default one will be used as injection point. Otherwise, exception\nis thrown.", "predict": " public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor); if (ctorReferences == null) { continue; } if (foundedCtor != null) { throw new PetiteException(\"Two or more"}, {"ID": 1804, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) { InputStream inputStream = null; try { inputStream = ClassLoaderUtil.getClassAsStream(advice); return new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(ioex); } finally { StreamUtil.close(inputStream); } } \nResponse:", "ground_truth": "Creates advice's class reader.", "predict": "\n\n*/\n\npackage org.springframework.aop.framework;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.aop.Advisor;\nimport org.springframework.aop.framework.AdvisedSupport;\nimport org.springframework.aop.framework.ProxyConfig;\nimport org.springframework.aop.framework.ProxyFactory;\nimport org.springframework.aop.framework.adapter.AdvisorAdapterRegistry;\nimport org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry;\nimport org.springframework.aop.framework.adapter.MutableInterceptorManager;\nimport org.springframework"}, {"ID": 1805, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) { if (adviceClassReaderCache == null) { adviceClassReaderCache = TypeCache.createDefault(); } ClassReader adviceReader = adviceClassReaderCache.get(advice); if (adviceReader == null) { adviceReader = createAdviceClassReader(advice); adviceClassReaderCache.put(advice, adviceReader); } return adviceReader; } \nResponse:", "ground_truth": "Returns class reader for advice.", "predict": "\n\n*/\n\npublic class AdviceClassReader {\n    private static final TypeCache adviceClassReaderCache = TypeCache.createDefault();\n\n    private static ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) {\n        final ClassReader adviceReader = new ClassReader(advice.getName());\n        final ClassVisitor adviceVisitor = new AdviceClassVisitor(advice);\n        adviceReader.accept(adviceVisitor, ClassReader.SKIP_FRAMES);\n        return adviceReader;\n    }\n\n    public static ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) {\n        return adviceClassReaderCache.get(advice);\n    }\n}\n"}, {"ID": 1806, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encrypt(final String str) { try { byte[] utf8 = StringUtil.getBytes(str); // encode the string into bytes using utf-8 byte[] enc = ecipher.doFinal(utf8); // encrypt return Base64.encodeToString(enc); // encode bytes to base64 to get a string } catch (Throwable ignore) { return null; } } \nResponse:", "ground_truth": "Symmetrically encrypts the string.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class Encrypt {\n    public static String encrypt(String str) {\n        try {\n            byte[] utf8 = str.getBytes(\"UTF-8\");\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(utf8);\n            byte[] digest = md.digest();\n            return Base64.getEncoder().encodeToString(digest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n"}, {"ID": 1807, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String decrypt(String str) { try { str = StringUtil.replaceChar(str, ' ', '+'); // replace spaces with chars. byte[] dec = Base64.decode(str); // decode base64 to get bytes byte[] utf8 = dcipher.doFinal(dec); // decrypt return new String(utf8, UTF_8); // decode using utf-8 } catch (Throwable ignore) { return null; } } \nResponse:", "ground_truth": "Symmetrically decrypts the string.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKey"}, {"ID": 1808, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Logger getLogger(final String name) { if (loggers == null) { return loggerProvider.apply(name); } return loggers.computeIfAbsent(name, loggerProvider); } \nResponse:", "ground_truth": "Returns logger for given name. Repeated calls to this method with the\nsame argument should return the very same instance of the logger.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1809, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setName(final String name) { if (name.contains(\";\") || name.contains(\",\") || name.startsWith(\"$\")) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } for (int n = 0; n < name.length(); n++) { char c = name.charAt(n); if (c <= 0x20 || c >= 0x7f) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } } this.name = name; } \nResponse:", "ground_truth": "Sets the cookie name and checks for validity.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.getHtmlCookie(\"\"));\n    }\n\n    public String getHtmlCookie(String cookie) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<html><head><title>Cookie</title></head><body>\");\n        sb.append(\"<h1>Cookie</h1>\");\n        sb.append(\"<form action=\\\"\\\" method=\\\"post\\\">\");\n        sb.append(\"<input type=\\\"text\\\" name=\\\"name\\\"/>\");\n        sb.append(\"<input type=\\\"submit\\\" value=\\\"Submit\\\"/>\");\n        sb.append(\"</form>\");\n        sb.append(\"<h1>Cookie</h1>\");\n        sb.append(\"<form action=\\\"\\\" method=\\\"post\\\">\");\n        sb.append(\""}, {"ID": 1810, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionRequest createActionRequest( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionRequest(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); } \nResponse:", "ground_truth": "", "predict": " public ActionResponse createActionResponse( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionResponse(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); } \n\n}\n"}, {"ID": 1811, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \nResponse:", "ground_truth": "Acquires filter from Petite container.", "predict": " @Override protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \n\n*/\n\npackage com.petebevin.markdown.client.filter;\n\nimport com.petebevin.markdown.client.Markdown;\nimport com.petebevin.markdown.client.MarkdownException;\nimport com.petebevin.markdown.client.MarkdownProcessor;\nimport com.petebevin.markdown.client.MarkdownProcessor.MarkdownProcessorBuilder;\nimport com.petebevin.markdown.client.MarkdownProcessor.MarkdownProcessorBuilder.MarkdownProcessorBuilderCallback;\nimport com.petebevin.markdown.client.MarkdownProcessor.MarkdownProcessorBuilder.MarkdownProcessorBuilderCallback.MarkdownProcessorBuilderCallbackResult;\nimport com.petebe"}, {"ID": 1812, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void destroyBean(final BeanData beanData) { if (destroyableBeans == null) { return; } if (!isBeanDestroyable(beanData)) { return; } if (destroyableBeans.remove(beanData)) { beanData.callDestroyMethods(); } } \nResponse:", "ground_truth": "Removes destroyable bean from the list and calls it destroy methods.\nIf bean is not destroyable, does nothing. Bean gets destroyed only once.", "predict": " void\n*/\n\npublic class DestroyBean {\n\tpublic static void main(String[] args) {\n\t\tBeanData beanData = new BeanData();\n\t\tbeanData.setBeanName(\"beanName\");\n\t\tbeanData.setBeanClass(\"beanClass\");\n\t\tbeanData.setBeanClassName(\"beanClassName\");\n\t\tbeanData.setBeanClassPackage(\"beanClassPackage\");\n\t\tbeanData.setBeanClassPackageName(\"beanClassPackageName\");\n\t\tbeanData.setBeanClassPackagePath(\"beanClassPackagePath\");\n\t\tbeanData.setBeanClassPackagePathName(\"beanClassPackagePathName\");\n\t\tbeanData.setBeanClassPackagePaths(\"beanClassPackagePaths\");\n\t\tbeanData.setBeanClassPackagePathsName(\"beanClassPackagePathsName\");\n\t\tbeanData.setBeanClassPackagePathsNames(\"beanClassPackagePathsNames\");\n\t\tbeanData.setBeanClassPackagePath"}, {"ID": 1813, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void shutdown() { if (destroyableBeans == null) { return; } for (final BeanData destroyableBean : destroyableBeans) { destroyableBean.callDestroyMethods(); } destroyableBeans.clear(); } \nResponse:", "ground_truth": "Shutdowns the scope and calls all collected destroyable beans.", "predict": " @Override public void shutdown() { if (destroyableBeans == null) { return; } for (final BeanData destroyableBean : destroyableBeans) { destroyableBean.callDestroyMethods(); } destroyableBeans.clear(); } \n */\n\npublic class ShutdownBean {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(ShutdownBean.class);\n\t\n\tprivate static final String SHUTDOWN_METHOD_NAME = \"shutdown\";\n\t\n\tprivate static final String DESTROYABLE_BEANS_FIELD_NAME = \"destroyableBeans\";\n\t\n\tprivate static final String DESTROYABLE_BEANS_FIELD_DESCRIPTION = \"The list of destroyable beans.\";\n\t\n\tprivate static final String DESTROYABLE_BEAN_FIELD_NAME = \"destroyableBean\";\n\t\n\tprivate static final String DESTROYABLE_BEAN_FIELD_DESCRIPTION = \"The"}, {"ID": 1814, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ReceivedEmail[] get() { if (fromFolder != null) { session.useFolder(fromFolder); } return session.receiveMessages(filter, flagsToSet, flagsToUnset, envelopeOnly, messages -> { if (targetFolder != null) { try { session.folder.copyMessages(messages, session.getFolder(targetFolder)); } catch (MessagingException e) { throw new MailException(\"Copying messages failed\"); } } }); } \nResponse:", "ground_truth": "Receives the emails as specified by the builder.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.mail.Flags;\nimport javax.mail.Folder;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Store;\nimport javax.mail.search.FlagTerm;\nimport javax.mail.search.SearchTerm;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class ReceiveEmail {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString fromFolder = \"INBOX\";\n\t\tString targetFolder = \"INBOX\";\n\t\tString filter = \"\";\n\t\tString flagsToSet = \"\";\n\t\tString flagsToUnset = \"\";\n\t\tString envelopeOnly = \"\";\n\t\t\n\t\tif (args.length > 0) {"}, {"ID": 1815, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(final String[] args) { loadPropertiesFiles(args); try (ClusteredServiceContainer container = launch()) { container.context().shutdownSignalBarrier().await(); System.out.println(\"Shutdown ClusteredServiceContainer...\"); } } \nResponse:", "ground_truth": "Launch the clustered service container and await a shutdown signal.\n\n@param args command line argument which is a list for properties files as URLs or filenames.", "predict": "\n\n*/\n\nimport java.util.Properties;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport org.apache.kafka.common.utils.Time;\nimport org.apache.kafka.common.utils.Utils;\n\npublic class Consumer {"}, {"ID": 1816, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void run() { do { LockSupport.parkNanos(parkNs); final long currentTotalMessages = totalMessages; final long currentTotalBytes = totalBytes; final long currentTimestamp = System.nanoTime(); final long timeSpanNs = currentTimestamp - lastTimestamp; final double messagesPerSec = ((currentTotalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs; final double bytesPerSec = ((currentTotalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs; reportingFunc.onReport(messagesPerSec, bytesPerSec, currentTotalMessages, currentTotalBytes); lastTotalBytes = currentTotalBytes; lastTotalMessages = currentTotalMessages; lastTimestamp = currentTimestamp; } while (!halt); } \nResponse:", "ground_truth": "Run loop for the rate reporter", "predict": "\n\n*/\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.LockSupport;\n\npublic class JavaCode {\n    public static void main(String[] args) {\n        final long parkNs = TimeUnit.SECONDS.toNanos(1);\n        final long reportIntervalNs = TimeUnit.SECONDS.toNanos(1);\n        final long totalMessages = 10000000;\n        final long totalBytes = 10000000;\n        final long lastTimestamp = System.nanoTime();\n        final long timeSpanNs = System.nanoTime() - lastTimestamp;\n        final double messagesPerSec = ((totalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs;\n        final double bytesPerSec = ((totalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs;"}, {"ID": 1817, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); } \nResponse:", "ground_truth": "Generic error handler that just prints message to stdout.\n\n@param channel   for the error\n@param streamId  for the error\n@param sessionId for the error, if source\n@param message   indicating what the error was\n@param cause     of the error", "predict": " @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); } \n */\n\npublic class MethodCommentGenerator {\n    public static void main(String[] args) {\n        String className = \"org.agrona.MutableDirectBuffer\";\n        String methodName = \"printError\";\n        String methodComment = generateMethodComment(className, methodName);\n        System.out.println(methodComment);\n    }\n\n    public static String generateMethodComment(String className, String methodName) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"// Generated by \").append(className).append(\".\").append(methodName).append(\"\\n\");\n        sb.append(\"// DO NOT EDIT THIS FILE!\\n\");\n        sb.append(\"// Gener"}, {"ID": 1818, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); } \nResponse:", "ground_truth": "Print the rates to stdout\n\n@param messagesPerSec being reported\n@param bytesPerSec    being reported\n@param totalMessages  being reported\n@param totalBytes     being reported", "predict": "\n\npublic static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); } \n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] a = new int[n];\n        for(int a_i=0; a_i < n; a_i++){\n            a[a_i] = in.nextInt();\n        }\n        int[] b = new int[m"}, {"ID": 1819, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MappedByteBuffer mapExistingFileReadOnly(final File location) { if (!location.exists()) { final String msg = \"file not found: \" + location.getAbsolutePath(); throw new IllegalStateException(msg); } MappedByteBuffer mappedByteBuffer = null; try (RandomAccessFile file = new RandomAccessFile(location, \"r\"); FileChannel channel = file.getChannel()) { mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size()); } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } return mappedByteBuffer; } \nResponse:", "ground_truth": "Map an existing file as a read only buffer.\n\n@param location of file to map.\n@return the mapped file.", "predict": " public static MappedByteBuffer mapExistingFileReadOnly(final File location) { if (!location.exists()) { final String msg = \"file not found: \" + location.getAbsolutePath(); throw new IllegalStateException(msg); } MappedByteBuffer mappedByteBuffer = null; try (RandomAccessFile file = new RandomAccessFile(location, \"r\"); FileChannel channel = file.getChannel()) { mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size()); } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } return mappedByteBuffer; } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n"}, {"ID": 1820, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { final State state = this.state; if (State.CLOSED != state) { if (isReplayActive) { isReplayActive = false; archive.stopReplay(replaySessionId); } if (State.MERGED != state) { subscription.removeDestination(replayDestination); } state(State.CLOSED); } } \nResponse:", "ground_truth": "Close the merge and stop any active replay. Will remove the replay destination from the subscription. Will\nNOT remove the live destination if it has been added.", "predict": "\n\n*/\n\npublic class ReplayDestination {\n    private final String name;\n    private final String subscriptionName;\n    private final String replayDestinationName;\n    private final String replayDestinationType;\n    private final String replayDestinationStatus;\n    private final String replayDestinationStatusDetails;\n    private final String replayDestinationStatusDescription;\n    private final String replayDestinationStatusDescriptionDetails;\n    private final String replayDestinationStatusDescriptionLink;\n    private final String replayDestinationStatusDescriptionLinkDetails;\n    private final String replayDestinationStatusDescriptionLinkTarget;\n    private final String replayDestinationStatusDescriptionLinkTargetDetails;\n    private final String replayDestinationStatusDescriptionLinkTargetType;\n    private final String replayDestinationStatusDescriptionLinkTargetTypeDetails;\n    private final String replayDestinationStatusDescriptionLinkTargetTypeDescription;\n    private final String replayDestinationStatusDescriptionLinkTargetTypeDescriptionDetails;\n    private final String replayDestinationStatusDescriptionLinkTargetTypeDescription"}, {"ID": 1821, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int doWork() { int workCount = 0; switch (state) { case AWAIT_INITIAL_RECORDING_POSITION: workCount += awaitInitialRecordingPosition(); break; case AWAIT_REPLAY: workCount += awaitReplay(); break; case AWAIT_CATCH_UP: workCount += awaitCatchUp(); break; case AWAIT_CURRENT_RECORDING_POSITION: workCount += awaitUpdatedRecordingPosition(); break; case AWAIT_STOP_REPLAY: workCount += awaitStopReplay(); break; } return workCount; } \nResponse:", "ground_truth": "Process the operation of the merge. Do not call the processing of fragments on the subscription.\n\n@return indication of work done processing the merge.", "predict": " public int doWork() { int workCount = 0; switch (state) { case AWAIT_INITIAL_RECORDING_POSITION: workCount += awaitInitialRecordingPosition(); break; case AWAIT_REPLAY: workCount += awaitReplay(); break; case AWAIT_CATCH_UP: workCount += awaitCatchUp(); break; case AWAIT_CURRENT_RECORDING_POSITION: workCount += awaitUpdatedRecordingPosition(); break; case AWAIT_STOP_REPLAY: workCount += awaitStopReplay(); break; } return workCount; } \n\n*/\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new instance of the class and call the doWork method.\n\t\t// TODO: Call the doWork method and print the result.\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t"}, {"ID": 1822, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long position() { if (isClosed) { return CLOSED; } final long rawTail = rawTailVolatile(logMetaDataBuffer); final int termOffset = termOffset(rawTail, termBufferLength); return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId); } \nResponse:", "ground_truth": "Get the current position to which the publication has advanced for this stream.\n\n@return the current position to which the publication has advanced for this stream or {@link #CLOSED}.", "predict": " public long position() { return position; }\n\n*/\n\npublic class LogMetaData {\n    public static final int LOG_META_DATA_LENGTH = 8;\n    public static final int LOG_META_DATA_TERM_ID_SHIFT = 0;\n    public static final int LOG_META_DATA_TERM_ID_MASK = 0xFFFFFFFF;\n    public static final int LOG_META_DATA_TERM_OFFSET_SHIFT = 4;\n    public static final int LOG_META_DATA_TERM_OFFSET_MASK = 0xFFFFFFFF << LOG_META_DATA_TERM_OFFSET_SHIFT;\n    public static final int LOG_META_DATA_POSITION_SHIFT = 8;\n    public static final int LOG_META_DATA_POSITION_MASK = 0xFFFFFFFF << LOG_META_DATA_POSITION_SHIFT;\n    public static"}, {"ID": 1823, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) { final int length = DirectBufferVector.validateAndComputeLength(vectors); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { final int result; if (length <= maxPayloadLength) { result = termAppender.appendUnfragmentedMessage( termId, termOffset, headerWriter, vectors, length, reservedValueSupplier); } else { checkMaxMessageLength(length); result = termAppender.appendFragmentedMessage( termId, termOffset, headerWriter, vectors, length, maxPayloadLength, reservedValueSupplier); } newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; } \nResponse:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message.\n\n@param vectors               which make up the message.\n@param reservedValueSupplier {@link ReservedValueSupplier} for the frame.\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.", "predict": " public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) { return offer(vectors, reservedValueSupplier); } \n\n}\n"}, {"ID": 1824, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long appendPadding(final int length) { checkMaxMessageLength(length); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { checkPositiveLength(length); final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length); newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; } \nResponse:", "ground_truth": "Append a padding record log of a given length to make up the log to a position.\n\n@param length of the range to claim, in bytes..\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.\n@throws IllegalArgumentException if the length is greater than {@link #maxMessageLength()}.", "predict": " public long appendPadding(final int length) { checkMaxMessageLength(length); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { checkPositiveLength(length); final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length); newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; } \nResp public long appendPadding(final int length, final long newPosition) { checkMaxMessageLength(length); if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position"}, {"ID": 1825, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { lock.lock(); try { if (!isClosed) { isClosed = true; archiveProxy.closeSession(controlSessionId); if (!context.ownsAeronClient()) { CloseHelper.close(controlResponsePoller.subscription()); CloseHelper.close(archiveProxy.publication()); } context.close(); } } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Notify the archive that this control session is closed so it can promptly release resources then close the\nlocal resources associated with the client.", "predict": "\n\n*/\n\npackage com.betfair.baseline.v2;\n\nimport com.betfair.baseline.v2.enumerations.CloseReason;\nimport com.betfair.baseline.v2.enumerations.SessionType;\nimport com.betfair.baseline.v2.to.SessionCloseRequest;\nimport com.betfair.baseline.v2.to.SessionCloseResponse;\nimport com.betfair.baseline.v2.to.SessionOpenRequest;\nimport com.betfair.baseline.v2.to.SessionOpenResponse;\nimport com.betfair.baseline.v2.to.SessionStatus;\nimport com.betfair.baseline.v2.to.SessionStatusResponse;\nimport com.betfair.baseline.v2.to.SessionStatusUpdateRequest;\nimport com.betfair.baseline.v2.to.SessionStatusUpdateResponse;\nimport com.bet"}, {"ID": 1826, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String pollForErrorResponse() { lock.lock(); try { ensureOpen(); if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) { if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) { return controlResponsePoller.errorMessage(); } } return null; } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Poll the response stream once for an error. If another message is present then it will be skipped over\nso only call when not expecting another response.\n\n@return the error String otherwise null if no error is found.", "predict": " public String pollForResponse() { lock.lock(); try { ensureOpen(); if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) { if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.RESPONSE) { return controlResponsePoller.responseMessage(); } } return null; } finally { lock.unlock(); } } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ControlSession {\n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private final ControlResponsePoller controlResponsePoller;\n    private final long"}, {"ID": 1827, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stopReplay(final long replaySessionId) { lock.lock(); try { ensureOpen(); final long correlationId = aeron.nextCorrelationId(); if (!archiveProxy.stopReplay(replaySessionId, correlationId, controlSessionId)) { throw new ArchiveException(\"failed to send stop replay request\"); } pollForResponse(correlationId); } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Stop a replay session.\n\n@param replaySessionId to stop replay for.", "predict": " public void stopReplay(final long replaySessionId) { stopReplay(replaySessionId, 0); } \n\n*/\n\n/*\n * Copyright 2012-2015 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client."}, {"ID": 1828, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void eventAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"new image on %s streamId %x sessionId %x from %s%n\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity()); } \nResponse:", "ground_truth": "Print the information for an available image to stdout.\n\n@param image that has been created", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons.lang3.tuple.TripleG;\nimport org."}, {"ID": 1829, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void eventUnavailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"inactive image on %s streamId %d sessionId %x%n\", subscription.channel(), subscription.streamId(), image.sessionId()); } \nResponse:", "ground_truth": "This handler is called when image is unavailable\n\n@param image that has gone inactive", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.log4j.Logger;\n\nimport com.hazelcast.client.HazelcastClient;\nimport com.hazelcast.client.config.ClientConfig;\nimport com.hazelcast.client.config.ClientNetworkConfig;\nimport com.hazelcast.client.config.XmlClientConfigBuilder;\nimport com.hazelcast.client.impl.HazelcastClientProxy;\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.ClientGetPartitionsCodec;\nimport com.hazelcast.client.impl.protocol.codec.ClientGetPartitionsCodec.RequestParameters;\nimport com.hazel"}, {"ID": 1830, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == SendChannelStatus.SEND_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; } \nResponse:", "ground_truth": "Return the read-only status indicator for the given send channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the send channel.\n@return read-only status indicator that can be used to query the status of the send channel or null\n@see ChannelEndpointStatus for status values and indications.", "predict": " public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) { return sendChannelStatus(countersReader, channel); }\n\n*/\n"}, {"ID": 1831, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StatusIndicatorReader receiveChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; } \nResponse:", "ground_truth": "Return the read-only status indicator for the given receive channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the receive channel.\n@return read-only status indicator that can be used to query the status of the receive channel or null.\n@see ChannelEndpointStatus for status values and indications.", "predict": " public static void sendChannelStatus(final CountersReader countersReader, final String channel, final StatusIndicator statusIndicator) { final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { countersReader.setCounterValue(id.value, statusIndicator.statusIndicatorBuffer()); } } \n */\npublic class UnsafeBufferStatusIndicator extends UnsafeBuffer\n{\n    public UnsafeBufferStatusIndicator(final UnsafeBuffer buffer, final int counterId)\n    {\n        super(buffer, counterId);\n    "}, {"ID": 1832, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void limit(final int limit) { if (limit < 0 || limit >= buffer.capacity()) { throw new IllegalArgumentException( \"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit); } this.limit = limit; } \nResponse:", "ground_truth": "Set this limit for this buffer as the position at which the next append operation will occur.\n\n@param limit to be the new value.", "predict": " public void limit(final int limit) { if (limit < 0 || limit >= buffer.capacity()) { throw new IllegalArgumentException( \"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit); } this.limit = limit; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n    \n    public void test() {\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9,10};\n        int limit = 3;\n        \n        System.out.println(\"Input:\\n\" + Arrays.toString(nums) + \"\\n\" + \"Output:\\n\" + Arrays.toString(s.limit(limit, nums)));\n    }\n    \n    public int[] limit(int limit, int[] nums) {\n        "}, {"ID": 1833, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; } \nResponse:", "ground_truth": "Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage.", "predict": " Resp public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; } \nResp Resp public BufferBuilder append(final ByteBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; } \nResp Resp public BufferBuilder append(final byte[] src, final int offset, final int length) { ensureCapacity(length); buffer.putBytes(limit, src, offset, length); limit += length; return this; } \nResp Resp public BufferBuilder append(final ByteBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; }"}, {"ID": 1834, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int poll() { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = null; pollComplete = false; return subscription.controlledPoll(fragmentAssembler, fragmentLimit); } \nResponse:", "ground_truth": "Poll for control response events.\n\n@return the number of fragments read during the operation. Zero if no events are available.", "predict": " public void onResponse(int responseCode, String responseMessage) { if (responseCode == ResponseCode.OK) { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = null; pollComplete = false; } } \nResp public void onError(Exception exception) { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = exception.getMessage(); pollComplete = true; } \n\n*/\n\npublic class PollControl {\n\t\n\tprivate static final Logger logger = Logger.getLogger(PollControl.class);\n\t\n\tprivate static final String METHOD_NAME = \"poll\";\n\t\n\tprivate static final String SUBSCRIPTION_NAME = \"subscription\";\n\t\n\tprivate static final String FRAGMENT_NAME = \"fragment\";\n\t\n\tprivate static final String FRAGMENT_LIMIT"}, {"ID": 1835, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MappedByteBuffer mapLossReport(final String aeronDirectoryName, final int reportFileLength) { return mapNewFile(file(aeronDirectoryName), reportFileLength, false); } \nResponse:", "ground_truth": "Map a new loss report in the Aeron directory for a given length.\n\n@param aeronDirectoryName in which to create the file.\n@param reportFileLength   for the file.\n@return the newly mapped buffer for the file.", "predict": " Resp public static MappedByteBuffer mapNewFile(final File file, final int reportFileLength, final boolean isReadOnly) { return mapNewFile(file, reportFileLength, isReadOnly, null); } \nResp Resp public static MappedByteBuffer mapNewFile(final File file, final int reportFileLength, final boolean isReadOnly, final String fileName) { return mapNewFile(file, reportFileLength, isReadOnly, fileName, null); } \nResp Resp public static MappedByteBuffer mapNewFile(final File file, final int reportFileLength, final boolean isReadOnly, final String fileName, final String fileExtension) { return mapNewFile(file, reportFileLength, isReadOnly, fileName, fileExtension, null); } \nResp Resp public static MappedByteBuffer mapNewFile(final File file, final int reportFileLength, final boolean isReadOnly, final String fileName, final String fileExt"}, {"ID": 1836, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<StreamCompositeKey, List<StreamPosition>> snapshot() { final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamPosition position = new StreamPosition( keyBuffer.getLong(REGISTRATION_ID_OFFSET), counters.getCounterValue(counterId), typeId); streams .computeIfAbsent(key, (ignore) -> new ArrayList<>()) .add(position); } }); return streams; } \nResponse:", "ground_truth": "Take a snapshot of all the counters and group them by streams.\n\n@return a snapshot of all the counters and group them by streams.", "predict": "\n\n*/\n\npackage com.persistent.bcsuite.distributormanager.message;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.persistent.bcsuite.distributormanager.common.Constant;\nimport com.persistent.bcsuite.distributormanager.common.Utils;\n\npublic class SnapshotRequest extends Request {\n\n\tprivate static final int SESSION_ID_OFFSET = 0;\n\tprivate static final int STREAM_ID_OFFSET = 4;\n\tprivate static final int CHANNEL_OFFSET = 8;\n\tprivate static final int REGISTRATION_ID_OFFSET = 12;\n\tprivate static final int COUNTER_ID_OFFSET = 16;\n\tprivate static final int TYPE_ID_OFFSET = 20;\n\tprivate static final int SENDER_LIMIT_OFFSET ="}, {"ID": 1837, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) { final UnsafeBuffer buffer = new UnsafeBuffer( BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH)); buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION); buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS); buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN); buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN); buffer.putInt(STREAM_ID_FIELD_OFFSET, streamId, LITTLE_ENDIAN); buffer.putInt(TERM_ID_FIELD_OFFSET, termId, LITTLE_ENDIAN); buffer.putLong(RESERVED_VALUE_OFFSET, DEFAULT_RESERVE_VALUE); return buffer; } \nResponse:", "ground_truth": "Return an initialised default Data Frame Header.\n\n@param sessionId for the header\n@param streamId  for the header\n@param termId    for the header\n@return byte array containing the header", "predict": " public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) { final UnsafeBuffer buffer = new UnsafeBuffer( BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH)); buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION); buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS); buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN); buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN); buffer.putInt(STREAM_ID_FIELD_OFFSET, streamId, LITTLE_ENDIAN); buffer.putInt(TERM_ID_FIELD_OFFSET, termId, LITTLE_ENDIAN); buffer.putLong(RESERV"}, {"ID": 1838, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) { buffer.putInt(KEY_LENGTH_OFFSET, keyLength); if (null != keyBuffer && keyLength > 0) { buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength); } return this; } \nResponse:", "ground_truth": "Fill the key buffer.\n\n@param keyBuffer containing the optional key for the counter.\n@param keyOffset within the keyBuffer at which the key begins.\n@param keyLength of the key in the keyBuffer.\n@return flyweight", "predict": " public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) { return keyBuffer(keyBuffer, keyOffset, keyLength, this); } \n\npublic static CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength, final CounterMessageFlyweight instance) { instance.buffer.putInt(KEY_LENGTH_OFFSET, keyLength); if (null != keyBuffer && keyLength > 0) { instance.buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength); } return instance; } \n\npublic static int keyBufferOffset() { return Integer.BYTES; } \n\npublic static int keyLengthOffset() { return Integer.BYTES + Integer.BYTES; } \n\npublic static int keyLength(final CounterMessageFlyweight instance) { return instance.buffer.getInt(KEY_LENGTH_OFFSET); } \n\npublic static"}, {"ID": 1839, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CounterMessageFlyweight labelBuffer( final DirectBuffer labelBuffer, final int labelOffset, final int labelLength) { buffer.putInt(labelOffset(), labelLength); buffer.putBytes(labelBufferOffset(), labelBuffer, labelOffset, labelLength); return this; } \nResponse:", "ground_truth": "Fill the label buffer.\n\n@param labelBuffer containing the mandatory label for the counter.\n@param labelOffset within the labelBuffer at which the label begins.\n@param labelLength of the label in the labelBuffer.\n@return flyweight", "predict": " public CounterMessageFlyweight responseBuffer( final DirectBuffer responseBuffer, final int responseOffset, final int responseLength) { buffer.putInt(responseOffset(), responseLength); buffer.putBytes(responseBufferOffset(), responseBuffer, responseOffset, responseLength); return this; } \nResp public CounterMessageFlyweight responseBuffer( final byte[] responseBuffer, final int responseOffset, final int responseLength) { buffer.putInt(responseOffset(), responseLength); buffer.putBytes(responseBufferOffset(), responseBuffer, responseOffset, responseLength); return this; } \nResp public CounterMessageFlyweight responseBuffer( final ByteBuffer responseBuffer, final int responseOffset, final int responseLength) { buffer.putInt(responseOffset(), responseLength); buffer.put(responseBuffer, responseOffset, responseLength); return this; } \nResp public CounterMessageFlyweight responseBuffer( final byte response) { buffer.putInt(responseOffset(), response); return this; } \nResp public CounterMessageFly"}, {"ID": 1840, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); return offerWithTimeout(connectRequestEncoder.encodedLength(), null); } \nResponse:", "ground_truth": "Connect to an archive on its control interface providing the response stream details.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestDecoder.wrap(buffer, connectRequestOffset, messageHeaderDecoder.blockLength(), messageHeaderDecoder.version()); connectRequestDecoder.wrapAndApplyHeader(buffer, connectRequestOffset + MessageHeaderDecoder.ENCODED_LENGTH, connectRequestDecoder.blockLength(), connectRequestDecoder.version(), responseChannel, responseStreamId, correlationId); return offerWithTimeout(connectRequestDecoder.encodedLength(), null); } \n\n*/\n"}, {"ID": 1841, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength(); return publication.offer(buffer, 0, length) > 0; } \nResponse:", "ground_truth": "Try Connect to an archive on its control interface providing the response stream details. Only one attempt will\nbe made to offer the request.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength(); return publication.offer(buffer, 0, length) > 0; } \n */\n\npublic class ArchiveClient\n{\n    public static void main(final String[] args) throws Exception\n    {\n        final AeronArchive.Context ctx = new AeronArchive.Context()\n            .archiveDirName(args[0])\n            .controlRequestChannel(\"aeron:udp?endpoint=localhost:54325\")\n            .controlResponseChannel(\"aeron:ud"}, {"ID": 1842, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean closeSession(final long controlSessionId) { closeSessionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId); return offer(closeSessionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Close this control session with the archive.\n\n@param controlSessionId with the archive.\n@return true if successfully offered otherwise false.", "predict": " CloseSessionResponseDecoder.wrap(buffer, messageHeaderDecoder.blockLength(), messageHeaderDecoder.version());\n\n*/\n\npackage com.betfair.tornjak.monitor.activemq;\n\nimport org.apache.activemq.command.ActiveMQMessage;\nimport org.apache.activemq.command.Message;\nimport org.apache.activemq.command.MessageDispatch;\nimport org.apache.activemq.command.ProducerInfo;\nimport org.apache.activemq.command.Response;\nimport org.apache.activemq.command.SessionInfo;\nimport org.apache.activemq.command.TransactionInfo;\nimport org.apache.activemq.openwire.OpenWireFormat;\nimport org.apache.activemq.openwire.OpenWireFormatFactory;\nimport org.apache.activemq.openwire.commands.ConnectionId;\nimport org.apache.activemq."}, {"ID": 1843, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean startRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long correlationId, final long controlSessionId) { startRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(startRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Start recording streams for a given channel and stream id pairing.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " startRecordingResponseDecoder.wrap(buffer, startRecordingResponseDecoder.sbeBlockLength(), startRecordingResponseDecoder.sbeSchemaVersion());\n}\n}\n"}, {"ID": 1844, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean stopRecording( final String channel, final int streamId, final long correlationId, final long controlSessionId) { stopRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .channel(channel); return offer(stopRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Stop an active recording.\n\n@param channel          to be stopped.\n@param streamId         to be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " stopRecordingResponseDecoder.wrap(buffer, stopRecordingResponseDecoder.sbeBlockLength(), stopRecordingResponseDecoder.sbeSchemaVersion(), offset);\n}\n}\n"}, {"ID": 1845, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean replay( final long recordingId, final long position, final long length, final String replayChannel, final int replayStreamId, final long correlationId, final long controlSessionId) { replayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .position(position) .length(length) .replayStreamId(replayStreamId) .replayChannel(replayChannel); return offer(replayRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Replay a recording from a given position.\n\n@param recordingId      to be replayed.\n@param position         from which the replay should be started.\n@param length           of the stream to be replayed. Use {@link Long#MAX_VALUE} to follow a live stream.\n@param replayChannel    to which the replay should be sent.\n@param replayStreamId   to which the replay should be sent.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " ReplayResponseDecoder.wrap(buffer, replayRequestDecoder.decode(buffer));\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.agrona.concurrent.UnsafeBuffer;\nimport org.agrona.concurrent.ringbuffer.ManyToOneRingBuffer;\nimport org.agrona.concurrent.ringbuffer.RingBuffer;\nimport org.agrona.concurrent.ringbuffer.RingBufferDescriptor;\nimport org.agrona.concurrent.ringbuffer.RingBufferFactory;\nimport org.agrona.concurrent.ringbuffer.RingBufferIndex;\nimport org.agrona.concurrent.ringbuffer.RingBufferIndexType;\nimport org.agrona.concurrent.ringbuffer.RingBufferOffer;\nimport org.agrona.concurrent.ringbuffer.RingBufferPeek;\n"}, {"ID": 1846, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) { stopReplayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .replaySessionId(replaySessionId); return offer(replayRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Stop an existing replay session.\n\n@param replaySessionId  that should be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) { return ResponseHelper.getResponse(this, stopReplayRequestDecoder.decode(buffer)); } \n\n}\n"}, {"ID": 1847, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId) { listRecordingsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount); return offer(listRecordingsRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a range of recording descriptors.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId, final long[] recordingIds) { listRecordingsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount); recordingIdsEncoder.wrap(buffer, messageHeaderEncoder.encodedLength(), recordingIds.length); for (int i = 0; i < recordingIds.length; i++) { recordingIdsEncoder.putLong(recordingIds[i]); } return offer(listRecordingsRequestEncoder.encodedLength() + recordingIdsEncoder.encodedLength()); } \nResp public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId, final long[]"}, {"ID": 1848, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordingsForUri( final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) { listRecordingsForUriRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount) .streamId(streamId) .channel(channelFragment); return offer(listRecordingsForUriRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a range of recording descriptors which match a channel URI fragment and stream id.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param channelFragment  to match recordings on from the original channel URI in the archive descriptor.\n@param streamId         to match recordings on.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean listRecordingsForUri( final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) { return Response.ok(listRecordingsForUriResponseDecoder.wrap(buffer, messageHeaderDecoder.blockLength())); } \n\n}\n"}, {"ID": 1849, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) { listRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(listRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a recording descriptor for a given recording id.\n\n@param recordingId      at which to begin listing.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) { return Response.parse(buffer, messageHeaderDecoder, listRecordingResponseDecoder); } \n\n*/\n"}, {"ID": 1850, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean extendRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long recordingId, final long correlationId, final long controlSessionId) { extendRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(extendRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Extend an existing, non-active, recorded stream for a the same channel and stream id.\n\nThe channel must be configured for the initial position from which it will be extended. This can be done\nwith {@link ChannelUriStringBuilder#initialPosition(long, int, int)}. The details required to initialise can\nbe found by calling {@link #listRecording(long, long, long)}.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param recordingId      to be extended.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " extendRecordingResponseDecoder.wrap(buffer, messageHeaderDecoder.blockLength(), messageHeaderDecoder.version());\n\n*/\n\npublic class ExtendRecordingRequestDecoder extends RequestDecoder<ExtendRecordingRequest> {\n\n    public static final int REQUEST_MESSAGE_TYPE = 2;\n    private static final int REQUEST_SOURCE_LOCATION_FIELD_OFFSET = REQUEST_MESSAGE_TYPE_FIELD_OFFSET + INT_SIZE_IN_BYTES;\n    private static final int REQUEST_RECORDING_ID_FIELD_OFFSET = REQUEST_SOURCE_LOCATION_FIELD_OFFSET + LONG_SIZE_IN_BYTES;\n    private static final int REQUEST_CORRELATION_ID_FIELD_OFFSET = REQUEST_RECORDING_ID_FIELD_OFFSET + LONG_SIZE_IN_BYTES;\n    private static final int REQUEST_CONTROL_SESSION_"}, {"ID": 1851, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) { recordingPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(recordingPositionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Get the recorded position of an active recording.\n\n@param recordingId      of the active recording that the position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) { return ResponseDecoder.wrap(buffer, 0, messageHeaderDecoder, recordingPositionResponseDecoder).controlSessionId(controlSessionId).correlationId(correlationId).recordingId(recordingId); } \n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.Collections;\nimport java.util.BitSet;\nimport java.nio.ByteBuffer;\n\npublic class RecordingPositionRequestDecoder extends Demultiplexer<RecordingPositionRequestDecoder.Event, RecordingPositionRequestDecoder.State> {\n\n    private static final byte RECORDING_POSITION_REQUEST = 0x0;\n    private static"}, {"ID": 1852, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) { stopPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(stopPositionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Get the stop position of a recording.\n\n@param recordingId      of the recording that the stop position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) { return ResponseHelper.getResponse(this, \"getStopPosition\", getStopPositionDelegate(correlationId, controlSessionId)); } \n*/\n\n/*\n *  Generated code\n */\n\n}\n\n"}, {"ID": 1853, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordingSubscriptions( final int pseudoIndex, final int subscriptionCount, final String channelFragment, final int streamId, final boolean applyStreamId, final long correlationId, final long controlSessionId) { listRecordingSubscriptionsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .pseudoIndex(pseudoIndex) .subscriptionCount(subscriptionCount) .applyStreamId(applyStreamId ? BooleanType.TRUE : BooleanType.FALSE) .streamId(streamId) .channel(channelFragment); return offer(listRecordingSubscriptionsRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List registered subscriptions in the archive which have been used to record streams.\n\n@param pseudoIndex       in the list of active recording subscriptions.\n@param subscriptionCount for the number of descriptors to be listed.\n@param channelFragment   for a contains match on the stripped channel used with the registered subscription.\n@param streamId          for the subscription.\n@param applyStreamId     when matching.\n@param correlationId     for this request.\n@param controlSessionId  for this request.\n@return true if successfully offered otherwise false.", "predict": "\n    public static int decode(byte[] buffer, int offset, int length) {\n        return decode(new Buffer(buffer, offset, length));\n    }\n    public static int decode(byte[] buffer) {\n        return decode(new Buffer(buffer, 0, buffer.length));\n    }\n    public static int decode(Buffer buffer) {\n        return decode(buffer, 0, buffer.length());\n    }\n    public static int decode(Buffer buffer, int offset, int length) {\n        return decode(new Buffer(buffer, offset, length));\n    }\n    public static int decode(Buffer buffer, int offset) {\n        return decode(new Buffer(buffer, offset, buffer.length() - offset));\n    }\n    public static int decode(Buffer buffer, int offset, int length, int maxPayloadLength) {\n        return decode(new Buffer(buffer, offset, length), maxPayloadLength);\n    }\n    public static int decode(Buffer"}, {"ID": 1854, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matchesTag(final UdpChannel udpChannel) { if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) { return false; } if (udpChannel.remoteData().getAddress().isAnyLocalAddress() && udpChannel.remoteData().getPort() == 0 && udpChannel.localData().getAddress().isAnyLocalAddress() && udpChannel.localData().getPort() == 0) { return true; } throw new IllegalArgumentException(\"matching tag has set endpoint or control address\"); } \nResponse:", "ground_truth": "Does this channel have a tag match to another channel including endpoints.\n\n@param udpChannel to match against.\n@return true if there is a match otherwise false.", "predict": " public boolean matchesTag(final UdpChannel udpChannel) { if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) { return false; } if (udpChannel.remoteData().getAddress().isAnyLocalAddress() && udpChannel.remoteData().getPort() == 0 && udpChannel.localData().getAddress().isAnyLocalAddress() && udpChannel.localData().getPort() == 0) { return true; } throw new IllegalArgumentException(\"matching tag has set endpoint or control address\"); } \n\n*/\n\npublic class UdpChannelMatcher extends AbstractMatcher {\n\n    private final UdpChannel udpChannel;\n\n    public UdpChannelMatcher(UdpChannel udpChannel) {\n        this.udpChannel = udpChannel;\n    }\n\n    @Override\n    public boolean matches(Object obj) {\n        if (obj instanceof UdpChannel) {\n            UdpChannel"}, {"ID": 1855, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InetSocketAddress destinationAddress(final ChannelUri uri) { try { validateConfiguration(uri); return getEndpointAddress(uri); } catch (final Exception ex) { throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex); } } \nResponse:", "ground_truth": "Get the endpoint address from the URI.\n\n@param uri to check\n@return endpoint address for URI", "predict": " public static InetSocketAddress destinationAddress(final ChannelUri uri) { try { validateConfiguration(uri); return getEndpointAddress(uri); } catch (final Exception ex) { throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex); } } \n\n*/\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\nimport io.netty.channel.ChannelUri;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEvent"}, {"ID": 1856, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String description() { final StringBuilder builder = new StringBuilder(\"UdpChannel - \"); if (null != localInterface) { builder .append(\"interface: \") .append(localInterface.getDisplayName()) .append(\", \"); } builder .append(\"localData: \").append(localData) .append(\", remoteData: \").append(remoteData) .append(\", ttl: \").append(multicastTtl); return builder.toString(); } \nResponse:", "ground_truth": "Used for debugging to get a human readable description of the channel.\n\n@return a human readable description of the channel.", "predict": " Response to the request.\n\n*/\n\npublic class UdpChannel extends Channel {\n    private static final Logger logger = LoggerFactory.getLogger(UdpChannel.class);\n    private static final String UDP_CHANNEL_NAME = \"UdpChannel\";\n    private static final String UDP_CHANNEL_DESCRIPTION = \"UdpChannel - interface: \";\n    private static final String UDP_CHANNEL_DESCRIPTION_END = \"localData: \";\n    private static final String UDP_CHANNEL_DESCRIPTION_END_END = \"remoteData: \";\n    private static final String UDP_CHANNEL_DESCRIPTION_END_END_END = \"ttl: \";\n    private static final String UDP_CHANNEL_DESCRIPTION_END_END_END_END = \"multicastTtl\";\n    private static final String UDP_CHANNEL_DESCRIPTION_END_END_END_END_END = \"description"}, {"ID": 1857, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) { imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1); if (transport.isMulticast()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl()); } else if (transport.hasExplicitControl()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.explicitControlAddress()); } } \nResponse:", "ground_truth": "Add a destination to this image so it can merge streams.\n\n@param transportIndex from which packets will arrive.\n@param transport      from which packets will arrive.", "predict": " void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) { imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1); if (transport.isMulticast()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl()); } else if (transport.hasExplicitControl()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.explicitControlAddress()); } } \n */\n\npublic class ImageConnection {\n    private final long creationTime;\n    private final InetSocketAddress address;\n    private final boolean isMulticast;\n    private final boolean hasExplicitControl;\n\n    public ImageConnection(final long creationTime, final InetSocketAddress address) {\n        this.creationTime = creationTime;\n        this.address = address;\n"}, {"ID": 1858, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int insertPacket( final int termId, final int termOffset, final UnsafeBuffer buffer, final int length, final int transportIndex, final InetSocketAddress srcAddress) { final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length); final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId); final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length; if (!isFlowControlUnderRun(packetPosition) && !isFlowControlOverRun(proposedPosition)) { trackConnection(transportIndex, srcAddress, lastPacketTimestampNs); if (isHeartbeat) { if (DataHeaderFlyweight.isEndOfStream(buffer) && !isEndOfStream && allEos(transportIndex)) { LogBufferDescriptor.endOfStreamPosition(rawLog.metaData(), proposedPosition); isEndOfStream = true; } heartbeatsReceived.incrementOrdered(); } else { final UnsafeBuffer termBuffer = termBuffers[indexByPosition(packetPosition, positionBitsToShift)]; TermRebuilder.insert(termBuffer, termOffset, buffer, length); } lastPacketTimestampNs = cachedNanoClock.nanoTime(); hwmPosition.proposeMaxOrdered(proposedPosition); } return length; } \nResponse:", "ground_truth": "Insert frame into term buffer.\n\n@param termId         for the data packet to insert into the appropriate term.\n@param termOffset     for the start of the packet in the term.\n@param buffer         for the data packet to insert into the appropriate term.\n@param length         of the data packet\n@param transportIndex which the packet came from.\n@param srcAddress     which the packet came from.\n@return number of bytes applied as a result of this insertion.", "predict": " int send(final int transportIndex, final InetSocketAddress srcAddress, final int termId, final int termOffset, final int length, final int transportIndex2, final InetSocketAddress srcAddress2) { final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length); final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId); final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length; if (!isFlowControlUnderRun(packetPosition) && !isFlowControlOverRun(proposedPosition)) { trackConnection(transportIndex, srcAddress, lastPacketTimestampNs); if (isHeartbeat) { if (DataHeaderFlyweight.isEndOfStream(buffer) && !isEndOfStream && allEos(transportIndex)) { LogBufferDescriptor.endOfStreamPosition(rawLog.metaData(), proposedPosition); isEndOfStream = true; } heartbeats"}, {"ID": 1859, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter findControlToggle(final CountersReader counters) { final AtomicBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { final int recordOffset = CountersReader.metaDataOffset(i); if (counters.getCounterState(i) == RECORD_ALLOCATED && buffer.getInt(recordOffset + TYPE_ID_OFFSET) == CONTROL_TOGGLE_TYPE_ID) { return new AtomicCounter(counters.valuesBuffer(), i, null); } } return null; } \nResponse:", "ground_truth": "Find the control toggle counter or return null if not found.\n\n@param counters to search for the control toggle.\n@return the control toggle counter or return null if not found.", "predict": "\n\n*/\n\npublic class AtomicCounter {\n    private final AtomicBuffer buffer;\n    private final int counterId;\n    private final String name;\n\n    public AtomicCounter(AtomicBuffer buffer, int counterId, String name) {\n        this.buffer = buffer;\n        this.counterId = counterId;\n        this.name = name;\n    }\n\n    public AtomicBuffer buffer() {\n        return buffer;\n    }\n\n    public int counterId() {\n        return counterId;\n    }\n\n    public String name() {\n        return name;\n    }\n}\n"}, {"ID": 1860, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String put(final String key, final String value) { return params.put(key, value); } \nResponse:", "ground_truth": "Put a key and value pair in the map of params.\n\n@param key   of the param to be put.\n@param value of the param to be put.\n@return the existing value otherwise null.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1861, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; } \nResponse:", "ground_truth": "Get the channel tag, if it exists, that refers to an another channel.\n\n@return channel tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Resp public String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; } \n\n// Generated code\n\npublic String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; } \n\n}\n"}, {"ID": 1862, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String entityTag() { return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null; } \nResponse:", "ground_truth": "Get the entity tag, if it exists, that refers to an entity such as subscription or publication.\n\n@return entity tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1863, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String addSessionId(final String channel, final int sessionId) { final ChannelUri channelUri = ChannelUri.parse(channel); channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId)); return channelUri.toString(); } \nResponse:", "ground_truth": "Add a sessionId to a given channel.\n\n@param channel   to add sessionId to.\n@param sessionId to add to channel.\n@return new string that represents channel with sessionId added.", "predict": " public static String addSessionId(final String channel, final int sessionId) { final ChannelUri channelUri = ChannelUri.parse(channel); channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId)); return channelUri.toString(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\n\npublic class ChannelUri {\n\tprivate static final Logger logger = Logger.getLogger(ChannelUri.class);\n\t\n\tprivate static final String CHANNEL_URI_P"}, {"ID": 1864, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getTag(final String paramValue) { return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG; } \nResponse:", "ground_truth": "Get the value of the tag from a given parameter value.\n\n@param paramValue to extract the tag value from.\n@return the value of the tag or {@link #INVALID_TAG} if not tagged.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Response is generated as follows. Code: public static long getTag(final String paramValue) { return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG; } \n\n*/\n\npublic class Solution {\n    public static long getTag(String paramValue) {\n        if (paramValue.length() < 4) {\n            return INVALID_TAG;\n        }\n        long tag = 0;\n        for (int i = 0; i < paramValue.length() - 4; i++) {\n            tag = tag << 8;\n            tag += paramValue.charAt(i);\n        }\n        return tag;\n    }\n}\n"}, {"ID": 1865, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int appendPadding( final int termId, final int termOffset, final HeaderWriter header, final int length) { final int frameLength = length + HEADER_LENGTH; final int alignedLength = align(frameLength, FRAME_ALIGNMENT); final UnsafeBuffer termBuffer = this.termBuffer; final int termLength = termBuffer.capacity(); int resultingOffset = termOffset + alignedLength; putRawTailOrdered(termId, resultingOffset); if (resultingOffset > termLength) { resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId); } else { header.write(termBuffer, termOffset, frameLength, termId); frameType(termBuffer, termOffset, PADDING_FRAME_TYPE); frameLengthOrdered(termBuffer, termOffset, frameLength); } return resultingOffset; } \nResponse:", "ground_truth": "Pad a length of the term buffer with a padding record.\n\n@param termId     for the current term.\n@param termOffset in the term at which to append.\n@param header     for writing the default header.\n@param length     of the padding to be written.\n@return the resulting offset of the term after success otherwise {@link #FAILED}.", "predict": " public int appendPadding( final int termId, final int termOffset, final HeaderWriter header, final int length) { final int frameLength = length + HEADER_LENGTH; final int alignedLength = align(frameLength, FRAME_ALIGNMENT); final UnsafeBuffer termBuffer = this.termBuffer; final int termLength = termBuffer.capacity(); int resultingOffset = termOffset + alignedLength; putRawTailOrdered(termId, resultingOffset); if (resultingOffset > termLength) { resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId); } else { header.write(termBuffer, termOffset, frameLength, termId); frameType(termBuffer, termOffset, PADDING_FRAME_TYPE); frameLengthOrdered(termBuffer, termOffset, frameLength); } return resultingOffset; } \n */\npublic class RawTailer\n{\n    private final int termLengthMask;\n    private final"}, {"ID": 1866, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final int updatePublisherLimit() { int workCount = 0; final long senderPosition = this.senderPosition.getVolatile(); if (hasReceivers || (spiesSimulateConnection && spyPositions.length > 0)) { long minConsumerPosition = senderPosition; for (final ReadablePosition spyPosition : spyPositions) { minConsumerPosition = Math.min(minConsumerPosition, spyPosition.getVolatile()); } final long proposedPublisherLimit = minConsumerPosition + termWindowLength; if (publisherLimit.proposeMaxOrdered(proposedPublisherLimit)) { cleanBuffer(proposedPublisherLimit); workCount = 1; } } else if (publisherLimit.get() > senderPosition) { publisherLimit.setOrdered(senderPosition); } return workCount; } \nResponse:", "ground_truth": "Update the publishers limit for flow control as part of the conductor duty cycle.\n\n@return 1 if the limit has been updated otherwise 0.", "predict": "\n\n*/\n\npublic class PublisherLimit {\n    private final long maxOrdered;\n    private final AtomicLong currentOrdered;\n    private final AtomicLong proposedPublisherLimit;\n    private final AtomicLong proposedConsumerLimit;\n    private final AtomicLong proposedConsumerLimitOrdered;\n    private final AtomicLong proposedConsumerLimitVolatile;\n    private final AtomicLong proposedConsumerLimitVolatileOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrderedOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrderedOrderedOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrderedOrderedOrderedOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrderedOrderedOrderedOrderedOrdered;\n    private final AtomicLong proposedConsumerLimitVolatileOrderedOrderedOrderedOrderedOrderedOrderedOrdered;\n    private"}, {"ID": 1867, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, streamId, channel), countersManager); } \nResponse:", "ground_truth": "Allocate a counter for tracking a position on a stream of messages.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@param sessionId       for the stream of messages.\n@param streamId        for the stream of messages.\n@param channel         for the stream of messages.\n@return a new {@link UnsafeBufferPosition} for tracking the stream.", "predict": " Generate the method-level comment for the following java Code. Code: public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, streamId, channel), countersManager); } \n */\n\npublic class UnsafeBufferPosition extends UnsafeBufferPositionBase\n{\n    public UnsafeBufferPosition(UnsafeBuffer countersBuffer, int counterId, CountersManager countersManager)\n    {\n        super(countersBuffer, counterId, countersManager);\n    }\n\n    public UnsafeBufferPosition(UnsafeBuffer countersBuffer, int counterId, CountersManager countersManager, int initialValue)\n    {\n        super(counters"}, {"ID": 1868, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String labelName(final int typeId) { switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: return PublisherLimit.NAME; case SenderPos.SENDER_POSITION_TYPE_ID: return SenderPos.NAME; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: return ReceiverHwm.NAME; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: return SubscriberPos.NAME; case ReceiverPos.RECEIVER_POS_TYPE_ID: return ReceiverPos.NAME; case SenderLimit.SENDER_LIMIT_TYPE_ID: return SenderLimit.NAME; case PublisherPos.PUBLISHER_POS_TYPE_ID: return PublisherPos.NAME; case SenderBpe.SENDER_BPE_TYPE_ID: return SenderBpe.NAME; default: return \"<unknown>\"; } } \nResponse:", "ground_truth": "Return the label name for a counter type identifier.\n\n@param typeId of the counter.\n@return the label name as a String.", "predict": "\n\n*/\n\npublic class SenderPos extends SenderPosBase {\n    public static final int SENDER_POS_TYPE_ID = 1;\n    public static final String NAME = \"SenderPos\";\n\n    public SenderPos(int typeId, int value) {\n        super(typeId, value);\n    }\n\n    public SenderPos(int typeId, int value, int senderPos) {\n        super(typeId, value, senderPos);\n    }\n\n    public SenderPos(int typeId, int value, int senderPos, int receiverPos) {\n        super(typeId, value, senderPos, receiverPos);\n    }\n\n    public SenderPos(int typeId, int value, int senderPos, int receiverPos, int senderLimit) {\n        super(typeId, value, senderPos, receiverPos, senderLimit);\n    }\n\n    public SenderPos(int typeId, int value, int senderPos, int"}, {"ID": 1869, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) { final int limit = Math.min(maxLength, termBuffer.capacity() - offset); int available = 0; int padding = 0; do { final int termOffset = offset + available; final int frameLength = frameLengthVolatile(termBuffer, termOffset); if (frameLength <= 0) { break; } int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT); if (isPaddingFrame(termBuffer, termOffset)) { padding = alignedFrameLength - HEADER_LENGTH; alignedFrameLength = HEADER_LENGTH; } available += alignedFrameLength; if (available > limit) { available -= alignedFrameLength; padding = 0; break; } } while (0 == padding && available < limit); return pack(padding, available); } \nResponse:", "ground_truth": "Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.\n\n@param termBuffer to be scanned for new message fragments.\n@param offset     at which the scan should begin.\n@param maxLength  in bytes of how much should be scanned.\n@return resulting status of the scan which packs the available bytes and padding into a long.", "predict": " public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) { final int limit = Math.min(maxLength, termBuffer.capacity() - offset); int available = 0; int padding = 0; do { final int termOffset = offset + available; final int frameLength = frameLengthVolatile(termBuffer, termOffset); if (frameLength <= 0) { break; } int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT); if (isPaddingFrame(termBuffer, termOffset)) { padding = alignedFrameLength - HEADER_LENGTH; alignedFrameLength = HEADER_LENGTH; } available += alignedFrameLength; if (available > limit) { available -= alignedFrameLength; padding = 0; break; } } while (0 == padding && available < limit); return pack(padding, available); } \n\n*/\n"}, {"ID": 1870, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder clear() { prefix = null; media = null; endpoint = null; networkInterface = null; controlEndpoint = null; controlMode = null; tags = null; alias = null; reliable = null; ttl = null; mtu = null; termLength = null; initialTermId = null; termId = null; termOffset = null; sessionId = null; linger = null; sparse = null; eos = null; tether = null; isSessionIdTagged = false; return this; } \nResponse:", "ground_truth": "Clear out all the values thus setting back to the initial state.\n\n@return this for a fluent API.", "predict": " ResponseCode = 200\n\n*/\n\npackage com.microsoft.azure.iot.service.transport.http;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.utils.URLEncodedUtils;\n\nimport com.microsoft.azure.iot.service.transport.http.HttpConstants.HttpHeaders;\n\n/**\n * The Class HttpRequest.\n */\npublic class HttpRequest {\n    /** The request method. */\n    private String requestMethod;\n\n    /** The request url. */\n    private String requestUrl;\n\n    /** The request headers. */\n    private List<NameValuePair> requestHeaders;\n\n    /** The request body. */\n    private String requestBody;\n\n    /** The request content type. */\n    private String requestContentType;\n\n    /** The request content length."}, {"ID": 1871, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder validate() { if (null == media) { throw new IllegalStateException(\"media type is mandatory\"); } if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) { throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\"); } int count = 0; count += null == initialTermId ? 0 : 1; count += null == termId ? 0 : 1; count += null == termOffset ? 0 : 1; if (count > 0) { if (count < 3) { throw new IllegalStateException( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\"); } if (termId - initialTermId < 0) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId); } if (null != termLength && termOffset > termLength) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException(\"termOffset=\" + termOffset + \" > termLength=\" + termLength); } } return this; } \nResponse:", "ground_truth": "Validates that the collection of set parameters are valid together.\n\n@return this for a fluent API.\n@throws IllegalStateException if the combination of params is invalid.", "predict": "\n\n*/\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Preconditions;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io"}, {"ID": 1872, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder prefix(final String prefix) { if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid prefix: \" + prefix); } this.prefix = prefix; return this; } \nResponse:", "ground_truth": "Set the prefix for taking an addition action such as spying on an outgoing publication with \"aeron-spy\".\n\n@param prefix to be applied to the URI before the the scheme.\n@return this for a fluent API.\n@see ChannelUri#SPY_QUALIFIER", "predict": " public ChannelUriStringBuilder suffix(final String suffix) { if (null != suffix && !suffix.equals(\"\") && !suffix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid suffix: \" + suffix); } this.suffix = suffix; return this; } \nResp public ChannelUriStringBuilder suffix(final String prefix, final String suffix) { if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid prefix: \" + prefix); } if (null != suffix && !suffix.equals(\"\") && !suffix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid suffix: \" + suffix); } this.prefix = prefix; this.suffix = suffix; return this; } \nResp public ChannelUriStringBuilder suffix(final String prefix"}, {"ID": 1873, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder media(final String media) { switch (media) { case CommonContext.UDP_MEDIA: case CommonContext.IPC_MEDIA: break; default: throw new IllegalArgumentException(\"invalid media: \" + media); } this.media = media; return this; } \nResponse:", "ground_truth": "Set the media for this channel. Valid values are \"udp\" and \"ipc\".\n\n@param media for this channel.\n@return this for a fluent API.", "predict": " Response = new Response(this.media); \n\n}\n"}, {"ID": 1874, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder controlMode(final String controlMode) { if (null != controlMode && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_MANUAL) && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_DYNAMIC)) { throw new IllegalArgumentException(\"invalid control mode: \" + controlMode); } this.controlMode = controlMode; return this; } \nResponse:", "ground_truth": "Set the control mode for multi-destination-cast. Set to \"manual\" for allowing control from the publication API.\n\n@param controlMode for taking control of MDC.\n@return this for a fluent API.\n@see Publication#addDestination(String)\n@see Publication#removeDestination(String)\n@see CommonContext#MDC_CONTROL_MODE_PARAM_NAME\n@see CommonContext#MDC_CONTROL_MODE_MANUAL\n@see CommonContext#MDC_CONTROL_MODE_DYNAMIC", "predict": "\n\n*/\n\npublic class ChannelUriStringBuilder {\n    private String controlMode;\n\n    public ChannelUriStringBuilder controlMode(final String controlMode) {\n        this.controlMode = controlMode;\n        return this;\n    }\n\n    public String build() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(\"controlMode(\");\n        builder.append(this.controlMode);\n        builder.append(\")\");\n        return builder.toString();\n    }\n}\n"}, {"ID": 1875, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder termLength(final Integer termLength) { if (null != termLength) { LogBufferDescriptor.checkTermLength(termLength); } this.termLength = termLength; return this; } \nResponse:", "ground_truth": "Set the length of buffer used for each term of the log. Valid values are powers of 2 in the 64K - 1G range.\n\n@param termLength of the buffer used for each term of the log.\n@return this for a fluent API.\n@see CommonContext#TERM_LENGTH_PARAM_NAME", "predict": " public ChannelUriStringBuilder termLength(final int termLength) { return termLength(Integer.valueOf(termLength)); } \n\n*/\n\npublic class ChannelUriStringBuilder {\n    private final StringBuilder builder = new StringBuilder();\n    private final StringBuilder builder2 = new StringBuilder();\n    private final StringBuilder builder3 = new StringBuilder();\n    private final StringBuilder builder4 = new StringBuilder();\n    private final StringBuilder builder5 = new StringBuilder();\n    private final StringBuilder builder6 = new StringBuilder();\n    private final StringBuilder builder7 = new StringBuilder();\n    private final StringBuilder builder8 = new StringBuilder();\n    private final StringBuilder builder9 = new StringBuilder();\n    private final StringBuilder builder10 = new StringBuilder();\n    private final StringBuilder builder11 = new StringBuilder();\n    private final StringBuilder builder12 = new StringBuilder();\n    private final StringBuilder builder13 = new StringBuilder();\n    private final StringBuilder"}, {"ID": 1876, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder termOffset(final Integer termOffset) { if (null != termOffset) { if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) { throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset); } if (0 != (termOffset & (FRAME_ALIGNMENT - 1))) { throw new IllegalArgumentException(\"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset); } } this.termOffset = termOffset; return this; } \nResponse:", "ground_truth": "Set the offset within a term at which a publication will start. This when combined with the term id can establish\na starting position.\n\n@param termOffset within a term at which a publication will start.\n@return this for a fluent API.\n@see CommonContext#TERM_OFFSET_PARAM_NAME", "predict": " public ChannelUriStringBuilder termOffset(final int termOffset) { return termOffset(Integer.valueOf(termOffset)); } \n*/\n\npublic class ChannelUriStringBuilder {\n    private final StringBuilder builder = new StringBuilder();\n    private final int maxLength;\n    private int termOffset = 0;\n\n    public ChannelUriStringBuilder(final int maxLength) {\n        this.maxLength = maxLength;\n    }\n\n    public ChannelUriStringBuilder termOffset(final int termOffset) {\n        this.termOffset = termOffset;\n        return this;\n    }\n\n    public ChannelUriStringBuilder termOffset(final Integer termOffset) {\n        if (null != termOffset) {\n            if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) {\n                throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset);\n            }\n            "}, {"ID": 1877, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder linger(final Long lingerNs) { if (null != lingerNs && lingerNs < 0) { throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs); } this.linger = lingerNs; return this; } \nResponse:", "ground_truth": "Set the time a network publication will linger in nanoseconds after being drained. This time is so that tail loss\ncan be recovered.\n\n@param lingerNs time for the publication after it is drained.\n@return this for a fluent API.\n@see CommonContext#LINGER_PARAM_NAME", "predict": " ResponseCode.OK\n*/\n\npublic class ChannelUriStringBuilder {\n    private Long linger;\n\n    public ChannelUriStringBuilder linger(final Long lingerNs) {\n        if (null != lingerNs && lingerNs < 0) {\n            throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs);\n        }\n        this.linger = lingerNs;\n        return this;\n    }\n\n    public String build() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(\"ChannelUriStringBuilder(\");\n        if (null != linger) {\n            builder.append(\"linger=\");\n            builder.append(linger);\n        }\n        builder.append(\")\");\n        return builder.toString();\n    }\n}\n"}, {"ID": 1878, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void openDatagramChannel(final AtomicCounter statusIndicator) { try { sendDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); receiveDatagramChannel = sendDatagramChannel; if (udpChannel.isMulticast()) { if (null != connectAddress) { receiveDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); } receiveDatagramChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); receiveDatagramChannel.bind(new InetSocketAddress(endPointAddress.getPort())); receiveDatagramChannel.join(endPointAddress.getAddress(), udpChannel.localInterface()); sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_IF, udpChannel.localInterface()); if (udpChannel.isHasMulticastTtl()) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, udpChannel.multicastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } else if (context.socketMulticastTtl() != 0) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, context.socketMulticastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } } else { sendDatagramChannel.bind(bindAddress); } if (null != connectAddress) { sendDatagramChannel.connect(connectAddress); } if (0 != context.socketSndbufLength()) { sendDatagramChannel.setOption(SO_SNDBUF, context.socketSndbufLength()); } if (0 != context.socketRcvbufLength()) { receiveDatagramChannel.setOption(SO_RCVBUF, context.socketRcvbufLength()); } sendDatagramChannel.configureBlocking(false); receiveDatagramChannel.configureBlocking(false); } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERRORED); } CloseHelper.quietClose(sendDatagramChannel); if (receiveDatagramChannel != sendDatagramChannel) { CloseHelper.quietClose(receiveDatagramChannel); } sendDatagramChannel = null; receiveDatagramChannel = null; throw new AeronException( \"channel error - \" + ex.getMessage() + \" (at \" + ex.getStackTrace()[0].toString() + \"): \" + udpChannel.originalUriString(), ex); } } \nResponse:", "ground_truth": "Create the underlying channel for reading and writing.\n\n@param statusIndicator to set for error status", "predict": "\npublic void sendDatagramChannel(final AtomicCounter statusIndicator) { try { if (null != sendDatagramChannel) { sendDatagramChannel.write(buffer, 0, buffer.length); } } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERRORED); } CloseHelper.quietClose(sendDatagramChannel); throw new AeronException( \"channel error - \" + ex.getMessage() + \" (at \" + ex.getStackTrace()[0].toString() + \"): \" + udpChannel.originalUriString(), ex); } } \npublic void receiveDatagramChannel(final AtomicCounter statusIndicator) { try { if (null != receiveDatagramChannel) { receiveDatagramChannel.receive(buffer); } } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERROR"}, {"ID": 1879, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (!isClosed) { isClosed = true; try { if (null != selectionKey) { selectionKey.cancel(); } if (null != transportPoller) { transportPoller.cancelRead(this); transportPoller.selectNowWithoutProcessing(); } if (null != sendDatagramChannel) { sendDatagramChannel.close(); } if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) { receiveDatagramChannel.close(); } if (null != transportPoller) { transportPoller.selectNowWithoutProcessing(); } } catch (final IOException ex) { errorLog.record(ex); } } } \nResponse:", "ground_truth": "Close transport, canceling any pending read operations and closing channel", "predict": "\n\n*/\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DatagramChannelTest {\n    public static void main(String[] args) throws Exception {\n        SocketAddress address = new InetSocketAddress(\"localhost\", 9999);\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        channel.connect(address);\n        channel.register(selector, SelectionKey.OP_READ);\n        while (true) {\n            selector.select();\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator ="}, {"ID": 1880, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isValidFrame(final UnsafeBuffer buffer, final int length) { boolean isFrameValid = true; if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) { isFrameValid = false; invalidPackets.increment(); } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) { isFrameValid = false; invalidPackets.increment(); } return isFrameValid; } \nResponse:", "ground_truth": "Is the received frame valid. This method will do some basic checks on the header and can be\noverridden in a subclass for further validation.\n\n@param buffer containing the frame.\n@param length of the frame.\n@return true if the frame is believed valid otherwise false.", "predict": "\npublic boolean isValidFrame(final UnsafeBuffer buffer, final int length) { boolean isFrameValid = true; if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) { isFrameValid = false; invalidPackets.increment(); } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) { isFrameValid = false; invalidPackets.increment(); } return isFrameValid; }\n\npublic static final class HeaderFlyweight {\n    public static final int CURRENT_VERSION = 1;\n    public static final int MIN_HEADER_LENGTH = Header.SIZE;\n\n    private static final int HEADER_LENGTH = MIN_HEADER_LENGTH;\n    private static final int HEADER_SIZE = HEADER_LENGTH;\n\n    private static final int VERSION_FIELD_OFFSET = 0;\n    private static final int TYPE_FIELD_OFFSET = VERSION_FIELD_OFFSET + INT_SIZE_"}, {"ID": 1881, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public InetSocketAddress receive(final ByteBuffer buffer) { buffer.clear(); InetSocketAddress address = null; try { if (receiveDatagramChannel.isOpen()) { address = (InetSocketAddress)receiveDatagramChannel.receive(buffer); } } catch (final PortUnreachableException ignored) { } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } return address; } \nResponse:", "ground_truth": "Receive a datagram from the media layer.\n\n@param buffer into which the datagram will be received.\n@return the source address of the datagram if one is available otherwise false.", "predict": "\n\n*/\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DatagramChannelTest {\n    public static void main(String[] args) {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open();\n            channel.configureBlocking(false);\n            channel.connect(new InetSocketAddress(\"localhost\", 9999));\n            channel.register(channel.provider().openSelector(), SelectionKey.OP_READ);\n            Selector selector = SelectorProvider.provider().openSelector();\n            while (true)"}, {"ID": 1882, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onNak( final int termId, final int termOffset, final int length, final int termLength, final RetransmitSender retransmitSender) { if (!isInvalid(termOffset, termLength)) { if (null == activeRetransmitsMap.get(termId, termOffset) && activeRetransmitsMap.size() < MAX_RETRANSMITS_DEFAULT) { final RetransmitAction action = assignRetransmitAction(); action.termId = termId; action.termOffset = termOffset; action.length = Math.min(length, termLength - termOffset); final long delay = delayGenerator.generateDelay(); if (0 == delay) { retransmitSender.resend(termId, termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else { action.delay(delay, nanoClock.nanoTime()); } activeRetransmitsMap.put(termId, termOffset, action); } } } \nResponse:", "ground_truth": "Called on reception of a NAK to start retransmits handling.\n\n@param termId           from the NAK and the term id of the buffer to retransmit from\n@param termOffset       from the NAK and the offset of the data to retransmit\n@param length           of the missing data\n@param termLength       of the term buffer.\n@param retransmitSender to call if an immediate retransmit is required", "predict": " public void onNak(final int termId, final int termOffset, final int length, final int termLength, final RetransmitSender retransmitSender) { if (!isInvalid(termOffset, termLength)) { if (null == activeRetransmitsMap.get(termId, termOffset) && activeRetransmitsMap.size() < MAX_RETRANSMITS_DEFAULT) { final RetransmitAction action = assignRetransmitAction(); action.termId = termId; action.termOffset = termOffset; action.length = Math.min(length, termLength - termOffset); final long delay = delayGenerator.generateDelay(); if (0 == delay) { retransmitSender.resend(termId, termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else { action.delay(delay, nanoClock.nanoTime()); } activeRetransmits"}, {"ID": 1883, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void processTimeouts(final long nowNs, final RetransmitSender retransmitSender) { if (activeRetransmitsMap.size() > 0) { for (final RetransmitAction action : retransmitActionPool) { if (DELAYED == action.state && (action.expireNs - nowNs < 0)) { retransmitSender.resend(action.termId, action.termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else if (LINGERING == action.state && (action.expireNs - nowNs < 0)) { action.cancel(); activeRetransmitsMap.remove(action.termId, action.termOffset); } } } } \nResponse:", "ground_truth": "Called to process any outstanding timeouts.\n\n@param nowNs            time in nanoseconds\n@param retransmitSender to call on retransmissions", "predict": "\n\n*/\n\npackage org.agrona.concurrent.ringbuffer;\n\nimport org.agrona.concurrent.UnsafeBuffer;\n\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n\nimport static org.agrona.concurrent.ringbuffer.RingBufferDescriptor.*;\n\n/**\n * The {@link RetransmitAction} is a structure that is used to store the state of a retransmit action.\n */\npublic class RetransmitAction\n{\n    private static final AtomicIntegerFieldUpdater<RetransmitAction> STATE_UPDATER =\n        AtomicIntegerFieldUpdater.newUpdater(RetransmitAction.class, \"state\");\n\n    private static final int INITIAL_STATE = 0;\n    private static final int DELAYED = 1;\n    private static final int LINGERING = 2;\n\n    private final long expireNs;\n    "}, {"ID": 1884, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String status(final long status) { if (INITIALIZING == status) { return \"INITIALIZING\"; } if (ERRORED == status) { return \"ERRORED\"; } if (ACTIVE == status) { return \"ACTIVE\"; } if (CLOSING == status) { return \"CLOSING\"; } return \"unknown id=\" + status; } \nResponse:", "ground_truth": "String representation of the channel status.\n\n@param status to be converted.\n@return representation of the channel status.", "predict": "\n\n*/\n\npublic class Status {\n    public static String status(long status) {\n        if (INITIALIZING == status) {\n            return \"INITIALIZING\";\n        }\n        if (ERRORED == status) {\n            return \"ERRORED\";\n        }\n        if (ACTIVE == status) {\n            return \"ACTIVE\";\n        }\n        if (CLOSING == status) {\n            return \"CLOSING\";\n        }\n        return \"unknown id=\" + status;\n    }\n}\n"}, {"ID": 1885, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) { final int keyLength = tempBuffer.putStringWithoutLengthAscii( CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH); tempBuffer.putInt(CHANNEL_OFFSET, keyLength); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name); labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, \": \"); labelLength += tempBuffer.putStringWithoutLengthAscii( keyLength + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength); return countersManager.newCounter(typeId, tempBuffer, 0, keyLength, tempBuffer, keyLength, labelLength); } \nResponse:", "ground_truth": "Allocate an indicator for tracking the status of a channel endpoint.\n\n@param tempBuffer      to be used for labels and metadata.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param channel         for the stream of messages.\n@return a new {@link AtomicCounter} for tracking the status.", "predict": " public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) { return countersManager.newCounter(typeId, tempBuffer, 0, tempBuffer.capacity(), tempBuffer, 0, tempBuffer.capacity(), name, channel); } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.cassandra.db.marshal.AsciiType;\nimport org.apache.cassandra.db.marshal.UTF8Type;\nimport org.apache.cassandra.service.StorageService;\nimport org.apache.cassandra.utils.FBUtilities;\nimport org.apache.cassandra.utils.UUIDGen;\n\nimport org.apache.cassandra.config.DatabaseDescriptor;\nimport org."}, {"ID": 1886, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; } \nResponse:", "ground_truth": "Reset the values.\n\n@param buffer which is the super set.\n@param offset at which the vector begins.\n@param length of the vector.\n@return this for a fluent API.", "predict": " Resp public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\n\npublic class JavaDocCommentParser {\n\n\tprivate static final Pattern JAVA_DOC_COMMENT_PATTERN = Pattern.compile(\"/\\\\*\\\\*(.*)\\\\*/\");\n\tprivate static final Pattern JAVA_DOC_COMMENT_PATTERN_2 = Pattern.compile(\"/\\\\*(.*)\\\\*/\");\n\tprivate static"}, {"ID": 1887, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirectBufferVector validate() { final int capacity = buffer.capacity(); if (offset < 0 || offset >= capacity) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity); } if (length < 0 || length > (capacity - offset)) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length); } return this; } \nResponse:", "ground_truth": "Ensure the vector is valid for the buffer.\n\n@throws NullPointerException if the buffer is null.\n@throws IllegalArgumentException if the offset is out of range for the buffer.\n@throws IllegalArgumentException if the length is out of range for the buffer.\n@return this for a fluent API.", "predict": " public DirectBufferVector validate() { return this; } \n*/\n\npublic class DirectBufferVector {\n    public static void main(String[] args) {\n        DirectBufferVector vector = new DirectBufferVector();\n        vector.validate();\n    }\n}\n"}, {"ID": 1888, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int validateAndComputeLength(final DirectBufferVector[] vectors) { int messageLength = 0; for (final DirectBufferVector vector : vectors) { vector.validate(); messageLength += vector.length; if (messageLength < 0) { throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors)); } } return messageLength; } \nResponse:", "ground_truth": "Validate an array of vectors to make up a message and compute the total length.\n\n@param vectors to be validated summed.\n@return the sum of the vector lengths.", "predict": " public static int validateAndComputeLength(final DirectBufferVector[] vectors) { int messageLength = 0; for (final DirectBufferVector vector : vectors) { vector.validate(); messageLength += vector.length; if (messageLength < 0) { throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors)); } } return messageLength; } \n */\n\npublic class DirectBufferVector {\n    public static int validateAndComputeLength(final DirectBufferVector[] vectors) {\n        int messageLength = 0;\n        for (final DirectBufferVector vector : vectors) {\n            vector.validate();\n            messageLength += vector.length;\n            if (messageLength < 0) {\n                throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors));\n            }\n        }\n        return messageLength;\n    }\n}\n"}, {"ID": 1889, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) { int termWindowLength = termBufferLength / 2; if (0 != defaultTermWindowLength) { termWindowLength = Math.min(defaultTermWindowLength, termWindowLength); } return termWindowLength; } \nResponse:", "ground_truth": "How far ahead a producer can get from a consumer position.\n\n@param termBufferLength        for when default is not set and considering an appropriate minimum.\n@param defaultTermWindowLength to take priority.\n@return the length to be used for the producer window.", "predict": " public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) { int termWindowLength = termBufferLength / 2; if (0 != defaultTermWindowLength) { termWindowLength = Math.min(defaultTermWindowLength, termWindowLength); } return termWindowLength; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.amazonaws.services.kinesis.AmazonKinesisClient;\nimport com.amazonaws.services.kinesis.model.CreateStreamRequest;\nimport com.amazonaws.services.kinesis.model.DescribeStreamRequest;\nimport com.amazonaws.services.kinesis.model.DescribeStreamResult;\nimport com.amazonaws.services.kinesis.model.GetRecordsRequest;\nimport com.amazonaws.services.kinesis.model."}, {"ID": 1890, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateSocketBufferLengths(final MediaDriver.Context ctx) { try (DatagramChannel probe = DatagramChannel.open()) { final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE); final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); if (maxSoSndBuf < ctx.socketSndbufLength()) { System.err.format( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.socketSndbufLength(), maxSoSndBuf); } probe.setOption(StandardSocketOptions.SO_RCVBUF, Integer.MAX_VALUE); final int maxSoRcvBuf = probe.getOption(StandardSocketOptions.SO_RCVBUF); if (maxSoRcvBuf < ctx.socketRcvbufLength()) { System.err.format( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_RCVBUF_LENGTH_PROP_NAME, ctx.socketRcvbufLength(), maxSoRcvBuf); } final int soSndBuf = 0 == ctx.socketSndbufLength() ? defaultSoSndBuf : ctx.socketSndbufLength(); if (ctx.mtuLength() > soSndBuf) { throw new ConfigurationException(String.format( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.mtuLength(), soSndBuf)); } if (ctx.initialWindowLength() > maxSoRcvBuf) { throw new ConfigurationException(\"window length greater than socket SO_RCVBUF, increase '\" + Configuration.INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx.initialWindowLength() + \", SO_RCVBUF=\" + maxSoRcvBuf); } } catch (final IOException ex) { throw new AeronException(\"probe socket: \" + ex.toString(), ex); } } \nResponse:", "ground_truth": "Validate that the socket buffer lengths are sufficient for the media driver configuration.\n\n@param ctx to be validated.", "predict": "\n\n*/\npackage com.lmax.disruptor.examples.stress;\n\nimport com.lmax.disruptor.EventHandler;\nimport com.lmax.disruptor.LifecycleAware;\nimport com.lmax.disruptor.RingBuffer;\nimport com.lmax.disruptor.SequenceBarrier;\nimport com.lmax.disruptor.TimeoutBlockingWaitStrategy;\nimport com.lmax.disruptor.TimeoutBlockingWaitStrategy.TimeoutException;\nimport com.lmax.disruptor.util.DaemonThreadFactory;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic final class StressTest\n{\n    private static final int BUFFER_SIZE = 32 * 1024;\n    private"}, {"ID": 1891, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validatePageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new ConfigurationException( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new ConfigurationException( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new ConfigurationException(\"page size not a power of 2: \" + pageSize); } } \nResponse:", "ground_truth": "Validate that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws ConfigurationException if the size is not as expected.", "predict": "\n\n*/\n\npublic class PageSizeValidator {\n    public static void validatePageSize(final int pageSize) {\n        if (pageSize < PAGE_MIN_SIZE) {\n            throw new ConfigurationException(\"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize);\n        }\n        if (pageSize > PAGE_MAX_SIZE) {\n            throw new ConfigurationException(\"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize);\n        }\n        if (!BitUtil.isPowerOfTwo(pageSize)) {\n            throw new ConfigurationException(\"page size not a power of 2: \" + pageSize);\n        }\n    }\n}\n"}, {"ID": 1892, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateSessionIdRange(final int low, final int high) { if (low > high) { throw new ConfigurationException(\"low session id value \" + low + \" must be <= high value \" + high); } if (Math.abs((long)high - low) > Integer.MAX_VALUE) { throw new ConfigurationException(\"reserved range to too large\"); } } \nResponse:", "ground_truth": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.\n\n@param low  value in the range.\n@param high value in the range.\n@throws ConfigurationException if the values are not valid.", "predict": "\n\n*/\n\npublic class SessionIdRangeValidator extends AbstractValidator {\n\n    public SessionIdRangeValidator() {\n        super(\"sessionIdRange\");\n    }\n\n    @Override\n    public void validate(final String value, final Object rootElement, final Object parentElement, final ValidationResult result) {\n        if (value == null) {\n            return;\n        }\n        final String[] split = value.split(\"-\");\n        if (split.length != 2) {\n            result.addError(new ValidationError(rootElement, \"sessionIdRange\", \"Invalid format, must be low-high\"));\n            return;\n        }\n        final int low = Integer.parseInt(split[0]);\n        final int high = Integer.parseInt(split[1]);\n        if (low > high) {\n            result.addError(new ValidationError(rootElement, \"sessionIdRange\", \"low session id value \" + low + \""}, {"ID": 1893, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateUnblockTimeout( final long publicationUnblockTimeoutNs, final long clientLivenessTimeoutNs, final long timerIntervalNs) { if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) { throw new ConfigurationException( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs); } if (clientLivenessTimeoutNs <= timerIntervalNs) { throw new ConfigurationException( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs); } } \nResponse:", "ground_truth": "Validate that the timeouts for unblocking publications from a client are valid.\n\n@param publicationUnblockTimeoutNs after which an uncommitted publication will be unblocked.\n@param clientLivenessTimeoutNs     after which a client will be considered not alive.\n@param timerIntervalNs             interval at which the driver will check timeouts.\n@throws ConfigurationException if the values are not valid.", "predict": "\n\n*/\n\npublic class PublicationUnblockTimeoutValidator extends Validator {\n\n    public static final String MESSAGE = \"publicationUnblockTimeoutNs must be greater than clientLivenessTimeoutNs\";\n\n    @Override\n    public ValidationResult validate(final Object target, final Object value, final ValidationContext context) {\n        final long publicationUnblockTimeoutNs = (Long) value;\n        final long clientLivenessTimeoutNs = context.getClientLivenessTimeoutNs();\n        if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) {\n            return new ValidationResult(MESSAGE);\n        }\n        return new ValidationResult();\n    }\n}\n"}, {"ID": 1894, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ErrorResponseFlyweight errorCode(final ErrorCode code) { buffer.putInt(offset + ERROR_CODE_OFFSET, code.value()); return this; } \nResponse:", "ground_truth": "Set the error code for the command.\n\n@param code for the error\n@return flyweight", "predict": " public ErrorResponseFlyweight errorCode(final int code) { buffer.putInt(offset + ERROR_CODE_OFFSET, code); return this; } \nResp public ErrorResponseFlyweight errorMessage(final String message) { buffer.putStringUtf8(offset + ERROR_MESSAGE_OFFSET, message); return this; } \nResp public ErrorResponseFlyweight errorMessage(final byte[] message) { buffer.putBytes(offset + ERROR_MESSAGE_OFFSET, message); return this; } \nResp public ErrorResponseFlyweight errorMessage(final ByteBuffer message) { buffer.putBytes(offset + ERROR_MESSAGE_OFFSET, message); return this; } \nResp public ErrorResponseFlyweight errorMessage(final byte[] message, final int offset, final int length) { buffer.putBytes(offset + ERROR_MESSAGE_OFFSET, message, offset, length); return this; } \nResp"}, {"ID": 1895, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void reset() { isBallotSent = false; isLeader = false; hasRequestedJoin = false; hasSentTerminationAck = false; vote = null; candidateTermId = Aeron.NULL_VALUE; leadershipTermId = Aeron.NULL_VALUE; logPosition = NULL_POSITION; } \nResponse:", "ground_truth": "Reset the state of a cluster member so it can be canvassed and reestablished.", "predict": "\npublic void reset() { isBallotSent = false; isLeader = false; hasRequestedJoin = false; hasSentTerminationAck = false; vote = null; candidateTermId = Aeron.NULL_VALUE; leadershipTermId = Aeron.NULL_VALUE; logPosition = NULL_POSITION; }\n\npublic void reset(final long termId, final long leaderId, final long leaderTermId, final long logPosition) {\nisBallotSent = false;\nisLeader = false;\nhasRequestedJoin = false;\nhasSentTerminationAck = false;\nvote = null;\ncandidateTermId = termId;\nleadershipTermId = leaderId;\nlogPosition = logPosition;\n}\n\npublic void reset(final long termId, final long leaderId, final long leaderTermId, final long logPosition, final long candidateTermId, final long leadershipTermId) {\nisBallotSent = false;\nisLeader = false;\n"}, {"ID": 1896, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeAsString(final ClusterMember[] clusterMembers) { final StringBuilder builder = new StringBuilder(); for (int i = 0, length = clusterMembers.length; i < length; i++) { final ClusterMember member = clusterMembers[i]; builder .append(member.id()) .append(',') .append(member.endpointsDetail()); if ((length - 1) != i) { builder.append('|'); } } return builder.toString(); } \nResponse:", "ground_truth": "Encode member details from a cluster members array to a string.\n\n@param clusterMembers to fill the details from\n@return String representation suitable for use with {@link ClusterMember#parse}", "predict": "\n\n*/\n\npackage com.hazelcast.client.impl.protocol.task.multimap;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MultiMapAddEntryListenerToKeyCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractAddListenerMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.util.CollectionUtil;\nimport com.hazelcast.multimap.impl.MultiMapService;\nimport com.hazelcast.multimap.impl.operations.MultiMapAddEntryListenerOperation;\nimport com.hazelcast.multimap.impl.operations.MultiMapResponse;\nimport com.hazelcast.nio.serialization"}, {"ID": 1897, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addMemberStatusPublications( final ClusterMember[] members, final ClusterMember exclude, final ChannelUri channelUri, final int streamId, final Aeron aeron) { for (final ClusterMember member : members) { if (member != exclude) { channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint()); member.publication = aeron.addExclusivePublication(channelUri.toString(), streamId); } } } \nResponse:", "ground_truth": "Add the publications for sending status messages to the other members of the cluster.\n\n@param members    of the cluster.\n@param exclude    this member when adding publications.\n@param channelUri for the publication.\n@param streamId   for the publication.\n@param aeron      to add the publications to.", "predict": "\n\n*/\n\npackage com.azure.cosmos.implementation.directconnectivity;\n\nimport com.azure.cosmos.implementation.HttpConstants;\nimport com.azure.cosmos.implementation.ResourceType;\nimport com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\nimport com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\nimport com.azure.cosmos.implementation.apachecommons.lang.tuple.Triple;\nimport com.azure.cosmos.implementation.routing.Range;\nimport com.azure.cosmos.implementation.routing.Ranges;\nimport com.azure.cosmos.implementation.routing.ReplicationProtocol;\nimport com.azure.cosmos.implementation.routing.UInt128;\nimport com.azure.cosmos."}, {"ID": 1898, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void closeMemberPublications(final ClusterMember[] clusterMembers) { for (final ClusterMember member : clusterMembers) { CloseHelper.close(member.publication); } } \nResponse:", "ground_truth": "Close the publications associated with members of the cluster.\n\n@param clusterMembers to close the publications for.", "predict": " Response = Response.ok().build();\n\n*/\n\npackage com.baeldung.spring.cloud.kubernetes.client.examples;\n\nimport static org.springframework.http.MediaType.APPLICATION_JSON_VALUE;\nimport static org.springframework.web.bind.annotation.RequestMethod.GET;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.baeldung.spring.cloud.kubernetes.client.examples.model.KubernetesCluster;\nimport com.baeldung.spring.cloud.kubernetes.client.examples.model.KubernetesClusterMember;\nimport com.baeldung."}, {"ID": 1899, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasActiveQuorum( final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs) { int threshold = quorumThreshold(clusterMembers.length); for (final ClusterMember member : clusterMembers) { if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs)) { if (--threshold <= 0) { return true; } } } return false; } \nResponse:", "ground_truth": "Check if the cluster leader has an active quorum of cluster followers.\n\n@param clusterMembers for the current cluster.\n@param nowMs          for the current time.\n@param timeoutMs      after which a follower is not considered active.\n@return true if quorum of cluster members are considered active.", "predict": "\n\n*/\n\npackage com.yahoo.pulsar.client.api;\n\nimport java.util.List;\n\nimport com.yahoo.pulsar.client.api.MessageId;\nimport com.yahoo.pulsar.client.api.PulsarClientException;\nimport com.yahoo.pulsar.client.api.Reader;\nimport com.yahoo.pulsar.client.api.ReaderBuilder;\nimport com.yahoo.pulsar.client.api.ReaderListener;\nimport com.yahoo.pulsar.client.api.SubscriptionType;\n\npublic interface ReaderBuilder<T> {\n\n    /**\n     * Set the subscription name for the reader.\n     *\n     * <p>The subscription name can be used to lookup the reader.\n     *\n     * @param subscriptionName\n     *            the subscription name\n     * @return the ReaderBuilder instance\n     */\n    public ReaderBuilder<T> subscriptionName"}, {"ID": 1900, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) { final int length = rankedPositions.length; for (int i = 0; i < length; i++) { rankedPositions[i] = 0; } for (final ClusterMember member : members) { long newPosition = member.logPosition; for (int i = 0; i < length; i++) { final long rankedPosition = rankedPositions[i]; if (newPosition > rankedPosition) { rankedPositions[i] = newPosition; newPosition = rankedPosition; } } } return rankedPositions[length - 1]; } \nResponse:", "ground_truth": "Calculate the position reached by a quorum of cluster members.\n\n@param members         of the cluster.\n@param rankedPositions temp array to be used for sorting the positions to avoid allocation.\n@return the position reached by a quorum of cluster members.", "predict": "\n\n*/\n\npublic class QuorumPosition {\n    public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) {\n        final int length = rankedPositions.length;\n        for (int i = 0; i < length; i++) {\n            rankedPositions[i] = 0;\n        }\n        for (final ClusterMember member : members) {\n            long newPosition = member.logPosition;\n            for (int i = 0; i < length; i++) {\n                final long rankedPosition = rankedPositions[i];\n                if (newPosition > rankedPosition) {\n                    rankedPositions[i] = newPosition;\n                    newPosition = rankedPosition;\n                }\n            }\n        }\n        return rankedPositions[length - 1];\n    }\n}\n"}, {"ID": 1901, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) { for (final ClusterMember member : clusterMembers) { member.logPosition(logPosition); } } \nResponse:", "ground_truth": "Reset the log position of all the members to the provided value.\n\n@param clusterMembers to be reset.\n@param logPosition    to set for them all.", "predict": " void\n*/\npublic static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) {\n\tfor (final ClusterMember member : clusterMembers) {\n\t\tmember.logPosition(logPosition);\n\t}\n}\n\n}\n"}, {"ID": 1902, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean haveVotersReachedPosition( final ClusterMember[] clusterMembers, final long position, final long leadershipTermId) { for (final ClusterMember member : clusterMembers) { if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) { return false; } } return true; } \nResponse:", "ground_truth": "Has the members of the cluster the voted reached the provided position in their log.\n\n@param clusterMembers   to check.\n@param position         to compare the {@link #logPosition()} against.\n@param leadershipTermId expected of the members.\n@return true if all members have reached this position otherwise false.", "predict": "\n\n*/\n\npackage com.netflix.eureka.cluster;\n\nimport com.netflix.eureka.cluster.PeerEurekaNode;\nimport com.netflix.eureka.cluster.PeerEurekaNodes;\nimport com.netflix.eureka.cluster.PeerEurekaNode.Action;\nimport com.netflix.eureka.cluster.PeerEurekaNodes.Status;\nimport com.netflix.eureka.cluster.PeerEurekaNodes.Type;\nimport com.netflix.eureka.cluster.PeerEurekaNodes.VoterStatus;\nimport com.netflix.eureka.cluster.PeerEurekaNodes.VoterStatus.Status;\nimport com.netflix.eureka.cluster.PeerEurekaNodes.VoterStatus.Type;\nimport com.netflix.eureka."}, {"ID": 1903, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) { int votes = 0; for (final ClusterMember member : members) { if (null == member.vote || member.candidateTermId != candidateTermId) { return false; } votes += member.vote ? 1 : 0; } return votes >= ClusterMember.quorumThreshold(members.length); } \nResponse:", "ground_truth": "Has the candidate got unanimous support of the cluster?\n\n@param members         to check for votes.\n@param candidateTermId for the vote.\n@return false if any member has not voted for the candidate.", "predict": " public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) { int votes = 0; for (final ClusterMember member : members) { if (null == member.vote || member.candidateTermId != candidateTermId) { return false; } votes += member.vote ? 1 : 0; } return votes >= ClusterMember.quorumThreshold(members.length); } \n\n*/\n\npublic class ClusterMember {\n\tprivate final long candidateTermId;\n\tprivate final long vote;\n\t\n\tpublic ClusterMember(final long candidateTermId, final long vote) {\n\t\tthis.candidateTermId = candidateTermId;\n\t\tthis.vote = vote;\n\t}\n\t\n\tpublic long getCandidateTermId() {\n\t\treturn candidateTermId;\n\t}\n\t\n\tpublic long getVote() {\n\t\treturn vote;\n\t}\n\t\n\tpublic static int quorumThreshold(final int n"}, {"ID": 1904, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) { int votes = 0; for (final ClusterMember member : clusterMembers) { if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) { ++votes; } } return votes >= ClusterMember.quorumThreshold(clusterMembers.length); } \nResponse:", "ground_truth": "Has sufficient votes being counted for a majority?\n\n@param clusterMembers  to check for votes.\n@param candidateTermId for the vote.\n@return true if a majority of positive votes.", "predict": " public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) { int votes = 0; for (final ClusterMember member : clusterMembers) { if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) { ++votes; } } return votes >= ClusterMember.quorumThreshold(clusterMembers.length); } \n\n*/\n\npublic class MajorityVote {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tfinal int quorumThreshold = ClusterMember.quorumThreshold(3);\n\t\t\n\t\tfinal ClusterMember[] clusterMembers = new ClusterMember[] {\n\t\t\t\tnew ClusterMember(true, 1),\n\t\t\t\tnew ClusterMember(true, 2),\n\t\t\t\tnew ClusterMember(true, 3),\n\t\t\t\tnew ClusterMember(true, 4),\n\t\t\t\tnew ClusterMember(true, 5),\n\t\t\t\tnew ClusterMember(true, 6),\n\t\t\t\tnew ClusterMember"}, {"ID": 1905, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClusterMember determineMember( final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) { ClusterMember member = NULL_VALUE != memberId ? ClusterMember.findMember(clusterMembers, memberId) : null; if ((null == clusterMembers || 0 == clusterMembers.length) && null == member) { member = ClusterMember.parseEndpoints(NULL_VALUE, memberEndpoints); } else { if (null == member) { throw new ClusterException(\"memberId=\" + memberId + \" not found in clusterMembers\"); } if (!\"\".equals(memberEndpoints)) { ClusterMember.validateMemberEndpoints(member, memberEndpoints); } } return member; } \nResponse:", "ground_truth": "Determine which member of a cluster this is and check endpoints.\n\n@param clusterMembers  for the current cluster which can be null.\n@param memberId        for this member.\n@param memberEndpoints for this member.\n@return the {@link ClusterMember} determined.", "predict": " public static ClusterMember determineMember(final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) { return determineMember(clusterMembers, memberId, memberEndpoints); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClusterMember {\n    private final int id;\n    private final String host;\n    private final int port;\n    private final String memberEndpoints;\n    private final String memberId;\n    private final String memberName;\n    private final String memberType;\n    private final String memberVersion;\n    private final String memberZone;\n    private final String memberZoneId;\n    private final String memberZoneName;\n    private final String memberZoneVersion;\n    private final String memberZoneVersionId;\n    private final String memberZoneVersionName;\n    private final String memberZoneVersionStatus;\n    private final String memberZoneVersionStatusId;\n    private final String memberZone"}, {"ID": 1906, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) { final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints); if (!areSameEndpoints(member, endpointMember)) { throw new ClusterException( \"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints); } } \nResponse:", "ground_truth": "Check the member with the memberEndpoints\n\n@param member          to check memberEndpoints against\n@param memberEndpoints to check member against\n@see ConsensusModule.Context#memberEndpoints()\n@see ConsensusModule.Context#clusterMembers()", "predict": " public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) { final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints); if (!areSameEndpoints(member, endpointMember)) { throw new ClusterException( \"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints); } } \n\n*/\n\npublic class ClusterException extends Exception {\n    public ClusterException(final String message) {\n        super(message);\n    }\n}\n"}, {"ID": 1907, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) { return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint()); } \nResponse:", "ground_truth": "Are two cluster members using the same endpoints?\n\n@param lhs to check\n@param rhs to check\n@return true if both are using the same endpoints or false if not.", "predict": " public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) { return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint()); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.gemstone.gemfire.cache.Cache;\nimport com.gemstone.gemfire.cache.CacheFactory;\nimport com.gemstone.gemfire.cache.Region;\nimport com.gemstone.gemfire.cache.RegionFactory;\n"}, {"ID": 1908, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { return false; } } return true; } \nResponse:", "ground_truth": "Has the member achieved a unanimous view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { return false; } } return true; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.solution(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41"}, {"ID": 1909, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { int possibleVotes = 0; for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { continue; } ++possibleVotes; } return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length); } \nResponse:", "ground_truth": "Has the member achieved a quorum view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { int possibleVotes = 0; for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { continue; } ++possibleVotes; } return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length); } \n\n*/\n\npublic class QuorumCandidate {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tClusterMember[] clusterMembers = new ClusterMember[] {\n\t\t\t\tnew ClusterMember(\"localhost\", 1234, 0),\n\t\t\t\tnew ClusterMember(\"localhost\", 1235, 0),\n\t\t\t\tnew ClusterMember(\"localhost\", 1236, 0),\n\t\t\t\tnew ClusterMember(\"localhost\", 1237, 0),\n\t\t\t\tnew ClusterMember(\"localhost\", 1238, 0),\n\t\t\t\tnew ClusterMember(\"localhost\", 1239, 0),\n"}, {"ID": 1910, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isNotDuplicateEndpoints(final ClusterMember[] members, final String memberEndpoints) { for (final ClusterMember member : members) { if (member.endpointsDetail().equals(memberEndpoints)) { return false; } } return true; } \nResponse:", "ground_truth": "Is the string of member endpoints not duplicated in the members.\n\n@param members         to check if the provided endpoints have a duplicate.\n@param memberEndpoints to check for duplicates.\n@return true if no duplicate is found otherwise false.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1911, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) { final int length = clusterMembers.length; int index = ArrayUtil.UNKNOWN_INDEX; for (int i = 0; i < length; i++) { if (clusterMembers[i].id() == memberId) { index = i; } } return index; } \nResponse:", "ground_truth": "Find the index at which a member id is present.\n\n@param clusterMembers to be searched.\n@param memberId       to search for.\n@return the index at which the member id is found otherwise {@link ArrayUtil#UNKNOWN_INDEX}.", "predict": " public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) { final int length = clusterMembers.length; int index = ArrayUtil.UNKNOWN_INDEX; for (int i = 0; i < length; i++) { if (clusterMembers[i].id() == memberId) { index = i; } } return index; } \n\n*/\n\npublic class FindMemberIndex {\n\tpublic static void main(String[] args) {\n\t\tClusterMember[] clusterMembers = new ClusterMember[] {\n\t\t\t\tnew ClusterMember(1, \"localhost\", 9090),\n\t\t\t\tnew ClusterMember(2, \"localhost\", 9091),\n\t\t\t\tnew ClusterMember(3, \"localhost\", 9092),\n\t\t\t\tnew ClusterMember(4, \"localhost\", 9093),\n\t\t\t\tnew ClusterMember(5, \"localhost\", 9094),\n\t\t\t\tnew ClusterMember(6, \"localhost\", 9095),\n\t\t\t\tnew ClusterMember(7,"}, {"ID": 1912, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClusterMember[] removeMember(final ClusterMember[] oldMembers, final int memberId) { return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId)); } \nResponse:", "ground_truth": "Remove a member from an array if found, otherwise return the array unmodified.\n\n@param oldMembers to remove a member from.\n@param memberId   of the member to remove.\n@return a new array with the member removed or the existing array if not found.", "predict": "\n\n*/\n\npublic class RemoveMember extends AbstractInstruction {\n\tprivate static final String METHOD_NAME = \"removeMember\";\n\tprivate static final String METHOD_NAME_WITH_ARGS = \"removeMember(ClusterMember[] oldMembers, int memberId)\";\n\t\n\tpublic RemoveMember(int lineNumber) {\n\t\tsuper(METHOD_NAME, lineNumber);\n\t}\n\t\n\tpublic RemoveMember(int lineNumber, String className, String methodName, String methodSignature, int parameterCount) {\n\t\tsuper(METHOD_NAME_WITH_ARGS, lineNumber, className, methodName, methodSignature, parameterCount);\n\t}\n\t\n\t@Override\n\tpublic void execute(ClassNode classNode, MethodNode methodNode, Object receiver, Object[] arguments) {\n\t\tif (arguments.length != 2) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of arguments for method '\" + METHOD_NAME"}, {"ID": 1913, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; } \nResponse:", "ground_truth": "Find the highest member id in an array of members.\n\n@param clusterMembers to search for the highest id.\n@return the highest id otherwise {@link Aeron#NULL_VALUE} if empty.", "predict": " public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; } \n */\n\npublic class MethodCommentGenerator {\n    public static void main(final String[] args) {\n        final String className = \"ClusterMember\";\n        final String methodName = \"highMemberId\";\n        final String methodComment = \"Generate the method-level comment for the following java Code. Code: public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; } \";\n        final String methodComment2 = \"Generate the method-level comment for the following java Code. Code: public static int high"}, {"ID": 1914, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MappedByteBuffer mapExistingCncFile(final Consumer<String> logger) { final File cncFile = new File(aeronDirectory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { if (null != logger) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); } return IoUtil.mapExistingFile(cncFile, CncFileDescriptor.CNC_FILE); } return null; } \nResponse:", "ground_truth": "Map the CnC file if it exists.\n\n@param logger for feedback\n@return a new mapping for the file if it exists otherwise null;", "predict": " public void onCncFileExists(final Consumer<String> logger) { if (null != logger) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); } } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class CncFile"}, {"ID": 1915, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isDriverActive( final File directory, final long driverTimeoutMs, final Consumer<String> logger) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } return false; } \nResponse:", "ground_truth": "Is a media driver active in the given directory?\n\n@param directory       to check\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " public static boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger, final MappedByteBuffer cncByteBuffer) { final long cncVersion = CncFileDescriptor.CNC_VERSION; final long cncVersionMask = CncFileDescriptor.CNC_VERSION_MASK; final long cncVersionValue = CncFileDescriptor.CNC_VERSION_VALUE; final long cncVersionOffset = CncFileDescriptor.CNC_VERSION_OFFSET; final long cncVersionSize = CncFileDescriptor.CNC_VERSION_SIZE; final long cncVersionMaskOffset = CncFileDescriptor.CNC_VERSION_MASK_OFFSET; final long cncVersionValueOffset = CncFileDescriptor.CNC_VERSION_VALUE_OFFSET; final long cncVersionSizeOffset = CncFileDescriptor.CNC_VERSION_SIZE_OFFSET; final long cncVersion"}, {"ID": 1916, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger) { final MappedByteBuffer cncByteBuffer = mapExistingCncFile(logger); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } \nResponse:", "ground_truth": "Is a media driver active in the current Aeron directory?\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " Response isDriverActive(final long driverTimeoutMs, final Consumer<String> logger, final MappedByteBuffer cncByteBuffer) { return new Response(cncByteBuffer, driverTimeoutMs, logger); } \n\n*/\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport com.google.common.base.Stopwatch;\n\npublic class Driver {\n\tprivate static final Logger logger = LogManager.getLogger(Driver.class);\n\t\n\tpublic static void main(String[] args) throws IO"}, {"ID": 1917, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isDriverActive( final long driverTimeoutMs, final Consumer<String> logger, final ByteBuffer cncByteBuffer) { if (null == cncByteBuffer) { return false; } final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final long startTimeMs = System.currentTimeMillis(); int cncVersion; while (0 == (cncVersion = cncMetaDataBuffer.getIntVolatile(CncFileDescriptor.cncVersionOffset(0)))) { if (System.currentTimeMillis() > (startTimeMs + driverTimeoutMs)) { throw new DriverTimeoutException(\"CnC file is created but not initialised.\"); } sleep(1); } if (CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long timestamp = toDriverBuffer.consumerHeartbeatTime(); final long now = System.currentTimeMillis(); final long timestampAge = now - timestamp; logger.accept(\"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge); return timestampAge <= driverTimeoutMs; } \nResponse:", "ground_truth": "Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait for\nup to the driverTimeoutMs by checking for the cncVersion being set.\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@param cncByteBuffer   for the existing CnC file.\n@return true if a driver is active or false if not.", "predict": "\n\n*/\n\npackage com.github.ambry.clustermap;\n\nimport com.github.ambry.config.ClusterMapConfig;\nimport com.github.ambry.config.VerifiableProperties;\nimport com.github.ambry.utils.Utils;\nimport java.util.Properties;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Tests for {@link CncUtil}\n */\npublic class CncUtilTest {\n  /**\n   * Tests the {@link CncUtil#getCncVersion(Properties)} method.\n   */\n  @Test\n  public void getCncVersionTest() {\n    Properties properties = new Properties();\n    properties.setProperty(\"cnc.version\", \"1\");\n    assertEquals(1, CncUtil.getCncVersion(properties));\n    properties.setProperty(\""}, {"ID": 1918, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean requestDriverTermination( final File directory, final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final int cncVersion = cncMetaDataBuffer.getIntVolatile(cncVersionOffset(0)); if (CncFileDescriptor.CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long clientId = toDriverBuffer.nextCorrelationId(); final DriverProxy driverProxy = new DriverProxy(toDriverBuffer, clientId); return driverProxy.terminateDriver(tokenBuffer, tokenOffset, tokenLength); } finally { IoUtil.unmap(cncByteBuffer); } } return false; } \nResponse:", "ground_truth": "Request a driver to run its termination hook.\n\n@param directory for the driver.\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return true if request was sent or false if request could not be sent.", "predict": " public static boolean driverProxyError( final long clientId, final long correlationId, final long errorCode, final String errorMessage) { final ResponseProxy responseProxy = new ResponseProxy(correlationId, errorCode, errorMessage); return responseProxy.send(); } \nResp public static boolean driverProxyError( final long clientId, final long correlationId, final long errorCode, final String errorMessage, final int errorCodeExtraInfo, final int errorExtraInfo1, final int errorExtraInfo2) { final ResponseProxy responseProxy = new ResponseProxy(correlationId, errorCode, errorMessage, errorCodeExtraInfo, errorExtraInfo1, errorExtraInfo2); return responseProxy.send(); } \nResp public static boolean driverProxyError( final long clientId, final long correlationId, final long errorCode, final String errorMessage, final int errorCodeExtraInfo, final int errorExtraInfo1, final int errorExtraInfo2, final int errorExtraInfo3) { final ResponseProxy responseProxy ="}, {"ID": 1919, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) { int frameLength = buffer.getIntVolatile(termOffset); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } return frameLength; } \nResponse:", "ground_truth": "Get the length of a frame from the header as a volatile read.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@return the value for the frame length.", "predict": " public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) { int frameLength = buffer.getIntVolatile(termOffset); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } return frameLength; } \n */\n\npublic class VolatileIntTest {\n\n    private static final int PAGE_SIZE = 1024;\n    private static final int BUFFER_SIZE = 128;\n    private static final int TOTAL_BUFFERS = 3;\n    private static final int TERM_BUFFER_LENGTH = PAGE_SIZE * TOTAL_BUFFERS;\n    private static final int BUFFER_LENGTH = BUFFER_SIZE * TOTAL_BUFFERS;\n\n    private static final int TOTAL_FRAMES = 3;\n    private static final int FRAME_LENGTH = BUFFER_LENGTH / TOTAL_FRAMES;\n\n    private static final int TOTAL_BYTES = BU"}, {"ID": 1920, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength) { int length = frameLength; if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { length = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(termOffset, length); } \nResponse:", "ground_truth": "Write the length header for a frame in a memory ordered fashion.\n\n@param buffer      containing the frame.\n@param termOffset  at which a frame begins.\n@param frameLength field to be set for the frame.", "predict": "\n\n*/\n\npublic class FrameLengthOrdered\n{\n    public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength)\n    {\n        int length = frameLength;\n        if (ByteOrder.nativeOrder() != LITTLE_ENDIAN)\n        {\n            length = Integer.reverseBytes(frameLength);\n        }\n\n        buffer.putIntOrdered(termOffset, length);\n    }\n}\n"}, {"ID": 1921, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) { buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the type field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param type       type value for the frame.", "predict": " Resp public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) { buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN); } \n\n*/\n\npublic class FrameType {\n    public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) {\n        buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN);\n    }\n\n    public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) {\n        buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN);\n    }\n}\n"}, {"ID": 1922, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) { buffer.putByte(flagsOffset(termOffset), flags); } \nResponse:", "ground_truth": "Write the flags field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param flags      value for the frame.", "predict": " Resp public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) { buffer.putByte(flagsOffset(termOffset), flags); } \n\n*/\n\npublic class FrameFlags {\n\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) {\n        buffer.putByte(flagsOffset(termOffset), flags);\n    }\n\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags, final int index) {\n        buffer.putByte(flagsOffset(termOffset, index), flags);\n    }\n\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags, final int index, final int index2) {\n        buffer.putByte(flagsOffset(termOffset, index, index2), flags);\n    }\n\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte"}, {"ID": 1923, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) { buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the term offset field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.", "predict": " Resp public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) { buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN); } \n\n*/\n\npublic class FrameTermOffset {\n    public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) {\n        buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN);\n    }\n\n    public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset, final int index) {\n        buffer.putInt(termOffsetOffset(termOffset, index), termOffset, LITTLE_ENDIAN);\n    }\n\n    public static int termOffsetOffset(final int termOffset) {\n        return termOffset * 4;\n    }\n\n    public static int termOffsetOffset(final int termOffset, final int index) {\n        return termOffset * 4 + index * 4;\n"}, {"ID": 1924, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the term id field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param termId     value for the frame.", "predict": " Resp public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); } \n\n*/\n\npublic class FrameHeaderFlyweight {\n    private static final int HEADER_LENGTH = 4;\n    private static final int TERM_ID_FIELD_OFFSET = 0;\n    private static final int TERM_OFFSET_FIELD_OFFSET = 4;\n    private static final int HEADER_OFFSET = 0;\n\n    private final UnsafeBuffer buffer;\n    private final int termOffset;\n    private final int termId;\n\n    public FrameHeaderFlyweight() {\n        this(Unpooled.buffer());\n    }\n\n    public FrameHeaderFlyweight(final UnsafeBuffer buffer) {\n        this(buffer, 0, 0);\n    }\n\n    public FrameHeaderFlyweight(final UnsafeBuffer buffer,"}, {"ID": 1925, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for a stream based on the recording id.\n\n@param countersReader to search within.\n@param recordingId    for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) { return i; } } } return NULL_COUNTER_ID; } \n\n*/\n"}, {"ID": 1926, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for a stream based on the session id.\n\n@param countersReader to search within.\n@param sessionId      for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) { return i; } } } return NULL_COUNTER_ID; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.cassandra.config.CFMetaData;\nimport org.apache.cassandra.config.Column"}, {"ID": 1927, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getRecordingId(final CountersReader countersReader, final int counterId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) { return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET); } } return NULL_RECORDING_ID; } \nResponse:", "ground_truth": "Get the recording id for a given counter id.\n\n@param countersReader to search within.\n@param counterId      for the active recording.\n@return the counter id if found otherwise {@link #NULL_RECORDING_ID}.", "predict": " public static long getRecordingId(final CountersReader countersReader, final int counterId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) { return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET); } } return NULL_RECORDING_ID; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.cassandra.config.CFMetaData;\nimport org.apache.cassandra.config.ColumnDefinition;\nimport org.apache.cassandra.config.Schema;\nimport org.apache.cassandra.db.Column"}, {"ID": 1928, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isActive(final CountersReader countersReader, final int counterId, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); return buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId; } return false; } \nResponse:", "ground_truth": "Is the recording counter still active.\n\n@param countersReader to search within.\n@param counterId      to search for.\n@param recordingId    to confirm it is still the same value.\n@return true if the counter is still active otherwise false.", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.cassandra.config.CFMetaData;\nimport org.apache.cassandra.config.ColumnDefinition;\nimport org.apache.cassandra.config.Schema;\nimport org.apache.cassandra.db.ColumnFamilyStore;\nimport org.apache.cassandra.db.DecoratedKey;\nimport org.apache.cassandra.db.Keyspace;\nimport org.apache.cassandra.db.Mutation;\nimport org.apache.cassandra.db.RowMutation;\nimport org.apache.cassandra.db.filter.QueryFilter;\nimport org.apache.cassandra.db.filter.QueryPath;\nimport org.apache.cassandra.io.sstable.Descriptor;\nimport org.apache.cassandra.io.sstable.SSTable"}, {"ID": 1929, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) { frameLength(HEADER_LENGTH + length); putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length); return this; } \nResponse:", "ground_truth": "Set the Application Specific Feedback for the Status Message.\n\n@param source of the feedback to set\n@param offset of the feedback in the source\n@param length of the feedback in bytes\n@return flyweight", "predict": " public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) { frameLength(HEADER_LENGTH + length); putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length); return this; } \n\n}\n"}, {"ID": 1930, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void reload() { entries.clear(); indexByLeadershipTermIdMap.clear(); indexByLeadershipTermIdMap.compact(); nextEntryIndex = 0; byteBuffer.clear(); try { while (true) { final int bytes = fileChannel.read(byteBuffer); if (byteBuffer.remaining() == 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } if (-1 == bytes) { if (byteBuffer.position() > 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } break; } } } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } } \nResponse:", "ground_truth": "Reload the log from disk.", "predict": "\n\n*/\n\npublic class LeaderboardFileReader {\n    private final FileChannel fileChannel;\n    private final ByteBuffer byteBuffer;\n    private final List<LeaderboardEntry> entries;\n    private final Map<Integer, LeaderboardEntry> indexByLeadershipTermIdMap;\n    private final int nextEntryIndex;\n    private final int bufferSize;\n\n    public LeaderboardFileReader(final FileChannel fileChannel, final int bufferSize) {\n        this.fileChannel = fileChannel;\n        this.byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n        this.entries = new ArrayList<>();\n        this.indexByLeadershipTermIdMap = new HashMap<>();\n        this.nextEntryIndex = 0;\n        this.bufferSize = bufferSize;\n    }\n\n    public void read() {\n        try {\n            while (true) {\n                final int bytes = fileChannel.read(byteBuffer);\n                if ("}, {"ID": 1931, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Entry findLastTerm() { for (int i = entries.size() - 1; i >= 0; i--) { final Entry entry = entries.get(i); if (ENTRY_TYPE_TERM == entry.type) { return entry; } } return null; } \nResponse:", "ground_truth": "Find the last leadership term in the recording log.\n\n@return the last leadership term in the recording log.", "predict": " public Entry findLastTerm() { for (int i = entries.size() - 1; i >= 0; i--) { final Entry entry = entries.get(i); if (ENTRY_TYPE_TERM == entry.type) { return entry; } } return null; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Entry entry = s.new Entry(1, \"a\", Entry.ENTRY_TYPE_TERM);\n        entry = s.new Entry(2, \"b\", Entry.ENTRY_TYPE_TERM);\n        entry = s.new Entry(3, \"c\", Entry.ENTRY_TYPE_TERM);\n        entry = s.new Entry(4, \"d\", Entry.ENTRY_TYPE_TERM);\n        entry = s.new Entry(5, \"e\", Entry.ENTRY_TYPE_TERM);\n        entry ="}, {"ID": 1932, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RecoveryPlan createRecoveryPlan(final AeronArchive archive, final int serviceCount) { final ArrayList<Snapshot> snapshots = new ArrayList<>(); final ArrayList<Log> logs = new ArrayList<>(); planRecovery(snapshots, logs, entries, archive, serviceCount); long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } if (!logs.isEmpty()) { final Log log = logs.get(0); lastLeadershipTermId = log.leadershipTermId; lastTermBaseLogPosition = log.termBaseLogPosition; appendedLogPosition = log.stopPosition; committedLogPosition = log.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, logs); } \nResponse:", "ground_truth": "Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the\nlatest stable state.\n\n@param archive      to lookup recording descriptors.\n@param serviceCount of services that may have snapshots.\n@return a new {@link RecoveryPlan} for the cluster.", "predict": " public void planRecovery(final ArrayList<Snapshot> snapshots, final ArrayList<Log> logs, final ArrayList<Entry> entries, final AeronArchive archive, final int serviceCount) { final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); final long leadershipTermId = snapshot.leadershipTermId; final long termBaseLogPosition = snapshot.termBaseLogPosition; final long logPosition = snapshot.logPosition; final long stopPosition = snapshot.stopPosition; final int snapshotStepsSize = snapshots.size(); for (int i = 0; i < snapshotStepsSize; i++) { final Snapshot snapshot = snapshots.get(i); final long leadershipTermId = snapshot.leadershipTermId; final long termBaseLogPosition = snapshot.termBaseLogPosition; final long logPosition = snapshot.logPosition; final long stopPosition = snapshot.stopPosition; final int snapshotStepsSize"}, {"ID": 1933, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) { long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new ArrayList<>()); } \nResponse:", "ground_truth": "Create a recovery plan that has only snapshots. Used for dynamicJoin snapshot load.\n\n@param snapshots to construct plan from\n@return a new {@link RecoveryPlan} for the cluster", "predict": " public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) { return createRecoveryPlan(snapshots); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RecoveryPlan {\n    private long leadershipTermId;\n    private long termBaseLogPosition;\n    private long logPosition;\n    private List<Snapshot> snapshots;\n    private List<RecoveryPlan> recoveryPlans;\n\n    public RecoveryPlan(long leadershipTermId, long termBaseLogPosition, long logPosition, List<Snapshot> snapshots, List<RecoveryPlan> recoveryPlans) {\n        this.leadershipTermId = leadershipTermId;\n        this.termBaseLogPosition = termBaseLogPosition;\n        this.logPosition = logPosition;\n        this.snapshots = snapshots;\n        this.recoveryPlans = recoveryPlans;\n    }\n\n    public long getLead"}, {"ID": 1934, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void appendTerm( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { final int size = entries.size(); if (size > 0) { final Entry lastEntry = entries.get(size - 1); if (lastEntry.type != NULL_VALUE && lastEntry.leadershipTermId >= leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + lastEntry.leadershipTermId + \" this \" + leadershipTermId); } } indexByLeadershipTermIdMap.put(leadershipTermId, nextEntryIndex); append( ENTRY_TYPE_TERM, recordingId, leadershipTermId, termBaseLogPosition, NULL_POSITION, timestamp, NULL_VALUE); } \nResponse:", "ground_truth": "Append a log entry for a leadership term.\n\n@param recordingId         of the log.\n@param leadershipTermId    for the current term.\n@param termBaseLogPosition reached at the beginning of the term.\n@param timestamp           at the beginning of the term.", "predict": " public void appendTerm( final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { appendTerm(NULL_RECORDING_ID, leadershipTermId, termBaseLogPosition, timestamp); } \nResp public void appendTerm( final long leadershipTermId, final long termBaseLogPosition) { appendTerm(NULL_RECORDING_ID, leadershipTermId, termBaseLogPosition, NULL_POSITION); } \nResp public void appendTerm( final long leadershipTermId) { appendTerm(NULL_RECORDING_ID, leadershipTermId, NULL_POSITION); } \nResp public void appendTerm( final long timestamp) { appendTerm(NULL_RECORDING_ID, NULL_LEADERSHIP_TERM_ID, NULL_POSITION, timestamp); } \nResp public void appendTerm( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { appendTerm(recordingId"}, {"ID": 1935, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) { final Entry entry = entries.get(size - 1); if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + entry.leadershipTermId + \" this \" + leadershipTermId); } } append( ENTRY_TYPE_SNAPSHOT, recordingId, leadershipTermId, termBaseLogPosition, logPosition, timestamp, serviceId); } \nResponse:", "ground_truth": "Append a log entry for a snapshot.\n\n@param recordingId         in the archive for the snapshot.\n@param leadershipTermId    for the current term\n@param termBaseLogPosition at the beginning of the leadership term.\n@param logPosition         for the position in the current term or length so far for that term.\n@param timestamp           at which the snapshot was taken.\n@param serviceId           for which the snapshot is recorded.", "predict": " public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) { final Entry entry = entries.get(size - 1); if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + entry.leadershipTermId + \" this \" + leadershipTermId); } } append( ENTRY_TYPE_SNAPSHOT, recordingId, leadershipTermId, termBaseLogPosition, logPosition, timestamp, serviceId); } \nResp public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) {"}, {"ID": 1936, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commitLogPosition(final long leadershipTermId, final long logPosition) { final int index = getLeadershipTermEntryIndex(leadershipTermId); commitEntryValue(index, logPosition, LOG_POSITION_OFFSET); final Entry entry = entries.get(index); entries.set(index, new Entry( entry.recordingId, entry.leadershipTermId, entry.termBaseLogPosition, logPosition, entry.timestamp, entry.serviceId, entry.type, entry.entryIndex)); } \nResponse:", "ground_truth": "Commit the position reached in a leadership term before a clean shutdown.\n\n@param leadershipTermId for committing the term position reached.\n@param logPosition      reached in the leadership term.", "predict": " CommitLogPositionResponse\n\n*/\n\npackage com.alachisoft.tayzgrid.caching.statistics.customcounters;\n\nimport com.alachisoft.tayzgrid.common.Common;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationDataChunk;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationPointer;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationResult;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationResultBlock;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationResultCollection;\nimport com.alachisoft.tayzgrid.common.datastructures.EnumerationResultCollection.EnumerationResultCollectionResizeListener;\nimport com.alachisoft.tayz"}, {"ID": 1937, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void tombstoneEntry(final long leadershipTermId, final int entryIndex) { int index = -1; for (int i = 0, size = entries.size(); i < size; i++) { final Entry entry = entries.get(i); if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) { index = entry.entryIndex; if (ENTRY_TYPE_TERM == entry.type) { indexByLeadershipTermIdMap.remove(leadershipTermId); } break; } } if (-1 == index) { throw new ClusterException(\"unknown entry index: \" + entryIndex); } buffer.putInt(0, NULL_VALUE, LITTLE_ENDIAN); byteBuffer.limit(SIZE_OF_INT).position(0); final long filePosition = (index * (long)ENTRY_LENGTH) + ENTRY_TYPE_OFFSET; try { if (SIZE_OF_INT != fileChannel.write(byteBuffer, filePosition)) { throw new ClusterException(\"failed to write field atomically\"); } } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } } \nResponse:", "ground_truth": "Tombstone an entry in the log so it is no longer valid.\n\n@param leadershipTermId to match for validation.\n@param entryIndex       reached in the leadership term.", "predict": " public void tombstoneEntry(final long leadershipTermId, final int entryIndex) { int index = -1; for (int i = 0, size = entries.size(); i < size; i++) { final Entry entry = entries.get(i); if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) { index = entry.entryIndex; if (ENTRY_TYPE_TERM == entry.type) { indexByLeadershipTermIdMap.remove(leadershipTermId); } break; } } if (-1 == index) { throw new ClusterException(\"unknown entry index: \" + entryIndex); } buffer.putInt(0, NULL_VALUE, LITTLE_ENDIAN); byteBuffer.limit(SIZE_OF_INT).position(0); final long filePosition = (index * (long)ENTRY_LENGTH) + ENTRY_TYPE_OFFSET; try { if (SIZE_OF_INT != fileChannel.write(byteBuffer"}, {"ID": 1938, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (null != publication && publication.isConnected()) { closeSession(); } if (!ctx.ownsAeronClient()) { CloseHelper.close(subscription); CloseHelper.close(publication); } ctx.close(); } \nResponse:", "ground_truth": "Close session and release associated resources.", "predict": "\n\n*/\n\npackage com.azure.cosmos.implementation.apachecommons.collections;\n\nimport com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\nimport com.azure.cosmos.implementation.apachecommons.lang.SystemUtils;\nimport com.azure.cosmos.implementation.apachecommons.lang.Validate;\nimport com.azure.cosmos.implementation.apachecommons.lang.exception.ExceptionUtils;\nimport com.azure.cosmos.implementation.apachecommons.lang.exception.ExceptionUtils.SuppressedException;\nimport com.azure.cosmos.implementation.apachecommons.lang.exception.ExceptionUtils.WrappedException;\nimport com.azure.cosmos.implementation.apachecommons.lang.exception.ExceptionUtils.WrappedRuntimeException;\nimport com.azure"}, {"ID": 1939, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBufferVector[] vectors) { if (headerVector != vectors[0]) { vectors[0] = headerVector; } return publication.offer(vectors, null); } \nResponse:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message. The first vector will be replaced by the cluster\ningress header so must be left unused.\n\n@param vectors which make up the message.\n@return the same as {@link Publication#offer(DirectBufferVector[])}.\n@see Publication#offer(DirectBufferVector[])", "predict": " public void offer(final DirectBufferVector[] vectors, final PublicationListener listener) { if (headerVector != vectors[0]) { vectors[0] = headerVector; } publication.offer(vectors, listener); } \n\n*/\n\npublic class DirectBufferVector {\n    public static final int SIZE = 8;\n    public static final int SIZE_OF_LONG = 8;\n    public static final int SIZE_OF_DOUBLE = 8;\n    public static final int SIZE_OF_FLOAT = 4;\n    public static final int SIZE_OF_INT = 4;\n    public static final int SIZE_OF_SHORT = 2;\n    public static final int SIZE_OF_BYTE = 1;\n    public static final int SIZE_OF_BOOLEAN = 1;\n    public static final int SIZE_OF_CHAR = 2;\n    public static final int SIZE_OF_BYTE_ARRAY ="}, {"ID": 1940, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean unblock( final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) { final int positionBitsToShift = LogBufferDescriptor.positionBitsToShift(termLength); final int blockedTermCount = (int)(blockedPosition >> positionBitsToShift); final int blockedOffset = (int)blockedPosition & (termLength - 1); final int activeTermCount = activeTermCount(logMetaDataBuffer); if (activeTermCount == (blockedTermCount - 1) && blockedOffset == 0) { final int currentTermId = termId(rawTailVolatile(logMetaDataBuffer, indexByTermCount(activeTermCount))); return rotateLog(logMetaDataBuffer, activeTermCount, currentTermId); } final int blockedIndex = indexByTermCount(blockedTermCount); final long rawTail = rawTailVolatile(logMetaDataBuffer, blockedIndex); final int termId = termId(rawTail); final int tailOffset = termOffset(rawTail, termLength); final UnsafeBuffer termBuffer = termBuffers[blockedIndex]; switch (TermUnblocker.unblock(logMetaDataBuffer, termBuffer, blockedOffset, tailOffset, termId)) { case UNBLOCKED_TO_END: rotateLog(logMetaDataBuffer, blockedTermCount, termId); // fall through case UNBLOCKED: return true; } return false; } \nResponse:", "ground_truth": "Attempt to unblock a log buffer at given position\n\n@param termBuffers       for current blockedOffset\n@param logMetaDataBuffer for log buffer\n@param blockedPosition   to attempt to unblock\n@param termLength        of the buffer for each term in the log\n@return whether unblocked or not", "predict": " public static boolean unblock(final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) { return TermUnblocker.unblock(logMetaDataBuffer, termBuffers[indexByTermCount(blockedPosition)], blockedPosition, termLength); } \n\n}\n"}, {"ID": 1941, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String channel() { final int length = buffer.getInt(offset + CHANNEL_OFFSET); lengthOfChannel = SIZE_OF_INT + length; return buffer.getStringAscii(offset + CHANNEL_OFFSET, length); } \nResponse:", "ground_truth": "Get the channel field as ASCII\n\n@return channel field", "predict": " public void channel(String channel) { buffer.putInt(offset + CHANNEL_OFFSET, channel.length()); buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); } \n*/\n\npublic class Channel {\n\tpublic static final int CHANNEL_OFFSET = 0;\n\tpublic static final int SIZE_OF_INT = 4;\n\tpublic static final int SIZE_OF_STRING = 4;\n\tpublic static final int SIZE_OF_STRING_ASCII = 4;\n\tpublic static final int SIZE_OF_STRING_ASCII_LENGTH = 4;\n\tpublic static final int SIZE_OF_STRING_ASCII_LENGTH_OFFSET = 4;\n\tpublic static final int SIZE_OF_STRING_ASCII_LENGTH_LENGTH = 4;\n\tpublic static final int SIZE_OF_STRING_ASCII_LENGTH_OFFSET_L"}, {"ID": 1942, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ImageMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; } \nResponse:", "ground_truth": "Set the channel field as ASCII\n\n@param channel field value\n@return flyweight", "predict": " public ImageMessageFlyweight channel(final String channel) { return channel(channel, offset + CHANNEL_OFFSET); } \nResp public ImageMessageFlyweight channel(final String channel, final int offset) { lengthOfChannel = buffer.putStringAscii(offset, channel); return this; } \nResp public ImageMessageFlyweight channel(final String channel, final int offset, final int length) { lengthOfChannel = buffer.putStringAscii(offset, channel, length); return this; } \nResp public ImageMessageFlyweight channel(final String channel, final int offset, final int length, final int padding) { lengthOfChannel = buffer.putStringAscii(offset, channel, length, padding); return this; } \nResp public ImageMessageFlyweight channel(final String channel, final int offset, final int length, final int padding, final int alignment) { lengthOfChannel = buffer.putStringAscii(offset, channel, length, padding"}, {"ID": 1943, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkTermLength(final int termLength) { if (termLength < TERM_MIN_LENGTH) { throw new IllegalStateException( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength); } if (termLength > TERM_MAX_LENGTH) { throw new IllegalStateException( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength); } if (!BitUtil.isPowerOfTwo(termLength)) { throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength); } } \nResponse:", "ground_truth": "Check that term length is valid and alignment is valid.\n\n@param termLength to be checked.\n@throws IllegalStateException if the length is not as expected.", "predict": "\n\n*/\n\npublic class TermLengthChecker {\n    public static void checkTermLength(final int termLength) {\n        if (termLength < TERM_MIN_LENGTH) {\n            throw new IllegalStateException(\"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength);\n        }\n        if (termLength > TERM_MAX_LENGTH) {\n            throw new IllegalStateException(\"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength);\n        }\n        if (!BitUtil.isPowerOfTwo(termLength)) {\n            throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength);\n        }\n    }\n}\n"}, {"ID": 1944, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkPageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new IllegalStateException( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new IllegalStateException( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize); } } \nResponse:", "ground_truth": "Check that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws IllegalStateException if the size is not as expected.", "predict": "\n\n*/\n\npublic class PageSizeChecker {\n    public static void checkPageSize(final int pageSize) {\n        if (pageSize < PAGE_MIN_SIZE) {\n            throw new IllegalStateException(\"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize);\n        }\n        if (pageSize > PAGE_MAX_SIZE) {\n            throw new IllegalStateException(\"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize);\n        }\n        if (!BitUtil.isPowerOfTwo(pageSize)) {\n            throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize);\n        }\n    }\n}\n"}, {"ID": 1945, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean casActiveTermCount( final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) { return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount); } \nResponse:", "ground_truth": "Compare and set the value of the current active term count.\n\n@param metadataBuffer    containing the meta data.\n@param expectedTermCount value of the active term count expected in the log\n@param updateTermCount   value of the active term count to be updated in the log\n@return true if successful otherwise false.", "predict": " public static boolean casActiveTermCount( final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) { return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount); } \n\n*/\n\npublic class LogAppenderMetadataCodec {\n\n    public static final int LOG_ACTIVE_TERM_COUNT_OFFSET = 0;\n    public static final int LOG_ACTIVE_TERM_COUNT_MASK = 0xFFFF_FFFFL;\n\n    public static final int LOG_ACTIVE_TERM_COUNT_OFFSET_MASK = 0xFFFF_FFFFL;\n    public static final int LOG_ACTIVE_TERM_COUNT_MASK_MASK = 0xFFFF_FFFFL;\n\n    public static final int LOG_ACTIVE_TERM_COUNT_OFFSET_SHIFT = 32;\n    "}, {"ID": 1946, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long computePosition( final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId) { final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover return (termCount << positionBitsToShift) + termOffset; } \nResponse:", "ground_truth": "Compute the current position in absolute number of bytes.\n\n@param activeTermId        active term id.\n@param termOffset          in the term.\n@param positionBitsToShift number of times to left shift the term count\n@param initialTermId       the initial term id that this stream started on\n@return the absolute position in bytes", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1947, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long computeLogLength(final int termLength, final int filePageSize) { if (termLength < (1024 * 1024 * 1024)) { return align((termLength * PARTITION_COUNT) + LOG_META_DATA_LENGTH, filePageSize); } return (PARTITION_COUNT * (long)termLength) + align(LOG_META_DATA_LENGTH, filePageSize); } \nResponse:", "ground_truth": "Compute the total length of a log file given the term length.\n\nAssumes {@link #TERM_MAX_LENGTH} is 1GB and that filePageSize is 1GB or less and a power of 2.\n\n@param termLength   on which to base the calculation.\n@param filePageSize to use for log.\n@return the total length of the log file.", "predict": "\n\n*/\n\npackage com.baidubce.services.cdn.model.domain;\n\nimport com.baidubce.auth.BceCredentials;\nimport com.baidubce.model.AbstractBceRequest;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\n\n/**\n * The request for getting domain log.\n */\npublic class GetDomainLogRequest extends AbstractBceRequest {\n\n    /**\n     * The id of domain.\n     */\n    @JsonIgnore\n    private String domainId;\n\n    /**\n     * The id of log.\n     */\n    private String logId;\n\n    /**\n     * The id of log type.\n     */\n    private String logType;\n\n    /**\n     * The id of log start time.\n     */\n    private String startTime;\n\n    /**\n     * The id of log end time.\n     */\n    private String end"}, {"ID": 1948, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) { if (defaultHeader.capacity() != HEADER_LENGTH) { throw new IllegalArgumentException( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity()); } metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH); metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH); } \nResponse:", "ground_truth": "Store the default frame header to the log meta data buffer.\n\n@param metadataBuffer into which the default headers should be stored.\n@param defaultHeader  to be stored.\n@throws IllegalArgumentException if the defaultHeader larger than {@link #LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH}", "predict": " public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) { if (defaultHeader.capacity() != HEADER_LENGTH) { throw new IllegalArgumentException( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity()); } metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH); metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH); } \n\n*/\n\npublic class LogDefaultFrameHeader\n{\n    public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader)\n    {\n        if (defaultHeader.capacity() != HEADER_LENGTH)\n        {\n            throw new IllegalArgumentException(\n                \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader."}, {"ID": 1949, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void applyDefaultHeader( final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) { termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH); } \nResponse:", "ground_truth": "Apply the default header for a message in a term.\n\n@param metadataBuffer containing the default headers.\n@param termBuffer     to which the default header should be applied.\n@param termOffset     at which the default should be applied.", "predict": " public static void applyDefaultHeader( final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) { termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH); } \n\n*/\n\npublic class LogDefaultFrameHeaderGenerator {\n\n    public static void generate(final int termOffset, final int termLength, final int headerLength, final UnsafeBuffer termBuffer, final UnsafeBuffer metadataBuffer) {\n\n        metadataBuffer.putInt(termOffset, termLength, LogHeaderFlyweight.TERM_OFFSET);\n        metadataBuffer.putInt(termOffset + LogHeaderFlyweight.TERM_LENGTH_OFFSET, termLength, LogHeaderFlyweight.TERM_LENGTH_MASK);\n        metadataBuffer.putInt(termOffset + LogHeaderFlyweight.SESSION_ID_OFFSET, 0, LogHeaderFlyweight.SESSION_ID_MAS"}, {"ID": 1950, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = indexByTermCount(nextTermCount); final int expectedTermId = nextTermId - PARTITION_COUNT; long rawTail; do { rawTail = rawTail(metadataBuffer, nextIndex); if (expectedTermId != termId(rawTail)) { break; } } while (!casRawTail(metadataBuffer, nextIndex, rawTail, packTail(nextTermId, 0))); return casActiveTermCount(metadataBuffer, termCount, nextTermCount); } \nResponse:", "ground_truth": "Rotate the log and update the tail counter for the new term.\n\nThis method is safe for concurrent use.\n\n@param metadataBuffer for the log.\n@param termCount      from which to rotate.\n@param termId         to be used in the default headers.\n@return true if log was rotated.", "predict": " public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = indexByTermCount(nextTermCount); final int expectedTermId = nextTermId - PARTITION_COUNT; long rawTail; do { rawTail = rawTail(metadataBuffer, nextIndex); if (expectedTermId != termId(rawTail)) { break; } } while (!casRawTail(metadataBuffer, nextIndex, rawTail, packTail(nextTermId, 0))); return casActiveTermCount(metadataBuffer, termCount, nextTermCount); } \nResp public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = index"}, {"ID": 1951, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void initialiseTailWithTermId( final UnsafeBuffer metadataBuffer, final int partitionIndex, final int termId) { metadataBuffer.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0)); } \nResponse:", "ground_truth": "Set the initial value for the termId in the upper bits of the tail counter.\n\n@param metadataBuffer contain the tail counter.\n@param partitionIndex to be initialised.\n@param termId         to be set.", "predict": " Response = {\n    code = 0,\n    message = \"OK\"\n}\n\n*/\n\npackage com.persinity.common.db;\n\nimport static com.persinity.common.StringUtils.format;\n\nimport java.util.Arrays;\n\nimport com.persinity.common.collection.DirectedEdge;\nimport com.persinity.common.collection.Pool;\nimport com.persinity.common.collection.PooledObject;\nimport com.persinity.common.collection.PooledObjectFactory;\nimport com.persinity.common.collection.PooledObjectPool;\nimport com.persinity.common.logging.Log4jLogger;\nimport com.persinity.common.logging.Log4jLoggerFactory;\n\n/**\n * @author Ivan Dachev\n */\npublic class TailCounter {\n\n    /**\n     * @param termId\n     * @param termOffset\n     * @return\n     */"}, {"ID": 1952, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int termOffset(final long rawTail, final long termLength) { final long tail = rawTail & 0xFFFF_FFFFL; return (int)Math.min(tail, termLength); } \nResponse:", "ground_truth": "Read the termOffset from a packed raw tail value.\n\n@param rawTail    containing the termOffset.\n@param termLength that the offset cannot exceed.\n@return the termOffset value.", "predict": " Resp public static int termOffset(final long rawTail, final long termLength) { final long tail = rawTail & 0xFFFF_FFFFL; return (int)Math.min(tail, termLength); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static int termOffset(long rawTail, long termLength) {\n        long tail = rawTail & 0xFFFF_FFFFL;\n        return (int)Math.min(tail, termLength);\n    }\n}\n"}, {"ID": 1953, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) { final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer)); return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex)); } \nResponse:", "ground_truth": "Get the raw value of the tail for the current active partition.\n\n@param metadataBuffer containing the tail counters.\n@return the raw value of the tail for the current active partition.", "predict": " public static long tailVolatile(final UnsafeBuffer metadataBuffer) { final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer)); return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex)); } \n\n*/\n\npublic class TermTailVolatile {\n\n    public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) {\n        final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer));\n        return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex));\n    }\n\n    public static long tailVolatile(final UnsafeBuffer metadataBuffer) {\n        final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer));\n        return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET +"}, {"ID": 1954, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean casRawTail( final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) { final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex); return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail); } \nResponse:", "ground_truth": "Compare and set the raw value of the tail for the given partition.\n\n@param metadataBuffer  containing the tail counters.\n@param partitionIndex  for the tail counter.\n@param expectedRawTail expected current value.\n@param updateRawTail   to be applied.\n@return true if the update was successful otherwise false.", "predict": " public static boolean casRawTail( final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) { final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex); return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail); } \n\n*/\n\npublic class TermTailCounters\n{\n    public static final int SIZE_OF_LONG = 8;\n    public static final int SIZE_OF_INT = 4;\n    public static final int SIZE_OF_SHORT = 2;\n    public static final int SIZE_OF_BYTE = 1;\n    public static final int SIZE_OF_FLOAT = 4;\n    public static final int SIZE_OF_DOUBLE = 8;\n    public static final int SIZE_OF_DOUBLE_WITH_"}, {"ID": 1955, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public TerminateDriverFlyweight tokenBuffer( final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength); if (null != tokenBuffer && tokenLength > 0) { buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength); } return this; } \nResponse:", "ground_truth": "Fill the token buffer.\n\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return flyweight", "predict": " public TerminateDriverFlyweight tokenBuffer( final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength); if (null != tokenBuffer && tokenLength > 0) { buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength); } return this; } \n\n}\n"}, {"ID": 1956, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) { tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId); tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition); tempBuffer.putLong(TIMESTAMP_OFFSET, timestamp); tempBuffer.putInt(REPLAY_FLAG_OFFSET, hasReplay ? 1 : 0); final int serviceCount = snapshotRecordingIds.length; tempBuffer.putInt(SERVICE_COUNT_OFFSET, serviceCount); final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + (serviceCount * SIZE_OF_LONG); if (keyLength > MAX_KEY_LENGTH) { throw new ClusterException(keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH); } for (int i = 0; i < serviceCount; i++) { tempBuffer.putLong(SNAPSHOT_RECORDING_IDS_OFFSET + (i * SIZE_OF_LONG), snapshotRecordingIds[i]); } final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putLongAscii(keyLength + labelLength, leadershipTermId); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" logPosition=\"); labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, logPosition); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" hasReplay=\" + hasReplay); return aeron.addCounter(RECOVERY_STATE_TYPE_ID, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength); } \nResponse:", "ground_truth": "Allocate a counter to represent the snapshot services should load on start.\n\n@param aeron                to allocate the counter.\n@param tempBuffer           to use for building the key and label without allocation.\n@param leadershipTermId     at which the snapshot was taken.\n@param logPosition          at which the snapshot was taken.\n@param timestamp            the snapshot was taken.\n@param hasReplay            flag is true if all or part of the log must be replayed.\n@param snapshotRecordingIds for the services to use during recovery indexed by service id.\n@return the {@link Counter} for the recovery state.", "predict": " public static Counter allocate(final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) { return allocate(aeron, tempBuffer, leadershipTermId, logPosition, timestamp, hasReplay, snapshotRecordingIds); }\n\n}\n"}, {"ID": 1957, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterId(final CountersReader counters) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for recovery state.\n\n@param counters to search within.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " public static int findCounterId(final CountersReader counters) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return i; } } } return NULL_COUNTER_ID; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.cassandra.io.util.FileUtils;\nimport org.apache.cassandra.utils.ByteBufferUtil;\nimport org.apache.cassandra.utils.FBUtilities;\nimport org.apache.cassandra.utils.UUIDGen"}, {"ID": 1958, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasReplay(final CountersReader counters, final int counterId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1; } } return false; } \nResponse:", "ground_truth": "Has the recovery process got a log to replay?\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@return true if a replay is required.", "predict": " public static boolean hasReplay(final CountersReader counters, final int counterId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1; } } return false; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.cassandra.io.util.FileUtils;\nimport org.apache.cassandra.utils.ByteBufferUtil;\nimport org.apache.cassandra.utils.FBUtilities;\nimport org.apache.cassandra.utils.UUIDGen;\n"}, {"ID": 1959, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET); if (serviceId < 0 || serviceId >= serviceCount) { throw new ClusterException(\"invalid serviceId \" + serviceId + \" for count of \" + serviceCount); } return buffer.getLong( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + (serviceId * SIZE_OF_LONG)); } } throw new ClusterException(\"Active counter not found \" + counterId); } \nResponse:", "ground_truth": "Get the recording id of the snapshot for a service.\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@param serviceId for the snapshot required.\n@return the count of replay terms if found otherwise {@link Aeron#NULL_VALUE}.", "predict": " public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET); if (serviceId < 0 || serviceId >= serviceCount) { throw new ClusterException(\"invalid serviceId \" + serviceId + \" for count of \" + serviceCount); } return buffer.getLong( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + (serviceId * SIZE_OF_LONG)); } } throw new ClusterException(\"Active counter"}, {"ID": 1960, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] flagsToChars(final short flags) { final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' }; final int length = chars.length; short mask = (short)(1 << (length - 1)); for (int i = 0; i < length; i++) { if ((flags & mask) == mask) { chars[i] = '1'; } mask >>= 1; } return chars; } \nResponse:", "ground_truth": "Convert header flags to an array of chars to be human readable.\n\n@param flags to be converted.\n@return header flags converted to an array of chars to be human readable.", "predict": "\npublic static char[] flagsToChars(final short flags) { final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' }; final int length = chars.length; short mask = (short)(1 << (length - 1)); for (int i = 0; i < length; i++) { if ((flags & mask) == mask) { chars[i] = '1'; } mask >>= 1; } return chars; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.flagsToChars(0));\n        System.out.println(s.flagsToChars(1));\n        System.out.println(s.flagsToChars(2));\n        System.out.println(s.flagsToChars(3));\n        System.out"}, {"ID": 1961, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PublicationMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; } \nResponse:", "ground_truth": "Set the channel field in ASCII\n\n@param channel field value\n@return flyweight", "predict": " public PublicationMessageFlyweight channel(final String channel) { return channel(channel, offset); } \n*/\n\npublic class PublicationMessageFlyweight extends AbstractFlyweight {\n    private static final int CHANNEL_OFFSET = 0;\n    private static final int SOURCE_OFFSET = 4;\n    private static final int PAYLOAD_OFFSET = 8;\n    private static final int PAYLOAD_LENGTH_OFFSET = 12;\n    private static final int PAYLOAD_LENGTH = 4;\n\n    private final int offset;\n    private final int length;\n\n    public PublicationMessageFlyweight(final ByteBuf buffer, final int offset) {\n        super(buffer);\n        this.offset = offset;\n        this.length = buffer.getInt(offset + PAYLOAD_LENGTH_OFFSET);\n    }\n\n    public PublicationMessageFlyweight(final ByteBuf buffer, final int offset, final int length) {\n        super(buffer);\n        this.offset"}, {"ID": 1962, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBuffer buffer, final int offset, final int length) { return cluster.offer(id, responsePublication, buffer, offset, length); } \nResponse:", "ground_truth": "Non-blocking publish of a partial buffer containing a message to a cluster.\n\n@param buffer containing message.\n@param offset offset in the buffer at which the encoded message begins.\n@param length in bytes of the encoded message.\n@return the same as {@link Publication#offer(DirectBuffer, int, int)} when in {@link Cluster.Role#LEADER}\notherwise {@link #MOCKED_OFFER}.", "predict": " public void offer(final DirectBuffer buffer, final int offset, final int length, final Header header) { cluster.offer(id, responsePublication, buffer, offset, length, header); } \nResp public void offer(final DirectBuffer buffer, final int offset, final int length, final Header header, final PublicationControl control) { cluster.offer(id, responsePublication, buffer, offset, length, header, control); } \nResp public void offer(final DirectBuffer buffer, final int offset, final int length, final Header header, final PublicationControl control, final long correlationId) { cluster.offer(id, responsePublication, buffer, offset, length, header, control, correlationId); } \nResp public void offer(final DirectBuffer buffer, final int offset, final int length, final Header header, final PublicationControl control, final long correlationId, final long clientId) { cluster.offer(id, responsePublication, buffer, offset, length, header, control, correlationId"}, {"ID": 1963, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void wrap(final AtomicBuffer buffer, final int offset, final int length) { this.buffer.wrap(buffer, offset, length); } \nResponse:", "ground_truth": "Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.\n\n@param buffer to be wrapped.\n@param offset at which the claimed region begins including space for the header.\n@param length length of the underlying claimed region including space for the header.", "predict": " Resp public final void wrap(final AtomicBuffer buffer, final int offset, final int length) { this.buffer.wrap(buffer, offset, length); } \n\n*/\n\npublic class AtomicBufferWrapper {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tAtomicBufferWrapper wrapper = new AtomicBufferWrapper();\n\t\t\n\t\tAtomicBuffer buffer = new AtomicBuffer(new byte[100]);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap(buffer, 0, 100);\n\t\t\n\t\twrapper.wrap("}, {"ID": 1964, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void commit() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); } \nResponse:", "ground_truth": "Commit the message to the log buffer so that is it available to subscribers.", "predict": " Response = new Response(buffer.toByteArray());\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolEncoderOutput;\nimport org.apache.mina.filter.codec.textline.TextLineEncoder;\n\npublic class TextLineEncoderTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tTextLineEncoder encoder = new TextLineEncoder();\n\t\tencoder.setCharset(\"UTF-8\");\n\t\tencoder.setLineLength(64);\n\t\tencoder.setEol(\"\\r\\n\");\n\t\t\n\t\tIoSession session = new TestIoSession();\n\t\t\n\t\tProtocolEncoderOutput out = encoder."}, {"ID": 1965, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void abort() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_PAD, LITTLE_ENDIAN); buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); } \nResponse:", "ground_truth": "Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.", "predict": "\n    public final void abort() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_PAD, LITTLE_ENDIAN); buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); } \n    */\n    public static final int HDR_TYPE_PAD = 0x00;\n    public static final int HDR_TYPE_PAD_LEN = 2;\n    public static final int HDR_TYPE_PAD_OFFSET = 0;\n    public static final int HDR_TYPE_PAD_LEN_OFFSET = HDR_TYPE_PAD_OFFSET + HDR_TYPE_PAD_LEN;\n    public static final int HDR_TYPE_PAD_LEN_LEN = 2;\n    "}, {"ID": 1966, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(final String[] args) { loadPropertiesFiles(args); final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier(); final MediaDriver.Context ctx = new MediaDriver.Context(); ctx.terminationHook(barrier::signal); try (MediaDriver ignore = MediaDriver.launch(ctx)) { barrier.await(); System.out.println(\"Shutdown Driver...\"); } } \nResponse:", "ground_truth": "Start Media Driver as a stand-alone process.\n\n@param args command line arguments", "predict": "\n\n*/\n\nimport java.util.Properties;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.retry.RetryForever;\nimport org.apache.curator.test.TestingServer;\nimport org.apache.curator.x.discovery.ServiceDiscovery;\nimport org.apache.curator.x.discovery.ServiceDiscoveryBuilder;\nimport org.apache.curator.x.discovery.ServiceInstance;\nimport org.apache.curator.x.discovery.details"}, {"ID": 1967, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { CloseHelper.close(sharedRunner); CloseHelper.close(sharedNetworkRunner); CloseHelper.close(receiverRunner); CloseHelper.close(senderRunner); CloseHelper.close(conductorRunner); CloseHelper.close(sharedInvoker); if (ctx.useWindowsHighResTimer() && SystemUtil.osName().startsWith(\"win\")) { if (!wasHighResTimerEnabled) { HighResolutionTimer.disable(); } } } \nResponse:", "ground_truth": "Shutdown the media driver by stopping all threads and freeing resources.", "predict": " Response = Response.ok();\n\n*/\n\npublic class CloseHelper {\n    public static void close(final Object o) {\n        if (o != null) {\n            try {\n                o.getClass().getMethod(\"close\").invoke(o);\n            } catch (final Exception e) {\n                // ignore\n            }\n        }\n    }\n}\n"}, {"ID": 1968, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final long position() { final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT); return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId); } \nResponse:", "ground_truth": "Get the current position to which the image has advanced on reading this message.\n\n@return the current position to which the image has advanced on reading this message.", "predict": " public final long position() { return position; }\n\n*/\n\npublic final long position() {\n\tfinal int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT);\n\treturn computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId);\n}\n\n}\n"}, {"ID": 1969, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) { tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId); final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId); return aeron.addCounter( SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength); } \nResponse:", "ground_truth": "Allocate a counter to represent the heartbeat of a clustered service.\n\n@param aeron           to allocate the counter.\n@param tempBuffer      to use for building the key and label without allocation.\n@param serviceId       of the service heartbeat.\n@return the {@link Counter} for the commit position.", "predict": " public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) { tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId); final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId); return aeron.addCounter( SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength); } \n\n*/\n"}, {"ID": 1970, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterId(final CountersReader counters, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for heartbeat of a given service id.\n\n@param counters  to search within.\n@param serviceId to search for.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " public static int findCounterId(final CountersReader counters, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) { return i; } } } return NULL_COUNTER_ID; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.cassandra.config.CFMetaData;\nimport org.apache.cassandra.config.ColumnDefinition;\nimport org.apache.c"}, {"ID": 1971, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<StreamCompositeKey, StreamBacklog> snapshot() { final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamBacklog streamBacklog = streams.computeIfAbsent(key, (ignore) -> new StreamBacklog()); final long registrationId = keyBuffer.getLong(REGISTRATION_ID_OFFSET); final long value = counters.getCounterValue(counterId); switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().limit(value); break; case PublisherPos.PUBLISHER_POS_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().position(value); break; case SenderPos.SENDER_POSITION_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().position(value); break; case SenderLimit.SENDER_LIMIT_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().limit(value); break; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().highWaterMark(value); break; case ReceiverPos.RECEIVER_POS_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().position(value); break; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: streamBacklog.subscriberBacklogs().put(registrationId, new Subscriber(value)); break; } } }); return streams; } \nResponse:", "ground_truth": "Take a snapshot of all the backlog information and group by stream.\n\n@return a snapshot of all the backlog information and group by stream.", "predict": " public Map<StreamCompositeKey, StreamBacklog> snapshot() { final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamBacklog streamBacklog = streams.computeIfAbsent(key, (ignore) -> new StreamBacklog());"}, {"ID": 1972, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) { return new AtomicCounter( countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager); } \nResponse:", "ground_truth": "Allocate a counter for tracking the last heartbeat of an entity.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@return a new {@link AtomicCounter} for tracking the last heartbeat.", "predict": " public static int allocateCounterId(final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) { return countersManager.allocateCounterId(tempBuffer, name, typeId, registrationId); } \n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.cassandra.db.marshal.AsciiType;\nimport org.apache.cassandra.db.marshal.UTF8Type;\nimport org.apache.cassandra.thrift.Cassandra;\nimport org.apache.cassandra.thrift.Column;\nimport org.apache.cassandra.thrift.ColumnOrSuperColumn;\nimport org.apache.cassandra.thrift.ColumnParent;\nimport org.apache.cassandra.thrift.ColumnPath;\n"}, {"ID": 1973, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { final MappedByteBuffer cncByteBuffer = this.cncByteBuffer; this.cncByteBuffer = null; IoUtil.unmap(cncByteBuffer); super.close(); } \nResponse:", "ground_truth": "Clean up all resources that the client uses to communicate with the Media Driver.", "predict": " Response is generated by the framework. It is not supposed to be modified by the user.\n */\n\npublic class Close extends AbstractInstruction {\n    public Close() {\n        super(0x0E);\n    }\n\n    public void execute(ExecutionNode node) throws Exception {\n        node.getOutput().close();\n    }\n}\n"}, {"ID": 1974, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void dispatchDescriptor( final RecordingDescriptorDecoder decoder, final RecordingDescriptorConsumer consumer) { consumer.onRecordingDescriptor( decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity()); } \nResponse:", "ground_truth": "Dispatch a descriptor message to a consumer by reading the fields in the correct order.\n\n@param decoder  which wraps the encoded message ready for reading.\n@param consumer to which the decoded fields should be passed.", "predict": " Generate the method-level comment for the following java Code. Code: public static void dispatchRecording( final RecordingConsumer consumer, final RecordingDescriptorDecoder decoder) { consumer.onRecording( decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity()); } \nResp Generate the method-level comment for the following java Code. Code: public static void dispatchRecording( final RecordingConsumer consumer, final RecordingDescriptorDecoder decoder) { consumer.onRecording( decoder.controlSessionId(), decoder.correlationId(), dec"}, {"ID": 1975, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addSlab(int minimumSize) { int nextSlabSize; if (bytesUsed == 0) { nextSlabSize = initialSlabSize; } else if (bytesUsed > maxCapacityHint / 5) { // to avoid an overhead of up to twice the needed size, we get linear when approaching target page size nextSlabSize = maxCapacityHint / 5; } else { // double the size every time nextSlabSize = bytesUsed; } if (nextSlabSize < minimumSize) { LOG.debug(\"slab size {} too small for value of size {}. Bumping up slab size\", nextSlabSize, minimumSize); nextSlabSize = minimumSize; } LOG.debug(\"used {} slabs, adding new slab of size {}\", slabs.size(), nextSlabSize); this.currentSlab = allocator.allocate(nextSlabSize); this.slabs.add(currentSlab); this.bytesAllocated += nextSlabSize; this.currentSlabIndex = 0; } \nResponse:", "ground_truth": "the new slab is guaranteed to be at least minimumSize\n@param minimumSize the size of the data we want to copy in the new slab", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.base.Preconditions;\n\npublic class SlabAllocator {\n\tprivate static final Logger LOG = Logger.getLogger(SlabAllocator.class);\n\tprivate final int initialSlabSize;\n\tprivate final int maxCapacityHint;\n\tprivate final int maxSlabs;\n\tprivate final int slabSize;\n\tprivate final AtomicInteger slabCount = new AtomicInteger(0);\n\tprivate final List<Slab> slabs = new ArrayList<Slab>();\n\tprivate Slab currentSlab;\n\tprivate int currentSlabIndex;\n\tprivate int bytesAllocated;\n\n\tpublic SlabAllocator(int initialSlabSize, int maxCap"}, {"ID": 1976, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setByte(long index, byte value) { checkArgument(index < bytesUsed, \"Index: \" + index + \" is >= the current size of: \" + bytesUsed); long seen = 0; for (int i = 0; i < slabs.size(); i++) { ByteBuffer slab = slabs.get(i); if (index < seen + slab.limit()) { // ok found index slab.put((int)(index-seen), value); break; } seen += slab.limit(); } } \nResponse:", "ground_truth": "Replace the byte stored at position index in this stream with value\n\n@param index which byte to replace\n@param value the value to replace it with", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.cassandra.config.CFMetaData;\nimport org.apache.cassandra.config.ColumnDefinition;\nimport org.apache.cassandra.config.DatabaseDescriptor;\nimport org.apache.cassandra.config.KSMetaData;\nimport org.apache.cassandra.config.Schema;\nimport org.apache.cassandra.db.ColumnFamilyStore;\nimport org.apache.cassandra.db.DecoratedKey;\nimport org.apache.cassandra.db.Keyspace;\nimport org.apache.cassandra.db.RowMutation;\nimport org.apache.cassandra.db.Table;\nimport org.apache.cassandra.db.filter.QueryFilter;\nimport org.apache"}, {"ID": 1977, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Statistics<?> stats) { if (stats.hasNonNullValue()) { nullPages.add(false); Object min = stats.genericGetMin(); Object max = stats.genericGetMax(); addMinMax(min, max); pageIndexes.add(nextPageIndex); minMaxSize += sizeOf(min); minMaxSize += sizeOf(max); } else { nullPages.add(true); } nullCounts.add(stats.getNumNulls()); ++nextPageIndex; } \nResponse:", "ground_truth": "Adds the data from the specified statistics to this builder\n\n@param stats\nthe statistics to be added", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.apache.drill.exec.expr.holders.NullableVarCharHolder;\nimport org.apache.drill.exec.expr.holders.VarCharHolder;\nimport org.apache.drill.exec.record.RecordBatchSizer;\nimport org.apache.drill.exec.record.RecordBatchSizer.ColSize;\nimport org.apache.drill.exec.record.RecordBatchSizer.ColSize.ColSizeType;\nimport org.apache.drill.exec.record.RecordBatchSizer.ColSize.ColSizeUnits;\nimport org.apache.drill.exec.record.RecordBatchSizer.ColSize.ColSizeUnits.ColSizeUnit;\nimport org.apache.drill.exec"}, {"ID": 1978, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) { return filter.accept(new FilterCompat.Visitor<RowRanges>() { @Override public RowRanges visit(FilterPredicateCompat filterPredicateCompat) { try { return filterPredicateCompat.getFilterPredicate() .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount)); } catch (MissingOffsetIndexException e) { LOGGER.info(e.getMessage()); return RowRanges.createSingle(rowCount); } } @Override public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) { return RowRanges.createSingle(rowCount); } @Override public RowRanges visit(NoOpFilter noOpFilter) { return RowRanges.createSingle(rowCount); } }); } \nResponse:", "ground_truth": "Calculates the row ranges containing the indexes of the rows might match the specified filter.\n\n@param filter\nto be used for filtering the rows\n@param columnIndexStore\nthe store for providing column/offset indexes\n@param paths\nthe paths of the columns used in the actual projection; a column not being part of the projection will be\nhandled as containing {@code null} values only even if the column has values written in the file\n@param rowCount\nthe total number of rows in the row-group\n@return the ranges of the possible matching row indexes; the returned ranges will contain all the rows if any of\nthe required offset index is missing", "predict": " public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) { return filter.accept(new FilterCompat.Visitor<RowRanges>() { @Override public RowRanges visit(FilterPredicateCompat filterPredicateCompat) { try { return filterPredicateCompat.getFilterPredicate() .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount)); } catch (MissingOffsetIndexException e) { LOGGER.info(e.getMessage()); return RowRanges.createSingle(rowCount); } } @Override public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) { return RowRanges.createSingle(rowCount); } @Override public RowRanges visit(NoOpFilter noOpFilter) { return RowRanges.createSingle(rowCount); } }); } \n"}, {"ID": 1979, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo) { final TypeInfo subType = typeInfo.getListElementTypeInfo(); return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType(\"array_element\", subType))); } \nResponse:", "ground_truth": "1 anonymous element \"array_element\"", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.parquet.schema.Type;\nimport org.apache.parquet.schema.Type.Repetition;\nimport org.apache.parquet.schema.Types;\n\npublic class ParquetHiveSerDe {\n\tpublic static Type listType() {\n\t\treturn Types.list(Types.primitive(Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.BINARY, \"element\"));\n\t}\n\t\n\tpublic static Type mapType() {\n\t\treturn Types.map(Types.primitive(Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.BINARY, \"key\"), Types.primitive(Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.BINARY, \"value\"));\n\t}\n\t\n\tpublic static Type arrayType() {\n"}, {"ID": 1980, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) { final List<String> columnNames = typeInfo.getAllStructFieldNames(); final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos(); return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes)); } \nResponse:", "ground_truth": "An optional group containing multiple elements", "predict": " Response = {\n    \"status\": \"OK\",\n    \"result\": {\n        \"name\": \"test\",\n        \"type\": \"struct\",\n        \"fields\": [\n            {\n                \"name\": \"name\",\n                \"type\": \"string\",\n                \"mapping\": \"name\"\n            },\n            {\n                \"name\": \"age\",\n                \"type\": \"int\",\n                \"mapping\": \"age\"\n            }\n        ]\n    }\n}\n\n*/\n\npackage com.baidu.palo.catalog;\n\nimport com.baidu.palo.thrift.TTableDescriptor;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class ColumnType {\n    public static final ColumnType NULL_TYPE = new ColumnType(Type.NULL_TYPE);\n    public static final ColumnType B"}, {"ID": 1981, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String annotateMessage(String message, int pos) { StringBuilder sb = new StringBuilder(message); sb.append('\\n'); for (int i = 0; i < pos; i++) { sb.append('-'); } sb.append('^'); return sb.toString(); } \nResponse:", "ground_truth": "for pretty printing which character had the error", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int[] result = new int[m];\n        for(int i = 0; i < m; i++){\n            result[i] = in.nextInt();\n        }\n        int[] result2 = new int[n];\n        for(int i = 0; i < n; i++){\n            result2[i] = in.nextInt();\n        }\n        int[] result3 = new int[m];\n        for(int i = 0; i <"}, {"ID": 1982, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void endPreviousBitPackedRun() { if (bitPackedRunHeaderPointer == -1) { // we're not currently in a bit-packed-run return; } // create bit-packed-header, which needs to fit in 1 byte byte bitPackHeader = (byte) ((bitPackedGroupCount << 1) | 1); // update this byte baos.setByte(bitPackedRunHeaderPointer, bitPackHeader); // mark that this run is over bitPackedRunHeaderPointer = -1; // reset the number of groups bitPackedGroupCount = 0; } \nResponse:", "ground_truth": "If we are currently writing a bit-packed-run, update the\nbit-packed-header and consider this run to be over\n\ndoes nothing if we're not currently writing a bit-packed run", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec"}, {"ID": 1983, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void readOne(TProtocol in, TProtocol out) throws TException { readOneStruct(in, out); } \nResponse:", "ground_truth": "reads one record from in and writes it to out\nexceptions are not recoverable as record might be halfway written\n@param in input protocol\n@param out output protocol\n@throws TException if there is an error while reading or writing", "predict": " @Override public void writeOne(TProtocol oprot) throws TException { writeOneStruct(oprot); } \n\n@Override public void readOneStruct(TProtocol in, TProtocol out) throws TException {\n  TMemoryInputTransport memoryTransport = new TMemoryInputTransport(in.getBuffer());\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil.skip(in, TType.STRUCT);\n  TProtocolUtil"}, {"ID": 1984, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException { return readFooters(configuration, pathStatus, false); } \nResponse:", "ground_truth": "this always returns the row groups\n@param configuration a configuration\n@param pathStatus a file status to read footers from\n@return a list of footers\n@throws IOException if an exception is thrown while reading the footers\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 1985, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException { final Path parent = summaryStatus.getPath().getParent(); ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false)); return footersFromSummaryFile(parent, mergedFooters); } \nResponse:", "ground_truth": "Specifically reads a given summary file\n@param configuration a configuration\n@param summaryStatus file status for a summary file\n@return the metadata translated for each file\n@throws IOException if an exception is thrown while reading the summary file\n@deprecated metadata files are not recommended and will be removed in 2.0.0", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output."}, {"ID": 1986, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException { ParquetReadOptions options; if (file instanceof HadoopInputFile) { options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration()) .withMetadataFilter(filter).build(); } else { options = ParquetReadOptions.builder().withMetadataFilter(filter).build(); } try (SeekableInputStream in = file.newStream()) { return readFooter(file, options, in); } } \nResponse:", "ground_truth": "Reads the meta data block in the footer of the file using provided input stream\n@param file a {@link InputFile} to read\n@param filter the filter to apply to row groups\n@return the metadata blocks in the footer\n@throws IOException if an error occurs while reading the file\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": "\n\n*/\n\npackage com.facebook.presto.hive.parquet.reader;\n\nimport com.facebook.presto.hive.HiveColumnHandle;\nimport com.facebook.presto.hive.HivePartitionKey;\nimport com.facebook.presto.hive.HiveRecordCursor;\nimport com.facebook.presto.hive.HiveRecordCursorProvider;\nimport com.facebook.presto.hive.HiveType;\nimport com.facebook.presto.hive.HiveUtil;\nimport com.facebook.presto.hive.parquet.HdfsParquetDataSource;\nimport com.facebook.presto.hive.parquet.ParquetCorruptionException;\nimport com.facebook.presto.hive.parquet.ParquetDataSource;\nimport com.facebook.presto.hive.parquet"}, {"ID": 1987, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PageReadStore readNextRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } this.currentRowGroup = new ColumnChunkPageReadStore(block.getRowCount()); // prepare the list of consecutive parts to read them in one scan List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); BenchmarkCounter.incrementTotalBytes(mc.getTotalSize()); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { long startingPos = mc.getStartingPos(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } currentParts.addChunk(new ChunkDescriptor(columnDescriptor, mc, startingPos, (int)mc.getTotalSize())); } } // actually read all the chunks ChunkListBuilder builder = new ChunkListBuilder(); for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; } \nResponse:", "ground_truth": "Reads all the columns requested from the row group at the current file position.\n@throws IOException if an error occurs while reading\n@return the PageReadStore which can provide PageReaders for each column.", "predict": " public void close() throws IOException { if (nextDictionaryReader != null) { nextDictionaryReader.close(); } } \n\n}\n"}, {"ID": 1988, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PageReadStore readNextFilteredRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } if (!options.useColumnIndexFilter()) { return readNextRowGroup(); } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } ColumnIndexStore ciStore = getColumnIndexStore(currentBlock); RowRanges rowRanges = getRowRanges(currentBlock); long rowCount = rowRanges.rowCount(); if (rowCount == 0) { // There are no matching rows -> skipping this row-group advanceToNextBlock(); return readNextFilteredRowGroup(); } if (rowCount == block.getRowCount()) { // All rows are matching -> fall back to the non-filtering path return readNextRowGroup(); } this.currentRowGroup = new ColumnChunkPageReadStore(rowRanges); // prepare the list of consecutive parts to read them in one scan ChunkListBuilder builder = new ChunkListBuilder(); List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { OffsetIndex offsetIndex = ciStore.getOffsetIndex(mc.getPath()); OffsetIndex filteredOffsetIndex = filterOffsetIndex(offsetIndex, rowRanges, block.getRowCount()); for (OffsetRange range : calculateOffsetRanges(filteredOffsetIndex, mc, offsetIndex.getOffset(0))) { BenchmarkCounter.incrementTotalBytes(range.getLength()); long startingPos = range.getOffset(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } ChunkDescriptor chunkDescriptor = new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) range.getLength()); currentParts.addChunk(chunkDescriptor); builder.setOffsetIndex(chunkDescriptor, filteredOffsetIndex); } } } // actually read all the chunks for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; } \nResponse:", "ground_truth": "Reads all the columns requested from the row group at the current file position. It may skip specific pages based\non the column indexes according to the actual filter. As the rows are not aligned among the pages of the different\ncolumns row synchronization might be required. See the documentation of the class SynchronizingColumnReader for\ndetails.\n\n@return the PageReadStore which can provide PageReaders for each column\n@throws IOException\nif any I/O error occurs while reading", "predict": " public void close() throws IOException { if (nextDictionaryReader != null) { nextDictionaryReader.close(); } } \n}\n"}, {"ID": 1989, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException { if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) { return null; } // TODO: this should use getDictionaryPageOffset() but it isn't reliable. if (f.getPos() != meta.getStartingPos()) { f.seek(meta.getStartingPos()); } PageHeader pageHeader = Util.readPageHeader(f); if (!pageHeader.isSetDictionary_page_header()) { return null; // TODO: should this complain? } DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f); BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec()); return new DictionaryPage( decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()), compressedPage.getDictionarySize(), compressedPage.getEncoding()); } \nResponse:", "ground_truth": "Reads and decompresses a dictionary page for the given column chunk.\n\nReturns null if the given column chunk has no dictionary page.\n\n@param meta a column's ColumnChunkMetaData to read the dictionary from\n@return an uncompressed DictionaryPage or null\n@throws IOException if there is an error while reading the dictionary", "predict": " DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException { if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) { return null; } // TODO: this should use getDictionaryPageOffset() but it isn't reliable. if (f.getPos() != meta.getStartingPos()) { f.seek(meta.getStartingPos()); } PageHeader pageHeader = Util.readPageHeader(f); if (!pageHeader.isSetDictionary_page_header()) { return null; // TODO: should this complain? } DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f); BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec()); return new DictionaryPage( decompressor.decompress(compressedPage.getBytes(),"}, {"ID": 1990, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) { Long oldValue = writerList.get(writer); if (oldValue == null) { writerList.put(writer, allocation); } else { throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer); } updateAllocation(); } \nResponse:", "ground_truth": "Add a new writer and its memory allocation to the memory manager.\n@param writer the new created writer\n@param allocation the requested buffer size", "predict": " void\n\n*/\n\npublic class ParquetMemoryManager {\n  private final Map<InternalParquetRecordWriter, Long> writerList = new HashMap<>();\n  private final long maxAllocation;\n  private long currentAllocation = 0;\n\n  public ParquetMemoryManager(long maxAllocation) {\n    this.maxAllocation = maxAllocation;\n  }\n\n  public synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) {\n    if (writerList.containsKey(writer)) {\n      throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer);\n    }\n    writerList.put(writer, allocation);\n    updateAllocation();\n  }\n\n  public synchronized void removeWriter(InternalParquetRecordWriter writer) {\n    writerList.remove(writer);\n    "}, {"ID": 1991, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: synchronized void removeWriter(InternalParquetRecordWriter writer) { if (writerList.containsKey(writer)) { writerList.remove(writer); } if (!writerList.isEmpty()) { updateAllocation(); } } \nResponse:", "ground_truth": "Remove the given writer from the memory manager.\n@param writer the writer that has been closed", "predict": " void\n\n*/\n\npublic class RemoveWriterInstruction extends Instruction {\n  private final String writerId;\n\n  public RemoveWriterInstruction(String writerId) {\n    this.writerId = writerId;\n  }\n\n  @Override\n  public void execute(ExecutionContext executionContext) throws Exception {\n    executionContext.removeWriter(writerId);\n  }\n\n  @Override\n  public String toString() {\n    return \"RemoveWriterInstruction{\" +\n        \"writerId='\" + writerId + '\\'' +\n        '}';\n  }\n}\n"}, {"ID": 1992, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void updateAllocation() { long totalAllocations = 0; for (Long allocation : writerList.values()) { totalAllocations += allocation; } if (totalAllocations <= totalMemoryPool) { scale = 1.0; } else { scale = (double) totalMemoryPool / totalAllocations; LOG.warn(String.format( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\", 100*memoryPoolRatio, totalMemoryPool, 100*scale, writerList.size())); for (Runnable callBack : callBacks.values()) { // we do not really want to start a new thread here. callBack.run(); } } int maxColCount = 0; for (InternalParquetRecordWriter w : writerList.keySet()) { maxColCount = Math.max(w.getSchema().getColumns().size(), maxColCount); } for (Map.Entry<InternalParquetRecordWriter, Long> entry : writerList.entrySet()) { long newSize = (long) Math.floor(entry.getValue() * scale); if(scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation) { throw new ParquetRuntimeException(String.format(\"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\", newSize, minMemoryAllocation)){}; } entry.getKey().setRowGroupSizeThreshold(newSize); LOG.debug(String.format(\"Adjust block size from %,d to %,d for writer: %s\", entry.getValue(), newSize, entry.getKey())); } } \nResponse:", "ground_truth": "Update the allocated size of each writer based on the current allocations and pool size.", "predict": "\n\n*/\n\npackage org.apache.parquet.hadoop.metadata;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.column.Encoding;\nimport org.apache.parquet.column.page.DictionaryPage;\nimport org.apache.parquet.column.page.PageWriteStore;\nimport org.apache.parquet.column.page.PageWriter;\nimport org.apache.parquet.column.statistics.Statistics;\nimport org.apache.parquet.hadoop.ParquetFileWriter;\nimport org.apache.parquet.hadoop.metadata.ColumnChunkMetaData.ColumnType;\nimport org.apache.parquet.io.api.Binary;\nimport"}, {"ID": 1993, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks.put(callBackName, callBack); } } \nResponse:", "ground_truth": "Register callback and deduplicate it if any.\n@param callBackName the name of callback. It should be identical.\n@param callBack the callback passed in from upper layer, such as Hive.", "predict": " public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks.put(callBackName, callBack); } } \nResp public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks"}, {"ID": 1994, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() throws IOException { state = state.start(); LOG.debug(\"{}: start\", out.getPos()); out.write(MAGIC); } \nResponse:", "ground_truth": "start the file\n@throws IOException if there is an error while writing", "predict": " public void start() throws IOException { state = state.start(); LOG.debug(\"{}: start\", out.getPos()); out.write(MAGIC); } \n\n*/\n\npublic class JavaGenerator {\n\t\n\tprivate static final Logger LOG = LoggerFactory.getLogger(JavaGenerator.class);\n\t\n\tprivate static final String MAGIC = \"// Generated by the JavaGenerator tool. Code: \";\n\t\n\tprivate final String packageName;\n\tprivate final String className;\n\tprivate final String classNameLowerCase;\n\tprivate final String classNameUpperCase;\n\tprivate final String classNameLowerCaseWithDots;\n\tprivate final String classNameUpperCaseWithDots;\n\tprivate final String classNameLowerCaseWithDotsAndLowerCaseFirstLetter;\n\tprivate final String classNameUpperCaseWithDotsAndLowerCaseFirstLetter;\n\tprivate final String classNameLowerCaseWithDotsAndLowerCase"}, {"ID": 1995, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startBlock(long recordCount) throws IOException { state = state.startBlock(); LOG.debug(\"{}: start block\", out.getPos()); // out.write(MAGIC); // TODO: add a magic delimiter alignment.alignForRowGroup(out); currentBlock = new BlockMetaData(); currentRecordCount = recordCount; currentColumnIndexes = new ArrayList<>(); currentOffsetIndexes = new ArrayList<>(); } \nResponse:", "ground_truth": "start a block\n@param recordCount the record count in this block\n@throws IOException if there is an error while writing", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.drill.exec.memory.BufferAllocator;\nimport org.apache.drill.exec.memory.OutOfMemoryException;\nimport org.apache.drill.exec.ops.FragmentContext;\nimport org.apache.drill.exec.ops.OperatorContext;\nimport org.apache.drill.exec.physical.impl.OutputMutator;\nimport org.apache.drill.exec.record.MaterializedField;\nimport org.apache.drill.exec.record.RecordBatch;\nimport org.apache.drill.exec.record.RecordBatch.IterOutcome;\nimport org.apache.drill.exec.record.TypedFieldId;\nimport org.apache.drill.exec.record.VectorWrapper;\nimport org.apache."}, {"ID": 1996, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException { state = state.startColumn(); encodingStatsBuilder.clear(); currentEncodings = new HashSet<Encoding>(); currentChunkPath = ColumnPath.get(descriptor.getPath()); currentChunkType = descriptor.getPrimitiveType(); currentChunkCodec = compressionCodecName; currentChunkValueCount = valueCount; currentChunkFirstDataPage = out.getPos(); compressedLength = 0; uncompressedLength = 0; // The statistics will be copied from the first one added at writeDataPage(s) so we have the correct typed one currentStatistics = null; columnIndexBuilder = ColumnIndexBuilder.getBuilder(currentChunkType, columnIndexTruncateLength); offsetIndexBuilder = OffsetIndexBuilder.getBuilder(); firstPageOffset = -1; } \nResponse:", "ground_truth": "start a column inside a block\n@param descriptor the column descriptor\n@param valueCount the value count in this column\n@param compressionCodecName a compression codec name\n@throws IOException if there is an error while writing", "predict": " public void endColumn() throws IOException { if (state == state.startColumn()) { writeDataPage(currentChunkPath, currentChunkType, currentChunkCodec, currentChunkValueCount, currentChunkFirstDataPage, currentEncodings, currentStatistics, currentChunkFirstRowGroupOffset, currentChunkLastRowGroupOffset, offsetIndexBuilder, compressedLength, uncompressedLength, columnIndexBuilder, currentChunkLastRowGroupOffset, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal, currentChunkLastRowGroupOrdinal,"}, {"ID": 1997, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException { state = state.write(); LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize()); currentChunkDictionaryPageOffset = out.getPos(); int uncompressedSize = dictionaryPage.getUncompressedSize(); int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts metadataConverter.writeDictionaryPageHeader( uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out); long headerSize = out.getPos() - currentChunkDictionaryPageOffset; this.uncompressedLength += uncompressedSize + headerSize; this.compressedLength += compressedPageSize + headerSize; LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize); dictionaryPage.getBytes().writeAllTo(out); encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding()); currentEncodings.add(dictionaryPage.getEncoding()); } \nResponse:", "ground_truth": "writes a dictionary page page\n@param dictionaryPage the dictionary page\n@throws IOException if there is an error while writing", "predict": "\n\n*/\n"}, {"ID": 1998, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeDataPage( int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException { long beforeHeader = out.getPos(); innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding); offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount); } \nResponse:", "ground_truth": "Writes a single page\n@param valueCount count of values\n@param uncompressedPageSize the size of the data once uncompressed\n@param bytes the compressed data for the page without header\n@param statistics the statistics of the page\n@param rowCount the number of rows in the page\n@param rlEncoding encoding of the repetition level\n@param dlEncoding encoding of the definition level\n@param valuesEncoding encoding of values\n@throws IOException if any I/O error occurs during writing the file", "predict": " public void writeDataPageV2( int rowCount, int compressedSize, int uncompressedSize, BytesInput compressed, BytesInput uncompressed, int valueCount, Statistics statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding, Encoding dictionaryEncoding, byte[] dictionaryBuffer) throws IOException { long beforeHeader = out.getPos(); innerWriteDataPageV2(rowCount, compressedSize, uncompressedSize, compressed, uncompressed, valueCount, statistics, rlEncoding, dlEncoding, valuesEncoding, dictionaryEncoding, dictionaryBuffer); offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount); } \nResp public void writeDictionaryPage(BytesInput dictionary, int valueCount, Statistics statistics) throws IOException { long beforeHeader = out.getPos(); innerWriteDictionaryPage(dictionary, valueCount, statistics); offsetIndexBuilder.add((int) (out.getPos()"}, {"ID": 1999, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void writeColumnChunk(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IOException { startColumn(descriptor, valueCount, compressionCodecName); state = state.write(); if (dictionaryPage != null) { writeDictionaryPage(dictionaryPage); } LOG.debug(\"{}: write data pages\", out.getPos()); long headersSize = bytes.size() - compressedTotalPageSize; this.uncompressedLength += uncompressedTotalPageSize + headersSize; this.compressedLength += compressedTotalPageSize + headersSize; LOG.debug(\"{}: write data pages content\", out.getPos()); firstPageOffset = out.getPos(); bytes.writeAllTo(out); encodingStatsBuilder.addDataEncodings(dataEncodings); if (rlEncodings.isEmpty()) { encodingStatsBuilder.withV2Pages(); } currentEncodings.addAll(rlEncodings); currentEncodings.addAll(dlEncodings); currentEncodings.addAll(dataEncodings); currentStatistics = totalStats; this.columnIndexBuilder = columnIndexBuilder; this.offsetIndexBuilder = offsetIndexBuilder; endColumn(); } \nResponse:", "ground_truth": "Writes a column chunk at once\n@param descriptor the descriptor of the column\n@param valueCount the value count in this column\n@param compressionCodecName the name of the compression codec used for compressing the pages\n@param dictionaryPage the dictionary page for this column chunk (might be null)\n@param bytes the encoded pages including page headers to be written as is\n@param uncompressedTotalPageSize total uncompressed size (without page headers)\n@param compressedTotalPageSize total compressed size (without page headers)\n@param totalStats accumulated statistics for the column chunk\n@param columnIndexBuilder the builder object for the column index\n@param offsetIndexBuilder the builder object for the offset index\n@param rlEncodings the RL encodings used in this column chunk\n@param dlEncodings the DL encodings used in this column chunk\n@param dataEncodings the data encodings used in this column chunk\n@throws IOException if there is an error while writing", "predict": "\n    public void startRowGroup(long rowCount) throws IOException { startRow(rowCount); }\n    public void startRow(long rowCount) throws IOException { state = state.startRow(); }\n    public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException { startColumn(descriptor, valueCount, compressionCodecName, null, null, null, null, null, null, null, null, null); }\n    public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IO"}, {"ID": 2000, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void endBlock() throws IOException { state = state.endBlock(); LOG.debug(\"{}: end block\", out.getPos()); currentBlock.setRowCount(currentRecordCount); blocks.add(currentBlock); columnIndexes.add(currentColumnIndexes); offsetIndexes.add(currentOffsetIndexes); currentColumnIndexes = null; currentOffsetIndexes = null; currentBlock = null; } \nResponse:", "ground_truth": "ends a block once all column chunks have been written\n@throws IOException if there is an error while writing", "predict": "\n\n*/\n\npublic class BlockGenerator {\n\t\n\tprivate static final Logger LOG = LoggerFactory.getLogger(BlockGenerator.class);\n\t\n\tprivate final int blockSize;\n\tprivate final int blockCount;\n\tprivate final int blockSizeInBytes;\n\tprivate final int blockCountInBytes;\n\tprivate final int blockSizeInRows;\n\tprivate final int blockCountInRows;\n\tprivate final int blockSizeInColumns;\n\tprivate final int blockCountInColumns;\n\tprivate final int blockSizeInColumnsPerRow;\n\tprivate final int blockCountInColumnsPerRow;\n\tprivate final int blockSizeInColumnsPerBlock;\n\tprivate final int blockCountInColumnsPerBlock;\n\tprivate final int blockSizeInRowsPerBlock;\n\tprivate final int blockCountInRowsPerBlock;\n\tprivate final int blockSizeInRowsPerColumn;\n\tprivate final int blockCount"}, {"ID": 1, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = downstream; final SimplePlainQueue<U> q = queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); } \nResponse:", "ground_truth": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "predict": "\npublic final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = this.downstream; final SimplePlainQueue<U> q = this.queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); } \n */\n"}, {"ID": 2, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public static <T> Observable<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); } \nResponse:", "ground_truth": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n\nScheduler:\n{@code wrap} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "predict": " Response<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); } \n\n*/\n"}, {"ID": 3, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Observable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\"); return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "predict": " @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody) { return toObservable().map(responseBody::toResponse); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer) { return toObservable().map(responseBody::toResponse).transform(transformer); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer, ErrorHandler errorHandler) { return toObservable().map(responseBody::toResponse).transform(transformer, errorHandler); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Observable<Response<R>> toResponse(ResponseBody responseBody, ResponseTransformer transformer"}, {"ID": 4, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); } \nResponse:", "ground_truth": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "\n\npublic static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Function;\nimport io.reactivex.internal.functions.ObjectHelper;\nimport io.reactivex.internal.subscriptions.SubscriptionHelper;\nimport io.reactivex.plugins.RxJavaPlugins;\n\npublic final class Replay<T> extends"}, {"ID": 5, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "predict": " @NonNull UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\n                \"/*\\n\" +\n                \" * Copyright (c) 2017-present, Facebook, Inc.\\n\" +\n                \" * All rights reserved.\\n\" +\n                \" *\\n\" +\n                \" * This source code is licensed under the BSD-style license found in the\\n\" +\n                \" * LICENSE file in the root directory of this source tree. An additional grant\\n\" +\n                \" * of patent rights can be found in the PATENTS file in the same directory.\\n\" +\n                \" *\\n\" +\n                \" */\\n\" +\n                \"\\n\" +\n                \"package com.facebook.fresco.sample"}, {"ID": 6, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) { ObjectHelper.requireNonNull(onCancelled, \"onTerminate\"); return new UnicastProcessor<T>(capacityHint, onCancelled); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "predict": " @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \nResp @NonNull public static <T> UnicastProcessor<T> create() { return new UnicastProcessor<T>(); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier) { return new UnicastProcessor<T>(supplier); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier, @NonNull Consumer<? super T> onSuccess) { return new UnicastProcessor<T>(supplier, onSuccess); } \nResp @NonNull public static <T> UnicastProcessor<T> create(@NonNull Supplier<? extends T> supplier, @NonNull Consumer<? super T>"}, {"ID": 7, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (u == null) { EmptySubscription.complete(subscriber); return true; } subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u)); } else { r.subscribe(subscriber); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param  the input value type\n@param  the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "predict": "\n\n@SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u;"}, {"ID": 8, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into a Publisher and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "predict": "\n\nimport static org.reactivestreams.Publisher.*;\n\nimport java.util.concurrent.Flowable;\n\nimport org.reactivestreams.Publisher;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Function;\n\npublic final class ScalarXMapFlowable<T, U> extends Flowable<U> {\n    final T value;\n    final Function<? super T, ? extends Publisher<? extends U>> mapper;\n\n    public ScalarXMapFlowable(T value, Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        this.value = value;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public void subscribeActual(Subscriber<? super U> s) {\n        Publisher<? extends U> p;\n        try {\n            p = ObjectHelper.requireNonNull(mapper.apply(value),"}, {"ID": 9, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { setErrorHandler(null); setScheduleHandler(null); setComputationSchedulerHandler(null); setInitComputationSchedulerHandler(null); setIoSchedulerHandler(null); setInitIoSchedulerHandler(null); setSingleSchedulerHandler(null); setInitSingleSchedulerHandler(null); setNewThreadSchedulerHandler(null); setInitNewThreadSchedulerHandler(null); setOnFlowableAssembly(null); setOnFlowableSubscribe(null); setOnObservableAssembly(null); setOnObservableSubscribe(null); setOnSingleAssembly(null); setOnSingleSubscribe(null); setOnCompletableAssembly(null); setOnCompletableSubscribe(null); setOnConnectableFlowableAssembly(null); setOnConnectableObservableAssembly(null); setOnMaybeAssembly(null); setOnMaybeSubscribe(null); setOnParallelAssembly(null); setFailOnNonBlockingScheduler(false); setOnBeforeBlocking(null); } \nResponse:", "ground_truth": "Removes all handlers and resets to default behavior.", "predict": "\n\n*/\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n"}, {"ID": 10, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); } \nResponse:", "ground_truth": "Wraps a CompletableSource into a Maybe.\n\n\nScheduler:\n{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "predict": " Response<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); } \n\n*/\n\nimport io.reactivex.annotations.CheckReturnValue;\nimport io.reactivex.annotations.NonNull;\nimport io.reactivex.functions.Function;\nimport java.util.concurrent.Callable;\n\npublic final class MaybeFromCompletable<T> extends Single<T> {\n\n    final CompletableSource source;\n\n    public MaybeFromCompletable(CompletableSource source) {\n        this.source = source;\n    }\n\n    @Override\n    @CheckReturnValue\n    @NonNull\n    protected SingleSource<T> apply(@NonNull SingleSource<T> t) {\n        return t"}, {"ID": 11, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) { ObjectHelper.requireNonNull(singleSource, \"singleSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource)); } \nResponse:", "ground_truth": "Wraps a SingleSource into a Maybe.\n\n\nScheduler:\n{@code fromSingle} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "predict": " Response<T> fromSingle(SingleSource<T> singleSource) { return RxJavaPlugins.onAssembly(new SingleToResponse<T>(singleSource)); } \n\n*/\n\n/**\n * Generated from RxJava2Plugins-3.x.x/RxJava/Single/toMaybe.java.\n */\npublic class MaybeToMaybe<T> extends SingleToMaybe<T> {\n    public MaybeToMaybe(SingleSource<T> source) {\n        super(source);\n    }\n}\n"}, {"ID": 12, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); } \nResponse:", "ground_truth": "Retries at most times or until the predicate returns false, whichever happens first.\n\n\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "predict": " @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(long times) { return toFlowable().retry(times).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry() { return toFlowable().retry().singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> retry(Predicate<? super Throwable> predicate) { return toFlowable().retry(predicate).singleElement(); } \nResp @SchedulerSupport(SchedulerSupport.NONE) public"}, {"ID": 13, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T requireNonNull(T object, String message) { if (object == null) { throw new NullPointerException(message); } return object; } \nResponse:", "ground_truth": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param  the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "predict": "\n\npublic static <T> T requireNonNull(T object, String message) {\n    if (object == null) {\n        throw new NullPointerException(message);\n    }\n    return object;\n}\n\n*/\n\nimport java.util.Objects;\n\npublic class JavaCodeGenerator {\n\n    public static void main(String[] args) {\n        JavaCodeGenerator generator = new JavaCodeGenerator();\n        generator.generateJavaCode();\n    }\n\n    public void generateJavaCode() {\n        String className = \"JavaCodeGenerator\";\n        String packageName = \"com.example.java.generator\";\n        String classNameWithPackage = packageName + \".\" + className;\n        String classNameWithPackageLowerCase = packageName + \".\" + className.toLowerCase();\n        String classNameWithPackageUpperCase = packageName + \".\" + className.toUpperCase();\n        String class"}, {"ID": 14, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; } \nResponse:", "ground_truth": "Returns an identity function that simply returns its argument.\n@param  the input and output value type\n@return the identity function", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 15, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); } \nResponse:", "ground_truth": "Returns a Callable that returns the given value.\n@param  the value type\n@param value the value to return\n@return the new Callable instance", "predict": "\n\npublic static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); }\n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Callable<String> callable = new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"Hello World\";\n            }\n        };\n        Future<String> future = executor.submit(call"}, {"ID": 16, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); } \nResponse:", "ground_truth": "Returns a Function that ignores its parameter and returns the given value.\n@param  the function's input type\n@param  the value and return type of the function\n@param value the value to return\n@return the new Function instance", "predict": "\n\npublic static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); }\n\n*/\n\npublic class JustValue<T, U> implements Function<T, U> {\n    private final U value;\n\n    public JustValue(U value) {\n        this.value = value;\n    }\n\n    @Override\n    public U apply(T t) {\n        return value;\n    }\n}\n"}, {"ID": 17, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); } \nResponse:", "ground_truth": "Returns a function that cast the incoming values via a Class object.\n@param  the input value type\n@param  the output and target type\n@param target the target class\n@return the new Function instance", "predict": "\n\npublic static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); }\n\n*/\n\npublic class CastToClass<T, U> implements Function<T, U> {\n    private Class<U> target;\n\n    public CastToClass(Class<U> target) {\n        this.target = target;\n    }\n\n    @Override\n    public U apply(T t) {\n        return (U) t;\n    }\n}\n"}, {"ID": 18, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param  the value type\n@return an UnicastSubject instance", "predict": " @NonNull UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); } \n\n*/\n\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int bufferSize, boolean delayError) {\n        super(bufferSize, delayError);\n    }\n\n    @Override\n    public void onNext(T t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onError(Throwable t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onComplete() {\n        if (compareAndSet(null, null)) {\n            drain();\n        }\n    }\n\n    @Override\n    public boolean hasObservers() {\n        return s.get()"}, {"ID": 19, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "predict": " @NonNull UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); } \n */\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int capacityHint, boolean delayError) {\n        super(new UnicastSubjectInner<T>(capacityHint, delayError));\n    }\n}\n"}, {"ID": 20, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "predict": " @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); } \n */\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    final int capacityHint;\n    final Runnable onTerminate;\n    final boolean hasSubscribers;\n\n    public UnicastSubject(int capacityHint, Runnable onTerminate, boolean hasSubscribers) {\n        super(new UnicastSubjectInner<T>(capacityHint, onTerminate, hasSubscribers));\n        this.capacityHint = capacityHint;\n        this.onTerminate = onTerminate;\n        this.hasSubscribers = hasSubscribers;\n    }\n\n    @Override\n    public int getBufferSize() {\n        return capacityHint;\n    }\n\n    @Override\n"}, {"ID": 21, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\nHistory: 2.0.8 - experimental\n@param  the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "predict": " @NonNull UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); } \n\n*/\n\npublic class UnicastSubject<T> extends Subject<T, T> {\n\n    public UnicastSubject(int bufferSize, boolean delayError) {\n        super(bufferSize, delayError);\n    }\n\n    @Override\n    public void onNext(T t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onError(Throwable t) {\n        if (compareAndSet(null, t)) {\n            drain();\n        }\n    }\n\n    @Override\n    public void onComplete() {\n        if (compareAndSet(null, null)) {\n            drain();\n        }\n    }\n\n    @Override\n    public boolean hasObservers() {\n"}, {"ID": 22, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError() { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); await(); } catch (InterruptedException ex) { dispose(); return ex; } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "predict": " public void setError(Throwable error) { this.error = error; } \nResp public void setCount(int count) { this.count = count; } \nResp public int getCount() { return count; } \nResp public void setBlockingHelper(BlockingHelper helper) { this.helper = helper; } \nResp public BlockingHelper getBlockingHelper() { return helper; } \nResp public void setError(String error) { this.error = error; } \nResp public String getError() { return error; } \nResp public void setCount(String count) { this.count = count; } \nResp public String getCount() { return count; } \nResp public void setBlockingHelper(String helper) { this.helper = helper; } \nResp public String getBlockingHelper() { return helper; } \nResp public void setError(String error, Throwable t"}, {"ID": 23, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "predict": " public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; } \n\n}\n"}, {"ID": 24, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; } \nResponse:", "ground_truth": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "predict": " public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; } \n\n}\n"}, {"ID": 25, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\")); return; } } missed = qd.leave(-missed); if (missed == 0) { break; } } } \nResponse:", "ground_truth": "Drain the queue but give up with an error if there aren't enough requests.\n@param  the queue value type\n@param  the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "predict": "\npublic static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException"}, {"ID": 26, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void request(Subscription s, int prefetch) { s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch); } \nResponse:", "ground_truth": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 27, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } } \nResponse:", "ground_truth": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n\nDon't modify the queue after calling this method!\n\n\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param  the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "predict": " public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } } \nResp public static <T> void postComplete(Subscriber<? super T> actual,"}, {"ID": 28, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } } \nResponse:", "ground_truth": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "predict": " public final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } } \nResp public final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazy"}, {"ID": 29, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; } \nResponse:", "ground_truth": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "predict": " @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceArrayFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerArrayFieldUpdater;\nimport java.util.concurrent.atomic"}, {"ID": 30, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; } \nResponse:", "ground_truth": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "predict": " @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; } \n\n*/\n\npublic class GenerateNotificationLite {\n\n    public static void main(String[] args) {\n        String className = \"Test\";\n        String packageName = \"com.example\";\n        String classNameWithPackage = packageName + \".\" + className;\n        String classNameWithPackageLower = packageName.toLowerCase() + \".\" + className;\n        String classNameWithPackageUpper = packageName.toUpperCase() + \".\" + className;\n        String classNameWithPackageLowerUpper = packageName.toUpperCase() + \".\" + className.toUpperCase();\n        String classNameWithPackageLowerLower = packageName.toLowerCase() + \".\" + className.toLowerCase();\n        "}, {"ID": 31, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "predict": " public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \n\n*/\n\npublic class ObservableDisposableTest {\n\n    @Test\n    public void testObservable() {\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n        \n        Observable.just(1, 2, 3)\n        .subscribe(ts);\n        \n        ts.assertValues(1, 2, 3)\n        .assertNoErrors()\n        .assertComplete();\n    }\n    \n    @Test\n    public void testObservableJust() {\n        TestSubscriber<Integer> ts = new TestSub"}, {"ID": 32, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \n\n*/\n\npublic class ObservableSetOnce<T> extends Observable<T> {\n\n    private final SetOnce<T> setOnce;\n\n    public ObservableSetOnce(SetOnce<T> setOnce) {\n        this.setOnce = setOnce;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super T> observer) {\n        SetOnceObserver<T> parent = new SetOnceObserver<T>(observer);\n        observer.onSubscribe(parent);\n        parent"}, {"ID": 33, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "predict": " public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.reactivestreams.Subscription;\n\npublic class SubscriptionHelper {\n    public static final Subscription CANCELLED = new Subscription() {\n        @Override\n        public void request(long n) {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n\n        @Override\n        public void cancel() {\n            throw new UnsupportedOperation"}, {"ID": 34, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceSubscription {\n\n    public static void main(String[] args) {\n        AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();\n        Subscription next = new Subscription() {\n            @Override\n            public void request(long n) {\n                System.out.println(\"request \" + n);\n            }\n\n            @Override\n            public void cancel() {\n                System.out.println(\"c"}, {"ID": 35, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; } \nResponse:", "ground_truth": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "predict": "\n\npublic static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; }\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long[] arr = new long[n];\n        for(int i=0;i<n;i++){\n            arr[i] = in.nextLong();\n        }\n        long sum = 0;\n        for(int i=0;i<n;i++){\n            sum += arr[i];\n        }\n        System.out.println(sum);\n    }\n}\n"}, {"ID": 36, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; } \nResponse:", "ground_truth": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "predict": "\n\npublic static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; } \n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long u = a * b;\n        if (((a | b) >>> 31) != 0) {\n            if (u / a != b) {\n                System.out.println(Long.MAX_VALUE);\n            } else {\n                System.out.println(u);\n            }\n        } else {\n            System.out.println(u"}, {"ID": 37, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long add(AtomicLong requested, long n) { for (;;) { long r = requested.get(); if (r == Long.MAX_VALUE) { return Long.MAX_VALUE; } long u = addCap(r, n); if (requested.compareAndSet(r, u)) { return r; } } } \nResponse:", "ground_truth": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class Solution {\n    public static void main(String[] args) {\n        AtomicLong requested = new AtomicLong(0);\n        long n = 1;\n        long r = addCap(requested, n);\n        System.out.println(r);\n    }\n\n    public static long addCap(AtomicLong requested, long n) {\n        for (;;) {\n            long r = requested.get();\n            if (r == Long.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            long u = addCap(r, n);\n            if (requested.compareAndSet(r, u)) {\n                return r;\n            }\n        }\n    }\n}\n"}, {"ID": 38, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static NullPointerException toNpe(Throwable ex) { NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\"); npe.initCause(ex); return npe; } \nResponse:", "ground_truth": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "predict": "\n\npublic static NullPointerException toNpe(Throwable ex) {\n\tNullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n\tnpe.initCause(ex);\n\treturn npe;\n}\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        System.out.println(toNpe(new Exception()));\n    }\n    \n    public static NullPointerException toNpe(Throwable ex) {\n        NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n        npe.initCause(ex);\n        return npe;\n    }\n}\n"}, {"ID": 39, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } } \nResponse:", "ground_truth": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.run();\n    }\n\n    public void run() {\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9,10};\n        int n = nums.length;\n        int[] result = new int[n];\n        int[] temp = new int[n];\n        int[] temp2 = new int[n];\n        int[] temp3 = new int[n];\n        int[] temp4 = new int[n];\n        int[] temp5 = new int[n];\n        int[] temp6 = new int[n];\n        int[] temp7 = new int[n];\n        int[] temp8 = new int[n];\n        int[] temp9 = new int[n];\n        int[] temp10 = new int[n];"}, {"ID": 40, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void shutdown() { ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null); if (exec != null) { exec.shutdownNow(); } POOLS.clear(); } \nResponse:", "ground_truth": "Stops the purge thread.", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class Shutdown {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newSingleThreadScheduledExecutor();\n        ScheduledExecutorService exec2 = Executors.newSingleThreadScheduledExecutor();\n        exec.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"ExecutorService shutdown\");\n                exec.shutdown();\n            }\n        }, 10, TimeUnit.SECONDS);\n        exec2.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"ScheduledExec"}, {"ID": 41, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; } \nResponse:", "ground_truth": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "predict": " public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; } \n\n*/\n\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScheduledExecutorServiceTest {\n    public static void main(String[] args) {\n        ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread t = new Thread(r);\n                t.setDaemon(true);\n                return t;\n            }\n"}, {"ID": 42, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); } \nResponse:", "ground_truth": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "predict": " public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); } \n */\n\npublic class SingleProducerConsumerTest {\n\n    @Test\n    public void testSingleProducerConsumer() throws InterruptedException {\n        final AtomicLong counter = new AtomicLong();\n        final AtomicReference<Subscription> ref = new AtomicReference"}, {"ID": 43, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } } \nResponse:", "ground_truth": "Loops until all notifications in the queue has been processed.", "predict": " void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.emitLoop();\n    }\n    \n    public void emitLoop() {\n        emit(\"void emitLoop() {\");\n        emit(\"    for (;;) {\");\n        emit(\"        AppendOnlyLinkedArrayList<Object> q;\");\n        emit(\"        synchronized (this) {\");\n        emit(\"            q = queue;\");\n        emit(\"            if (q == null) {\");\n        emit(\"                emitting = false;\");\n        emit(\"                return;\");\n        emit"}, {"ID": 44, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RuntimeException wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (RuntimeException)error; } return new RuntimeException(error); } \nResponse:", "ground_truth": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "predict": " Response<T> wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (Response<T>)error; } if (error instanceof IOException) { throw (IOException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error instanceof TimeoutException) { throw (TimeoutException)error; } if (error instanceof ExecutionException) { throw (ExecutionException)error; } if (error instanceof CancellationException) { throw (CancellationException)error; } if (error instanceof TimeoutException) { throw (TimeoutException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error instanceof IOException) { throw (IOException)error; } if (error instanceof InterruptedException) { throw (InterruptedException)error; } if (error"}, {"ID": 45, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; } \nResponse:", "ground_truth": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "predict": " public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; } \n\n*/\n\nimport java.util.ArrayDeque;\nimport java.util.List;\n\npublic class Flatten {\n\n    public static List<Throwable> flatten(Throwable t) {\n        List<Throwable> list = new Array"}, {"ID": 46, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return (Exception)e; } throw (E)e; } \nResponse:", "ground_truth": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param  the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "predict": " Response<T> throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return Response.success((T)e); } throw (E)e; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.NameValuePair;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.util.Log;\n\npublic class Utils {\n\t\n\tpublic static final String PREF_NAME = \"pref_name\";\n\tpublic static final String PREF_NAME_KEY = \"pref_name_key\";\n\tpublic static final String PREF_NAME_VALUE = \"pref_"}, {"ID": 47, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); } \nResponse:", "ground_truth": "Atomically clears the container, then disposes all the previously contained Disposables.", "predict": " public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); } \n */\n\npublic class DisposableResource {\n    private static final Logger LOGGER = LoggerFactory.getLogger(DisposableResource.class);\n    private static final String DISPOSABLE_RESOURCE_PREFIX = \"DisposableResource\";\n    private static final String DISPOSABLE_RESOURCE_SUFFIX = \"DisposableResource\";\n    private static final String DISPOSABLE_RESOURCE_PREFIX_WITH_SEPARATOR = DISPOSABLE_RESOURCE_PREFIX + \".\";\n    private static final String DISPOSABLE_RESOURCE_SUFFIX_WITH_SEPARATOR = DISPOSABLE_RESOURCE_SUFFIX + \".\";\n    private static final"}, {"ID": 48, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int size() { if (disposed) { return 0; } synchronized (this) { if (disposed) { return 0; } OpenHashSet<Disposable> set = resources; return set != null ? set.size() : 0; } } \nResponse:", "ground_truth": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 49, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (u == null) { EmptyDisposable.complete(observer); return true; } ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u); observer.onSubscribe(sd); sd.run(); } else { r.subscribe(observer); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param  the input value type\n@param  the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "predict": "\n\npublic static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try"}, {"ID": 50, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into an Observable and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "predict": "\n\npublic static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); } \n\n*/\n\npublic class ScalarXMapObservable<T, R> extends Observable<R> {\n    final T value;\n    final Function<? super T, ? extends ObservableSource<? extends R>> mapper;\n\n    public ScalarXMapObservable(T value, Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n        this.value = value;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super R> s) {\n        ObservableSource<? extends R> o;\n        try {\n            o = Object"}, {"ID": 51, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param  the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "predict": " public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; } \n */\n\npublic class Main {\n    public static void main(String[] args) {\n        final int capacity = 10;\n        final int count = 100;\n        final int[] data = new int[count];\n        for (int i = 0; i < count; i++) {\n            data[i] = i;\n        }\n        final int[] data2 = new int[count];\n        for (int i = 0; i < count; i++) {\n            data2[i] ="}, {"ID": 52, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param  the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "predict": " public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; } \n */\n\npublic class Main {\n    public static void main(String[] args) {\n        Observer<Integer> observer = new Observer<Integer>() {\n            @Override\n            public void onNext(Integer integer) {\n                System.out.println(\"onNext: \" + integer);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"onError: \" + e);\n            }\n\n            @Override\n            public void onCompleted()"}, {"ID": 53, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } } \n */\npublic class SpscArrayQueue<T> extends AbstractQueue<T> {\n    private final int bufferSize;\n    private final int mask;\n    private final Object[] items;\n    private int putIndex;\n    private int takeIndex;\n    private int count;\n    private final AtomicLong requested = new AtomicLong();\n    private final AtomicLong produced = new AtomicLong();\n    private final AtomicLong requestedSubscription = new AtomicLong();\n    private final AtomicLong producedSubscription = new AtomicLong();\n    private final AtomicLong requestedSubscriptionPeriod = new AtomicLong();\n    private final AtomicLong producedSubscriptionPeriod = new AtomicLong();\n    private final AtomicLong requestedPeriod = new AtomicLong();\n    private final AtomicLong producedPeriod = new AtomicLong();\n"}, {"ID": 54, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } } \n */\npublic class SpscLinkedArrayQueue<T> extends SpscLinkedArrayQueue<T> {\n    public SpscLinkedArrayQueue(int bufferSize) {\n        super(bufferSize);\n    }\n}\n"}, {"ID": 55, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; } \nResponse:", "ground_truth": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "predict": " public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; } \n\n//end::include[]\n"}, {"ID": 56, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Disposable get() { Disposable d = resource.get(); if (d == DisposableHelper.DISPOSED) { return Disposables.disposed(); } return d; } \nResponse:", "ground_truth": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "predict": " @Nullable public Disposable get() { return resource.get(); } \n */\npublic class DisposableHelper {\n    public static final Disposable DISPOSED = new Disposable() {\n        @Override\n        public void dispose() {\n        }\n    };\n    \n    public static Disposable getDisposable(Disposable resource) {\n        if (resource == null) {\n            return DISPOSED;\n        }\n        return resource;\n    }\n}\n"}, {"ID": 57, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } } \nResponse:", "ground_truth": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "predict": "\n\npublic final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } } \n\n*/\n\npublic final class BlockingObservable<T> extends AbstractBlockingObservable<T> {\n\n    private final BlockingQueue<T> queue;\n\n    public BlockingObservable(BlockingQueue<T> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void subscribeActual(Observer<? super"}, {"ID": 58, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); } \nResponse:", "ground_truth": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "predict": " public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); } \n\n*/\n\npublic final class OnErrorFuseable<T> extends AbstractOnErrorFuseable<T> {\n    final ConditionalSubscriber<? super T> actual;\n\n    public OnErrorFuseable(ConditionalSubscriber<? super T> actual) {\n        this.actual = actual;\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        if (e != null) {\n            actual.onError(e);\n        } else {\n            actual.onError(new NullPointerException(\"onError(null)\"));\n        }\n    }\n\n"}, {"ID": 59, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResponse:", "ground_truth": "Complete the target without any value.", "predict": " public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResp public final void complete() { int state = get(); if ((state & (FUSED_READY | F"}, {"ID": 60, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) { return concatMapDelayError(mapper, 2, true); } \nResponse:", "ground_truth": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that may throw an {@code IllegalStateException} when that\n{@code Publisher} completes.\nScheduler:\n{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "predict": " @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { return concatMapDelayError(mapper, prefetch, true); } \nResp @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean delayError) { return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, delayError)); } \nResp @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport"}, {"ID": 61, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) { return concatMapIterable(mapper, 2); } \nResponse:", "ground_truth": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.\nScheduler:\n{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see ReactiveX operators documentation: FlatMap", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.internal.functions.ObjectHelper;\nimport io.reactivex.internal.subscriptions.SubscriptionHelper;\nimport io.reactivex.internal.util.BackpressureHelper;\nimport io.reactivex.plugins.RxJavaPlugins;\n\npublic final class FlowableConcatMapIterable<T, U> extends Flowable<U> {\n    final Flow"}, {"ID": 62, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction\"); return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nBackpressure:\nThe operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "predict": " @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse() { return toList().toSingle().map(Functions.response(response -> response.getBody())); } \nResp @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse(ResponseTransformer<R> transformer) { return toList().toSingle().map(Functions.response(transformer)); } \nResp @NonNull @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Single<Response<R>> toResponse(ResponseTransformer<R> transformer, ResponseConverter<R> converter) { return toList().toSingle()."}, {"ID": 63, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PerfAsyncConsumer await(int count) { if (count <= 1000) { while (getCount() != 0) { } } else { try { await(); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } return this; } \nResponse:", "ground_truth": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "predict": "\n\n*/\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class PerfAsyncConsumer {\n    private static final int COUNT = 1000000;\n    private static final int THREAD_COUNT = 4;\n    private static final int THREAD_COUNT_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n    private static final int THREAD_COUNT_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD_PER_METHOD = 4;\n\n    private static final AtomicInteger count = new AtomicInteger(0);\n    "}, {"ID": 64, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void request(long n) { Subscription s = this.upstream; if (s != null) { s.request(n); } } \nResponse:", "ground_truth": "Requests from the upstream Subscription.\n@param n the request amount, positive", "predict": " Resp public final void cancel() { Subscription s = this.upstream; if (s != null) { s.cancel(); } } \n\n*/\n\npublic class Subscription {\n\tprivate final Subscriber<? super T> subscriber;\n\tprivate final Subscription upstream;\n\t\n\tpublic Subscription(Subscriber<? super T> subscriber, Subscription upstream) {\n\t\tthis.subscriber = subscriber;\n\t\tthis.upstream = upstream;\n\t}\n\t\n\tpublic void request(long n) {\n\t\tupstream.request(n);\n\t}\n\t\n\tpublic void cancel() {\n\t\tupstream.cancel();\n\t}\n}\n"}, {"ID": 65, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: boolean add(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n + 1]; System.arraycopy(a, 0, b, 0, n); b[n] = ps; if (subscribers.compareAndSet(a, b)) { return true; } } } \nResponse:", "ground_truth": "Tries to add the given subscriber to the subscribers array atomically\nor returns false if the subject has terminated.\n@param ps the subscriber to add\n@return true if successful, false if the subject has terminated", "predict": " void onSuccess(T t) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n - 1]; System.arraycopy(a, 1, b, 0, n - 1); if (subscribers.compareAndSet(a, b)) { return; } } } \nResp void onError(Throwable t) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n - 1]; System.arraycopy(a, 1, b, 0, n - 1); if (subscribers.compareAndSet(a, b)) { return; } } } "}, {"ID": 66, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") void remove(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED || a == EMPTY) { return; } int n = a.length; int j = -1; for (int i = 0; i < n; i++) { if (a[i] == ps) { j = i; break; } } if (j < 0) { return; } PublishDisposable<T>[] b; if (n == 1) { b = EMPTY; } else { b = new PublishDisposable[n - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, n - j - 1); } if (subscribers.compareAndSet(a, b)) { return; } } } \nResponse:", "ground_truth": "Atomically removes the given subscriber if it is subscribed to the subject.\n@param ps the subject to remove", "predict": "\n\npublic class PublishSubscriber<T> extends Subscriber<T> {\n    final Subscriber<? super T> actual;\n    final AtomicLong requested = new AtomicLong();\n    final AtomicReference<Subscriber<? super T>> terminal;\n    final AtomicReference<PublishSubscriber<T>> parent;\n    final int bufferSize;\n    final int prefetch;\n    final int limit;\n    final int index;\n    final int offset;\n    final int mask;\n    final int capacity;\n    final int mask;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    final int offset;\n    final int index;\n    "}, {"ID": 67, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); } \nResponse:", "ground_truth": "Child Subscribers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param cf the ConnectableFlowable to wrap\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "\n\npublic static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); } \n\n*/\n\nimport java.util.concurrent.TimeUnit;\nimport rx.Observable;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\nimport rx.functions.Func2;\nimport rx.functions.Func3;\nimport rx.functions.Func4;\nimport rx.functions.Func5;\nimport rx.functions.Func6;\nimport rx.functions.Func7;\nimport rx.functions.Func8;\nimport rx"}, {"ID": 68, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \"'\" + getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } if (responseType == Response.class) { throw methodError(method, \"Response must include generic type (e.g., Response<String>)\"); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\"HEAD\") && !Void.class.equals(responseType)) { throw methodError(method, \"HEAD method must use Void as response type.\"); } Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable); } } \nResponse:", "ground_truth": "Inspects the annotations on an interface method to construct a reusable service method that\nspeaks HTTP. This requires potentially-expensive reflection so it is best to build each service\nmethod only once and reuse it.", "predict": " Generate the method-level comment for the following java Code. Code: static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType"}, {"ID": 69, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDelay(long amount, TimeUnit unit) { if (amount < 0) { throw new IllegalArgumentException(\"Amount must be positive value.\"); } this.delayMs = unit.toMillis(amount); } \nResponse:", "ground_truth": "Set the network round trip delay.", "predict": "\n\n*/\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Delay {\n    private long delayMs;\n\n    public Delay(long delayMs) {\n        this.delayMs = delayMs;\n    }\n\n    public void setDelay(long amount, TimeUnit unit) {\n        if (amount < 0) {\n            throw new IllegalArgumentException(\"Amount must be positive value.\");\n        }\n        this.delayMs = unit.toMillis(amount);\n    }\n\n    public long getDelayMs() {\n        return delayMs;\n    }\n}\n"}, {"ID": 70, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response<?> createErrorResponse() { Response<?> call; try { call = errorFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; } \nResponse:", "ground_truth": "The HTTP error to be used when an error is triggered.", "predict": " public Response<?> createResponse() { Response<?> call; try { call = responseFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; } \n\n}\n"}, {"ID": 71, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long calculateDelay(TimeUnit unit) { float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta; // 0.2f --> 0.8f float upperBound = 1f + delta; // 0.2f --> 1.2f float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4) long callDelayMs = (long) (delayMs * delayPercent); return MILLISECONDS.convert(callDelayMs, unit); } \nResponse:", "ground_truth": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "predict": "\n\n*/\n\nimport java.util.Random;\n\npublic class DelayCalculator {\n    private static final float variancePercent = 20f;\n    private static final float lowerBound = 1f - variancePercent / 100f;\n    private static final float upperBound = 1f + variancePercent / 100f;\n    private static final float bound = upperBound - lowerBound;\n    private static final float delayPercent = lowerBound + (new Random().nextFloat() * bound);\n\n    public static long calculateDelay(TimeUnit unit) {\n        return MILLISECONDS.convert(delayMs, unit);\n    }\n}\n"}, {"ID": 72, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createSampleData(String username, String password) { Assert.notNull(documentDao, \"DocumentDao required\"); Assert.hasText(username, \"Username required\"); Authentication auth = new UsernamePasswordAuthenticationToken(username, password); try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder.getContext().setAuthentication(auth); // Create the home directory first Directory home = new Directory(username, Directory.ROOT_DIRECTORY); documentDao.create(home); addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN); addPermission(documentDao, home, \"ROLE_USER\", LEVEL_GRANT_READ); createFiles(documentDao, home); // Now create the confidential directory Directory confid = new Directory(\"confidential\", home); documentDao.create(confid); addPermission(documentDao, confid, \"ROLE_USER\", LEVEL_NEGATE_READ); createFiles(documentDao, confid); // Now create the shared directory Directory shared = new Directory(\"shared\", home); documentDao.create(shared); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_READ); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_WRITE); createFiles(documentDao, shared); } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder.clearContext(); } } \nResponse:", "ground_truth": "Creates a directory for the user, and a series of sub-directories. The root\ndirectory is the parent for the user directory. The sub-directories are\n\"confidential\" and \"shared\". The ROLE_USER will be given read and write access to\n\"shared\".", "predict": "\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doublevalue;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\nimport com.github.dkellenb.formulaevaluator.term.operator.OperatorTerm;\n\n/**\n * Double value greater than operator.\n */\npublic class DoubleValueGreaterThanOperatorTerm\n    extends GenericStackableOperatorTerm<Double, Double>\n    implements DoubleValueOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleValueGreater"}, {"ID": 73, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \nResponse:", "ground_truth": "Provides a save way of obtaining the HttpMethod from a String. If the method is\ninvalid, returns null.\n\n@param method the HTTP method to use.\n\n@return the HttpMethod or null if method is invalid.", "predict": " Response to the following java Code. Code: public static Response valueOf(String response) { try { return Response.valueOf(response); } catch (IllegalArgumentException e) { } return null; } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \n\t\t\n\t\tString method = \"GET\";\n\t\t\n\t\tSystem.out.println(\"Generating the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \");\n\t\t\n\t\tSystem."}, {"ID": 74, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public DirContextOperations searchForUser(String username) { if (logger.isDebugEnabled()) { logger.debug(\"Searching for user '\" + username + \"', with user search \" + this); } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate( contextSource); template.setSearchControls(searchControls); try { return template.searchForSingleEntry(searchBase, searchFilter, new String[] { username }); } catch (IncorrectResultSizeDataAccessException notFound) { if (notFound.getActualSize() == 0) { throw new UsernameNotFoundException(\"User \" + username + \" not found in directory.\"); } // Search should never return multiple results if properly configured, so just // rethrow throw notFound; } } \nResponse:", "ground_truth": "Return the LdapUserDetails containing the user's information\n\n@param username the username to search for.\n\n@return An LdapUserDetails object containing the details of the located user's\ndirectory entry\n\n@throws UsernameNotFoundException if no matching entry is found.", "predict": "\n\n@Override\npublic DirContextOperations searchForUser(String username) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Searching for user '\" + username + \"', with user search \" + this);\n\t}\n\tSpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate(contextSource);\n\ttemplate.setSearchControls(searchControls);\n\ttry {\n\t\treturn template.searchForSingleEntry(searchBase, searchFilter, new String[] { username });\n\t}\n\tcatch (IncorrectResultSizeDataAccessException notFound) {\n\t\tif (notFound.getActualSize() == 0) {\n\t\t\tthrow new UsernameNotFoundException(\"User \" + username + \" not found in directory.\");\n\t\t}\n\t\t// Search should never return multiple results if properly configured, so just\n\t\t// rethrow\n\t\tthrow notFound;\n\t}\n}\n\n@Override\npublic DirContextOper"}, {"ID": 75, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(CharSequence rawPassword) { String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX; return digest(salt, rawPassword); } \nResponse:", "ground_truth": "Encodes the rawPass using a MessageDigest. If a salt is specified it will be merged\nwith the password before encoding.\n\n@param rawPassword The plain text password\n@return Hex string of password digest (or base64 encoded string if\nencodeHashAsBase64 is enabled.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 76, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matches(CharSequence rawPassword, String encodedPassword) { String salt = extractSalt(encodedPassword); String rawPasswordEncoded = digest(salt, rawPassword); return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded); } \nResponse:", "ground_truth": "Takes a previously encoded password and compares it with a rawpassword after mixing\nin the salt and encoding that value\n\n@param rawPassword plain text password\n@param encodedPassword previously encoded password\n@return true or false", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Preconditions;\n\npublic class PasswordEncoderUtils {\n\n\tprivate static final Pattern ENCODED_PASSWORD_PATTERN = Pattern.compile(\"^(\\\\w{32})(\\\\w{2})(\\\\w{2})(\\\\w{2})(\\\\w{2})("}, {"ID": 77, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void performVersionChecks(String minSpringVersion) { if (minSpringVersion == null) { return; } // Check Spring Compatibility String springVersion = SpringVersion.getVersion(); String version = getVersion(); if (disableChecks(springVersion, version)) { return; } logger.info(\"You are running with Spring Security Core \" + version); if (new ComparableVersion(springVersion) .compareTo(new ComparableVersion(minSpringVersion)) < 0) { logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion); } } \nResponse:", "ground_truth": "Perform version checks with specific min Spring Version\n\n@param minSpringVersion", "predict": "\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double less than or equal operator.\n */\npublic class DoubleLessThanOrEqualOperatorTerm\n    extends GenericStackableOperatorTerm<Double>\n    implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleLessThanOrEqualOperatorTerm(Term<Double> base, Term<Double> applicant) {\n    super(base,"}, {"ID": 78, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); } \nResponse:", "ground_truth": "Disable if springVersion and springSecurityVersion are the same to allow working\nwith Uber Jars.\n\n@param springVersion\n@param springSecurityVersion\n@return", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DisableChecks {\n\n    public static void main(String[] args) {\n        String javaCode = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\";\n        String javaCode2 = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\";\n        String javaCode3 = \"private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion"}, {"ID": 79, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSpringVersion() { Properties properties = new Properties(); try { properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\")); } catch (IOException | NullPointerException e) { return null; } return properties.getProperty(\"org.springframework:spring-core\"); } \nResponse:", "ground_truth": "Loads the spring version or null if it cannot be found.\n@return", "predict": "\n\n<pre>\n{\n  \"status\": \"ok\",\n  \"version\": \"3.2.0.RELEASE\",\n  \"spring-version\": \"3.2.0.RELEASE\",\n  \"spring-security-version\": \"3.2.0.RELEASE\"\n}\n</pre>\n\n*/\n\npackage com.github.springtestdbunit.junit4;\n\nimport static org.springframework.util.StringUtils.hasLength;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.PropertiesLoaderUtils;\n\n/**\n * Utility class for retrieving the Spring version.\n *\n * @author Phillip Webb\n * @author Dave Syer\n * @author Andy Wilkinson\n */\npublic class SpringVersion {\n\n\tprivate static"}, {"ID": 80, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AttributeExchangeConfigurer attributeExchange(String identifierPattern) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer( identifierPattern); this.attributeExchangeConfigurers.add(attributeExchangeConfigurer); return attributeExchangeConfigurer; } \nResponse:", "ground_truth": "", "predict": " Response(String identifierPattern) { this.identifierPattern = identifierPattern; } \n\n*/\n\npublic class AttributeExchangeConfigurer {\n\tprivate String identifierPattern;\n\tprivate List<AttributeExchangeConfigurer> attributeExchangeConfigurers;\n\t\n\tpublic AttributeExchangeConfigurer(String identifierPattern) {\n\t\tthis.identifierPattern = identifierPattern;\n\t\tthis.attributeExchangeConfigurers = new ArrayList<AttributeExchangeConfigurer>();\n\t}\n\t\n\tpublic void addAttributeExchangeConfigurer(AttributeExchangeConfigurer attributeExchangeConfigurer) {\n\t\tthis.attributeExchangeConfigurers.add(attributeExchangeConfigurer);\n\t}\n\t\n\tpublic String getIdentifierPattern() {\n\t\treturn identifierPattern;\n\t}\n\t\n\tpublic List<AttributeExchangeConfigurer> getAttributeExchangeConfigurers() {\n\t\treturn attributeExchangeConfigurers;\n\t}\n}\n"}, {"ID": 81, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception { OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>()); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Client support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ClientConfigurer} for further customizations\n@throws Exception", "predict": " ResponseEntity<OAuth2ClientConfigurer<HttpSecurity>> oauth2Client() throws Exception { return getOrApply(new OAuth2ClientConfigurer<>()); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientProperties;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientPropertiesRegistrationAdapter;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientPropertiesRegistrationAutoConfiguration;\nimport org"}, {"ID": 82, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception { OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Resource Server support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ResourceServerConfigurer} for further customizations\n@throws Exception", "predict": " ResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> oauth2ResourceServer() throws Exception { return getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer) throws Exception { return getOrApply(configurer, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer, String method) throws Exception { return getOrApply(configurer, method, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<HttpSecurity>> getOrApply(OAuth2ResourceServerConfigurer<HttpSecurity> configurer, String method, String path) throws Exception { return getOrApply(configurer, method, path, null); } \nResponseEntity<OAuth2ResourceServerConfigurer<Http"}, {"ID": 83, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); } \nResponse:", "ground_truth": "Configures channel security. In order for this configuration to be useful at least\none mapping to a required channel must be provided.\n\nExample Configuration\n\nThe example below demonstrates how to require HTTPs for every request. Only\nrequiring HTTPS for some requests is supported, but not recommended since an\napplication that allows for HTTP introduces many security vulnerabilities. For one\nsuch example, read about Firesheep.\n\n\n\n\n@return the {@link ChannelSecurityConfigurer} for further customizations\n@throws Exception", "predict": " public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); } \n */\n\npublic class ChannelSecurityConfigurer<H extends HttpSecurity> {\n\n    private final ApplicationContext context;\n\n    public ChannelSecurityConfigurer(ApplicationContext context) {\n        this.context = context;\n    }\n\n    public ChannelSecurityConfigurer<H> getOrApply(ChannelSecurityConfigurer<H> configurer) {\n        return configurer;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel() throws Exception {\n        return this;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel(String channel) throws Exception {\n        return this;\n    }\n\n    public ChannelSecurityConfigurer<H> requiresChannel(Channel channel) throws Exception {\n        return this;\n    }\n\n    public ChannelSecurity"}, {"ID": 84, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean compare(final String dn, final String attributeName, final Object value) { final String comparisonFilter = \"(\" + attributeName + \"={0})\"; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext(DirContext ctx) throws NamingException { SearchControls ctls = new SearchControls(); ctls.setReturningAttributes(NO_ATTRS); ctls.setSearchScope(SearchControls.OBJECT_SCOPE); NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls); Boolean match = Boolean.valueOf(results.hasMore()); LdapUtils.closeEnumeration(results); return match; } } Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback()); return matches.booleanValue(); } \nResponse:", "ground_truth": "Performs an LDAP compare operation of the value of an attribute for a particular\ndirectory entry.\n\n@param dn the entry who's attribute is to be used\n@param attributeName the attribute who's value we want to compare\n@param value the value to be checked against the directory value\n\n@return true if the supplied value matches that in the directory", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons.lang"}, {"ID": 85, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) { return (DirContextOperations) executeReadOnly(new ContextExecutor() { public Object executeWithContext(DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve); // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace())); } }); } \nResponse:", "ground_truth": "Composes an object from the attributes of the given DN.\n\n@param dn the directory entry which will be read\n@param attributesToRetrieve the named attributes which will be retrieved from the\ndirectory entry.\n\n@return the object created by the mapper", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.ModificationItem;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;"}, {"ID": 86, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) { String[] attributeNames = new String[] { attributeName }; Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues( base, filter, params, attributeNames); Set<String> result = new HashSet<>(); for (Map<String, List<String>> map : multipleAttributeValues) { List<String> values = map.get(attributeName); if (values != null) { result.addAll(values); } } return result; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the union of the values of\nthe named attribute found in all entries matched by the search. Note that one\ndirectory entry may have several values for the attribute. Intended for role\nsearches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute who's values are to be retrieved.\n\n@return the set of String values for the attribute as a union of the values found\nin all the matching entries.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\n\npublic class SearchForSingleAttributeValues {\n\n\tprivate static final Logger logger = Logger.getLogger(SearchForSingleAttributeValues.class);\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString base = \"http://localhost:8080/openemap-backend/rest/v1/\";\n\t\t\tString"}, {"ID": 87, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i = 0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, List<String>> record = new HashMap<String, List<String>>(); if (attributeNames == null || attributeNames.length == 0) { try { for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae .hasMore();) { Attribute attr = (Attribute) ae.next(); extractStringAttributeValues(adapter, record, attr.getID()); } } catch (NamingException x) { org.springframework.ldap.support.LdapUtils .convertLdapException(x); } } else { for (String attributeName : attributeNames) { extractStringAttributeValues(adapter, record, attributeName); } } record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter))); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null); search(base, formattedFilter, ctls, roleMapper); return set; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the values of each named\nattribute found in all entries matched by the search. Note that one directory entry\nmay have several values for the attribute. Intended for role searches and similar\nscenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching\nentries. The attribute name is the key for each set of values. In addition each map\ncontains the DN as a String with the key predefined key {@link #DN_KEY}.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.ldap.core.DirContextAdapter;\nimport org.springframework.ldap.core.DirContextOperations;\nimport org.springframework.ldap.core.DistinguishedName;\nimport org.springframework.ldap.core.LdapTemplate;\nimport org.springframework.ldap.core.support.AbstractContextMapper;\nimport org.springframework.ldap.filter.Filter;\nimport org.springframework.ldap.filter.FilterParser;\nimport org.springframework.ldap.support.LdapUtils;\nimport org.springframework.util.Assert;\n\npublic class LdapTemplateTest {\n\n\tpublic static void main(String[] args) {\n\t\tLdapTemplate template = new Ldap"}, {"ID": 88, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (DirContextAdapter) searchResult.getObject(); Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\"); if (logger.isDebugEnabled()) { logger.debug(\"Found DN: \" + dca.getDn()); } results.add(dca); } } catch (PartialResultException e) { LdapUtils.closeEnumeration(resultsEnum); logger.info(\"Ignoring PartialResultException\"); } if (results.size() == 0) { throw new IncorrectResultSizeDataAccessException(1, 0); } if (results.size() > 1) { throw new IncorrectResultSizeDataAccessException(1, results.size()); } return results.iterator().next(); } \nResponse:", "ground_truth": "Internal method extracted to avoid code duplication in AD search.", "predict": " public static DirContextOperations searchForSingleEntryInternal(DirContextOperations ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (Dir"}, {"ID": 89, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static SearchControls buildControls(SearchControls originalControls) { return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag()); } \nResponse:", "ground_truth": "We need to make sure the search controls has the return object flag set to true, in\norder for the search to return DirContextAdapter instances.\n@param originalControls\n@return", "predict": " Response = new SearchControls(SearchControls.SUBTREE_SCOPE, 1000, 0, new String[] { \"uid\" }, ReturnObject.AS_OBJECT, DerefLink.NEVER); \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@XmlRootElement(name = \"searchControls\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class SearchControls {\n\t@XmlElement(name = \"searchScope\")\n\tprivate SearchScope searchScope;\n\t@XmlElement(name = \"countLimit\")\n\tprivate"}, {"ID": 90, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) { Assert.notNull(acls, \"ACLs are required\"); Assert.notEmpty(findNow, \"Items to find now required\"); String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size()); Set<Long> parentsToLookup = jdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { int i = 0; for (Long toFind : findNow) { i++; ps.setLong(i, toFind); } } }, new ProcessResultSet(acls, sids)); // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if (parentsToLookup.size() > 0) { lookupPrimaryKeys(acls, parentsToLookup, sids); } } \nResponse:", "ground_truth": "Locates the primary key IDs specified in \"findNow\", adding AclImpl instances with\nStubAclParents to the \"acls\" Map.\n\n@param acls the AclImpls (with StubAclParents)\n@param findNow Long-based primary keys to retrieve\n@param sids", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.security.acls.domain.BasePermission;\nimport org.springframework.security.acls.domain.ObjectIdentityImpl;\nimport org.springframework.security.acls.domain.PrincipalSid;\nimport org.springframework.security.acls.model.Acl;\nimport org.springframework.security.acls.model.NotFoundException;\nimport org.springframework.security.acls.model.ObjectIdentity;\nimport org.springframework.security.acls.model.Sid;\nimport org.springframework.security.acls.model.SidRetrievalStrategy;\nimport org.springframework.security.acls.model.UnloadedSidException;\nimport org.springframework.security.acls.model.UnsupportedSidException;\nimport org.springframework"}, {"ID": 91, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails( HttpServletRequest context) { Collection<String> j2eeUserRoles = getUserRoles(context); Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper .getGrantedAuthorities(j2eeUserRoles); if (logger.isDebugEnabled()) { logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\"); } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails( context, userGas); return result; } \nResponse:", "ground_truth": "Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)", "predict": " public Response buildResponse( HttpServletRequest context) { return new Response(); } \n\n}\n"}, {"ID": 92, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); String suffix = element.getAttribute(ATT_ROOT_SUFFIX); if (!StringUtils.hasText(suffix)) { suffix = OPT_DEFAULT_ROOT_SUFFIX; } String port = element.getAttribute(ATT_PORT); if (!StringUtils.hasText(port)) { port = getDefaultPort(); if (logger.isDebugEnabled()) { logger.debug(\"Using default port of \" + port); } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder .rootBeanDefinition(CONTEXT_SOURCE_CLASS); contextSource.addConstructorArgValue(url); contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\"); contextSource.addPropertyValue(\"password\", \"secret\"); RootBeanDefinition apacheContainer = new RootBeanDefinition( \"org.springframework.security.ldap.server.ApacheDSContainer\", null, null); apacheContainer.setSource(source); apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix); String ldifs = element.getAttribute(ATT_LDIF_FILE); if (!StringUtils.hasText(ldifs)) { ldifs = OPT_DEFAULT_LDIF_FILE; } apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs); apacheContainer.getPropertyValues().addPropertyValue(\"port\", port); logger.info(\"Embedded LDAP server bean definition created for URL: \" + url); if (parserContext.getRegistry() .containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) { parserContext.getReaderContext().error( \"Only one embedded server bean is allowed per application context\", element); } parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer); return (RootBeanDefinition) contextSource.getBeanDefinition(); } \nResponse:", "ground_truth": "Will be called if no url attribute is supplied.\n\nRegisters beans to create an embedded apache directory server.\n\n@return the BeanDefinition for the ContextSource for the embedded server.\n\n@see ApacheDSContainer", "predict": "\n\n@RequestMapping(value = \"/ldap/{suffix}\", method = RequestMethod.GET)\npublic class LdapController {\n\t@Autowired\n\tprivate LdapContextSource contextSource;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate;\n\t@Autowired\n\tprivate LdapContextSource contextSource2;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate2;\n\t@Autowired\n\tprivate LdapContextSource contextSource3;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate3;\n\t@Autowired\n\tprivate LdapContextSource contextSource4;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate4;\n\t@Autowired\n\tprivate LdapContextSource contextSource5;\n\t@Autowired\n\tprivate LdapTemplate ldapTemplate5;"}, {"ID": 93, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createServletApiFilter(BeanReference authenticationManager) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\"; final String DEF_SERVLET_API_PROVISION = \"true\"; String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION); if (!StringUtils.hasText(provideServletApi)) { provideServletApi = DEF_SERVLET_API_PROVISION; } if (\"true\".equals(provideServletApi)) { servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class); servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager); } } \nResponse:", "ground_truth": "Adds the servlet-api integration filter if required", "predict": "\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <meta name=\"description\" content=\"\">\n  <meta name=\"author\" content=\"\">\n  <title>Welcome to Spring Boot</title>\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3"}, {"ID": 94, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createJaasApiFilter() { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\"; final String DEF_JAAS_API_PROVISION = \"false\"; String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION); if (!StringUtils.hasText(provideJaasApi)) { provideJaasApi = DEF_JAAS_API_PROVISION; } if (\"true\".equals(provideJaasApi)) { jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class); } } \nResponse:", "ground_truth": "Adds the jaas-api integration filter if required", "predict": "\n\n<pre>\n{\n    \"status\": \"OK\",\n    \"message\": \"\",\n    \"jaas-api-provision\": \"true\",\n    \"jaas-api-provision-status\": \"true\",\n    \"jaas-api-provision-message\": \"\",\n    \"jaas-api-provision-status-message\": \"\",\n    \"jaas-api-provision-status-message-code\": \"\",\n    \"jaas-api-provision-status-message-description\": \"\",\n    \"jaas-api-provision-status-message-severity\": \"\",\n    \"jaas-api-provision-status-message-summary\": \"\",\n    \"jaas-api-provision-status-message-type\": \"\",\n    \"jaas-api-provision-status-message-instance\": \"\",\n    \"jaas-api-provision-status-message-component\":"}, {"ID": 95, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() { TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); result = result.init(JsonTypeInfo.Id.CLASS, null); result = result.inclusion(JsonTypeInfo.As.PROPERTY); return result; } \nResponse:", "ground_truth": "Creates a TypeResolverBuilder that performs whitelisting.\n@return a TypeResolverBuilder that performs whitelisting.", "predict": " Response.ok().build();\n\n*/\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.datatype.joda.JodaModule;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeZoneSerializer;\nimport com.fasterxml.jackson.datatype.joda.ser.JacksonJodaFormat;\nimport com.fasterxml.jackson.datatype.joda.ser.JodaSerializer;\nimport com.f"}, {"ID": 96, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = DEFAULT_FILTER_NAME; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy( filterName); String contextAttribute = getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } registerFilter(servletContext, true, filterName, springSecurityFilterChain); } \nResponse:", "ground_truth": "Registers the springSecurityFilterChain\n@param servletContext the {@link ServletContext}", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterRegistration;\nimport javax.servlet.FilterRegistration.Dynamic;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\npublic class FilterRegistrationBean implements FilterRegistration.Dynamic {\n\n\tprivate String name;\n\tprivate Class<? extends Filter> filterClass;\n\tprivate boolean asyncSupported = true;\n\tprivate boolean enabled = true;\n\tprivate String servletName;\n\tprivate String dispatcherTypes;\n\tprivate String description;\n\tprivate String displayName;\n\tprivate String contextAttribute;\n\tprivate String urlPatterns;\n\tprivate String dispatcher"}, {"ID": 97, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PersistentRememberMeToken getTokenForSeries(String seriesId) { try { return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() { public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException { return new PersistentRememberMeToken(rs.getString(1), rs .getString(2), rs.getString(3), rs.getTimestamp(4)); } }, seriesId); } catch (EmptyResultDataAccessException zeroResults) { if (logger.isDebugEnabled()) { logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults); } } catch (IncorrectResultSizeDataAccessException moreThanOne) { logger.error(\"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\"); } catch (DataAccessException e) { logger.error(\"Failed to load token for series \" + seriesId, e); } return null; } \nResponse:", "ground_truth": "Loads the token data for the supplied series identifier.\n\nIf an error occurs, it will be reported and null will be returned (since the result\nshould just be a failed persistent login).\n\n@param seriesId\n@return the token matching the series, or null if no match found or an exception\noccurred.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Date;\nimport java.util.List;\n\n@Service(\"rememberMeTokenService\")\npublic class RememberMeTokenServiceImpl implements RememberMeTokenService {\n\n    @Autowired\n    @Qualifier(\"userDetailsService\")\n"}, {"ID": 98, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { List<GrantedAuthority> result = new ArrayList<>(attributes.size()); for (String attribute : attributes) { result.add(getGrantedAuthority(attribute)); } return result; } \nResponse:", "ground_truth": "Map the given list of string attributes one-to-one to Spring Security\nGrantedAuthorities.", "predict": " ResponseEntity<List<GrantedAuthority>> getGrantedAuthorities(Collection<String> attributes) { return ResponseEntity.ok(getGrantedAuthorities(attributes)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class UserDetailsImpl implements UserDetails {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate String password;\n\tprivate List<GrantedAuthority> authorities;\n\tprivate boolean enabled;\n\tprivate boolean accountNonExpired;\n\tprivate boolean credentialsNonExpired;\n\tprivate boolean accountNonLocked;\n\tprivate boolean admin;\n\tprivate boolean superAdmin;\n"}, {"ID": 99, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cipher newCipher(String algorithm) { try { return Cipher.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e); } catch (NoSuchPaddingException e) { throw new IllegalStateException(\"Should not happen\", e); } } \nResponse:", "ground_truth": "Constructs a new Cipher.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBE"}, {"ID": 100, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void afterPropertiesSet() { try { super.afterPropertiesSet(); } catch (ServletException e) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException(e); } Assert.notNull(authenticationManager, \"An AuthenticationManager must be set\"); } \nResponse:", "ground_truth": "Check whether all required properties have been set.", "predict": " ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) { return authenticationManager.authenticate(loginRequest); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\n@RestController\n@RequestMapping(\"/api/login\")\npublic class LoginController {\n\n\t@Autowired\n\tprivate AuthenticationManager authenticationManager;\n\n\t@RequestMapping(method = RequestMethod.POST)\n\t@JsonView(View.Login"}, {"ID": 101, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); } \nResponse:", "ground_truth": "Try to authenticate a pre-authenticated user with Spring Security if the user has\nnot yet been authenticated.", "predict": " Generate the method-level comment for the following java Code. Code: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;"}, {"ID": 102, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) { Object principal = getPreAuthenticatedPrincipal(request); if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) { return false; } if (principal != null && principal.equals(currentAuthentication.getPrincipal())) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\"); } return true; } \nResponse:", "ground_truth": "Determines if the current principal has changed. The default implementation tries\n\n\nIf the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is a String, the {@link Authentication#getName()} is compared against the pre authenticated principal\nOtherwise, the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is compared against the {@link Authentication#getPrincipal()}\n\n\nSubclasses can override this method to determine when a principal has changed.\n\n\n@param request\n@param currentAuthentication\n@return true if the principal has changed, else false", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Type;\n\npublic final class Primitives {\n    private Primitives() {\n    }\n\n    public static Type primitiveTypeToWrapperType(Type type) {\n        if (type == Boolean.TYPE) {\n            return Boolean.class;\n        }\n        if (type == Byte.TYPE) {\n            return Byte.class;\n        }\n        if (type == Character.TYPE) {\n            return Character.class;\n        }\n        if (type == Double.TYPE) {\n            return Double.class;\n        }\n        if (type == Float.TYPE) {\n            return Float.class;\n        }\n        if (type == Integer.TYPE) {\n            return Integer.class;\n        }\n        if (type == Long.TYPE) {\n            return Long.class;\n        }\n        if (type == Short.TYPE"}, {"ID": 103, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Authentication authResult; Object principal = getPreAuthenticatedPrincipal(request); Object credentials = getPreAuthenticatedCredentials(request); if (principal == null) { if (logger.isDebugEnabled()) { logger.debug(\"No pre-authenticated principal found in request\"); } return; } if (logger.isDebugEnabled()) { logger.debug(\"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\"); } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken( principal, credentials); authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); authResult = authenticationManager.authenticate(authRequest); successfulAuthentication(request, response, authResult); } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); if (!continueFilterChainOnUnsuccessfulAuthentication) { throw failed; } } } \nResponse:", "ground_truth": "Do the actual authentication for a pre-authenticated user.", "predict": "\n\n@Override\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t// TODO Auto-generated method stub\n\t\n}\n\n@Override\npublic void destroy() {\n\t// TODO Auto-generated method stub\n\t\n}\n\n@Override\npublic void init(FilterConfig arg0) throws ServletException {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n"}, {"ID": 104, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkContentLength(long contentLengthToWrite) { this.contentWritten += contentLengthToWrite; boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength; int bufferSize = getBufferSize(); boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize; if (isBodyFullyWritten || requiresFlush) { doOnResponseCommitted(); } } \nResponse:", "ground_truth": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if\nthe response should be written.\n\n@param contentLengthToWrite the size of the content that is about to be written.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://localhost:8080/\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Content-Length\", \"10\");\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setConnectTimeout(10000);\n            connection.setReadTimeout(10000);\n            connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Cache-Control\", \"no-cache\");\n            connection.setRequestProperty(\"Pragma\", \"no-cache\");\n"}, {"ID": 105, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; } \nResponse:", "ground_truth": "Creates a mapping of the supplied authorities based on the case-conversion and\nprefix settings. The mapping will be one-to-one unless duplicates are produced\nduring the conversion. If a default authority has been set, this will also be\nassigned to each mapping.\n\n@param authorities the original authorities\n\n@return the converted set of authorities", "predict": "\n\npublic Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; } \n\n*/\n\npublic class AuthorityMapper {\n\n    private static final Logger LOG = LoggerFactory.getLogger(AuthorityMapper.class);\n\n    private static final String DEFAULT_AUTHORITY = \"ROLE_USER\";\n\n    private static final String DEFAULT_AUTHORITY_PREFIX = \"ROLE_\";\n\n    private static final String DEFAULT_AUTHORITY_SUFFIX = \"\";\n\n    private static final String DEFAULT_AUTHORITY_SEPARATOR = \",\";\n\n    private static"}, {"ID": 106, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); } \nResponse:", "ground_truth": "Specifies the URL to validate the credentials.\n\n@param loginProcessingUrl the URL to validate username and password\n@return the {@link FormLoginConfigurer} for additional customization", "predict": " public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); } \n\n// Generated by IntelliJ IDEA\npublic class AuthFilterTest {\n  public static void main(String[] args) {\n    AuthFilterTest test = new AuthFilterTest();\n    test.testAuthFilter();\n  }\n\n  public void testAuthFilter() {\n    AuthFilter authFilter = new AuthFilter();\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/login\"));\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/logout\"));\n    authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(\"/logout\"));\n    authFilter.setRequiresAuthenticationRequest"}, {"ID": 107, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } if (failureHandler == null) { failureUrl(loginPage + \"?error\"); } final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) { logoutConfigurer.logoutSuccessUrl(loginPage + \"?logout\"); } } \nResponse:", "ground_truth": "Updates the default values for authentication.\n\n@throws Exception", "predict": "\n\n*/\n\nimport org.springframework.security.web.DefaultRedirectStrategy;\nimport org.springframework.security.web.RedirectStrategy;\nimport org.springframework.security.web.util.UrlUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author Rob Winch\n * @since 3.2\n */\npublic class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {\n\tprivate final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n\tprivate final String logoutSuccessUrl;\n\n\tprivate final List<LogoutHandler> handlers;\n\n\tpublic LogoutSuccessHandlerImpl(String logoutSuccessUrl, LogoutHandler... handlers) {\n\t\tthis.logoutSuccess"}, {"ID": 108, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAccessDefaults(B http) { if (permitAll) { PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl); } } \nResponse:", "ground_truth": "Updates the default values for access.", "predict": " Response.ok().build();\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doublevalue;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double value greater than operator.\n */\npublic class DoubleValueGreaterThanOperator extends GenericStackableOperatorTerm<Double>\n    implements DoubleValueOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant value\n   */\n  public DoubleValueGreaterThanOperator(Term<Double> base, Term<Double> applicant) {\n    super(base,"}, {"ID": 109, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String mapPassword(Object passwordValue) { if (!(passwordValue instanceof String)) { // Assume it's binary passwordValue = new String((byte[]) passwordValue); } return (String) passwordValue; } \nResponse:", "ground_truth": "Extension point to allow customized creation of the user's password from the\nattribute stored in the directory.\n\n@param passwordValue the value of the password attribute\n@return a String representation of the password.", "predict": " Response is generated by the method.\n\n*/\n\npublic class PasswordEncryption {\n\tpublic static void main(String[] args) {\n\t\tString password = \"password\";\n\t\tString encryptedPassword = encrypt(password);\n\t\tSystem.out.println(encryptedPassword);\n\t\tString decryptedPassword = decrypt(encryptedPassword);\n\t\tSystem.out.println(decryptedPassword);\n\t}\n\n\tpublic static String encrypt(String password) {\n\t\treturn \"\";\n\t}\n\n\tpublic static String decrypt(String encryptedPassword) {\n\t\treturn \"\";\n\t}\n}\n"}, {"ID": 110, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String extractRememberMeCookie(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (cookieName.equals(cookie.getName())) { return cookie.getValue(); } } return null; } \nResponse:", "ground_truth": "Locates the Spring Security remember me cookie in the request and returns its\nvalue. The cookie is searched for by name and also by matching the context path to\nthe cookie path.\n\n@param request the submitted request which is to be authenticated\n@return the cookie value (if present), null otherwise.", "predict": " ResponseEntity<String> rememberMe(@RequestBody String login, HttpServletRequest request) { return rememberMeService.login(login); }\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/v1/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(method = RequestMethod.POST)\n    public ResponseEntity<String> login(@RequestBody String login) {\n        return userService.login(login);\n    }"}, {"ID": 111, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String encodeCookie(String[] cookieTokens) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cookieTokens.length; i++) { try { sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString())); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage(), e); } if (i < cookieTokens.length - 1) { sb.append(DELIMITER); } } String value = sb.toString(); sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes()))); while (sb.charAt(sb.length() - 1) == '=') { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); } \nResponse:", "ground_truth": "Inverse operation of decodeCookie.\n\n@param cookieTokens the tokens to be encoded.\n@return base64 encoding of the tokens concatenated with the \":\" delimiter.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class CookieUtils {\n\tprivate static final String DELIMITER = \";\";\n\tprivate static final String EQUAL = \"=\";\n\tprivate static final String VALUE_DELIMITER = \"\\\\s*;\\\\s*\";\n\tprivate static final String NAME_VALUE_DELIMITER = \"\\\\s*=\\\\s*\";\n\tprivate static final String NAME_DELIMITER = \"\\\\s*=\\\\s*\";\n\tprivate static final String PATH_DELIMITER = \"\\\\"}, {"ID": 112, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) { String cookieValue = encodeCookie(tokens); Cookie cookie = new Cookie(cookieName, cookieValue); cookie.setMaxAge(maxAge); cookie.setPath(getCookiePath(request)); if (cookieDomain != null) { cookie.setDomain(cookieDomain); } if (maxAge < 1) { cookie.setVersion(1); } if (useSecureCookie == null) { cookie.setSecure(request.isSecure()); } else { cookie.setSecure(useSecureCookie); } cookie.setHttpOnly(true); response.addCookie(cookie); } \nResponse:", "ground_truth": "Sets the cookie on the response.\n\nBy default a secure cookie will be used if the connection is secure. You can set\nthe {@code useSecureCookie} property to {@code false} to override this. If you set\nit to {@code true}, the cookie will always be flagged as secure. By default the cookie\nwill be marked as HttpOnly.\n\n@param tokens the tokens which will be encoded to make the cookie value.\n@param maxAge the value passed to {@link Cookie#setMaxAge(int)}\n@param request the request\n@param response the response to add the cookie to.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CookieServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String COOKIE_NAME = \"cookieName\";\n\tprivate static final String COOKIE_VALUE = \"cookieValue\";\n\tprivate static final String COOKIE_DOMAIN = \"cookieDomain\";\n\tprivate static final String COOKIE_PATH = \"cookiePath\";\n\tprivate static final String COOKIE_SECURE = \"cookieSecure\";\n\tprivate"}, {"ID": 113, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); } \nResponse:", "ground_truth": "resolve the argument to inject into the controller parameter.\n@param parameter the method parameter.\n@param bindingContext the binding context.\n@param exchange the server web exchange.\n@return the reactive mono object result.", "predict": " @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); } \n\n@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { return Mono.justOrEmpty(resolveSecurityContext(parameter, bindingContext, exchange)); } \n\n@Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange"}, {"ID": 114, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) { final String query = request.getQueryString(); if (query == null) { return null; } final String result = artifactPattern.matcher(query).replaceFirst(\"\"); if (result.length() == 0) { return null; } // strip off the trailing & only if the artifact was the first query param return result.startsWith(\"&\") ? result.substring(1) : result; } \nResponse:", "ground_truth": "If present, removes the artifactParameterName and the corresponding value from the\nquery String.\n@param request\n@return the query String minus the artifactParameterName and the corresponding\nvalue.", "predict": "\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class QueryString {\n    public static void main(String[] args) {\n        String query = \"http://www.example.com/search?q=java&a=1&b=2&c=3\";\n        Pattern pattern = Pattern.compile(\"(?<=\\\\?)(.*)(?=&|$)\");\n        Matcher matcher = pattern.matcher(query);\n        if (matcher.find()) {\n            System.out.println(matcher.group());\n        }\n    }\n}\n"}, {"ID": 115, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getServicePort(URL casServiceUrl) { int port = casServiceUrl.getPort(); if (port == -1) { port = casServiceUrl.getDefaultPort(); } return port; } \nResponse:", "ground_truth": "", "predict": " Response.ok().build();\n\n*/\n\npackage com.github.scribejava.core.model;\n\nimport com.github.scribejava.core.exceptions.OAuthException;\nimport com.github.scribejava.core.utils.Preconditions;\nimport java.util.Objects;\n\n/**\n * Represents an HTTP response.\n */\npublic class Response {\n\n    private final int code;\n    private final String body;\n    private final String contentType;\n    private final String charset;\n\n    /**\n     * Creates a new response.\n     *\n     * @param code The HTTP status code.\n     * @param body The HTTP response body.\n     * @param contentType The HTTP content type.\n     * @param charset The HTTP charset.\n     */\n    public Response(int code, String body, String contentType, String charset) {\n        this.code = code;\n        this.body = body;"}, {"ID": 116, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPrincipal() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); if (authentication == null) { log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\"); return \"\"; } Object principal = authentication.getPrincipal(); if (principal instanceof LdapUserDetails) { LdapUserDetails details = (LdapUserDetails) principal; return details.getDn(); } else if (authentication instanceof AnonymousAuthenticationToken) { if (log.isDebugEnabled()) { log.debug(\"Anonymous Authentication, returning empty String as Principal\"); } return \"\"; } else { throw new IllegalArgumentException( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\"); } } \nResponse:", "ground_truth": "Get the principals of the logged in user, in this case the distinguished name.\n\n@return the distinguished name of the logged in user.", "predict": "\n\n*/\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.ldap.userdetails.LdapUserDetails;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LdapUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth == null) {\n            throw new UsernameNotFoundException(\"No user is logged in\");\n        }\n        Object principal = auth.getPrincipal();\n        if (principal instanceof LdapUserDetails) {\n            LdapUserDetails details = (LdapUserDetails) principal;\n            return details;\n        } else {\n            "}, {"ID": 117, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, \"HttpServletRequest required\"); if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(\"Invalidating session: \" + session.getId()); session.invalidate(); } } if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } SecurityContextHolder.clearContext(); } \nResponse:", "ground_truth": "Requires the request to be passed in.\n\n@param request from which to obtain a HTTP session (cannot be null)\n@param response not used (can be null)\n@param authentication not used (can be null)", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Controller\npublic class LogoutController {\n\n    @Autowired\n    private SecurityContextLogout"}, {"ID": 118, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Authentication authenticate(Authentication auth) throws AuthenticationException { if (!(auth instanceof UsernamePasswordAuthenticationToken)) { return null; } UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth; Set<GrantedAuthority> authorities; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext( new InternalCallbackHandler(auth)); // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext.login(); // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet<>(); // Get the subject principals and pass them to each of the AuthorityGranters Set<Principal> principals = loginContext.getSubject().getPrincipals(); for (Principal principal : principals) { for (AuthorityGranter granter : this.authorityGranters) { Set<String> roles = granter.grant(principal); // If the granter doesn't wish to grant any authorities, it should // return null. if ((roles != null) && !roles.isEmpty()) { for (String role : roles) { authorities.add(new JaasGrantedAuthority(role, principal)); } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken( request.getPrincipal(), request.getCredentials(), new ArrayList<>(authorities), loginContext); // Publish the success event publishSuccessEvent(result); // we're done, return the token. return result; } catch (LoginException loginException) { AuthenticationException ase = this.loginExceptionResolver .resolveException(loginException); publishFailureEvent(request, ase); throw ase; } } \nResponse:", "ground_truth": "Attempts to login the user given the Authentication objects principal and\ncredential\n\n@param auth The Authentication object to be authenticated.\n\n@return The authenticated Authentication object, with it's grantedAuthorities set.\n\n@throws AuthenticationException This implementation does not handle 'locked' or\n'disabled' accounts. This method only throws a AuthenticationServiceException, with\nthe message of the LoginException that will be thrown, should the\nloginContext.login() method fail.", "predict": "\n\n*/\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.token.DefaultTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Collection;\nimport java.util.Collections"}, {"ID": 119, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildProviderUrl(List<String> urls, String baseDn) { Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\"); Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\"); String trimmedBaseDn = baseDn.trim(); StringBuilder providerUrl = new StringBuilder(); for (String serverUrl : urls) { String trimmedUrl = serverUrl.trim(); if (\"\".equals(trimmedUrl)) { continue; } providerUrl.append(trimmedUrl); if (!trimmedUrl.endsWith(\"/\")) { providerUrl.append(\"/\"); } providerUrl.append(trimmedBaseDn); providerUrl.append(\" \"); } return providerUrl.toString(); } \nResponse:", "ground_truth": "Builds a Spring LDAP-compliant Provider URL string, i.e. a space-separated list of\nLDAP servers with their base DNs. As the base DN must be identical for all servers,\nit needs to be supplied only once.\n\n@param urls A list of string values which are LDAP server URLs. An example would be\n\n\nldap://ldap.company.com:389\n\n\n. LDAPS URLs may be used as well, given that Spring Security is able to connect to\nthe server.\n@param baseDn The common Base DN for all provided servers, e.g.\n\n\ndc=company,dc=com\n\n\n.\n@return A Spring Security/Spring LDAP-compliant Provider URL string.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.ldap.core.DirContextOperations;\nimport org.springframework.ldap.core.support.LdapContextSource;\nimport org.springframework.ldap.filter.AndFilter;\nimport org.springframework.ldap.filter.EqualsFilter;\nimport org.springframework.ldap.filter.Filter;\nimport org.springframework.ldap.filter.OrFilter;\nimport org.springframework.ldap.filter.WhitespaceWildcardsFilter;\nimport org.springframework.ldap.support.LdapUtils;\nimport org.springframework.util.Assert;\n\npublic class LdapUtilsTest {\n\n\tpublic static void main(String[] args) {\n\t\tLdapContextSource contextSource = new LdapContextSource();\n\t\tcontextSource.setUrl(\""}, {"ID": 120, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setContextEnvironmentProperties(Map<String, Object> environment) { Assert.notEmpty(environment, \"environment must not be empty\"); this.contextEnvironmentProperties = new Hashtable<>(environment); } \nResponse:", "ground_truth": "Allows a custom environment properties to be used to create initial LDAP context.\n\n@param environment the additional environment parameters to use when creating the LDAP Context", "predict": " void\n*/\n\npublic class ContextEnvironmentProperties {\n\tprivate Map<String, Object> contextEnvironmentProperties;\n\n\tpublic ContextEnvironmentProperties(Map<String, Object> contextEnvironmentProperties) {\n\t\tthis.contextEnvironmentProperties = contextEnvironmentProperties;\n\t}\n\n\tpublic Map<String, Object> getContextEnvironmentProperties() {\n\t\treturn contextEnvironmentProperties;\n\t}\n\n\tpublic void setContextEnvironmentProperties(Map<String, Object> contextEnvironmentProperties) {\n\t\tthis.contextEnvironmentProperties = contextEnvironmentProperties;\n\t}\n}\n"}, {"ID": 121, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String getRedirectUrl() { return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString); } \nResponse:", "ground_truth": "Indicates the URL that the user agent used for this request.\n\n@return the full URL of this request", "predict": " @Override public ResponseEntity<String> getResponse(String redirectUrl) { return new ResponseEntity<String>(HttpStatus.OK); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations.ApiResponse;\n"}, {"ID": 122, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int doEndTag() throws JspException { try { if (!authorized && TagLibConfig.isUiSecurityDisabled()) { pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix()); } } catch (IOException e) { throw new JspException(e); } return EVAL_PAGE; } \nResponse:", "ground_truth": "Default processing of the end tag returning EVAL_PAGE.\n\n@return EVAL_PAGE\n@see Tag#doEndTag()", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.struts2.StrutsStatics;\nimport org.apache.struts2.components.Component;\nimport org.apache.struts2.components.UIBean;\nimport org.apache.struts2.views.jsp.TagUtils;\n\nimport com.opensymphony.xwork2.util.ValueStack;\n\n/**\n * @author <a href=\"mailto:"}, {"ID": 123, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void initUserDetailsService() throws Exception { for (UserDetailsBuilder userBuilder : userBuilders) { getUserDetailsService().createUser(userBuilder.build()); } for (UserDetails userDetails : this.users) { getUserDetailsService().createUser(userDetails); } } \nResponse:", "ground_truth": "Populates the users that have been added.\n\n@throws Exception", "predict": " ResponseEntity<UserDetails[]> findAllUsers() { return new ResponseEntity<UserDetails[]>(this.users, HttpStatus.OK); } \nResp ResponseEntity<UserDetails> findUser(String username) { return new ResponseEntity<UserDetails>(this.users.get(username), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> createUser(UserDetails userDetails) { return new ResponseEntity<UserDetails>(this.users.put(userDetails.getUsername(), userDetails), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> updateUser(String username, UserDetails userDetails) { return new ResponseEntity<UserDetails>(this.users.put(username, userDetails), HttpStatus.OK); } \nResp ResponseEntity<UserDetails> deleteUser(String username) { return new ResponseEntity<UserDetails>(this.users.remove(username), HttpStatus.OK); } \nResp ResponseEntity"}, {"ID": 124, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private UserDetailsService getUserDetailsService() { Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class); if (beans.size() == 0) { beans = getBeansOfType(UserDetailsService.class); } if (beans.size() == 0) { throw new ApplicationContextException(\"No UserDetailsService registered.\"); } else if (beans.size() > 1) { throw new ApplicationContextException( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\"); } return (UserDetailsService) beans.values().toArray()[0]; } \nResponse:", "ground_truth": "Obtains a user details service for use in RememberMeServices etc. Will return a\ncaching version if available so should not be used for beans which need to separate\nthe two.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>OpenID Connect Demo</title>\n</head>\n<body>\n<h1>OpenID Connect Demo</h1>\n<p>\nThis example demonstrates how to use the OpenID Connect protocol to authenticate users.\n</p>\n<p>\nThe example uses the <a href=\"http://openid.net/specs/openid-connect-core-1_0.html\">OpenID Connect Core 1.0</a> specification.\n</p>\n<p>\nThe example uses the <a href=\"http://openid.net/specs/openid-connect-discovery-1_0.html\">OpenID Connect Discovery 1.0</a> specification.\n</p>\n<p>\nThe example uses the <a"}, {"ID": 125, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) { String codeVerifier = this.codeVerifierGenerator.generateKey(); attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier); try { String codeChallenge = createCodeChallenge(codeVerifier); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\"); } catch (NoSuchAlgorithmException e) { additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier); } } \nResponse:", "ground_truth": "Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests\n\n@param attributes where {@link PkceParameterNames#CODE_VERIFIER} is stored for the token request\n@param additionalParameters where {@link PkceParameterNames#CODE_CHALLENGE} and, usually,\n{@link PkceParameterNames#CODE_CHALLENGE_METHOD} are added to be used in the authorization request.\n\n@since 5.2\n@see 1.1.  Protocol Flow\n@see 4.1.  Client Creates a Code Verifier\n@see 4.2.  Client Creates the Code Challenge", "predict": " 200 OK\n\n*/\n\npackage com.microsoft.azure.cognitiveservices.language.textanalytics.models;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * The PkceParameters model.\n */\npublic class PkceParameters {\n    /**\n     * The codeVerifier property.\n     */\n    @JsonProperty(value = \"code_verifier\")\n    private String codeVerifier;\n\n    /**\n     * The codeChallenge property.\n     */\n    @JsonProperty(value = \"code_challenge\")\n    private String codeChallenge;\n\n    /**\n     * The codeChallengeMethod property.\n     */\n    @JsonProperty(value = \"code_challenge_method\")\n    private String codeChallengeMethod;\n\n    /**\n     * Get the codeVerifier value.\n     *\n     * @return the codeVerifier value\n     "}, {"ID": 126, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { final boolean serviceTicketRequest = serviceTicketRequest(request, response); final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request)); if (logger.isDebugEnabled()) { logger.debug(\"requiresAuthentication = \" + result); } return result; } \nResponse:", "ground_truth": "Overridden to provide proxying capabilities.", "predict": " Generate the method-level comment for the following java Code. Code: protected boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { final String serviceTicket = serviceTicketRequest(request, response); if (serviceTicket == null) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + serviceTicket); } return serviceTicket; } \nResp Generate the method-level comment for the following java Code. Code: protected boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorRequest(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \nResp Generate the method-level comment for the following java Code. Code: protected boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { final"}, {"ID": 127, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a service ticket. This method exists\nfor readability.\n@param request\n@param response\n@return", "predict": " Generate the method-level comment for the following java Code. Code: private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; } \n\n*/\n\n/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express"}, {"ID": 128, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { if (serviceTicketRequest) { return false; } final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated(); if (logger.isDebugEnabled()) { logger.debug(\"proxyTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a proxy ticket.\n@param request\n@return", "predict": " private boolean authenticateAllArtifacts = false; private boolean authenticated() { return authenticated; } private boolean authenticated = false; private Artifact obtainArtifact(final HttpServletRequest request) { return obtainArtifact(request, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId) { return obtainArtifact(request, artifactId, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType) { return obtainArtifact(request, artifactId, artifactType, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType, final String artifactQualifier) { return obtainArtifact(request, artifactId, artifactType, artifactQualifier, null); } private Artifact obtainArtifact(final HttpServletRequest request, final String artifactId, final String artifactType, final String artifactQualifier, final String artifactVersion) { return obtainArtifact("}, {"ID": 129, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean authenticated() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken); } \nResponse:", "ground_truth": "Determines if a user is already authenticated.\n@return", "predict": " ResponseEntity<String> authentication(Authentication authentication) { if (authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken)) { return new ResponseEntity<String>(\"User \" + authentication.getName() + \" is authenticated\", HttpStatus.OK); } else { return new ResponseEntity<String>(\"User is not authenticated\", HttpStatus.UNAUTHORIZED); } }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson."}, {"ID": 130, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to be processed as the proxy receptor.\n@param request\n@return", "predict": " Generate the method-level comment for the following java Code. Code: private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.google.common.base.Strings;\n\npublic class ProxyReceptorMatcher {\n\n\tprivate static final Pattern proxyReceptorPattern = Pattern.compile(\"^(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.(.*)\\\\.("}, {"ID": 131, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MethodSecurityExpressionOperations createSecurityExpressionRoot( Authentication authentication, MethodInvocation invocation) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot( authentication); root.setThis(invocation.getThis()); root.setPermissionEvaluator(getPermissionEvaluator()); root.setTrustResolver(getTrustResolver()); root.setRoleHierarchy(getRoleHierarchy()); root.setDefaultRolePrefix(getDefaultRolePrefix()); return root; } \nResponse:", "ground_truth": "Creates the root object for expression evaluation.", "predict": " Response = createSecurityExpressionRoot( authentication, invocation).checkPermission( permission); \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.access.expression.SecurityExpressionRoot;\nimport org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;\nimport org.springframework.security.access.expression.method.MethodSecurityExpressionOperations;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n@Component\npublic class MyMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {\n\n    @Autowired\n    @Qualifier(\"myPermissionEval"}, {"ID": 132, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Mono<JWKSet> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); } \nResponse:", "ground_truth": "Updates the cached JWK set from the configured URL.\n\n@return The updated JWK set.\n\n@throws RemoteKeySourceException If JWK retrieval failed.", "predict": "\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n    public Mono<Response<JWKSet>> getJWKSet() { return this.webClient.get() .uri(this.jwk"}, {"ID": 133, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String utf8UrlEncode(String value) { try { return URLEncoder.encode(value, \"UTF-8\"); } catch (UnsupportedEncodingException e) { Error err = new AssertionError( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\"); err.initCause(e); throw err; } } \nResponse:", "ground_truth": "Performs URL encoding with UTF-8\n\n@param value the value to URL encode\n@return the encoded value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 134, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() { List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser(); Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper .getGrantedAuthorities(webSphereGroups); if (logger.isDebugEnabled()) { logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas); } return userGas; } \nResponse:", "ground_truth": "Get a list of Granted Authorities based on the current user's WebSphere groups.\n\n@return authorities mapped from the user's WebSphere groups.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class WebSphereUserDetails implements UserDetails {\n\n    private static final long serialVersionUID = -828379812085662898L;\n\n    private final String userName;\n    private final String password;\n    private final List<GrantedAuthority> authorities;\n\n    public"}, {"ID": 135, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken( assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); } \nResponse:", "ground_truth": "Template method for retrieving the UserDetails based on the assertion. Default is\nto call configured userDetailsService and pass the username. Deployers can override\nthis method and retrieve the user based on any criteria they desire.\n\n@param assertion The CAS Assertion.\n@return the UserDetails.", "predict": " ResponseEntity<UserDetails> loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service(\"userDetailsService\")\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n"}, {"ID": 136, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = wasHelper.getCurrentUserName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated WebSphere principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the WebSphere user name.", "predict": " Response wasHelper.getPreAuthenticatedPrincipal(HttpServletRequest httpRequest);\n\n*/\n\nimport java.util.logging.Logger;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.ibm.websphere.security.auth.WSSubject;\nimport com.ibm.websphere.security.auth.WSSubjectProvider;\n\npublic class WASHelper {\n\tprivate static final Logger logger = Logger.getLogger(WASHelper.class.getName());\n\t\n\tpublic static Object getCurrentUserName() {\n\t\treturn WSSubject.getCallerPrincipal();\n\t}\n\t\n\tpublic static Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {\n\t\treturn WSSubjectProvider.getCallerPrincipal(httpRequest);\n\t}\n\t"}, {"ID": 137, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] concatenate(byte[]... arrays) { int length = 0; for (byte[] array : arrays) { length += array.length; } byte[] newArray = new byte[length]; int destPos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, newArray, destPos, array.length); destPos += array.length; } return newArray; } \nResponse:", "ground_truth": "Combine the individual byte arrays into one array.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 138, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] subArray(byte[] array, int beginIndex, int endIndex) { int length = endIndex - beginIndex; byte[] subarray = new byte[length]; System.arraycopy(array, beginIndex, subarray, 0, length); return subarray; } \nResponse:", "ground_truth": "Extract a sub array of bytes out of the byte array.\n@param array the byte array to extract from\n@param beginIndex the beginning index of the sub array, inclusive\n@param endIndex the ending index of the sub array, exclusive", "predict": "\n\n*/\n\nimport java.util.Arrays;\n\npublic class SubArray {\n    public static byte[] subArray(byte[] array, int beginIndex, int endIndex) {\n        int length = endIndex - beginIndex;\n        byte[] subarray = new byte[length];\n        System.arraycopy(array, beginIndex, subarray, 0, length);\n        return subarray;\n    }\n\n    public static void main(String[] args) {\n        byte[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(Arrays.toString(subArray(array, 2, 4)));\n    }\n}\n"}, {"ID": 139, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { ArrayList<GrantedAuthority> gaList = new ArrayList<>(); for (String attribute : attributes) { Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap .get(attribute); if (c != null) { gaList.addAll(c); } } gaList.trimToSize(); return gaList; } \nResponse:", "ground_truth": "Map the given array of attributes to Spring Security GrantedAuthorities.", "predict": "\n\npublic List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {\n\tArrayList<GrantedAuthority> gaList = new ArrayList<>();\n\tfor (String attribute : attributes) {\n\t\tCollection<GrantedAuthority> c = attributes2grantedAuthoritiesMap.get(attribute);\n\t\tif (c != null) {\n\t\t\tgaList.addAll(c);\n\t\t}\n\t}\n\tgaList.trimToSize();\n\treturn gaList;\n}\n\n*/\n\npublic class GrantedAuthorityImpl implements GrantedAuthority {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String authority;\n\n\tpublic GrantedAuthorityImpl(String authority) {\n\t\tthis.authority = authority;\n\t}\n\n\t@Override\n\tpublic String getAuthority() {\n\t\treturn authority;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;"}, {"ID": 140, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) { Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>( orgMap.size()); for (Map.Entry<?, ?> entry : orgMap.entrySet()) { Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\"); result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue())); } return result; } \nResponse:", "ground_truth": "Preprocess the given map to convert all the values to GrantedAuthority collections\n\n@param orgMap The map to process\n@return the processed Map", "predict": " private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object orgCollection) { if (orgCollection == null) { return null; } if (orgCollection instanceof Collection) { return (Collection<GrantedAuthority>) orgCollection; } if (orgCollection instanceof GrantedAuthority) { return Collections.singletonList((GrantedAuthority) orgCollection); } throw new IllegalArgumentException(\"attributes2grantedAuthoritiesMap contains non-Collection or non-GrantedAuthority objects as values\"); } \n\n*/\n"}, {"ID": 141, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) { Collection<GrantedAuthority> result = new ArrayList<>(); addGrantedAuthorityCollection(result, value); return result; } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.POST)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(@RequestBody Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.PUT)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection(@RequestBody Object value) { return ResponseEntity.ok(getGrantedAuthorityCollection(value)); } \n\n@RequestMapping(value = \"/getGrantedAuthorityCollection\", method = RequestMethod.DELETE)\npublic ResponseEntity<Collection<GrantedAuthority>> getGrantedAuthorityCollection"}, {"ID": 142, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) { if (value == null) { return; } if (value instanceof Collection<?>) { addGrantedAuthorityCollection(result, (Collection<?>) value); } else if (value instanceof Object[]) { addGrantedAuthorityCollection(result, (Object[]) value); } else if (value instanceof String) { addGrantedAuthorityCollection(result, (String) value); } else if (value instanceof GrantedAuthority) { result.add((GrantedAuthority) value); } else { throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName()); } } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities, adding the result\nto the given result collection.\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": "\n\npublic class UserDetailsImpl extends AbstractUserDetails implements UserDetails {\n    private static final long serialVersionUID = 1L;\n    private final String password;\n    private final Collection<GrantedAuthority> authorities;\n    private final boolean accountNonExpired;\n    private final boolean accountNonLocked;\n    private final boolean credentialsNonExpired;\n    private final boolean enabled;\n    private final String username;\n    private final String email;\n    private final String firstName;\n    private final String lastName;\n    private final String phoneNumber;\n    private final String address;\n    private final String city;\n    private final String state;\n    private final String zip;\n    private final String country;\n    private final String organization;\n    private final String organizationUnit;\n    private final String title;\n    private final String department;\n    private final String departmentUnit;\n    private final String departmentTitle;\n    private final String departmentDepartment;\n    private final String"}, {"ID": 143, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest .getUserPrincipal().getName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated J2EE principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the J2EE user name.", "predict": " Response.ok().build();\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\n\n@Path(\"/\")\npublic class HelloWorldResource {\n\n\tprivate static final Logger logger = Logger.getLogger(HelloWorldResource.class);\n\n\t@GET\n\t@Path(\"/hello\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic String getHelloWorld() {\n\t\tlogger.info(\"HelloWorldResource.getHelloWorld()\");\n\t\treturn \"Hello World\";\n\t}\n\n\t@GET\n\t@Path(\"/users"}, {"ID": 144, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); } \nResponse:", "ground_truth": "Gets a shared Object. Note that object heirarchies are not considered.\n\n@param sharedType the type of the shared Object\n@return the shared Object or null if it is not found", "predict": " @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); } \n\n*/\n\npublic class SharedObjects {\n\tprivate Map<Class<?>, Object> sharedObjects;\n\t\n\tpublic SharedObjects() {\n\t\tsharedObjects = new HashMap<Class<?>, Object>();\n\t}\n\t\n\tpublic <C> C getSharedObject(Class<C> sharedType) {\n\t\treturn (C) sharedObjects.get(sharedType);\n\t}\n\t\n\tpublic <C> void setSharedObject(Class<C> sharedType, C sharedObject) {\n\t\tsharedObjects.put(sharedType, sharedObject);\n\t}\n}\n"}, {"ID": 145, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException { int serverPort = portResolver.getServerPort(request); Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort)); if (httpsPort != null) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder(); urlBuilder.setScheme(\"https\"); urlBuilder.setServerName(request.getServerName()); urlBuilder.setPort(httpsPort.intValue()); urlBuilder.setContextPath(request.getContextPath()); urlBuilder.setServletPath(request.getServletPath()); urlBuilder.setPathInfo(request.getPathInfo()); urlBuilder.setQuery(request.getQueryString()); return urlBuilder.getUrl(); } // Fall through to server-side forward with warning message logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort); return null; } \nResponse:", "ground_truth": "Builds a URL to redirect the supplied request to HTTPS. Used to redirect the\ncurrent request to HTTPS, before doing a forward to the login page.", "predict": "\n\npublic class RedirectUrlBuilder {\n    private String scheme;\n    private String serverName;\n    private int port;\n    private String contextPath;\n    private String servletPath;\n    private String pathInfo;\n    private String query;\n\n    public String getUrl() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(scheme).append(\"://\").append(serverName);\n        if (port != -1) {\n            sb.append(\":\").append(port);\n        }\n        sb.append(contextPath).append(servletPath);\n        if (pathInfo != null) {\n            sb.append(pathInfo);\n        }\n        if (query != null) {\n            sb.append(\"?\").append(query);\n        }\n        return sb.toString();\n    }\n\n    public void setScheme(String scheme) {\n        this.scheme = scheme;\n    }"}, {"ID": 146, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); } \nResponse:", "ground_truth": "Method that is suitable for user with traditional AspectJ-code aspects.\n\n@param jp The AspectJ joint point being invoked which requires a security decision\n@param advisorProceed the advice-defined anonymous class that implements\n{@code AspectJCallback} containing a simple {@code return proceed();} statement\n\n@return The returned value from the method invocation", "predict": " public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); } \n\n*/\n\npackage com.aspectj.autoproxy;\n\nimport java.lang.reflect.Method;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\n\n@Aspect\npublic class Advice {\n\t@Pointcut(\"execution(public * com.aspectj.autoproxy"}, {"ID": 147, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String hasRole(String role) { Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\"); return \"ROLE_\" + role; } \nResponse:", "ground_truth": "Creates a String for specifying a user requires a role.\n\n@param role the role that should be required which is prepended with ROLE_\nautomatically (i.e. USER, ADMIN, etc). It should not start with ROLE_\n@return the {@link ConfigAttribute} expressed as a String", "predict": "\n\n@RequestMapping(value = \"/users/{userId}\", method = RequestMethod.GET)\npublic ResponseEntity<User> getUser(@PathVariable Long userId) {\n    return ResponseEntity.ok()\n        .header(\"Access-Control-Allow-Origin\", \"*\")\n        .header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\")\n        .header(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, DELETE, OPTIONS\")\n        .header(\"Access-Control-Max-Age\", \"3600\")\n        .header(\"Access-Control-Allow-Credentials\", \"true\")\n        .body(userService.getUser(userId));\n}\n\n@RequestMapping(value = \"/users\", method = RequestMethod.GET)\npublic ResponseEntity<List<User>> getAllUsers() {\n    return ResponseEntity."}, {"ID": 148, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String[] hasAnyRole(String... roles) { for (int i = 0; i < roles.length; i++) { roles[i] = \"ROLE_\" + roles[i]; } return roles; } \nResponse:", "ground_truth": "Creates a String for specifying that a user requires one of many roles.\n\n@param roles the roles that the user should have at least one of (i.e. ADMIN, USER,\netc). Each role should not start with ROLE_ since it is automatically prepended\nalready.\n@return the {@link ConfigAttribute} expressed as a String", "predict": " Response.ok().build();\n\n*/\n\npackage com.example.springmvc.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.JoinTable;\nimport javax.persistence.ManyToMany;\nimport javax.persistence.Table;\n\n@Entity\n@Table(name = \"user\")\npublic class User {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.AUTO)\n\t@Column(name = \"id\")\n\tprivate int id;\n\n\t@Column(name = \"name\")\n\tprivate String"}, {"ID": 149, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { if (cookieTokens.length != 2) { throw new InvalidCookieException(\"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\"); } final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException( \"No persistent token found for series id: \" + presentedSeries); } // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( \"PersistentTokenBasedRememberMeServices.cookieStolen\", \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\")); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System .currentTimeMillis()) { throw new RememberMeAuthenticationException(\"Remember-me login has expired\"); } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) { logger.debug(\"Refreshing persistent login token for user '\" + token.getUsername() + \"', series '\" + token.getSeries() + \"'\"); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try { tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); } catch (Exception e) { logger.error(\"Failed to update token: \", e); throw new RememberMeAuthenticationException( \"Autologin failed due to data access problem\"); } return getUserDetailsService().loadUserByUsername(token.getUsername()); } \nResponse:", "ground_truth": "Locates the presented cookie data in the token repository, using the series id. If\nthe data compares successfully with that in the persistent store, a new token is\ngenerated and stored with the same series. The corresponding cookie value is set on\nthe response.\n\n@param cookieTokens the series and token values\n\n@throws RememberMeAuthenticationException if there is no stored token corresponding\nto the submitted cookie, or if the token in the persistent store has expired.\n@throws InvalidCookieException if the cookie doesn't have two tokens as expected.\n@throws CookieTheftException if a presented series value is found, but the stored\ntoken is different from the one presented.", "predict": "\n\n@RequestMapping(value = \"/login\", method = RequestMethod.POST)\npublic String login(@RequestParam(\"j_username\") String username, @RequestParam(\"j_password\") String password, Model model, HttpServletRequest request, HttpServletResponse response) {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"login() - username: \" + username + \" - password: \" + password);\n\t}\n\tif (StringUtils.isEmpty(username)) {\n\t\tlogger.warn(\"login() - username is empty\");\n\t\treturn \"login\";\n\t}\n\tif (StringUtils.isEmpty(password)) {\n\t\tlogger.warn(\"login() - password is empty\");\n\t\treturn \"login\";\n\t}\n\ttry {\n\t\tUserDetails userDetails = getUserDetailsService().loadUserByUsername(username);\n\t\tif (userDetails == null) {\n\t\t\tlogger."}, {"ID": 150, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); logger.debug(\"Creating new persistent login for user \" + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try { tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } catch (Exception e) { logger.error(\"Failed to save persistent token \", e); } } \nResponse:", "ground_truth": "Creates a new persistent login token with a new series number, stores the data in\nthe persistent token repository and adds the corresponding cookie to the response.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.env.Environment;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport"}, {"ID": 151, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest; String username = request.getParameter(this.usernameParameter); if (username == null) { username = \"\"; } if (this.logger.isDebugEnabled()) { this.logger.debug(\"Attempt to switch to user [\" + username + \"]\"); } UserDetails targetUser = this.userDetailsService.loadUserByUsername(username); this.userDetailsChecker.check(targetUser); // OK, create the switch user token targetUserRequest = createSwitchUserToken(request, targetUser); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\"); } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser)); } return targetUserRequest; } \nResponse:", "ground_truth": "Attempt to switch to another user. If the user does not exist or is not active,\nreturn null.\n\n@return The new Authentication request if successfully switched to\nanother user, null otherwise.\n\n@throws UsernameNotFoundException If the target user is not found.\n@throws LockedException if the account is locked.\n@throws DisabledException If the target user is disabled.\n@throws AccountExpiredException If the target user account is expired.\n@throws CredentialsExpiredException If the target user credentials are expired.", "predict": "\n\npublic class AuthenticationSwitchUserEvent extends AbstractAuthenticationEvent {\n\tprivate UserDetails userDetails;\n\n\tpublic AuthenticationSwitchUserEvent(Authentication authentication, UserDetails userDetails) {\n\t\tsuper(authentication);\n\t\tthis.userDetails = userDetails;\n\t}\n\n\tpublic UserDetails getUserDetails() {\n\t\treturn this.userDetails;\n\t}\n}\n\n*/\n"}, {"ID": 152, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder.getContext().getAuthentication(); if (null == current) { throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noCurrentUser\", \"No current user associated with this request\")); } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication(current); if (original == null) { this.logger.debug(\"Could not find original user Authentication object!\"); throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noOriginalAuthentication\", \"Could not find original Authentication object\")); } // get the source user details UserDetails originalUser = null; Object obj = original.getPrincipal(); if ((obj != null) && obj instanceof UserDetails) { originalUser = (UserDetails) obj; } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent( new AuthenticationSwitchUserEvent(current, originalUser)); } return original; } \nResponse:", "ground_truth": "Authentication object or null\notherwise.\n\n@throws AuthenticationCredentialsNotFoundException If no\nAuthentication associated with this request.", "predict": "\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.POST)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.GET)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod.POST)\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n\tSecurityContextHolder.getContext().setAuthentication(null);\n\treturn \"redirect:/\";\n}\n\n@RequestMapping(value = \"/logout\", method = RequestMethod."}, {"ID": 153, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setExitUserUrl(String exitUserUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\"); this.exitUserMatcher = createMatcher(exitUserUrl); } \nResponse:", "ground_truth": "Set the URL to respond to exit user processing.\n\n@param exitUserUrl The exit user URL.", "predict": "\n\n@RequestMapping(value = \"/api/exituser\", method = RequestMethod.POST)\npublic ResponseEntity<ExitUser> exitUser(@RequestBody ExitUser exitUser) {\n\tAssert.notNull(exitUser, \"exitUser cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exitUserId cannot be null\");\n\tAssert.notNull(exitUser.getExitUserId(), \"exitUser.exit"}, {"ID": 154, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); } \nResponse:", "ground_truth": "The public index page, used for unauthenticated users.", "predict": "\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n@RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello"}, {"ID": 155, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); } \nResponse:", "ground_truth": "Creates the Spring Security Filter Chain\n@return the {@link Filter} that represents the security filter chain\n@throws Exception", "predict": "\n\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n@Bean(name = AbstractSecurityWebApplication"}, {"ID": 156, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); } \nResponse:", "ground_truth": "Decode and validate the JWT from its compact claims representation format\n\n@param token the JWT value\n@return a validated {@link Jwt}\n@throws JwtException", "predict": " @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); } \n\n*/\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.datab"}, {"ID": 157, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingAccessExpression() throws IOException { if (SecurityContextHolder.getContext().getAuthentication() == null) { return false; } SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler(); Expression accessExpression; try { accessExpression = handler.getExpressionParser().parseExpression(getAccess()); } catch (ParseException e) { IOException ioException = new IOException(); ioException.initCause(e); throw ioException; } return ExpressionUtils.evaluateAsBoolean(accessExpression, createExpressionEvaluationContext(handler)); } \nResponse:", "ground_truth": "Make an authorization decision based on a Spring EL expression. See the\n\"Expression-Based Access Control\" chapter in Spring Security for details on what\nexpressions can be used.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.access.expression.SecurityExpressionHandler;\nimport org.springframework.security.access.expression.SecurityExpressionOperations;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AccessExpressionEvaluator {\n\t\n\t@Autowired\n\tprivate SecurityExpressionHandler<FilterInvocation> expressionHandler;\n\t\n\tpublic boolean authorizeUsingAccessExpression() {\n\t\tAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\t\tif (authentication == null"}, {"ID": 158, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingUrlCheck() throws IOException { String contextPath = ((HttpServletRequest) getRequest()).getContextPath(); Authentication currentUser = SecurityContextHolder.getContext() .getAuthentication(); return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser); } \nResponse:", "ground_truth": "Make an authorization decision based on the URL and HTTP method attributes. True is\nreturned if the user is allowed to access the given URL as defined.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.Sets.SetView;\nimport com.google.common.collect.S"}, {"ID": 159, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<GrantedAuthority> convert(Jwt jwt) { return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Extracts the authorities\n@param jwt The {@link Jwt} token\n@return The {@link GrantedAuthority authorities} read from the token scopes", "predict": "\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList());\n}\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList());\n}\n\n@Override\npublic Collection<GrantedAuthority> convert(Jwt jwt) {\n    return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new"}, {"ID": 160, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } \nResponse:", "ground_truth": "Generates a new token\n@param request the {@link HttpServletRequest} to use. The\n{@link HttpServletRequest} must have the {@link HttpServletResponse} as an\nattribute with the name of HttpServletResponse.class.getName()", "predict": " @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } \n\nMethod: @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response) { return wrap(request, this.delegate.generateToken(request, response)); } \nResp @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response) { return wrap(request, this.delegate.generateToken(request, response)); } \n\nMethod: @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response, String cookieName) { return wrap(request, this.delegate.generateToken(request, response, cookieName)); } \nResp @Override public CsrfToken generateToken(HttpServletRequest request, HttpServletResponse response, String cookieName) {"}, {"ID": 161, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); } \nResponse:", "ground_truth": "Displays the permission admin page for a particular contact.", "predict": "\n\n@RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); } \n\n@RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact));"}, {"ID": 162, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); } \nResponse:", "ground_truth": "Displays the \"add permission\" page for a contact.", "predict": "\n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); } \n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public ModelAndView addPermission(@ModelAttribute(\"addPermission\") AddPermission addPermission, BindingResult result, ModelMap model) { Contact contact = addPermission.getContact(); if (result"}, {"ID": 163, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles submission of the \"add permission\" form.", "predict": "\n\n@RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients"}, {"ID": 164, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); } \nResponse:", "ground_truth": "Deletes a permission", "predict": " @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); } \nResp @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\")"}, {"ID": 165, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) { if (role == null) { return role; } if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) { return role; } if (role.startsWith(defaultRolePrefix)) { return role; } return defaultRolePrefix + role; } \nResponse:", "ground_truth": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if role\ndoes not already start with defaultRolePrefix.\n\n@param defaultRolePrefix\n@param role\n@return", "predict": " Response = Response.ok().entity(getRoleWithDefaultPrefix(defaultRolePrefix, role)).build();\n\n*/\n\npackage com.google.code.magja.model.user;\n\nimport java.util.Date;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport com.google.code.magja.model.BaseMagentoModel;\n\n/**\n * @author andre\n * @author Simon Zambrovski\n */\n@XmlRootElement\npublic class User extends BaseMagentoModel {\n\n  private static final long serialVersionUID = -8283798410095537984L;\n\n  private String username;\n\n  private String email;\n\n  private String password;\n\n  private String firstname;\n\n  private String lastname;\n\n  private String address;\n\n  private String city;\n\n  private String state;\n\n  private String country;\n\n  private String zip;\n\n  private String"}, {"ID": 166, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UserDetailsResourceFactoryBean fromString(String users) { InMemoryResource resource = new InMemoryResource(users); return fromResource(resource); } \nResponse:", "ground_truth": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean", "predict": " ResponseEntity<UserDetailsResource> fromResource(Resource resource) { return new ResponseEntity<UserDetailsResource>(new UserDetailsResource(resource), HttpStatus.OK); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.Api"}, {"ID": 167, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; } \nResponse:", "ground_truth": "Returns the values for a specific attribute\n\n@param name the attribute name\n@return a String array, never null but may be zero length", "predict": " public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; } \n\n*/\n\npublic class Solution {\n    public List<String> getAttributeValues(String name) {\n        List<String> result = null;\n        if (attributes != null) {\n            result = attributes.get(name);\n        }\n        if (result == null) {\n            result = Collections.emptyList();\n        }\n        return result;\n    }\n}\n"}, {"ID": 168, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getFirstAttributeValue(String name) { List<String> result = getAttributeValues(name); if (result.isEmpty()) { return null; } else { return result.get(0); } } \nResponse:", "ground_truth": "Returns the first attribute value for a specified attribute\n\n@param name\n@return the first attribute value for a specified attribute, may be null", "predict": " Response is generated by the method getFirstAttributeValue(String name)\n\n*/\n\npublic class GetAttributeValues {\n\tpublic static void main(String[] args) {\n\t\tString name = \"name\";\n\t\tString response = \"Response is generated by the method getFirstAttributeValue(String name)\";\n\t\tSystem.out.println(response);\n\t}\n}\n"}, {"ID": 169, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] encode(CharSequence string) { try { ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string)); byte[] bytesCopy = new byte[bytes.limit()]; System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit()); return bytesCopy; } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } } \nResponse:", "ground_truth": "Get the bytes of the String in UTF-8 encoded form.", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String encoded = encode(input);\n        System.out.println(encoded);\n    }\n\n    public static String encode(String input) {\n        byte[] bytes = input.getBytes();\n        byte[] encoded = Base64.getEncoder().encode(bytes);\n        return new String(encoded);\n    }\n\n    public static String decode(String input) {\n        byte[] bytes = Base64.getDecoder().decode(input.getBytes());"}, {"ID": 170, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(byte[] bytes) { try { return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString(); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Decoding failed\", e); } } \nResponse:", "ground_truth": "Decode the bytes in UTF-8 form into a String.", "predict": " public static byte[] encode(String string) { try { return CHARSET.newEncoder().encode(CharBuffer.wrap(string)); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } } \n\n*/\n\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.util.Arrays;\n\npublic class CharsetDemo {\n    public static void main(String[] args) {\n        Charset cs = Charset.forName(\"UTF-8\");\n        CharsetEncoder encoder = cs.newEncoder();\n        CharsetDec"}, {"ID": 171, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends AccessibleObject> String[] lookupParameterNames( ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; } \nResponse:", "ground_truth": "Gets the parameter names or null if not found.\n\n@param parameterNameFactory the {@link ParameterNameFactory} to use\n@param t the {@link AccessibleObject} to find the parameter names on (i.e. Method\nor Constructor)\n@return the parameter names or null", "predict": " private <T extends AccessibleObject> String[] lookupParameterNames(ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ParameterNameFactory"}, {"ID": 172, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles the submission of the contact form, creating a new instance if the username\nand email are valid.", "predict": "\n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \n\n@RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST"}, {"ID": 173, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) { if (targetClass == null) { return null; } return findAttributesSpecifiedAgainst(method, targetClass); } \nResponse:", "ground_truth": "Will walk the method inheritance tree to find the most specific declaration\napplicable.", "predict": " Response is generated by the following java Code. Code: @Override protected Collection<ConfigAttribute> findAttributes(Object object) { if (object == null) { return null; } return findAttributesSpecifiedAgainst(object); } \n\n*/\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.springframework.security.access.ConfigAttribute;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.web.FilterInvocation;\n\npublic class FilterInvocationSecurityMetadataSource extends org.springframework.security.access.intercept.FilterInvocationSecurityMetadataSource {\n\n\tpublic Collection<ConfigAttribute> findAttributes(Object object) {\n\t\tif (object instanceof FilterInvocation) {\n\t\t\tFilterInvocation fi = (FilterInvocation) object;\n\t\t\treturn findAttributesSpecifiedAgainst(fi.getHttpRequest().getRequestURI(), fi.get"}, {"ID": 174, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) { Assert.notNull(method, \"RegisteredMethod required\"); Assert.notNull(attr, \"Configuration attribute required\"); if (logger.isInfoEnabled()) { logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\"); } this.methodMap.put(method, attr); } \nResponse:", "ground_truth": "Add configuration attributes for a secure method.\n\n@param method the method to be secured\n@param attr required authorities associated with the method", "predict": "\n\n*/\n\npackage org.springframework.security.oauth2.provider.endpoint;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.security.oauth2.common.exceptions.InvalidClientException;\nimport org.springframework.security.oauth2.common.exceptions.InvalidGrantException;\nimport org.springframework.security.oauth2.common.exceptions.InvalidRequestException;\nimport org.springframework.security.oauth2.common.exceptions.OAuth2Exception;\nimport org.springframework.security.oauth2.provider.ClientDetails;\nimport org.springframework.security.oauth2.provider.ClientRegistrationException;\nimport org.springframework.security.oauth2.provider.OAuth2RequestValidator;\nimport org.springframework.security.oauth2.provider"}, {"ID": 175, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; } \nResponse:", "ground_truth": "Obtains the configuration attributes explicitly defined against this bean.\n\n@return the attributes explicitly defined against this bean", "predict": " @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.security.access.ConfigAttribute;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.web.FilterInvocation;\n\npublic class MethodSecurityMetadataSource extends org.springframework.security.access.method.MethodSecurityMetadataSource {\n\n\tprivate Map<String, List<ConfigAttribute>> methodMap;\n\n\tpublic MethodSecurityMetadataSource(Map<String, List<ConfigAttribute>> methodMap) {\n\t\tthis.methodMap = methodMap;\n"}, {"ID": 176, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isMatch(String methodName, String mappedName) { return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length()))); } \nResponse:", "ground_truth": "Return if the given method name matches the mapped name. The default implementation\nchecks for \"xxx\" and \"xxx\" matches.\n\n@param methodName the method name of the class\n@param mappedName the name in the descriptor\n\n@return if the names match", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.isMatch(\"aa\",\"a\"));\n    }\n\n    public boolean isMatch(String s, String p) {\n        if(s.length() == 0 && p.length() == 0) return true;\n        if(s.length() == 0 || p.length() == 0) return false;\n        if(s.charAt(0) == p.charAt(0)) return isMatch(s.substring(1), p.substring(1));\n        return false;\n    }\n}\n"}, {"ID": 177, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResponse:", "ground_truth": "Maps any request.\n\n@return the object that is chained after creating the {@link RequestMatcher}", "predict": " public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResp public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_RE"}, {"ID": 178, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void handleBindException(String userDn, String username, Throwable cause) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to bind as \" + userDn + \": \" + cause); } } \nResponse:", "ground_truth": "Allows subclasses to inspect the exception thrown by an attempt to bind with a\nparticular DN. The default implementation just reports the failure to the debug\nlogger.", "predict": "\n\n*/\n\npackage com.ibm.ws.security.saml.sso20.acs;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.opensaml.saml2.core.Assertion;\nimport org.opensaml.saml2.core.Attribute;\nimport org.opensaml.saml2.core.AttributeStatement;\nimport org.opensaml.saml2.core.AttributeValue;\nimport org.opensaml.saml2.core.Audience;\nimport org.opensaml.saml2.core.AudienceRestriction;\nimport org.opensaml.saml2.core.Conditions;\nimport org.opensaml.saml2.core.NameID;\nimport org.opensaml.saml2"}, {"ID": 179, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); } \nResponse:", "ground_truth": "This is a public method.", "predict": "\n\n@Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); } \n\n*/\n\n@Transactional(readOnly = true)\npublic Contact getRandomContact() {\n\tlogger.debug(\"Returning random contact\");\n\tRandom rnd = new Random();\n\tList<Contact> contacts = contactDao.findAll();\n\tint getNumber = rnd.nextInt(contacts.size());\n\treturn contacts.get(getNumber);\n}\n\n}\n"}, {"ID": 180, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void clearAuthenticationAttributes(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); } \nResponse:", "ground_truth": "Removes temporary authentication-related data which may have been stored in the\nsession during the authentication process.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation."}, {"ID": 181, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException { Assert.notNull(clazz, \"Class required\"); Assert.hasText(fieldName, \"Field name required\"); try { return clazz.getDeclaredField(fieldName); } catch (NoSuchFieldException nsf) { // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName); } throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz); } } \nResponse:", "ground_truth": "Attempts to locate the specified field on the class.\n\n@param clazz the class definition containing the field\n@param fieldName the name of the field to locate\n\n@return the Field (never null)\n\n@throws IllegalStateException if field could not be found", "predict": "\n\n*/\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FieldUtils {\n\n    public static List<Field> getFields(Class<?> clazz) {\n        List<Field> fields = new ArrayList<Field>();\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field : declaredFields) {\n            fields.add(field);\n        }\n        return fields;\n    }\n\n    public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException {\n        Field field = null;\n        try {\n            field = clazz.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException nsf) {\n            // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName);"}, {"ID": 182, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) { return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId); } \nResponse:", "ground_truth": "Constructs a new Service Url. The default implementation relies on the CAS client\nto do the bulk of the work.\n@param request the HttpServletRequest\n@param response the HttpServlet Response\n@return the constructed service url. CANNOT be NULL.", "predict": " Response\n\n*/\n\npackage com.microsoft.bingads.v12.bulk.entities;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.BiConsumer;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport com.microsoft.bingads.internal.functionalinterfaces.Supplier;\nimport com.microsoft.bingads.v12.bulk.BulkFileReader;\nimport com.microsoft.bingads.v12.bulk.BulkFileWriter;\nimport com.microsoft.bingads.v12.bulk.BulkOperation;\nimport com.microsoft.bingads.v12.bulk.BulkServiceManager;\nimport com.microsoft.bingads.v12.bulk.BulkStreamReader;\nimport com.microsoft.bingads.v12.b"}, {"ID": 183, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createRedirectUrl(final String serviceUrl) { return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false); } \nResponse:", "ground_truth": "Constructs the Url for Redirection to the CAS server. Default implementation relies\non the CAS client to do the bulk of the work.\n\n@param serviceUrl the service url that should be included.\n@return the redirect url. CANNOT be NULL.", "predict": " Response\n\n*/\n\npackage com.microsoft.bingads.v12.reporting;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.BiConsumer;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport com.microsoft.bingads.internal.functionalinterfaces.Supplier;\nimport com.microsoft.bingads.v12.reporting.ReportFormat;\nimport com.microsoft.bingads.v12.reporting.ReportTimePeriod;\n\npublic class ReportRequest {\n\t\n\tprivate ReportFormat format;\n\t\n\tprivate ReportTimePeriod timePeriod;\n\t\n\tprivate List<String> reportEntities;\n\t\n\tprivate List<String> reportColumns;\n\t\n\tprivate Map<String, String> reportFilters;\n\t"}, {"ID": 184, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String extractPrefix(String encPass) { if (!encPass.startsWith(\"{\")) { return null; } int secondBrace = encPass.lastIndexOf('}'); if (secondBrace < 0) { throw new IllegalArgumentException( \"Couldn't find closing brace for SHA prefix\"); } return encPass.substring(0, secondBrace + 1); } \nResponse:", "ground_truth": "Returns the hash prefix or null if there isn't one.", "predict": "\n\n*/\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        String[] input = new String[n];\n        for(int a0 = 0; a0 < n; a0++){\n            input[a0] = in.next();\n        }\n        String result = \"\";\n        for(int a0 = 0; a0 < n; a0++){\n            result += input[a0].charAt(0);\n        }\n        System.out.println(result);\n    }\n}\n"}, {"ID": 185, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); } \nResponse:", "ground_truth": "Always returns a 403 error code to the client.", "predict": "\npublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class SimpleServlet extends HttpServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServlet"}, {"ID": 186, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkFilterStack(List<Filter> filters) { checkForDuplicates(SecurityContextPersistenceFilter.class, filters); checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters); checkForDuplicates(SessionManagementFilter.class, filters); checkForDuplicates(BasicAuthenticationFilter.class, filters); checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters); checkForDuplicates(JaasApiIntegrationFilter.class, filters); checkForDuplicates(ExceptionTranslationFilter.class, filters); checkForDuplicates(FilterSecurityInterceptor.class, filters); } \nResponse:", "ground_truth": "Checks the filter list for possible errors and logs them", "predict": "\n\npublic class FilterSecurityInterceptor extends OncePerRequestFilter {\n\t@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n\t\tList<Filter> filters = getFilters(request);\n\t\tcheckFilterStack(filters);\n\t\tfilterChain.doFilter(request, response);\n\t}\n}\n\n*/\n"}, {"ID": 187, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final Class<? extends Throwable>[] getRegisteredTypes() { Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet(); return typeList.toArray(new Class[typeList.size()]); } \nResponse:", "ground_truth": "Returns an array containing the classes for which extractors are registered. The\norder of the classes is the order in which comparisons will occur for resolving a\nmatching extractor.\n\n@return the types for which extractors are registered", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 188, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Throwable extractCause(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractCause(throwable); } } return null; } \nResponse:", "ground_truth": "Extracts the cause of the given throwable using an appropriate extractor.\n\n@param throwable the Throwable (not null\n@return the cause, may be null if none could be resolved", "predict": " Response<T> extractResponse(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractResponse(throwable); } } return null; } \n\n*/\n\npublic class ThrowableCauseExtractor {\n\t\n\tprivate Map<Class<? extends Throwable>, ThrowableCauseExtractor> extractorMap = new HashMap<Class<? extends Throwable>, ThrowableCauseExtractor>();\n\t\n\tpublic ThrowableCauseExtractor() {\n\t\textractorMap.put(NullPointerException.class, new NullPointerCauseExtractor());\n\t\textractorMap.put(IllegalArgumentException.class, new IllegalArgumentCauseExtractor());\n\t\textractor"}, {"ID": 189, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder .rootBeanDefinition(AffirmativeBased.class); ManagedList voters = new ManagedList(4); if (expressionVoter != null) { voters.add(expressionVoter); } voters.add(new RootBeanDefinition(RoleVoter.class)); voters.add(new RootBeanDefinition(AuthenticatedVoter.class)); if (jsr250Enabled) { voters.add(new RootBeanDefinition(Jsr250Voter.class)); } accessMgrBuilder.addConstructorArgValue(voters); BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition(); String id = pc.getReaderContext().generateBeanName(accessManager); pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id)); return id; } \nResponse:", "ground_truth": "Register the default AccessDecisionManager. Adds the special JSR 250 voter jsr-250\nis enabled and an expression voter if expression-based access control is enabled.\n@return", "predict": "\n\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic class AffirmativeBased extends AffirmativeBasedSupport {\n\tpublic AffirmativeBased(List voters) {\n\t\tsuper(voters);\n\t}\n\tpublic boolean isRequestAuthenticated(HttpServletRequest request) {\n\t\treturn super.isRequestAuthenticated(request);\n\t}\n\tpublic boolean supports(Class clazz) {\n\t\treturn super.supports(clazz);\n\t}\n\tpublic void decide(Authentication authentication, Object object, Collection collection) {\n\t\tsuper.decide(authentication, object, collection);\n\t}\n\tpublic void setMessageSource(MessageSource messageSource) {\n\t\tsuper.setMessageSource(messageSource);\n\t}\n\tpublic void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n\t\tsuper.setApplicationEventPublisher(applicationEventPublisher);\n\t}\n\tpublic void setApplicationContext(ApplicationContext application"}, {"ID": 190, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) { Assert.notNull(userAuthorities, \"userAuthorities cannot be null\"); Set<String> set = new HashSet<>(userAuthorities.size()); for (GrantedAuthority authority : userAuthorities) { set.add(authority.getAuthority()); } return set; } \nResponse:", "ground_truth": "Converts an array of GrantedAuthority objects to a Set.\n@return a Set of the Strings obtained from each call to\nGrantedAuthority.getAuthority()", "predict": " ResponseEntity<Set<String>> setAuthorities(Collection<? extends GrantedAuthority> authorities);\n\n*/\n\nimport java.util.Collection;\nimport java.util.Set;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\npublic class UserDetailsImpl implements UserDetails {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate String password;\n\tprivate Set<GrantedAuthority> authorities;\n\t\n\tpublic UserDetailsImpl(String username, String password, Collection<? extends GrantedAuthority> authorities) {\n\t\tthis.username = username;\n\t\tthis.password = password;\n\t\tthis.authorities = new HashSet<GrantedAuthority>(authorities);\n\t}\n\n\t@Override\n\tpublic Collection<? extends GrantedAuthor"}, {"ID": 191, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean matches(byte[] expected, byte[] actual) { if (expected.length != actual.length) { return false; } int result = 0; for (int i = 0; i < expected.length; i++) { result |= expected[i] ^ actual[i]; } return result == 0; } \nResponse:", "ground_truth": "Constant time comparison to prevent against timing attacks.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 192, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDefaultFailureUrl(String defaultFailureUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\"); this.defaultFailureUrl = defaultFailureUrl; } \nResponse:", "ground_truth": "The URL which will be used as the failure destination.\n\n@param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".", "predict": " public void setDefaultSuccessUrl(String defaultSuccessUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultSuccessUrl), () -> \"'\" + defaultSuccessUrl + \"' is not a valid redirect URL\"); this.defaultSuccessUrl = defaultSuccessUrl; } \nResp public void setDefaultExceptionUrl(String defaultExceptionUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultExceptionUrl), () -> \"'\" + defaultExceptionUrl + \"' is not a valid redirect URL\"); this.defaultExceptionUrl = defaultExceptionUrl; } \nResp public void setDefaultFailureView(String defaultFailureView) { Assert.isTrue(ViewNames.isValidViewName(defaultFailureView), () -> \"'\" + defaultFailureView + \"' is not a valid view name\"); this.defaultFailureView = defaultFailureView; } \nResp public void setDefaultSuccessView(String defaultSuccessView) { Assert.isTrue(ViewNames.is"}, {"ID": 193, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; } \nResponse:", "ground_truth": "Sets a Function used to resolve a Map of the hidden inputs where the key is the\nname of the input and the value is the value of the input. Typically this is used\nto resolve the CSRF token.\n@param resolveHiddenInputs the function to resolve the inputs", "predict": " public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; } \n\n}\n"}, {"ID": 194, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildRequestUrl(String servletPath, String requestURI, String contextPath, String pathInfo, String queryString) { StringBuilder url = new StringBuilder(); if (servletPath != null) { url.append(servletPath); if (pathInfo != null) { url.append(pathInfo); } } else { url.append(requestURI.substring(contextPath.length())); } if (queryString != null) { url.append(\"?\").append(queryString); } return url.toString(); } \nResponse:", "ground_truth": "Obtains the web application-specific fragment of the URL.", "predict": " private static String buildResponse(String contentType, String content) { return \"HTTP/1.1 200 OK\\r\\nContent-Type: \" + contentType + \"\\r\\nContent-Length: \" + content.length() + \"\\r\\n\\r\\n\" + content; } \n\n*/\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Servlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Serv"}, {"ID": 195, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAbsoluteUrl(String url) { if (url == null) { return false; } final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE); return ABSOLUTE_URL.matcher(url).matches(); } \nResponse:", "ground_truth": "Decides if a URL is absolute based on whether it contains a valid scheme name, as\ndefined in RFC 1738.", "predict": "\n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static boolean isAbsoluteUrl(String url) {\n        if (url == null) {\n            return false;\n        }\n        final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = ABSOLUTE_URL.matcher(url);\n        return matcher.matches();\n    }\n}\n"}, {"ID": 196, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<OpenIDAttribute> createAttributeList(String identifier) { for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) { if (entry.getKey().matcher(identifier).matches()) { return entry.getValue(); } } return Collections.emptyList(); } \nResponse:", "ground_truth": "Iterates through the patterns stored in the map and returns the list of attributes\ndefined for the first match. If no match is found, returns an empty list.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OpenIDAttribute {\n    private String name;\n    private String type;\n    private String count;\n    private String value;\n    private String valueFormat;\n    private String required;\n    private String description;\n    private String issuer;\n    private String ui;\n    private String preferred;\n    private String isRequired;\n    private String isMultiValued;\n    private String isCounted;\n    private String isToken;\n    private String isUri;\n    private String isEmail;\n    private String isIP;\n    private String isDN;\n    private String isX500;\n    private String isBinary;\n    private String isPattern;\n    private String isRegularExpression;\n    "}, {"ID": 197, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; } \nResponse:", "ground_truth": "Converts the raw type from the database into the right Java type. For most applications the 'raw type' will be Long, for some applications\nit could be String.\n@param identifier The identifier from the database\n@param resultSet  Result set of the query\n@return The identifier in the appropriate target Java type. Typically Long or UUID.\n@throws SQLException", "predict": " Response(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; } \n\n*/\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.J"}, {"ID": 198, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createEntries(final MutableAcl acl) { if (acl.getEntries().isEmpty()) { return; } jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() { public int getBatchSize() { return acl.getEntries().size(); } public void setValues(PreparedStatement stmt, int i) throws SQLException { AccessControlEntry entry_ = acl.getEntries().get(i); Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\"); AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_; stmt.setLong(1, ((Long) acl.getId()).longValue()); stmt.setInt(2, i); stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true) .longValue()); stmt.setInt(4, entry.getPermission().getMask()); stmt.setBoolean(5, entry.isGranting()); stmt.setBoolean(6, entry.isAuditSuccess()); stmt.setBoolean(7, entry.isAuditFailure()); } }); } \nResponse:", "ground_truth": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl\nobject.\n\n@param acl containing the ACEs to insert", "predict": " ResponseCode.SUCCESS\n*/\n\npublic class AclImpl extends AbstractAcl<Long> implements Acl {\n\n    private static final long serialVersionUID = -8283798430740551837L;\n\n    public AclImpl(Long id) {\n        super(id);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries) {\n        super(id, entries);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries, List<Sid> sids) {\n        super(id, entries, sids);\n    }\n\n    public AclImpl(Long id, List<AccessControlEntryImpl> entries, List<Sid> sids, boolean isAuditSuccess, boolean isAuditFailure) {\n        super(id, entries, sids, isAuditSuccess, isAuditFailure);\n    }\n\n    public AclImpl(Long id,"}, {"ID": 199, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createObjectIdentity(ObjectIdentity object, Sid owner) { Long sidId = createOrRetrieveSidPrimaryKey(owner, true); Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass()); jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId, Boolean.TRUE); } \nResponse:", "ground_truth": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity.\nThe Sid is also necessary, as acl_object_identity has defined the sid column as\nnon-null.\n\n@param object to represent an acl_object_identity for\n@param owner for the SID column (will be created if there is no acl_sid entry for\nthis particular Sid already)", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 200, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void updateObjectIdentity(MutableAcl acl) { Long parentId = null; if (acl.getParentAcl() != null) { Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl() .getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\"); ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl() .getObjectIdentity(); parentId = retrieveObjectIdentityPrimaryKey(oii); } Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\"); Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true); int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId()); if (count != 1) { throw new NotFoundException(\"Unable to locate ACL to update\"); } } \nResponse:", "ground_truth": "Updates an existing acl_object_identity row, with new information presented in the\npassed MutableAcl object. Also will create an acl_sid entry if needed for the Sid\nthat owns the MutableAcl.\n\n@param acl to modify (a row must already exist in acl_object_identity)\n\n@throws NotFoundException if the ACL could not be found to update.", "predict": " ResponseEntity<Object> updateObjectIdentity(@PathVariable(\"id\") Long id, @RequestBody MutableAcl mutableAcl) { return new ResponseEntity<Object>(updateObjectIdentity(mutableAcl), HttpStatus.OK); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\npublic void deleteObjectIdentity(@PathVariable(\"id\") Long id) { jdbcOperations.update(\"delete from acl_object_identity where id = ?\", id); }\n\n@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n@ResponseStatus(HttpStatus.OK)\n@ResponseBody\npublic MutableAcl readObjectIdentity(@PathVariable(\"id\") Long id) { return readObjectIdentity(id, false); }\n\n@RequestMapping(value = \"/{id}"}, {"ID": 201, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (requestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); if (createSessionAllowed || request.getSession(false) != null) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request.getSession().setAttribute(this.sessionAttrName, savedRequest); logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest); } } else { logger.debug(\"Request not saved as configured RequestMatcher did not match\"); } } \nResponse:", "ground_truth": "Stores the current request, provided the configuration properties allow it.", "predict": "\n\n*/\n\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Date;\n\npublic class DefaultSavedRequest {\n\n    private final HttpServletRequest request;\n    private final HttpServletResponse response;\n    private final RequestMatcher requestMatcher;\n    private final PortResolver portResolver;\n    private final String requestCacheKey;\n    private final String requestCachePrefix;\n    private final String sessionAttrName;\n    private final boolean createSessionAllowed;\n\n    public DefaultSavedRequest(HttpServletRequest request, PortResolver portResolver, RequestMatcher requestMatcher, String requestCacheKey, String requestCachePrefix, String sessionAttr"}, {"ID": 202, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); } \nResponse:", "ground_truth": "Creates a matcher that matches on the specific method and any of the provided patterns.\n@param method the method to match on. If null, any method will be matched\n@param patterns the patterns to match on\n@return the matcher to use", "predict": " public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); } \nResp public static ServerWebExchangeMatcher pathMatchers(String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern)); } return new OrServerWebExchangeMatcher(matchers); } \nResp public static ServerWebExchangeMatcher pathMatchers(String pattern, HttpMethod method) { return new PathPatternParserServerWebExchangeMatcher(pattern, method); } \nResp"}, {"ID": 203, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; } \nResponse:", "ground_truth": "Matches any exchange\n@return the matcher to use", "predict": "\n\npublic static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; }\n\n*/\n\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static java.util.stream.Collectors.toMap;\n\npublic class ServerWebExchangeMatcher {\n\n    public static <T> ServerWebExchangeMatcher anyExchange() {\n        return new ServerWebExchangeMatcher();\n    }\n\n    "}, {"ID": 204, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"stronger\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#stronger(CharSequence, CharSequence)", "predict": "\n\npublic static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        String[] input = {\n                \"abc\",\n                \"abcdefghijklmnopqrstuvwxyz\",\n                \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\",\n                \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:',./<>"}, {"ID": 205, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"standard\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#standard(CharSequence, CharSequence)", "predict": "\n\npublic static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); } \n\n*/\n\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Base64.DecodingException;\nimport java.util.Base64.EncodingException;\nimport java.util.Base64.UnsupportedEncodingException;\n\npublic class HexEncodingTextEncryptor {\n    private static final Encoder encoder = Base64.getEncoder();\n    private static final Decoder decoder = Base64.getDecoder();\n\n    public static String standard(CharSequence password, CharSequence salt) {\n        byte[] passwordBytes = password.toString().getBytes();\n        byte[] saltBytes = salt.toString()."}, {"ID": 206, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt)); } \nResponse:", "ground_truth": "Creates an encryptor for queryable text strings that uses standard password-based\nencryption. Uses a 16-byte all-zero initialization vector so encrypting the same\ndata results in the same encryption result. This is done to allow encrypted data to\nbe queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the\nsecret key", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Base64.Encoder;\nimport java.util.Base64.Decoder;\nimport java.util.Base64.DecodingException;\nimport java.util.Base64.EncodingException;\nimport java.util.Base64.UnsupportedEncodingException;\n\npublic class HexEncodingTextEncryptor implements TextEncryptor {\n    private final Encoder encoder = Base64.getEncoder();\n    private final Decoder decoder = Base64.getDecoder();\n\n    public HexEncodingTextEncryptor(byte[] key) {\n        this.key = key;\n    }\n\n    public String encrypt(String plaintext) {\n        try {\n            return encoder.encodeToString(encrypt(plaintext.getBytes(\"UTF-8\")));\n        } catch (UnsupportedEncodingException e) {\n"}, {"ID": 207, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeHeaders(HttpServletRequest request, HttpServletResponse response) { if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) { String allowFromValue = this.allowFromStrategy.getAllowFromValue(request); if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode()); } } else if (allowFromValue != null) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFromValue); } } } else { response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode()); } } \nResponse:", "ground_truth": "Writes the X-Frame-Options header value, overwritting any previous value.\n\n@param request the servlet request\n@param response the servlet response", "predict": "\n\npublic void writeHeaders(HttpServletRequest request, HttpServletResponse response) {\n\tif (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) {\n\t\tString allowFromValue = this.allowFromStrategy.getAllowFromValue(request);\n\t\tif (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) {\n\t\t\tif (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {\n\t\t\t\tresponse.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode());\n\t\t\t}\n\t\t} else if (allowFromValue != null) {\n\t\t\tif (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {\n\t\t\t\tresponse.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFrom"}, {"ID": 208, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc\n\n@since 5.2", "predict": " ResponseEntity<String> determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations"}, {"ID": 209, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available String targetUrl = null; if (targetUrlParameter != null) { targetUrl = request.getParameter(targetUrlParameter); if (StringUtils.hasText(targetUrl)) { logger.debug(\"Found targetUrlParameter in request: \" + targetUrl); return targetUrl; } } if (useReferer && !StringUtils.hasLength(targetUrl)) { targetUrl = request.getHeader(\"Referer\"); logger.debug(\"Using Referer header: \" + targetUrl); } if (!StringUtils.hasText(targetUrl)) { targetUrl = defaultTargetUrl; logger.debug(\"Using default Url: \" + targetUrl); } return targetUrl; } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc.", "predict": " Generate the method-level comment for the following java Code. Code: protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available ModelAndView modelAndView = null; if (targetUrlParameter != null) { modelAndView = new ModelAndView(new RedirectView(determineTargetUrl(request, response))); } else { modelAndView = new ModelAndView(new RedirectView(determineTargetUrl(request, response))); } if (useReferer && !StringUtils.hasLength(modelAndView.getViewName())) { modelAndView.addObject(\"referer\", request.getHeader(\"Referer\")); } return modelAndView; } \nResp Generate the method-level comment for the following java Code. Code: protected ModelAndView handleRequestInternal(HttpServ"}, {"ID": 210, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResponse:", "ground_truth": "If this property is set, the current request will be checked for this a parameter\nwith this name and the value used as the target URL if present.\n\n@param targetUrlParameter the name of the parameter containing the encoded target\nURL. Defaults to null.", "predict": " ResponseEntity<String> getTargetUrlParameter(@PathVariable(\"id\") String id) { return new ResponseEntity<String>(this.targetUrlParameter, HttpStatus.OK); } \n\nMethod: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResp ResponseEntity<String> getTargetUrlParameter(@PathVariable(\"id\") String id) { return new ResponseEntity<String>(this.targetUrlParameter, HttpStatus.OK); } \n\nMethod: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResp ResponseEntity<String> getTargetUrlParameter(@PathVariable(\""}, {"ID": 211, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Directory getDirectoryWithImmediateParentPopulated(final Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory); FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\"))); return directory; } }); } \nResponse:", "ground_truth": "Executes recursive SQL as needed to build a full Directory hierarchy of objects", "predict": "\n\n@RequestMapping(value = \"/api/v1/directories/{id}\", method = RequestMethod.GET)\n@ResponseBody\npublic Directory getDirectoryWithImmediateParentPopulated(@PathVariable(\"id\") Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory);"}, {"ID": 212, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DistinguishedName buildDn(String username) { DistinguishedName dn = new DistinguishedName(userDnBase); dn.add(usernameAttribute, username); return dn; } \nResponse:", "ground_truth": "Assembles the Distinguished Name that should be used the given username.", "predict": " Response is generated by the method buildDn(String username)\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons.lang3.tuple."}, {"ID": 213, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<Class<? extends Object>, Object> createSharedObjects() { Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>(); sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects()); sharedObjects.put(UserDetailsService.class, userDetailsService()); sharedObjects.put(ApplicationContext.class, context); sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy); sharedObjects.put(AuthenticationTrustResolver.class, trustResolver); return sharedObjects; } \nResponse:", "ground_truth": "Creates the shared objects\n\n@return the shared Objects", "predict": " ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest) { return authenticationService.authenticate(authenticationRequest); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error) { return authenticationService.authenticate(authenticationRequest, error); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error, @RequestParam(required = false) String logout) { return authenticationService.authenticate(authenticationRequest, error, logout); } \nResp ResponseEntity<Object> authentication(@RequestBody AuthenticationRequest authenticationRequest, @RequestParam(required = false) String error, @RequestParam(required = false) String logout, @RequestParam(required = false) String rememberMe) { return authenticationService.authenticate(authenticationRequest, error, logout, rememberMe); } \nResp ResponseEntity<Object"}, {"ID": 214, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void configureJaasUsingLoop() throws IOException { String loginConfigUrl = convertLoginConfigToUrl(); boolean alreadySet = false; int n = 1; final String prefix = \"login.config.url.\"; String existing; while ((existing = Security.getProperty(prefix + n)) != null) { alreadySet = existing.equals(loginConfigUrl); if (alreadySet) { break; } n++; } if (!alreadySet) { String key = prefix + n; log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl); Security.setProperty(key, loginConfigUrl); } } \nResponse:", "ground_truth": "Loops through the login.config.url.1,login.config.url.2 properties looking for the\nlogin configuration. If it is not set, it will be set to the last available\nlogin.config.url.X property.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.Properties;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.NameCallback;\nimport javax.security.auth.callback.PasswordCallback;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.login.Configuration;\nimport javax.security.auth.login.LoginContext;\nimport javax.security.auth.login.LoginException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class LoginServlet extends HttpServlet {\n\n"}, {"ID": 215, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getCurrentDate() { long now = System.currentTimeMillis(); if ((now - currentDateGenerated) > 1000) { synchronized (format) { if ((now - currentDateGenerated) > 1000) { currentDateGenerated = now; currentDate = format.format(new Date(now)); } } } return currentDate; } \nResponse:", "ground_truth": "Gets the current date in HTTP format.\n\n@return Current date in HTTP format", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.text.SimpleDateFormat;\n\npublic class DateTime {\n\tpublic static void main(String[] args) {\n\t\tDate now = new Date();\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tString currentDate = format.format(now);\n\t\tSystem.out.println(currentDate);\n\t}\n}\n"}, {"ID": 216, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Long internalParseDate(String value, DateFormat[] formats) { Date date = null; for (int i = 0; (date == null) && (i < formats.length); i++) { try { date = formats[i].parse(value); } catch (ParseException ignored) { } } if (date == null) { return null; } return new Long(date.getTime()); } \nResponse:", "ground_truth": "Parses date with given formatters.\n\n@param value The string to parse\n@param formats Array of formats to use\n\n@return Parsed date (or null if no formatter mached)", "predict": " Response is generated based on the above java code.\n*/\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DateParser {\n    public static Long internalParseDate(String value, DateFormat[] formats) {\n        Date date = null;\n        for (int i = 0; (date == null) && (i < formats.length); i++) {\n            try {\n                date = formats[i].parse(value);\n            } catch (ParseException ignored) {\n            }\n        }\n        if (date == null) {\n            return null;\n        }\n        return new Long(date.getTime());\n    }\n\n    public static Map<String, Object> parseDate(String value, DateFormat[] formats) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"date\", internalParseDate(value,"}, {"ID": 217, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static void updateCache(HashMap cache, Object key, Object value) { if (value == null) { return; } if (cache.size() > 1000) { cache.clear(); } cache.put(key, value); } \nResponse:", "ground_truth": "Updates cache.\n\n@param cache Cache to be updated\n@param key Key to be updated\n@param value New value", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test();\n    }\n\n    public void test() {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n        map.put(\"c\", 3);\n        map.put(\"d\", 4);\n        map.put(\"e\", 5);\n        map.put(\"f\", 6);\n        map.put(\"g\", 7);\n        map.put(\"h\", 8);\n        map.put(\"i\", 9);\n        map.put(\"j\", 10);\n        map.put(\"k\", 11);\n        map.put(\"l\", 12);\n"}, {"ID": 218, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } \nResponse:", "ground_truth": "Provided so that subclasses may configure what is put into the authentication\nrequest's details property.\n\n@param request that an authentication request is being created for\n@param authRequest the authentication request object that should have its details\nset", "predict": " ResponseEntity<UserDetails> userDetails(UsernamePasswordAuthenticationToken authRequest) { return userDetailsService.loadUserByUsername(authRequest.getName()); } \n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n@RestController\npublic class UserController {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @RequestMapping(value = \"/user\", method = RequestMethod.GET)\n    public UserDetails userDetails() {\n        Authentication authentication = Security"}, {"ID": 219, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSecurityName(final Subject subject) { if (logger.isDebugEnabled()) { logger.debug(\"Determining Websphere security name for subject \" + subject); } String userSecurityName = null; if (subject != null) { // SEC-803 Object credential = subject.getPublicCredentials(getWSCredentialClass()) .iterator().next(); if (credential != null) { userSecurityName = (String) invokeMethod(getSecurityNameMethod(), credential); } } if (logger.isDebugEnabled()) { logger.debug(\"Websphere security name is \" + userSecurityName + \" for subject \" + subject); } return userSecurityName; } \nResponse:", "ground_truth": "Get the security name for the given subject.\n\n@param subject The subject for which to retrieve the security name\n@return String the security name for the given subject", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.Callback;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.callback.NameCallback;\nimport javax.security.auth.callback.PasswordCallback;\nimport javax.security.auth.callback.UnsupportedCallbackException;\nimport javax.security.auth.login.LoginContext;\nimport javax.security.auth.login.LoginException;\nimport javax.security.auth.spi.LoginModule;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\npublic class WSSubjectLoginModule implements LoginModule {\n\n    private static final Log log = LogFactory.getLog(WSS"}, {"ID": 220, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception e) { logger.error(\"Exception occured while looking up groups for user\", e); throw new RuntimeException( \"Exception occured while looking up groups for user\", e); } finally { try { if (ic != null) { ic.close(); } } catch (NamingException e) { logger.debug(\"Exception occured while closing context\", e); } } } \nResponse:", "ground_truth": "Get the WebSphere group names for the given security name.\n\n@param securityName The security name for which to retrieve the WebSphere group\nnames\n@return the WebSphere group names for the given security name", "predict": "\n\n@SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception"}, {"ID": 221, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void changePassword(final String oldPassword, final String newPassword) { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); Assert.notNull( authentication, \"No authentication object found in security context. Can't change current user's password!\"); String username = authentication.getName(); logger.debug(\"Changing password for user '\" + username); DistinguishedName userDn = usernameMapper.buildDn(username); if (usePasswordModifyExtensionOperation) { changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword); } else { changePasswordUsingAttributeModification(userDn, oldPassword, newPassword); } } \nResponse:", "ground_truth": "Changes the password for the current user. The username is obtained from the\nsecurity context.\n\nThere are two supported strategies for modifying the user's password depending on\nthe capabilities of the corresponding LDAP server.\n\n\nConfigured one way, this method will modify the user's password via the\n\nLDAP Password Modify Extended Operation\n.\n\nSee {@link LdapUserDetailsManager#setUsePasswordModifyExtensionOperation(boolean)} for details.\n\n\nBy default, though, if the old password is supplied, the update will be made by rebinding as the user,\nthus modifying the password using the user's permissions. If\noldPassword is null, the update will be attempted using a standard\nread/write context supplied by the context source.\n\n\n@param oldPassword the old password\n@param newPassword the new value of the password.", "predict": "\n\n*/\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport com.google.common.base.Strings;\n\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\n@Service\npublic class PasswordChangeService implements UserDetailsService {\n\n\t@Autowired\n\tprivate PasswordChangeServiceImpl passwordChangeServiceImpl;\n\n\t@Override\n\tpublic UserDetails loadUserByUsername(String username) throws Username"}, {"ID": 222, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DistinguishedName buildGroupDn(String group) { DistinguishedName dn = new DistinguishedName(groupSearchBase); dn.add(groupRoleAttributeName, group.toLowerCase()); return dn; } \nResponse:", "ground_truth": "Creates a DN from a group name.\n\n@param group the name of the group\n@return the DN of the corresponding group, including the groupSearchBase", "predict": " Response.ok()\n\n*/\n\npackage com.ibm.ws.security.wim.scim20.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\n\n@JsonInclude(Include.NON_NULL)\npublic class Group {\n\n    private String id;\n    private String displayName;\n    private String name;\n    private String type;\n    private List<String> members = new ArrayList<String>();\n    private List<String> schemas = new ArrayList<String>();\n\n    public Group() {\n    }\n\n    public Group(String id, String displayName, String name, String type, List<String> members, List<String> schemas) {\n        this.id = id;"}, {"ID": 223, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\")); } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null; for (SessionInformation session : sessions) { if ((leastRecentlyUsed == null) || session.getLastRequest() .before(leastRecentlyUsed.getLastRequest())) { leastRecentlyUsed = session; } } leastRecentlyUsed.expireNow(); } \nResponse:", "ground_truth": "Allows subclasses to customise behaviour when too many sessions are detected.\n\n@param sessions either null or all unexpired sessions associated with\nthe principal\n@param allowableSessions the number of concurrent sessions the user is allowed to\nhave\n@param registry an instance of the SessionRegistry for subclass use", "predict": "\n\n*/\n\npublic class ConcurrentSessionControlAuthenticationStrategy extends AbstractSessionControlAuthenticationStrategy {\n\n    private static final Log log = LogFactory.getLog(ConcurrentSessionControlAuthenticationStrategy.class);\n\n    private int allowableSessions = -1;\n    private boolean exceptionIfMaximumExceeded = false;\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions) {\n        this.allowableSessions = allowableSessions;\n    }\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions, boolean exceptionIfMaximumExceeded) {\n        this.allowableSessions = allowableSessions;\n        this.exceptionIfMaximumExceeded = exceptionIfMaximumExceeded;\n    }\n\n    public ConcurrentSessionControlAuthenticationStrategy(int allowableSessions, boolean exceptionIfMaximumExceeded, String message) {\n        this.allowableSessions = allowableSessions;\n        this.exception"}, {"ID": 224, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void copyDetails(Authentication source, Authentication dest) { if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) { AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest; token.setDetails(source.getDetails()); } } \nResponse:", "ground_truth": "Copies the authentication details from a source Authentication object to a\ndestination one, provided the latter does not already have one set.\n\n@param source source authentication\n@param dest the destination authentication object", "predict": " ResponseEntity<Authentication> authenticationDetails(Authentication authentication) { return new ResponseEntity<Authentication>(authentication, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status) { return new ResponseEntity<Authentication>(authentication, status); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers) { return new ResponseEntity<Authentication>(authentication, status, headers, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers, HttpHeaders responseHeaders) { return new ResponseEntity<Authentication>(authentication, status, responseHeaders, HttpStatus.OK); } \nResp ResponseEntity<Authentication> authenticationDetails(Authentication authentication, HttpStatus status, Map<String, ?> headers, H"}, {"ID": 225, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Filter> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; } \nResponse:", "ground_truth": "Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain", "predict": " ResponseEntity<List<Filter>> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.fasterxml.jackson.annotation.JsonView;"}, {"ID": 226, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Filter> getFilters(String url) { return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest()))); } \nResponse:", "ground_truth": "Convenience method, mainly for testing.\n\n@param url the URL\n@return matching filter list", "predict": " public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation.getRequest()); } \nResp public List<Filter> getFilters(Request request) { return getFilters(request.getRequestURI()); } \nResp public List<Filter> getFilters(String url) { return getFilters(new FilterInvocation(url, \"GET\") .getRequest()); } \nResp public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation.getRequest()); } \nResp public List<Filter> getFilters(Request request) { return getFilters(request.getRequestURI()); } \nResp public List<Filter> getFilters(String url) { return getFilters(new FilterInvocation(url, \"GET\") .getRequest()); } \nResp public List<Filter> getFilters(FilterInvocation invocation) { return getFilters(invocation"}, {"ID": 227, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ApplicationContext getContext(PageContext pageContext) { ServletContext servletContext = pageContext.getServletContext(); return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext); } \nResponse:", "ground_truth": "Allows test cases to override where application context obtained from.\n\n@param pageContext so the ServletContext can be accessed as required\nby Spring's WebApplicationContextUtils\n\n@return the Spring application context (never null)", "predict": " Response getContext(PageContext pageContext) { return SecurityWebApplicationContextUtils.getContext(pageContext).getResponse(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport"}, {"ID": 228, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException { DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace()); if (dn.contains(baseDn)) { return dn; } baseDn.append(dn); return baseDn; } \nResponse:", "ground_truth": "Gets the full dn of a name by prepending the name of the context it is relative to.\nIf the name already contains the base name, it is returned unaltered.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.ModificationItem;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.apache.log4j.Logger;\n\npublic class LdapUtils {\n\tprivate static final Logger LOGGER = Logger.getLogger(LdapUtils.class);\n\n\tpublic static DistinguishedName getFullDn(DistinguishedName dn,\n\t\t\tDirContext baseCtx) throws NamingException {\n\t\tDistinguishedName baseDn = new DistinguishedName(baseCtx"}, {"ID": 229, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) { notNull(sessionAttributes, \"sessionAttributes\"); parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes); return this; } \nResponse:", "ground_truth": "Set session attributes.\n\n@param sessionAttributes the session attributes", "predict": " ResponseEntity<Object> response(HttpStatus status) { return response(status, null); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body) { notNull(status, \"status\"); notNull(body, \"body\"); return new ResponseEntity<Object>(body, new HttpHeaders(), status); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body, HttpHeaders headers) { notNull(status, \"status\"); notNull(body, \"body\"); notNull(headers, \"headers\"); return new ResponseEntity<Object>(body, headers, status); } \nResp ResponseEntity<Object> response(HttpStatus status, Object body, HttpHeaders headers, HttpStatus status2) { notNull(status, \"status\"); notNull(body, \"body\"); notNull(headers, \"headers\"); notNull(status2, \"status2\"); return new ResponseEntity<Object>(body, headers, status2); }"}, {"ID": 230, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AuthenticationScheme basic(String userName, String password) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme(); preemptiveBasicAuthScheme.setUserName(userName); preemptiveBasicAuthScheme.setPassword(password); return preemptiveBasicAuthScheme; } \nResponse:", "ground_truth": "", "predict": "\n\npublic class AuthenticationScheme {\n    private String userName;\n    private String password;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AuthenticationScheme {\n    private String userName;\n    private String password;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password"}, {"ID": 231, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(List<Filter> filters) { Validate.notNull(filters, \"Filter list cannot be null\"); RestAssured.filters.addAll(filters); } \nResponse:", "ground_truth": "Add default filters that will be applied to each request.\n\n@param filters The filter list", "predict": " Response with the following java Code. Code: public static Response filters(List<Filter> filters) { return RestAssured.filters(filters); } \n\n*/\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport com.jayway.restassured.RestAssured;\nimport com.jayway.restassured.filter.Filter;\nimport com.jayway.restassured.filter.FilterContext;\nimport com.jayway.restassured.filter.log.RequestLoggingFilter;\nimport com.jayway.restassured.response.Response;\nimport com.jayway.restassured.specification.FilterableRequestSpecification;\nimport com.jayway.restassured.specification.FilterableResponseSpecification;\n\npublic class FilterTest {\n\n"}, {"ID": 232, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(Filter filter, Filter... additionalFilters) { Validate.notNull(filter, \"Filter cannot be null\"); RestAssured.filters.add(filter); if (additionalFilters != null) { Collections.addAll(RestAssured.filters, additionalFilters); } } \nResponse:", "ground_truth": "Add default filters to apply to each request.\n\n@param filter            The filter to add\n@param additionalFilters An optional array of additional filters to add", "predict": " Response response = RestAssured.given().filter(filter).filter(additionalFilters).when().get(\"/filters\"); \n\n*/\npackage com.jayway.restassured.filter.log;\n\nimport com.jayway.restassured.filter.Filter;\nimport com.jayway.restassured.internal.filter.FilterChainImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextBuilder;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplBuilder;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplBuilderImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl.FilterContextImplImpl;\nimport com.jayway.restassured.internal.filter.FilterContextImpl."}, {"ID": 233, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme basic(String userName, String password) { final BasicAuthScheme scheme = new BasicAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); return scheme; } \nResponse:", "ground_truth": "", "predict": " Response { return Response.ok().header(\"WWW-Authenticate\", \"Basic\").build(); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class BasicAuthScheme implements AuthenticationScheme {\n\n\tprivate static final long serialVersionUID = -8285555555555555555L;\n\n\tprivate String userName;\n\tprivate String password;\n\n\tpublic BasicAuthScheme() {\n\t}\n\n\tpublic BasicAuthScheme(String userName, String password) {\n\t\tthis.userName = userName;\n\t\tthis.password"}, {"ID": 234, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) { final NTLMAuthScheme scheme = new NTLMAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setWorkstation(workstation); scheme.setDomain(domain); return scheme; } \nResponse:", "ground_truth": "Create a NTLM authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@param workstation The NTLM workstation.\n@param domain The NTLM workstation.\n@return The authentication scheme", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Objects;\n\npublic class NTLMAuthScheme extends AuthenticationScheme {\n\n\tprivate static final long serialVersionUID = -8285555555555555555L;\n\n\tprivate String userName;\n\tprivate String password;\n\tprivate String workstation;\n\tprivate String domain;\n\n\tpublic NTLMAuthScheme() {\n\t\tsuper();\n\t}\n\n\tpublic NTLMAuthScheme(String userName, String password, String workstation, String domain) {\n\t\tsuper();\n\t\t"}, {"ID": 235, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; } \nResponse:", "ground_truth": "Use form authentication with the supplied configuration.\n\n@param userName The user name.\n@param password The password.\n@param config   The form authentication config\n@return The authentication scheme", "predict": " public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; } \n\n*/\n\npublic class FormAuthScheme extends AuthenticationScheme {\n\t\n\tprivate String userName;\n\tprivate String password;\n\tprivate FormAuthConfig config;\n\t\n\tpublic FormAuthScheme() {\n\t\tsuper();\n\t}\n\t\n\tpublic FormAuthScheme(String userName, String password, FormAuthConfig config) {\n\t\tsuper();\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.config = config;\n\t}"}, {"ID": 236, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void proxy(URI uri) { if (uri == null) { throw new IllegalArgumentException(\"Proxy URI cannot be null\"); } proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme())); } \nResponse:", "ground_truth": "Instruct REST Assured to connect to a proxy using a URI.\n\n@param uri The URI of the proxy", "predict": " Response.ok().build();\n\n*/\n\npackage com.google.code.magja.model.product;\n\nimport java.util.Date;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport com.google.code.magja.model.BaseMagentoModel;\n\n/**\n * @author andre\n *\n */\n@XmlRootElement\npublic class ProductAttribute extends BaseMagentoModel {\n\n  private static final long serialVersionUID = -8285555555555555555L;\n\n  private String name;\n  private String value;\n  private String type;\n  private String scope;\n  private String scopeDefault;\n  private String scopeDefaultValue;\n  private String scopeDefaultText;\n  private String scopeDefaultTextValue;\n  private String scopeDefaultTextValue2;\n  private String scopeDefaultTextValue2Value;\n  private String scopeDefaultTextValue2Value2;\n  "}, {"ID": 237, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if (shouldPrettyPrint) { responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody); } else { responseBodyToAppend = responseBody.asString(); } if (logDetail == ALL && !isBlank(responseBodyToAppend)) { builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR); } builder.append(responseBodyToAppend); } String response = builder.toString(); stream.println(response); return response; } \nResponse:", "ground_truth": "Prints the response to the print stream\n\n@return A string of representing the response", "predict": " Generate the method-level comment for the following java Code. Code: public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if ("}, {"ID": 238, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredConfig redirect(RedirectConfig redirectConfig) { notNull(redirectConfig, \"Redirect config\"); return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); } \nResponse:", "ground_truth": "Set the redirect config.\n\n@param redirectConfig The {@link RedirectConfig} to set\n@return An updated RestAssuredConfiguration", "predict": " public Response response(ResponseConfig responseConfig) { notNull(responseConfig, \"Response config\"); return new Response(responseConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); } \nResp public Response response(ResponseConfig responseConfig, ResponseOptions responseOptions) { notNull(responseConfig, \"Response config\"); notNull(responseOptions, \"Response options\"); return new Response(responseConfig, responseOptions.config(HttpClientConfig.class), responseOptions.config(LogConfig.class"}, {"ID": 239, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EncoderConfig defaultQueryParameterCharset(String charset) { return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true); } \nResponse:", "ground_truth": "Specify the default charset for query parameters\n\n@param charset The charset to use.\n@return A new instance of {@link EncoderConfig}", "predict": " Response<ResponseBody> response(ResponseBody responseBody) throws IOException { return responseBody.response(); }\n\n*/\n\n// @formatter:on\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ResponseBody {\n    /**\n     * The HTTP status code to return.\n     */\n    int value() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is empty.\n     */\n    int emptyValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is null.\n     */\n    int nullValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is empty and the emptyValue is not -1.\n     */\n    int emptyEmptyValue() default -1;\n\n    /**\n     * The HTTP status code to return if the response body is null and the nullValue"}, {"ID": 240, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Creates an object mapper configuration that uses the specified object mapper as default.\n\n@param defaultObjectMapperType The object mapper to use. If null then classpath scanning will be used.", "predict": " Resp public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\nimport org."}, {"ID": 241, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Specify a custom JAXB object mapper factory.\n\n@param jaxbObjectMapperFactory The object mapper factory", "predict": " Response(Status status, String message, Object entity)\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double to Double.\n */\npublic class DoubleToDoubleOperator extends GenericStackableOperatorTerm<Double>\n  implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   * @param applicant applicant\n   */\n  public DoubleToDoubleOperator(Term<Double> base, Term<Double> applicant) {\n    super(base, applicant);\n  }"}, {"ID": 242, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) { notNull(logConfig, \"Log config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Log config.\n\n@param logConfig The {@link LogConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"Response body\"); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"Response body\"); notNull(responseOptions, \"Response options\"); return new Response(responseBody.getStatus(), responseBody.getHeaders"}, {"ID": 243, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) { notNull(sessionConfig, \"Session config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the session config.\n\n@param sessionConfig The {@link SessionConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 244, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) { notNull(objectMapperConfig, \"Object mapper config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the object mapper config.\n\n@param objectMapperConfig The {@link ObjectMapperConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResp public Response response(ResponseBuilder responseBuilder) { notNull(responseBuilder, \"Response builder\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseBuilder); } \nResp public Response response(Response response, ResponseBuilder responseBuilder) { notNull(response, \"Response\"); notNull(responseBuilder, \"Response builder\"); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig,"}, {"ID": 245, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) { notNull(jsonConfig, \"JsonConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Json config.\n\n@param jsonConfig The {@link JsonConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 246, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) { notNull(xmlConfig, \"XmlConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Xml config.\n\n@param xmlConfig The {@link XmlConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); return new Response(responseBody, responseOptions); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions, ResponseType responseType) { notNull(responseBody, \"ResponseBody\"); notNull(responseOptions, \"ResponseOptions\"); notNull(responseType, \"ResponseType\"); return new Response(responseBody, response"}, {"ID": 247, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) { notNull(encoderConfig, \"EncoderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the encoder config\n\n@param encoderConfig The {@link EncoderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequest(), response.getErrorMessage(), response.getRawStatusCode(), response.getRawResponseHeaders(), response.getRawResponseBody()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); return new Response(responseBody, responseStatus); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus, ResponseHeaders responseHeaders) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); notNull(responseHeaders"}, {"ID": 248, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) { notNull(headerConfig, \"HeaderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the header config\n\n@param headerConfig The {@link HeaderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, \"Response\"); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequest(), response.getErrorMessage(), response.getRawStatusCode(), response.getRawResponseHeaders(), response.getRawResponseBody()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, \"ResponseBody\"); return new Response(responseBody); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); return new Response(responseBody, responseStatus); } \nResp public Response response(ResponseBody responseBody, ResponseStatus responseStatus, ResponseHeaders responseHeaders) { notNull(responseBody, \"ResponseBody\"); notNull(responseStatus, \"ResponseStatus\"); notNull(responseHeaders"}, {"ID": 249, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) { notNull(asyncConfig, AsyncConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the async config\n\n@param asyncConfig The {@link AsyncConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getHeaders().getContentType(), response.getHeaders().getContentLength(), response.getHeaders().getContentEncoding(), response.getHeaders().getETag(), response.getHeaders().getLastModified(), response.getHeaders().getLocation(), response.getHeaders().getDate(), response.getHeaders().getServer(), response.getHeaders().getVary(), response.getHeaders().getWWWAuthenticate(), response.getHeaders().getExpires(), response.getHeaders().getAcceptRanges(), response.getHeaders().getContentRange(), response.getHeaders().getContentMD5(), response.getHeaders().getContentType(), response.getHeaders().getContentLength(), response.getHeaders().getContentEnc"}, {"ID": 250, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) { notNull(mockMvcConfig, MockMvcConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the MockMVC config\n\n@param mockMvcConfig The {@link MockMvcConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResponseSpecification: public ResponseSpecification responseSpecification(ResponseSpecification responseSpecification) { notNull(responseSpecification, ResponseSpecification.class); return new ResponseSpecification(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseSpecification); } \nRestAssuredMockMvcConfig: public RestAssuredMockMvcConfig(LogConfig logConfig, EncoderConfig encoderConfig, DecoderConfig decoderConfig, SessionConfig sessionConfig, ObjectMapperConfig objectMapperConfig"}, {"ID": 251, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) { notNull(multiPartConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the multi-part config\n\n@param multiPartConfig The {@link MultiPartConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, response); } \nResponseSpecification: public ResponseSpecification responseSpecification(ResponseSpecification responseSpecification) { notNull(responseSpecification, ResponseSpecification.class); return new ResponseSpecification(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig, responseSpecification); } \nRestAssuredMockMvcConfig: public RestAssuredMockMvcConfig(LogConfig logConfig, EncoderConfig encoderConfig, DecoderConfig decoderConfig, SessionConfig sessionConfig, ObjectMapperConfig objectMapperConfig"}, {"ID": 252, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) { notNull(paramConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the parameter config\n\n@param paramConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusMessage(), response.getHeaders()); } \nResp public Response response(ResponseBody responseBody) { notNull(responseBody, ResponseBody.class); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseBody.getHeaders()); } \nResp public Response response(ResponseBody responseBody, ResponseOptions responseOptions) { notNull(responseBody, ResponseBody.class); notNull(responseOptions, ResponseOptions.class); return new Response(responseBody.getStatus(), responseBody.getHeaders(), responseBody.getBody(), responseBody.getCookies(), responseBody.getStatusMessage(), responseOptions.getHeaders()); } \nResp"}, {"ID": 253, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) { notNull(matcherConfig, MatcherConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the matcher config\n\n@param matcherConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " public Response response(Response response) { notNull(response, Response.class); return new Response(response.getStatus(), response.getHeaders(), response.getBody(), response.getCookies(), response.getStatusLine(), response.getRequestMethod(), response.getRequestUrl(), response.getRequestHeaders(), response.getRequestContent(), response.getRequestContentType(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response.getRequestCookies(), response.getRequestHeaders(), response."}, {"ID": 254, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CertificateAuthSettings allowAllHostnames() { return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory); } \nResponse:", "ground_truth": "", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.Properties;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class CertificateAuthSettings {\n\t\n\tprivate static final String KEYSTORE_TYPE = \"J"}, {"ID": 255, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Specify declared namespaces that will be used when parsing XML.\n\n@param namespacesToDeclare A map containing features that will be used by the underlying {@link groovy.util.XmlSlurper}.\n@return A new instance of XmlPathConfig\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Response is generated by the following java Code. Code: public Response declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); } \n\n*/\n\npackage com.github.fge.grappa.matchers;\n\nimport com.github.fge.grappa.matchers.base.Matcher;\nimport com.github.fge.grappa.matchers.base.MatcherType;\nimport com.github.fge.grappa.parsers.BaseParser;\nimport com.github.fge.grappa.rules.Rule;\nimport com.github.fge.grappa.run.MatcherContext;\nimport com.github.fge.grappa.run.ParseRunner;\nimport"}, {"ID": 256, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) { Validate.notEmpty(prefix, \"Prefix cannot be empty\"); Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\"); Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces); updatedNamespaces.put(prefix, namespaceURI); return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Declares a namespace.\n\n@param prefix       The feature name, which is a fully-qualified URI.\n@param namespaceURI The requested value of the feature (true or false).\n@return A new XmlPathConfig instance\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": "\n\n*/\n\npackage com.github.fge.grappa.transform;\n\nimport com.github.fge.grappa.rules.Rule;\nimport com.github.fge.grappa.run.context.MatcherContext;\nimport com.github.fge.grappa.run.events.MatchFailureEvent;\nimport com.github.fge.grappa.run.events.MatchSuccessEvent;\nimport com.github.fge.grappa.run.events.RuleFailureEvent;\nimport com.github.fge.grappa.run.events.RuleSuccessEvent;\nimport com.github.fge.grappa.run.events.TestFailureEvent;\nimport com.github.fge.grappa.run.events.TestSuccessEvent;\nimport com.github.fge.grappa.run.events.TestSkippedEvent;\nimport com.github.fge.grappa.run.events.TestSkippedEvent"}, {"ID": 257, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); } \nResponse:", "ground_truth": "Make an HTTP request to the default URI, and parse using the default\ncontent-type.\n\n@param method        {@link HttpRequestFactory HTTP method}\n@param configClosure request configuration options\n@return whatever value was returned by the executed response handler.\n@throws ClientProtocolException\n@throws IOException\n@see #request(Object, HttpRequestFactory, Object, Closure)", "predict": " Response<Object> request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(uri, method, contentType, hasBody, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Map<String, Object> params, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(uri, method, contentType, hasBody, params, configClosure); } \nResp Response<Object> request(URI uri, String method, String contentType, boolean hasBody, Map<String, Object> params"}, {"ID": 258, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setHeaders(Map<?, ?> headers) { this.defaultRequestHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultRequestHeaders.put(key.toString(), val.toString()); } } \nResponse:", "ground_truth": "Set the default headers to add to all requests made by this builder\ninstance.  These values will replace any previously set default headers.\n\n@param headers map of header names & values.", "predict": " public void setHeaders(Map<?, ?> headers) { this.defaultResponseHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultResponseHeaders.put(key.toString(), val.toString()); } } \n\n*/\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport"}, {"ID": 259, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); } \nResponse:", "ground_truth": "null for the default\n@see HttpHost#HttpHost(String, int, String)", "predict": " public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); } \n\n*/\n\npublic class ProxyTest {\n    public static void main(String[] args) {\n        try {\n            // Create a new instance of HttpClient.\n            HttpClient httpclient = new HttpClient();\n\n            // Create a method instance.\n            HttpGet httpget = new HttpGet(\"http://www.google.com/\");\n\n            // Add the Proxy to the execution context.\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, new HttpHost(\"myproxy.com\", 8080));\n\n            // Execute the method.\n            HttpResponse response = httpclient.execute(httpget);\n\n            // Examine the response status.\n            System.out.println(\"Response status"}, {"ID": 260, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder controlName(String controlName) { Validate.notEmpty(controlName, \"Control name cannot be empty\"); this.controlName = controlName; this.isControlNameExplicit = true; return this; } \nResponse:", "ground_truth": "Specify the control name of this multi-part.\n\n@param controlName The control name to use. Default is file.\n@return An instance of MultiPartSpecBuilder", "predict": " Response { return new Response(this); } \n\n*/\n\npublic class MultiPartSpecBuilder {\n\tprivate String controlName;\n\tprivate boolean isControlNameExplicit;\n\t\n\tpublic MultiPartSpecBuilder controlName(String controlName) {\n\t\tthis.controlName = controlName;\n\t\tthis.isControlNameExplicit = true;\n\t\treturn this;\n\t}\n\t\n\tpublic MultiPartSpecBuilder isControlNameExplicit(boolean isControlNameExplicit) {\n\t\tthis.isControlNameExplicit = isControlNameExplicit;\n\t\treturn this;\n\t}\n\t\n\tpublic MultiPartSpec build() {\n\t\treturn new MultiPartSpec(this);\n\t}\n}\n"}, {"ID": 261, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder header(String name, String value) { Validate.notEmpty(name, \"Header name cannot be empty\"); Validate.notEmpty(value, \"Header value cannot be empty\"); // Replace previous header if exists final Set<String> headerNames = headers.keySet(); final String trimmedName = name.trim(); for (String headerName : headerNames) { if (headerName.equalsIgnoreCase(trimmedName)) { headers.remove(headerName); } } // Put the name header in the header list headers.put(name, value); return this; } \nResponse:", "ground_truth": "Add a header to this multipart specification.\n\n@param name The name of the header\n@param value The value of the header\n@return An instance of MultiPartSpecBuilder", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MultiPartSpecBuilder {\n    private Map<String, String> headers = new HashMap<>();\n\n    public MultiPartSpecBuilder header(String name, String value) {\n        headers.put(name, value);\n        return this;\n    }\n\n    public MultiPartSpecBuilder contentType(String contentType) {\n        headers.put(\"Content-Type\", contentType);\n        return this;\n    }\n\n    public MultiPartSpecBuilder file(String fileName, byte[] fileData) {\n        headers.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n        headers.put(\"Content-Type\", \"application/octet-stream\");\n        headers.put(\"Content-Length\", \"\" + fileData.length);\n        return this;\n    }\n\n    public MultiPartSpecBuilder file(String fileName"}, {"ID": 262, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void basic(String host, int port, String user, String pass) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new UsernamePasswordCredentials(user, pass) ); } \nResponse:", "ground_truth": "Set authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass", "predict": "\n\npublic void basic(String host, int port, String user, String pass) {\n        try {\n            builder.getClient().getCredentialsProvider().setCredentials(new AuthScope(host, port), new UsernamePasswordCredentials(user, pass));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org."}, {"ID": 263, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void ntlm(String host, int port, String user, String pass, String workstation, String domain) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain) ); } \nResponse:", "ground_truth": "Set NTLM authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass\n@param workstation\n@param domain", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class NTLM {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://www.google.com\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Authorization\", \"NTLM TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACgAOAAACAAAABQAADQAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}, {"ID": 264, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Headers headers(Header header, Header... additionalHeaders) { notNull(header, \"Header\"); final List<Header> headerList = new LinkedList<Header>(); headerList.add(header); if (additionalHeaders != null) { Collections.addAll(headerList, additionalHeaders); } return new Headers(headerList); } \nResponse:", "ground_truth": "An alternative way to create a Headers object from the constructor.\n\n@param header            The header to be included\n@param additionalHeaders Additional headers to be included (optional)\n@return A new headers object containing the specified headers", "predict": " public static ResponseBuilder response(Response response) { notNull(response, \"Response\"); return new ResponseBuilder(response); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status) { notNull(status, \"Status\"); return new ResponseBuilder(status); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message) { notNull(status, \"Status\"); notNull(message, \"Message\"); return new ResponseBuilder(status, message); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message, Object... args) { notNull(status, \"Status\"); notNull(message, \"Message\"); notNull(args, \"Arguments\"); return new ResponseBuilder(status, message, args); } \nResponseBuilder: public static ResponseBuilder response(Response.Status status, String message, Throwable cause) { notNull(status, \"Status\"); notNull(message, \"Message\"); notNull(cause, \"Cause\"); return new"}, {"ID": 265, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; } \nResponse:", "ground_truth": "Reset all static configurations to their default values.", "predict": "\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\t\n\tpublic static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null"}, {"ID": 266, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; } \nResponse:", "ground_truth": "Set a specific header\n\n@return The builder", "predict": " ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; } \nResp ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name)."}, {"ID": 267, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; } \nResponse:", "ground_truth": "Build the actual response\n\n@return The response object", "predict": " public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; } \n\n}\n"}, {"ID": 268, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher))); } \nResponse:", "ground_truth": "Verifies whether value of cookie satisfies specified matcher.\n@param valueMatcher value assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed value property assertion", "predict": " public DetailedCookieMatcher value(String value) { return value(equalTo(value)); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"value\", equalTo(\"value\")).matches(new Cookie(\"name\", \"value\")),\n                MatcherAssert.isTrue());\n    }\n}\n"}, {"ID": 269, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); } \nResponse:", "ground_truth": "Verifies whether comment of cookie satisfies specified matcher.\n@param commentMatcher comment assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed comment property assertion", "predict": " public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); } \n\n*/\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.regex.PatternSyntaxException;\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n    private Matcher<String> commentMatcher;\n\n    public DetailedCookieMatcher(Matcher<String> commentMatcher) {\n        super(\"\");\n        this.commentMatcher = commentMatcher;\n    }\n\n    public DetailedCookieMatcher(String comment) {\n        super(\"\");\n        try {\n            this.commentMatcher = Pattern.compile(comment).matcher(\"\");\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException"}, {"ID": 270, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); } \nResponse:", "ground_truth": "Verifies whether expiry date of cookie satisfies specified matcher.\n@param expiryDateMatcher expiry date assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed expiry date property assertion", "predict": " public DetailedCookieMatcher expiryDate(DateMatcher expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\nimport java.util.Date;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(Matchers.hasProperty(\"expiryDate\", Matchers.equalTo(new Date(System.currentTimeMillis() + 10000000L))))\n                .matches(new Cookie(\"name\", \"value\", \"domain\", \"path\", new Date(System.currentTimeMillis() + 10000000L))), Matchers.is(true));"}, {"ID": 271, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher))); } \nResponse:", "ground_truth": "Verifies whether domain of cookie satisfies specified matcher.\n@param domainMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed domain property assertion", "predict": " public DetailedCookieMatcher domain(String domain) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", equalTo(domain)))); } \n\n*/\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.regex.PatternSyntaxException;\n\npublic class DetailedCookieMatcher {\n    private Matcher<String> domainMatcher;\n    private Matcher<String> pathMatcher;\n    private Matcher<String> nameMatcher;\n    private Matcher<String> valueMatcher;\n    private Matcher<String> commentMatcher;\n    private Matcher<String> commentUrlMatcher;\n    private Matcher<String> commentDomainMatcher;\n    private Matcher<String> commentPathMatcher;\n    private Matcher<String> commentNameMatcher;\n    private Matcher<String> commentValueMatcher"}, {"ID": 272, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); } \nResponse:", "ground_truth": "Verifies whether path of cookie satisfies specified matcher.\n@param pathMatcher assertion for path property\n@return A {@link DetailedCookieMatcher} instance with and-composed path property assertion", "predict": " public DetailedCookieMatcher path(String path) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", equalTo(path)))); } \n\n*/\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n\n    public DetailedCookieMatcher(Matcher<? super Cookie> matcher) {\n        super(matcher);\n    }\n\n    @Override\n    protected String getName() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getDescription() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getJavadoc() {\n        return \"Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); } \";\n    }\n}"}, {"ID": 273, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); } \nResponse:", "ground_truth": "Verifies whether secured property of cookie satisfies specified matcher.\n@param securedMatcher assertion for secured property\n@return A {@link DetailedCookieMatcher} instance with and-composed secured property assertion", "predict": " Response with the following java Code. Code: public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.hamcrest.Matcher;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class DetailedCookieMatcher {\n\t\n\tprivate final Matcher<Cookie> matcher;\n\t\n\tpublic DetailedCookieMatcher(Matcher<Cookie"}, {"ID": 274, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); } \nResponse:", "ground_truth": "", "predict": " public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); } \n\nThe method-level comment will be used for the following java Code. Code: public DetailedCookieMatcher httpOnly(boolean httpOnly) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", equalTo(httpOnly)))); } \nResp public DetailedCookieMatcher httpOnly(boolean httpOnly) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", equalTo(httpOnly)))); } \n\nThe method-level comment will be used for the following java Code. Code: public DetailedCookieMatcher httpOnly(boolean httpOnly, boolean ignoreCase) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\""}, {"ID": 275, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); } \nResponse:", "ground_truth": "Verifies whether version of cookie satisfies specified matcher.\n@param versionMatcher assertion for version property\n@return A {@link DetailedCookieMatcher} instance with and-composed version property assertion", "predict": " public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); } \n\n*/\n\npublic class DetailedCookieMatcher extends CookieMatcher {\n\n    public DetailedCookieMatcher(Matcher<? super Cookie> cookieMatcher) {\n        super(cookieMatcher);\n    }\n\n    @Override\n    protected String getName() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getDescription() {\n        return \"cookie\";\n    }\n\n    @Override\n    protected String getJavadoc() {\n        return \"Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher)));"}, {"ID": 276, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); } \nResponse:", "ground_truth": "Verifies whether max age of cookie satisfies specified matcher.\n@param maxAgeMatcher assertion for max age property\n@return A {@link DetailedCookieMatcher} instance with and-composed max age property assertion", "predict": " public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); } \n\n*/\n\nimport org.hamcrest.Matcher;\nimport org.hamcrest.MatcherAssert;\nimport org.junit.Test;\n\npublic class DetailedCookieMatcherTest {\n\n    @Test\n    public void testHasProperty() {\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"maxAge\", Matchers.hasProperty(\"maxAge\", Matchers.equalTo(10))).matches(new Cookie(\"maxAge\", \"10\")), Matchers.is(true));\n        MatcherAssert.assertThat(new DetailedCookieMatcher(\"maxAge\", Matchers.hasProperty(\"maxAge\", Matchers.equalTo(10))).matches(new Cookie(\""}, {"ID": 277, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) { spec.header(headerName, expectedValueMatcher); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied header name and hamcrest matcher.\n\n@param headerName           The name of the expected header\n@param expectedValueMatcher The Hamcrest matcher that must conform to the value\n@return The builder", "predict": " ResponseSpecBuilder expectStatusCode(int statusCode) { spec.expectStatusCode(statusCode); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase) { spec.expectStatusCode(statusCode, reasonPhrase); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String content) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String content, String charset) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, content, charset); return this"}, {"ID": 278, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) { spec.header(headerName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied name and value.\n\n@param headerName    The name of the expected header\n@param expectedValue The value of the expected header\n@return The builder", "predict": " ResponseSpecBuilder expectStatusCode(int statusCode) { spec.expectStatusCode(statusCode); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase) { spec.expectStatusCode(statusCode, reasonPhrase); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, String contentType, String charset) { spec.expectStatusCode(statusCode, reasonPhrase, contentType, charset); return this; } \nResp ResponseSpecBuilder expectStatusCode(int statusCode, String reasonPhrase, byte[] content) { spec.expectStatusCode(statusCode, reasonPhrase, content); return this; } \nResp ResponseSpecBuilder expectStatus"}, {"ID": 279, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) { spec.cookie(cookieName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response cookie matches the supplied name and value.\n\n@param cookieName    The name of the expected cookie\n@param expectedValue The value of the expected cookie\n@return The builder", "predict": "\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain) {\n        spec.cookie(cookieName, expectedValue, domain);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path) {\n        spec.cookie(cookieName, expectedValue, domain, path);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path, boolean secure) {\n        spec.cookie(cookieName, expectedValue, domain, path, secure);\n        return this;\n    }\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue, String domain, String path, boolean secure, boolean httpOnly"}, {"ID": 280, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProxySpecification withHost(String host) { return new ProxySpecification(host, port, scheme, username, password); } \nResponse:", "ground_truth": "Specify the hostname of the proxy.\n\n@param host The hostname of the proxy.\n@return A new ProxySpecification instance", "predict": " Response withHost(String host) { return new Response(host, port, scheme, username, password); }\n\n*/\n\npublic class ProxySpecification {\n\tprivate String host;\n\tprivate int port;\n\tprivate String scheme;\n\tprivate String username;\n\tprivate String password;\n\t\n\tpublic ProxySpecification(String host, int port, String scheme, String username, String password) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.scheme = scheme;\n\t\tthis.username = username;\n\t\tthis.password = password;\n\t}\n\t\n\tpublic ProxySpecification(String host, int port, String scheme) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.scheme = scheme;\n\t}\n\t\n\tpublic ProxySpecification(String host, int port) {\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t}\n"}, {"ID": 281, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.\n\n@param numberReturnType The choice.\n@return A new instance of JsonPathConfig with the given configuration", "predict": "\n\n*/\n\npackage com.github.fge.jsonschema.main;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.JSONPObject;\nimport com.fasterxml.jackson.databind.util.JSONWrappedObject;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.StdTimeFormat;\nimport com.fasterxml.jackson.databind.util.StdTimestampFormat;\nimport com.github.fge.jsonschema.core.exceptions.ProcessingException;\nimport com.github."}, {"ID": 282, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig defaultParserType(JsonParserType defaultParserType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Creates an json path configuration that uses the specified parser type as default.\n\n@param defaultParserType The parser type to use. If null then classpath scanning will be used.", "predict": " Response(JsonPathConfig config) { return new Response(config); }\n\n*/\n\npackage com.github.fge.jsonschema.main;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectWriter;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.util.JSONPObject;\nimport com.fasterxml.jackson.databind.util.JSONWrappedObject;\nimport com.fasterxml.jackson.databind.util.StdDateFormat;\nimport com.fasterxml.jackson.databind.util.StdDateFormat.DateFormat;\nimport com.github.fge.jsonschema.core.exceptions.ProcessingException;\nimport com.github.fge.js"}, {"ID": 283, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig defaultStream(PrintStream printStream) { return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Specify a new default stream to the print to.\n\n@param printStream The stream\n@return A new LogConfig instance", "predict": " Response is generated by the method.\n */\npublic class LogConfig {\n    private PrintStream printStream;\n    private boolean logDetailIfValidationFails;\n    private String urlEncodeRequestUri;\n    private boolean isRequestUriEncoded;\n\n    public LogConfig(PrintStream printStream, boolean logDetailIfValidationFails, String urlEncodeRequestUri, boolean isRequestUriEncoded) {\n        this.printStream = printStream;\n        this.logDetailIfValidationFails = logDetailIfValidationFails;\n        this.urlEncodeRequestUri = urlEncodeRequestUri;\n        this.isRequestUriEncoded = isRequestUriEncoded;\n    }\n\n    public PrintStream getPrintStream() {\n        return printStream;\n    }\n\n    public boolean isLogDetailIfValidationFails() {\n        return logDetailIfValidationFails;\n    }"}, {"ID": 284, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail\n\n@param logDetail The log detail to show in the log\n@return A new LogConfig instance", "predict": " public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); } \n\n*/\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogConfig {\n    private static final Logger LOGGER = Logger.getLogger(LogConfig.class.getName());\n    private static final String LOG_CONFIG_PREFIX = \"LogConfig\";\n    private static final String LOG_CONFIG_SUFFIX = \"LogConfig\";\n    private static final String LOG_CONFIG_PREFIX_PRETTY_PRINTING = \"LogConfig (pretty printing)\";\n    private static final String LOG_CONFIG_SUFFIX_PRETTY_PRINTING = \"LogConfig (pretty printing)\";\n    private static"}, {"ID": 285, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) { String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\"); Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method); final HttpRequestBase httpRequest; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) { httpRequest = new CustomHttpMethod(method, uri); } else { try { httpRequest = type.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } httpRequest.setURI(uri); } return httpRequest; } \nResponse:", "ground_truth": "Get the HttpRequest class that represents this request type.\n\n@return a non-abstract class that implements {@link HttpRequest}", "predict": " Generate the method-level comment for the following java Code. Code: static HttpResponseBase createHttpResponse(int statusCode, String statusText, String contentType, InputStream content) { Class<? extends HttpResponseBase> type = HTTP_STATUS_CODE_TO_HTTP_RESPONSE_TYPE.get(statusCode); final HttpResponseBase httpResponse; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingResponse.class)) && content != null)) { httpResponse = new CustomHttpResponse(statusCode, statusText, contentType, content); } else { try { httpResponse = type.newInstance(); } catch (Exception e) { throw new Runtime"}, {"ID": 286, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartConfig defaultBoundary(String defaultBoundary) { return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true); } \nResponse:", "ground_truth": "Specify an explicit default multipart boundary to use when sending multi-part data.\n\n@param defaultBoundary The boundary to set\n@return An updated MultiPartConfig", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 287, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) { spec.attribute(attributeName, attributeValue); return this; } \nResponse:", "ground_truth": "Add request attribute\n\n@param attributeName  The attribute name\n@param attributeValue The attribute value\n@return The request specification builder", "predict": " Response is generated by the method-level comment. \n\n*/\n\npublic class MockMvcRequestSpecBuilder {\n\t\n\tprivate final MockMvcRequestSpecification spec;\n\t\n\tpublic MockMvcRequestSpecBuilder(MockMvcRequestSpecification spec) {\n\t\tthis.spec = spec;\n\t}\n\t\n\tpublic MockMvcRequestSpecification and() {\n\t\treturn spec;\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec) {\n\t\treturn spec.and(spec);\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec, MockMvcRequestSpecification spec2) {\n\t\treturn spec.and(spec2);\n\t}\n\t\n\tpublic MockMvcRequestSpecification and(MockMvcRequestSpecification spec, MockMvcRequestSpecification spec2, MockMvcRequestSpecification spec3) {\n"}, {"ID": 288, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) { spec.header(headerName, headerValue); return this; } \nResponse:", "ground_truth": "Add a header to be sent with the request\n\n@param headerName  The header name\n@param headerValue The header value\n@return The request specification builder", "predict": " Response = new ResponseBuilder().setStatusCode(200).setBody(\"{\\\"id\\\":\\\"123\\\",\\\"name\\\":\\\"John\\\"}\").build(); \n\n*/\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.springframework"}, {"ID": 289, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) { spec.multiPart(controlName, mimeType); return this; } \nResponse:", "ground_truth": "Specify a string to send to the server using multi-part form data with a specific mime-type.\n\n@param controlName Defines the control name of the body part. In HTML this is the attribute name of the input tag.\n@param contentBody The string to send\n@param mimeType    The mime-type\n@return The request specification", "predict": " MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8)\n\n*/\n\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"ID": 290, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.resultHandlers(resultHandler, additionalResultHandlers); return this; } \nResponse:", "ground_truth": "Add a result handler\n\n@param resultHandler The result handler\n@return MockMvcRequestSpecBuilder", "predict": " public MockMvcResponseSpecBuilder addResponseHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResponseResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResponseResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.responseHandlers(resultHandler, additionalResultHandlers); return this; } \nResp public MockMvcResponseSpecBuilder addResponseHandlers(ResponseResultHandler resultHandler, Result"}, {"ID": 291, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> HttpClientConfig setParam(String parameterName, T parameterValue) { notNull(parameterName, \"Parameter name\"); final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams); newParams.put(parameterName, parameterValue); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "            The parameter type\n@return An updated HttpClientConfig", "predict": " public <T> Response<T> get(String url, Class<T> responseType, Map<String, Object> params, Map<String, String> headers, HttpMultipartMode httpMultipartMode, boolean shouldReuseHttpClientInstance, HttpClient httpClient, boolean shouldAutoCloseHttpClient, HttpClientConfig httpClientConfig) { notNull(url, \"URL\"); notNull(responseType, \"Response type\"); notNull(params, \"Parameters\"); notNull(headers, \"Headers\"); notNull(httpMultipartMode, \"HttpMultipartMode\"); notNull(shouldReuseHttpClientInstance, \"Should reuse http client instance\"); notNull(httpClient, \"HttpClient\"); notNull(shouldAutoCloseHttpClient, \"Should auto close http client\"); notNull(httpClientConfig, \"HttpClientConfig\"); return new Response<T>(httpClient.get(url, responseType, params, headers, httpMultipartMode, shouldReuseHttpClientInstance"}, {"ID": 292, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig addParams(Map<String, ?> httpClientParams, HttpMultipartMode httpMultipartMode) { notNull(httpClientParams, \"httpClientParams\"); notNull(httpMultipartMode, \"httpMultipartMode\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams);"}, {"ID": 293, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResp public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultip"}, {"ID": 294, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); } \nResponse:", "ground_truth": "", "predict": " public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); } \n\n*/\n\npublic class HttpClientConfig {\n\tprivate HttpClientFactory httpClientFactory;\n\tprivate HttpClientParams httpClientParams;\n\tprivate HttpMultipartMode httpMultipartMode;\n\tprivate boolean shouldReuseHttpClientInstance;\n\tprivate HttpClient httpClient;\n\tprivate boolean isHttpClientConfig;\n\t\n\tpublic HttpClientConfig(HttpClientFactory httpClientFactory, HttpClientParams httpClientParams, HttpMultipartMode httpMultipartMode, boolean shouldReuseHttpClientInstance, HttpClient httpClient, boolean isHttpClientConfig) {\n\t\tthis.httpClientFactory = httpClientFactory;\n\t\tthis.http"}, {"ID": 295, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T get(String path) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a boolean.\n\n@param path The Object path.\n@return The object matching the Object path. This may be any primitive type, a List or a Map.  A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " public <T> T get(String path, Map<String, Object> params) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResp public <T> T get(String path, Map<String, Object> params, Map<String, Object> headers) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params, headers); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResp public <T> T get(String path, Map<String, Object> params, Map<String, Object> headers, Map<String, Object> cookies) { final JSONAssertion jsonAssertion = create"}, {"ID": 296, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as an int.\n\n@param path The Object path.\n@return The int matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " The method-level comment is now generated. Code: public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus"}, {"ID": 297, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte getByte(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Byte) { return (Byte) value; } else if (value instanceof Long) { return ((Long) value).byteValue(); } else if (value instanceof Integer) { return ((Integer) value).byteValue(); } else { return ObjectConverter.convertObjectTo(value, Byte.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a byte.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a byte.\n\n*/\n\npublic class ByteGetter implements Getter {\n    public Object get(Object object) {\n        return ((Map) object).get(key);\n    }\n}\n"}, {"ID": 298, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a short.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a short value.\n\n*/\n\npublic class ShortGetter extends Getter {\n    public Object getValue(Object obj) {\n        Object value = get(obj);\n        if (value instanceof Short) {\n            return value;\n        } else if (value instanceof Long) {\n            return ((Long) value).shortValue();\n        } else if (value instanceof Integer) {\n            return ((Integer) value).shortValue();\n        } else {\n            return ObjectConverter.convertObjectTo(value, Short.class);\n        }\n    }\n}\n"}, {"ID": 299, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public float getFloat(String path) { final Object value = get(path); //Groovy will always return a Double for floating point values. if (value instanceof Double) { return ((Double) value).floatValue(); } else { return ObjectConverter.convertObjectTo(value, Float.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a float.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is generated by the method getFloat(String path) in the class ObjectConverter.java.\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class ObjectConverter {\n    private static Map<String, Object> cache = new ConcurrentHashMap<String, Object>();\n\n    public static Object get(String path) {\n        if (cache.containsKey(path)) {\n            return cache.get(path);\n        }\n        return null;\n    }\n\n    public static void set(String path, Object value) {\n        cache.put(path, value);\n    }\n\n    public static List<Object> getList(String path) {\n        List<Object> list = new ArrayList<Object>();\n        if (cache.containsKey(path)) {\n            list.add("}, {"ID": 300, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public double getDouble(String path) { final Object value = get(path); if (value instanceof Double) { return (Double) value; } return ObjectConverter.convertObjectTo(value, Double.class); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a double.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is generated by the method.\n\n*/\n\npublic class ObjectConverter {\n\t\n\tpublic static Object convertObjectTo(Object value, Class<?> clazz) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (clazz.isAssignableFrom(value.getClass())) {\n\t\t\treturn value;\n\t\t}\n\t\tif (clazz.isAssignableFrom(String.class)) {\n\t\t\treturn value.toString();\n\t\t}\n\t\tif (clazz.isAssignableFrom(Integer.class)) {\n\t\t\treturn Integer.valueOf(value.toString());\n\t\t}\n\t\tif (clazz.isAssignableFrom(Double.class)) {\n\t\t\treturn Double.valueOf(value.toString());\n\t\t}\n\t\tif (clazz.isAssignableFrom(Float.class)) {\n\t\t\treturn Float.valueOf(value.toString());\n\t\t}"}, {"ID": 301, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a long.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Response is returned as a long value.\n\n*/\n\npublic class GroovyObjectConverter {\n\t\n\tpublic static Object convertObjectTo(Object value, Class<?> clazz) {\n\t\tif (clazz.equals(Long.class)) {\n\t\t\treturn (Long) value;\n\t\t} else if (clazz.equals(Short.class)) {\n\t\t\treturn (Short) value;\n\t\t} else if (clazz.equals(Integer.class)) {\n\t\t\treturn (Integer) value;\n\t\t} else if (clazz.equals(Float.class)) {\n\t\t\treturn (Float) value;\n\t\t} else if (clazz.equals(Double.class)) {\n\t\t\treturn (Double) value;\n\t\t} else if (clazz.equals(Boolean.class)) {\n\t\t\treturn (Boolean) value;\n\t\t} else if (clazz.equals(String.class)) {\n\t\t\treturn (String)"}, {"ID": 302, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> List<T> getList(String path, Class<T> genericType) { if (genericType == null) { throw new IllegalArgumentException(\"Generic type cannot be null\"); } final List<T> original = get(path); final List<T> newList = new LinkedList<T>(); if (original != null) { for (T t : original) { T e; if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) { // TODO Avoid double parsing String str = objectToString(t); //noinspection unchecked e = (T) jsonStringToObject(str, genericType); } else { e = ObjectConverter.convertObjectTo(t, genericType); } newList.add(e); } } return Collections.unmodifiableList(newList); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a list.\n\n@param path        The Object path.\n@param genericType The generic list type\n@param          The type\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " public <T> List<T> getList(String path, Class<T> genericType) { return get(path, genericType); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class ObjectConverter {\n\n    public static <T> T convertObjectTo(Object object, Class<T> genericType) {\n        if (genericType == null) {\n            throw new IllegalArgumentException(\"Generic type cannot be null\");\n        }\n        if (object == null) {\n            return null;\n        }\n        if (genericType.isAssignableFrom(object.getClass())) {\n            return (T) object;\n        }\n        if (genericType.isAssignableFrom(Map.class)) {\n            return (T) objectToMap(object);\n        }\n        if (genericType.isAssignableFrom(List.class)) {\n            return (T"}, {"ID": 303, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <K, V> Map<K, V> getMap(String path) { return get(path); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a map.\n\n@param path The Object path.\n@param   The type of the expected key\n@param   The type of the expected value\n@return The map matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 304, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); } \nResponse:", "ground_truth": "Get an XML document as a Java Object.\n\n@param objectType The type of the java object.\n@param         The type of the java object\n@return A Java object representation of the XML document", "predict": " public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); } \n\n*/\n\npublic class GetObject {\n\tpublic static void main(String[] args) {\n\t\tString path = \"\";\n\t\tString objectType = \"\";\n\t\t\n\t\tif (args.length == 2) {\n\t\t\tpath = args[0];\n\t\t\tobjectType = args[1];\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Generating the method-level comment for the following java Code.\");\n\t\tSystem.out.println(\"Code: public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); }\");\n\t\tSystem.out.println(\"Resp public <T> T getObject(String path, Class<T> object"}, {"ID": 305, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponse:", "ground_truth": "", "predict": " ResponseSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponseSpecBuilder setBody(Object object) { spec.body(object); return this; } \nResponseSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType) { spec.body(object, mimeType); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, String charset) { spec.body(object, mimeType, charset); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, Charset charset) { spec.body(object, mimeType, charset); return this; } \nResponseSpecBuilder setBody(Object object, String mimeType, String charsetName) { spec.body"}, {"ID": 306, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { spec.cookie(key, value, cookieNameValuePairs); return this; } \nResponse:", "ground_truth": "Add a cookie to be sent with the request.\n\n@param key                  The cookie key\n@param value                The cookie value\n@param cookieNameValuePairs Additional cookies values. This will actually create two cookies with the same name but with different values.\n@return The request specification builder", "predict": " public ResponseSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { return spec.response().addCookie(key, value, cookieNameValuePairs); } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode) { spec.expectStatus(statusCode); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase) { spec.expectStatus(statusCode, reasonPhrase); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase, String content) { spec.expectStatus(statusCode, reasonPhrase, content); return this; } \nResponseSpecBuilder: public ResponseSpecBuilder expectStatus(int statusCode, String reasonPhrase, String contentType, String content) { spec.expectStatus(statusCode, reasonPhrase, contentType, content); return this; } \nResponseSpecBuilder"}, {"ID": 307, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a parameter to be sent with the request.\n\n@param parameterName   The parameter name\n@param parameterValues Zero to many parameter values for this parameter name.\n@return The request specification builder", "predict": " ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody) { spec.response(httpStatusCode, responseBody); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType) { spec.response(httpStatusCode, responseBody, contentType); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding, acceptHeader); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader, String content"}, {"ID": 308, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a multi-value parameter to be sent with the request.\n\n@param parameterName   The parameter key\n@param parameterValues The parameter values\n@return The request specification builder", "predict": " ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody) { spec.response(httpStatusCode, responseBody); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType) { spec.response(httpStatusCode, responseBody, contentType); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader) { spec.response(httpStatusCode, responseBody, contentType, contentEncoding, acceptHeader); return this; } \nResp ResponseSpecBuilder addResponse(int httpStatusCode, String responseBody, String contentType, String contentEncoding, String acceptHeader, String content"}, {"ID": 309, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) { return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true); } \nResponse:", "ground_truth": "Set form parameter update strategy to the given value.\n\n@param updateStrategy The update strategy to use for form parameters\n@return A new instance of {@link MockMvcParamConfig}", "predict": " public MockMvcResponse response(MockMvcResult result) { return new MockMvcResponse(result); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType) { return new MockMvcResponse(result, contentType); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content) { return new MockMvcResponse(result, contentType, content); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content, String contentTypeOverride) { return new MockMvcResponse(result, contentType, content, contentTypeOverride); } \nResp public MockMvcResponse response(MockMvcResult result, String contentType, String content, String contentTypeOverride, String charset) { return new MockMvcResponse(result, contentType, content, contentTypeOverride, charset); } \nResp public MockM"}, {"ID": 310, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \nResponse:", "ground_truth": "Create a new logging filter without using the \"new\" operator.\nWill make the DSL look nicer.\n\n@param stream The print stream to log to\n@param matcher The matcher that must be fulfilled in order for logging to occur\n@return a new instance of the filter", "predict": "\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \n\nThe above code is the same as the following code.\n\npublic static Filter logResponseToIf"}, {"ID": 311, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Cookies(cookieList); } \nResponse:", "ground_truth": "An alternative way to create a Cookies object from the constructor.\n\n@param cookie            The cookie to be included\n@param additionalCookies Additional cookies to be included (optional)\n@return A new cookies object containing the specified cookies", "predict": " Response cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Response(cookieList); } \n\n*/\n\npublic class Cookies {\n\tprivate List<Cookie> cookies;\n\t\n\tpublic Cookies(List<Cookie> cookies) {\n\t\tthis.cookies = cookies;\n\t}\n\t\n\tpublic Response cookies(Cookie cookie, Cookie... additionalCookies) {\n\t\tAssertParameter.notNull(cookie, \"Cookie\");\n\t\tfinal List<Cookie> cookieList = new LinkedList<Cookie>();\n\t\tcookieList.add(cookie);\n\t\tCollections.addAll(cookieList, additionalCookies);\n\t\treturn new Response(cookieList);\n\t}\n}\n"}, {"ID": 312, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) { synchronized (lock) { for (KeyAndSource keyAndSource : keysAndSources) { Multiset<Object> set = backingMap.get(keyAndSource.key); if (set != null) { set.remove(keyAndSource.source); if (set.isEmpty()) { backingMap.remove(keyAndSource.key); } } } } } \nResponse:", "ground_truth": "There may be multiple child injectors blacklisting a certain key so only remove the source\nthat's relevant.", "predict": "\n\n*/\n\npublic class Solution {\n    public void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) {\n        synchronized (lock) {\n            for (KeyAndSource keyAndSource : keysAndSources) {\n                Multiset<Object> set = backingMap.get(keyAndSource.key);\n                if (set != null) {\n                    set.remove(keyAndSource.source);\n                    if (set.isEmpty()) {\n                        backingMap.remove(keyAndSource.key);\n                    }\n                }\n            }\n        }\n    }\n}\n"}, {"ID": 313, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } } \nResponse:", "ground_truth": "Indexes bindings by type.", "predict": " void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } } \n */\n\npublic class GenerateMethodComment {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString className = \"Test\";\n\t\tString methodName = \"index\";\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"/**\\n\");\n\t\tsb.append(\" * Generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2\\n\");\n\t\tsb.append(\" * See <a href=\\\"http://java.sun.com/xml/jaxb\\\">http://java.sun.com/xml/jaxb</a>\\n\");\n\t\tsb.append(\" * Any modifications to this file will be lost upon recompilation of the source"}, {"ID": 314, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); } \nResponse:", "ground_truth": "Gets a binding implementation. First, it check to see if the parent has a binding. If the\nparent has a binding and the binding is scoped, it will use that binding. Otherwise, this\nchecks for an explicit binding. If no explicit binding is found, it looks for a just-in-time\nbinding.", "predict": " Response<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding.getResponse(errors); } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); } \n\n}\n"}, {"ID": 315, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException { // Find a constant string binding. Key<String> stringKey = key.ofType(STRING_TYPE); BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey); if (stringBinding == null || !stringBinding.isConstant()) { return null; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @SuppressWarnings(\"unchecked\") String stringValue = ((InstanceBinding<String>) stringBinding).getInstance(); Object source = stringBinding.getSource(); // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type); if (converted == null) { throw errors .converterReturnedNull(stringValue, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(stringValue, source, type, typeConverterBinding, converted) .toException(); } return new ConvertedConstantBindingImpl<T>( this, key, converted, stringBinding, typeConverterBinding); } catch (ErrorsException e) { throw e; } catch (RuntimeException e) { throw errors .conversionError(stringValue, source, type, typeConverterBinding, e) .toException(); } } \nResponse:", "ground_truth": "Converts a constant string binding to the required type.\n\n@return the binding if it could be resolved, or null if the binding doesn't exist\n@throws com.google.inject.internal.ErrorsException if there was an error resolving the binding", "predict": " Response<T> { // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(value, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(value, type); if (converted == null) { throw errors .converterReturnedNull(value, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(value, source, type, typeConverterB"}, {"ID": 316, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if (failed) { removeFailedJitBinding(depBinding, ip); bindingFailed = true; } } else if (state.getExplicitBinding(depKey) == null) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true; } } } return bindingFailed; } \nResponse:", "ground_truth": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "predict": " public boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if"}, {"ID": 317, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) { failedJitBindings.add(binding.getKey()); jitBindings.remove(binding.getKey()); membersInjectorStore.remove(binding.getKey().getTypeLiteral()); provisionListenerStore.remove(binding); if (ip != null) { constructors.remove(ip); } } \nResponse:", "ground_truth": "Cleans up any state that may have been cached when constructing the JIT binding.", "predict": "\n\n*/\n\npackage com.google.inject.internal;\n\nimport com.google.inject.Binding;\nimport com.google.inject.Key;\nimport com.google.inject.internal.util.StackTraceElements;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.HasDependencies;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding;\nimport com.google.inject.spi.ProvidesProviderTarget"}, {"ID": 318, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) { if (binding instanceof ConstructorBindingImpl) { return ((ConstructorBindingImpl) binding).getInternalDependencies(); } else if (binding instanceof HasDependencies) { return ((HasDependencies) binding).getDependencies(); } else { return ImmutableSet.of(); } } \nResponse:", "ground_truth": "Safely gets the dependencies of possibly not initialized bindings.", "predict": " Response<Set<Dependency<?>>>\n\n*/\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.name.Names;\n\n@Path(\"/\")\npublic class MyResource {\n\n    private final Injector injector;\n\n    @Inject\n    public MyResource(Injector injector) {\n        this.injector = injector;\n    }\n\n    @GET\n    @Path(\"/get\")\n    @Produces(MediaType.AP"}, {"ID": 319, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException { Class<?> rawType = key.getTypeLiteral().getRawType(); ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class); // Don't try to inject arrays or enums annotated with @ImplementedBy. if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) { throw errors.missingImplementationWithHint(key, this).toException(); } // Handle TypeLiteral<T> by binding the inner type if (rawType == TypeLiteral.class) { @SuppressWarnings(\"unchecked\") // we have to fudge the inner type as Object BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors); return binding; } // Handle @ImplementedBy if (implementedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createImplementedByBinding(key, scoping, implementedBy, errors); } // Handle @ProvidedBy. ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class); if (providedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createProvidedByBinding(key, scoping, providedBy, errors); } return ConstructorBindingImpl.create( this, key, null, /* use default constructor */ source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired); } \nResponse:", "ground_truth": "Creates a binding for an injectable type with the given scope. Looks for a scope on the type if\nnone is specified.", "predict": " Response<T> createResponse( Class<T> responseType, Object response, Scoping scoping, Errors errors) { return new Response<T>( responseType, response, scoping, errors ); } \n\n}\n"}, {"ID": 320, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException { if (parameterInjectors == null) { return NO_ARGUMENTS; } int size = parameterInjectors.length; Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) { parameters[i] = parameterInjectors[i].inject(context); } return parameters; } \nResponse:", "ground_truth": "Returns an array of parameter values.", "predict": " Response = new Response(new Object[] {parameterInjectors});\n\n*/\n\npublic class SingleParameterInjector<T> implements ParameterInjector<T> {\n    private final Class<T> clazz;\n    private final T value;\n\n    public SingleParameterInjector(Class<T> clazz, T value) {\n        this.clazz = clazz;\n        this.value = value;\n    }\n\n    @Override\n    public Class<T> getParameterClass() {\n        return clazz;\n    }\n\n    @Override\n    public T inject(InternalContext context) throws InternalProvisionException {\n        return value;\n    }\n}\n"}, {"ID": 321, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindInjector(InjectorImpl injector) { Key<Injector> key = Key.get(Injector.class); InjectorFactory injectorFactory = new InjectorFactory(injector); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Injector>( injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Injector is a special case because we allow both parent and child injectors to both have a\nbinding for that key.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Providers.ProviderInstanceBinding;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilder;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilderImpl;\nimport com.google.inject.util.Providers.ProviderInstanceBindingImpl.ProviderInstanceBindingBuilderImpl.ProviderInstanceBindingBuilder"}, {"ID": 322, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding"}, {"ID": 323, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) { Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation( errors, member, ((AnnotatedElement) member).getAnnotations()); if (misplacedBindingAnnotation == null) { return false; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if (member instanceof Method) { try { if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) { return false; } } catch (NoSuchFieldException ignore) { } } errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation); return true; } \nResponse:", "ground_truth": "Returns true if the binding annotation is in the wrong place.", "predict": "\n\n*/\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Documented\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Response {\n    String value();\n}\n"}, {"ID": 324, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean overrides(Method a, Method b) { // See JLS section 8.4.8.1 int modifiers = b.getModifiers(); if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) { return true; } if (Modifier.isPrivate(modifiers)) { return false; } // b must be package-private return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage()); } \nResponse:", "ground_truth": "Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\nclass is a subclass of b's declaring class.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add(\"m\");\n        list.add(\"n\");\n        list.add(\"o\");\n        list.add(\"p\");\n        list.add(\"q\");\n        list.add(\"r\");\n        list.add(\"s\");\n        list.add(\"t\");\n        list"}, {"ID": 325, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(MembersInjector<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual members injector.\n\n@throws IllegalStateException if the delegate is already set", "predict": " public void injectMembers(T instance) { checkState(this.delegate != null, \"delegate not initialized\"); this.delegate.injectMembers(instance); } \n\n*/\n\npublic class MembersInjectorGenerator extends AbstractMethodGenerator {\n    public MembersInjectorGenerator(int access, Type returnType, Type... argumentTypes) {\n        super(access, returnType, argumentTypes);\n    }\n\n    @Override\n    public void generate(CodeEmitter cv) {\n        cv.visitMethodInsn(Opcodes.INVOKESTATIC, \"MembersInjector\", \"initializeDelegate\",\n                \"(LMembersInjector;)V\", false);\n        cv.visitVarInsn(Opcodes.ALOAD, 0);\n        cv.visitMethodInsn(Opcodes.INVOKESTATIC, \"MembersInjector\", \"injectMembers\",\n                \"(Ljava/"}, {"ID": 326, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final TypeLiteral<Provider<T>> providerType() { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())); } \nResponse:", "ground_truth": "Gets the type of this type's provider.", "predict": " Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType) { return get(type, annotations, mediaType, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders) { return get(type, annotations, mediaType, httpHeaders, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders, final Class<? extends Annotation> annotationType) { return get(type, annotations, mediaType, httpHeaders, annotationType, null); } \nResp Response<T> get(final TypeLiteral<T> type, final Annotation[] annotations, final MediaType mediaType, final"}, {"ID": 327, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<TypeLiteral<?>> resolveAll(Type[] types) { TypeLiteral<?>[] result = new TypeLiteral<?>[types.length]; for (int t = 0; t < types.length; t++) { result[t] = resolve(types[t]); } return ImmutableList.copyOf(result); } \nResponse:", "ground_truth": "Returns an immutable list of the resolved types.", "predict": " private TypeLiteral<?> resolve(Type type) { return TypeLiteral.get(type); } \n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class TypeLiteralTest {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list2 = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list3 = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list4 = Arrays.asList"}, {"ID": 328, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { Type type = typeLiteral.getType(); if (!isFullySpecified(type)) { Errors errors = new Errors().keyNotFullySpecified(typeLiteral); throw new ConfigurationException(errors.getMessages()); } if (typeLiteral.getRawType() == javax.inject.Provider.class) { ParameterizedType parameterizedType = (ParameterizedType) type; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @SuppressWarnings(\"unchecked\") TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0])); return guiceProviderType; } @SuppressWarnings(\"unchecked\") TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral); if (wrappedPrimitives != null) { return wrappedPrimitives; } // If we know this isn't a subclass, return as-is. if (typeLiteral.getClass() == TypeLiteral.class) { return typeLiteral; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @SuppressWarnings(\"unchecked\") TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType()); return recreated; } \nResponse:", "ground_truth": "Returns an type that's appropriate for use in a key.\n\nIf the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a\n{@code com.google.inject.Provider} with the same type parameters.\n\nIf the type is a primitive, the corresponding wrapper type will be returned.\n\n@throws ConfigurationException if {@code type} contains a type variable", "predict": " public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { return canonicalizeForKey(typeLiteral, new Errors()); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors) { return canonicalizeForKey(typeLiteral, errors, new TypeLiteral[0]); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors, TypeLiteral<?>... typeLiterals) { return canonicalizeForKey(typeLiteral, errors, Arrays.asList(typeLiterals)); } \nResp public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral, Errors errors, Collection<TypeL"}, {"ID": 329, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \"TypeConverter<Character>\"; } }); convertToClasses( injector, Matchers.subclassesOf(Enum.class), new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { return Enum.valueOf((Class) toType.getRawType(), value); } @Override public String toString() { return \"TypeConverter<E extends Enum<E>>\"; } }); internalConvertToTypes( injector, new AbstractMatcher<TypeLiteral<?>>() { @Override public boolean matches(TypeLiteral<?> typeLiteral) { return typeLiteral.getRawType() == Class.class; } @Override public String toString() { return \"Class<?>\"; } }, new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new RuntimeException(e.getMessage()); } } @Override public String toString() { return \"TypeConverter<Class<?>>\"; } }); } \nResponse:", "ground_truth": "Installs default converters for primitives, enums, and class literals.", "predict": " Response<String> convertToString(String value) { return Response.ok(value); } \nResp Response<Integer> convertToInteger(String value) { return Response.ok(Integer.valueOf(value)); } \nResp Response<Long> convertToLong(String value) { return Response.ok(Long.valueOf(value)); } \nResp Response<Boolean> convertToBoolean(String value) { return Response.ok(Boolean.valueOf(value)); } \nResp Response<Byte> convertToByte(String value) { return Response.ok(Byte.valueOf(value)); } \nResp Response<Short> convertToShort(String value) { return Response.ok(Short.valueOf(value)); } \nResp Response<Float> convertToFloat(String value) { return Response.ok(Float.valueOf(value)); } \nResp Response<Double> convertToDouble(String value) { return Response."}, {"ID": 330, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static ClassLoader canonicalize(ClassLoader classLoader) { return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent(); } \nResponse:", "ground_truth": "Attempts to canonicalize null references to the system class loader. May return null if for\nsome reason the system loader is unavailable.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 331, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasSameVersionOfCglib(ClassLoader classLoader) { Class<?> fc = net.sf.cglib.reflect.FastClass.class; try { return classLoader.loadClass(fc.getName()) == fc; } catch (ClassNotFoundException e) { return false; } } \nResponse:", "ground_truth": "Returns true if the types classloader has the same version of cglib that BytecodeGen has. This\nonly returns false in strange OSGI situations, but it prevents us from using FastClass for non\npublic members.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class CglibProxy {\n\tpublic static void main(String[] args) {\n\t\tEnhancer enhancer = new Enhancer();\n\t\tenhancer.setSuperclass(Object.class);\n\t\tenhancer.setCallback(new MethodInterceptor() {\n\t\t\t@Override\n\t\t\tpublic Object intercept(Object obj, Method method, Object[] args,\n\t\t\t\t\tMethodProxy proxy) throws Throwable {\n\t\t\t\tSystem.out.println(\"CglibProxy: \" + method.getName());\n\t\t\t\treturn proxy.invokeSuper(obj, args);\n\t\t\t}\n\t\t});\n\t\tenhancer.setUseCache(false);"}, {"ID": 332, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean isPubliclyCallable(Member member) { if (!Modifier.isPublic(member.getModifiers())) { return false; } Class<?>[] parameterTypes; if (member instanceof Constructor) { parameterTypes = ((Constructor) member).getParameterTypes(); } else { Method method = (Method) member; if (!Modifier.isPublic(method.getReturnType().getModifiers())) { return false; } parameterTypes = method.getParameterTypes(); } for (Class<?> type : parameterTypes) { if (!Modifier.isPublic(type.getModifiers())) { return false; } } return true; } \nResponse:", "ground_truth": "Returns true if the member can be called by a fast class generated in a different classloader.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n    public static void main(String[] args) {\n        List<String> javaCode = new ArrayList<>();\n        javaCode.add(\"package com.example.myapp;\");\n        javaCode.add(\"\");\n        javaCode.add(\"import java.util.ArrayList;\");\n        javaCode.add(\"import java.util.List;\");\n        javaCode.add(\"\");\n        javaCode.add(\"public class JavaCodeGenerator {\");\n        javaCode.add(\"\");\n        javaCode.add(\"    private static boolean isPubliclyCallable(Member member) {\");\n        javaCode.add(\"        if (!Modifier.isPublic(member.getModifiers())) {\");\n        javaCode.add(\"            return false;\");\n        javaCode.add(\"        }\");\n        javaCode"}, {"ID": 333, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); } \nResponse:", "ground_truth": "Replace annotation instances with annotation types, this is only appropriate for testing if a\nkey is bound and not for injecting.\n\n", "predict": " public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface FixAnnotations {\n}\n"}, {"ID": 334, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Initializable<T> requestInjection( InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Member injection could not be requested after validation is started\"); ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding); // short circuit if the object has no injections or listeners. if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return Initializables.of(instance); } if (initializablesCache.containsKey(instance)) { @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T> Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance); return cached; } InjectableReference<T> injectableReference = new InjectableReference<T>( injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass())); initializablesCache.put(instance, injectableReference); pendingInjections.add(injectableReference); return injectableReference; } \nResponse:", "ground_truth": "Registers an instance for member injection when that step is performed.\n\n@param instance an instance that optionally has members to be injected (each annotated\nwith @Inject).\n@param binding the binding that caused this initializable to be created, if it exists.\n@param source the source location that this injection was requested", "predict": " void requestStaticInjection( InjectorImpl injector, Class<?> type, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Static injection could not be requested after validation is started\"); ProvisionListenerStackCallback<Object> provisionCallback = injector.provisionListenerStore.get(type); // short circuit if the object has no injections or listeners. if (type == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return; } if (staticInjections.containsKey(type)) { @SuppressWarnings(\"unchecked\") // Map from Class<T> to StaticInjection<T> StaticInjection<T> cached = (StaticInjection<T>) staticInjections.get(type); return cached; } StaticInjection<Object> staticInjection = new StaticIn"}, {"ID": 335, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } } \nResponse:", "ground_truth": "Prepares member injectors for all injected instances. This prompts Guice to do static analysis\non the injected instances.", "predict": " void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } } \n */\n\npublic class InjectableReference<T> {\n    private final Class<T> type;\n    private final String name;\n    private final String description;\n    private final boolean optional;\n    private final boolean required;\n    private final boolean injectable;\n    private final boolean injectableAtStartup;\n    private final boolean injectableAtShutdown;\n    private final boolean injectableAtValidation;\n    private final boolean injectableAtInitialization;\n    private final boolean injectableAtValidation;\n    private final boolean injectableAtInitialization;\n    private final boolean injectableAtShutdown;\n    private"}, {"ID": 336, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T newInstance(Object[] args) throws Throwable { constructor.setAccessible(true); try { return constructor.newInstance(args); } catch (InvocationTargetException e) { throw e.getCause(); } } \nResponse:", "ground_truth": "Returns an instance of T, constructed using this constructor, with the supplied arguments.", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        try {\n            test.newInstance(new Object[]{});\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n\n    public Test() {\n    }\n\n    public Test(Object[] args) {\n    }\n\n    public Test(Object arg) {\n    }\n\n    public Test(Object arg1, Object arg2) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {\n    }\n\n    public Test(Object arg1, Object arg2, Object arg3, Object arg4, Object arg"}, {"ID": 337, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"JavaDoc\", \"deprecation\"}) private ServletRequest withDispatcher( ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if (!servletPipeline.hasServletsMapped()) { return servletRequest; } HttpServletRequest request = (HttpServletRequest) servletRequest; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper(request) { @Override public RequestDispatcher getRequestDispatcher(String path) { final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path); return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path); } }; } \nResponse:", "ground_truth": "Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular\npipeline based on uri-path match. This proxy also provides minimal forwarding support.\n\nWe cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline\nis not called again). However, we can wrap requests with our own dispatcher to forward the\n*other* way. web.xml Servlets/JSPs can forward to themselves as per normal.\n\nThis is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,\nincrementally, but not the other way around (which, we should actively discourage).", "predict": "\n\npublic class HttpServletRequestWrapper extends HttpServletRequestWrapper {\n    private final HttpServletRequest request;\n    private final ManagedServletPipeline servletPipeline;\n\n    public HttpServletRequestWrapper(HttpServletRequest request, ManagedServletPipeline servletPipeline) {\n        super(request);\n        this.request = request;\n        this.servletPipeline = servletPipeline;\n    }\n\n    @Override public ServletContext getServletContext() {\n        return servletPipeline.getServletContext();\n    }\n\n    @Override public AsyncContext startAsync() throws IllegalStateException {\n        return request.startAsync();\n    }\n\n    @Override public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException {\n        return request.startAsync(servletRequest, servletResponse);"}, {"ID": 338, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> InternalFactory<? extends T> scope( Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) { if (scoping.isNoScope()) { return creator; } Scope scope = scoping.getScopeInstance(); // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here. If you change the type make sure to update // SingletonScope as well. Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)); return new InternalFactoryToProviderAdapter<T>(scoped, source); } \nResponse:", "ground_truth": "Scopes an internal factory.", "predict": "\n\n*/\n\npackage com.google.inject.internal;\n\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.internal.util.SourceProvider;\nimport com.google.inject.spi.BindingTargetVisitor;\nimport com.google.inject.spi.Dependency;\nimport com.google.inject.spi.ProviderInstanceBinding;\nimport com.google.inject.spi.ProviderWithExtensionVisitor;\nimport com.google.inject.spi.ProvidesMethodBinding;\nimport com.google.inject.spi.ProvidesMethodTargetVisitor;\nimport com.google.inject.spi.ProvidesProviderBinding;\nimport com.google.inject.spi.ProvidesProviderTargetVisitor;\nimport com.google.inject.spi.ProvidesScoping;\n"}, {"ID": 339, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) { Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation(); if (scopeAnnotation == null) { return scoping; } ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation); if (scope != null) { return forInstance(scope.getScope()); } errors.scopeNotFound(scopeAnnotation); return UNSCOPED; } \nResponse:", "ground_truth": "Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance\nmap. If the scope annotation has no corresponding instance, an error will be added and unscoped\nwill be retuned.", "predict": " Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance(Scope scope) { return new Response<Scoping>(scope); } \nResp Response<Scoping> forInstance("}, {"ID": 340, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static String normalizePath(String path) { StringBuilder sb = new StringBuilder(path.length()); int queryStart = path.indexOf('?'); String query = null; if (queryStart != -1) { query = path.substring(queryStart); path = path.substring(0, queryStart); } // Normalize the path. we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List<String> segments = new ArrayList<>(); for (String segment : SLASH_SPLITTER.split(path)) { // This decodes all non-special characters from the path segment. so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false)); if (\".\".equals(normalized)) { // skip } else if (\"..\".equals(normalized)) { if (segments.size() > 1) { segments.remove(segments.size() - 1); } } else { segments.add(normalized); } } SLASH_JOINER.appendTo(sb, segments); if (query != null) { sb.append(query); } return sb.toString(); } \nResponse:", "ground_truth": "Normalizes a path by unescaping all safe, percent encoded characters.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static String normalizePath(String path) {\n        StringBuilder sb = new StringBuilder(path.length());\n        int queryStart = path.indexOf('?');\n        String query = null;\n        if (queryStart != -1) {\n            query = path.substring(queryStart);\n            path = path.substring(0, queryStart);\n        }\n        // Normalize the path. we need to decode path segments, normalize and rejoin in order to\n        // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p'\n        // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/'\n        "}, {"ID": 341, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); } \nResponse:", "ground_truth": "Generates an Annotation for the annotation class. Requires that the annotation is all\noptionals.", "predict": " public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common"}, {"ID": 342, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) { Retention retention = annotationType.getAnnotation(Retention.class); return retention != null && retention.value() == RetentionPolicy.RUNTIME; } \nResponse:", "ground_truth": "Returns true if the given annotation is retained at runtime.", "predict": "\n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class RetentionPolicy {\n\n    public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) {\n        Retention retention = annotationType.getAnnotation(Retention.class);\n        return retention != null && retention.value() == RetentionPolicy.RUNTIME;\n    }\n\n    public static Set<String> getRetainedAnnotationTypes(Class<? extends Annotation> annotationType) {\n        Set<String> retainedAnnotationTypes = new HashSet<>();\n        for (Method method : annotationType.getMethods()) {\n            if (method.getName().startsWith(\"is\")) {\n                retainedAnnotationTypes.add(method.getName().substring(2));\n            "}, {"ID": 343, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class<? extends Annotation> findScopeAnnotation( Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; } \nResponse:", "ground_truth": "Returns the scoping annotation, or null if there isn't one.", "predict": " public static Class<? extends Annotation> findScopeAnnotation(Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ScopeAnnotation {\n    Class<? extends Annotation> value();\n}\n"}, {"ID": 344, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); } \nResponse:", "ground_truth": "Gets a key for the given type, member and annotations.", "predict": " public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\n\n"}, {"ID": 345, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } } \nResponse:", "ground_truth": "Returns the name the binding should use. This is based on the annotation. If the annotation has\nan instance and is not a marker annotation, we ask the annotation for its toString. If it was a\nmarker annotation or just an annotation type, we use the annotation's name. Otherwise, the name\nis the empty string.", "predict": " public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } } \n\n*/\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class AnnotationUtils {\n\n    private static final Map<Class<? extends Annotation>, Set<Class<?>>> annotationMap = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();\n\n    static {\n        ann"}, {"ID": 346, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual provider.\n\n@throws IllegalStateException if the delegate is already set", "predict": " public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResp public void initializeDelegate(Provider<T> delegate) { checkState("}, {"ID": 347, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); } \nResponse:", "ground_truth": "Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate\nbindings.", "predict": " Response is generated by the following java Code. Code: private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); } \n */\n\npublic class RealDirectTypeProvider<T> implements Provider<T> {\n    private final BindingSelection bindingSelection;\n\n    public RealDirectTypeProvider(BindingSelection bindingSelection) {\n        this.bindingSelection = bindingSelection;\n    }\n\n    @Override\n    public T get() {\n        return bindingSelection.getDirectKey();\n    }\n}\n"}, {"ID": 348, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); } \nResponse:", "ground_truth": "Returns a new complete constructor injector with injection listeners registered.", "predict": " public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); } \n\n*/\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\n\npublic class ConstructorInjector<T> {\n\t\n\tprivate final Constructor<T> constructor;\n\tprivate final List"}, {"ID": 349, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasScope(Class<? extends Interceptor> interceptorClass) { for (Annotation annotation : interceptorClass.getAnnotations()) { if (Annotations.isScopeAnnotation(annotation.annotationType())) { return true; } } return false; } \nResponse:", "ground_truth": "Returns true if the given class has a scope annotation.", "predict": " Response response = null;\nif (hasScope(interceptorClass)) {\nresponse = interceptorClass.newInstance().intercept(request);\n}\nreturn response;\n}\n\n*/\n"}, {"ID": 350, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <K, V> RealMapBinder<K, V> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) { binder = binder.skipSources(RealMapBinder.class); TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral(); return newRealMapBinder( binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder( binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType)))); } \nResponse:", "ground_truth": "since it's an easy way to group a type and an optional annotation type or instance.", "predict": " Response<RealMapBinder<K, V>> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, TypeLiteral<E> elementType, Multibinder<E> elements) { return newRealMapBinder( binder, keyType, valueType, elementType, elements, RealMultibinder.newRealSetBinder( binder, elementType)); } \nResp Response<RealMapBinder<K, V>> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, TypeLiteral<E> elementType, Multibinder<E> elements, SetBinder<V> valueSetBinder) { return newRealMapBinder( binder, keyType, valueType, elementType, elements, valueSetBinder, RealMultibinder.newRealSetBinder( binder,"}, {"ID": 351, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<V> getKeyForNewValue(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey)); return valueKey; } \nResponse:", "ground_truth": "Adds a binding to the map for the given key.", "predict": " Response<V> getValueForKey(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); return entrySetBinder.get(key).get(); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.multibindings.Multibinder;\nimport com.google.inject.name.Names;\n\npublic class MapBinderModule extends AbstractModule {\n\n\t@Override\n\tprotected void configure() {\n\t\tMultibinder<Map.Entry<String,"}, {"ID": 352, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return t; } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor(cause) .addSource(constructionProxy.getInjectionPoint()); } finally { constructionContext.removeCurrentReference(); } } \nResponse:", "ground_truth": "Provisions a new T.", "predict": " Response<T> provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return Response.instance(t); } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor("}, {"ID": 353, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object writeReplace() throws ObjectStreamException { Object[] sourcesAsStrings = sources.toArray(); for (int i = 0; i < sourcesAsStrings.length; i++) { sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString(); } return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause); } \nResponse:", "ground_truth": "When serialized, we eagerly convert sources to strings. This hurts our formatting, but it\nguarantees that the receiving end will be able to read the message.", "predict": " Response(Message message) { this.message = message; } \nResp Response(Message message, Throwable cause) { this.message = message; this.cause = cause; } \nResp Response(Throwable cause) { this.cause = cause; } \nResp Response(Throwable cause, Message message) { this.message = message; this.cause = cause; } \nResp Response(Throwable cause, Message message, Object[] sources) { this.message = message; this.cause = cause; this.sources = sources; } \nResp Response(Throwable cause, Message message, Object[] sources, Object[] params) { this.message = message; this.cause = cause; this.sources = sources; this.params = params; } \nResp Response(Throwable cause, Message message, Object[] sources, Object[] params, Object[] args) { this.message = message; this.cause = cause; this.sources = sources;"}, {"ID": 354, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Module forModule(Module module) { // avoid infinite recursion, since installing a module always installs itself if (module instanceof CheckedProviderMethodsModule) { return Modules.EMPTY_MODULE; } return new CheckedProviderMethodsModule(module); } \nResponse:", "ground_truth": "Returns a module which creates bindings for provider methods from the given module.", "predict": "\n\n*/\n\npublic class CheckedProviderMethodsModule extends AbstractModule {\n    private final Module module;\n\n    public CheckedProviderMethodsModule(Module module) {\n        this.module = module;\n    }\n\n    @Override\n    protected void configure() {\n        install(module);\n    }\n}\n"}, {"ID": 355, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings(\"unchecked\") public Collection<AssistedMethod> getAssistedMethods() { return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values(); } \nResponse:", "ground_truth": "the collection is immutable.", "predict": " Response is generated by the method getResponse() in the class Response.\n*/\n\npublic class AssistData {\n\t\n\tprivate String methodName;\n\tprivate String methodDescription;\n\tprivate String methodReturnType;\n\tprivate String methodReturnDescription;\n\tprivate String methodReturnTypeName;\n\tprivate String methodReturnDescriptionName;\n\tprivate String methodReturnTypeNameWithGenerics;\n\tprivate String methodReturnDescriptionNameWithGenerics;\n\tprivate String methodReturnTypeNameWithGenericsAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParametersAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParametersAndParameters;\n\tprivate String methodReturnDescriptionNameWithGenericsAndParametersAndParametersAndParameters;\n\tprivate String methodReturnTypeNameWithGenericsAndParametersAndParametersAndParametersAndParameters;\n\tprivate"}, {"ID": 356, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) { Collection<Message> messages = ce.getErrorMessages(); if (messages.size() == 1) { Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages()); return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage()); } else { return false; } } \nResponse:", "ground_truth": "Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully\nspecified.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport org.junit.Test;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedMap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\npublic class TestGenerate {\n\n\t@Test\n\tpublic void testGenerate() {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t"}, {"ID": 357, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean constructorHasMatchingParams( TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException { List<TypeLiteral<?>> params = type.getParameterTypes(constructor); Annotation[][] paramAnnotations = constructor.getParameterAnnotations(); int p = 0; List<Key<?>> constructorKeys = Lists.newArrayList(); for (TypeLiteral<?> param : params) { Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors); constructorKeys.add(paramKey); } // Require that every key exist in the constructor to match up exactly. for (Key<?> key : paramList) { // If it didn't exist in the constructor set, we can't use it. if (!constructorKeys.remove(key)) { return false; } } // If any keys remain and their annotation is Assisted, we can't use it. for (Key<?> key : constructorKeys) { if (key.getAnnotationType() == Assisted.class) { return false; } } // All @Assisted params match up to the method's parameters. return true; } \nResponse:", "ground_truth": "Matching logic for constructors annotated with AssistedInject. This returns true if and only if\nall @Assisted parameters in the constructor exactly match (in any order) all @Assisted\nparameters the method's parameter.", "predict": " private Response<R> invoke(TypeLiteral<?> type, Object[] args, Type genericReturnType, Type genericReturnType2, Type genericReturnType3, Type genericReturnType4, Type genericReturnType5, Type genericReturnType6, Type genericReturnType7, Type genericReturnType8, Type genericReturnType9, Type genericReturnType10, Type genericReturnType11, Type genericReturnType12, Type genericReturnType13, Type genericReturnType14, Type genericReturnType15, Type genericReturnType16, Type genericReturnType17, Type genericReturnType18, Type genericReturnType19, Type genericReturnType20, Type genericReturnType21, Type genericReturnType22, Type genericReturnType23, Type genericReturnType24, Type genericReturnType25, Type genericReturnType26, Type genericReturnType27, Type genericReturnType28, Type genericReturnType29, Type genericReturnType30, Type genericReturnType31, Type genericReturnType32, Type genericReturnType33,"}, {"ID": 358, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); builder.addAll(ctorPoint.getDependencies()); if (!implementation.getRawType().isInterface()) { for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) { builder.addAll(ip.getDependencies()); } } return builder.build(); } \nResponse:", "ground_truth": "Calculates all dependencies required by the implementation and constructor.", "predict": " Response<T> get(Request<T> request) { return null; } \nResp Response<T> post(Request<T> request) { return null; } \nResp Response<T> put(Request<T> request) { return null; } \nResp Response<T> delete(Request<T> request) { return null; } \nResp Response<T> head(Request<T> request) { return null; } \nResp Response<T> options(Request<T> request) { return null; } \nResp Response<T> trace(Request<T> request) { return null; } \nResp Response<T> patch(Request<T> request) { return null; } \nResp Response<T> connect(Request<T> request) { return null; } \nResp Response<T> patch(Request<T> request) { return null; } \nResp Response<T> options("}, {"ID": 359, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); for (Dependency<?> dep : deps) { Class<?> annotationType = dep.getKey().getAnnotationType(); if (annotationType == null || !annotationType.equals(Assisted.class)) { builder.add(dep); } } return builder.build(); } \nResponse:", "ground_truth": "Return all non-assisted dependencies.", "predict": " Response<Set<Dependency<?>>> removeAssistedDeps(Set<Dependency<?>> deps) { return Response.success(removeAssistedDeps(deps)); } \n */\n\npublic class RemoveAssistedDeps {\n    public static void main(String[] args) {\n        Response<Set<Dependency<?>>> response = Response.success(removeAssistedDeps(new HashSet<Dependency<?>>()));\n        System.out.println(response.body());\n    }\n}\n"}, {"ID": 360, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { Set<Dependency<?>> badDeps = null; // optimization: create lazily for (Dependency<?> dep : dependencies) { if (isInjectorOrAssistedProvider(dep)) { if (badDeps == null) { badDeps = Sets.newHashSet(); } badDeps.add(dep); } } if (badDeps != null && !badDeps.isEmpty()) { logger.log( Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!) \" + \"The exact offending deps are: {2}\", new Object[] {factoryType, implementation, badDeps}); return false; } return true; } \nResponse:", "ground_truth": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "predict": "\n\n@AssistedInject\npublic class MyAssistedInjectFactory implements Factory<MyAssistedInjectFactory> {\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider2;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider2;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider3;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider3;\n    private final Provider<MyAssistedInjectService> myAssistedInjectServiceProvider4;\n    private final Provider<MyOtherAssistedInjectService> myOtherAssistedInjectServiceProvider4;\n    private final Provider<My"}, {"ID": 361, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey).toProvider(Providers.of(args[p++])); } } else { for (Key<?> paramKey : data.paramTypes) { // Bind to our ThreadLocalProviders. binder.bind((Key) paramKey).toProvider(data.providers.get(p++)); } } Constructor constructor = data.constructor; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if (constructor != null) { binder .bind(returnKey) .toConstructor(constructor, (TypeLiteral) data.implementationType) .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type } } }; Injector forCreate = injector.createChildInjector(assistedModule); Binding<?> binding = forCreate.getBinding(returnKey); // If we have providers cached in data, cache the binding for future optimizations. if (data.optimized) { data.cachedBinding = binding; } return binding; } \nResponse:", "ground_truth": "Creates a child injector that binds the args, and returns the binding for the method's result.", "predict": " public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey"}, {"ID": 362, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if (methodHandleByMethod.containsKey(method)) { return methodHandleByMethod.get(method).invokeWithArguments(args); } if (method.getDeclaringClass().equals(Object.class)) { if (\"equals\".equals(method.getName())) { return proxy == args[0]; } else if (\"hashCode\".equals(method.getName())) { return System.identityHashCode(proxy); } else { return method.invoke(this, args); } } AssistData data = assistDataByMethod.get(method); checkState(data != null, \"No data for method: %s\", method); Provider<?> provider; if (data.cachedBinding != null) { // Try to get optimized form... provider = data.cachedBinding.getProvider(); } else { provider = getBindingFromNewInjector(method, args, data).getProvider(); } try { int p = 0; for (ThreadLocalProvider tlp : data.providers) { tlp.set(args[p++]); } return provider.get(); } catch (ProvisionException e) { // if this is an exception declared by the factory method, throw it as-is if (e.getErrorMessages().size() == 1) { Message onlyError = getOnlyElement(e.getErrorMessages()); Throwable cause = onlyError.getCause(); if (cause != null && canRethrow(method, cause)) { throw cause; } } throw e; } finally { for (ThreadLocalProvider tlp : data.providers) { tlp.remove(); } } } \nResponse:", "ground_truth": "When a factory method is invoked, we create a child injector that binds all parameters, then\nuse that to get an instance of the return type.", "predict": "\n\npublic Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n  Object result = null;\n  try {\n    result = invokeProxy(proxy, method, args);\n  } catch (InvocationTargetException e) {\n    Throwable cause = e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw (RuntimeException) cause;\n    } else if (cause instanceof Error) {\n      throw (Error) cause;\n    } else {\n      throw e;\n    }\n  }\n  return result;\n}\n\npublic Object invokeProxy(Object proxy, final Method method, final Object[] args) throws Throwable {\n  Object result = null;\n  try {\n    result = method.invoke(this, args);\n  } catch (InvocationTargetException e) {\n    Throwable cause = e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw ("}, {"ID": 363, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb.append(format(\"%n * %s\", sameTypes.get(i).getKey())); } int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED; if (remaining > 0) { String plural = (remaining == 1) ? \"\" : \"s\"; sb.append(format(\"%n %d more binding%s with other annotations.\", remaining, plural)); } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type.toString(); Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings(); for (Key<?> bindingKey : bindingMap.keySet()) { String have = bindingKey.getTypeLiteral().toString(); if (have.contains(want) || want.contains(have)) { Formatter fmt = new Formatter(); Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource()); String match = String.format(\"%s bound%s\", convert(bindingKey), fmt.toString()); possibleMatches.add(match); // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) { // Early exit if we have found more than we need. break; } } } if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) { sb.append(format(\"%n Did you mean?\")); for (String possibleMatch : possibleMatches) { sb.append(format(\"%n %s\", possibleMatch)); } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotation() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) { // We don't recommend using such simple types without annotations. sb.append(format(\"%nThe key seems very generic, did you forget an annotation?\")); } return addMessage(sb.toString()); } \nResponse:", "ground_truth": "Within guice's core, allow for better missing binding messages", "predict": " Generate the method-level comment for the following java Code. Code: <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look"}, {"ID": 364, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); RealMultibinder<T> result = new RealMultibinder<>(binder, key); binder.install(result); return result; } \nResponse:", "ground_truth": "Implementation of newSetBinder.", "predict": " public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); return new RealMultibinder<>(binder, key); } \n\n*/\n\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\n@Singleton\npublic class RealMultibinder<T> {\n  private final Provider<Binder> binder;\n  private final Key<T> key;\n\n  @Inject\n  RealMultibinder(Provider<Binder> binder, Key<T> key) {\n    this.binder = binder;\n    this.key = key;\n  }\n\n  public void bind(Class<? extends T> clazz) {\n    binder.get()."}, {"ID": 365, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<T> getKeyForNewItem() { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Key.get( bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\")); } \nResponse:", "ground_truth": "Adds a new entry to the set and returns the key for it.", "predict": " Response<T> getItem(Key<T> key) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key); } \nResp Response<T> getItem(Key<T> key, String name) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key, name); } \nResp Response<T> getItem(Key<T> key, String name, String description) { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Response.create(bindingSelection.getElementTypeLiteral(), key, name, description); } \nResp Response<T> getItem(Key<T> key, String name, String description, String shortDescription) { checkConfiguration(!bindingSelection.is"}, {"ID": 366, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Filter findNextFilter(HttpServletRequest request) { while (++index < filterDefinitions.length) { Filter filter = filterDefinitions[index].getFilterIfMatching(request); if (filter != null) { return filter; } } return null; } \nResponse:", "ground_truth": "Iterates over the remaining filter definitions. Returns the first applicable filter, or null if\nnone apply.", "predict": " Response filter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { return chain.doFilter(request, response); } \n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FilterChainTest implements Filter {\n\n\tprivate List<Filter> filters = new ArrayList<Filter>();\n\t\n\tpublic void init(FilterConfig filterConfig)"}, {"ID": 367, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasAtInject(Constructor cxtor) { return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class); } \nResponse:", "ground_truth": "Returns true if the inject annotation is on the constructor.", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\n\n@Component\npublic class MethodInjector {\n\n\tprivate Map<Method, List<Injector>> injectors = Maps.newHashMap();\n\n\tpublic void addInjector(Method method, Injector injector) {\n\t\tList<Injector> list = injectors.get(method);\n\t\tif (list == null) {\n\t\t\tlist = new ArrayList<Injector>();\n\t\t\tinjectors"}, {"ID": 368, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: InjectionPoint getInternalConstructor() { if (factory.constructorInjector != null) { return factory.constructorInjector.getConstructionProxy().getInjectionPoint(); } else { return constructorInjectionPoint; } } \nResponse:", "ground_truth": "Returns an injection point that can be used to clean up the constructor store.", "predict": " Response getInternalConstructor() { return factory.constructorInjector.getConstructionProxy().getResponse(); } \n\n*/\n\npublic class ConstructorInjectionPoint extends InjectionPoint {\n\t\n\tprivate ConstructorInjectionPoint(Constructor<?> constructor, Type type, AnnotatedType<Constructor> annotatedType) {\n\t\tsuper(constructor, type, annotatedType);\n\t}\n\t\n\tpublic static ConstructorInjectionPoint create(Constructor<?> constructor, Type type, AnnotatedType<Constructor> annotatedType) {\n\t\treturn new ConstructorInjectionPoint(constructor, type, annotatedType);\n\t}\n\t\n\tpublic Constructor<?> getConstructor() {\n\t\treturn (Constructor<?>) getMember();\n\t}\n\t\n\tpublic Response getResponse() {\n\t\treturn new Response(getConstructor());\n\t}\n\t\n\tpublic Response getResponse(Object[] args) {\n\t\treturn"}, {"ID": 369, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Set<Dependency<?>> getInternalDependencies() { ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder(); if (factory.constructorInjector == null) { builder.add(constructorInjectionPoint); // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder.addAll( InjectionPoint.forInstanceMethodsAndFields( constructorInjectionPoint.getDeclaringType())); } catch (ConfigurationException ignored) { } } else { builder.add(getConstructor()).addAll(getInjectableMembers()); } return Dependency.forInjectionPoints(builder.build()); } \nResponse:", "ground_truth": "Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.", "predict": " Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response.withEntity(getInternalDependencies()); } \nResp Response<Set<Dependency<?>>> getInternalDependencies() { return Response"}, {"ID": 370, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) { return forObject(module, false, scanner); } \nResponse:", "ground_truth": "Returns a module which creates bindings methods in the module that match the scanner.", "predict": "\n\n*/\n\npublic class ModuleAnnotatedMethodScanner extends AnnotatedMethodScanner {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ModuleAnnotatedMethodScanner.class);\n\n    private final ModuleScanner scanner;\n\n    public ModuleAnnotatedMethodScanner(ModuleScanner scanner) {\n        this.scanner = scanner;\n    }\n\n    @Override\n    public void scan(Object module, AnnotatedMethodScannerContext context) {\n        if (module instanceof Module) {\n            scanModule((Module) module, context);\n        } else if (module instanceof ModuleIdentifier) {\n            scanModule((ModuleIdentifier) module, context);\n        } else {\n            LOGGER.warn(\"Unsupported module type: {}\", module.getClass().getName());\n        }\n    }\n\n    private void scanModule(ModuleIdentifier module, AnnotatedMethodScannerContext context) {\n        "}, {"ID": 371, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; } \nResponse:", "ground_truth": "Returns the annotation that is claimed by the scanner, or null if there is none.", "predict": " private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; } \n */\n\npublic class AnnotationScanner {\n    private final List<Class<? extends Annotation>> annotationClasses;\n\n    public AnnotationScanner(List<Class<? extends Annotation>> annotationClasses) {\n        this.annotationClasses = annotationClasses;\n    }\n\n    public List<"}, {"ID": 372, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Integer getLineNumber(Member member) { Preconditions.checkArgument( type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type); return lines.get(memberKey(member)); } \nResponse:", "ground_truth": "Get the line number associated with the given member.\n\n@param member a field, constructor, or method belonging to the class used during construction\n@return the wrapped line number, or null if not available\n@throws IllegalArgumentException if the member does not belong to the class used during\nconstruction", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class LineNumberGenerator {\n    private final Map<String, Integer> lines = new TreeMap<>();\n\n    public LineNumberGenerator(Class<?> type) {\n        for (Method method : type.getMethods()) {\n            lines.put(methodKey(method), method.getAnnotation(LineNumber.class).value());\n        }\n    }\n\n    public int getLineNumber(Member member) {\n        Preconditions.checkArgument(member.getDeclaringClass() == type, \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type);\n        return lines.get(methodKey(member));\n    }\n\n    private String methodKey(Member member) {\n        return member.getDeclaringClass().getName"}, {"ID": 373, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void initialize(Errors errors) { injector.lookups = injector; new LookupProcessor(errors).process(injector, lookups); } \nResponse:", "ground_truth": "Initialize the specified lookups, either immediately or when the injector is created.", "predict": " Response.ok().build();\n */\n\npublic class LookupProcessor extends AbstractProcessor {\n\n    private final Errors errors;\n\n    public LookupProcessor(Errors errors) {\n        this.errors = errors;\n    }\n\n    @Override\n    public void process(RequestContext context) {\n        final String lookupName = context.getPathTokens().get(1);\n        final Lookup lookup = context.getLookup(lookupName);\n        if (lookup == null) {\n            throw new NotFoundException(errors.getErrorMessage(ErrorCode.LOOKUP_NOT_FOUND, lookupName));\n        }\n        context.setLookup(lookupName, lookup);\n    }\n}\n"}, {"ID": 374, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"continues\" the HTTP request in another\nthread. This acts as a way of transporting request context data from the request processing\nthread to to worker threads.\n\nThere are some limitations:\n\n\nDerived objects (i.e. anything marked @RequestScoped will not be transported.\nState changes to the HttpServletRequest after this method is called will not be seen in the\ncontinued thread.\nOnly the HttpServletRequest, ServletContext and request parameter map are available in the\ncontinued thread. The response and session are not available.\n\nThe returned callable will throw a {@link ScopingException} when called if the HTTP request\nscope is still active on the current thread.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@param seedMap the initial set of scoped instances for Guice to seed the request scope with. To\nseed a key with null, use {@code null} as the value.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 3.0\n@deprecated You probably want to use {@code transferRequest} instead", "predict": " @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); } \n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Pre"}, {"ID": 375, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"transfers\" the request to another\nthread. This acts as a way of transporting request context data from the current thread to a\nfuture thread.\n\nAs opposed to {@link #continueRequest}, this method propagates all existing scoped objects.\nThe primary use case is in server implementations where you can detach the request processing\nthread while waiting for data, and reattach to a different thread to finish processing at a\nlater time.\n\nBecause request-scoped objects are not typically thread-safe, the callable returned by this\nmethod must not be run on a different thread until the current request scope has terminated.\nThe returned callable will block until the current thread has released the request scope.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 4.0", "predict": " public static <T> Response<T> transferRequest(Response<T> response) { return wrap(response, transferRequest()); } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport"}, {"ID": 376, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; } \nResponse:", "ground_truth": "Validates the key and object, ensuring the value matches the key type, and canonicalizing null\nobjects to the null sentinel.", "predict": " public static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; } \n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentHashMap<>();\n        map.put(\"a\", \"b\");\n        map.put(\"c\", \"d\");\n        map.put(\"e\", \"f\");\n        map.put(\"g\", \"h"}, {"ID": 377, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") // the MembersInjector type always agrees with the passed type public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException { return (MembersInjectorImpl<T>) cache.get(key, errors); } \nResponse:", "ground_truth": "Returns a new complete members injector with injection listeners registered.", "predict": "\n\npublic class MembersInjectorImpl<T> implements MembersInjector<T> {\n    private final TypeLiteral<T> typeLiteral;\n    private final MembersInjectionComponentAdapter<T> adapter;\n    private final ImmutableList<MembersInjectionComponentAdapter<? super T>> delegates;\n\n    public MembersInjectorImpl(TypeLiteral<T> typeLiteral, MembersInjectionComponentAdapter<T> adapter, ImmutableList<MembersInjectionComponentAdapter<? super T>> delegates) {\n        this.typeLiteral = typeLiteral;\n        this.adapter = adapter;\n        this.delegates = delegates;\n    }\n\n    public void injectMembers(T instance) {\n        adapter.inject(instance, typeLiteral);\n        for (MembersInjectionComponentAdapter<? super T> delegate : delegates) {\n            delegate.inject(instance, typeLiteral);\n        }\n    "}, {"ID": 378, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Set<InjectionPoint> injectionPoints; try { injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type); } catch (ConfigurationException e) { errors.merge(e.getErrorMessages()); injectionPoints = e.getPartialValue(); } ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors); errors.throwIfNewErrors(numErrorsBefore); EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups); Set<TypeListener> alreadySeenListeners = Sets.newHashSet(); for (TypeListenerBinding binding : typeListenerBindings) { TypeListener typeListener = binding.getListener(); if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) { alreadySeenListeners.add(typeListener); try { typeListener.hear(type, encounter); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } encounter.invalidate(); errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(injector, type, encounter, injectors); } \nResponse:", "ground_truth": "Creates a new members injector and attaches both injection listeners and method aspects.", "predict": " private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors, Set<TypeListener> listeners) throws ErrorsException { int numErrorsBefore = errors.size(); ImmutableList.Builder<SingleMemberInjector> builder = ImmutableList.builder(); for (TypeListenerBinding binding : typeListenerBindings) { if (listeners.contains(binding.getListener())) { try { binding.getListener().hear(type, new EncounterImpl<>(errors, binding.getInjector().lookups)); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(binding.getInjector(), type, new EncounterImpl<>(errors, binding.getInjector().lookups), builder.build()); } \n}\n"}, {"ID": 379, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); } \nResponse:", "ground_truth": "Returns the injectors for the specified injection points.", "predict": " ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); } \n\n}\n"}, {"ID": 380, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); } \nResponse:", "ground_truth": "Gets a key for an injection type and an annotation strategy.", "predict": " Response<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Response<T>(type, annotationStrategy); } \n\n*/\n\npublic class KeyGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); } \n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Response<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Response<T>(type, annotationStrategy); } \n\t\t\n\t\t// Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, Annotation"}, {"ID": 381, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Annotation annotation) { checkNotNull(annotation, \"annotation\"); Class<? extends Annotation> annotationType = annotation.annotationType(); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); if (Annotations.isMarker(annotationType)) { return new AnnotationTypeStrategy(annotationType, annotation); } return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation)); } \nResponse:", "ground_truth": "Gets the strategy for an annotation.", "predict": " Response<T> get(Request request) { return strategyFor(request.annotation()).get(request); } \nResp Response<T> post(Request request) { return strategyFor(request.annotation()).post(request); } \nResp Response<T> put(Request request) { return strategyFor(request.annotation()).put(request); } \nResp Response<T> delete(Request request) { return strategyFor(request.annotation()).delete(request); } \nResp Response<T> head(Request request) { return strategyFor(request.annotation()).head(request); } \nResp Response<T> options(Request request) { return strategyFor(request.annotation()).options(request); } \nResp Response<T> trace(Request request) { return strategyFor(request.annotation()).trace(request); } \nResp Response<T> patch(Request request) { return strategyFor"}, {"ID": 382, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, null); } \nResponse:", "ground_truth": "Gets the strategy for an annotation type.", "predict": " static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType, Annotation annotation) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType, annotation)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, annotation); } \nResp static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType, Annotation[] annotations) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType, annotations)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation("}, {"ID": 383, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pruneStacktrace(Throwable throwable) { for (Throwable t = throwable; t != null; t = t.getCause()) { StackTraceElement[] stackTrace = t.getStackTrace(); List<StackTraceElement> pruned = Lists.newArrayList(); for (StackTraceElement element : stackTrace) { String className = element.getClassName(); if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) { pruned.add(element); } } t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()])); } } \nResponse:", "ground_truth": "Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace\nand any causes it may have.", "predict": "\n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Compar"}, {"ID": 384, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getBindingSource() { if (source instanceof Class) { return StackTraceElements.forType((Class) source).toString(); } else if (source instanceof Member) { return StackTraceElements.forMember((Member) source).toString(); } else { return source.toString(); } } \nResponse:", "ground_truth": "Returns a string describing where this dependency was bound. If the binding was just-in-time,\nthere is no valid binding source, so this describes the class in question.", "predict": "\n\n*/\n\npublic class BindingSource {\n\t\n\tpublic static String getBindingSource(Object source) {\n\t\tif (source instanceof Class) {\n\t\t\treturn StackTraceElements.forType((Class) source).toString();\n\t\t} else if (source instanceof Member) {\n\t\t\treturn StackTraceElements.forMember((Member) source).toString();\n\t\t} else {\n\t\t\treturn source.toString();\n\t\t}\n\t}\n}\n"}, {"ID": 385, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause); if (!causes.containsKey(causeEquivalence)) { causes.put(causeEquivalence, thisIdx); fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause)); } else { int causeIdx = causes.get(causeEquivalence); fmt.format( \"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx); } } fmt.format(\"%n\"); } if (errorMessages.size() == 1) { fmt.format(\"1 error\"); } else { fmt.format(\"%s errors\", errorMessages.size()); } return fmt.toString(); } \nResponse:", "ground_truth": "Returns the formatted message for an exception with the specified messages.", "predict": " public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE"}, {"ID": 386, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message without a cause.\n\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Resp public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); } \n\n*/\n\npublic class Message {\n\tprivate String messageFormat;\n\tprivate Object[] arguments;\n\t\n\tpublic Message(String messageFormat, Object... arguments) {\n\t\tthis.messageFormat = messageFormat;\n\t\tthis.arguments = arguments;\n\t}\n\t\n\tpublic String getMessageFormat() {\n\t\treturn messageFormat;\n\t}\n\t\n\tpublic Object[] getArguments() {\n\t\treturn arguments;\n\t}\n\t\n\tpublic static Message create(String messageFormat, Object... arguments) {\n\t\treturn new Message(messageFormat, arguments);\n\t}\n}\n"}, {"ID": 387, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(Throwable cause, String messageFormat, Object... arguments) { return create(cause, ImmutableList.of(), messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message with the given cause.\n\n@param cause The exception that caused the error\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Response.create(cause, ImmutableList.of(), messageFormat, arguments);\n\n*/\n\npublic class Response {\n    private final Throwable cause;\n    private final ImmutableList<Object> arguments;\n    private final String messageFormat;\n\n    public Response(Throwable cause, ImmutableList<Object> arguments, String messageFormat) {\n        this.cause = cause;\n        this.arguments = arguments;\n        this.messageFormat = messageFormat;\n    }\n\n    public static Response create(Throwable cause, ImmutableList<Object> arguments, String messageFormat, Object... arguments) {\n        return new Response(cause, arguments, messageFormat);\n    }\n\n    public Throwable getCause() {\n        return cause;\n    }\n\n    public ImmutableList<Object> getArguments() {\n        return arguments;\n    }\n\n    public String getMessageFormat() {\n        return messageFormat;\n    }\n}\n"}, {"ID": 388, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Message(sources, message, cause); } \nResponse:", "ground_truth": "Creates a new Message with the given cause and a binding source stack.\n\n@param cause The exception that caused the error\n@param sources The binding sources for the source stack\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Response is generated by the following java Code. Code: public static Response create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Response(sources, message, cause); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MessageFormat {\n\n    private static final String MESSAGE_PATTERN = \"\\\\{\\\\{(.*?)\\\\}\\\\}\";\n    private static final Pattern MESSAGE_PATTERN_PATTERN = Pattern.compile(MESSAGE_PATTERN);\n\n    private static final String MESSAGE_FORMAT_PATTERN = \"\\\\{\\\\{(.*?)\\\\"}, {"ID": 389, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object convert(Object o) { ElementSource source = null; if (o instanceof ElementSource) { source = (ElementSource) o; o = source.getDeclaringSource(); } return convert(o, source); } \nResponse:", "ground_truth": "Formats an object in a user friendly way.", "predict": " Response is generated by the method convert(Object o, ElementSource source)\n\n*/\n\npublic class Convert {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 390, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean shouldBeSkipped(String className) { return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className); } \nResponse:", "ground_truth": "Returns true if the className should be skipped.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ClassNameFilter {\n    private List<String> classNamesToSkip = new ArrayList<>();\n\n    public ClassNameFilter(String[] classNamesToSkip) {\n        for (String className : classNamesToSkip) {\n            this.classNamesToSkip.add(className);\n        }\n    }\n\n    public boolean shouldBeSkipped(String className) {\n        return classNamesToSkip.contains(className);\n    }\n}\n"}, {"ID": 391, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; } \nResponse:", "ground_truth": "Returns the non-skipped module class name.", "predict": " public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Predicate"}, {"ID": 392, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\"); System.err.println(\"Then run 'jconsole' to connect.\"); System.exit(1); } Module module = (Module) Class.forName(args[0]).newInstance(); Injector injector = Guice.createInjector(module); manage(args[0], injector); System.out.println(\"Press Ctrl+C to exit...\"); // Sleep forever. Thread.sleep(Long.MAX_VALUE); } \nResponse:", "ground_truth": "Run with no arguments for usage instructions.", "predict": "\n\n*/\n\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.servlet.GuiceServletContextListener;\nimport com.google.inject.servlet.ServletModule;\nimport com.sun.management.jmxremote.JMXServiceURL;\nimport com.sun.management.jmxremote.LocalConnectorServer;\nimport com.sun.management.jmxremote.NotificationListener;\nimport com.sun.management.jmxremote.NotificationListenerMBean;\nimport com.sun.management.jmxremote.NotificationSupport;\nimport com.sun.management.jmxremote.remote.JMXConnectorServer;\nimport com.sun.management.jmxremote.remote.JMXConnectorServerFactory;\nimport com.sun.management.jmxremote.remote.JMXServiceURL;\nimport com.sun.management.jmxremote"}, {"ID": 393, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Dependency<?> pushDependency(Dependency<?> dependency, Object source) { Dependency<?> previous = this.dependency; this.dependency = dependency; doPushState(dependency, source); return previous; } \nResponse:", "ground_truth": "Sets the new current dependency & adds it to the state.", "predict": " void pushState(Object source) { doPushState(null, source); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source, Object... params) { doPushState(null, source, params); } \nResp void pushState(Object source"}, {"ID": 394, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); } \nResponse:", "ground_truth": "Adds to the state without setting the dependency.", "predict": " void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); } \n\n*/\n\npublic class PushState {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n"}, {"ID": 395, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Initializable<T> of(final T instance) { return new Initializable<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; } \nResponse:", "ground_truth": "Returns an initializable for an instance that requires no initialization.", "predict": " Response<T> of(final T instance) { return new Response<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; } \n\n*/\n\npublic class Initializable<T> {\n\tprivate T instance;\n\t\n\tpublic Initializable(T instance) {\n\t\tthis.instance = instance;\n\t}\n\t\n\tpublic T get() {\n\t\treturn instance;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn String.valueOf(instance);\n\t}\n}\n\n/*\n\npublic class Response<T> {\n\tprivate T instance;\n\t\n\tpublic Response(T instance) {\n\t\tthis.instance = instance;\n\t}\n\t\n\tpublic T get() {\n\t\treturn instance;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn String.valueOf(instance);\n\t}\n}"}, {"ID": 396, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T provision( Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { T t = provider.get(); if (t == null && !dependency.isNullable()) { InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency); } constructionContext.setProxyDelegates(t); return t; } \nResponse:", "ground_truth": "Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as\nErrorsExceptions.", "predict": " Response<T> provision(Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { return Response.from(provider.get()); } \n\n*/\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.jboss.weld.environment.se.Weld;\nimport org.jboss.weld.environment.se.WeldContainer;\nimport org.junit.Test;\n\nimport com.google.common.base.Optional;\n\npublic class TestProvisioning {\n\n\t@Test\n\tpublic void testProvisioning() {\n\t\tWeld weld = new Weld();\n\t\tWeldContainer container ="}, {"ID": 397, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } } \nResponse:", "ground_truth": "Dispatch events.\n\n@param type\n@param remoteAddr\n@param conn", "predict": " Response is generated by the following java Code. Code: public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ConnectionEventProcessor {\n\t\n\tprivate List<ConnectionEventProcessor> processors;\n\t\n\tpublic ConnectionEventProcessor() {\n\t\tprocessors = new ArrayList<ConnectionEventProcessor>();\n\t}\n\t\n\tpublic void addProcessor(ConnectionEventProcessor processor) {\n\t\tprocessors.add(processor);\n\t}\n\t\n\tpublic void onEvent(String remoteAddr, Connection conn) {\n\t\tfor (ConnectionEventProcessor processor : processors)"}, {"ID": 398, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList == null) { this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1)); processorList = this.processors.get(type); } processorList.add(processor); } \nResponse:", "ground_truth": "Add event processor.\n\n@param type\n@param processor", "predict": " void\n*/\n\npublic class ConnectionEventProcessor {\n\tprivate ConnectionEventType type;\n\tprivate ConnectionEventProcessor processor;\n\t\n\tpublic ConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) {\n\t\tthis.type = type;\n\t\tthis.processor = processor;\n\t}\n\t\n\tpublic ConnectionEventType getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic ConnectionEventProcessor getProcessor() {\n\t\treturn processor;\n\t}\n}\n"}, {"ID": 399, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) { T t = null; if (null != task) { try { t = task.getAfterRun(); } catch (InterruptedException e) { logger.error(\"Future task interrupted!\", e); } catch (ExecutionException e) { logger.error(\"Future task execute failed!\", e); } catch (FutureTaskNotRunYetException e) { logger.error(\"Future task has not run yet!\", e); } catch (FutureTaskNotCompleted e) { logger.error(\"Future task has not completed!\", e); } } return t; } \nResponse:", "ground_truth": "get the result of a future task\n\nNotice: the run method of this task should have been called at first.\n\n@param task\n@param \n@return", "predict": "\n\n*/\n\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class FutureTaskTest {\n    public static void main(String[] args) {\n        RunStateRecordedFutureTask<String> task = new RunStateRecordedFutureTask<String>(\"Hello World\");\n        System.out.println(task.getAfterRun());\n        System.out.println(task.getState());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecorded());\n        System.out.println(task.getStateRecord"}, {"ID": 400, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void launderThrowable(Throwable t) { if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new IllegalStateException(\"Not unchecked!\", t); } } \nResponse:", "ground_truth": "launder the throwable\n\n@param t", "predict": "\n\npublic static void launderThrowable(Throwable t) {\n    if (t instanceof RuntimeException) {\n        throw (RuntimeException) t;\n    } else if (t instanceof Error) {\n        throw (Error) t;\n    } else {\n        throw new IllegalStateException(\"Not unchecked!\", t);\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LaunderThrowable {\n\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<String>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n"}, {"ID": 401, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); } \nResponse:", "ground_truth": "Register processor to process command that has the command code of cmdCode.\n\n@param cmdCode\n@param processor", "predict": " public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); } \n\n*/\n\npublic class CommandProcessorRegistry {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(CommandProcessorRegistry.class);\n\t\n\tprivate Map<CommandCode, RemotingProcessor<?>> cmd2processors = new HashMap<CommandCode, RemotingProcessor<?>>();\n\t\n\tpublic void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) {\n\t\tif (this.cmd2processors"}, {"ID": 402, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerDefaultProcessor(RemotingProcessor<?> processor) { if (this.defaultProcessor == null) { this.defaultProcessor = processor; } else { throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass()); } } \nResponse:", "ground_truth": "Register the default processor to process command with no specific processor registered.\n\n@param processor", "predict": " public void registerProcessor(RemotingProcessor<?> processor) { if (this.processors.containsKey(processor.getClass())) { throw new IllegalStateException(\"The processor has already been registered: \" + processor.getClass()); } this.processors.put(processor.getClass(), processor); } \nResp public void unregisterProcessor(RemotingProcessor<?> processor) { this.processors.remove(processor.getClass()); } \nResp public void unregisterDefaultProcessor(RemotingProcessor<?> processor) { this.defaultProcessor = null; } \nResp public void unregisterAllProcessors() { this.processors.clear(); } \nResp public void setDefaultProcessor(RemotingProcessor<?> processor) { this.defaultProcessor = processor; } \nResp public RemotingProcessor<?> getDefaultProcessor() { return this.defaultProcessor; } \nResp public RemotingProcessor"}, {"ID": 403, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RemotingProcessor<?> getProcessor(CommandCode cmdCode) { RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode); if (processor != null) { return processor; } return this.defaultProcessor; } \nResponse:", "ground_truth": "Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.\n\n@param cmdCode\n@return", "predict": " public Response<?> process(CommandCode cmdCode, Object... args) { Response<?> response = this.cmd2responses.get(cmdCode); if (response != null) { return response; } return this.defaultResponse; } \n\n*/\n\npublic class CommandProcessor {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(CommandProcessor.class);\n\t\n\tprivate static final String DEFAULT_COMMAND_PROCESSOR_CLASS = \"org.apache.commons.lang3.mutable.MutableInt\";\n\tprivate static final String DEFAULT_RESPONSE_PROCESSOR_CLASS = \"org.apache.commons.lang3.mutable.MutableInt\";\n\t\n\tprivate static final String DEFAULT_COMMAND_PROCESSOR_CLASS_NAME = \"org.apache.commons.lang3.mutable.MutableInt\";\n\tprivate static final String DE"}, {"ID": 404, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); } \nResponse:", "ground_truth": "try get from cache\n\n@param url\n@return", "predict": " private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.tryGet(\"http://www.google.com/\"));\n    }\n    \n    public Url tryGet(String url) {\n        return Url.parsedUrls.get(url);\n    }\n}\n\nclass Url {\n    public static HashMap<String, SoftReference<Url>> parsedUrls = new HashMap<String, SoftReference<Url>>();\n    \n    public static void addUrl(String url, Url parsedUrl) {\n        parsedUrls.put(url, new SoftReference<Url>(parsedUrl));"}, {"ID": 405, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ProtocolCode decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; } \nResponse:", "ground_truth": "decode the protocol code\n\n@param in input byte buf\n@return an instance of ProtocolCode", "predict": " Generate the method-level comment for the following java Code. Code: public void encodeProtocolCode(ByteBuf out, ProtocolCode protocolCode) { if (protocolCode != null) { out.writeBytes(protocolCode.toBytes()); } } \nResp Generate the method-level comment for the following java Code. Code: public void decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; } \n */\n\npublic class ProtocolCode {\n    public static final int protocolCodeLength = 1;\n    public static final byte PROTOCOL_CODE_RESPONSE = 0x00;\n    public static final byte PROTOCOL_CODE_REQUEST = 0x01;\n    public static final byte PROTOCOL_"}, {"ID": 406, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> getAll() { Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>(); Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this .getConnPools().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); if (null != pool) { allConnections.put(entry.getKey(), pool.getAll()); } } return allConnections; } \nResponse:", "ground_truth": "Get all connections of all poolKey.\n\n@return a map with poolKey as key and a list of connections in ConnectionPool as value", "predict": " Response = Response.ok().entity(allConnections).build();\n\n*/\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.ListenableScheduledFuture;\nimport com.google.common.util.concurrent.ListeningScheduledExecutorService;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.common.util.concurrent.SettableFuture;\n\npublic class ConnectionPool {\n\tprivate static final Logger logger = Logger.getLogger(ConnectionPool.class);\n\tprivate static final ListeningScheduledExecutorService executor"}, {"ID": 407, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void scan() { if (null != this.connTasks && !this.connTasks.isEmpty()) { Iterator<String> iter = this.connTasks.keySet().iterator(); while (iter.hasNext()) { String poolKey = iter.next(); ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey)); if (null != pool) { pool.scan(); if (pool.isEmpty()) { if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) { iter.remove(); logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey); } } } } } } \nResponse:", "ground_truth": "in case of cache pollution and connection leak, to do schedule scan\n\n@see com.alipay.remoting.Scannable#scan()", "predict": "\n\n*/\n\npackage com.taobao.tddl.dbsync.binlog.event;\n\nimport com.taobao.tddl.dbsync.binlog.LogBuffer;\n\n/**\n * @author <a href=\"mailto:changyuan.lh@taobao.com\">Changyuan.lh</a>\n * @version 1.0\n */\npublic final class QueryLogHeader extends LogHeader {\n\n    public QueryLogHeader(LogHeader header) {\n        super(header);\n    }\n\n    public QueryLogHeader(LogBuffer buffer) {\n        super(buffer);\n    }\n\n    @Override\n    public final LogHeaderType getHeaderType() {\n        return LogHeaderType.QUERY_EVENT;\n    }\n\n}\n"}, {"ID": 408, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\n\n@see ConnectionManager#getAndCreateIfAbsent(Url)", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss.netty.channel.socket"}, {"ID": 409, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\nIf task cached, check whether the number of connections adequate, if not then heal it.\n\n@param url\n@return\n@throws InterruptedException\n@throws RemotingException", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss.netty.channel.socket"}, {"ID": 410, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeTask(String poolKey) { RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey); if (null != task) { ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger); if (null != pool) { pool.removeAllAndTryClose(); } } } \nResponse:", "ground_truth": "remove task and remove all connections\n\n@param poolKey", "predict": " void\n*/\n\npublic class RemoveTask implements Runnable {\n    private final String poolKey;\n    private final Logger logger;\n\n    public RemoveTask(String poolKey, Logger logger) {\n        this.poolKey = poolKey;\n        this.logger = logger;\n    }\n\n    @Override\n    public void run() {\n        try {\n            removeTask(poolKey);\n        } catch (Exception e) {\n            logger.error(\"Failed to remove task for poolKey: \" + poolKey, e);\n        }\n    }\n}\n"}, {"ID": 411, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException { String poolKey = url.getUniqueKey(); // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) { FutureTask<Integer> task = this.healTasks.get(poolKey); if (null == task) { task = new FutureTask<Integer>(new HealConnectionCall(url, pool)); task = this.healTasks.putIfAbsent(poolKey, task); if (null == task) { task = this.healTasks.get(poolKey); task.run(); } } try { int numAfterHeal = task.get(); if (logger.isDebugEnabled()) { logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup()); } } catch (InterruptedException e) { this.healTasks.remove(poolKey); throw e; } catch (ExecutionException e) { this.healTasks.remove(poolKey); Throwable cause = e.getCause(); if (cause instanceof RemotingException) { throw (RemotingException) cause; } else { FutureTaskUtil.launderThrowable(cause); } } // heal task is one-off, remove from cache directly after run this.healTasks.remove(poolKey); } } \nResponse:", "ground_truth": "execute heal connection tasks if the actual number of connections in pool is less than expected\n\n@param pool\n@param url", "predict": "\npublic class Response {\npublic static final int SUCCESS = 0;\npublic static final int FAILURE = 1;\npublic static final int RETRY = 2;\npublic static final int RETRY_IMMEDIATELY = 3;\npublic static final int RETRY_IN_TIME = 4;\npublic static final int RETRY_IN_TIMEOUT = 5;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY = 6;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IMMEDIATELY = 7;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIME = 8;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIMEOUT = 9;\npublic static final int RETRY_IN_TIMEOUT_AND_RETRY_IN_TIMEOUT_AND_RETRY = 10;\npublic static final int RETRY_IN"}, {"ID": 412, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException { final int actualNum = pool.size(); final int expectNum = url.getConnNum(); if (actualNum < expectNum) { if (logger.isDebugEnabled()) { logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName); } if (url.isConnWarmup()) { for (int i = actualNum; i < expectNum; ++i) { Connection connection = create(url); pool.add(connection); } } else { if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) { throw new IllegalArgumentException( \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\"); } // create connection in sync way if (syncCreateNumWhenNotWarmup > 0) { for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) { Connection connection = create(url); pool.add(connection); } if (syncCreateNumWhenNotWarmup == url.getConnNum()) { return; } } // initialize executor in lazy way initializeExecutor(); pool.markAsyncCreationStart();// mark the start of async try { this.asyncCreateConnectionExecutor.execute(new Runnable() { @Override public void run() { try { for (int i = pool.size(); i < url.getConnNum(); ++i) { Connection conn = null; try { conn = create(url); } catch (RemotingException e) { logger .error( \"Exception occurred in async create connection thread for {}, taskName {}\", url.getUniqueKey(), taskName, e); } pool.add(conn); } } finally { pool.markAsyncCreationDone();// mark the end of async } } }); } catch (RejectedExecutionException e) { pool.markAsyncCreationDone();// mark the end of async when reject throw e; } } // end of NOT warm up } // end of if } \nResponse:", "ground_truth": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport com.alibaba.dubbo.common.URL;\nimport com.alibaba.dubbo.remoting.Channel;\nimport com.alibaba.dubbo.remoting.ChannelHandler;\nimport com.alibaba.dubbo.remoting.RemotingException;\nimport com.alibaba.dubbo.remoting.transport.AbstractClient;\n\nimport org.jboss.netty.channel.ChannelFactory;\nimport org.jboss.netty.channel.ChannelPipeline;\nimport org.jboss.netty.channel.ChannelPipelineFactory;\nimport org.jboss.netty.channel.Channels;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n\nimport java.net.InetSocketAddress;\nimport java"}, {"ID": 413, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void closeConnection(String addr) { Url url = this.addressParser.parse(addr); this.connectionManager.remove(url.getUniqueKey()); } \nResponse:", "ground_truth": "Close all connections of a address\n\n@param addr", "predict": " Response = this.connectionManager.get(url.getUniqueKey()); \n\n*/\n\npublic class ConnectionManager {\n\tprivate static final Logger logger = Logger.getLogger(ConnectionManager.class);\n\tprivate static final String CONNECTION_MANAGER_NAME = \"ConnectionManager\";\n\tprivate static final String CONNECTION_MANAGER_DESCRIPTION = \"Manages the connections to the database\";\n\tprivate static final String CONNECTION_MANAGER_VERSION = \"1.0\";\n\tprivate static final String CONNECTION_MANAGER_AUTHOR = \"Saravanan R\";\n\tprivate static final String CONNECTION_MANAGER_EMAIL = \"saravanan.r@gmail.com\";\n\tprivate static final String CONNECTION_MANAGER_WEBSITE = \"http://www.saravanan.in\";\n\tprivate static final String CONNECTION_MANAGER_LICENSE ="}, {"ID": 414, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } } \nResponse:", "ground_truth": "Do something when closing.", "predict": " public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } } \n\n*/\n"}, {"ID": 415, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } } \nResponse:", "ground_truth": "Close the connection.", "predict": "\npublic void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } } \n\n*/\n"}, {"ID": 416, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); } \nResponse:", "ground_truth": "set attribute if key absent.\n\n@param key\n@param value\n@return", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 417, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (processor instanceof MultiInterestUserProcessor) { registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors); } else { if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register single-interest user processor.\n\n@param processor  the processor need to be registered\n@param userProcessors   the map of user processors", "predict": " public static void registerUserProcessor(MultiInterestUserProcessor processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } \n\n*/\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.thrift.TException;\nimport org.apache.thrift"}, {"ID": 418, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) { throw new RuntimeException(\"Processor interest should not be blank!\"); } for (String interest : processor.multiInterest()) { UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register multi-interest user processor.\n\n@param processor  the processor with multi-interest need to be registered\n@param userProcessors    the map of user processors", "predict": "\n\n*/\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TFramedTransport;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\n\nimport com.twitter.heron.api.generated.TopologyAPI;\nimport com.twitter.heron.api.utils.TopologyUtils;\nimport com.twitter.heron.common.basics.ByteAmount;\nimport com.twitter.heron.common.basics.SysUtils;"}, {"ID": 419, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) { final int id = cmd.getId(); final byte type = cmd.getType(); // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass()); if (processor instanceof AsyncUserProcessor) { try { processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject()); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } else { try { Object responseObject = processor .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), cmd.getRequestObject()); sendResponseIfNecessary(ctx, type, this.getCommandFactory().createResponse(responseObject, cmd)); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } } \nResponse:", "ground_truth": "dispatch request command to user processor\n@param ctx remoting context\n@param cmd rpc request command", "predict": "\n\n*/\n\npublic class RpcRequestProcessor implements AsyncProcessor<RpcRequestCommand, RpcResponseCommand> {\n\n    private static final Logger logger = LoggerFactory.getLogger(RpcRequestProcessor.class);\n\n    private final RpcCommandFactory commandFactory;\n\n    private final AsyncProcessor<RpcRequestCommand, RpcResponseCommand> processor;\n\n    public RpcRequestProcessor(RpcCommandFactory commandFactory, AsyncProcessor<RpcRequestCommand, RpcResponseCommand> processor) {\n        this.commandFactory = commandFactory;\n        this.processor = processor;\n    }\n\n    @Override\n    public RpcResponseCommand process(RpcRequestCommand request) throws Exception {\n        RpcResponseCommand response = null;\n        try {\n            response = processor.process(request);\n        } catch (Exception e) {\n            logger.error(\"process rpc request failed, request={}\", request, e"}, {"ID": 420, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) { boolean result; try { cmd.deserialize(level); result = true; } catch (DeserializationException e) { logger .error( \"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e)); result = false; } catch (Throwable t) { String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" + cmd.getId() + \", deserializeLevel=\" + level; logger.error(errMsg, t); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), t, errMsg)); result = false; } return result; } \nResponse:", "ground_truth": "deserialize request command\n\n@return true if deserialize success; false if exception catched", "predict": "\n    public static class Response {\n        private final RpcResponseCommand cmd;\n        private final RpcResponseStatus status;\n        private final String errMsg;\n        public Response(RpcResponseCommand cmd, RpcResponseStatus status, String errMsg) {\n            this.cmd = cmd;\n            this.status = status;\n            this.errMsg = errMsg;\n        }\n        public RpcResponseCommand getCmd() {\n            return cmd;\n        }\n        public RpcResponseStatus getStatus() {\n            return status;\n        }\n        public String getErrMsg() {\n            return errMsg;\n        }\n    }\n    public static class ResponseStatus {\n        public static final RpcResponseStatus SUCCESS = new RpcResponseStatus(0, \"Success\");\n        public static final RpcResponseStatus FAILURE = new RpcResponseStatus(1, \"Failure\");\n        public static final RpcResponseStatus SERVER_DESER"}, {"ID": 421, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); } \nResponse:", "ground_truth": "pre process remoting context, initial some useful infos and pass to biz\n\n@param ctx remoting context\n@param cmd rpc request command\n@param currentTimestamp current timestamp", "predict": " private void processRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); } \n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.j"}, {"ID": 422, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } \nResponse:", "ground_truth": "print some log when request timeout and discarded in io thread.", "predict": "\n    public void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{"}, {"ID": 423, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } } \nResponse:", "ground_truth": "print some debug log when receive request", "predict": " Generate the method-level comment for the following java Code. Code: private void debugLog(RemotingContext ctx, RpcResponseCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc response received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } } \n */\n\npublic class RpcRequestCommand extends RpcCommand {\n    private static final long serialVersionUID = -828379842290987908L;\n\n    private String methodName;\n    private Object[] args;\n    private long arriveTime;\n    private long timeout;\n\n    "}, {"ID": 424, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } } \nResponse:", "ground_truth": "Process the remoting command with its own executor or with the defaultExecutor if its own if null.\n\n@param ctx\n@param msg\n@param defaultExecutor\n@throws Exception", "predict": " Generate the method-level comment for the following java Code. Code: @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } } \n */\n\npublic class ProcessTask implements Runnable {\n\tprivate RemotingContext ctx;\n\tprivate Object msg;\n\tprivate ExecutorService defaultExecutor;\n\t\n\tpublic ProcessTask(RemotingContext ctx, Object msg) {\n\t\tthis.ctx = ctx;\n\t\tthis.msg = msg;\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tthis.ctx.getProcessor().process(this.ctx, this.msg);\n\t\t} catch (Exception e) {\n\t\t\tthis.ctx.getProcessor()."}, {"ID": 425, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), invokeCallback); conn.addInvokeFuture(future); final int requestId = request.getId(); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(requestId); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn .getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture cf) throws Exception { if (!cf.isSuccess()) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse( conn.getRemoteAddress(), cf.cause())); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause()); } } }); } catch (Exception e) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e)); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } \nResponse:", "ground_truth": "Invocation with callback.\n\n@param conn\n@param request\n@param invokeCallback\n@param timeoutMillis\n@throws InterruptedException", "predict": " public void invokeAsync(final Connection conn, final RemotingCommand request, final long timeoutMillis) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException, RemotingTooMuchRequestException, RemotingExecuteException { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), null); conn.addInvokeFuture(future); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(request.getId()); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn.getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFuture"}, {"ID": 426, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } } \nResponse:", "ground_truth": "Oneway invocation.\n\n@param conn\n@param request\n@throws InterruptedException", "predict": " public void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } } \n\n*/\n"}, {"ID": 427, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; } \nResponse:", "ground_truth": "from bit set to byte\n@param bs\n@return byte represent the bit set", "predict": "\n\npublic static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; } \n\n*/\n\nimport java.util.BitSet;\n\npublic class Solution {\n    public static byte toByte(BitSet bs) {\n        int value = 0;\n        for (int i = 0; i < bs.length(); ++i) {\n            if (bs.get(i)) {\n                value += 1 << i;\n            }\n        }\n"}, {"ID": 428, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; } \nResponse:", "ground_truth": "from byte to bit set\n@param value\n@return bit set represent the byte", "predict": "\n\npublic static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; } \n\n*/\n\nimport java.util.BitSet;\n\npublic class Solution {\n    public static BitSet toBitSet(int value) {\n        BitSet bs = new BitSet();\n        int index = 0;\n        while (value != 0) {\n            if (value % 2 != 0) {\n                bs.set("}, {"ID": 429, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); } \nResponse:", "ground_truth": "add reconnect task\n\n@param url", "predict": " public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); } \n\n*/\n\npublic class ReconnectTask extends Task {\n\tprivate Url url;\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\turl.reconnect();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void setUrl(Url url) {\n\t\tthis.url = url;\n\t}\n}\n"}, {"ID": 430, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop() { if (!this.started) { return; } this.started = false; healConnectionThreads.interrupt(); this.tasks.clear(); this.canceled.clear(); } \nResponse:", "ground_truth": "stop reconnect thread", "predict": "\n\n*/\n\npublic class Stop extends AbstractInstruction {\n\t\n\tpublic Stop(String name, String description) {\n\t\tsuper(name, description);\n\t}\n\t\n\t@Override\n\tpublic void execute(Context context) {\n\t\t\n\t\t// Get the connection\n\t\tConnection connection = context.getConnection();\n\t\t\n\t\t// Get the thread\n\t\tThread thread = context.getThread();\n\t\t\n\t\t// Get the task\n\t\tTask task = context.getTask();\n\t\t\n\t\t// Get the canceled\n\t\tSet<Task> canceled = context.getCanceled();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t// Get the started\n\t\tboolean started = context.getStarted();\n\t\t\n\t\t//"}, {"ID": 431, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException { RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request); if (null != invokeContext) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER); if (null != clientCustomSerializer) { try { command.setSerializer((Byte) clientCustomSerializer); } catch (ClassCastException e) { throw new IllegalArgumentException( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\"); } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE); if (null != crcSwitch && crcSwitch) { command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } } else { // enable crc by default, if there is no invoke context. command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } command.setTimeout(timeoutMillis); command.setRequestClass(request.getClass().getName()); command.setInvokeContext(invokeContext); command.serialize(); logDebugInfo(command); return command; } \nResponse:", "ground_truth": "Convert application request object to remoting request command.\n\n@param request\n@param conn\n@param timeoutMillis\n@return\n@throws CodecException", "predict": " public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, null); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object arg) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, new Object[] { arg }); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object[] args) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException { return this.invoke(request, invokeCallback, args, null); } \nResp public RemotingCommand invoke(RemotingCommand request, final InvokeCallback invokeCallback, final Object[] args, final Object arg) throws InterruptedException, Rem"}, {"ID": 432, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> filter(List<Connection> connections) { List<Connection> serviceOnConnections = new ArrayList<Connection>(); List<Connection> serviceOffConnections = new ArrayList<Connection>(); Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>(); for (Connection connection : connections) { String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS); if (serviceStatus != null) { if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) { serviceOffConnections.add(connection); } } else { serviceOnConnections.add(connection); } } filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections); filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections); return filteredConnections; } \nResponse:", "ground_truth": "Filter connections to monitor\n\n@param connections", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec."}, {"ID": 433, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) { try { if (null != connPools && !connPools.isEmpty()) { Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools .entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter .next(); String poolKey = entry.getKey(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); List<Connection> connections = pool.getAll(); Map<String, List<Connection>> filteredConnectons = this.filter(connections); List<Connection> serviceOnConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_ON); List<Connection> serviceOffConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_OFF); if (serviceOnConnections.size() > CONNECTION_THRESHOLD) { Connection freshSelectConnect = serviceOnConnections.get(random .nextInt(serviceOnConnections.size())); freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF); Connection lastSelectConnect = freshSelectConnections.remove(poolKey); freshSelectConnections.put(poolKey, freshSelectConnect); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } else { if (freshSelectConnections.containsKey(poolKey)) { Connection lastSelectConnect = freshSelectConnections.remove(poolKey); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } if (logger.isInfoEnabled()) { logger .info( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD); } } for (Connection offConn : serviceOffConnections) { if (offConn.isFine()) { offConn.close(); } } } } } catch (Exception e) { logger.error(\"ScheduledDisconnectStrategy monitor error\", e); } } \nResponse:", "ground_truth": "Monitor connections and close connections with status is off\n\n@param connPools", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel"}, {"ID": 434, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException { if (null != lastSelectConnect) { if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { Thread.sleep(RETRY_DETECT_PERIOD); if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { if (logger.isInfoEnabled()) { logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel())); } } } } } \nResponse:", "ground_truth": "close the connection of the fresh select connections\n\n@param lastSelectConnect\n@param serviceOffConnections\n@throws InterruptedException", "predict": "\n    public void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException {\n        if (null != lastSelectConnect) {\n            if (lastSelectConnect.isInvokeFutureMapFinish()) {\n                serviceOffConnections.add(lastSelectConnect);\n            } else {\n                Thread.sleep(RETRY_DETECT_PERIOD);\n                if (lastSelectConnect.isInvokeFutureMapFinish()) {\n                    serviceOffConnections.add(lastSelectConnect);\n                } else {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel()));\n                    }\n                }\n            }\n        }\n    }\n    \n    public void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws Interrupted"}, {"ID": 435, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean getBool(String key, String defaultValue) { return Boolean.parseBoolean(System.getProperty(key, defaultValue)); } \nResponse:", "ground_truth": "~~~ public helper methods to retrieve system property", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 436, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void infoLog(String format, String addr) { if (logger.isInfoEnabled()) { if (StringUtils.isNotEmpty(addr)) { logger.info(format, addr); } else { logger.info(format, \"UNKNOWN-ADDR\"); } } } \nResponse:", "ground_truth": "print info log\n@param format\n@param addr", "predict": "\n\n*/\n\npublic class Logger {\n    private static final String TAG = \"Logger\";\n    private static final String LOG_TAG = \"Logger\";\n    private static final String LOG_TAG_PREFIX = \"Logger\";\n    private static final String LOG_TAG_PREFIX_PREFIX = \"Logger_\";\n    private static final String LOG_TAG_PREFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX = \"Logger\";\n    private static final String LOG_TAG_POSTFIX_PREFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String LOG_TAG_POSTFIX_POSTFIX_POSTFIX_POSTFIX = \"Logger_\";\n    private static final String"}, {"ID": 437, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isRequestTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; } \nResponse:", "ground_truth": "whether this request already timeout\n\n@return", "predict": " public boolean isResponseTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.RESPONSE_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; } \n\n*/\n\npublic class RpcCommand {\n\t\n\tprivate RpcCommandType rpcCommandType;\n\tprivate String rpcCommand;\n\tprivate String rpcCommandArguments;\n\tprivate long arriveTimestamp;\n\tprivate long timeout;\n\t\n\tpublic RpcCommand(RpcCommandType rpcCommandType, String rpcCommand, String rpcCommandArguments, long arriveTimestamp, long timeout) {\n\t\tthis.rpcCommandType = rpcCommandType;\n\t\tthis.rpcCommand = rpcCommand;\n\t\tthis.rpcCommandArguments = rpcCommandArguments;\n\t\tthis.arriveTimestamp ="}, {"ID": 438, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public UserProcessor<?> getUserProcessor(String className) { return StringUtils.isBlank(className) ? null : this.userProcessors.get(className); } \nResponse:", "ground_truth": "Get user processor for class name.\n\n@param className\n@return", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 439, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; } \nResponse:", "ground_truth": "get one connection randomly\n\n@param conns\n@return", "predict": " private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class RandomGet {\n\t\n\tprivate static final int MAX_TIMES = 100;\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tList<Connection> conns = new ArrayList<Connection>();\n\t\t\n\t\tconns.add(new Connection(\"1\", \"2\"));\n\t\t"}, {"ID": 440, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; } \nResponse:", "ground_truth": "get and use default if not found\n\n@param key\n@param defaultIfNotFound\n@param \n@return", "predict": " Response.ok().build();\n\n}\n"}, {"ID": 441, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getProperty(String key) { if (properties == null) { return null; } return properties.getProperty(key); } \nResponse:", "ground_truth": "Get property value according to property key\n\n@param key\n@return property value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 442, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException { preProcess(responseCommand, addr); if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return toResponseObject(responseCommand); } else { String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId()); logger.warn(msg); if (responseCommand.getCause() != null) { throw new InvokeException(msg, responseCommand.getCause()); } else { throw new InvokeException(msg + \", please check the server log for more.\"); } } } \nResponse:", "ground_truth": "Analyze the response command and generate the response object.\n\n@param responseCommand response command\n@param addr response address\n@return response object", "predict": " public static Object toResponseObject(ResponseCommand responseCommand) { if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return responseCommand.getResult(); } else { return responseCommand.getCause(); } } \n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang.reflect.MethodUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.serializer.SerializerFeature.WriteMapNullValue;\nimport com.alibaba.fastjson.serial"}, {"ID": 443, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); } \nResponse:", "ground_truth": "Convert remoting response command to application response object.", "predict": " private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonDeserializationContext;\nimport com.google.gson.JsonDeserializer;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParseException;\nimport com.google.gson.JsonPrimitive;\nimport"}, {"ID": 444, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; } \nResponse:", "ground_truth": "Convert remoting response command to throwable if it is a throwable, otherwise return null.", "predict": " Generate the method-level comment for the following java Code. Code: private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.Collections;\nimport java.util.BitSet;\nimport java.util.Arrays;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.LinkedHashMap;\nimport java.util."}, {"ID": 445, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } } \nResponse:", "ground_truth": "Detail your error msg with the error msg returned from response command", "predict": " Generate the method-level comment for the following java Code. Code: private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } } \n */\n\npublic class RpcResponseCommand {\n    private String errorMsg;\n    private String errorCode;\n    private String errorCodeDesc;\n    private String errorCodeDetail;\n    private String errorCodeDetailDesc;\n    private String errorCodeDetailCode;\n    private String errorCodeDetailCodeDesc;\n    private String errorCodeDetailCodeDescCode;\n    private String errorCodeDetailCodeDescCode"}, {"ID": 446, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; } \nResponse:", "ground_truth": "create server exception using error msg and fill the stack trace using the stack trace of throwable.\n\n@param t the origin throwable to fill the stack trace of rpc server exception\n@param errMsg additional error msg, null is allowed\n@return an instance of RpcServerException", "predict": " public RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; } \n\n}\n"}, {"ID": 447, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } } \nResponse:", "ground_truth": "print trace log\n@param traceId\n@param invokeContext", "predict": " public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } } \n\n*/\n"}, {"ID": 448, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) { return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory); } \nResponse:", "ground_truth": "Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.\n\n@param nThreads\n@param threadFactory\n@return an EventLoopGroup suitable for the current platform", "predict": "\n\n*/\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool(new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable r) {\n                Thread t = new Thread(r);\n                t.setDaemon(true);\n                return t;\n            }\n        });\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello World\");\n            }\n        });\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.SECONDS);\n"}, {"ID": 449, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the remote address of the channel.\n\n@param channel\n@return", "predict": " public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); } \n\n*/\n\npublic class RemoteAddressParser {\n    public static final String REMOTE_ADDRESS_PATTERN = \"^(\\\\w+\\\\.\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+|\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+|\\\\w+\\\\.\\\\w+\\\\.\\\\w+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+:\\\\d+|\\\\w+\\\\"}, {"ID": 450, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the local address of the channel.\n\n@param channel\n@return", "predict": " public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); } \n\n*/\n\npublic class ChannelLocalAddressParser extends AbstractParser {\n\n    public ChannelLocalAddressParser() {\n        super();\n    }\n\n    @Override\n    public String parse(String channel) {\n        if (null == channel) {\n            return StringUtils.EMPTY;\n        }\n        final SocketAddress local = channel.localAddress();\n        return local != null ? local.toString().trim() : StringUtils.EMPTY;\n    }\n\n}\n"}, {"ID": 451, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote host ip of the channel.\n\n@param channel\n@return", "predict": " Generate the method-level comment for the following java Code. Code: public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \n */\n\npublic class RemoteIP {\n    public static void main(String[] args) {\n        String ip = \"\";\n        try {\n            ip = InetAddress.getLocalHost().getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        System.out.println(ip);\n    }\n}\n"}, {"ID": 452, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote hostname of the channel.\n\nNote: take care to use this method, for a reverse name lookup takes uncertain time in {@link InetAddress#getHostName}.\n\n@param channel\n@return", "predict": " Generate the method-level comment for the following java Code. Code: public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; } \n */\n\npublic class RemoteHostName {\n    public static void main(String[] args) {\n        String hostName = \"\";\n        try {\n            hostName = InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        System.out.println(hostName);\n    }\n}\n"}, {"ID": 453, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the local host ip of the channel.\n\n@param channel\n@return", "predict": " public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \n\n*/\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class LocalIP {\n\tpublic static void main(String[] args) {\n\t\tString ip = \"192.168.1.1\";\n\t\tString ip2 = \"192.168.1.1\";\n\t\tString ip3 = \"192.168.1.1\";\n\t\tString ip4 = \"192.168.1.1\";\n\t\tString ip5 = \"192.168.1.1\";\n\t\tString ip6 = \"192.168.1.1\";\n\t\tString ip7 = \""}, {"ID": 454, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the remote host port of the channel.\n\n@param channel\n@return int", "predict": " public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; } \n */\n\npublic class Solution {\n    public static int parseRemotePort(final Channel channel) {\n        if (null == channel) {\n            return -1;\n        }\n        final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress();\n        if (remote != null) {\n            return remote.getPort();\n        }\n        return -1;\n    }\n}\n"}, {"ID": 455, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the local host port of the channel.\n\n@param channel\n@return int", "predict": " public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; } \n */\n\npublic class Solution {\n    public static int parseLocalPort(final Channel channel) {\n        if (null == channel) {\n            return -1;\n        }\n        final InetSocketAddress local = (InetSocketAddress) channel.localAddress();\n        if (local != null) {\n            return local.getPort();\n        }\n        return -1;\n    }\n}\n"}, {"ID": 456, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseSocketAddressToHostIp(SocketAddress socketAddress) { final InetSocketAddress addrs = (InetSocketAddress) socketAddress; if (addrs != null) { InetAddress addr = addrs.getAddress(); if (null != addr) { return addr.getHostAddress(); } } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the host ip of socket address.\n\ne.g. /127.0.0.1:1234 -> 127.0.0.1\n\n@param socketAddress\n@return String", "predict": "\n\n*/\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SocketAddressToHostIp {\n\n    public static void main(String[] args) {\n        SocketAddress socketAddress = new InetSocketAddress(\"localhost\", 8080);\n        System.out.println(parseSocketAddressToHostIp(socketAddress));\n    }\n\n    public static String parseSocketAddressToHostIp(SocketAddress socketAddress) {\n        if (socketAddress == null) {\n            return \"\";\n        }\n        if (socketAddress instanceof InetSocketAddress) {\n            InetSocketAddress addrs = (InetSocketAddress) socketAddress;\n            if (addrs != null) {\n                InetAddress addr = addrs.getAddress();\n                if (addr != null) {\n                    return addr.getHostAddress();\n                "}, {"ID": 457, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.addIfAbsent(connection); if (res) { connection.increaseRef(); } } \nResponse:", "ground_truth": "add a connection\n\n@param connection", "predict": " public void remove(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } } \nResp public void remove(Connection connection, boolean force) { markAccess(); if (null == connection) { return; } boolean res = this.conns.remove(connection, force); if (res) { connection.decreaseRef(); } } \nResp public void removeAll(Collection<Connection> connections) { markAccess(); if (null == connections) { return; } for (Connection connection : connections) { this.remove(connection); } } \nResp public void removeAll(Collection<Connection> connections, boolean force) { markAccess(); if (null == connections) { return; } for (Connection connection : connections) { this.remove(connection, force); } } \nResp public void clear() { markAccess(); this.conns.clear"}, {"ID": 458, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } } \nResponse:", "ground_truth": "removeAndTryClose a connection\n\n@param connection", "predict": " public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n    \n    public void test() {\n        Connection conn1 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn2 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn3 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn4 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn5 = new Connection(\"localhost\", 3306, \"root\", \"123456\");\n        Connection conn"}, {"ID": 459, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Connection get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } } \nResponse:", "ground_truth": "get a connection\n\n@return", "predict": " Response is generated by the following java Code. Code: public Response get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } } \n */\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        List<Connection> conns = new ArrayList<Connection>();\n        conns.add(new Connection(\"a\", \"b\"));\n        conns.add(new Connection(\"a\", \"c\"));\n        conns.add(new Connection(\"b\", \"c\"));\n        conns.add(new Connection(\"c\", \"d\"));\n        conns.add(new"}, {"ID": 460, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(String className, CustomSerializer serializer) { CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for class name.\n\n@param className\n@param serializer\n@return", "predict": "\n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CustomSerializer {\n    private static Map<String, CustomSerializer> customSerializerMap = new HashMap<String, CustomSerializer>();\n\n    public static void registerCustomSerializer(String className, CustomSerializer customSerializer) {\n        customSerializerMap.put(className, customSerializer);\n    }\n\n    public static CustomSerializer getCustomSerializer(String className) {\n        return customSerializerMap.get(className);\n    }\n}\n"}, {"ID": 461, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(String className) { if (!classCustomSerializer.isEmpty()) { return classCustomSerializer.get(className); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for class name.\n\n@param className\n@return", "predict": " Response = Response.ok(CustomSerializer.getCustomSerializer(className)).build();\n\n*/\n\npublic class CustomSerializer {\n\t\n\tprivate static final Logger logger = Logger.getLogger(CustomSerializer.class);\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE = \"com.fasterxml.jackson.databind.ser.std.ToStringSerializer\";\n\tprivate static final String CUSTOM_SERIALIZER_CLASS = \"ToStringSerializer\";\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE_NAME = \"com.fasterxml.jackson.databind.ser.std.ToStringSerializer\";\n\tprivate static final String CUSTOM_SERIALIZER_CLASS_NAME = \"ToStringSerializer\";\n\t\n\tprivate static final String CUSTOM_SERIALIZER_PACKAGE_NAME_"}, {"ID": 462, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) { CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for command code.\n\n@param code\n@param serializer\n@return", "predict": " ResponseCode.SUCCESS\n*/\n\npublic class CommandSerializer {\n    private static final Logger logger = LoggerFactory.getLogger(CommandSerializer.class);\n\n    private static final Map<CommandCode, CustomSerializer> customSerializers = new HashMap<>();\n\n    public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) {\n        customSerializers.put(code, serializer);\n    }\n\n    public static ResponseCode serialize(CommandCode code, Object command) {\n        if (code == null) {\n            return ResponseCode.INVALID_COMMAND_CODE;\n        }\n\n        if (command == null) {\n            return ResponseCode.INVALID_COMMAND_OBJECT;\n        }\n\n        CustomSerializer serializer = customSerializers.get(code);\n        if (serializer == null) {\n            return ResponseCode.UNSUPPORTED_COMMAND_"}, {"ID": 463, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(CommandCode code) { if (!commandCustomSerializer.isEmpty()) { return commandCustomSerializer.get(code); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for command code.\n\n@param code\n@return", "predict": " ResponseCode = 0, if the method is successfully executed. Otherwise, ResponseCode = -1, ResponseMessage = Error Message.\n*/\n\npublic class CommandSerializer {\n    private static final Logger logger = LoggerFactory.getLogger(CommandSerializer.class);\n    private static final String COMMAND_SERIALIZER_CLASS_NAME = \"CommandSerializer\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_PREFIX = \"CommandSerializer_\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_SUFFIX = \"CommandSerializer\";\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_PREFIX_WITH_SUFFIX = COMMAND_SERIALIZER_CLASS_NAME_PREFIX + COMMAND_SERIALIZER_CLASS_NAME_SUFFIX;\n    private static final String COMMAND_SERIALIZER_CLASS_NAME_"}, {"ID": 464, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager.conn_monitor_initial_delay(); /** period of schedule task, unit: ms*/ long period = ConfigManager.conn_monitor_period(); this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy()); MonitorTask monitorTask = new MonitorTask(); this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS); } \nResponse:", "ground_truth": "Start schedule task", "predict": "\n\n*/\n\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionMonitorTask implements Runnable {\n\tprivate ScheduledExecutorService executor;\n\tprivate ScheduledFuture<?> monitorTask;\n\t\n\tpublic ConnectionMonitorTask() {\n\t\texecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"ConnectionMonitorThread\", true));\n\t}\n\t\n\tpublic void start() {\n\t\tmonitorTask = executor.scheduleAtFixedRate(this, ConfigManager.conn_monitor_initial_delay(), ConfigManager.conn_monitor_period(), TimeUnit.MILLISECONDS);\n\t}\n\t\n\tpublic void stop() {\n\t\tmonitorTask.cancel(true);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n"}, {"ID": 465, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isConnected(String remoteAddr) { Url url = this.rpcRemoting.addressParser.parse(remoteAddr); return this.isConnected(url); } \nResponse:", "ground_truth": "check whether a client address connected\n\n@param remoteAddr\n@return", "predict": " public boolean isConnected(Url url) { return this.rpcRemoting.isConnected(url); } \n*/\n\npublic class RpcRemoting {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(RpcRemoting.class);\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_FILE = \"rpc-remoting.properties\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_PREFIX = \"rpc.remoting.\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_SERVER_LIST = RPC_REMOTING_CONFIG_KEY_PREFIX + \"server.list\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_SERVER_LIST_SEPARATOR = \",\";\n\t\n\tprivate static final String RPC_REMOTING_CONFIG_KEY_"}, {"ID": 466, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void initWriteBufferWaterMark() { int lowWaterMark = this.netty_buffer_low_watermark(); int highWaterMark = this.netty_buffer_high_watermark(); if (lowWaterMark > highWaterMark) { throw new IllegalArgumentException( String .format( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\", highWaterMark, lowWaterMark)); } else { logger.warn( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\", lowWaterMark, highWaterMark); } this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( lowWaterMark, highWaterMark)); } \nResponse:", "ground_truth": "init netty write buffer water mark", "predict": "\n\n*/\n\npackage com.alibaba.dubbo.remoting.transport.netty;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.channel.SimpleChannelHandler;\nimport org.jboss.netty.channel.WriteCompletionEvent;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.channel.group.DefaultChannelGroup;\nimport org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\nimport org.jboss."}, {"ID": 467, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } } \nResponse:", "ground_truth": "Get a frame with a specific opcode\n\n@param opcode the opcode representing the frame\n@return the frame with a specific opcode", "predict": " public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } } \n\n*/\n\npackage org.java_websocket.exceptions;\n\npublic class InvalidDataException extends InvalidFrameException {\n\tprivate static final long serialVersionUID = -8680098990129154701L;\n\n\tpublic InvalidDataException(String s) {\n\t\tsuper(s);\n\t}\n}\n"}, {"ID": 468, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if( buffer == null ) { if( sockchannel instanceof WrappedByteChannel ) { c = (WrappedByteChannel) sockchannel; if( c.isNeedWrite() ) { c.writeMore(); } } } else { do {// FIXME writing as much as possible is unfair!! /*int written = */sockchannel.write( buffer ); if( buffer.remaining() > 0 ) { return false; } else { ws.outQueue.poll(); // Buffer finished. Remove it. buffer = ws.outQueue.peek(); } } while ( buffer != null ); } if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {// ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); } \nResponse:", "ground_truth": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_17;\nimport org.java_websocket.drafts.Draft_75;\nimport org.java_websocket.drafts.Draft_76;\nimport org.java_websocket.drafts.Draft_77;\nimport org.java_websocket.drafts.Draft_78;\nimport org.java_websocket.drafts.Draft_79;\nimport org.java_websocket.drafts.Draft_80;\nimport org.java_websocket.drafts.Draft"}, {"ID": 469, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setCode(int code) { this.code = code; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = \"\"; } updatePayload(); } \nResponse:", "ground_truth": "Set the close code for this close frame\n@param code the close code", "predict": " public void setResponse(byte[] response) { this.response = response; } \n\n*/\n\npublic class CloseFrame extends FramedataImpl1 implements Close {\n    public static final byte TYPE = 8;\n\n    private int code;\n    private String reason;\n    private byte[] response;\n\n    /**\n     * Create a new Close request with the given status code\n     *\n     * @param code The status code\n     */\n    public CloseFrame(int code) {\n        super(TYPE);\n        this.code = code;\n    }\n\n    /**\n     * Create a new Close request with the given status code and reason\n     *\n     * @param code The status code\n     * @param reason The reason\n     */\n    public CloseFrame(int code, String reason) {\n        super(TYPE);\n        this.code = code;\n        this.reason = reason;\n    }\n\n    /**\n     * Create a new Close request with the given"}, {"ID": 470, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position( payload.position() + 2 ); reason = Charsetfunctions.stringUtf8( payload ); } catch ( IllegalArgumentException e ) { throw new InvalidDataException( CloseFrame.NO_UTF8 ); } finally { payload.position( mark ); } } \nResponse:", "ground_truth": "Validate the payload to valid utf8\n@param mark the current mark\n@param payload the current payload\n@throws InvalidDataException the current payload is not a valid utf8", "predict": "\n\npublic void onFailure(String reason, int code, String message) {\n}\n\npublic void onSuccess(String message) {\n}\n\npublic void onSuccess(String message, int code, String reason) {\n}\n\npublic void onSuccess(String message, int code) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo, String otherReason) {\n}\n\npublic void onSuccess(String message, int code, String reason, String evidence, int errorCode, String otherInfo, String otherReason, String otherEvidence) {\n"}, {"ID": 471, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); } \nResponse:", "ground_truth": "Update the payload to represent the close code and the reason", "predict": " Response = new Response(Response.OK, super.getPayload());\n*/\n\npublic class Payload {\n\tpublic static final int OK = 0;\n\tpublic static final int ERROR = 1;\n\tpublic static final int ERROR_INVALID_PAYLOAD = 2;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH = 3;\n\tpublic static final int ERROR_INVALID_PAYLOAD_TYPE = 4;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE = 5;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_OR_CODE = 6;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_OR_CODE_OR_REASON = 7;\n\tpublic static final int ERROR_INVALID_PAYLOAD_LENGTH_OR_TYPE_"}, {"ID": 472, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; } \nResponse:", "ground_truth": "Check if the requested protocol is part of this draft\n@param requestedProtocol the requested protocol\n@return MATCHED if it is matched, otherwise NOT_MATCHED", "predict": " HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return Response.ACCEPTED; } } return Response.REJECTED; } \nResp HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return Response.ACCEPTED; } } return Response.REJECTED; } \nResp HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if("}, {"ID": 473, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if( length > Integer.MAX_VALUE ) { log.trace(\"Limit exedeed: Payloadsize is to big...\"); throw new LimitExceededException(\"Payloadsize is to big...\"); } if( length > maxFrameSize) { log.trace( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize, length); throw new LimitExceededException( \"Payload limit reached.\", maxFrameSize ); } if( length < 0 ) { log.trace(\"Limit underflow: Payloadsize is to little...\"); throw new LimitExceededException(\"Payloadsize is to little...\"); } } \nResponse:", "ground_truth": "Check if the frame size exceeds the allowed limit\n@param length the current payload length\n@throws LimitExceededException if the payload length is to big", "predict": "\n\n*/\n\npublic class Frame {\n\t\n\tprivate static final Logger log = LoggerFactory.getLogger(Frame.class);\n\t\n\tprivate static final int MAX_PAYLOAD_SIZE = 65535;\n\t\n\tprivate static final int MAX_FRAME_SIZE = 65535;\n\t\n\tprivate static final int MAX_FRAME_SIZE_LOWER_BOUND = 0;\n\t\n\tprivate static final int MAX_FRAME_SIZE_UPPER_BOUND = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_DEFAULT = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MIN = 0;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MAX = MAX_PAYLOAD_SIZE;\n\t\n\tprivate static final int MAX_FRAME_SIZE_MIDDLE = MAX_PAYLOAD"}, {"ID": 474, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } } \nResponse:", "ground_truth": "Check if the max packet size is smaller than the real packet size\n@param maxpacketsize the max packet size\n@param realpacketsize the real packet size\n@throws IncompleteException if the maxpacketsize is smaller than the realpackagesize", "predict": " Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } } \n*/\n\npublic class FrameCheckPacketSize extends Frame {\n\tpublic FrameCheckPacketSize() {\n\t\tsuper();\n\t\tthis.setOpcode(Frame.OPCODE_CHECK_PACKET_SIZE);\n\t}\n\t\n\tpublic FrameCheckPacketSize(int maxpacketsize, int realpacketsize) {\n\t\tthis();\n\t\tthis.setMaxPacketSize(maxpacketsize);\n\t\tthis.setRealPacketSize(realpacketsize);\n\t}\n\t\n\tpublic int getMaxPacketSize() {"}, {"ID": 475, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String generateFinalKey( String in ) { String seckey = in.trim(); String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance( \"SHA1\" ); } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException( e ); } return Base64.encodeBytes( sh1.digest( acc.getBytes() ) ); } \nResponse:", "ground_truth": "Generate a final key from a input string\n@param in the input string\n@return a final key", "predict": "\n\n*/\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class FinalKeyGenerator {\n\tpublic static void main(String[] args) {\n\t\tString input = \"\";\n\t\ttry {\n\t\t\tinput = \"test\";\n\t\t\tSystem.out.println(generateFinalKey(input));\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static String generateFinalKey(String input) throws NoSuchAlgorithmException {\n\t\tMessageDigest sh1;\n\t\ttry {\n\t\t\tsh1 = MessageDigest.getInstance(\"SHA1\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tbyte"}, {"ID": 476, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if( curop != Opcode.CONTINUOUS ) { processFrameIsNotFin(frame); } else if( frame.isFin() ) { processFrameIsFin(webSocketImpl, frame); } else if( currentContinuousFrame == null ) { log.error( \"Protocol error: Continuous frame sequence was not started.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } //Check if the whole payload is valid utf8, when the opcode indicates a text if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) { log.error( \"Protocol error: Payload is not UTF8\" ); throw new InvalidDataException( CloseFrame.NO_UTF8 ); } //Checking if the current continuous frame contains a correct payload with the other frames combined if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) { addToBufferList(frame.getPayloadData()); } } \nResponse:", "ground_truth": "Process the frame if it is a continuous frame or the fin bit is not set\n@param webSocketImpl the websocket implementation to use\n@param frame the current frame\n@param curop the current Opcode\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) {\n\tif( frame.getOpcode() == Opcode.CONTINUOUS ) {\n\t\tif( currentContinuousFrame != null ) {\n\t\t\tcurrentContinuousFrame.setPayload(currentContinuousFrame.getPayload() + frame.getPayloadData());\n\t\t} else {\n\t\t\tcurrentContinuousFrame = new FramedataImpl1(frame);\n\t\t}\n\t} else {\n\t\tif( currentContinuousFrame != null ) {\n\t\t\tcurrentContinuousFrame.setPayload(currentContinuousFrame.getPayload() + frame.getPayloadData());\n\t\t\tprocessFrameIsFin(webSocketImpl, currentContinuousFrame);\n\t\t} else {\n\t\t\tprocessFrameIsNotFin(frame);\n\t\t}\n\t}\n}\n\npublic void processFrameIsNotFin(Framedata frame) {\n\tif( frame.getOpcode()"}, {"ID": 477, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a binary frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\npublic void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \n\n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger logger = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final int MAX_FRAME_SIZE = 16384;\n\t\n\tprivate final int port;\n\t\n\tprivate final ServerSocketChannel server;\n\t\n\tprivate final ExecutorService executor;\n\t\n\tprivate final WebSocketServerFactory wsFactory;\n\t\n\tprivate final Map<WebSocket, WebSocketWorker> workers = new HashMap<WebSocket, WebSocketWorker>();\n\t\n\tprivate final Map<WebSocket, Web"}, {"ID": 478, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { log.error( \"Runtime exception during onWebsocketMessage\", e ); webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e ); } \nResponse:", "ground_truth": "Log the runtime exception to the specific WebSocketImpl\n@param webSocketImpl the implementation of the websocket\n@param e the runtime exception", "predict": "\npublic void onWebsocketMessage(WebSocket webSocket, String message) {\n\ttry {\n\t\tlog.info( \"Received message: \" + message );\n\t\twebSocket.getWebSocketListener().onWebsocketMessage( webSocket, message );\n\t} catch (RuntimeException e) {\n\t\tlogRuntimeException(webSocket, e);\n\t}\n}\n\npublic void onWebsocketError(WebSocket webSocket, Exception ex) {\n\ttry {\n\t\tlog.error( \"Error during onWebsocketError\", ex );\n\t\twebSocket.getWebSocketListener().onWebsocketError( webSocket, ex );\n\t} catch (RuntimeException e) {\n\t\tlogRuntimeException(webSocket, e);\n\t}\n}\n\npublic void onWebsocketClose(WebSocket webSocket, int code, String reason, boolean remote) {\n\ttry {\n\t\tlog.info( \"Connection closed: \" + code + \" -"}, {"ID": 479, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a text frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\npublic void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \n\n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger LOG = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final String WEBSOCKET_PATH = \"/websocket\";\n\t\n\tprivate static final int DEFAULT_PORT = 8080;\n\t\n\tprivate static final int DEFAULT_BACKLOG = 10;\n\t\n\tprivate static final int DEFAULT_READ_TIMEOUT = 0;\n\t\n\tprivate static final int DEFAULT_WRITE_TIMEOUT = 0;\n\t\n"}, {"ID": 480, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if( currentContinuousFrame == null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); } \nResponse:", "ground_truth": "Process the frame if it is the last frame\n@param webSocketImpl the websocket impl\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic void sendFrame( Framedata frame ) {\nif( !isOpen() ) { throw new IllegalStateException( \"this.webSocketImpl.getReadyState() != READYSTATE.OPEN\" ); }\nif( frame.getOpcode() == Opcode.CONTINUOUS ) { if( currentContinuousFrame != null ) { throw new IllegalArgumentException( \"Only a single continuous frame is allowed.\" ); } currentContinuousFrame = frame; } else { if( currentContinuousFrame != null ) { throw new IllegalStateException( \"A continuous frame is already being processed.\" ); } }\nif( frame.getOpcode() == Opcode.TEXT ) { if( !frame.isFin() ) { throw new InvalidFrameException( \"A text frame must be a final frame (FIN bit set).\" ); } }\nif( frame.getOpcode() == Opcode.BINARY ) { if( !frame.isFin() ) { throw new InvalidFrameException"}, {"ID": 481, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if( currentContinuousFrame != null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" ); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); } \nResponse:", "ground_truth": "Process the frame if it is not the last frame\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "\n\npublic class ServerHandshake extends WebSocketServerHandshaker {\n    private static final Logger log = LoggerFactory.getLogger(ServerHandshake.class);\n    private final String subprotocols;\n    private final boolean allowExtensions;\n    private final int maxFramePayloadLength;\n    private final int maxMessagePayloadLength;\n    private final boolean allowMaskMismatch;\n    private final boolean checkStartsWith;\n    private final boolean maskedPayload;\n    private final int maxBufferSize;\n    private final boolean sendCloseFrame;\n    private final boolean expectCloseFrame;\n    private final boolean sendMask;\n    private final int maxBinaryFramePayloadLength;\n    private final int maxTextFramePayloadLength;\n    private final boolean allowMaskMismatch;\n    private final boolean checkStartsWith;\n    private final boolean maskedPayload;\n    private final int maxBufferSize;\n    private final boolean sendCloseFrame"}, {"ID": 482, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = \"\"; if( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) { // complete the close handshake by disconnecting webSocketImpl.closeConnection( code, reason, true ); } else { // echo close handshake if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY ) webSocketImpl.close( code, reason, true ); else webSocketImpl.flushAndClose( code, reason, false ); } } \nResponse:", "ground_truth": "Process the frame if it is a closing frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger LOG = Logger.getLogger(WebSocketServer.class.getName());\n    private static final String WEBSOCKET_PATH = \"/websocket\";\n    private static final String WEBSOCKET_PATH_PROPERTY = \"websocket.path\";\n    private static final String WEBSOCKET_HOST = \"websocket.host\";\n    private static final String WEBSOCKET_HOST_PROPERTY = \"websocket.host\";\n    private static final String WEBSOCKET_PORT = \"websocket.port\";\n    private static final String WEBSOCKET_PORT_PROPERTY = \"websocket.port\";\n    private static final String WEBSOCKET_MAX_CONNECTIONS = \"websocket.maxConnections\";\n    private static final String WEBSOCKET_MAX_CONNECTIONS_PROPERTY = \""}, {"ID": 483, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if( totalSize > maxFrameSize ) { clearBufferList(); log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize); throw new LimitExceededException(maxFrameSize); } } \nResponse:", "ground_truth": "Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size\n@throws LimitExceededException if the current size is bigger than the allowed size", "predict": "\n\n*/\n\npublic class Frame {\n    private final int frameSize;\n    private final int frameType;\n    private final int frameVersion;\n    private final int frameFlags;\n    private final int frameLength;\n    private final int framePayloadSize;\n    private final int framePayloadOffset;\n    private final int framePayloadLength;\n    private final int framePayloadData;\n    private final int framePayloadDataOffset;\n    private final int framePayloadDataLength;\n    private final int framePayloadDataOffsetEnd;\n    private final int framePayloadDataLengthEnd;\n    private final int framePayloadDataOffsetStart;\n    private final int framePayloadDataLengthStart;\n    private final int framePayloadDataOffsetStartEnd;\n    private final int framePayloadDataLengthStartEnd;\n    private final int framePayloadDataOffsetEnd;\n    private final int framePayloadDataLengthEnd;\n    private final int framePay"}, {"ID": 484, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate( (int) totalSize ); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put( buffer ); } } resultingByteBuffer.flip(); return resultingByteBuffer; } \nResponse:", "ground_truth": "Method to generate a full bytebuffer out of all the fragmented frame payload\n@return a bytebuffer containing all the data\n@throws LimitExceededException will be thrown when the totalSize is bigger then Integer.MAX_VALUE due to not being able to allocate more", "predict": " ResponseCode = 0, ErrorMessage = null \n*/\n\npublic class ByteBufferList {\n\tprivate List<ByteBuffer> byteBufferList;\n\tprivate int totalSize;\n\tprivate int limit;\n\t\n\tpublic ByteBufferList() {\n\t\tbyteBufferList = new ArrayList<ByteBuffer>();\n\t\ttotalSize = 0;\n\t\tlimit = 0;\n\t}\n\t\n\tpublic void add(ByteBuffer buffer) {\n\t\tbyteBufferList.add(buffer);\n\t\ttotalSize += buffer.limit();\n\t\tlimit = totalSize;\n\t}\n\t\n\tpublic ByteBuffer get(int index) {\n\t\treturn byteBufferList.get(index);\n\t}\n\t\n\tpublic int size() {\n\t\treturn byteBufferList.size();\n\t}\n\t\n\tpublic int getLimit() {\n\t\treturn limit;\n\t}\n\t\n\tpublic void checkBufferLimit() throws LimitExceededException {\n\t\tif (limit >"}, {"ID": 485, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; } \nResponse:", "ground_truth": "Get the current size of the resulting bytebuffer in the bytebuffer list\n@return the size as long (to not get an integer overflow)", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 486, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return clienthandshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as server\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the SERVER if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ServerHandshakeBuilder serverhandshake = new HandshakeImpl1Server(); serverhandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return serverhandshake; } \n\n*/\n"}, {"ID": 487, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] ); return handshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as client\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage("}, {"ID": 488, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time if( socketBuffer.hasRemaining() ) { decodeFrames( socketBuffer ); } else if( tmpHandshakeBytes.hasRemaining() ) { decodeFrames( tmpHandshakeBytes ); } } } } \nResponse:", "ground_truth": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "predict": " public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { decodeFrames( socketBuffer ); } } } \nResp public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socket"}, {"ID": 489, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem", "predict": " Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResp Generate the method-level comment for the following java Code. Code: private void close"}, {"ID": 490, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToInternalServerError( RuntimeException exception ) { write( generateHttpResponseDueToError( 500 ) ); flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if there was a server error by a RuntimeException\n\n@param exception the RuntimeException causing this problem", "predict": "\n\npublic class HttpResponse {\n    private final int statusCode;\n    private final String reasonPhrase;\n    private final byte[] content;\n    private final String contentType;\n    private final int contentLength;\n\n    public HttpResponse(int statusCode, String reasonPhrase, byte[] content, String contentType, int contentLength) {\n        this.statusCode = statusCode;\n        this.reasonPhrase = reasonPhrase;\n        this.content = content;\n        this.contentType = contentType;\n        this.contentLength = contentLength;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getReasonPhrase() {\n        return reasonPhrase;\n    }\n\n    public byte[] getContent() {\n        return content;\n    }\n\n    public String getContentType() {\n        return contentType;\n    }\n\n    public int getContentLength() {\n        return"}, {"ID": 491, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); } \nResponse:", "ground_truth": "", "predict": " Generate the method-level comment for the following java Code. Code: private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); } \n"}, {"ID": 492, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); } \nResponse:", "ground_truth": "Send Text data to the other end.\n\n@throws WebsocketNotConnectedException websocket is not yet connected", "predict": " @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); } \n\n*/\n\npublic class WebSocketImpl {\n    private final WebSocketDraft draft;\n    private final WebSocketListener listener;\n    private final WebSocketClientHandshaker handshaker;\n    private final URI uri;\n    private final WebSocketClientHandler handler;\n    private final WebSocketClientProtocolHandler protocolHandler;\n    private final HttpHeaders customHeaders;\n    private final int maxFramePayloadLength;\n    private final int maxMessagePayloadLength;\n    private final boolean allowExtensions;\n    private final boolean performMasking;\n    private final boolean useMask;\n    private final int maxFrameSize;\n    private final int maxMessagesPerFrame;\n    private final int"}, {"ID": 493, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\"); } try { closeBlocking(); if( writeThread != null ) { this.writeThread.interrupt(); this.writeThread = null; } if( connectReadThread != null ) { this.connectReadThread.interrupt(); this.connectReadThread = null; } this.draft.reset(); if( this.socket != null ) { this.socket.close(); this.socket = null; } } catch ( Exception e ) { onError( e ); engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() ); return; } connectLatch = new CountDownLatch( 1 ); closeLatch = new CountDownLatch( 1 ); this.engine = new WebSocketImpl( this, this.draft ); } \nResponse:", "ground_truth": "Reset everything relevant to allow a reconnect\n@since 1.3.8", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private final WebSocketDelegate delegate;\n    private final WebSocketDraft draft;\n    private final Socket socket;\n    private final InputStream in;\n    private final OutputStream out;\n    private final List<WebSocket> connections = new ArrayList<WebSocket>();\n    private final List<WebSocketWorker> workers = new ArrayList<WebSocketWorker>();\n    private final List<WebSocketImpl> connections_ = new ArrayList<WebSocketImpl>();\n    private volatile boolean closed = false;\n    private volatile boolean closedRemotely = false;\n    private volatile boolean failed = false;\n    private volatile boolean disposed = false;\n    private volatile boolean disposedRemotely = false;\n    private volatile boolean open = false;\n    private volatile boolean openRemotely = false;\n    private volatile boolean wasConnected = false;\n    private volatile boolean wasDisconnected = false;\n    private volatile boolean"}, {"ID": 494, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void connect() { if( connectReadThread != null ) throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" ); connectReadThread = new Thread( this ); connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() ); connectReadThread.start(); } \nResponse:", "ground_truth": "Initiates the websocket connection. This method does not block.", "predict": " public void run() { try { if( connectReadThread != null ) connectReadThread.join(); } catch( InterruptedException e ) { } } \n\n*/\n\npublic class WebSocketClient {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger( WebSocketClient.class );\n\t\n\tprivate final String host;\n\tprivate final int port;\n\tprivate final String path;\n\tprivate final String protocol;\n\tprivate final String username;\n\tprivate final String password;\n\tprivate final String url;\n\tprivate final String method;\n\tprivate final String contentType;\n\tprivate final String content;\n\tprivate final String contentEncoding;\n\tprivate final String accept;\n\tprivate final String acceptEncoding;\n\tprivate final String acceptLanguage;\n\tprivate final String acceptCharset;\n\tprivate final String cookie;\n\tprivate final String cookieDomain;\n\tprivate final String cookiePath;\n\tprivate final String cookieMaxAge;"}, {"ID": 495, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getPort() { int port = uri.getPort(); if( port == -1 ) { String scheme = uri.getScheme(); if( \"wss\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_WSS_PORT; } else if( \"ws\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_PORT; } else { throw new IllegalArgumentException( \"unknown scheme: \" + scheme ); } } return port; } \nResponse:", "ground_truth": "Extract the specified port\n@return the specified port or the default port for the specific scheme", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger logger = Logger.getLogger(WebSocketServer.class.getName());\n\n    private static final String WEBSOCKET_PATH = \"/websocket\";\n    private static final String WEBSOCKET_PATH_WITH_PORT = \"/websocket/:port\";\n\n    private static final String WEBSOCKET_PATH_WITH_SSL = \"/websocket/ssl\";\n    private static final String WEBSOCKET_PATH_WITH_SSL_WITH_PORT = \"/websocket/ssl/:port\";\n\n    private static final String WEBSOCKET_PATH_WITH_SSL_AND_AUTH = \"/websocket/ssl/auth\";\n    private static final String WEBSOCKET_PATH_WITH_SSL_AND_AUTH_WITH_PORT = \"/websocket/ssl/auth/:port\";\n\n    private static final String"}, {"ID": 496, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if( part1 == null || part1.length() == 0 ) path = \"/\"; else path = part1; if( part2 != null ) path += '?' + part2; int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? \":\" + port : \"\" ); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor( path ); handshake.put( \"Host\", host ); if( headers != null ) { for( Map.Entry<String,String> kv : headers.entrySet() ) { handshake.put( kv.getKey(), kv.getValue() ); } } engine.startHandshake( handshake ); } \nResponse:", "ground_truth": "Create and send the handshake to the other endpoint\n@throws InvalidHandshakeException  a invalid handshake was created", "predict": " Send a Server Handshake\n\n*/\n\npublic class WebSocketServerHandshaker13 extends WebSocketServerHandshaker {\n\n    private static final String WEBSOCKET_13 = \"WebSocket-Version: 13\";\n\n    public WebSocketServerHandshaker13(String webSocketURL, String subprotocols, int maxFramePayloadLength, int maxIdleTime, int maxTextMessageSize, int maxBinaryMessageSize, boolean allowExtensions) {\n        super(webSocketURL, subprotocols, maxFramePayloadLength, maxIdleTime, maxTextMessageSize, maxBinaryMessageSize, allowExtensions);\n    }\n\n    @Override\n    protected String getWebSocketVersion() {\n        return WEBSOCKET_13;\n    }\n}\n"}, {"ID": 497, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setConnectionLostTimeout( int connectionLostTimeout ) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); return; } if (this.websocketRunning) { log.trace(\"Connection lost timer restarted\"); //Reset all the pings try { ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { log.error(\"Exception during connection lost restart\", e); } restartConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Setter for the interval checking for lost connections\nA value lower or equal 0 results in the check to be deactivated\n\n@param connectionLostTimeout the interval in seconds\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private static final Logger log = LoggerFactory.getLogger(WebSocketImpl.class);\n    private static final long serialVersionUID = -8288880591730267843L;\n    private static final int DEFAULT_CONNECTION_LOST_TIMEOUT = 60;\n    private static final int DEFAULT_CONNECTION_TIMEOUT = 60;\n    private static final int DEFAULT_PING_INTERVAL = 60;\n    private static final int DEFAULT_PONG_TIMEOUT = 60;\n    private static final int DEFAULT_MAX_BINARY_MESSAGE_SIZE = 16384;\n    private static final int DEFAULT_MAX_TEXT_MESSAGE_SIZE = 16384;\n    private static final int DEFAULT_MAX_PONG_MESSAGES = 10;\n    private static final int DEFAULT_MAX_PONG_"}, {"ID": 498, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Stop the connection lost timer\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketConnectionLostTimerTask extends TimerTask {\n    private static final Logger log = LoggerFactory.getLogger(WebSocketConnectionLostTimerTask.class);\n    private final WebSocketConnectionManager wsConnectionManager;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener wsConnectionStateListener;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionState;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateTo;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateFrom;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFrom;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFromTo;\n    private final WebSocketConnectionManager.WebSocketConnectionStateListener.ConnectionState connectionStateToFromToTo;\n    private final WebSocketConnectionManager"}, {"ID": 499, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } } \nResponse:", "ground_truth": "Start the connection lost timer\n@since 1.3.4", "predict": " public void onClose(int code, String reason, boolean remote) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer stopped\"); this.websocketRunning = false; stopConnectionLostTimer(); } } \nResp public void onError(Exception ex) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer stopped\"); this.websocketRunning = false; stopConnectionLostTimer(); } } \nResp public void onOpen(ServerHandshake handshakeData) { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } } \nResp"}, {"ID": 500, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"connectionLostChecker\")); Runnable connectionLostChecker = new Runnable() { /** * Keep the connections in a separate list to not cause deadlocks */ private ArrayList<WebSocket> connections = new ArrayList<WebSocket>( ); @Override public void run() { connections.clear(); try { connections.addAll( getConnections() ); long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 )); for( WebSocket conn : connections ) { executeConnectionLostDetection(conn, minimumPongTime); } } catch ( Exception e ) { //Ignore this exception } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); } \nResponse:", "ground_truth": "This methods allows the reset of the connection lost timer in case of a changed parameter\n@since 1.3.4", "predict": "\n\n*/\n\npublic class WebSocketServer {\n    private static final Logger LOGGER = LoggerFactory.getLogger(WebSocketServer.class);\n    private final int port;\n    private final List<WebSocket> connections = new ArrayList<WebSocket>();\n    private final List<WebSocket> connectionsToRemove = new ArrayList<WebSocket>();\n    private final List<WebSocket> connectionsToAdd = new ArrayList<WebSocket>();\n    private final ScheduledExecutorService connectionLostCheckerService;\n    private final ScheduledFuture connectionLostCheckerFuture;\n    private final long connectionLostTimeout;\n    private final WebSocketServerHandler handler;\n    private final WebSocketServerConfig config;\n\n    public WebSocketServer(int port, WebSocketServerHandler handler, WebSocketServerConfig config) {\n        this.port = port;\n        this.handler = handler;\n        this.config = config;\n        this.connectionLostTimeout = config"}, {"ID": 501, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if( webSocketImpl.getLastPong() < minimumPongTime ) { log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl); webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ); } else { if( webSocketImpl.isOpen() ) { webSocketImpl.sendPing(); } else { log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl); } } } \nResponse:", "ground_truth": "Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping\n@param webSocket the websocket instance\n@param minimumPongTime the lowest/oldest allowable last pong time (in nanoTime) before we consider the connection to be lost", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.websocket.ClientEndpoint;\nimport javax.websocket.CloseReason;\nimport javax.websocket.ContainerProvider;\nimport javax.websocket.DeploymentException;\nimport javax.websocket.Endpoint;\nimport javax.websocket.EndpointConfig;\nimport javax.websocket.MessageHandler;\nimport javax.websocket.Session;\n\nimport org.apache.log4j.Logger;\n\n@ClientEndpoint\npublic class WebSocketClientEndpoint extends Endpoint {\n\n\tprivate static final Logger log = Logger.getLogger(WebSocket"}, {"ID": 502, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cancelConnectionLostTimer() { if( connectionLostCheckerService != null ) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } } \nResponse:", "ground_truth": "Cancel any running timer for the connection lost detection\n@since 1.3.4", "predict": "\n\n*/\n\npublic class ConnectionLostCheckerService extends ScheduledThreadPoolExecutor {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionLostCheckerService.class);\n    private static final int DEFAULT_THREAD_POOL_SIZE = 1;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT = 60;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT = TimeUnit.SECONDS;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_VALUE = DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT;\n    private static final long DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT_VALUE = DEFAULT_THREAD_POOL_SHUTDOWN_TIMEOUT_UNIT;\n    private static final long DEFAULT_"}, {"ID": 503, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); } \nResponse:", "ground_truth": "This default implementation does not do anything. Go ahead and overwrite it.\n\n@see org.java_websocket.WebSocketListener#onWebsocketHandshakeReceivedAsServer(WebSocket, Draft, ClientHandshake)", "predict": " @Override public WebSocket handshake( FullHttpRequest request, HttpHeaders headers, int maxFramePayloadLength, int maxHeaderSize, int maxInitialLineLength, ChannelPromise promise ) { return new WebSocketServerHandshaker13( \"ws\" ).handshake( request, headers, maxFramePayloadLength, maxHeaderSize, maxInitialLineLength, promise ); }\n\n}\n"}, {"ID": 504, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void onWebsocketPing( WebSocket conn, Framedata f ) { conn.sendFrame( new PongFrame( (PingFrame)f ) ); } \nResponse:", "ground_truth": "This default implementation will send a pong in response to the received ping.\nThe pong frame will have the same payload as the ping frame.\n\n@see org.java_websocket.WebSocketListener#onWebsocketPing(WebSocket, Framedata)", "predict": " @Override public void onWebsocketPong( WebSocket conn, Framedata f ) { } \nResp @Override public void onWebsocketClose( WebSocket conn, int code, String reason, boolean remote ) { } \nResp @Override public void onWebsocketError( WebSocket conn, Exception ex ) { } \nResp @Override public void onWebsocketMessage( WebSocket conn, String message ) { } \nResp @Override public void onWebsocketOpen( WebSocket conn, Handshakedata d ) { } \n*/\n\npublic class WebSocketServer {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(WebSocketServer.class.getName());\n\t\n\tprivate static final int MAX_CONTENT_LENGTH = 1024 * 1024 * 10;\n\t\n\tprivate static final int MIN_CONTENT_LENGTH = 1024 * 1024 * 2;\n\t\n\tprivate static final int RECON"}, {"ID": 505, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop( int timeout ) throws InterruptedException { if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections return; } List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList<WebSocket>( connections ); } for( WebSocket ws : socketsToClose ) { ws.close( CloseFrame.GOING_AWAY ); } wsf.close(); synchronized ( this ) { if( selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join( timeout ); } } } \nResponse:", "ground_truth": "Closes all connected clients sockets, then closes the underlying\nServerSocketChannel, effectively killing the server socket selectorthread,\nfreeing the port the server was bound to and stops all internal workerthreads.\n\nIf this method is called before the server is started it will never start.\n\n@param timeout\nSpecifies how many milliseconds the overall close handshaking may take altogether before the connections are closed without proper close handshaking.\n\n@throws InterruptedException Interrupt", "predict": "\n\n*/\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_17;\nimport org.java_websocket.exceptions.InvalidDataException;\nimport org.java_websocket.exceptions.InvalidHandshakeException;\nimport org.java_websocket.exceptions.WebsocketNotConnectedException;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.handshake.Handshakedata;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java"}, {"ID": 506, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getPort() { int port = getAddress().getPort(); if( port == 0 && server != null ) { port = server.socket().getLocalPort(); } return port; } \nResponse:", "ground_truth": "Gets the port number that this server listens on.\n\n@return The port number.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 507, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while ( !iqueue.isEmpty() ) { conn = iqueue.remove( 0 ); WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() ); ByteBuffer buf = takeBuffer(); try { if( SocketChannelIOHelper.readMore( buf, conn, c ) ) iqueue.add( conn ); if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } } } \nResponse:", "ground_truth": "Do an additional read\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": "\npublic void doAdditionalWrite( WrappedByteChannel channel, ByteBuffer buffer ) throws IOException { if( buffer.hasRemaining() ) { WrappedByteChannel c = ( (WrappedByteChannel) channel ); ByteBuffer buf = takeBuffer(); try { SocketChannelIOHelper.write( buf, c, buffer ); } catch ( IOException e ) { throw e; } finally { pushBuffer( buf ); } } } \npublic void setMaxBinaryMessageBufferSize( int max ) { this.maxBinaryMessageBufferSize = max; } \npublic int getMaxBinaryMessageBufferSize() { return this.maxBinaryMessageBufferSize; } \npublic void setMaxTextMessageBufferSize( int max ) { this.maxTextMessageBufferSize = max; } \npublic int getMaxTextMessageBufferSize() { return this.maxTextMessageBufferSize; } \npublic void setMaxIdleTime( int maxIdleTime ) { this.maxIdleTime = maxId"}, {"ID": 508, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if( !onConnect( key ) ) { key.cancel(); return; } SocketChannel channel = server.accept(); if(channel==null){ return; } channel.configureBlocking( false ); Socket socket = channel.socket(); socket.setTcpNoDelay( isTcpNoDelay() ); socket.setKeepAlive( true ); WebSocketImpl w = wsf.createWebSocket( this, drafts ); w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w )); try { w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() )); i.remove(); allocateBuffers( w ); } catch (IOException ex) { if( w.getSelectionKey() != null ) w.getSelectionKey().cancel(); handleIOException( w.getSelectionKey(), null, ex ); } } \nResponse:", "ground_truth": "Execute a accept operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@throws InterruptedException  thrown by taking a buffer\n@throws IOException if an error happened during accept", "predict": "\npublic void onConnect(SelectionKey key) throws IOException {\n}\npublic void onMessage(SelectionKey key, WebSocketMessage m) throws IOException {\n}\npublic void onClose(SelectionKey key, WebSocketMessage m) {\n}\npublic void onError(SelectionKey key, Throwable t) {\n}\npublic void onStart() {\n}\npublic void onStop() {\n}\npublic void onIdle() {\n}\npublic void onMessage(byte[] data, int offset, int length) {\n}\npublic void onMessage(byte[] data, int offset, int length, boolean last) {\n}\npublic void onMessage(ByteBuffer data) {\n}\npublic void onMessage(ByteBuffer data, boolean last) {\n}\npublic void onMessage(String data) {\n}\npublic void onMessage(String data, boolean last) {\n}\npublic void onMessage(byte[] data, int offset, int length"}, {"ID": 509, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if(conn.getChannel() == null){ key.cancel(); handleIOException( key, conn, new IOException() ); return false; } try { if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) { if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); i.remove(); if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) { iqueue.add( conn ); } } else { pushBuffer(buf); } } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } return true; } \nResponse:", "ground_truth": "Execute a read operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@return true, if the read was successful, or false if there was an error\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " private void handleIOException(SelectionKey key, WebSocket conn, IOException ex) { try { SelectionKeyUtil.cancel(key); SelectionKeyUtil.close(key, ex); conn.close( CloseFrame.ABNORMAL_CLOSE, ex.getMessage() ); } catch (IOException e) { e.printStackTrace(); } } \n\n}\n"}, {"ID": 510, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doWrite(SelectionKey key) throws IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) { if( key.isValid() ) { key.interestOps(SelectionKey.OP_READ); } } } \nResponse:", "ground_truth": "Execute a write operation\n@param key the selectionkey to write on\n@throws IOException if an error happened during batch", "predict": "\n\n*/\n\npublic class WebSocketImpl extends WebSocket {\n    private final WebSocketClientHandshaker handshaker;\n    private final URI uri;\n    private final List<WebSocketChannel> channels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> closeChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverConnectedChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientConnectedChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> serverCloseChannels = new ArrayList<WebSocketChannel>();\n    private final List<WebSocketChannel> clientCloseChannels = new"}, {"ID": 511, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doSetupSelectorAndServerThread() { selectorthread.setName( \"WebSocketSelector-\" + selectorthread.getId() ); try { server = ServerSocketChannel.open(); server.configureBlocking( false ); ServerSocket socket = server.socket(); socket.setReceiveBufferSize( WebSocketImpl.RCVBUF ); socket.setReuseAddress( isReuseAddr() ); socket.bind( address ); selector = Selector.open(); server.register( selector, server.validOps() ); startConnectionLostTimer(); for( WebSocketWorker ex : decoders ){ ex.start(); } onStart(); } catch ( IOException ex ) { handleFatal( null, ex ); return false; } return true; } \nResponse:", "ground_truth": "Setup the selector thread as well as basic server settings\n@return true, if everything was successful, false if some error happened", "predict": "\n\n*/\n\npublic class WebSocketWorker implements Runnable {\n    private final WebSocketClientHandler handler;\n    private final WebSocketClient client;\n    private final WebSocketDecoderRx decoder;\n    private final WebSocketEncoderRx encoder;\n    private final WebSocketDecoderRx.FrameProcessor processor;\n    private final WebSocketEncoderRx.FrameProcessor frameProcessor;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult result;\n    private final WebSocketEncoderRx.FrameProcessor.FrameProcessorResult frameResult;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult.FrameProcessorResultHandler handler;\n    private final WebSocketEncoderRx.FrameProcessor.FrameProcessorResult.FrameProcessorResultHandler frameHandler;\n    private final WebSocketDecoderRx.FrameProcessor.FrameProcessorResult.FrameProcessor"}, {"ID": 512, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doEnsureSingleThread() { synchronized ( this ) { if( selectorthread != null ) throw new IllegalStateException( getClass().getName() + \" can only be started once.\" ); selectorthread = Thread.currentThread(); if( isclosed.get() ) { return false; } } return true; } \nResponse:", "ground_truth": "The websocket server can only be started once\n@return true, if the server can be started, false if already a thread is running", "predict": "\n\n*/\n\npublic class SingleThreadedSelector extends Selector {\n    private final Selector selector;\n    private final AtomicBoolean isclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselecting = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthread = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopen = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopenclosed = new AtomicBoolean(false);\n    private final AtomicBoolean isselectingthreadopenopenopen = new Atomic"}, {"ID": 513, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doServerShutdown() { stopConnectionLostTimer(); if( decoders != null ) { for( WebSocketWorker w : decoders ) { w.interrupt(); } } if( selector != null ) { try { selector.close(); } catch ( IOException e ) { log.error( \"IOException during selector.close\", e ); onError( null, e ); } } if( server != null ) { try { server.close(); } catch ( IOException e ) { log.error( \"IOException during server.close\", e ); onError( null, e ); } } } \nResponse:", "ground_truth": "Clean up everything after a shutdown", "predict": "\n\n*/\n\npublic class WebSocketWorker extends Thread {\n    private final WebSocketServer server;\n    private final Selector selector;\n    private final WebSocketFactory factory;\n    private final Map<WebSocket, Set<WebSocketWorker>> connections = new HashMap<WebSocket, Set<WebSocketWorker>>();\n    private final Map<WebSocket, WebSocketWorker> workers = new HashMap<WebSocket, WebSocketWorker>();\n    private final Map<WebSocket, WebSocket> sockets = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverse = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverseConnections = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket, WebSocket> reverseConnections2 = new HashMap<WebSocket, WebSocket>();\n    private final Map<WebSocket,"}, {"ID": 514, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Socket getSocket( WebSocket conn ) { WebSocketImpl impl = (WebSocketImpl) conn; return ( (SocketChannel) impl.getSelectionKey().channel() ).socket(); } \nResponse:", "ground_truth": "Getter to return the socket used by this specific connection\n@param conn The specific connection\n@return The socket used by this connection", "predict": " Generate the method-level comment for the following java Code. Code: private void setSocket( WebSocket conn, SocketChannel channel ) { WebSocketImpl impl = (WebSocketImpl) conn; ((SocketChannel) impl.getSelectionKey().channel() ).socket().setSoTimeout( WEBSOCKET_TIMEOUT ); } \n */\n\npublic class WebSocketServer {\n\tpublic static void main(String[] args) throws Exception {\n\t\tint port = 8080;\n\t\tif (args.length > 0) {\n\t\t\tport = Integer.parseInt(args[0]);\n\t\t}\n\t\tnew WebSocketServer(port).run();\n\t}\n\n\tpublic WebSocketServer(int port) {\n\t\tthis.port = port;\n\t}\n\n\tpublic void run() {\n\t\tSystem.out.println(\"Starting WebSocketServer on port \" + port);\n\t\ttry {\n\t\t\tServerSocketChannel ssc = ServerSocketChannel.open();\n\t\t\tssc.configure"}, {"ID": 515, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); } \nResponse:", "ground_truth": "Send a byte array to a specific collection of websocket connections\n@param data the data to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": "\n\n*/\n\nimport java.util.Collection;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer."}, {"ID": 516, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); } \nResponse:", "ground_truth": "Send a text to a specific collection of websocket connections\n@param text the text to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Response is generated by the method doBroadcast(String text, Collection<WebSocket> clients)\n\n*/\n\npublic class Broadcast {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new WebSocket object\n\t\tWebSocket ws = new WebSocket();\n\t\t\n\t\t// Create a new WebSocketClient object\n\t\tWebSocketClient wsClient = new WebSocketClient();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer2 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer3 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer wsServer4 = new WebSocketServer();\n\t\t\n\t\t// Create a new WebSocketServer object\n\t\tWebSocketServer w"}, {"ID": 517, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doBroadcast(Object data, Collection<WebSocket> clients) { String sData = null; if (data instanceof String) { sData = (String)data; } ByteBuffer bData = null; if (data instanceof ByteBuffer) { bData = (ByteBuffer)data; } if (sData == null && bData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>(); for( WebSocket client : clients ) { if( client != null ) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, sData, bData); try { client.sendFrame( draftFrames.get( draft ) ); } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } } \nResponse:", "ground_truth": "Private method to cache all the frames to improve memory footprint and conversion time\n@param data the data to broadcast\n@param clients the clients to send the message to", "predict": "\n\n*/\n\npublic class WebSocketServer extends WebSocket implements Runnable {\n\n    private final int port;\n    private final List<WebSocket> connections = Collections.synchronizedList(new ArrayList<WebSocket>());\n    private final List<WebSocket> clients = Collections.synchronizedList(new ArrayList<WebSocket>());\n    private Thread serverThread;\n    private ServerSocketChannel server;\n    private Selector selector;\n    private Draft draft;\n    private final ObjectMapper mapper = new ObjectMapper();\n\n    public WebSocketServer(int port) {\n        this(port, null);\n    }\n\n    public WebSocketServer(int port, Draft draft) {\n        this.port = port;\n        this.draft = draft;\n    }\n\n    public void start() {\n        try {\n            server = ServerSocketChannel.open();\n            server.configureBlocking(false);\n            server.socket().bind(new"}, {"ID": 518, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { if( !draftFrames.containsKey( draft ) ) { List<Framedata> frames = null; if (sData != null) { frames = draft.createFrames( sData, false ); } if (bData != null) { frames = draft.createFrames( bData, false ); } if (frames != null) { draftFrames.put(draft, frames); } } } \nResponse:", "ground_truth": "Fills the draftFrames with new data for the broadcast\n@param draft The draft to use\n@param draftFrames The list of frames per draft to fill\n@param sData the string data, can be null\n@param bData the bytebuffer data, can be null", "predict": "\n\n*/\n\npublic class Draft_7_1_1 extends Draft {\n    public static final int METHOD_ID = 1;\n\n    public static final int REQUEST_ID = 1;\n\n    public static final String NAME = \"WebSocket\";\n\n    public static final String VERSION = \"7.1.1\";\n\n    public static final String DESCRIPTION = \"The WebSocket protocol provides a way to send and receive messages between a client and a server.\";\n\n    public static final String REFERENCE = \"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07\";\n\n    public static final int[] WEBSOCKET_VERSIONS = { 7, 8, 13 };\n\n    public static final int WEBSOCKET_VERSION_NOT_SET = 0;\n\n    public static final int WEBSOCKET_VERSION_DRAFT_7_1_1 = 7;\n\n    public static final int WEBSOCKET_"}, {"ID": 519, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } } \nResponse:", "ground_truth": "Transfer from one ByteBuffer to another ByteBuffer\n\n@param source the ByteBuffer to copy from\n@param dest   the ByteBuffer to copy to\n@return the number of transferred bytes", "predict": " public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } } \nResp public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fre"}, {"ID": 520, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JPAApi start() { jpaConfig .persistenceUnits() .forEach( persistenceUnit -> emfs.put( persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName))); return this; } \nResponse:", "ground_truth": "Initialise JPA entity manager factories.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 521, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return emf.createEntityManager(); } \nResponse:", "ground_truth": "Get a newly created EntityManager for the specified persistence unit name.\n\n@param name The persistence unit name", "predict": " ResponseEntity<EntityManager> em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return new ResponseEntity<EntityManager>(emf.createEntityManager(), HttpStatus.OK); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.PersistenceContext;\nimport javax.persistence.PersistenceContextType;\nimport javax.persistence.PersistenceUnit;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.crit"}, {"ID": 522, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void withTransaction(Consumer<EntityManager> block) { withTransaction( em -> { block.accept(em); return null; }); } \nResponse:", "ground_truth": "Run a block of code with a newly created EntityManager for the default Persistence Unit.\n\n@param block Block of code to execute", "predict": "\n\npublic void withTransaction(Consumer<EntityManager> block) {\n    withTransaction(em -> {\n        block.accept(em);\n        return null;\n    });\n}\n\n*/\n\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Transaction {\n\n    public static <T> T withTransaction(Consumer<EntityManager> block) {\n        return withTransaction(em -> {\n            block.accept(em);\n            return null;\n        });\n    }\n\n    public static <T> T withTransaction(Function<EntityManager, T> block) {\n        return withTransaction(em -> {\n            block.apply(em);\n            return null;\n        });\n    }\n\n    public static <T> T withTransaction(Supplier<T> block) {\n        return withTransaction(em -> {\n            block.get();\n            return null"}, {"ID": 523, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Seq<Object> convertArgsToScalaBuffer(final Object... args) { return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args)) .asScala() .toList(); } \nResponse:", "ground_truth": "Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate list\nif necessary\n\n@param args the message arguments\n@return scala type for message processing", "predict": " Response = convertArgsToScalaBuffer(args)\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaConverters {\n    public static List<Object> wrapArgsToListIfNeeded(Object... args) {\n        List<Object> list = new ArrayList<Object>();\n        for (Object arg : args) {\n            if (arg instanceof List) {\n                list.addAll((List) arg);\n            } else {\n                list.add(arg);\n            }\n        }\n        return list;\n    }\n\n    public static Seq<Object> asScalaBufferConverter(List<Object> list) {\n        return new Seq<Object>(list);\n    }\n}\n"}, {"ID": 524, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; } \nResponse:", "ground_truth": "Wraps arguments passed into a list if necessary.\n\nReturns the first value as is if it is the only argument and a subtype of `java.util.List`\nOtherwise, it calls Arrays.asList on args\n\n@param args arguments as a List", "predict": " @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SafeVarargs {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"Hello\");\n        list.add(\"World\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add(\"!\");\n        list.add"}, {"ID": 525, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, String key, Object... args) { Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(key, scalaArgs, lang); } \nResponse:", "ground_truth": "Translates a message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " public play.api.i18n.Lang messages(play.api.i18n.Lang lang, String key, Seq<Object> args) { return messages.apply(key, args, lang); } \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletionStage;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons."}, {"ID": 526, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) { Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala(); Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(keyArgs.toSeq(), scalaArgs, lang); } \nResponse:", "ground_truth": "Translates the first defined message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " public play.api.i18n.Lang lang; List<String> keys; Object[] args; \n\n*/\n\nimport java.util.List;\nimport java.util.Map;\n\nimport play.api.i18n.Lang;\nimport play.api.i18n.MessagesApi;\nimport scala.collection.JavaConverters;\nimport scala.collection.Seq;\n\npublic class Java_MessagesApi_Impl implements MessagesApi {\n    @Override\n    public String get(Lang lang, List<String> keys, Object... args) {\n        Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);\n        return Messages.apply(JavaConverters.asScalaBufferConverter(keys).asScala(), scalaArgs, lang);\n    }\n}\n"}, {"ID": 527, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); } \nResponse:", "ground_truth": "Check if a message key is defined.\n\n@param lang the message lang\n@param key the message key\n@return a Boolean", "predict": " public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); } \n\n*/\n\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.con"}, {"ID": 528, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given candidates.\n\nWill select a language from the candidates, based on the languages available, and fallback\nto the default language if none of the candidates are available.\n\n@param candidates the candidate languages\n@return the most appropriate Messages instance given the candidate languages", "predict": " public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); } \n\n*/\npackage play.api.i18n;\n\nimport scala.collection.Seq;\n\nimport java.util.List;\n\npublic class Messages {\n    public final Lang lang;\n    public final MessagesImpl impl;\n\n    public Messages(Lang lang, MessagesImpl impl) {\n        this.lang = lang;\n        this.impl = impl;\n    }\n\n    public Messages(Seq<Lang> candidates) {\n        this.lang = candidates.head();\n        this.impl = new MessagesImpl(this.lang, this);\n    }\n\n    public Messages preferred(Seq<Lang> candidates) {\n"}, {"ID": 529, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given request.\n\nWill select a language from the request, based on the languages available, and fallback to\nthe default language if none of the candidates are available.\n\n@param request the incoming request\n@return the preferred messages context for the request", "predict": " public play.api.i18n.Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); } \n\n*/\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Completion"}, {"ID": 530, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); } \nResponse:", "ground_truth": "Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.\n\n@param result the result where the lang will be set.\n@param lang the lang to set on the result\n@return a new result with the lang.", "predict": " public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the Java code for the following java Code. Code: public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); } \n\t\t\n\t\tString javaCode = \"public class JavaCodeGenerator { \" +\n\t\t\t\t\"public static void main(String[] args) { \" +\n\t\t\t\t\"Result result = new Result(); \" +\n\t\t\t\t\"Lang lang = new Lang(); \" +\n\t\t\t\t\"result.setLang(result, lang); \" +\n\t\t\t\t\"System.out.println(result.asJava()); \" +\n\t\t\t\t\"} \" +\n\t\t\t\t\"}\";\n\t\t\n\t\tSystem.out.println(javaCode);"}, {"ID": 531, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Add bindings from guiceable modules.\n\n@param modules the set of modules to bind\n@return a copy of this builder configured with those modules", "predict": " public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module) { return newBuilder(delegate.bindings(module)); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule... modules) { return newBuilder(delegate.bindings(module, Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule module1) { return newBuilder(delegate.bindings(module, module1)); } \nResp public final Self bindings(GuiceableModule module, GuiceableModule module1, GuiceableModule... modules) { return newBuilder(delegate.bindings(module, module1, Scala.varargs(modules))); } \nResp public final Self bindings(GuiceableModule module, Guice"}, {"ID": 532, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Add bindings from Play modules.\n\n@param modules the set of Guice modules whose bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.inject.Binding;\nimport play.api.inject.Module;\nimport scala.collection.JavaConverters;\n\npublic class Guiceable {\n    public static Module[] modules(Module... modules) {\n        List<Module> list = new ArrayList<Module>();\n        for (Module module : modules) {\n            list.add(module);\n        }\n        return list.toArray(new Module[list.size()]);\n    }\n\n    public static Binding[] bindings(Binding... bindings) {\n        List<Binding> list = new ArrayList<Binding>();\n        for (Binding binding : bindings) {\n            list.add(binding);\n        }"}, {"ID": 533, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Add Play bindings.\n\n@param bindings the set of play bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Guiceable {\n    public static final String[] DEFAULT_BINDINGS = new String[] {\n        \"play.api.inject.Binding<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$Tuple2<play.api.libs.Scala$T"}, {"ID": 534, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(GuiceableModule... modules) { return newBuilder(delegate.overrides(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override bindings using guiceable modules.\n\n@param modules the set of Guice modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(GuiceableModule module) { return newBuilder(delegate.overrides(module)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2) { return newBuilder(delegate.overrides(module1, module2)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3) { return newBuilder(delegate.overrides(module1, module2, module3)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3, GuiceableModule module4) { return newBuilder(delegate.overrides(module1, module2, module3, module4)); } \nResp public final Self overrides(GuiceableModule module1, GuiceableModule module2, GuiceableModule module3"}, {"ID": 535, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override bindings using Play modules.\n\n@param modules the set of Play modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.inject.Binding;\nimport play.api.inject.Module;\nimport scala.collection.JavaConverters;\n\npublic class Guiceable {\n    public static Module[] modules(Module... modules) {\n        List<Module> list = new ArrayList<Module>();\n        for (Module module : modules) {\n            list.add(module);\n        }\n        return list.toArray(new Module[list.size()]);\n    }\n\n    public static Binding[] bindings(Binding... bindings) {\n        List<Binding> list = new ArrayList<Binding>();\n        for (Binding binding : bindings) {\n            list.add(binding);\n"}, {"ID": 536, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override bindings using Play bindings.\n\n@param bindings a set of Play bindings that override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); } \n\n*/\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Overrides {\n    \n    /**\n     * The Guice bindings to use for the method.\n     * @return\n     */\n    public Guiceable.Binding<?>[] value();\n}\n"}, {"ID": 537, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); } \nResponse:", "ground_truth": "Disable modules by class.\n\n@param moduleClasses the module classes whose bindings should be disabled\n@return a copy of this builder configured to ignore the provided module classes", "predict": " public final Self disable(Class<?> moduleClass) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass))); } \nResp public final Self disable(Class<?> moduleClass, Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClasses))); } \nResp public final Self disable(Class<?> moduleClass, Collection<? extends Class<?>> moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClasses))); } \nResp public final Self disable(Class<?> moduleClass, Class<?> moduleClass1, Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClass), Scala.toSeq(moduleClass1), Scala.toSeq(moduleClasses)));"}, {"ID": 538, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \nResponse:", "ground_truth": "the\nmigration guide for more details.", "predict": " @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \n\n// TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \n\n// TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().add"}, {"ID": 539, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<Result> call( Request req) { // TODO: Make this method abstract after removing call(Context) return Context.safeCurrent() .map( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS)); Context.setCurrent(newCtx); return call(newCtx); }) .orElseGet( () -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents); ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>()); return call(ctx); }); } \nResponse:", "ground_truth": "", "predict": "\n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport static java.util.Optional.ofNullable;\n\npublic class Context {\n    private final Optional<Map<String, Object>> args;\n    private final Supplier<Map<String, Object>> contextComponents;\n\n    public Context(Optional<Map<String, Object>> args, Supplier<Map<String, Object>> contextComponents) {\n        this.args = args;\n        this.contextComponents = contextComponents;\n    }\n\n    public Context(Optional<Map<String, Object>> args) {\n        this(args, () -> new HashMap<>());\n    }\n\n    public Context(Supplier<Map<String, Object>> contextComponents) {\n        this(Optional.empty(), contextComponents);\n    }\n\n    public Context() {\n        this(Optional.empty"}, {"ID": 540, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \nResponse:", "ground_truth": "Retrieves a file relative to the application root path. This method returns an Optional, using\nempty if the file was not found.\n\n@param relativePath relative path of the file to fetch\n@return an existing file", "predict": " public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\n\npublic class JavaCodeGenerator {\n\n    public static void main(String[] args) {\n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \n        // TODO: Generate the method-level comment for the following java Code. Code: public Optional"}, {"ID": 541, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> Binding<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); } \nResponse:", "ground_truth": "Configure the scope for this binding.", "predict": " Response<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String JAVA_CODE_PREFIX = \"public class \";\n\tprivate static final String JAVA_CODE_SUFFIX = \" { } \";\n\t\n\tprivate static final String JAVA_CODE_PREFIX_WITH_ANNOTATION = \"public class \";\n\tprivate static final String JAVA_CODE_SUFFIX_WITH_ANNOTATION = \" { } \";\n\t\n\tprivate static final String JAVA_CODE_PREFIX_WITH_IMPORT = \"import \";\n\tprivate static final String JAVA_CODE_SUFFIX_WITH_IMPORT = \"; \";\n\t\n\tprivate static final String JAVA_CODE_P"}, {"ID": 542, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); } \nResponse:", "ground_truth": "Constructs a tuple of A,B\n\n@param a The a value\n@param b The b value\n@param  a's type\n@param  b's type\n@return The tuple", "predict": "\n\npublic static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tuple {\n    private List<Object> values;\n\n    public Tuple() {\n        values = new ArrayList<Object>();\n    }\n\n    public Tuple(Object... values) {\n        this.values = new ArrayList<Object>();\n        for (Object value : values) {\n            this.values.add(value);\n        }\n    }\n\n    public List<Object> getValues() {\n        return values;\n    }\n\n    public void setValues(List<Object> values) {\n        this.values = values;\n    }\n\n    public Object get(int index) {\n        return values.get(index);\n    }\n\n    "}, {"ID": 543, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); } \nResponse:", "ground_truth": "Constructs a tuple of A,B,C,D,E\n\n@param a The a value\n@param b The b value\n@param c The c value\n@param d The d value\n@param e The e value\n@param  a's type\n@param  b's type\n@param  c's type\n@param  d's type\n@param  e's type\n@return The tuple", "predict": "\n\npublic static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); } \n\n*/\n\npublic class Tuple5<A, B, C, D, E> {\n\tpublic final A a;\n\tpublic final B b;\n\tpublic final C c;\n\tpublic final D d;\n\tpublic final E e;\n\n\tpublic Tuple5(A a, B b, C c, D d, E e) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.d = d;\n\t\tthis.e = e;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \""}, {"ID": 544, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Executor toExecutor(ExecutionContext ec) { ExecutionContext prepared = ec.prepare(); if (prepared instanceof Executor) { return (Executor) prepared; } else { return prepared::execute; } } \nResponse:", "ground_truth": "Converts the execution context to an executor, preparing it first.\n\n@param ec the execution context.\n@return the Java Executor.", "predict": " Response<Executor>\n*/\n\npublic class Executor {\n    public static Response<Executor> toExecutor(ExecutionContext ec) {\n        ExecutionContext prepared = ec.prepare();\n        if (prepared instanceof Executor) {\n            return Response.success((Executor) prepared);\n        } else {\n            return Response.success(prepared::execute);\n        }\n    }\n}\n"}, {"ID": 545, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String name, String unitName) { return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given name and unit name.\n\n@param name the name for the entity manager factory\n@param unitName the persistence unit name as used in `persistence.xml`\n@return a default JPA configuration", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 546, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String n1, String u1, String n2, String u2) { return new DefaultJPAConfig( new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given names and unit names.\n\n@param n1 Name of the first entity manager factory\n@param u1 Name of the first unit\n@param n2 Name of the second entity manager factory\n@param u2 Name of the second unit\n@return a default JPA configuration with the provided persistence units.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class JPAConfigTest {\n\n\tprivate static EntityManagerFactory emf;\n\tprivate static EntityManager em;\n\tprivate static JPAConfig jpaConfig;\n\n\t@BeforeClass\n\tpublic static void setUpBeforeClass() throws Exception {\n\t\temf = Persistence.createEntityManagerFactory(\"test\");\n\t\tem = emf.createEntityManager();\n\t\tjpaConfig = new JPAConfig(em);\n\t}\n\n\t@AfterClass\n\tpublic"}, {"ID": 547, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig from(Map<String, String> map) { ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>(); for (Map.Entry<String, String> entry : map.entrySet()) { persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue())); } return new DefaultJPAConfig(persistenceUnits.build()); } \nResponse:", "ground_truth": "Create a default JPA configuration from a map of names to unit names.\n\n@param map Map of entity manager factory names to unit names\n@return a JPAConfig configured with the provided mapping", "predict": " ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id) { return new ResponseEntity<JPAConfig>(new JPAConfig(id), HttpStatus.OK); } \nResp ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id, @RequestParam(value = \"include\", required = false) String include) { return new ResponseEntity<JPAConfig>(new JPAConfig(id, include), HttpStatus.OK); } \nResp ResponseEntity<JPAConfig> getJPAConfig(@PathVariable(\"id\") String id, @RequestParam(value = \"include\", required = false) String include, @RequestParam(value = \"exclude\", required = false) String exclude) { return new ResponseEntity<JPAConfig>(new JPAConfig(id, include, exclude), HttpStatus.OK); } \nResp ResponseEntity"}, {"ID": 548, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<String, ByteString, NotUsed> string(String callbackName) { return Flow.of(String.class) .map( str -> { return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\"); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a Flow of escaped ByteString from a series of String elements. Calls out to Comet.flow\ninternally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Response.ok(ByteString.fromString(\"'Hello World'\")).build();\n\n*/\n\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.google.common.base.Preconditions;\n\nimport io.reactivex.Flowable;\nimport io.reactivex.Single;\nimport io.reactivex.SingleObserver;\nimport io.reactivex.SingleSource;\nimport io.reactivex.functions.Function3;\nimport io.reactivex.functions.Function4;\nimport io.reactivex.functions.Function5;\nimport io.reactivex.functions.Function6;\nimport io.reactivex.functions.Function7;\nimport io.reactivex.functions.Function8;\nimport io.reactivex.functions.Function9;\nimport io.reactivex.functions.FunctionN;\n"}, {"ID": 549, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) { return Flow.of(JsonNode.class) .map( json -> { return ByteString.fromString(Json.stringify(json)); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode. Calls out to\nComet.flow internally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Response.ok(ByteString.fromString(\"{\\\"foo\\\":\\\"bar\\\"}\"));\n\n*/\n\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.reflect.TypeToken;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\npublic class FlowTest {\n\n  @Test\n  public void testFlow() {\n    Flow<String"}, {"ID": 550, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) { validators.put(key, () -> constraintValidator); return this; } \nResponse:", "ground_truth": "Adds validator as a singleton.\n\n@param key the constraint validator type\n@param constraintValidator the constraint validator instance\n@param  the type of constraint validator implementation\n@return {@link MappedConstraintValidatorFactory} with the given constraint validator added.", "predict": " public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, Supplier<T> constraintValidator) { validators.put(key, constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator, T defaultConstraintValidator) { validators.put(key, () -> constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, Supplier<T> constraintValidator, T defaultConstraintValidator) { validators.put(key, constraintValidator); return this; } \nResp public <T extends ConstraintValidator<?, ?>>"}, {"ID": 551, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) { try { return key.getDeclaredConstructor().newInstance(); } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) { throw new RuntimeException(ex); } } \nResponse:", "ground_truth": "need to do so.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.run();\n    }\n\n    private void run() {\n        List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        list.add(\"e\");\n        list.add(\"f\");\n        list.add(\"g\");\n        list.add(\"h\");\n        list.add(\"i\");\n        list.add(\"j\");\n        list.add(\"k\");\n        list.add(\"l\");\n        list.add"}, {"ID": 552, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method getMatchingAccessibleMethod( final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { try { final Method method = cls.getMethod(methodName, parameterTypes); MemberUtils.setAccessibleWorkaround(method); return method; } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null; final Method[] methods = cls.getMethods(); for (final Method method : methods) { // compare name and parameters if (method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod(method); if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) { bestMatch = accessibleMethod; } } } if (bestMatch != null) { MemberUtils.setAccessibleWorkaround(bestMatch); } if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) { final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes(); final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType(); final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName(); final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName(); final String parameterTypeSuperClassName = parameterTypes[parameterTypes.length - 1].getSuperclass().getName(); if (!methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) { return null; } } return bestMatch; } \nResponse:", "ground_truth": "Finds an accessible method that matches the given name and has compatible parameters.\nCompatible parameters mean that every method parameter is assignable from the given parameters.\nIn other words, it finds a method with the given name that will take the parameters given.\n\nThis method can match primitive parameter by passing in wrapper classes. For example, a\n{@code Boolean} will match a primitive {@code boolean} parameter.\n\n@param cls find method in this class\n@param methodName find method with this name\n@param parameterTypes find method with most compatible parameters\n@return The accessible method", "predict": "\n\n*/\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MethodUtils {\n\n    public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n        try {\n            final Method method = cls.getMethod(methodName, parameterTypes);\n            MemberUtils.setAccessibleWorkaround(method);\n            return method;\n        } catch (final NoSuchMethodException e) {\n            // NOPMD - Swallow the exception\n        }\n        // search through all methods\n        final List<Method> methods = new ArrayList<Method>(Arrays.asList(cls.getMethods()));\n        final List<Method> matchingMethods = new ArrayList<Method>();\n        for (final Method method : methods) {\n            // compare"}, {"ID": 553, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } } \nResponse:", "ground_truth": "Invoked when a client error occurs, that is, an error in the 4xx series.\n\nThe base implementation calls onBadRequest, onForbidden, onNotFound, or onOtherClientError\ndepending on the HTTP status code.\n\n@param request The request that caused the client error.\n@param statusCode The error status code. Must be greater or equal to 400, and less than 500.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } } \nResp @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404)"}, {"ID": 554, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.badRequest( views.html.defaultpages.badRequest.render( request.method(), request.uri(), message, request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a bad request.\n\nReturns Results.badRequest (400) with the included template from {@code\nviews.html.defaultpages.badRequest} as the content.\n\n@param request The request that was bad.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjdu"}, {"ID": 555, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onForbidden(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a request that was forbidden.\n\nReturns Results.forbidden (401) with the included template from {@code\nviews.html.defaultpages.unauthorized} as the content.\n\n@param request The forbidden request.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>My first Spring Boot application</title>\n\n    <!-- Bootstrap -->\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com"}, {"ID": 556, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onNotFound(RequestHeader request, String message) { if (environment.isProd()) { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.notFound.render( request.method(), request.uri(), request.asScala()))); } else { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.devNotFound.render( request.method(), request.uri(), Some.apply(routes.get()), request.asScala()))); } } \nResponse:", "ground_truth": "Invoked when a handler or resource is not found.\n\nIf the environment's mode is production, then returns Results.notFound (404) with the\nincluded template from `views.html.defaultpages.notFound` as the content.\n\nOtherwise, Results.notFound (404) is rendered with {@code\nviews.html.defaultpages.devNotFound} template.\n\n@param request The request that no handler was found to handle.\n@param message A message, which is not used by the default implementation.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\">\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjdu"}, {"ID": 557, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return CompletableFuture.completedFuture(Results.internalServerError()); } } \nResponse:", "ground_truth": "Invoked when a server error occurs.\n\nBy default, the implementation of this method delegates to [[onProdServerError()]] when in\nprod mode, and [[onDevServerError()]] in dev mode. It is recommended, if you want Play's debug\ninfo on the error page in dev mode, that you override [[onProdServerError()]] instead of this\nmethod.\n\n@param request The request that triggered the server error.\n@param exception The server error.\n@return a CompletionStage containing the Result.", "predict": " @Override public Response onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return Response.serverError().build(); } } \nResp @Override public Response onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return Response.serverError()."}, {"ID": 558, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void logServerError(RequestHeader request, UsefulException usefulException) { logger.error( String.format( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException); } \nResponse:", "ground_truth": "Responsible for logging server errors.\n\nThe base implementation uses a SLF4J Logger. If a special annotation is desired for internal\nserver errors, you may want to use SLF4J directly with the Marker API to distinguish server\nerrors from application errors.\n\nThis can also be overridden to add additional logging information, eg. the id of the\nauthenticated user.\n\n@param request The request that triggered the server error.\n@param usefulException The server error.", "predict": " ResponseHeader response = new ResponseHeader(StatusCode.INTERNAL_SERVER_ERROR, \"Internal server error\");\n\n*/\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tHttpClient httpclient = new DefaultHttpClient();\n\t\tHttpGet httpget = new HttpGet(\"http://localhost:8080/test/test\");\n\t\t\n\t\ttry {\n\t\t\tHttpResponse response = httpclient.execute("}, {"ID": 559, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final UsefulException throwableToUsefulException(final Throwable throwable) { return HttpErrorHandlerExceptions.throwableToUsefulException( sourceMapper.sourceMapper(), environment.isProd(), throwable); } \nResponse:", "ground_truth": "Convert the given exception to an exception that Play can report more information about.\n\nThis will generate an id for the exception, and in dev mode, will load the source code for\nthe code that threw the exception, making it possible to report on the location that the\nexception was thrown from.", "predict": " Response.ok().entity(throwableToUsefulException(throwable)).build();\n\n}\n\n}\n"}, {"ID": 560, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in dev mode when a server error occurs. Note that this method is where the URL set by\nplay.editor is used.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.devError}.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " public CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); } \n\n*/\n\npackage controllers.defaultpages;\n\nimport com.feth.play.module.pa.PlayAuthenticate;\nimport com.feth.play.module.pa.user.AuthUser;\nimport com.feth.play.module.pa.user.NoAuthUser;\nimport com.feth.play.module.pa.user.NoAuthUserFound;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUser;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUser$;\nimport com.feth.play.module.pa.user.UsernamePasswordAuthUserFactory;\n"}, {"ID": 561, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in prod mode when a server error occurs.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.error} template.\n\nOverride this rather than [[onServerError()]] if you don't want to change Play's debug\noutput when logging errors in dev mode.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": "\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>My first Spring Boot application</title>\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" rel=\"stylesheet\">\n"}, {"ID": 562, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); } \nResponse:", "ground_truth": "Create a BuildDocHandler that serves documentation from the given files, which could either be\ndirectories or jar files. The baseDir array must be the same length as the files array, and the\ncorresponding entry in there for jar files is used as a base directory to use resources from in\nthe jar.\n\n@param files The directories or jar files to serve documentation from.\n@param baseDirs The base directories for the jar files. Entries may be null.\n@return a BuildDocHandler.", "predict": " public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); } \n\n*/\n"}, {"ID": 563, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectory(File directory) { FileRepository repo = new FilesystemRepository(directory); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given directory by wrapping a\nFilesystemRepository.\n\n@param directory The directory to serve the documentation from.", "predict": " Response is a generic type. It is used to return the result of a request.\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double unary minus operator.\n */\npublic class DoubleUnaryMinusOperatorTerm\n  extends GenericStackableOperatorTerm<Double>\n  implements DoubleOperator {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   */\n  public DoubleUnaryMinusOperatorTerm(Term<Double> base) {\n    super(base);\n"}, {"ID": 564, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) { return fromDirectoryAndJar(directory, jarFile, base, false); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Response is generated by the method.\n*/\n\npublic class BuildDocHandler {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString base = \"\";\n\t\t\tif (args.length > 0) {\n\t\t\t\tbase = args[0];\n\t\t\t}\n\t\t\tFile directory = new File(\".\");\n\t\t\tJarFile jarFile = new JarFile(base);\n\t\t\tString[] files = directory.list();\n\t\t\tfor (String file : files) {\n\t\t\t\tif (file.endsWith(\".java\")) {\n\t\t\t\t\tString className = file.substring(0, file.length() - 5);\n\t\t\t\t\tString classNameWithPackage = className.replace(\"/\", \".\");\n\t\t\t\t\tSystem.out.println(\"Processing \" + classNameWithPackage);\n\t\t\t\t\tClass<?> clazz = Class.forName(classNameWithPackage);\n\t\t\t\t\tMethod[] methods = clazz.getMethods();\n\t\t\t\t\tfor (Method method : methods) {\n\t\t\t\t\t\tif"}, {"ID": 565, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.\n@param fallbackToJar Whether the doc handler should fall back to the jar repo for docs.", "predict": " Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); } \n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern"}, {"ID": 566, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromJar(JarFile jarFile, String base) { FileRepository repo = new JarRepository(jarFile, Option.apply(base)); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a\nJarRepository.\n\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Response to the request.\n\n*/\n\npackage com.github.dkellenb.formulaevaluator.term.operator.doubletype;\n\nimport com.github.dkellenb.formulaevaluator.FormulaEvaluatorConfiguration;\nimport com.github.dkellenb.formulaevaluator.term.Term;\nimport com.github.dkellenb.formulaevaluator.term.operator.GenericStackableOperatorTerm;\n\n/**\n * Double to String.\n */\npublic class DoubleToStringOperator extends GenericStackableOperatorTerm<String> {\n\n  /**\n   * C'tor.\n   *\n   * @param base base value\n   */\n  public DoubleToStringOperator(Term base) {\n    super(base);\n  }\n\n  @Override\n  public String calculateDefault(FormulaEvaluatorConfiguration conf,\n                                 Double v1, Double v2) {"}, {"ID": 567, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResponse:", "ground_truth": "Consumes the data.\n\nThis method should be used carefully, since if the source represents an ephemeral stream,\nthen the entity may not be usable after this method is invoked.\n\n@param mat the application's materializer.\n@return a CompletionStage holding the data", "predict": " public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \n\n// The following java Code is generated. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResp public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \n\n// The following java Code is generated. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResp public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), Byte"}, {"ID": 568, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given content.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); } \n\n*/\n\nimport java.util.Optional;\n\npublic class Strict {\n    private final ByteString content;\n    private final Optional<String> contentType;\n\n    public Strict(ByteString content, Optional<String> contentType) {\n        this.content = content;\n        this.contentType = contentType;\n    }\n\n    public ByteString content() {\n        return content;\n    }\n\n    public Optional<String> contentType() {\n        return contentType;\n    }"}, {"ID": 569, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromString(String content, String charset) { return new Strict( ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given String.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " ResponseEntity<byte[]> fromString(String content, String charset) { return new ResponseEntity<byte[]>(ByteString.fromString(content, charset).toByteArray(), HttpStatus.OK); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class HttpEntity {\n    private final ByteString content;\n    private final Optional<String> contentType;\n\n    public HttpEntity(ByteString content, Optional<String> contentType) {\n        this.content = content;\n        this.contentType = contentType;\n    }\n\n    public ByteString getContent() {\n        return content;\n    }\n\n    public Optional<String> getContentType() {\n        return contentType;\n    }\n\n    public static HttpEntity fromString(String content, String charset) {\n        return new HttpEntity(ByteString"}, {"ID": 570, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); } \nResponse:", "ground_truth": "Convert the given source of ByteStrings to a chunked entity.\n\n@param data The source.\n@param contentType The optional content type.\n@return The ByteStrings.", "predict": " ResponseEntity<byte[]> chunked(HttpEntity<ByteString> chunk, Optional<String> contentType) { return new ResponseEntity<>(chunk.getBody(), chunk.getHeaders(), chunk.getStatusCode()); } \n\n*/\n\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Chunked {\n    private final Supplier<HttpEntity<ByteString>> supplier;\n    private final Optional<String> contentType;\n\n    public Chunked(Supplier<HttpEntity<ByteString>> supplier, Optional<String> contentType) {\n        this.supplier = supplier;\n        this.contentType = contentType;\n    }\n\n    public static Chunked chunked(Supplier<HttpEntity<ByteString>> supplier, Optional<String> contentType) {\n        return new Chunked(supplier, contentType);\n    }\n\n    public static"}, {"ID": 571, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content) { return status(status, content, JsonEncoding.UTF8); } \nResponse:", "ground_truth": "Generates a simple result with json content and UTF8 encoding.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content as a play-json object\n@return the result", "predict": " Response(int status, JsonNode content, JsonEncoding encoding) {\n    this.status = status;\n    this.content = content;\n    this.encoding = encoding;\n}\n\n*/\n\npackage com.github.fge.grappa.matchers;\n\nimport com.github.fge.grappa.matchers.base.Matcher;\nimport com.github.fge.grappa.matchers.base.MatcherType;\nimport com.github.fge.grappa.run.MatcherContext;\n\nimport java.util.Objects;\n\n/**\n * Matches a JSON node with a given name.\n */\npublic final class JsonNodeMatcher\n    extends Matcher\n{\n    private final String name;\n\n    public JsonNodeMatcher(final String name)\n    {\n        super(MatcherType.JSON_NODE);\n        this.name = Objects.requireNonNull(name"}, {"ID": 572, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content, JsonEncoding encoding) { if (content == null) { throw new NullPointerException(\"Null content\"); } return status(status).sendJson(content, encoding); } \nResponse:", "ground_truth": "Generates a simple result with json content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a play-json object\n@param encoding the encoding into which the json should be encoded\n@return the result", "predict": " Response.status(status).sendJson(content, encoding);\n\n*/\n\npackage com.example.mydemo.http.response;\n\nimport com.example.mydemo.http.HttpStatus;\nimport com.example.mydemo.http.JsonNode;\nimport com.example.mydemo.http.JsonEncoding;\nimport com.example.mydemo.http.JsonEncoder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderBuilder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext.JsonEncoderContextBuilder;\nimport com.example.mydemo.http.JsonEncoder.JsonEncoderContext.JsonEncoderContextBuilder.JsonEncoderContextBuilderContext;\nimport com."}, {"ID": 573, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, byte[] content) { if (content == null) { throw new NullPointerException(\"Null content\"); } return new Result( status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty())); } \nResponse:", "ground_truth": "Generates a simple result with byte-array content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a byte array\n@return the result", "predict": " Response(int status, HttpEntity entity) { this.status = status; this.entity = entity; }\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.google.common.base.Optional;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport io.swagger.annotations.ApiResponse;\nimport io.swagger.annot"}, {"ID": 574, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, InputStream content, long contentLength) { return status(status).sendInputStream(content, contentLength); } \nResponse:", "ground_truth": "Generates a chunked result.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the input stream containing data to chunk over\n@param contentLength the length of the provided content in bytes.\n@return the result", "predict": " Response.status(status).sendInputStream(content, contentLength);\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.ResponseHandler;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class HttpClient {\n\t\n\tprivate static final AtomicInteger threadId = new AtomicInteger"}, {"ID": 575, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, File content) { return status(status, content, StaticFileMimeTypes.fileMimeTypes()); } \nResponse:", "ground_truth": "Generates a result with file contents.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the file to send\n@return the result", "predict": "\n\npublic static Result status(int status, File content, MimeTypes mimeTypes) {\n    return status(status, content, mimeTypes, null);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType) {\n    return status(status, content, mimeTypes, contentType);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType) {\n    return status(status, content, mimeTypes, contentType, null);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType, String contentDisposition) {\n    return status(status, content, mimeTypes, contentType, contentDisposition);\n}\n\npublic static Result status(int status, File content, MimeTypes mimeTypes, String contentType, String contentDisposition) {\n    return status(status, content"}, {"ID": 576, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private User findById(Long id) { if (id > 3) return null; User user = new User(); user.id = id; user.name = \"User \" + String.valueOf(id); return user; } \nResponse:", "ground_truth": "designed to be lightweight operation", "predict": "\n\npublic User findById(Long id) {\n    if (id > 3) return null;\n    User user = new User();\n    user.id = id;\n    user.name = \"User \" + String.valueOf(id);\n    return user;\n}\n\n*/\n\npublic class JavaCodeGenerator {\n    public static void main(String[] args) {\n        String className = \"User\";\n        String methodName = \"findById\";\n        String methodReturnType = \"User\";\n        String methodParameters = \"Long id\";\n        String methodComment = \"\";\n        String methodBody = \"\";\n        String methodBodyComment = \"\";\n        String methodBodyComment2 = \"\";\n        String methodBodyComment3 = \"\";\n        String methodBodyComment4 = \"\";\n        String methodBodyComment5 = \"\";\n        String methodBodyComment6 = \"\";\n        String methodBodyComment7 = \"\";\n        String methodBodyComment"}, {"ID": 577, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); } \nResponse:", "ground_truth": "Select a preferred language, given the list of candidates.\n\nWill select the preferred language, based on what languages are available, or return the\ndefault language if none of the candidates are available.\n\n@param candidates The candidate languages\n@return The preferred language", "predict": " Resp public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.spark.SparkConf;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.api.java.function.Function;\nimport org.apache.spark.api.java.function.PairFunction;\nimport org.apache.spark.mllib.linalg.Vectors;\nimport org.apache.spark.mllib.regression.LabeledPoint;\nimport org.apache.spark.mllib.tree.RandomForest;"}, {"ID": 578, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); } \nResponse:", "ground_truth": "Append a unique identifier to the URL.\n\n@return a copy if this call with a unique identifier to this url", "predict": " public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); } \n\n*/\n\npackage play.api.mvc;\n\nimport java.util.concurrent.CompletionStage;\n\nimport play.mvc.Http.Request;\nimport play.mvc.Result;\n\n/**\n * The Call class represents a request to a controller method.\n *\n * @author Michael Lavelle\n */\npublic class Call {\n\n    /**\n     * The method to call.\n     */\n    public final String method;\n\n    /**\n     * The URL to call.\n     */\n    public final String url;\n\n    /**\n     * The fragment to call.\n     */\n    public final String fragment;\n\n    /**\n     * The request.\n     */\n    public final Request request;\n\n    /**\n     * The result.\n     */\n    public final CompletionStage<"}, {"ID": 579, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); } \nResponse:", "ground_truth": "Returns a new Call with the given fragment.\n\n@param fragment the URL fragment\n@return a copy of this call that contains the fragment", "predict": " public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); } \n\n*/\n\npackage play.api.mvc;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation is used to mark a method as a controller method.\n *\n * @see Controller\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Controller {\n    /**\n     * The controller method name.\n     */\n    String value();\n}\n"}, {"ID": 580, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String absoluteURL(Http.Request request) { return absoluteURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an absolute URL.\n\n@param request used to identify the host and protocol that should base this absolute URL\n@return the absolute URL string", "predict": " Response.ok()\n\n*/\n\npackage com.example.android.sunshine.app;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.text.TextUtils;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n/**\n * Created by karan on 9/30/15.\n */\npublic class Utility {\n    public static String getPreferredLocation(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context.getString(R.string.pref_location_key),\n                context.getString(R.string.pref_location_default));\n    }\n\n    public static boolean isMetric(Context context) {\n        SharedPreferences prefs = PreferenceManager.get"}, {"ID": 581, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String webSocketURL(Http.Request request) { return webSocketURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an WebSocket URL.\n\n@param request used as the base for forming the WS url\n@return the websocket url string", "predict": " Response.ok()\n\n*/\n\npackage com.example.android.sunshine.app;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.text.TextUtils;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class Utility {\n    public static String getPreferredLocation(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context.getString(R.string.pref_location_key),\n                context.getString(R.string.pref_location_default));\n    }\n\n    public static boolean isMetric(Context context) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);\n        return prefs.getString(context"}, {"ID": 582, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new AbstractFunction1<Connection, BoxedUnit>() { public BoxedUnit apply(Connection connection) { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionRunnable.\n\n@param block a Java functional interface instance to wrap\n@return a scala function that wraps the given block", "predict": " Response<BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new Response<BoxedUnit>() { public BoxedUnit getBody() { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<Boxed"}, {"ID": 583, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) { return new AbstractFunction1<Connection, A>() { public A apply(Connection connection) { try { return block.call(connection); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionCallable.\n\n@param block a Java functional interface instance to wrap\n@param  the provided block's return type\n@return a scala function wrapping the given block", "predict": " Response<A> connectionFunction(final ConnectionCallable<A> block) { return new Response<A>() { public A get() { try { return block.call(); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; } \n\n*/\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<String> future = executor.submit(new Callable<String>() {"}, {"ID": 584, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) { return new Builder().mode(mode).http(port).build(block); } \nResponse:", "ground_truth": "Create a server for the router returned by the given block.\n\n@param block The block which creates a router.\n@param mode The mode the server will run on.\n@param port The port the server will run on.\n@return The running server.", "predict": "\n\n*/\n\npublic class Builder {\n    private Mode mode;\n    private int httpPort;\n    private Function<BuiltInComponents, Router> router;\n\n    public Builder mode(Mode mode) {\n        this.mode = mode;\n        return this;\n    }\n\n    public Builder http(int httpPort) {\n        this.httpPort = httpPort;\n        return this;\n    }\n\n    public Builder router(Function<BuiltInComponents, Router> router) {\n        this.router = router;\n        return this;\n    }\n\n    public Server build(Function<BuiltInComponents, Router> router) {\n        return new Server(mode, httpPort, router);\n    }\n}\n"}, {"ID": 585, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts an object to JsonNode.\n\n@param data Value to convert in Json.\n@return the JSON node.", "predict": " public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleComparator;\nimport org.apache.commons.lang3.tuple.TripleFactory;\nimport org.apache.commons.lang3.tuple.TripleImpl;\nimport org.apache.commons.lang3.tuple.TripleImpl.Tri"}, {"ID": 586, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts a JsonNode to a Java value\n\n@param  the type of the return value.\n@param json Json value to convert.\n@param clazz Expected Java value type.\n@return the return value.", "predict": " public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\npublic class JsonUtils {\n\n\tpublic static <T> T fromJson(JsonNode json, Class<T> clazz) {\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\ttry {\n\t\t\treturn mapper.treeToValue("}, {"ID": 587, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(String src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON string.\n@return the JSON node.", "predict": " Response(JsonNode node) { this.node = node; }\n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.utils.URLEncodedUtils;\nimport org.apache.http.impl.client"}, {"ID": 588, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a InputStream representing a json, and return it as a JsonNode.\n\n@param src the JSON input stream.\n@return the JSON node.", "predict": " public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \n\n*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonMappingException;"}, {"ID": 589, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relative(String startPath, String targetPath) { // If the start and target path's are the same then link to the current directory if (startPath.equals(targetPath)) { return CURRENT_DIR; } String[] start = toSegments(canonical(startPath)); String[] target = toSegments(canonical(targetPath)); // If start path has no trailing separator (a \"file\" path), then drop file segment if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1); // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = \"\"; if (!targetPath.endsWith(SEPARATOR)) { targetFile = target[target.length - 1]; target = Arrays.copyOfRange(target, 0, target.length - 1); } // Work out how much of the filepath is shared by start and path. String[] common = commonPrefix(start, target); String[] parents = toParentDirs(start.length - common.length); int relativeStartIdx = common.length; String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length); String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length); System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length); // If this is not a sibling reference append a trailing / to path String trailingSep = \"\"; if (relativePath.length > 0) trailingSep = SEPARATOR; return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR)) + trailingSep + targetFile; } \nResponse:", "ground_truth": "Create a path to targetPath that's relative to the given startPath.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        String startPath = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test\\\\\";\n        String targetPath = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test\\\\\";\n        String relativePath = \"\";\n        String targetFile = \"\";\n        String[] start = toSegments(canonical(startPath));\n        String[] target = toSegments(canonical(targetPath));\n        String[] common = commonPrefix(start, target);\n        String[] parents = toParentDirs(start.length - common.length);\n        int relative"}, {"ID": 590, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String canonical(String url) { String[] urlPath = toSegments(url); Stack<String> canonical = new Stack<>(); for (String comp : urlPath) { if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue; if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp); else canonical.pop(); } String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\"; String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\"; return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep; } \nResponse:", "ground_truth": "Create a canonical path that does not contain parent directories, current directories, or\nsuperfluous directory separators.", "predict": "\n\npublic static String canonical(String url) {\n    String[] urlPath = toSegments(url);\n    Stack<String> canonical = new Stack<>();\n    for (String comp : urlPath) {\n        if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue;\n        if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp);\n        else canonical.pop();\n    }\n    String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\";\n    String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\";\n    return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep;\n}\n\npublic static String canonical(String url) {\n    String[] urlPath = toSegments(url"}, {"ID": 591, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Converts a set of constraints to human-readable values. Does not guarantee the order of the\nreturned constraints.\n\nThis method calls {@code displayableConstraint} under the hood.\n\n@param constraints the set of constraint descriptors.\n@return a list of pairs of tuples assembled from displayableConstraint.", "predict": "\n\npublic static List<Tuple<String, List<Object>>> displayableConstraint(ConstraintDescriptor<?> constraint) {\n    return constraint.getAnnotation().annotationType().isAnnotationPresent(Display.class) ? constraint.getAnnotation().annotationType().getAnnotation(Display.class).value() : Collections.emptyList();\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class DisplayableConstraint {\n\n    public static List<Tuple<String, List<Object>>> displayableConstraint(ConstraintDescriptor<?> constraint) {\n        return constraint.getAnnotation().annotationType().isAnnotationPresent(Display.class) ? constraint.getAnnotation().annotationType().getAnnotation(Display.class).value() : Collections.emptyList();\n    }\n\n    public static List<T"}, {"ID": 592, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Tuple<String, List<Object>> displayableConstraint( ConstraintDescriptor<?> constraint) { final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class); return Tuple( displayAnnotation.name(), Collections.unmodifiableList( Stream.of(displayAnnotation.attributes()) .map(attr -> constraint.getAttributes().get(attr)) .collect(Collectors.toList()))); } \nResponse:", "ground_truth": "Converts a constraint to a human-readable value.\n\n@param constraint the constraint descriptor.\n@return A tuple containing the constraint's display name and the constraint attributes.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.TripleA;\nimport org.apache.commons.lang3.tuple.TripleB;\nimport org.apache.commons.lang3.tuple.TripleC;\nimport org.apache.commons.lang3.tuple.TripleD;\nimport org.apache.commons.lang3.tuple.TripleE;\nimport org.apache.commons.lang3.tuple.TripleF;\nimport org.apache.commons."}, {"ID": 593, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResponse:", "ground_truth": "Creates a CompletionStage that returns either the input stage, or a futures.\n\nNote that timeout is not the same as cancellation. Even in case of futures, the given\ncompletion stage will still complete, even though that completed value is not returned.\n\n@param stage the input completion stage that may time out.\n@param amount The amount (expressed with the corresponding unit).\n@param unit The time Unit.\n@param  the completion's result type.\n@return either the completed future, or a completion stage that failed with futures.", "predict": " @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final FiniteDuration duration) { requireNonNull(stage, \"Null stage\"); requireNonNull(duration, \"Null duration\"); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResp @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final Duration duration) { requireNonNull(stage, \"Null stage\"); requireNonNull(duration, \"Null duration\"); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResp @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit, final Executor executor) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); require"}, {"ID": 594, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAssignable( Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) { return false; } if (classArray == null) { classArray = EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } \nResponse:", "ground_truth": "Checks if an array of Classes can be assigned to another array of Classes.\n\nThis method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in\nthe input arrays. It can be used to check if a set of arguments (the first parameter) are\nsuitably compatible with a set of method parameter types (the second parameter).\n\nUnlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into\naccount widenings of primitive classes and {@code null}s.\n\nPrimitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code\ndouble}. This method returns the correct result for these cases.\n\n{@code Null} may be assigned to any reference type. This method will return {@code true} if\n{@code null} is passed in and the toClass is non-primitive.\n\nSpecifically, this method tests whether the type represented by the specified {@code Class}\nparameter can be converted to the type represented by this {@code Class} object via an identity\nconversion widening primitive or widening reference conversion. See The Java Language Specification, sections\n5.1.1, 5.1.2 and 5.1.4 for details.\n\n@param classArray the array of Classes to check, may be {@code null}\n@param toClassArray the array of Classes to try to assign into, may be {@code null}\n@param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n@return {@code true} if assignment possible", "predict": "\n\npublic static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n\tif (classArray == null) {\n\t\tclassArray = EMPTY_CLASS_ARRAY;\n\t}\n\tif (toClassArray == null) {\n\t\ttoClassArray = EMPTY_CLASS_ARRAY;\n\t}\n\tif (classArray.length != toClassArray.length) {\n\t\treturn false;\n\t}\n\tfor (int i = 0; i < classArray.length; i++) {\n\t\tif (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\npublic static boolean isAssignable(Class<?> clazz, Class<?> toClass, boolean autoboxing) {\n\tif (clazz == null) {\n"}, {"ID": 595, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Date parseCRONExpression(String cron) { try { return new CronExpression(cron).getNextValidTimeAfter(new Date()); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Parses a CRON expression.\n\n@param cron the CRON String\n@return the next Date that satisfies the expression", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CronExpression {\n    private static final String MINUTE = \"\\\\d{1,2}\";\n    private static final String HOUR = \"\\\\d{1,2}\";\n    private static final String DAY_OF_MONTH = \"\\\\d{1,2}\";\n    private static final String MONTH = \"\\\\d{1,2}\";\n    private static final String YEAR = \"\\\\d{4}\";\n    private static final String WEEKDAY = \"\\\\w\";\n    private"}, {"ID": 596, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long cronInterval(String cron, Date date) { try { return new CronExpression(cron).getNextInterval(date); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Compute the number of milliseconds between the next valid date and the one after.\n\n@param cron the CRON String\n@param date the date to start search\n@return the number of milliseconds between the next valid date and the one after, with an\ninvalid interval between", "predict": "\n\n*/\n\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone"}, {"ID": 597, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); } \nResponse:", "ground_truth": "Creates WS client manually from configuration, internally creating a new instance of\nAsyncHttpClient and managing its own thread pool.\n\nThis client is not managed as part of Play's lifecycle, and must be closed by calling\nws.close(), otherwise you will run into memory leaks.\n\n@param config a config object, usually from AhcWSClientConfigFactory\n@param cache if not null, provides HTTP caching.\n@param materializer an Akka materializer\n@return a new instance of AhcWSClient.", "predict": " public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); } \n\n*/\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.Http"}, {"ID": 598, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder builder(ApplicationLoader.Context context) { return initialBuilder .in(context.environment()) .loadConfig(context.initialConfig()) .overrides(overrides(context)); } \nResponse:", "ground_truth": "Construct a builder to use for loading the given context.\n\n@param context the context the returned builder will load\n@return the builder", "predict": " Response.ok().build();\n\n@Override\npublic Response.ResponseBuilder responseBuilder() {\n\treturn Response.ok();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status) {\n\treturn Response.status(status).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message) {\n\treturn Response.status(status).entity(message).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message, Object... args) {\n\treturn Response.status(status).entity(String.format(message, args)).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder(Response.Status status, String message, Throwable throwable) {\n\treturn Response.status(status).entity(message + \": \" + throwable.getMessage()).build();\n}\n\n@Override\npublic Response.ResponseBuilder responseBuilder"}, {"ID": 599, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); } \nResponse:", "ground_truth": "Generates a 501 NOT_IMPLEMENTED simple result.", "predict": " public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); } \n\n*/\n\npackage controllers\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/julienc91/heygo/app/models\"\n\t\"github.com/julienc91/heygo/app/utils\"\n)\n\n// TODO: Add a description of the controller here.\ntype TodoController struct {\n\t*utils.BaseController\n}\n\n// TODO: Add a description of the controller here.\nfunc (c *TodoController) Index(w http.ResponseWriter, r *http.Request) {\n\t// TODO: Add a description of the controller here."}, {"ID": 600, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void session(String key, String value) { session().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the current session.\n\n@param key the key to set into the session\n@param value the value to set for key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " @Deprecated public static void session(String key, String value) { session().put(key, value); } \n\n*/\n\npublic class Session {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Create a new session\n\t\tSession session = new Session();\n\t\t\n\t\t// Set the session value\n\t\tsession.set(\"key\", \"value\");\n\t\t\n\t\t// Get the session value\n\t\tString value = session.get(\"key\");\n\t\t\n\t\t// Print the session value\n\t\tSystem.out.println(value);\n\t\t\n\t\t// Close the session\n\t\tsession.close();\n\t\t\n\t}\n\t\n\t// Set the session value\n\tpublic void set(String key, String value) {\n\t\t\n\t\t// Create a new session\n\t\tSession session = new Session();\n\t\t\n\t\t// Set the session value\n\t\tsession.set(key, value);\n\t\t\n\t\t// Close the session\n\t\tsession.close();\n"}, {"ID": 601, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void flash(String key, String value) { flash().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the flash scope.\n\n@param key the key to put into the flash scope\n@param value the value corresponding to key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " @Deprecated public static void flash(String key, String value) { flash().put(key, value); } \n\n*/\n\npublic class Flash {\n\t\n\tpublic static void put(String key, String value) {\n\t\t\n\t\tif (key == null || value == null) {\n\t\t\tthrow new IllegalArgumentException(\"key and value cannot be null\");\n\t\t}\n\t\t\n\t\tif (key.length() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"key cannot be empty\");\n\t\t}\n\t\t\n\t\tif (value.length() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"value cannot be empty\");\n\t\t}\n\t\t\n\t\tif (key.length() > 255) {\n\t\t\tthrow new IllegalArgumentException(\"key cannot be longer than 255 characters\");\n\t\t}\n\t\t\n\t\tif (value.length() > 255) {\n\t\t\tthrow new IllegalArgumentException(\"value cannot be longer than 255 characters\");\n\t\t}\n\t\t"}, {"ID": 602, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given instance of an annotation.\n\nThis can be used to specify bindings with annotations that have particular values.", "predict": " Response<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); } \n\n*/\n\npublic class BindingKey<T> {\n\t\n\tprivate final BindingKey<T> underlying;\n\t\n\tpublic BindingKey(BindingKey<T> underlying) {\n\t\tthis.underlying = underlying;\n\t}\n\t\n\tpublic BindingKey<T> asJava() {\n\t\treturn this;\n\t}\n\t\n\tpublic Response<T> asJava(Response<T> response) {\n\t\treturn response;\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance) {\n\t\treturn underlying.qualifiedWith(instance);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance, final Response<T> response) {\n\t\treturn underlying.qualifiedWith(instance, response);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation instance"}, {"ID": 603, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given annotation.\n\nFor example, you may have both a cached implementation, and a direct implementation of a\nservice. To differentiate between them, you may define a Cached annotation:\n\n{@code\nbindClass(Foo.class).qualifiedWith(Cached.class).to(FooCached.class),\nbindClass(Foo.class).to(FooImpl.class)\n\n...\n\nclass MyController {\n{@literal @}Inject\nMyController({@literal @}Cached Foo foo) {\n...\n}\n...\n}\n}\n\nIn the above example, the controller will get the cached {@code Foo} service.", "predict": " Response<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation); } \n\n*/\n\npublic class BindingKey<T> {\n\t\n\tprivate final BindingKey<T> underlying;\n\t\n\tpublic BindingKey(BindingKey<T> underlying) {\n\t\tthis.underlying = underlying;\n\t}\n\t\n\tpublic BindingKey<T> asJava() {\n\t\treturn new BindingKey<T>(underlying.asJava());\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Class<? extends Annotation> annotation) {\n\t\treturn underlying.qualifiedWith(annotation);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation annotation) {\n\t\treturn underlying.qualifiedWith(annotation);\n\t}\n\t\n\tpublic Response<T> qualifiedWith(final Annotation annotation, final Class<? extends Annotation> annotation2) {\n\t\treturn underlying.qualifiedWith"}, {"ID": 604, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given implementation class.\n\nThis class will be instantiated and injected by the injection framework.", "predict": " Response<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tprivate static final String JAVA_PACKAGE_PREFIX = \"java.lang.\";\n\tprivate static final String JAVA_PACKAGE_SUFFIX = \"\";\n\tprivate static final String JAVA_PACKAGE_SEPARATOR = \".\";\n\t\n\tprivate static final String JAVA_PACKAGE_PREFIX_WITH_SEPARATOR = JAVA_PACKAGE_PREFIX + JAVA_PACKAGE_SEPARATOR;\n\tprivate static final String JAVA_PACKAGE_SUFFIX_WITH_SEPARATOR = JAVA_PACKAGE_SUFFIX + JAVA_PACKAGE_SEPARATOR;\n\t\n\tprivate static final String J"}, {"ID": 605, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider instance.\n\nThis provider instance will be invoked to obtain the implementation for the key.", "predict": " Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResp Response<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResponse"}, {"ID": 606, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given instance.", "predict": " public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)); } \n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); } \n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)); } \n\t\t\n\t\t// Generate the Java code for the following java code.\n\t\t// Code: public <A extends T> Binding<T> to(final"}, {"ID": 607, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to another binding key.", "predict": " Response<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder, final Response.ResponseBuilder errorResponseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder, errorResponseBuilder); } \nResp Response<T> to(final BindingKey<? extends T> key, final Response.ResponseBuilder responseBuilder, final Response.ResponseBuilder errorResponseBuilder, final Response.ResponseBuilder errorResponseBuilder) { return underlying.to(key.asScala()).asJava(responseBuilder, errorResponseBuilder, errorResponseBuilder); } \nResp"}, {"ID": 608, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) { return underlying.toProvider(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider class.\n\nThe dependency injection framework will instantiate and inject this provider, and then\ninvoke its `get` method whenever an instance of the class is needed.", "predict": " public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response) { return underlying.toProvider(provider, response).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener) { return underlying.toProvider(provider, response, errorListener).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener, final Response.Listener<T> listener) { return underlying.toProvider(provider, response, errorListener, listener).asJava(); } \nResp public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider, final Response response, final Response.ErrorListener errorListener, final Response.Listener<T>"}, {"ID": 609, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Lang> availables(Application app) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables()); return availableLangs.stream().map(Lang::new).collect(toList()); } \nResponse:", "ground_truth": "Retrieve Lang availables from the application configuration.\n\n@param app the current application.\n@return the list of available Lang.", "predict": " public static play.libs.F.Promise<Result> index(Application app) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs, play.api.i18n.Lang lang) { return app.injector().instanceOf(play.libs.F.Promise.class); } \nResp public static play.libs.F.Promise<Result> index(Application app, play.api.i18n.Langs langs, play.api.i"}, {"ID": 610, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); } \nResponse:", "ground_truth": "Guess the preferred lang in the langs set passed as argument. The first Lang that matches an\navailable Lang wins, otherwise returns the first Lang available in this application.\n\n@param app the currept application\n@param availableLangs the set of langs from which to guess the preferred\n@return the preferred lang.", "predict": " public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); } \n\n*/\n\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.stream.Stream;\n\nimport play.api.i18n.Langs;\nimport play.api.i18n.Lang;\nimport scala.collection.Seq;\n\npublic class LangsJava {\n\n    public"}, {"ID": 611, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); } \nResponse:", "ground_truth": "Create an evolutions reader based on a simple map of database names to evolutions.\n\n@param evolutions The map of database names to evolutions.\n@return the evolutions reader.", "predict": " public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport play.api.db.evolutions.EvolutionsReader;\nimport play.api.db.evolutions.EvolutionsWriter;\nimport play.api.db.evolutions.EvolutionsWriter.Evolution;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType.EvolutionTypeEnum;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType.EvolutionTypeEnum.EvolutionTypeEnumBuilder;\nimport play.api.db.evolutions.EvolutionsWriter.EvolutionType."}, {"ID": 612, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); } \nResponse:", "ground_truth": "Create an evolutions reader for the default database from a list of evolutions.\n\n@param evolutions The list of evolutions.\n@return the evolutions reader.", "predict": " public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); } \n\n*/\n\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.SortedMap;\nimport java.util.SortedSet;"}, {"ID": 613, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cleanupEvolutions(Database database, boolean autocommit, String schema) { DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema); evolutions.evolve(evolutions.resetScripts(), autocommit); } \nResponse:", "ground_truth": "Cleanup evolutions for the given database.\n\nThis will run the down scripts for all the applied evolutions.\n\n@param database The database to apply the evolutions to.\n@param autocommit Whether autocommit should be used.\n@param schema The schema where all the play evolution tables are saved in", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.spark.SparkConf;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.api.java.function.Function;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.types.DataTypes;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\n\nimport scala.Tuple2;\n\npublic class DatabaseEvolutions {\n\t\n\tprivate static final String DATABASE_NAME = \"database\";\n"}, {"ID": 614, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); } \nResponse:", "ground_truth": "Set the initial configuration loader. Overrides the default or any previously configured\nvalues.\n\n@param load the configuration loader\n@return the configured application builder", "predict": " public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigValue;\nimport com.typesafe.config.ConfigValueType;\nimport com.typesafe.config.ConfigValueType.ValueType;\nimport com.typesafe.config.ConfigValueVisitor;\nimport com.typesafe.config.ConfigValueVisitor"}, {"ID": 615, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); } \nResponse:", "ground_truth": "Set the module loader. Overrides the default or any previously configured values.\n\n@param loader the configuration\n@return the configured application builder", "predict": " public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigValue;\nimport com.typesafe.config.ConfigValueType;\nimport com.typesafe.config.ConfigValueType.ValueType;\nimport com.typesafe.config.ConfigValueVisitor;\nimport com.typesafe.config"}, {"ID": 616, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override the module loader with the given guiceable modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Providers.Provider;\nimport com.google.inject.util.Providers.TypeLiteral;\nimport com.google.inject.util.Types;\n\nimport scala.collection.JavaConversions;\nimport scala.collection.imm"}, {"ID": 617, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(com.google.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Guice modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "\n\npublic GuiceApplicationBuilder load(Module... modules) {\n    return Guice.createInjector(modules);\n}\n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Guiceable {\n    public static Module modules(Module... modules) {\n        List<Module> list = new Array"}, {"ID": 618, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Play modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "\n\npublic GuiceApplicationBuilder load(Guiceable.Module... modules) {\n    return GuiceApplicationBuilder.load(modules);\n}\n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Module;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedType;\nimport com.google.inject.util.Types.WildcardType;\nimport com.google.inject.util.Types.Visitor;\nimport com.google.inject.util.Types.Visitor.VisitorException;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\n"}, {"ID": 619, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override the module loader with the given Play bindings.\n\n@param bindings the set of binding override\n@return an application builder that incorporates the overrides", "predict": " public GuiceApplicationBuilder load(Guiceable.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Binding;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Module;\nimport com.google.inject.Provider;\nimport com.google.inject.Provides;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types"}, {"ID": 620, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); } \nResponse:", "ground_truth": "Implementation of Self creation for GuiceBuilder.\n\n@return the application builder", "predict": " public GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); } \n\n*/\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Modules;\nimport com.google.inject.util.Providers;\nimport com.google.inject.util.Types;\nimport com.google.inject.util.Types.ParameterizedTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl;\nimport com.google.inject.util.Types.WildcardTypeImpl.Substitution;\nimport com.google.inject.util.Types.WildcardTypeImpl.TypeVar;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect."}, {"ID": 621, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); encode(buf, cookie); return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Cookie header value.\n\n@param cookie specified the cookie\n@return a Rfc6265 style Cookie header value", "predict": " public String decode(String cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); decode(buf, cookie); return stripLeadingSeparator(buf); } \n\n*/\n\npublic class CookieEncoder {\n    private static final String BOUNDARY = \"7d87f1b8cfa9c\";\n\n    public static String encode(Cookie cookie) {\n        if (cookie == null) {\n            throw new NullPointerException(\"cookie\");\n        }\n\n        StringBuilder buf = new StringBuilder();\n        encode(buf, cookie);\n        return buf.toString();\n    }\n\n    public static void encode(StringBuilder buf, Cookie cookie) {\n        if (cookie == null) {\n            throw new NullPointerException(\"cookie\");\n        }\n\n        buf.append(\"Cookie: \");\n        buf.append(cookie.getName());\n        buf.append(\""}, {"ID": 622, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em() { Deque<EntityManager> ems = this.emStack(true); if (ems.isEmpty()) { Http.Context.safeCurrent() .map( ctx -> { throw new RuntimeException( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\"); }) .orElseGet( () -> { throw new RuntimeException( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\"); }); } return ems.peekFirst(); } \nResponse:", "ground_truth": "Get the default EntityManager for this thread.\n\n@throws RuntimeException if no EntityManager is bound to the current Http.Context or the\ncurrent Thread.\n@return the EntityManager", "predict": " public EntityManager em() { return em(); }\n\n*/\n\npackage controllers;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport com.google.inject.name.Named;\nimport controllers.deadbolt.DeadboltHandler;\nimport controllers.deadbolt.Restricted;\nimport models.User;\nimport play.Logger;\nimport play.api.libs.json.JsObject;\nimport play.api.libs.json.JsObjectApi;\nimport play.api.libs.json.JsValue;\nimport play.api.libs.json.JsValueApi;\nimport play.api.libs.json.JsValueConver"}, {"ID": 623, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Deque<EntityManager> emStack(boolean threadLocalFallback) { return Http.Context.safeCurrent() .map( context -> { Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER); if (emsObject != null) { return (Deque<EntityManager>) emsObject; } else { Deque<EntityManager> ems = new ArrayDeque<>(); context.args.put(CURRENT_ENTITY_MANAGER, ems); return ems; } }) .orElseGet( () -> { // Not a web request if (threadLocalFallback) { return this.get(); } else { throw new RuntimeException( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\"); } }); } \nResponse:", "ground_truth": "Get the EntityManager stack.\n\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.\n@return the queue of entity managers.", "predict": "\n\n*/\n\nimport java.util.Deque;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.collect.Queues;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClient;\nimport io.vertx.core.http.HttpClientOptions;\nimport io.vertx.core.http.HttpClientRequest;\nimport io"}, {"ID": 624, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } } \nResponse:", "ground_truth": "Pushes or pops the EntityManager stack depending on the value of the em argument. If em is\nnull, then the current EntityManager is popped. If em is non-null, then em is pushed onto the\nstack and becomes the current EntityManager.\n\n@param em the entity manager to push, if null then will pop one off the stack.\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.", "predict": " void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } } \n */\n\npublic class EmStack {\n\tprivate Deque<EntityManager> ems = new ArrayDeque<EntityManager>();\n\tprivate boolean threadLocalFallback = false;\n\t\n\tpublic EmStack(boolean threadLocalFallback) {\n\t\tthis.threadLocalFallback = threadLocalFallback;\n\t}\n\t\n\tpublic void push(EntityManager em) {\n\t\tems.push(em);\n\t}\n\t\n\tpublic EntityManager pop() {\n\t\treturn ems.pop();\n\t}\n\t\n\tpublic EntityManager"}, {"ID": 625, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) { return bypassWith( Flow.<In>create().map(splitter::apply), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), flow); } \nResponse:", "ground_truth": "Bypass the given flow using the given splitter function.\n\nIf the splitter function returns Left, they will go through the flow. If it returns Right,\nthey will bypass the flow.\n\nUses onlyFirstCanFinishMerge(2) by default.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow\n@param flow the original flow\n@param splitter the splitter function to use\n@return the flow with a bypass.", "predict": "\n\n*/\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport akka.NotUsed;\nimport akka.actor.ActorSystem;\nimport akka.stream.ActorMaterializer;\nimport akka.stream.javadsl.Flow;\nimport akka.stream.javadsl.Sink;\nimport akka.stream.javadsl.Source;\nimport akka.util.ByteString;\nimport scala.concurrent"}, {"ID": 626, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) { return splitter.via( Flow.fromGraph( GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true)); UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy); Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.left.isPresent()) { return x.left.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, Out, ?> collectOut = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.right.isPresent()) { return x.right.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel = play.api.libs.streams.AkkaStreams .<F.Either<FlowIn, Out>>ignoreAfterCancellation() .asJava(); // Normal flow builder .from(broadcast.out(0)) .via(builder.add(collectIn)) .via(builder.add(flow)) .toInlet(merge.in(0)); // Bypass flow, need to ignore downstream finish builder .from(broadcast.out(1)) .via(builder.add(blockCancel)) .via(builder.add(collectOut)) .toInlet(merge.in(1)); return new FlowShape<>(broadcast.in(), merge.out()); }))); } \nResponse:", "ground_truth": "Using the given splitter flow, allow messages to bypass a flow.\n\nIf the splitter flow produces Left, they will be fed into the flow. If it produces Right,\nthey will bypass the flow.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow.\n@param flow the original flow.\n@param splitter the splitter function.\n@param mergeStrategy the merge strategy (onlyFirstCanFinishMerge, ignoreAfterFinish,\nignoreAfterCancellation)\n@return the flow with a bypass.", "predict": "\n\n<pre>{@code\npublic static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith(Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) {\n  return splitter.via(Flow.fromGraph(GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create(builder -> {\n    UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true));\n    UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy);\n    Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala"}, {"ID": 627, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); } \nResponse:", "ground_truth": "Create a flow that is handled by an actor.\n\nMessages can be sent downstream by sending them to the actor passed into the props function.\nThis actor meets the contract of the actor returned by {@link\nakka.stream.javadsl.Source#actorRef}.\n\nThe props function should return the props for an actor to handle the flow. This actor will\nbe created using the passed in {@link akka.actor.ActorRefFactory}. Each message received will\nbe sent to the actor - there is no back pressure, if the actor is unable to process the\nmessages, they will queue up in the actors mailbox. The upstream can be cancelled by the actor\nterminating itself.\n\n@param  the In type parameter for a Flow\n@param  the Out type parameter for a Flow\n@param props A function that creates the props for actor to handle the flow.\n@param bufferSize The maximum number of elements to buffer.\n@param overflowStrategy The strategy for how to handle a buffer overflow.\n@param factory The Actor Factory used to create the actor to handle the flow - for example, an\nActorSystem.\n@param mat The materializer to materialize the flow.\n@return the flow itself.", "predict": " public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); } \n\n*/\npackage play.libs.streams;\n\nimport java.util.concurrent.Callable;\n\nimport scala.concurrent.Future;\nimport scala.concurrent.duration.Duration;\nimport scala.concurrent.duration.FiniteDuration;\n\nimport play.libs.Scala;\nimport play.mvc.Http.Request;\nimport play.mvc."}, {"ID": 628, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Object> convertErrorArguments(Object[] arguments) { if (arguments == null) { return Collections.emptyList(); } List<Object> converted = Arrays.stream(arguments) .filter( arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable)) .collect(Collectors.toList()); return Collections.unmodifiableList(converted); } \nResponse:", "ground_truth": "Convert the error arguments.\n\n@param arguments The arguments to convert.\n@return The converted arguments.", "predict": " ResponseEntity<Object> convertErrorResponse(Object response) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, HttpStatus.OK); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, status); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status, String message) { if (response == null) { return null; } ResponseEntity<Object> converted = new ResponseEntity<>(response, status); converted.getBody().add(new ErrorMessage(message)); return converted; } \nResp ResponseEntity<Object> convertErrorResponse(Object response, HttpStatus status, String message, Object... arguments) { if (response == null) { return null; } ResponseEntity<Object> converted"}, {"ID": 629, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Form<T> fill(T value) { if (value == null) { throw new RuntimeException(\"Cannot fill a form with a null value\"); } return new Form<>( rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess); } \nResponse:", "ground_truth": "Populates this form with an existing value, used for edit forms.\n\n@param value existing value of type T used to fill this form\n@return a copy of this form filled with the new data", "predict": "\n\npublic Form<T> fill(T value) {\n    if (value == null) {\n        throw new RuntimeException(\"Cannot fill a form with a null value\");\n    }\n    return new Form<>(rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess);\n}\n\npublic Form<T> fill(T value, String... groupNames) {\n    if (value == null) {\n        throw new RuntimeException(\"Cannot fill a form with a null value\");\n    }\n    return new Form<>(rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), Arrays.asList(groupNames), messagesApi, formatters, validatorFactory, config, lang, directField"}, {"ID": 630, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<ValidationError> globalErrors() { return Collections.unmodifiableList( errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList())); } \nResponse:", "ground_truth": "Retrieve all global errors - errors without a key.\n\n@return All global errors.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 631, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); } \nResponse:", "ground_truth": "Returns the form errors serialized as Json using the given Lang.\n\n@param lang the language to use.\n@return the JSON node containing the errors.", "predict": " public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); } \n\n*/\n"}, {"ID": 632, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<Object> value(String key) { return super.value().map(v -> v.getData().get(asNormalKey(key))); } \nResponse:", "ground_truth": "Gets the concrete value\n\n@param key the string key.\n@return the value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 633, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DynamicForm fill(Map<String, Object> value) { Form<Dynamic> form = super.fill(new Dynamic(value)); return new DynamicForm( form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null)); } \nResponse:", "ground_truth": "Fills the form with existing data.\n\n@param value the map of values to fill in the form.\n@return the modified form.", "predict": "\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.POST)\npublic ResponseEntity<DynamicForm> fill(@RequestBody Map<String, Object> value) {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(value), HttpStatus.OK);\n}\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.GET)\npublic ResponseEntity<DynamicForm> get() {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(new Dynamic(new HashMap<String, Object>())), HttpStatus.OK);\n}\n\n@RequestMapping(value = \"/api/v1/dynamicform\", method = RequestMethod.PUT)\npublic ResponseEntity<DynamicForm> put(@RequestBody Map<String, Object> value) {\n    return new ResponseEntity<DynamicForm>(new DynamicForm(value), HttpStatus.OK);\n}"}, {"ID": 634, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); } \nResponse:", "ground_truth": "Parses this string as instance of the given class.\n\n@param text the text to parse\n@param clazz class representing the required type\n@param  the type to parse out of the text\n@return the parsed value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 635, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T parse(Field field, String text) { return (T) conversion.convert(text, new TypeDescriptor(field)); } \nResponse:", "ground_truth": "Parses this string as instance of a specific field\n\n@param field the related field (custom formatters are extracted from this field annotation)\n@param text the text to parse\n@param  the type to parse out of the text\n@return the parsed value", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 636, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(T t) { if (t == null) { return \"\"; } if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value.\n\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new Test()));\n    }\n}\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new Test()));\n    }\n}\n"}, {"ID": 637, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific field.\n\n@param field the related field - custom formatters are extracted from this field annotation\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class <T> String print(Field field, T t) {\n    return print(new TypeDescriptor(field), t);\n}\n\npublic class TypeDescriptor {\n    private final Field field;\n    private final Class<?> type;\n\n    public TypeDescriptor(Field field) {\n        this.field = field;\n        this.type = field.getType();\n    }\n\n    public String print() {\n        return field.getName() + \": \" + type.getSimpleName();\n    }\n}\n\n*/\n\npublic class TypeDescriptor {\n    private final Field field;\n    private final Class<?> type;\n\n    public TypeDescriptor(Field field) {\n        this.field = field;\n        this.type = field.getType();\n    }\n\n    public String print() {\n        return field.getName() + \": \" + type.getSimpleName();\n    }\n"}, {"ID": 638, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(TypeDescriptor desc, T t) { if (t == null) { return \"\"; } if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) { return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class)); } else if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific type.\n\n@param desc the field descriptor - custom formatters are extracted from this descriptor.\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(test.print(new TypeDescriptor(String.class), \"Hello World\"));\n        System.out.println(test.print(new TypeDescriptor(String.class), null));\n        System.out.println(test.print(new TypeDescriptor(String.class), new Object()));\n    }\n}\n\nOutput:\n\npublic class Test {\n    public static void main(String[] args) {\n        Test test = new Test();\n        System.out.println(\"Hello World\");\n        System.out.println(\"\");\n        System.out.println(\"\");\n    }\n}\n\n*/\n\npublic class TypeDescriptor {\n    private final Class<?> clazz;\n\n    public TypeDescriptor(Class<?> clazz) {\n        this.clazz ="}, {"ID": 639, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Formatters registerOptional() { conversion.addConverter( new GenericConverter() { public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map( o -> conversion.convert( source, sourceType.getElementTypeDescriptor(), targetType)) .orElse(\"\"); } return null; } public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<ConvertiblePair> result = new HashSet<>(); result.add(new ConvertiblePair(Optional.class, String.class)); result.add(new ConvertiblePair(String.class, Optional.class)); return result; } }); return this; } \nResponse:", "ground_truth": "Converter for String -> Optional and Optional -> String", "predict": " Response<String> registerOptional(Optional<String> optional) { return null; } \nResp Response<String> registerOptional(String optional) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, String optional2) { return null; } \nResp Response<String> registerOptional(String optional, String optional2) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, Optional<String> optional2) { return null; } \nResp Response<String> registerOptional(String optional, Optional<String> optional2) { return null; } \nResp Response<String> registerOptional(Optional<String> optional, Optional<String> optional2, String optional3) { return null; } \nResp Response<String> registerOptional(String optional, Optional<String> optional2, String optional3) { return null; } \nResp Response<String> registerOptional(Optional"}, {"ID": 640, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; } \nResponse:", "ground_truth": "Registers a simple formatter.\n\n@param clazz class handled by this formatter\n@param  the type that this formatter will parse and print\n@param formatter the formatter to register\n@return the modified Formatters object.", "predict": " public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter, final Response response) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; } \nResp public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter, final Response response, final String pattern) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException"}, {"ID": 641, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) sourceType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.print(a, (T) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return \"@\" + annotationType.getName() + \" \" + clazz.getName() + \" -> \" + String.class.getName() + \": \" + formatter; } }); conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(String.class, clazz)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (targetType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) targetType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.parse(a, (String) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return String.class.getName() + \" -> @\" + annotationType.getName() + \" \" + clazz.getName() + \": \" + formatter; } }); return this; } \nResponse:", "ground_truth": "Registers an annotation-based formatter.\n\n@param clazz class handled by this formatter\n@param formatter the formatter to register\n@param  the annotation type\n@param  the type that will be parsed or printed\n@return the modified Formatters object.", "predict": " public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter, final Response.Status status) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor"}, {"ID": 642, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } final String name = cookie.name(); final String value = cookie.value() != null ? cookie.value() : \"\"; validateCookie(name, value); StringBuilder buf = new StringBuilder(); if (cookie.wrap()) { addQuoted(buf, name, value); } else { add(buf, name, value); } if (cookie.maxAge() != Integer.MIN_VALUE) { add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge()); Date expires = cookie.maxAge() <= 0 ? new Date(0) // Set expires to the Unix epoch : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis()); add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires)); } if (cookie.sameSite() != null) { add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite()); } if (cookie.path() != null) { add(buf, CookieHeaderNames.PATH, cookie.path()); } if (cookie.domain() != null) { add(buf, CookieHeaderNames.DOMAIN, cookie.domain()); } if (cookie.isSecure()) { add(buf, CookieHeaderNames.SECURE); } if (cookie.isHttpOnly()) { add(buf, CookieHeaderNames.HTTPONLY); } return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Set-Cookie header value.\n\n@param cookie the cookie\n@return a single Set-Cookie header value", "predict": " Generate the method-level comment for the following java Code. Code: public Cookie decode(String name, String value) { if (name == null) { throw new NullPointerException(\"name\"); } if (value == null) { throw new NullPointerException(\"value\"); } validateCookie(name, value); if (name.indexOf('=') != -1) { throw new IllegalArgumentException(\"Cookie name cannot contain '=' character\"); } if (value.indexOf('=') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain '=' character\"); } if (value.indexOf(' ') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain space character\"); } if (value.indexOf('\\t') != -1) { throw new IllegalArgumentException(\"Cookie value cannot contain tab character\"); } if (value.indexOf('\\r') != -1) { throw new IllegalArgumentException(\"Cookie value"}, {"ID": 643, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static NodeList selectNodes(String path, Object node) { return selectNodes(path, node, null); } \nResponse:", "ground_truth": "Select all nodes that are selected by this XPath expression. If multiple nodes match, multiple\nnodes will be returned. Nodes will be returned in document-order,\n\n@param path the xpath expression\n@param node the starting node\n@return result of evaluating the xpath expression against node", "predict": " Resp public static NodeList selectNodes(String path, Object node, Object result) { \n\tNodeList nodes = null;\n\ttry {\n\t\tnodes = XPathAPI.selectNodeList(node, path);\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\treturn nodes;\n}\n\n*/\n\n}\n"}, {"ID": 644, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) { return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList(); } \nResponse:", "ground_truth": "Converts a Java List to Scala Seq.\n\n@param list    the java list.\n@return the converted Seq.\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class JavaStreams {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> list2 = Arrays.asList(\"d\", \"e\", \"f\");"}, {"ID": 645, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) { return toSeq(java.util.Arrays.asList(array)); } \nResponse:", "ground_truth": "Converts a Java Array to Scala Seq.\n\n@param array    the java array.\n@return the converted Seq.\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCode {\n    public static <T> List<T> toList(T[] array) {\n        List<T> list = new ArrayList<T>();\n        for (T t : array) {\n            list.add(t);\n        }\n        return list;\n    }\n\n    public static <T> List<T> toList(List<T> list) {\n        return list;\n    }\n\n    public static <T> List<T> toList(Iterable<T> iterable) {\n        List<T> list = new ArrayList<T>();\n        for (T t : iterable) {\n            list.add(t);\n        }\n        return list;\n    }\n\n    public static <T> List<T> toList(Iterable<T> iterable, int size) {\n        "}, {"ID": 646, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs public static <T> scala.collection.immutable.Seq<T> varargs(T... array) { return toSeq(array); } \nResponse:", "ground_truth": "Converts a Java varargs to Scala varargs.\n\n@param array    the java array.\n@return the Scala varargs\n@param  the element type.", "predict": "\n\n*/\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class JavaSafeVarargs {\n    public static <T> List<T> varargs(T... array) {\n        return Arrays.asList(array);\n    }\n\n    public static void main(String[] args) {\n        List<String> list = varargs(\"a\", \"b\", \"c\");\n        System.out.println(list);\n    }\n}\n"}, {"ID": 647, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); } catch (Exception e) { throw new RuntimeException(e); } }); } \nResponse:", "ground_truth": "Acceptor for JSON WebSockets.\n\n@param in The class of the incoming messages, used to decode them from the JSON.\n@param  The websocket's input type (what it receives from clients)\n@param  The websocket's output type (what it writes to clients)\n@return The WebSocket acceptor.", "predict": " public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); }"}, {"ID": 648, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get().map(outMapper::apply)); return F.Either.Right(flow); } }); } }; } \nResponse:", "ground_truth": "Helper to create handlers for WebSockets.\n\n@param inMapper Function to map input messages. If it produces left, the message will be passed\nto the WebSocket flow, if it produces right, the message will be sent back out to the\nclient - this can be used to send errors directly to the client.\n@param f The function to handle the WebSocket.\n@param outMapper Function to map output messages.\n@return The WebSocket handler.", "predict": "\n\npublic static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get()."}, {"ID": 649, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static boolean setAccessibleWorkaround(final AccessibleObject o) { if (o == null || o.isAccessible()) { return false; } final Member m = (Member) o; if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { try { o.setAccessible(true); return true; } catch (final SecurityException e) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false; } \nResponse:", "ground_truth": "XXX Default access superclass workaround.\n\nWhen a {@code public} class has a default access superclass with {@code public} members,\nthese members are accessible. Calling them from compiled code works fine. Unfortunately, on\nsome JVMs, using reflection to invoke these members seems to (wrongly) prevent access even when\nthe modifier is {@code public}. Calling {@code setAccessible(true)} solves the problem but will\nonly work from sufficiently privileged code. Better workarounds would be gratefully accepted.\n\n@param o the AccessibleObject to set as accessible\n@return a boolean indicating whether the accessibility of the object was set to true.", "predict": "\n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution.setAccessibleWorkaround(null);\n    }\n\n    public static boolean setAccessibleWorkaround(final AccessibleObject o) {\n        if (o == null || o.isAccessible()) {\n            return false;\n        }\n        final Member m = (Member) o;\n        if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n            try {\n                o.setAccessible(true);\n                return true;\n            } catch (final SecurityException e) {\n                // NOPMD // ignore in favor of subsequent IllegalAccessException\n            }\n        }\n        return false;\n    }\n\n    private static boolean isPackageAccess(final int modifiers) {\n        return Modifier.isPublic(modifiers) && !"}, {"ID": 650, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getPrimitivePromotionCost( final Class<?> srcClass, final Class<?> destClass) { float cost = 0.0f; Class<?> cls = srcClass; if (!cls.isPrimitive()) { // slight unwrapping penalty cost += 0.1f; cls = ClassUtils.wrapperToPrimitive(cls); } for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { if (cls == ORDERED_PRIMITIVE_TYPES[i]) { cost += 0.1f; if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { cls = ORDERED_PRIMITIVE_TYPES[i + 1]; } } } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required to promote a primitive number to another type.\n\n@param srcClass the (primitive) source class\n@param destClass the (primitive) destination class\n@return The cost of promoting the primitive", "predict": "\n\n*/\n\npublic class Solution {\n    public static float getPrimitivePromotionCost(Class<?> srcClass, Class<?> destClass) {\n        float cost = 0.0f;\n        Class<?> cls = srcClass;\n        if (!cls.isPrimitive()) {\n            cost += 0.1f;\n            cls = ClassUtils.wrapperToPrimitive(cls);\n        }\n        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n                cost += 0.1f;\n                if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n                    cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n                }\n            }\n        }\n        "}, {"ID": 651, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getTotalTransformationCost( final Class<?>[] srcArgs, final Executable executable) { final Class<?>[] destArgs = executable.getParameterTypes(); final boolean isVarArgs = executable.isVarArgs(); // \"source\" and \"destination\" are the actual and declared args respectively. float totalCost = 0.0f; final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length; if (srcArgs.length < normalArgsLen) { return Float.MAX_VALUE; } for (int i = 0; i < normalArgsLen; i++) { totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]); } if (isVarArgs) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs.length < destArgs.length; final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray(); final float varArgsCost = 0.001f; final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType(); if (noVarArgsPassed) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost; } else if (explicitArrayForVarags) { final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType(); totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost; } else { // This is typical varargs case. for (int i = destArgs.length - 1; i < srcArgs.length; i++) { final Class<?> srcClass = srcArgs[i]; totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost; } } } return totalCost; } \nResponse:", "ground_truth": "Returns the sum of the object transformation cost for each class in the source argument list.\n\n@param srcArgs The source arguments\n@param executable The executable to calculate transformation costs for\n@return The total transformation cost", "predict": "\n\npublic static float getTotalTransformationCost(final Class<?>[] srcArgs, final Executable executable) {\n\tfinal Class<?>[] destArgs = executable.getParameterTypes();\n\tfinal boolean isVarArgs = executable.isVarArgs();\n\tfinal long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length;\n\tif (srcArgs.length < normalArgsLen) {\n\t\treturn Float.MAX_VALUE;\n\t}\n\tfloat totalCost = 0.0f;\n\tfor (int i = 0; i < normalArgsLen; i++) {\n\t\ttotalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);\n\t}\n\tif (isVarArgs) {\n\t\tfinal boolean noVarArgsPassed = srcArgs.length < destArgs.length;\n\t\tfinal boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1"}, {"ID": 652, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { if (destClass.isPrimitive()) { return getPrimitivePromotionCost(srcClass, destClass); } float cost = 0.0f; while (srcClass != null && !destClass.equals(srcClass)) { if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f; break; } cost++; srcClass = srcClass.getSuperclass(); } /* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if (srcClass == null) { cost += 1.5f; } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required needed to turn the source class into the destination class.\nThis represents the number of steps in the object hierarchy graph.\n\n@param srcClass The source class\n@param destClass The destination class\n@return The cost of transforming an object", "predict": "\n\npublic static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {\n\tfloat cost = 0.0f;\n\twhile (srcClass != null && !destClass.equals(srcClass)) {\n\t\tif (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {\n\t\t\t// slight penalty for interface match.\n\t\t\tcost += 0.25f;\n\t\t\tbreak;\n\t\t}\n\t\tcost++;\n\t\tsrcClass = srcClass.getSuperclass();\n\t}\n\t/* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */\n\tif (srcClass == null) {\n\t\tcost += 1.5f;\n\t}\n\treturn cost;\n}\n\n*/\n"}, {"ID": 653, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(String key, Object... args) { return messagesApi.get(lang, key, args); } \nResponse:", "ground_truth": "Get the message at the given key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 654, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(List<String> keys, Object... args) { return messagesApi.get(lang, keys, args); } \nResponse:", "ground_truth": "Get the message at the first defined key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "\n\n*/\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @author jaehong.kim\n */\npublic class MethodJsonParser {\n    private final Object object;\n    private final Method method;\n    private final StringBuilder builder;\n    private final List<Object> list;\n\n    public MethodJsonParser(final Object object, final Method method) {\n        this.object = object;\n        this.method = method;\n        this.builder = new StringBuilder();\n        this.list = new ArrayList<Object>();\n    }\n\n    public StringBuilder getBuilder() {\n        return builder;\n    }\n\n    public List<Object> getList() {\n        return list;\n    }\n\n    public void parse() {\n        final Class<?>"}, {"ID": 655, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Database createFrom( String driver, String url, Map<String, ? extends Object> config) { return createFrom(\"default\", driver, url, config); } \nResponse:", "ground_truth": "Create a pooled database named \"default\" with the given configuration.\n\n@param driver the database driver class\n@param url the database url\n@param config a map of extra database configuration\n@return a configured database", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 656, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ParallelSorter create(Object[] arrays) { Generator gen = new Generator(); gen.setArrays(arrays); return gen.create(); } \nResponse:", "ground_truth": "Create a new ParallelSorter object for a set of arrays. You may\nsort the arrays multiple times via the same ParallelSorter object.\n@param arrays An array of arrays to sort. The arrays may be a mix\nof primitive and non-primitive types, but should all be the same\nlength.\n@param loader ClassLoader for generated class, uses \"current\" if null", "predict": " public static ParallelSorter create(Object[] arrays) { return new ParallelSorter(arrays); }\n\n*/\n\npublic class ParallelSorter {\n\tprivate Object[] arrays;\n\tprivate int[] indexes;\n\tprivate int[] sizes;\n\tprivate int[] offsets;\n\tprivate int[] lengths;\n\tprivate int[] offsets2;\n\tprivate int[] lengths2;\n\tprivate int[] offsets3;\n\tprivate int[] lengths3;\n\tprivate int[] offsets4;\n\tprivate int[] lengths4;\n\tprivate int[] offsets5;\n\tprivate int[] lengths5;\n\tprivate int[] offsets6;\n\tprivate int[] lengths6;\n\tprivate int[] offsets7;\n\tprivate int[] lengths7;\n\tprivate int[] offsets8;\n\tprivate int[] lengths8;\n\tprivate int[] offsets9;\n\tprivate int[] lengths9;\n\tprivate int[] offsets10;\n\tprivate int[] lengths10;\n\tprivate int"}, {"ID": 657, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void quickSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.quickSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using the quicksort algorithm.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "\n\npublic void quickSort(int index, int lo, int hi, Comparator cmp) {\n\tif (lo >= hi) return;\n\tint mid = partition(index, lo, hi, cmp);\n\tquickSort(index, lo, mid - 1, cmp);\n\tquickSort(index, mid + 1, hi, cmp);\n}\n\npublic int partition(int index, int lo, int hi, Comparator cmp) {\n\tint i = lo, j = hi + 1;\n\tint pivot = lo;\n\twhile (true) {\n\t\twhile (cmp.compare(array[index], array[lo]) < 0) lo++;\n\t\twhile (cmp.compare(array[index], array[j]) > 0) j--;\n\t\tif (j < i) break;\n\t\tswap(index, j, lo);\n\t\tlo++;\n\t\tj--;\n\t}\n\tswap(index, lo"}, {"ID": 658, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void mergeSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.mergeSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using an in-place merge sort.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "\n\npublic void mergeSort(int index, int lo, int hi, Comparator cmp) {\n    if (lo < hi) {\n        int mid = (lo + hi) / 2;\n        mergeSort(index, lo, mid, cmp);\n        mergeSort(index, mid + 1, hi, cmp);\n        merge(index, lo, mid, hi, cmp);\n    }\n}\n\npublic void merge(int index, int lo, int mid, int hi, Comparator cmp) {\n    int[] a = new int[hi - lo + 1];\n    int i = lo;\n    int j = mid + 1;\n    int k = lo;\n    while (i <= mid && j <= hi) {\n        if (cmp.compare(a[k], a[j]) <= 0) {\n            a[k++] = a[j++];\n        } else {\n            a[k"}, {"ID": 659, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } } \nResponse:", "ground_truth": "Invoke the original method, on a different object of the same type.\n@param obj the compatible object; recursion will result if you use the object passed as the first\nargument to the MethodInterceptor (usually not what you want)\n@param args the arguments passed to the intercepted method; you may substitute a different\nargument array as long as the types are compatible\n@see MethodInterceptor#intercept\n@throws Throwable the bare exceptions thrown by the called method are passed through\nwithout wrapping in an InvocationTargetException", "predict": " public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } } \n\n*/\n\npublic class FastClassInfo {\n\tpublic int i1;\n\tpublic int i2;\n\tpublic int i3;\n\tpublic int i4;\n\tpublic int i5;\n\tpublic int i6;\n\tpublic int i7;\n\tpublic int i8;\n\tpublic int i9;\n\tpublic int i10;\n\tpublic int i11;\n\tpublic int i12;\n\tpublic int i13;\n\tpublic int i"}, {"ID": 660, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.LONG_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.L2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.L2F); } else { mv.visitInsn(Constants.L2I); cast_numeric(Type.INT_TYPE, to); } } else { if (to == Type.BYTE_TYPE) { mv.visitInsn(Constants.I2B); } else if (to == Type.CHAR_TYPE) { mv.visitInsn(Constants.I2C); } else if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.I2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.I2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.I2L); } else if (to == Type.SHORT_TYPE) { mv.visitInsn(Constants.I2S); } } } } \nResponse:", "ground_truth": "Casts from one primitive numeric type to another", "predict": "\npublic void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_"}, {"ID": 661, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); } \nResponse:", "ground_truth": "Pushes the specified argument of the current method onto the stack.\n@param index the zero-based index into the argument list", "predict": "\n\n*/\n\npublic class LoadArgument extends Instruction {\n\tpublic LoadArgument(int index) {\n\t\tsuper(OpCode.LoadArgument);\n\t\tthis.index = index;\n\t}\n\t\n\tpublic void execute(Frame frame) {\n\t\tframe.stack.push(frame.stack.get(frame.stack.size() - 1 - index));\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"load_arg \" + index;\n\t}\n\t\n\tpublic void load(BytecodeReader reader) {\n\t\tindex = reader.readInt();\n\t}\n\t\n\tpublic void store(BytecodeWriter writer) {\n\t\twriter.writeInt(index);\n\t}\n\t\n\tpublic int getIndex() {\n\t\treturn index;\n\t}\n\t\n\tprivate int index;\n}\n"}, {"ID": 662, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); } \nResponse:", "ground_truth": "package-protected for EmitUtils, try to fix", "predict": "\n\n*/\n\npublic class FieldInsnNode extends AbstractInsnNode {\n    private int opcode;\n    private Type ctype;\n    private String name;\n    private Type ftype;\n\n    public FieldInsnNode(int opcode, Type ctype, String name, Type ftype) {\n        super(Opcodes.FIELDINSN);\n        this.opcode = opcode;\n        this.ctype = ctype;\n        this.name = name;\n        this.ftype = ftype;\n    }\n\n    public int getOpcode() {\n        return opcode;\n    }\n\n    public Type getCtype() {\n        return ctype;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Type getFtype() {\n        return ftype;\n    }\n\n    public void accept(Visitor visitor) {\n        visitor.visitFieldInsn(this);\n"}, {"ID": 663, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } } \nResponse:", "ground_truth": "Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.", "predict": "\n\npublic void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.InsnNode;\nimport org.objectweb.asm.tree.IntInsnNode;\n"}, {"ID": 664, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } } \nResponse:", "ground_truth": "Unboxes the object on the top of the stack. If the object is null, the\nunboxed primitive value becomes zero.", "predict": " Generate the method-level comment for the following java Code. Code: public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } } \n */\n\npublic class Unboxing {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n"}, {"ID": 665, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) { Type componentType = TypeUtils.getComponentType(type); Local array = e.make_local(); Local loopvar = e.make_local(Type.INT_TYPE); Label loopbody = e.make_label(); Label checkloop = e.make_label(); e.store_local(array); e.push(0); e.store_local(loopvar); e.goTo(checkloop); e.mark(loopbody); e.load_local(array); e.load_local(loopvar); e.array_load(componentType); callback.processElement(componentType); e.iinc(loopvar, 1); e.mark(checkloop); e.load_local(loopvar); e.load_local(array); e.arraylength(); e.if_icmp(e.LT, loopbody); } \nResponse:", "ground_truth": "Process an array on the stack. Assumes the top item on the stack\nis an array of the specified type. For each element in the array,\nputs the element on the stack and triggers the callback.\n@param type the type of the array (type.isArray() must be true)\n@param callback the callback triggered for each element", "predict": "\n\n*/\n\npublic class ProcessArrayCallback {\n    public void processElement(Type type) {\n        // TODO Auto-generated method stub\n        \n    }\n}\n"}, {"ID": 666, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) { e.dup2(); Label nonNull = e.make_label(); Label oneNullHelper = e.make_label(); Label end = e.make_label(); e.ifnonnull(nonNull); e.ifnonnull(oneNullHelper); e.pop2(); e.goTo(bothNull); e.mark(nonNull); e.ifnull(oneNullHelper); e.goTo(end); e.mark(oneNullHelper); e.pop2(); e.goTo(oneNull); e.mark(end); } \nResponse:", "ground_truth": "If both objects on the top of the stack are non-null, does nothing.\nIf one is null, or both are null, both are popped off and execution\nbranches to the respective label.\n@param oneNull label to branch to if only one of the objects is null\n@param bothNull label to branch to if both of the objects are null", "predict": "\n\npublic static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n\tif (oneNull == null) {\n\t\tif (bothNull == null) {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(bothNull);\n\t\t} else {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(oneNull);\n\t\t}\n\t} else {\n\t\tif (bothNull == null) {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(oneNull);\n\t\t} else {\n\t\t\te.dup2();\n\t\t\te.pop2();\n\t\t\te.goTo(bothNull);\n\t\t}\n\t}\n}\n\n*/\n"}, {"ID": 667, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; } \nResponse:", "ground_truth": "Finds all bridge methods that are being called with invokespecial &\nreturns them.", "predict": " public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; } \n\n}\n"}, {"ID": 668, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void getMethods(Class superclass, Class[] interfaces, List methods) { getMethods(superclass, interfaces, methods, null, null); } \nResponse:", "ground_truth": "Finds all of the methods that will be extended by an\nEnhancer-generated class using the specified superclass and\ninterfaces. This can be useful in building a list of Callback\nobjects. The methods are added to the end of the given list.  Due\nto the subclassing nature of the classes generated by Enhancer,\nthe methods are guaranteed to be non-static, non-final, and\nnon-private. Each method signature will only occur once, even if\nit occurs in multiple classes.\n@param superclass the class that will be extended, or null\n@param interfaces the list of interfaces that will be implemented, or null\n@param methods the list into which to copy the applicable methods", "predict": "\n\n*/\n\npublic class GetMethods {\n\tpublic static void main(String[] args) {\n\t\tClass superclass = Object.class;\n\t\tClass[] interfaces = new Class[] {};\n\t\tList methods = new ArrayList();\n\t\t\n\t\tgetMethods(superclass, interfaces, methods, null, null);\n\t\t\n\t\tfor (Iterator i = methods.iterator(); i.hasNext();) {\n\t\t\tMethod m = (Method) i.next();\n\t\t\tSystem.out.println(m.getName());\n\t\t}\n\t}\n\t\n\tpublic static void getMethods(Class superclass, Class[] interfaces, List methods, String prefix, String suffix) {\n\t\tif (superclass != null) {\n\t\t\tgetMethods(superclass.getSuperclass(), interfaces, methods, prefix, suffix);\n\t\t\t\n\t\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\t\tgetMethods(interfaces[i], interfaces, methods, prefix, suffix"}, {"ID": 669, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void filterConstructors(Class sc, List constructors) { CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true)); if (constructors.size() == 0) throw new IllegalArgumentException(\"No visible constructors in \" + sc); } \nResponse:", "ground_truth": "Filter the list of constructors from the superclass. The\nconstructors which remain will be included in the generated\nclass. The default implementation is to filter out all private\nconstructors, but subclasses may extend Enhancer to override this\nbehavior.\n@param sc the superclass\n@param constructors the list of all declared constructors from the superclass\n@throws IllegalArgumentException if there are no non-private constructors", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class VisibilityPredicate implements Predicate<Constructor> {\n    private final Class<?> clazz;\n    private final boolean visible;\n\n    public VisibilityPredicate(Class<?> clazz, boolean visible) {\n        this.clazz = clazz;\n        this.visible = visible;\n    }\n\n    @Override\n    public boolean evaluate(Constructor constructor) {\n        return visible == isVisible(constructor);\n    }\n\n    private boolean isVisible(Constructor constructor) {\n        return isVisible(constructor.getDeclaringClass());\n    }\n\n    private boolean isVisible(Class<?> clazz) {\n        return clazz.getModifiers() == (clazz.getModifiers() & ~Modifier.PRIVATE);\n    "}, {"ID": 670, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setSuperclass(Class superclass) { if (superclass != null && superclass.equals(Object.class)) { superclass = null; } this.superclass = superclass; } \nResponse:", "ground_truth": "Set the class which the generated class will extend. The class\nmust not be declared as final, and must have a non-private\nno-argument constructor.\n@param superclass class to extend, or null to extend Object", "predict": "\n\n*/\n\npublic class Test {\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.setSuperclass(Object.class);\n    }\n}\n"}, {"ID": 671, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void getField(String[] names) throws Exception { final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null); e.load_this(); e.load_arg(0); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label end) { Type type = (Type)fields.get(key); e.getfield((String)key); e.box(type); e.return_value(); } public void processDefault() { e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\"); } }); e.end_method(); } \nResponse:", "ground_truth": "to avoid JVM hashcode implementation incompatibilities", "predict": "\npublic void getField(String[] names) throws Exception {\n\tfinal CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);\n\te.load_this();\n\te.load_arg(0);\n\tEmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n\t\tpublic void processCase(Object key, Label end) {\n\t\t\tType type = (Type)fields.get(key);\n\t\t\te.getfield((String)key);\n\t\t\te.box(type);\n\t\t\te.return_value();\n\t\t}\n\t\tpublic void processDefault() {\n\t\t\te.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\n\t\t}\n\t});\n\te.end_method();\n}\n\n}\n"}, {"ID": 672, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Method method) { add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method)); } \nResponse:", "ground_truth": "Add a method signature to the interface. The method modifiers are ignored,\nsince interface methods are by definition abstract and public.\n@param method the method to add to the interface", "predict": " Response = new Response(this.getClass().getName(), \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add\", \"add"}, {"ID": 673, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; } \nResponse:", "ground_truth": "If bit 31 is set then this method results in an infinite loop.\n\n@return the number of bits set to true in this TinyBitSet.", "predict": "\n\npublic int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; }\n\n*/\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.countBit(1));\n        System.out.println(s.countBit(2));\n        System.out.println(s.countBit(3));\n        System.out.println(s.countBit(4));\n        System.out.println(s.countBit(5));\n        System.out.println(s.countBit(6));\n        System.out.println(s.countBit(7));\n        System.out.println(s.countBit"}, {"ID": 674, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setNamingPolicy(NamingPolicy namingPolicy) { if (namingPolicy == null) namingPolicy = DefaultNamingPolicy.INSTANCE; this.namingPolicy = namingPolicy; } \nResponse:", "ground_truth": "Override the default naming policy.\n@see DefaultNamingPolicy\n@param namingPolicy the custom policy, or null to use the default", "predict": " Response is generated.\n*/\n\npublic class NamingPolicy {\n    private static final NamingPolicy instance = new NamingPolicy();\n    private NamingPolicy() {\n    }\n    public static NamingPolicy getInstance() {\n        return instance;\n    }\n    public String getName(String name) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName, boolean isAttributeName) {\n        return name;\n    }\n    public String getName(String name, String prefix, String suffix, boolean isElementName, boolean isAttributeName, boolean isTypeName) {\n        return name;\n    }\n    public String getName(String"}, {"ID": 675, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) { Map map = new HashMap(); for (int i = 0; i < methods.length; i++) { Method method = methods[i]; map.put(method.getName() + Type.getMethodDescriptor(method), method); } Method[] result = new Method[namesAndDescriptors.length / 2]; for (int i = 0; i < result.length; i++) { result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]); if (result[i] == null) { // TODO: error? } } return result; } \nResponse:", "ground_truth": "used by MethodInterceptorGenerated generated code", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.ClassNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\n\npublic class MethodVisitor extends MethodNode {\n\tprivate final List<AbstractInsnNode> instructions = new ArrayList<>();\n\tprivate final List<AbstractInsnNode> instructionsToRemove = new ArrayList<>();\n\tprivate final List<AbstractInsnNode> instructions"}, {"ID": 676, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Path resolve(final Path base, String child) { if (StringUtil.startsWithChar(child, File.separatorChar)) { child = child.substring(1); } return base.resolve(child); } \nResponse:", "ground_truth": "Resolves subpath in safer way. For some reason, if child starts with\na separator it gets resolved as a full path, ignoring the base.\nThis method acts different.", "predict": "\n\npublic static Path resolve(final Path base, String child) {\n    if (StringUtil.startsWithChar(child, File.separatorChar)) {\n        child = child.substring(1);\n    }\n    return base.resolve(child);\n}\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        String javaCode = readFile(\"src/main/java/com/example/Path.java\");\n        String javaCode2 = readFile(\"src/main/"}, {"ID": 677, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer); return writer.toString(); } } \nResponse:", "ground_truth": "Reads path content.", "predict": "\n\npublic static String readString(final Path path) throws IOException {\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n        StringWriter writer = new StringWriter();\n        StreamUtil.copy(reader, writer);\n        return writer.toString();\n    }\n}\n\n*/\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String fileName = scanner.nextLine();\n        File file = new File(fileName);\n        List<String>"}, {"ID": 678, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; } \nResponse:", "ground_truth": "Sets request host name.", "predict": " public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n\tprivate String host;\n\tprivate List<String> headers = new ArrayList<String>();\n\t\n\tpublic HttpRequest() {\n\t\t\n\t}\n\t\n\tpublic HttpRequest(String host) {\n\t\tthis.host = host;\n\t}\n\t\n\tpublic HttpRequest(String host, List<String> headers) {\n\t\tthis.host = host;\n\t\tthis.headers = headers;\n\t}\n\t\n\tpublic String getHost() {\n\t\treturn host;\n\t}\n\t\n\tpublic void setHost(String host) {\n\t\tthis.host = host;"}, {"ID": 679, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest create(final String method, final String destination) { return new HttpRequest() .method(method.toUpperCase()) .set(destination); } \nResponse:", "ground_truth": "Generic request builder, usually used when method is a variable.\nOtherwise, use one of the other static request builder methods.", "predict": " public static HttpResponse create(final String method, final String destination) { return new HttpResponse() .method(method.toUpperCase()) .set(destination); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> params;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> params, String destination) {\n\t\tthis.method = method;\n\t\tthis.params = params;\n\t\tthis.destination = destination;\n\t}\n\t\n\tpublic String getMethod() {\n\t\treturn method;\n\t}\n\t\n\tpublic void setMethod(String method) {\n\t\tthis.method = method;\n\t}\n\t"}, {"ID": 680, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest connect(final String destination) { return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination); } \nResponse:", "ground_truth": "Builds a CONNECT request.", "predict": " public static HttpResponse connect(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate Map<String, String> cookies;\n\tprivate String body;\n\tprivate String destination;\n\tprivate String url;\n\tprivate String contentType;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptCharset;\n\tprivate String acceptLanguage;\n\tprivate String host;\n\tprivate String userAgent;\n\tprivate String remoteAddress;\n\tprivate String remoteHost;\n\tprivate String remoteUser;\n\tprivate String serverName;\n\tprivate String serverPort;\n\tprivate String serverProtocol;\n\tprivate String scheme;\n\tprivate String status;\n"}, {"ID": 681, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest get(final String destination) { return new HttpRequest() .method(HttpMethod.GET) .set(destination); } \nResponse:", "ground_truth": "Builds a GET request.", "predict": " Response get(final String destination) { return new Response() .set(destination); }\n\n*/\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString destination = \"destination\";\n\t\t\n\t\tHttpRequest httpRequest = new HttpRequest()\n\t\t\t\t.method(HttpMethod.GET)\n\t\t\t\t.set(destination);\n\t\t\n\t\tResponse response = new Response()\n\t\t\t\t.set(destination);\n\t\t\n\t\tSystem.out.println(httpRequest.toString());\n\t\tSystem.out.println(response.toString());\n\t\t\n\t}\n\n}\n"}, {"ID": 682, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest post(final String destination) { return new HttpRequest() .method(HttpMethod.POST) .set(destination); } \nResponse:", "ground_truth": "Builds a POST request.", "predict": " Response<HttpRequest> post(final String destination) { return new Response<HttpRequest>() .request(new HttpRequest() .method(HttpMethod.POST) .set(destination)); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tList<String> lines = new ArrayList<String>();\n\t\t\n\t\tlines.add(\"package com.example.myapp;\");\n\t\tlines.add(\"\");\n\t\tlines.add(\"import com.example.myapp.http.HttpRequest;\");\n\t\tlines.add(\"import com.example.myapp.http.HttpResponse;\");\n\t\tlines.add(\"import com.example.myapp.http.Response;\");\n\t\tlines.add(\"\");\n\t\tlines.add(\"public class JavaCodeGenerator {\");\n\t\tlines.add(\"\");"}, {"ID": 683, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest put(final String destination) { return new HttpRequest() .method(HttpMethod.PUT) .set(destination); } \nResponse:", "ground_truth": "Builds a PUT request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> parameters;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.parameters = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> headers, Map<String, String> parameters, String body, String destination) {\n\t\tthis.method = method;\n\t\tthis.headers = headers;\n\t\tthis.parameters = parameters;\n\t\tthis.body = body;\n\t\tthis.destination = destination;\n\t}\n\t"}, {"ID": 684, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest patch(final String destination) { return new HttpRequest() .method(HttpMethod.PATCH) .set(destination); } \nResponse:", "ground_truth": "Builds a PATCH request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n    private List<String> headers = new ArrayList<>();\n    private List<String> params = new ArrayList<>();\n    private List<String> cookies = new ArrayList<>();\n    private String method;\n    private String url;\n    private String body;\n    private String contentType;\n    private String contentEncoding;\n    private String acceptEncoding;\n    private String accept;\n    private String acceptCharset;\n    private String acceptLanguage;\n    private String host;\n    private int port;\n    private String protocol;\n    private String userAgent;\n    private String remoteAddress;\n    private String remoteHost;\n    private String remotePort;\n    private String remoteUser;\n    private String serverName;\n    private String serverPort"}, {"ID": 685, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest delete(final String destination) { return new HttpRequest() .method(HttpMethod.DELETE) .set(destination); } \nResponse:", "ground_truth": "Builds a DELETE request.", "predict": " Response is generated by the following java Code. Code: public static HttpResponse delete(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpRequest {\n\tprivate List<String> headers = new ArrayList<String>();\n\tprivate List<String> params = new ArrayList<String>();\n\tprivate List<String> cookies = new ArrayList<String>();\n\tprivate String method;\n\tprivate String url;\n\tprivate String body;\n\tprivate String contentType;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptCharset;\n\tprivate String acceptLanguage;\n\tprivate String host;\n\tprivate String userAgent;\n\tprivate String remoteAddr;\n\tprivate String remoteHost;\n\tprivate"}, {"ID": 686, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest head(final String destination) { return new HttpRequest() .method(HttpMethod.HEAD) .set(destination); } \nResponse:", "ground_truth": "Builds a HEAD request.", "predict": " Response<HttpRequest> head(final String destination) { return new Response<HttpRequest>(new HttpRequest() .method(HttpMethod.HEAD) .set(destination)); } \n\n*/\n\npublic class HttpRequest {\n\tprivate String method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = \"GET\";\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(String method, Map<String, String> headers, Map<String, String> params, String body, String destination) {\n\t\tthis.method = method;\n\t\tthis.headers = headers;\n\t\tthis.params"}, {"ID": 687, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest trace(final String destination) { return new HttpRequest() .method(HttpMethod.TRACE) .set(destination); } \nResponse:", "ground_truth": "Builds a TRACE request.", "predict": " public static HttpResponse trace(final String destination) { return new HttpResponse() .status(HttpStatus.OK) .set(destination); } \n\n*/\n\npublic class Trace {\n\tpublic static void main(String[] args) {\n\t\tHttpRequest request = new HttpRequest()\n\t\t\t\t.method(HttpMethod.TRACE)\n\t\t\t\t.set(\"http://www.google.com\");\n\t\tHttpResponse response = new HttpResponse()\n\t\t\t\t.status(HttpStatus.OK)\n\t\t\t\t.set(\"http://www.google.com\");\n\t\tSystem.out.println(request);\n\t\tSystem.out.println(response);\n\t}\n}\n"}, {"ID": 688, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest options(final String destination) { return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination); } \nResponse:", "ground_truth": "Builds an OPTIONS request.", "predict": " Response = new HttpResponse() .set(destination);\n\n*/\n\npublic class HttpRequest {\n\tprivate HttpMethod method;\n\tprivate Map<String, String> headers;\n\tprivate Map<String, String> params;\n\tprivate String body;\n\tprivate String destination;\n\t\n\tpublic HttpRequest() {\n\t\tthis.method = HttpMethod.GET;\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic HttpRequest(HttpMethod method) {\n\t\tthis.method = method;\n\t\tthis.headers = new HashMap<String, String>();\n\t\tthis.params = new HashMap<String, String>();\n\t\tthis.body = \"\";\n\t\tthis.destination = \"\";\n\t}\n\t\n\tpublic H"}, {"ID": 689, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest path(String path) { // this must be the only place that sets the path if (!path.startsWith(StringPool.SLASH)) { path = StringPool.SLASH + path; } int ndx = path.indexOf('?'); if (ndx != -1) { String queryString = path.substring(ndx + 1); path = path.substring(0, ndx); query = HttpUtil.parseQuery(queryString, true); } else { query = HttpMultiMap.newCaseInsensitiveMap(); } this.path = path; return this; } \nResponse:", "ground_truth": "Sets request path. Query string is allowed.\nAdds a slash if path doesn't start with one.\nQuery will be stripped out from the path.\nPrevious query is discarded.\n@see #query()", "predict": " public HttpRequest method(String method) { this.method = method; return this; } \nResp public HttpRequest header(String name, String value) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } this.headers.put(name, value); return this; } \nResp public HttpRequest header(String name, List<String> values) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } for (String value : values) { this.headers.put(name, value); } return this; } \nResp public HttpRequest header(String name, Map<String, List<String>> values) { if (this.headers == null) { this.headers = new HashMap<String, String>(); } for (Map.Entry<String, List<String>> entry : values.entrySet()) { this.headers.put(entry.get"}, {"ID": 690, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; } \nResponse:", "ground_truth": "Sets cookies to the request.", "predict": " public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; } \nResp public HttpRequest cookies(final Map<String, Cookie> cookies) { if (cookies.isEmpty()) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Map.Entry<String, Cookie> cookie : cookies.entrySet()) { if (!first) { cookieString.append(\""}, {"ID": 691, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResponse:", "ground_truth": "Adds many query parameters at once. Although it accepts objects,\neach value will be converted to string.", "predict": " public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResp public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResp public HttpRequest query(final String name1, final Object value1, final Object... parameters) {"}, {"ID": 692, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final Map<String, String> queryMap) { for (Map.Entry<String, String> entry : queryMap.entrySet()) { query.add(entry.getKey(), entry.getValue()); } return this; } \nResponse:", "ground_truth": "Adds all parameters from the provided map.", "predict": " Response<T> query(final Map<String, String> queryMap) { return this.query(queryMap, null); } \nResp Response<T> query(final Map<String, String> queryMap, final Response.Listener<T> listener) { return this.query(queryMap, null, listener); } \nResp Response<T> query(final Map<String, String> queryMap, final Response.ErrorListener errorListener) { return this.query(queryMap, null, errorListener); } \nResp Response<T> query(final Map<String, String> queryMap, final Map<String, String> headers, final Response.Listener<T> listener) { return this.query(queryMap, headers, null, listener); } \nResp Response<T> query(final Map<String, String> queryMap, final Map<String, String> headers, final Response.ErrorListener errorListener) { return this.query(queryMap, headers,"}, {"ID": 693, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; } \nResponse:", "ground_truth": "Sets query from provided query string. Previous query values\nare discarded.", "predict": " public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset) { this.query = HttpUtil.parseQuery(queryString, decode, charset); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset, final String contentType) { this.query = HttpUtil.parseQuery(queryString, decode, charset, contentType); return this; } \nResp public HttpRequest queryString(final String queryString, final boolean decode, final String charset, final String contentType, final String contentEncoding) { this.query = HttpUtil.parseQuery(queryString, decode, charset, contentType, contentEncoding); return this; } \n"}, {"ID": 694, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String queryString() { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResponse:", "ground_truth": "Generates query string. All values are URL encoded.", "predict": " public String queryString(String query, String queryEncoding) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResp public String queryString(String query) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResp public String queryString(String query, String queryEncoding, String acceptEncoding) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding, acceptEncoding); } \nResp public String queryString(String query, String queryEncoding, String acceptEncoding, String acceptLanguage) { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding, acceptEncoding, acceptLanguage); } \nResp"}, {"ID": 695, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); } \nResponse:", "ground_truth": "Returns just host url, without path and query.", "predict": " public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); } \n\n*/\n\npublic class StringBand {\n\tprivate StringBuffer buffer = new StringBuffer();\n\tprivate int length = 0;\n\t\n\tpublic StringBand(int length) {\n\t\tthis.length = length;\n\t}\n\t\n\tpublic void append(String string) {\n\t\tbuffer.append(string);\n\t\tlength += string.length();\n\t}\n\t\n\tpublic String toString() {\n\t\treturn buffer.toString();\n\t}\n\t\n\tpublic int length() {\n\t\treturn length;\n\t}\n}\n"}, {"ID": 696, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest basicAuthentication(final String username, final String password) { if (username != null && password != null) { String data = username.concat(StringPool.COLON).concat(password); String base64 = Base64.encodeToString(data); headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64); } return this; } \nResponse:", "ground_truth": "Enables basic authentication by adding required header.", "predict": "\n\n*/\n\npublic class BasicAuthentication extends HttpRequest {\n\n    private static final String HEADER_AUTHORIZATION = \"Authorization\";\n    private static final String HEADER_AUTHORIZATION_VALUE = \"Basic \";\n    private static final String HEADER_AUTHORIZATION_VALUE_BASE64 = \"Basic \";\n    private static final String HEADER_AUTHORIZATION_VALUE_BASE64_ENCODED = \"Basic \" + Base64.encodeToString(new String(new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T"}, {"ID": 697, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest setHostHeader() { String hostPort = this.host; if (port != Defaults.DEFAULT_PORT) { hostPort += StringPool.COLON + port; } headerOverwrite(HEADER_HOST, hostPort); return this; } \nResponse:", "ground_truth": "Sets 'Host' header from current host and port.", "predict": " public HttpRequest setHostHeader() { return this; }\n\n*/\n\npublic class HttpRequest {\n\t\n\tprivate String host;\n\tprivate int port;\n\tprivate String path;\n\tprivate String method;\n\tprivate String contentType;\n\tprivate String content;\n\tprivate String contentEncoding;\n\tprivate String acceptEncoding;\n\tprivate String accept;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String acceptEncodingCharset;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String acceptEncoding;\n\tprivate String acceptEncodingCharset;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n\tprivate String accept;\n\tprivate String acceptLanguageCharset;\n\tprivate String acceptLanguage;\n\tprivate String acceptCharset;\n"}, {"ID": 698, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Buffer buffer(final boolean fullRequest) { // INITIALIZATION // host port if (header(HEADER_HOST) == null) { setHostHeader(); } // form Buffer formBuffer = formBuffer(); // query string String queryString = queryString(); // user-agent if (header(\"User-Agent\") == null) { header(\"User-Agent\", Defaults.userAgent); } // POST method requires Content-Type to be set if (method.equals(\"POST\") && (contentLength() == null)) { contentLength(0); } // BUILD OUT Buffer request = new Buffer(); request.append(method) .append(SPACE) .append(path); if (query != null && !query.isEmpty()) { request.append('?'); request.append(queryString); } request.append(SPACE) .append(httpVersion) .append(CRLF); populateHeaderAndBody(request, formBuffer, fullRequest); return request; } \nResponse:", "ground_truth": "Prepares the request buffer.", "predict": " Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason) { // BUILD OUT Response response = new Response(buffer, status, reason); // BUILD OUT populateHeaderAndBody(response, buffer, false); return response; } \nResp Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason, final String contentType, final String content) { // BUILD OUT Response response = new Response(buffer, status, reason); // BUILD OUT populateHeaderAndBody(response, buffer, false); return response; } \nResp Generate the method-level comment for the following java Code. Code: @Override protected Response response(final Buffer buffer, final int status, final String reason, final String contentType, final String content, final String contentEncoding) { // BUILD OUT Response response = new Response(buffer,"}, {"ID": 699, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); } \nResponse:", "ground_truth": "Syntax sugar.", "predict": " public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); } \n\n*/\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\n\npublic class HttpClientTest {\n\n\tpublic static void main(String[] args) {\n\t\tHttpClient httpClient = Http"}, {"ID": 700, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Handler removeRange(final Handler firstHandler, final Label start, final Label end) { if (firstHandler == null) { return null; } else { firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end); } int handlerStart = firstHandler.startPc.bytecodeOffset; int handlerEnd = firstHandler.endPc.bytecodeOffset; int rangeStart = start.bytecodeOffset; int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) { return firstHandler; } if (rangeStart <= handlerStart) { if (rangeEnd >= handlerEnd) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler.nextHandler; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler(firstHandler, end, firstHandler.endPc); } } else if (rangeEnd >= handlerEnd) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler(firstHandler, firstHandler.startPc, start); } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = // [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc); return new Handler(firstHandler, firstHandler.startPc, start); } } \nResponse:", "ground_truth": "Removes the range between start and end from the Handler list that begins with the given\nelement.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@param start the start of the range to be removed.\n@param end the end of the range to be removed. Maybe {@literal null}.\n@return the exception handler list with the start-end range removed.", "predict": "\n\n*/\n\npublic class Handler {\n    public Handler(Handler nextHandler, Label start, Label end) {\n        this.nextHandler = nextHandler;\n        this.startPc = start;\n        this.endPc = end;\n    }\n\n    public Handler(Handler nextHandler, Label start, int end) {\n        this.nextHandler = nextHandler;\n        this.startPc = start;\n        this.endPc = new Label();\n        this.endPc.bytecodeOffset = end;\n    }\n\n    public Handler(Handler nextHandler, int start, Label end) {\n        this.nextHandler = nextHandler;\n        this.startPc = new Label();\n        this.startPc.bytecodeOffset = start;\n        this.endPc = end;\n    }\n\n    public Handler(Handler nextHandler, int start, int end) {\n        this.nextHandler = nextHandler;\n        this."}, {"ID": 701, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; } \nResponse:", "ground_truth": "Returns the number of elements of the Handler list that begins with the given element.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@return the number of elements of the Handler list that begins with 'handler'.", "predict": " static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; } \n\n*/\n\npublic class Solution {\n    public static int getExceptionTableLength(Handler firstHandler) {\n        int length = 0;\n        Handler handler = firstHandler;\n        while (handler != null) {\n            length++;\n            handler = handler.nextHandler;\n        }\n        return length;\n    }\n}\n"}, {"ID": 702, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionInterceptors() { final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors(); interceptors = new ArrayList<>(); interceptors.addAll(interceptorValues); interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all interceptors.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class InterceptorsManager {\n    private List<ActionInterceptor> interceptors = new ArrayList<>();\n\n    public InterceptorsManager() {\n        interceptors.add(new ActionInterceptor() {\n            @Override\n            public void intercept(ActionInvocation invocation) throws Exception {\n                System.out.println(\"Action Interceptor 1\");\n            }\n        });\n        interceptors.add(new ActionInterceptor() {\n            @Override\n            public void intercept(ActionInvocation invocation) throws Exception {\n                System.out.println(\"Action Interceptor 2\");\n            }\n        });\n    }\n\n    public List<ActionInterceptor> getAllInterceptors() {\n        return interceptors;\n    }\n}\n"}, {"ID": 703, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionFilters() { final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters(); filters = new ArrayList<>(); filters.addAll(filterValues); filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all filters.", "predict": " Response = new Response(); Response.setStatus(Response.Status.OK); Response.setEntity(filters); return Response; }\n\n@GET\n@Path(\"/{id}\")\n@Produces(MediaType.APPLICATION_JSON)\npublic Response getActionFilterById(@PathParam(\"id\") String id) {\n\tActionFilter filter = filtersManager.getActionFilterById(id);\n\tif (filter == null) {\n\t\treturn Response.status(Response.Status.NOT_FOUND).build();\n\t}\n\treturn Response.ok(filter).build();\n}\n\n@POST\n@Path(\"/{id}\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic Response addActionFilter(@PathParam(\"id\") String id, ActionFilter filter) {\n\tActionFilter filterToAdd = filtersManager.getActionFilterById(id);\n\tif ("}, {"ID": 704, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all action results.", "predict": " public void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \n\n*/\n\npublic class ActionResultCollector {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// TODO: Create a new instance of the ActionResultCollector class.\n\t\tActionResultCollector collector = new ActionResultCollector();\n\t\t\n\t\t// TODO: Create a new instance of the ActionResultManager class.\n\t\tActionResultManager manager = new ActionResultManager();\n\t\t\n\t\t// TODO: Create a new instance of the ActionResult class.\n\t\tActionResult result = new ActionResult();\n\t\t\n\t\t// TODO: Add the ActionResult to the ActionResultManager.\n\t\tmanager.addActionResult(result);\n\t\t\n\t\t//"}, {"ID": 705, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); } \nResponse:", "ground_truth": "Collects all action runtime configurations.", "predict": "\n\n*/\n\npackage com.epam.jdi.uitests.mobile.appium.elements.common;\n\nimport com.epam.commons.Timer;\nimport com.epam.jdi.uitests.core.interfaces.base.IClickable;\nimport com.epam.jdi.uitests.mobile.appium.elements.BaseElement;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebElement;\n\nimport java.util.List;\n\nimport static com.epam.commons.LinqUtils.first;\nimport static com.epam.commons.LinqUtils.select;\nimport static com.epam.jdi.uitests.core.settings.JDISettings.exception;\nimport static com.epam.jdi.uitests.mobile.appium.driver.WebDriverByUtils.fillByTemplate;"}, {"ID": 706, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected void setSimpleProperty(final BeanProperty bp, final Object value) { Setter setter = bp.getSetter(isDeclared); // try: setter if (setter != null) { invokeSetter(setter, bp, value); return; } // try: put(\"property\", value) if (bp.isMap()) { ((Map) bp.bean).put(bp.name, value); return; } if (isSilent) { return; } throw new BeanException(\"Simple property not found: \" + bp.name, bp); } \nResponse:", "ground_truth": "Sets a value of simple property.", "predict": " void\n*/\n\npublic class BeanException extends RuntimeException {\n    private static final long serialVersionUID = -828379842290987909L;\n\n    public BeanException(final String message, final BeanProperty bp) {\n        super(message + \": \" + bp);\n    }\n}\n"}, {"ID": 707, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <T> T getProperty(final Object bean, final String name) { BeanProperty beanProperty = new BeanProperty(this, bean, name); if (!isSilent) { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } else { try { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } catch (Exception ignore) { return null; } } } \nResponse:", "ground_truth": "Returns value of bean's property.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 708, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); } \nResponse:", "ground_truth": "Extract the first name of this reference.", "predict": " @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); } \n\n*/\n\npublic class ExtractThisReference {\n\n\tpublic static void main(String[] args) {\n\t\tString code = \"public class Test { \" +\n\t\t\t\t\"private String name; \" +\n\t\t\t\t\"private int age; \" +\n\t\t\t\t\"private String address; \" +\n\t\t\t\t\"private String[] friends; \" +\n\t\t\t\t\"private String[] friends2; \" +\n\t\t\t\t\"private String[] friends3; \" +\n\t\t\t\t\"private String[] friends4; \" +\n\t\t\t\t\"private String[] friends5; \" +\n\t\t\t\t\"private String[] friends6; \" +\n\t\t\t\t\"private String[] friends7; \" +\n\t\t\t\t\"private String[] friends8; \" +\n\t\t\t\t\""}, {"ID": 709, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; } \nResponse:", "ground_truth": "Returns buffered writer. Buffer will be created if not already used.", "predict": " @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = in.nextInt();\n        }\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(arr[i] + arr[j] > max){\n                    max = arr[i] + arr[j];\n                }\n            }\n        }\n        System.out.println(max);"}, {"ID": 710, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setObjectReference(final String name, final Object object) { if (objectRefs == null) { objectRefs = new HashMap<>(); } objectRefs.put(name, object); } \nResponse:", "ground_truth": "Saves object reference.", "predict": " Response is generated by the method.\n\n*/\n\npublic class ObjectReference {\n\t\n\tpublic static void setObjectReference(final String name, final Object object) {\n\t\tif (objectRefs == null) {\n\t\t\tobjectRefs = new HashMap<>();\n\t\t}\n\t\tobjectRefs.put(name, object);\n\t}\n\t\n\tpublic static Object getObjectReference(final String name) {\n\t\treturn objectRefs.get(name);\n\t}\n\t\n\tprivate static HashMap<String, Object> objectRefs = null;\n}\n"}, {"ID": 711, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); } \nResponse:", "ground_truth": "Returns object reference.", "predict": " Resp public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); } \n\n*/\n\npublic class ObjectReference {\n\t\n\tprivate static final String OBJECT_REFERENCE_PREFIX = \"ObjectReference: \";\n\t\n\tprivate static final String OBJECT_REFERENCE_SUFFIX = \"\";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR = \" \";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX = \"\\\\s+\";\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX_MATCHER = Pattern.compile(OBJECT_REFERENCE_SEPARATOR_REGEX);\n\t\n\tprivate static final String OBJECT_REFERENCE_SEPARATOR_REGEX_MATCHER_MATCHER"}, {"ID": 712, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; } \nResponse:", "ground_truth": "Lookups for object reference and throws an exception if reference doesn't exist.", "predict": " public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; } \n\n*/\n\npublic class DbSqlBuilderException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic DbSqlBuilderException(final String message) {\n\t\tsuper(message);\n\t}\n}\n"}, {"ID": 713, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor getTableDescriptor(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.desc; } \nResponse:", "ground_truth": "Returns entity descriptor for provided table reference.", "predict": " Response is generated by the method getTableDescriptor(final String tableRef)\n*/\n\npublic class TableRefData {\n\tpublic DbEntityDescriptor desc;\n\tpublic String tableRef;\n\tpublic TableRefData(DbEntityDescriptor desc, String tableRef) {\n\t\tthis.desc = desc;\n\t\tthis.tableRef = tableRef;\n\t}\n}\n"}, {"ID": 714, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) { for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) { DbEntityDescriptor ded = entry.getValue().desc; if (ded.findByPropertyName(columnRef) != null) { return ded; } } return null; } \nResponse:", "ground_truth": "Finds entity descriptor of a table that contains provided column reference.", "predict": " Response = Response.ok().build();\n\n*/\n\npublic class TableRefData {\n\tprivate String tableName;\n\tprivate DbEntityDescriptor ded;\n\t\n\tpublic TableRefData(String tableName, DbEntityDescriptor ded) {\n\t\tthis.tableName = tableName;\n\t\tthis.ded = ded;\n\t}\n\t\n\tpublic String getTableName() {\n\t\treturn tableName;\n\t}\n\t\n\tpublic DbEntityDescriptor getDed() {\n\t\treturn ded;\n\t}\n}\n"}, {"ID": 715, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getTableAlias(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.alias; } \nResponse:", "ground_truth": "Returns table alias for provided table reference.", "predict": " Response is generated by the method getTableAlias(final String tableRef)\n*/\n\npublic class TableRefData {\n\tpublic String tableRef;\n\tpublic String alias;\n\t\n\tpublic TableRefData(String tableRef, String alias) {\n\t\tthis.tableRef = tableRef;\n\t\tthis.alias = alias;\n\t}\n}\n"}, {"ID": 716, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) { if (tableRefs == null) { tableRefs = new HashMap<>(); } TableRefData t = new TableRefData(ded, tableAlias); if (tableRefs.put(tableReference, t) != null) { throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference); } } \nResponse:", "ground_truth": "Registers table reference for provided entity.", "predict": "\n\n*/\n\npublic class TableRefData {\n    private final DbEntityDescriptor ded;\n    private final String tableAlias;\n\n    public TableRefData(final DbEntityDescriptor ded, final String tableAlias) {\n        this.ded = ded;\n        this.tableAlias = tableAlias;\n    }\n\n    public DbEntityDescriptor getDed() {\n        return ded;\n    }\n\n    public String getTableAlias() {\n        return tableAlias;\n    }\n}\n"}, {"ID": 717, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor lookupTableRef(final String tableRef) { DbEntityDescriptor ded = getTableDescriptor(tableRef); if (ded == null) { throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef); } return ded; } \nResponse:", "ground_truth": "Lookups for table reference and throws an exception if table reference not found.", "predict": " Response = new Response();\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTableName(tableRef);\nResponse.setTableDescriptor(lookupTableRef(tableRef));\nResponse.setTable"}, {"ID": 718, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); } \nResponse:", "ground_truth": "Registers a hint.", "predict": " public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); } \n\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.test();\n    }\n\n    public void test() {\n        String[] hints = {\"hint1\", \"hint2\", \"hint3\"};\n        int hintCount = hints.length;\n        String[] hintStrings = new String[hintCount];\n        for (int i = 0; i < hintCount; i++) {\n            hintStrings[i] = hints[i];\n        }\n        System.out.println(hintStrings);\n    }\n}\n"}, {"ID": 719, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public final boolean serialize(final JsonContext jsonContext, final T value) { if (jsonContext.pushValue(value)) { // prevent circular dependencies return false; } serializeValue(jsonContext, value); jsonContext.popValue(); return true; } \nResponse:", "ground_truth": "Detects circular dependencies and pushes value as current\ntype context.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 720, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) { final Enumeration<String> attributeNames = servletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attrName = attributeNames.nextElement(); targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(attrName); if (name != null) { final Object attrValue = servletRequest.getAttribute(attrName); target.writeValue(name, attrValue, true); } }); } } \nResponse:", "ground_truth": "Injects request attributes.", "predict": " Response is generated by the following java Code. Code: public Response getResponse(final Targets targets) { final Response response = new Response(); final Enumeration<String> attributeNames = targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(target.getName()); if (name != null) { final Object attrValue = target.getValue(name); response.addAttribute(name, attrValue); } }); return response; } \n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Target {\n    private String name;\n    private List<Injection> injections = new ArrayList<>();\n\n    public Target(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n"}, {"ID": 721, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) { final boolean encode = encodeGetParams && servletRequest.getMethod().equals(\"GET\"); final Enumeration<String> paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = ServletUtil.prepareParameters( paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues != null) { if (encode) { for (int j = 0; j < paramValues.length; j++) { final String p = paramValues[j]; if (p != null) { final String encoding = madvocEncoding.getEncoding(); paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding); } } } final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]); target.writeValue(name, value, true); } } }); } } \nResponse:", "ground_truth": "Inject request parameters.", "predict": "\n\n*/\npackage org.madvoc.servlet.multipart;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.util.Streams;\nimport org"}, {"ID": 722, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) { if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } final Enumeration<String> paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { final FileUpload[] paramValues = multipartRequest.getFiles(paramName); if (ignoreInvalidUploadFiles) { for (int j = 0; j < paramValues.length; j++) { final FileUpload paramValue = paramValues[j]; if ((!paramValue.isValid()) || (!paramValue.isUploaded())) { paramValues[j] = null; } } } final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues); target.writeValue(name, value, true); } }); } } \nResponse:", "ground_truth": "Inject uploaded files from multipart request parameters.", "predict": "\n\n*/\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\npublic class UploadServlet extends BaseServlet {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String UPLOAD_DIR = \"upload\";\n\n\tprivate static final int MAX"}, {"ID": 723, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertPropertyNameToColumnName(final String propertyName) { StringBuilder tableName = new StringBuilder(propertyName.length() * 2); if (splitCamelCase) { String convertedTableName = Format.fromCamelCase(propertyName, separatorChar); tableName.append(convertedTableName); } else { tableName.append(propertyName); } if (!changeCase) { return tableName.toString(); } return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString(); } \nResponse:", "ground_truth": "Converts property name to column name.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConvertPropertyNameToColumnName {\n\n    public static void main(String[] args) {\n        String propertyName = \"propertyName\";\n        String separatorChar = \".\";\n        boolean splitCamelCase = true;\n        boolean changeCase = true;\n        boolean uppercase = true;\n\n        StringBuilder tableName = new StringBuilder(propertyName.length() * 2);\n        if (splitCamelCase) {\n            String convertedTableName = Format.fromCamelCase(propertyName, separatorChar);\n            tableName.append(convertedTableName);\n        } else {\n            tableName.append(propertyName);\n        }\n        if (!changeCase) {\n            return tableName.toString();\n        "}, {"ID": 724, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertColumnNameToPropertyName(final String columnName) { StringBuilder propertyName = new StringBuilder(columnName.length()); int len = columnName.length(); if (splitCamelCase) { boolean toUpper = false; for (int i = 0; i < len; i++) { char c = columnName.charAt(i); if (c == separatorChar) { toUpper = true; continue; } if (toUpper) { propertyName.append(Character.toUpperCase(c)); toUpper = false; } else { propertyName.append(Character.toLowerCase(c)); } } return propertyName.toString(); } return columnName; } \nResponse:", "ground_truth": "Converts column name to property name.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println(solution.convertToTitleCase(\"This is a test\"));\n        System.out.println("}, {"ID": 725, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String applyToColumnName(final String columnName) { String propertyName = convertColumnNameToPropertyName(columnName); return convertPropertyNameToColumnName(propertyName); } \nResponse:", "ground_truth": "Applies column naming strategy to given column name hint.\nReturns full column name.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 726, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException { T t = TypeConverterManager.get().convertType(value, sqlType); set(st, index, t, dbSqlType); } \nResponse:", "ground_truth": "Stores value in database. Value is casted to sql type.", "predict": " Response is generated by the method-level comment.\n\n*/\n\npublic class TypeConverterManager {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(TypeConverterManager.class);\n\t\n\tprivate static final String SQL_TYPE_PREFIX = \"java.sql.Types.\";\n\t\n\tprivate static final Map<String, Class<?>> SQL_TYPE_MAP = new HashMap<String, Class<?>>();\n\t\n\tstatic {\n\t\tSQL_TYPE_MAP.put(\"BIT\", Boolean.class);\n\t\tSQL_TYPE_MAP.put(\"TINYINT\", Byte.class);\n\t\tSQL_TYPE_MAP.put(\"SMALLINT\", Short.class);\n\t\tSQL_TYPE_MAP.put(\"INTEGER\", Integer.class);\n\t\tSQL_TYPE_MAP.put(\"BIGINT\", Long.class);\n\t\tSQL_TYPE_MAP.put(\"FLOAT\", Float.class"}, {"ID": 727, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected <E> E prepareGetValue(final T t, final Class<E> destinationType) { if (t == null) { return null; } if (destinationType == null) { return (E) t; } return TypeConverterManager.get().convertType(t, destinationType); } \nResponse:", "ground_truth": "Once when value is read from result set, prepare it to match destination type.\n@param t get value\n@param destinationType destination type", "predict": " Response<T> prepareGetValue(final T t, final Class<T> destinationType) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t); } return Response.ok(TypeConverterManager.get().convertType(t, destinationType)); } \nResp Response<T> prepareGetValue(final T t, final Class<T> destinationType, final String contentType) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t); } return Response.ok(TypeConverterManager.get().convertType(t, destinationType), contentType); } \nResp Response<T> prepareGetValue(final T t, final Class<T> destinationType, final String contentType, final String accept) { if (t == null) { return null; } if (destinationType == null) { return Response.ok(t"}, {"ID": 728, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Set<T> getAll() { final Set<T> set = new HashSet<>(wrappers.size()); set.addAll(wrappers.values()); return set; } \nResponse:", "ground_truth": "Returns all action wrappers. Returns a copy in new set.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 729, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; } \nResponse:", "ground_truth": "Resolves single wrapper. Creates new wrapper instance if not already registered.\nDoes not expand the wrappers.", "predict": " public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; } \n\n*/\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class WrapperGenerator {\n\t\n\tprivate static final String WRAPPER_PACKAGE = \"com.github.javaparser.wrapper\";\n\tprivate static final String WRAPPER_CLASS_NAME = \"Wrapper\";\n\tprivate static final String WRAPPER_CLASS_FULL_NAME = WRAPPER_PACKAGE + \".\" + WRAPPER_CLASS_NAME;\n\tprivate static final String WRAPPER_CLASS_DESCRIPTION = \"Wrapper class for the given type\";\n\tprivate static final String WR"}, {"ID": 730, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } } \nResponse:", "ground_truth": "Creates new wrapper.", "predict": " public <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } } \n\n*/\n\npackage madvoc.sample.simple;\n\nimport java.util.Date;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.web.servlet.ModelAndView;\n\nimport madvoc.ActionMethod;\nimport madvoc.MadvocConfig;\nimport madvoc.sample.simple.model.User;\n\n/**\n * @author mariotaku\n */\npublic class SimpleAction {\n\n\t@ActionMethod(value = \"/simple/{id}\")\n\tpublic ModelAndView show(HttpServletRequest request, HttpServletResponse"}, {"ID": 731, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } } \nResponse:", "ground_truth": "Converts all separators to the system separator.\n\n@param path  the path to be changed, null ignored\n@return the updated path", "predict": "\n\npublic static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } } \n\npublic static String separatorsToWindows(final String path) { if (path == null) { return null; } if (path.indexOf(WINDOWS_SEPARATOR) == -1) { return path; } else { return path.replace(WINDOWS_SEPARATOR, SYSTEM_SEPARATOR); } } \npublic static String separatorsToUnix(final String path) { if (path == null) { return null; } if (path.indexOf(SYSTEM_SEPARATOR) == -1) { return path; } else { return path.replace(SYSTEM_SEPARATOR, WINDOWS_SEPARATOR); } } \n\npublic static String separators"}, {"ID": 732, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String doGetPath(final String filename, final int separatorAdd) { if (filename == null) { return null; } int prefix = getPrefixLength(filename); if (prefix < 0) { return null; } int index = indexOfLastSeparator(filename); int endIndex = index + separatorAdd; if (prefix >= filename.length() || index < 0 || prefix >= endIndex) { return StringPool.EMPTY; } return filename.substring(prefix, endIndex); } \nResponse:", "ground_truth": "Does the work of getting the path.\n\n@param filename  the filename\n@param separatorAdd  0 to omit the end separator, 1 to return it\n@return the path", "predict": "\n\n*/\n\npublic class Solution {\n    public static int getPrefixLength(String filename) {\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return -1;\n        }\n        return index;\n    }\n\n    public static int indexOfLastSeparator(String filename) {\n        if (filename == null) {\n            return -1;\n        }\n        int lastUnixPos = filename.lastIndexOf('/');\n        int lastWindowsPos = filename.lastIndexOf('\\\\');\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    public static String getPath(String filename) {\n        if (filename == null) {\n            return null;\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return StringPool.EMPTY;\n        }\n        return filename.substring"}, {"ID": 733, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } return new String[] {prefix, path, baseName, extension}; } \nResponse:", "ground_truth": "Splits filename into a array of four Strings containing prefix, path, basename and extension.\nPath will contain ending separator.", "predict": " public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool."}, {"ID": 734, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relativePath(final String targetPath, final String basePath) { return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString(); } \nResponse:", "ground_truth": "Calculates relative path of target path on base path.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 735, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; } \nResponse:", "ground_truth": "Registers additional Madvoc components after the registration of default components.", "predict": " public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String... path) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String path) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path)); return this; } \nResp public WebApp registerComponent(final Class<?> madvocComponent, final String path, final String... pathSegments) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent, path, pathSeg"}, {"ID": 736, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; } \nResponse:", "ground_truth": "Configures the action configurations.", "predict": " public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; } \nResp public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer, actionConfigConsumer)); return this; } \nResp public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final BiConsumer<A, Response> actionConfigConsumer, final BiConsumer<A, Response> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with("}, {"ID": 737, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp start() { log = LoggerFactory.getLogger(WebApp.class); log.debug(\"Initializing Madvoc WebApp\"); //// params & props for (final Map<String, Object> params : paramsList) { madvocContainer.defineParams(params); } for (final Props props : propsList) { madvocContainer.defineParams(props); } propsList = null; //// components registerMadvocComponents(); madvocComponents.forEach( madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer())); madvocComponents = null; madvocComponentInstances.forEach(madvocContainer::registerComponentInstance); madvocComponentInstances = null; configureDefaults(); //// listeners madvocContainer.fireEvent(Init.class); //// component configuration componentConfigs.accept(madvocContainer); componentConfigs = null; initialized(); madvocContainer.fireEvent(Start.class); if (!madvocRouterConsumers.isEmpty()) { final MadvocRouter madvocRouter = MadvocRouter.create(); madvocContainer.registerComponentInstance(madvocRouter); madvocRouterConsumers.accept(madvocRouter); } madvocRouterConsumers = null; started(); madvocContainer.fireEvent(Ready.class); ready(); return this; } \nResponse:", "ground_truth": "Initializes and starts web application.", "predict": " public WebApp start() { return null; } \npublic WebApp start() { return null; } \npublic WebApp start(final Map<String, Object> params) { return null; } \npublic WebApp start(final Props props) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Map<String, Object> params, final Props props, final Map<String, Object> componentConfigs) { return null; } \npublic WebApp start(final Props props, final Map<String, Object> componentConfigs, final Map<String,"}, {"ID": 738, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void configureDefaults() { final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class); actionConfigManager.registerAnnotation(Action.class); actionConfigManager.registerAnnotation(RestAction.class); } \nResponse:", "ground_truth": "Configure defaults.", "predict": "\n\n*/\n\npackage org.madvoc.config;\n\nimport org.madvoc.Action;\nimport org.madvoc.MadvocConfigurator;\nimport org.madvoc.Scope;\nimport org.madvoc.ScopeType;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.ActionConfigBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder.RestActionConfigBuilderBuilderBuilder;\nimport org.madvoc.config.ConfiguratorHelper.ActionConfig.RestActionConfigBuilder.RestActionConfigBuilderBuilder.RestActionConfigBuilderBuilderBuilderBuilder;\nimport"}, {"ID": 739, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerMadvocComponents() { if (madvocContainer == null) { throw new MadvocException(\"Madvoc WebApp not initialized.\"); } log.debug(\"Registering Madvoc WebApp components\"); madvocContainer.registerComponent(MadvocEncoding.class); madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext)); madvocContainer.registerComponent(ActionConfigManager.class); madvocContainer.registerComponent(ActionMethodParamNameResolver.class); madvocContainer.registerComponent(ActionMethodParser.class); madvocContainer.registerComponent(ActionPathRewriter.class); madvocContainer.registerComponent(ActionsManager.class); madvocContainer.registerComponent(ContextInjectorComponent.class); madvocContainer.registerComponent(InterceptorsManager.class); madvocContainer.registerComponent(FiltersManager.class); madvocContainer.registerComponent(MadvocController.class); madvocContainer.registerComponent(RootPackages.class); madvocContainer.registerComponent(ResultsManager.class); madvocContainer.registerComponent(ResultMapper.class); madvocContainer.registerComponent(ScopeResolver.class); madvocContainer.registerComponent(ScopeDataInspector.class); madvocContainer.registerComponent(AsyncActionExecutor.class); madvocContainer.registerComponent(FileUploader.class); } \nResponse:", "ground_truth": "Registers default Madvoc components.", "predict": "\n\n*/\n\npackage org.madvoc.config;\n\nimport org.madvoc.interceptor.Interceptor;\nimport org.madvoc.interceptor.InterceptorsManager;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.InterceptorType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Type;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType.PriorityTypeType;\nimport org.madvoc.interceptor.InterceptorsManager.InterceptorInfo.Priority.PriorityType.PriorityTypeTypeType;"}, {"ID": 740, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeJars(final String... excludedJars) { for (final String excludedJar : excludedJars) { rulesJars.exclude(excludedJar); } return this; } \nResponse:", "ground_truth": "Specify excluded jars.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 741, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeJars(final String... includedJars) { for (final String includedJar : includedJars) { rulesJars.include(includedJar); } return this; } \nResponse:", "ground_truth": "Specify included jars.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 742, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; } \nResponse:", "ground_truth": "Sets included set of names that will be considered during configuration.\n@see InExRules", "predict": " Resp public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; } \n\n*/\n\npublic class ClassScanner {\n\t\n\tprivate static final Logger LOGGER = Logger.getLogger(ClassScanner.class);\n\t\n\tprivate final String[] includedEntries;\n\tprivate final String[] excludedEntries;\n\tprivate final String[] includedPackages;\n\tprivate final String[] excludedPackages;\n\tprivate final String[] includedClasses;\n\tprivate final String[] excludedClasses;\n\tprivate final String[] includedMethods;\n\tprivate final String[] excludedMethods;\n\tprivate final String[] includedFields;\n\tprivate final String[] excludedFields;\n\tprivate final String[] includedAnnotations;\n\tprivate final String[] excludedAnnotations;\n\tprivate final String[] includedInterfaces;\n\tprivate final"}, {"ID": 743, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeEntries(final String... excludedEntries) { for (final String excludedEntry : excludedEntries) { rulesEntries.exclude(excludedEntry); } return this; } \nResponse:", "ground_truth": "Sets excluded names that narrows included set of packages.\n@see InExRules", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 744, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanJarFile(final File file) { final ZipFile zipFile; try { zipFile = new ZipFile(file); } catch (IOException ioex) { if (!ignoreException) { throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex); } return; } final Enumeration entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry zipEntry = (ZipEntry) entries.nextElement(); final String zipEntryName = zipEntry.getName(); try { if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) { final String entryName = prepareEntryName(zipEntryName, true); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } else if (includeResources) { final String entryName = prepareEntryName(zipEntryName, false); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } } catch (RuntimeException rex) { if (!ignoreException) { ZipUtil.close(zipFile); throw rex; } } } ZipUtil.close(zipFile); } \nResponse:", "ground_truth": "Scans classes inside single JAR archive. Archive is scanned as a zip file.\n@see #onEntry(ClassPathEntry)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class JarScanner {\n    private static final String CLASS_FILE_EXT = \".class\";\n    private static final String JAR_FILE_EXT = \".jar\";\n    private static final String JAR_FILE_MARKER = \"META-INF/MANIFEST.MF\";\n    private static final String JAR_FILE_MARKER_PREFIX = \"META-INF/\";\n    private static final String JAR_FILE_MARKER_SUFFIX = \"/MANIFEST.MF\";\n    private static final String JAR_FILE_MARKER_PREFIX_LENGTH = JAR_"}, {"ID": 745, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanClassPath(final File root) { String rootPath = root.getAbsolutePath(); if (!rootPath.endsWith(File.separator)) { rootPath += File.separatorChar; } final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath); File file; while ((file = ff.nextFile()) != null) { final String filePath = file.getAbsolutePath(); try { if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) { scanClassFile(filePath, rootPath, file, true); } else if (includeResources) { scanClassFile(filePath, rootPath, file, false); } } catch (RuntimeException rex) { if (!ignoreException) { throw rex; } } } } \nResponse:", "ground_truth": "Scans single classpath directory.\n@see #onEntry(ClassPathEntry)", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.lang3.tuple.Triple;\nimport org.apache.commons.lang3.tuple.Triple.TripleBuilder;\nimport org.apache.commons.lang3.tuple.Triple.Tri"}, {"ID": 746, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] bytecodeSignatureOfType(final Class type) { final String name = 'L' + type.getName().replace('.', '/') + ';'; return name.getBytes(); } \nResponse:", "ground_truth": "Returns type signature bytes used for searching in class file.", "predict": "\n\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JavaCodeGenerator {\n    public static String generateJavaCode(String className, List<String> methods) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"public class \" + className + \" {\\n\");\n        for (String method : methods) {\n            builder.append(method + \"\\n\");\n        }\n        builder.append(\"}\");\n        return builder.toString();\n    }\n}\n"}, {"ID": 747, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner scan(final String... paths) { for (final String path : paths) { filesToScan.add(new File(path)); } return this; } \nResponse:", "ground_truth": "Scans provided paths.", "predict": " Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp Resp"}, {"ID": 748, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (detectEntriesMode) { rulesEntries.detectMode(); } filesToScan.forEach(file -> { final String path = file.getAbsolutePath(); if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) { if (!acceptJar(file)) { return; } scanJarFile(file); } else if (file.isDirectory()) { scanClassPath(file); } }); } \nResponse:", "ground_truth": "Starts with the scanner.", "predict": "\n\n*/\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.apache.commons.io"}]