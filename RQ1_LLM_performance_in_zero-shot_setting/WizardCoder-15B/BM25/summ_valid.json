[{"ID": 1, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> boolean onNext(Subscriber<? super T> subscriber, T value, AtomicInteger wip, AtomicThrowable error) { if (wip.get() == 0 && wip.compareAndSet(0, 1)) { subscriber.onNext(value); if (wip.decrementAndGet() != 0) { Throwable ex = error.terminate(); if (ex != null) { subscriber.onError(ex); } else { subscriber.onComplete(); } return true; } } return false; }\n\n    ### Response: Emits the given value if possible and terminates if there was an onComplete or onError\nwhile emitting, drops the value otherwise.\n\n@param  the value type\n@param subscriber the target Subscriber to emit to\n@param value the value to emit\n@param wip the serialization work-in-progress counter/indicator\n@param error the holder of Throwables\n@return true if a terminal event was emitted to {@code observer}, false if not.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = downstream; final SimplePlainQueue<U> q = queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); }\n\n    ### Response:", "ground_truth": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "predict": "Emits the given value to the downstream observer, if possible, in a fast-path manner.\n\n@param value the value to emit\n@param delayError if true, errors are delayed until all values have been emitted\n@param disposable the Disposable to dispose on termination\n@return true if the value was emitted, false if not (e.g., the downstream observer is cancelled)\n\n    "}, {"ID": 2, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) { if (times < 0) { throw new IllegalArgumentException(\"times >= 0 required but it was \" + times); } ObjectHelper.requireNonNull(predicate, \"predicate is null\"); return RxJavaPlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate)); }\n\n    ### Response: Retries at most times or until the predicate returns false, whichever happens first.\n\n\nBackpressure:\nThe operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\nIf this expectation is violated, the operator may throw an {@code IllegalStateException}.\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to repeat\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Flowable instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public static <T> Observable<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); }\n\n    ### Response:", "ground_truth": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n\nScheduler:\n{@code wrap} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "predict": "Wraps a source {@code ObservableSource} into an Observable.\n\n@param source the source ObservableSource, not null\n@return the new Observable instance\n\nNote that the resulting Observable is not backed by the source ObservableSource,\nbut rather by a safe Observable wrapper that ensures the source is properly\nsubscribed and unsubscribed."}, {"ID": 3, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final <U, R> Maybe<R> zipWith(MaybeSource<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) { ObjectHelper.requireNonNull(other, \"other is null\"); return zip(this, other, zipper); }\n\n    ### Response: Waits until this and the other MaybeSource signal a success value then applies the given BiFunction\nto those values and emits the BiFunction's resulting value to downstream.\n\n\n\nIf either this or the other MaybeSource is empty or signals an error, the resulting Maybe will\nterminate immediately and dispose the other source.\n\n\nScheduler:\n{@code zipWith} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of items emitted by the {@code other} MaybeSource\n@param \nthe type of items emitted by the resulting Maybe\n@param other\nthe other MaybeSource\n@param zipper\na function that combines the pairs of items from the two MaybeSources to generate the items to\nbe emitted by the resulting Maybe\n@return the new Maybe instance\n@see ReactiveX operators documentation: Zip.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Observable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\"); return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); }\n\n    ### Response:", "ground_truth": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "predict": "Sorts the items emitted by the source Observable in ascending order according to a specified\nComparator.\n\n\nIf the source Observable completes without emitting any items, the resulting Observable will also complete\nwithout emitting any items.\n\n\nIf the source Observable emits any null item, the resulting Observable will throw a NullPointerException\nwhen trying to access that item.\n\n\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\nthe function that compares two items emitted by the source Observable and returns a negative integer, zero,\nor a positive integer as the first item is less than, equal to, or greater than the second item\n@return the new Observable instance\n@see ReactiveX operators documentation: Sort."}, {"ID": 4, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> ConnectableObservable<T> wrap( ConnectableObservable<T> source, Collection<ReactiveInstrumenter> instrumentations) { return new RxInstrumentedConnectableObservable<>(source, instrumentations); }\n\n    ### Response: Wrap a connectable observable.\n@param source The source\n@param instrumentations The instrumentations\n@param  The type\n@return The wrapped subscriber.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); }\n\n    ### Response:", "ground_truth": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "Observe the connectable observable on a specified scheduler.\n@param co The connectable observable\n@param scheduler The scheduler to observe on\n@param  The type of the observable\n@return The observable that observes on the specified scheduler."}, {"ID": 5, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> Transformer<T, List<T>> bufferWhile(Func1<? super T, Boolean> predicate, int capacityHint) { return new OperatorBufferPredicateBoundary<T>(predicate, RxRingBuffer.SIZE, capacityHint, false); }\n\n    ### Response: Buffers the elements into continuous, non-overlapping Lists where the\nboundary is determined by a predicate receiving each item, before being\nbuffered, and returns true to indicate a new buffer should start.\n\n\nThe operator won't return an empty first or last buffer.\n\n\nBackpressure Support:\nThis operator supports backpressure.\nScheduler:\nThis operator does not operate by default on a particular\n{@link Scheduler}.\n\n\n@param \nthe input value type\n@param predicate\nthe Func1 that receives each item, before being buffered, and\nshould return true to indicate a new buffer has to start.\n@param capacityHint\nthe expected number of items in each buffer\n@return the new Observable instance\n@see #bufferWhile(Func1)\n@since (if this graduates from Experimental/Beta to supported, replace\nthis parenthetical with the release number).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); }\n\n    ### Response:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "predict": "Creates a new {@link UnicastProcessor} instance with the specified buffer capacity hint.\n\n\nThe buffer capacity hint is a hint to the underlying buffer size and is used to optimize the performance of the operator.\n\n\nThe operator will request an initial buffer size of 16 and will request additional buffers as needed up to the specified capacity hint.\n\n\nBackpressure Support:\nThis operator supports backpressure.\n\n\nScheduler:\nThis operator does not operate by default on a particular\n{@link Scheduler}.\n\n\n@param capacityHint the buffer capacity hint\n@return the new UnicastProcessor instance\n@since 1.2.6"}, {"ID": 6, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> Transformer<T, List<T>> bufferWhile(Func1<? super T, Boolean> predicate, int capacityHint) { return new OperatorBufferPredicateBoundary<T>(predicate, RxRingBuffer.SIZE, capacityHint, false); }\n\n    ### Response: Buffers the elements into continuous, non-overlapping Lists where the\nboundary is determined by a predicate receiving each item, before being\nbuffered, and returns true to indicate a new buffer should start.\n\n\nThe operator won't return an empty first or last buffer.\n\n\nBackpressure Support:\nThis operator supports backpressure.\nScheduler:\nThis operator does not operate by default on a particular\n{@link Scheduler}.\n\n\n@param \nthe input value type\n@param predicate\nthe Func1 that receives each item, before being buffered, and\nshould return true to indicate a new buffer has to start.\n@param capacityHint\nthe expected number of items in each buffer\n@return the new Observable instance\n@see #bufferWhile(Func1)\n@since (if this graduates from Experimental/Beta to supported, replace\nthis parenthetical with the release number).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) { ObjectHelper.requireNonNull(onCancelled, \"onTerminate\"); return new UnicastProcessor<T>(capacityHint, onCancelled); }\n\n    ### Response:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "predict": "Creates a new {@link UnicastProcessor} instance with the given capacity hint and onCancelled action.\n\n\nThe returned processor will be empty and not started.\n\n\n@param capacityHint\nthe expected number of items to be buffered before pausing the downstream\nsubscribers\n@param onCancelled\nthe action to be called when the downstream subscribers cancel the\nsubscription\n@return the new UnicastProcessor instance\n@throws NullPointerException\nif the onCancelled action is null\n@since 2.0\n\n    "}, {"ID": 7, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E extends Comparable<E>> boolean sort(List<E> input) { if (input == null) { return false; } try { Collections.sort(input); return true; } catch (UnsupportedOperationException ex) { return false; } }\n\n    ### Response: Sort the elements within a list according to their natural order. The input list is modified in place, so this\noperation will succeed only if the list is modifiable.\n\n@param  the type of the elements in the list\n@param input the list to sort\n@return {@code true} if the list was successfully sorted, {@code false} otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (u == null) { EmptySubscription.complete(subscriber); return true; } subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u)); } else { r.subscribe(subscriber); } return true; } return false; }\n\n    ### Response:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param  the input value type\n@param  the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "predict": "Subscribe to a source publisher and apply a function to each element to obtain a new publisher. If the resulting publisher is a Callable, extract the value and subscribe to it. Otherwise, subscribe to the resulting publisher.\n\n@param <T> the type of the elements in the source publisher\n@param <R> the type of the elements in the resulting publisher\n@param source the source publisher\n@param subscriber the subscriber to subscribe to the resulting publisher\n@param mapper the function to apply to each element in the source publisher to obtain a new publisher\n@return {@code true} if the subscription was successful, {@code false} otherwise."}, {"ID": 8, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, K, U> Collector<T, ?, LinkedHashMap<K, U>> toLinkedMap( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction) { return Collectors.toMap(keyMapper, valueMapper, mergeFunction, LinkedHashMap::new); }\n\n    ### Response: Collects a stream to a LinkedHashMap.\n@param keyMapper   function to deal with keys.\n@param valueMapper function to deal with values.\n@param mergeFunction function to apply one values if keyMapper produces same key multiple times.\n@param          type of element in input stream.\n@param          type of key for created map.\n@param          type of value for created map.\n@return map with a key/value for each item in the stream..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper)); }\n\n    ### Response:", "ground_truth": "Maps a scalar value into a Publisher and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "predict": "Maps a scalar value to a Publisher of values using a mapper function.\n@param value scalar value to map.\n@param mapper function to map the scalar value to a Publisher of values.\n@param          type of scalar value.\n@param          type of value in the Publisher.\n@return a Flowable that emits the mapped values.\n\n    "}, {"ID": 9, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reset() { for (Object name : Collections.list(MAP_KEY_TO_SCOPE.keys())) { closeScope(name); } ConfigurationHolder.configuration.onScopeForestReset(); ScopeImpl.resetUnBoundProviders(); }\n\n    ### Response: Clears all scopes. Useful for testing and not getting any leak....\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reset() { setErrorHandler(null); setScheduleHandler(null); setComputationSchedulerHandler(null); setInitComputationSchedulerHandler(null); setIoSchedulerHandler(null); setInitIoSchedulerHandler(null); setSingleSchedulerHandler(null); setInitSingleSchedulerHandler(null); setNewThreadSchedulerHandler(null); setInitNewThreadSchedulerHandler(null); setOnFlowableAssembly(null); setOnFlowableSubscribe(null); setOnObservableAssembly(null); setOnObservableSubscribe(null); setOnSingleAssembly(null); setOnSingleSubscribe(null); setOnCompletableAssembly(null); setOnCompletableSubscribe(null); setOnConnectableFlowableAssembly(null); setOnConnectableObservableAssembly(null); setOnMaybeAssembly(null); setOnMaybeSubscribe(null); setOnParallelAssembly(null); setFailOnNonBlockingScheduler(false); setOnBeforeBlocking(null); }\n\n    ### Response:", "ground_truth": "Removes all handlers and resets to default behavior.", "predict": "Sets all the handlers to null. Useful for testing and not getting any leak...."}, {"ID": 10, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); return fromIterable(sources).concatMapDelayError((Function)Functions.identity()); }\n\n    ### Response: Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\none after the other, one at a time and delays any errors till the all inner Publishers terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\nsources are expected to honor backpressure as well. If the outer violates this, a\n{@code MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violates\nthis, it may throw an {@code IllegalStateException} when an inner {@code Publisher} completes.\nScheduler:\n{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the common element base type\n@param sources the Iterable sequence of Publishers\n@return the new Publisher with the concatenating behavior.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); }\n\n    ### Response:", "ground_truth": "Wraps a CompletableSource into a Maybe.\n\n\nScheduler:\n{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "predict": "Converts a CompletableSource into a Maybe.\n\n@param completableSource the CompletableSource to convert\n@return the new Maybe instance\n\n@CheckReturnValue: indicates that the method does not modify the state of the object and returns the same value each time it is called.\n@NonNull: indicates that the method returns a non-null value.\n@SchedulerSupport(SchedulerSupport.NONE): indicates that the method does not operate by default on a particular Scheduler."}, {"ID": 11, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); return fromIterable(sources).concatMapDelayError((Function)Functions.identity()); }\n\n    ### Response: Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,\none after the other, one at a time and delays any errors till the all inner Publishers terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both the outer and inner {@code Publisher}\nsources are expected to honor backpressure as well. If the outer violates this, a\n{@code MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violates\nthis, it may throw an {@code IllegalStateException} when an inner {@code Publisher} completes.\nScheduler:\n{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the common element base type\n@param sources the Iterable sequence of Publishers\n@return the new Publisher with the concatenating behavior.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) { ObjectHelper.requireNonNull(singleSource, \"singleSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource)); }\n\n    ### Response:", "ground_truth": "Wraps a SingleSource into a Maybe.\n\n\nScheduler:\n{@code fromSingle} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "predict": "Converts a {@link SingleSource} into a {@link Maybe}.\n\n\n@param singleSource the {@link SingleSource} to convert\n@param <T> the type of the item emitted by the {@link SingleSource}\n@return the new {@link Maybe} instance\n\n@see #fromPublisher(Publisher)\n@see #fromFuture(Future)\n@see #fromCallable(Callable)\n@see #fromAction(Action)"}, {"ID": 12, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) { if (times < 0) { throw new IllegalArgumentException(\"times >= 0 required but it was \" + times); } ObjectHelper.requireNonNull(predicate, \"predicate is null\"); return RxJavaPlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate)); }\n\n    ### Response: Retries at most times or until the predicate returns false, whichever happens first.\n\n\nBackpressure:\nThe operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\nIf this expectation is violated, the operator may throw an {@code IllegalStateException}.\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to repeat\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Flowable instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); }\n\n    ### Response:", "ground_truth": "Retries at most times or until the predicate returns false, whichever happens first.\n\n\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "predict": "Retries at most times or until the predicate returns false, whichever happens first.\n\n@param times the number of times to repeat\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance.\n\n    "}, {"ID": 13, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T requireNonNull(T object, String errorMessage) { if (object == null) { throw new NullPointerException(errorMessage); } else { return object; } }\n\n    ### Response: Checks that the specified object reference is not null.\n\n@param object the object reference to check for nullity\n@param errorMessage detail message to be used in the event that a NullPointerException is\nthrown\n@param  the type of the reference\n@return object if not null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T requireNonNull(T object, String message) { if (object == null) { throw new NullPointerException(message); } return object; }\n\n    ### Response:", "ground_truth": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param  the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "predict": " Checks that the specified object reference is not null.\n\n@param object the object reference to check for nullity\n@param message the detail message to be used in the event that a NullPointerException is thrown\n@return object if not null."}, {"ID": 14, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> Mapping<T, T> identity() { return (Mapping<T, T>) IDENTITY_MAPPING; }\n\n    ### Response: Retrieves the identity mapping, which maps each domain value to itself.\n\n@param \ndomain/range class.\n\n@return the identity mapping..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; }\n\n    ### Response:", "ground_truth": "Returns an identity function that simply returns its argument.\n@param  the input and output value type\n@return the identity function", "predict": " Retrieves the identity function, which maps each input value to itself.\n\n@param \ninput class.\n\n@return the identity function."}, {"ID": 15, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> decorateWithBarrier(CyclicBarrier barrier, Callable<T> callable) { return new BarrierCallableDecorator<T>(barrier, callable); }\n\n    ### Response: Create a callable that waits on a barrier before starting execution\n@param barrier\n@param callable\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); }\n\n    ### Response:", "ground_truth": "Returns a Callable that returns the given value.\n@param  the value type\n@param value the value to return\n@return the new Callable instance", "predict": " Create a callable that returns a value immediately\n@param value\n@return."}, {"ID": 16, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> CompletionStage<U> computeOnFxThread(final T element, final Function<T, U> compute) { return CompletableFuture.supplyAsync(() -> compute.apply(element), Platform::runLater); }\n\n    ### Response: Asynchronously executes a computing operation on the JavaFX thread.\n\n@param element The element(s) required for the computation (use {@link Tuple2} for pair-based for example)\n@param compute The computation to perform\n@param      The type of the (aggregated if necessary) inputs\n@param      The output type\n\n@return A {@link CompletionStage} to have monitoring over the state of the asynchronous computation.\n\nPlease make sure to read this class' documentation regarding threading and these methods..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); }\n\n    ### Response:", "ground_truth": "Returns a Function that ignores its parameter and returns the given value.\n@param  the function's input type\n@param  the value and return type of the function\n@param value the value to return\n@return the new Function instance", "predict": " Returns a function that always returns the given value.\n\n@param value The value to return\n@param      The input type\n@param      The output type\n\n@return A function that always returns the given value."}, {"ID": 17, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> CompletionStage<U> computeOnFxThread(final T element, final Function<T, U> compute) { return CompletableFuture.supplyAsync(() -> compute.apply(element), Platform::runLater); }\n\n    ### Response: Asynchronously executes a computing operation on the JavaFX thread.\n\n@param element The element(s) required for the computation (use {@link Tuple2} for pair-based for example)\n@param compute The computation to perform\n@param      The type of the (aggregated if necessary) inputs\n@param      The output type\n\n@return A {@link CompletionStage} to have monitoring over the state of the asynchronous computation.\n\nPlease make sure to read this class' documentation regarding threading and these methods..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); }\n\n    ### Response:", "ground_truth": "Returns a function that cast the incoming values via a Class object.\n@param  the input value type\n@param  the output and target type\n@param target the target class\n@return the new Function instance", "predict": " Creates a function that casts an input object to the specified class.\n\n@param target The class to cast the input to\n@param      The input type\n@param      The output type\n\n@return A function that casts an input object to the specified class."}, {"ID": 18, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> @NonNull CompletableFuture<T> immediateFailedFuture(final @NonNull Throwable ex) { final CompletableFuture<T> future = new CompletableFuture<>(); future.completeExceptionally(ex); return future; }\n\n    ### Response: Returns a completable future that is exceptionally completed with the provided exception.\n\n@param ex the throwable\n@param  the type\n@return an exceptionally completed completable future.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param  the value type\n@return an UnicastSubject instance", "predict": " Creates a new unicast subject with a buffer size of 128 elements.\n\n@return a new unicast subject with a buffer size of 128 elements.\n\n    "}, {"ID": 19, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> Transformer<T, List<T>> bufferWhile(Func1<? super T, Boolean> predicate, int capacityHint) { return new OperatorBufferPredicateBoundary<T>(predicate, RxRingBuffer.SIZE, capacityHint, false); }\n\n    ### Response: Buffers the elements into continuous, non-overlapping Lists where the\nboundary is determined by a predicate receiving each item, before being\nbuffered, and returns true to indicate a new buffer should start.\n\n\nThe operator won't return an empty first or last buffer.\n\n\nBackpressure Support:\nThis operator supports backpressure.\nScheduler:\nThis operator does not operate by default on a particular\n{@link Scheduler}.\n\n\n@param \nthe input value type\n@param predicate\nthe Func1 that receives each item, before being buffered, and\nshould return true to indicate a new buffer has to start.\n@param capacityHint\nthe expected number of items in each buffer\n@return the new Observable instance\n@see #bufferWhile(Func1)\n@since (if this graduates from Experimental/Beta to supported, replace\nthis parenthetical with the release number).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "predict": "Creates a new {@link UnicastSubject} instance with the specified buffer capacity hint.\n\n\nThe buffer capacity hint is used to determine the size of the buffer that will hold the items that are multicasted to the subject.\n\n\nThe subject will be multicasted to multiple subscribers, but only the last one to subscribe will receive the items.\n\n\nThe subject will not replay any items to new subscribers.\n\n\nThe subject will not terminate.\n\n\nThe subject will not support backpressure.\n\n\nThe subject will not operate on a particular {@link Scheduler}.\n\n\n@param <T> the type of item the subject will hold\n@param capacityHint the expected number of items in each buffer\n@return the new UnicastSubject instance\n@since 1.2.0\n\n    "}, {"ID": 20, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> Transformer<T, List<T>> bufferWhile(Func1<? super T, Boolean> predicate, int capacityHint) { return new OperatorBufferPredicateBoundary<T>(predicate, RxRingBuffer.SIZE, capacityHint, false); }\n\n    ### Response: Buffers the elements into continuous, non-overlapping Lists where the\nboundary is determined by a predicate receiving each item, before being\nbuffered, and returns true to indicate a new buffer should start.\n\n\nThe operator won't return an empty first or last buffer.\n\n\nBackpressure Support:\nThis operator supports backpressure.\nScheduler:\nThis operator does not operate by default on a particular\n{@link Scheduler}.\n\n\n@param \nthe input value type\n@param predicate\nthe Func1 that receives each item, before being buffered, and\nshould return true to indicate a new buffer has to start.\n@param capacityHint\nthe expected number of items in each buffer\n@return the new Observable instance\n@see #bufferWhile(Func1)\n@since (if this graduates from Experimental/Beta to supported, replace\nthis parenthetical with the release number).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "predict": "Creates a new {@link UnicastSubject} instance with the specified buffer capacity hint and a callback to be called when the subject is terminated.\n\n\nThe subject will buffer at most one item and will terminate when the first subscriber unsubscribes.\n\n\n@param capacityHint\nthe expected number of items to buffer before applying backpressure\n@param onTerminate\nthe callback to be called when the subject is terminated\n@return the new UnicastSubject instance\n@since 1.2.6"}, {"ID": 21, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> @NonNull CompletableFuture<T> immediateFailedFuture(final @NonNull Throwable ex) { final CompletableFuture<T> future = new CompletableFuture<>(); future.completeExceptionally(ex); return future; }\n\n    ### Response: Returns a completable future that is exceptionally completed with the provided exception.\n\n@param ex the throwable\n@param  the type\n@return an exceptionally completed completable future.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\nHistory: 2.0.8 - experimental\n@param  the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "predict": " Creates a new unicast subject with the specified buffer size and delay error behavior.\n\n@param bufferSize the buffer size\n@param delayError whether to delay error until all subscribers have cancelled\n@return a new unicast subject\n@throws IllegalStateException if the subject has already been created\n\n    "}, {"ID": 22, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Throwable unwrap(Throwable ex) { if (canInspectCause(ex)) { Throwable cause = ex.getCause(); if (cause != null) { return unwrap(cause); } } return ex; }\n\n    ### Response: If the provided exception is a CompletionException or ExecutionException which need be unwrapped.\n\n@param ex The exception to be unwrapped.\n@return The cause or the exception provided..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Throwable blockingGetError() { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); await(); } catch (InterruptedException ex) { dispose(); return ex; } } return error; }\n\n    ### Response:", "ground_truth": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "predict": " If the provided exception is a CompletionException or ExecutionException which need be unwrapped.\n\n@return The cause or the exception provided.."}, {"ID": 23, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T get(long timeout, TimeUnit unit) throws TimeoutException { try { if (!latch.await(timeout, unit)) { throw new TimeoutException(\"Command timed out\"); } } catch (InterruptedException e) { throw new RedisCommandInterruptedException(e); } return output.get(); }\n\n    ### Response: Get the command output and if the command hasn't completed yet,\nwait up to the specified time until it does.\n\n@param timeout   Maximum time to wait for a result.\n@param unit      Unit of time for the timeout.\n\n@return The command output.\n\n@throws TimeoutException if the wait timed out..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; }\n\n    ### Response:", "ground_truth": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "predict": " Get the error that occurred during the execution of the command. If the command hasn't completed yet, wait up to the specified time until it does.\n\n@param timeout   Maximum time to wait for a result.\n@param unit      Unit of time for the timeout.\n\n@return The error that occurred during the execution of the command.\n\n@throws TimeoutException if the wait timed out."}, {"ID": 24, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean waitForRegistered(long timeout, TimeUnit unit) { try { if (this.registeredLatch.await(timeout, unit)) { return true; } } catch (InterruptedException e) { LOG.severe(\"Failed to wait for mesos framework got registered\"); return false; } return false; }\n\n    ### Response: Causes the current thread to wait for MesosFramework got registered,\nunless the thread is interrupted, or the specified waiting time elapses.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the timeout argument\n@return true MesosFramework got registered,\nand false if the waiting time elapsed before the count reached zero.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; }\n\n    ### Response:", "ground_truth": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "predict": "Blocks until the count reaches zero, or the specified waiting time elapses.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the timeout argument\n@return true if the count reached zero, and false if the waiting time elapsed before the count reached zero.\n\n    "}, {"ID": 25, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) available.await(); else { long delay = first.getDelay(NANOSECONDS); if (delay <= 0L) return q.poll(); first = null; // don't retain ref while waiting if (leader != null) available.await(); else { Thread thisThread = Thread.currentThread(); leader = thisThread; try { available.awaitNanos(delay); } finally { if (leader == thisThread) leader = null; } } } } } finally { if (leader == null && q.peek() != null) available.signal(); lock.unlock(); } }\n\n    ### Response: Retrieves and removes the head of this queue, waiting if necessary\nuntil an element with an expired delay is available on this queue.\n\n@return the head of this queue\n@throws InterruptedException {@inheritDoc}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\")); return; } } missed = qd.leave(-missed); if (missed == 0) { break; } } }\n\n    ### Response:", "ground_truth": "Drain the queue but give up with an error if there aren't enough requests.\n@param  the queue value type\n@param  the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "predict": "Drains the queue by consuming the elements in a loop and requesting more elements from the upstream if the downstream is not ready to consume them.\n\n@param <T> the value type\n@param <U> the output value type\n@param q the queue to drain\n@param a the downstream subscriber\n@param delayError if true, errors are delayed until all elements have been processed\n@param dispose the dispose handler to call if the downstream is disposed\n@param qd the queue drain instance to use for consuming the queue and requesting more elements from the upstream\n\n@throws Exception if the downstream fails or the queue is terminated and delayError is true"}, {"ID": 26, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static long getMaxTTL(Map<byte[], Long> ttlByFamily) { long maxTTL = 0; for (Long familyTTL : ttlByFamily.values()) { maxTTL = Math.max(familyTTL <= 0 ? Long.MAX_VALUE : familyTTL, maxTTL); } return maxTTL == 0 ? Long.MAX_VALUE : maxTTL; }\n\n    ### Response: Returns the max TTL for the given TTL values. Returns Long.MAX_VALUE if any of the column families has no TTL set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void request(Subscription s, int prefetch) { s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch); }\n\n    ### Response:", "ground_truth": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "predict": " Requests the given number of elements in the stream. If the prefetch parameter is negative, requests Long.MAX_VALUE elements."}, {"ID": 27, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> void setMax(E obj, AtomicLongFieldUpdater<E> updater, long value) { for (; ; ) { long current = updater.get(obj); if (current >= value) { return; } if (updater.compareAndSet(obj, current, value)) { return; } } }\n\n    ### Response: Atomically sets the max value.\n\nIf the current value is larger than the provided value, the call is ignored.\nSo it will not happen that a smaller value will overwrite a larger value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } }\n\n    ### Response:", "ground_truth": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n\nDon't modify the queue after calling this method!\n\n\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param  the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "predict": " Posts an onComplete signal to the actual Subscriber if the queue is empty and the state is marked as complete.\n\nIf the queue is not empty, it drains the queue and posts the signals to the actual Subscriber.\n\nIf the state is marked as complete, it returns immediately without doing anything.\n\nIf the state is not marked as complete, it sets the state to complete and checks if the requested amount was non-zero. If it was, it drains the queue.\n\nIf the requested amount was zero, it returns immediately without doing anything."}, {"ID": 28, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static long getLong(ByteBuffer buffer) { long v = buffer.get(); long value = v & 0x7F; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 7; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 14; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 21; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 28; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 35; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 42; if ((v & 0x80) != 0) { v = buffer.get(); value |= (v & 0x7F) << 49; if ((v & 0x80) != 0) { v = buffer.get(); value |= v << 56; } } } } } } } } value = (value >>> 1) ^ (-(value & 1)); return value; }\n\n    ### Response: Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n@param buffer the buffer to read from\n@return the value read from the buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } }\n\n    ### Response:", "ground_truth": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "predict": " Completes the current stream with the given value.\n@param n the value to complete the stream with.\n\n    "}, {"ID": 29, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @GwtIncompatible(\"incompatible method\") @SuppressWarnings(\"unchecked\") @Nullable public static <T> T findValueOfType(final Collection<?> collection, @Nullable final Class<T> type) { if (CollectionUtils.isEmpty(collection)) { return null; } T value = null; for (final Object element : collection) { if (type == null || type.isInstance(element)) { if (value != null) { // More than one value found... no clear single value. return null; } value = (T) element; } } return value; }\n\n    ### Response: Find a single value of the given type in the given Collection.\n\n@param collection the Collection to search\n@param type the type to look for\n@return a value of the given type found if there is a clear match, or {@code null} if none or\nmore than one such value found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; }\n\n    ### Response:", "ground_truth": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "predict": " Get the value of the object.\n\n@return the value of the object, or {@code null} if the value is not set or is an error."}, {"ID": 30, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @GwtIncompatible(\"incompatible method\") @SuppressWarnings(\"unchecked\") @Nullable public static <T> T findValueOfType(final Collection<?> collection, @Nullable final Class<T> type) { if (CollectionUtils.isEmpty(collection)) { return null; } T value = null; for (final Object element : collection) { if (type == null || type.isInstance(element)) { if (value != null) { // More than one value found... no clear single value. return null; } value = (T) element; } } return value; }\n\n    ### Response: Find a single value of the given type in the given Collection.\n\n@param collection the Collection to search\n@param type the type to look for\n@return a value of the given type found if there is a clear match, or {@code null} if none or\nmore than one such value found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; }\n\n    ### Response:", "ground_truth": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "predict": " Get the error object from the value field.\n\n@return the error object if there is one, or {@code null} otherwise."}, {"ID": 31, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { AutoDisposeUtil.checkNotNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != AutoDisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response: Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "predict": " Atomically validates the target upstream Disposable from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the upstream already contains a non-cancelled Disposable.\n\n@param upstream the target Disposable to validate\n@param next the Disposable to validate against\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the upstream was non null."}, {"ID": 32, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { AutoDisposeUtil.checkNotNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != AutoDisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response: Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null."}, {"ID": 33, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { AutoDisposeUtil.checkNotNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != AutoSubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response: Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "predict": " Atomically validates the target upstream Subscription from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the upstream already contains a non-cancelled Subscription.\n\n@param upstream the target Subscription to validate\n@param next the Subscription to validate against\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the upstream was non null."}, {"ID": 34, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { AutoDisposeUtil.checkNotNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != AutoSubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response: Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null."}, {"ID": 35, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static long addCap(long a, long b) { long res = a + b; if (res < 0L) { return Long.MAX_VALUE; } return res; }\n\n    ### Response: Cap an addition to Long.MAX_VALUE\n\n@param a left operand\n@param b right operand\n\n@return Addition result or Long.MAX_VALUE if overflow.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; }\n\n    ### Response:", "ground_truth": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "predict": " Cap an addition to Long.MAX_VALUE\n\n@param a left operand\n@param b right operand\n\n@return Addition result or Long.MAX_VALUE if overflow."}, {"ID": 36, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static long addCap(long a, long b) { long res = a + b; if (res < 0L) { return Long.MAX_VALUE; } return res; }\n\n    ### Response: Cap an addition to Long.MAX_VALUE\n\n@param a left operand\n@param b right operand\n\n@return Addition result or Long.MAX_VALUE if overflow.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; }\n\n    ### Response:", "ground_truth": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "predict": " Cap a multiplication to Long.MAX_VALUE\n\n@param a left operand\n@param b right operand\n\n@return Multiplication result or Long.MAX_VALUE if overflow."}, {"ID": 37, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Reference<? extends T> remove(long timeout) throws IllegalArgumentException, InterruptedException { if (timeout < 0) { throw new IllegalArgumentException(\"Negative timeout value\"); } synchronized (lock) { Reference<? extends T> r = reallyPollLocked(); if (r != null) return r; long start = (timeout == 0) ? 0 : System.nanoTime(); for (;;) { lock.wait(timeout); r = reallyPollLocked(); if (r != null) return r; if (timeout != 0) { long end = System.nanoTime(); timeout -= (end - start) / 1000_000; if (timeout <= 0) return null; start = end; } } } }\n\n    ### Response: Removes the next reference object in this queue, blocking until either\none becomes available or the given timeout period expires.\n\n This method does not offer real-time guarantees: It schedules the\ntimeout as if by invoking the {@link Object#wait(long)} method.\n\n@param  timeout  If positive, block for up to timeout\nmilliseconds while waiting for a reference to be\nadded to this queue.  If zero, block indefinitely.\n\n@return  A reference object, if one was available within the specified\ntimeout period, otherwise null\n\n@throws  IllegalArgumentException\nIf the value of the timeout argument is negative\n\n@throws  InterruptedException\nIf the timeout wait is interrupted.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long add(AtomicLong requested, long n) { for (;;) { long r = requested.get(); if (r == Long.MAX_VALUE) { return Long.MAX_VALUE; } long u = addCap(r, n); if (requested.compareAndSet(r, u)) { return r; } } }\n\n    ### Response:", "ground_truth": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "predict": "Atomically adds the given value to the current value of the given\nAtomicLong, returning the updated value.\n\nThis method is guaranteed to be thread-safe and is designed to be used in\nhighly concurrent applications. It uses a loop to repeatedly update the\ncurrent value of the requested counter until the update is successful,\nensuring that the value is not increased beyond the maximum value of a\nlong.\n\n@param  requested  The current value of the counter\n@param  n          The value to add to the counter\n\n@return  The updated value of the counter\n\n    "}, {"ID": 38, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static ObjectName getObjectName(String name) { ObjectName mBeanName = null; try { mBeanName = new ObjectName(name); } catch (MalformedObjectNameException | NullPointerException e) { throw new JmxConfigException(e); } return mBeanName; }\n\n    ### Response: Create an object name from the name passed in parameter\n\n@param name\nthe name\n@return the objectName.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static NullPointerException toNpe(Throwable ex) { NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\"); npe.initCause(ex); return npe; }\n\n    ### Response:", "ground_truth": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "predict": " Create a new NullPointerException with a custom message and set the cause to the given exception.\n\n@param ex\nthe exception\n@return the new NullPointerException with the given exception as cause."}, {"ID": 39, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addLast( AbstractJournalOperation op ) { if (tail == null) { head = tail = op; } else { tail.setNext(op); tail = op; } op.setNext(null); size++; }\n\n    ### Response: Append an operation at the end of the queue\n@param op a journal operation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } }\n\n    ### Response:", "ground_truth": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "predict": " Add an element to the end of the queue\n@param o the element to be added to the queue."}, {"ID": 40, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void shutdown() { if (MetricsManager.executorService != null) { MetricsManager.executorService.shutdown(); MetricsManager.executorService = null; } if (MetricsManager.instance != null) { MetricsManager.instance = null; MetricsManager.poolManager.shutdown(); MetricsManager.poolManager = null; MetricsManager.httpClient = null; MetricsManager.rootMetricsLogger = null; } }\n\n    ### Response: Shutdown MetricsManager, clean up resources\nThis method is not thread-safe, only use it to clean up resources when your application is shutting down..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void shutdown() { ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null); if (exec != null) { exec.shutdownNow(); } POOLS.clear(); }\n\n    ### Response:", "ground_truth": "Stops the purge thread.", "predict": " Shutdown purge thread and clear pools\nThis method is not thread-safe, only use it to clean up resources when your application is shutting down."}, {"ID": 41, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ScheduledExecutorService newSingleScheduledThreadPool() { ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); OS.addShutdownHook(scheduledExecutorService::shutdown); return scheduledExecutorService; }\n\n    ### Response: New single scheduled thread pool scheduled executor service.\n\n@return the scheduled executor service.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; }\n\n    ### Response:", "ground_truth": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "predict": " Creates a new scheduled executor service with the given thread factory.\n\n@param factory the thread factory to use for creating threads in the executor service\n@return the scheduled executor service\n\n    "}, {"ID": 42, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean groupInfoMatches(Map<String, List<GroupInfo>> a, Map<String, List<GroupInfo>> b) { if (a == null && b == null) { return true; } boolean isMatch = false; if (a != null && b != null) { if (a.isEmpty() && b.isEmpty()) { isMatch = true; } else if (a.size() == b.size()) { for (Entry<String, List<GroupInfo>> entry : a.entrySet()) { List<GroupInfo> otherList = b.get(entry.getKey()); isMatch = (otherList != null); if (!isMatch) { break; } List<GroupInfo> thisList = entry.getValue(); isMatch = otherList.containsAll(thisList) && thisList.containsAll(otherList); if (!isMatch) { break; } } } } return isMatch; }\n\n    ### Response: Compares the keys and values of two group-info maps\n\n@param a the first map to compare\n@param b the other map to compare\n@return {@code true} if the first map contains all of the other map's keys and values; {@code false} otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); }\n\n    ### Response:", "ground_truth": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "predict": " Sets the subscription to the given value and requests the specified number of elements from the subscription if the number of requests is greater than zero.\n\n@param s the subscription to set\n@throws NullPointerException if s is null\n\n    "}, {"ID": 43, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<T> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.accept(actual); } }\n\n    ### Response: Loops until all notifications in the queue has been processed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } }\n\n    ### Response:", "ground_truth": "Loops until all notifications in the queue has been processed.", "predict": " Loops until all notifications in the queue has been processed and calls the accept method of the AppendOnlyLinkedArrayList class with the actual object as a parameter."}, {"ID": 44, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getMessage(Object error) { if (error instanceof Throwable) { String message = ((Throwable) error).getMessage(); if (message == null) { if (fullStack) { message = error.getClass().getName(); } } return message; } else if (error instanceof String) { return (String) error; } else if (error instanceof Integer) { return HttpResponseStatus.valueOf((Integer) error).reasonPhrase(); } else if (error instanceof JsonObject) { return ((JsonObject) error).getString(\"message\"); } else if (error instanceof Map) { return (String) ((Map) error).get(\"message\"); } else { return error.toString(); } }\n\n    ### Response: Extracts a single message from a error Object. This will handle Throwables, Strings and Numbers. In case of\nnumbers these are handled as Http error codes.\n\n@param error Error object\n@return String representation of the error object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RuntimeException wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (RuntimeException)error; } return new RuntimeException(error); }\n\n    ### Response:", "ground_truth": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "predict": " Wraps a Throwable into a RuntimeException. If the Throwable is already a RuntimeException, it is returned as is. If the Throwable is an Error, it is thrown as is. Otherwise, a new RuntimeException is created with the original Throwable as the cause.\n\n@param error Throwable to wrap\n@return RuntimeException with the original Throwable as the cause."}, {"ID": 45, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Throwable> getCausalChain(final Throwable throwable) { if (throwable == null) { throw new NullPointerException(\"Throwable is null\"); } List<Throwable> causes = new ArrayList<Throwable>(); causes.add(throwable); Throwable cause = throwable.getCause(); while ((cause != null) && (!causes.contains(cause))) { causes.add(cause); cause = cause.getCause(); } return causes; }\n\n    ### Response: Returns the Throwable's cause chain as a list. The first entry is the Throwable followed by the cause chain.\n@param throwable The Throwable\n@return The Throwable and its cause chain.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; }\n\n    ### Response:", "ground_truth": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "predict": " Flattens a Throwable and its cause chain into a list of Throwables.\n@param t The Throwable to flatten\n@return A list of Throwables representing the flattened Throwable and its cause chain."}, {"ID": 46, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Beta public static <E extends Throwable> void check(boolean condition, E throwable) throws E { checkArgument(throwable != null, \"Expected non-null reference\"); if (!condition) { throw throwable; } }\n\n    ### Response: Performs check of the condition.\n\n@param condition condition to check\n@param        the exception type\n@throws IllegalArgumentException if the {@code throwable} is null\n@throws IllegalArgumentException if the {@code throwableType} cannot be instantiated\n@throws E                        if the {@code reference} doesn't match provided predicate.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return (Exception)e; } throw (E)e; }\n\n    ### Response:", "ground_truth": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param  the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "predict": " Throws the exception if it is an instance of the specified type.\n\n@param e the exception to check\n@return the exception if it is an instance of the specified type\n@throws E if the exception is not an instance of the specified type"}, {"ID": 47, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Handler(priority = -10000) public void onStop(Stop event) throws InterruptedException { synchronized (this) { if (runner == null) { return; } runner.interrupt(); synchronized (this) { if (registered) { unregisterAsGenerator(); registered = false; } } runner = null; } }\n\n    ### Response: Stops the thread that reads data from the input stream.\nNote that the input stream is not closed.\n\n@param event the event\n@throws InterruptedException the interrupted exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); }\n\n    ### Response:", "ground_truth": "Atomically clears the container, then disposes all the previously contained Disposables.", "predict": " Clears the resources associated with this object.\n\n@throws Exception if an error occurs during disposal."}, {"ID": 48, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getNumFaultyTrackers() { int count = 0; synchronized (this) { for (String trackerName : usageReports.keySet()) { if (isFaulty(trackerName)) { count++; } } } return count; }\n\n    ### Response: Get the number of faulty trackers.\n@return the number of faulty trackers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int size() { if (disposed) { return 0; } synchronized (this) { if (disposed) { return 0; } OpenHashSet<Disposable> set = resources; return set != null ? set.size() : 0; } }\n\n    ### Response:", "ground_truth": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "predict": " Get the number of resources in the set.\n@return the number of resources in the set."}, {"ID": 49, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E extends Comparable<E>> boolean sort(List<E> input) { if (input == null) { return false; } try { Collections.sort(input); return true; } catch (UnsupportedOperationException ex) { return false; } }\n\n    ### Response: Sort the elements within a list according to their natural order. The input list is modified in place, so this\noperation will succeed only if the list is modifiable.\n\n@param  the type of the elements in the list\n@param input the list to sort\n@return {@code true} if the list was successfully sorted, {@code false} otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (u == null) { EmptyDisposable.complete(observer); return true; } ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u); observer.onSubscribe(sd); sd.run(); } else { r.subscribe(observer); } return true; } return false; }\n\n    ### Response:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param  the input value type\n@param  the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "predict": "Attempts to subscribe to an ObservableSource using a scalar value obtained by calling the source's {@code call()} method. If the source is a Callable, the value obtained by calling it is used to create an ObservableSource by applying the provided mapper function. If the resulting ObservableSource is also a Callable, the value obtained by calling it is emitted to the downstream observer. Otherwise, the resulting ObservableSource is subscribed to directly.\n\n@param <T> the type of the source value\n@param <R> the type of the result value\n@param source the source ObservableSource, which is either a Callable or an ObservableSource\n@param observer the downstream observer to subscribe to the resulting ObservableSource\n@param mapper the function to apply to the source value to obtain an ObservableSource\n@return {@code true} if the subscription was successful, {@code false} otherwise."}, {"ID": 50, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, K, U> Collector<T, ?, LinkedHashMap<K, U>> toLinkedMap( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction) { return Collectors.toMap(keyMapper, valueMapper, mergeFunction, LinkedHashMap::new); }\n\n    ### Response: Collects a stream to a LinkedHashMap.\n@param keyMapper   function to deal with keys.\n@param valueMapper function to deal with values.\n@param mergeFunction function to apply one values if keyMapper produces same key multiple times.\n@param          type of element in input stream.\n@param          type of key for created map.\n@param          type of value for created map.\n@return map with a key/value for each item in the stream..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); }\n\n    ### Response:", "ground_truth": "Maps a scalar value into an Observable and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "predict": "Maps a scalar value to an ObservableSource of a different type.\n@param value scalar value to map.\n@param mapper function to map the scalar value to an ObservableSource.\n@param          type of scalar value.\n@param          type of ObservableSource to map to.\n@return Observable that emits the result of the mapping.\n\n    "}, {"ID": 51, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean sameList(final Vector v, final Object[] a) { if (v == null || a == null || v.size() != a.length) { return false; } for (int i = 0; i < a.length; i++) { final Object o = a[i]; if (!o.equals(v.elementAt(i))) { return false; } } return true; }\n\n    ### Response: Compares the contents of an array and a Vector for equality..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; }\n\n    ### Response:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param  the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "predict": " Accepts a subscriber and returns true if any of the elements in the queue match the subscriber's interests."}, {"ID": 52, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean sameList(final Vector v, final Object[] a) { if (v == null || a == null || v.size() != a.length) { return false; } for (int i = 0; i < a.length; i++) { final Object o = a[i]; if (!o.equals(v.elementAt(i))) { return false; } } return true; }\n\n    ### Response: Compares the contents of an array and a Vector for equality..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; }\n\n    ### Response:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param  the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "predict": " Accepts an observer for each element in the linked list.\n\n    "}, {"ID": 53, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { application = new CitrusRemoteApplication(configuration); port(configuration.getPort()); application.init(); if (!configuration.isSkipTests()) { new RunController(configuration).run(); } if (configuration.getTimeToLive() == 0) { stop(); } }\n\n    ### Response: Start server instance and listen for incoming requests..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } }\n\n    ### Response:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " Initializes the queue for the first time.\n\n    "}, {"ID": 54, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void addUnusedView(@NonNull final View view, final int viewType) { if (useCache) { if (unusedViews == null) { unusedViews = new SparseArray<>(adapter.getViewTypeCount()); } Queue<View> queue = unusedViews.get(viewType); if (queue == null) { queue = new LinkedList<>(); unusedViews.put(viewType, queue); } queue.add(view); } }\n\n    ### Response: Adds an unused view to the cache.\n\n@param view\nThe unused view, which should be added to the cache, as an instance of the class\n{@link View}. The view may not be null\n@param viewType\nThe view type, the unused view corresponds to, as an {@link Integer} value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } }\n\n    ### Response:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": "Starts an unbounded flowable sequence.\n\n@param bufferSize\nThe size of the buffer used to hold the elements of the sequence."}, {"ID": 55, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isInformative() { if (this == SAFE_CONFIG) { // these are loaded automatically, do not need to store them return false; } if (outputTaint == null) { return false; } if (!outputTaint.isUnknown()) { return true; } if (outputTaint.hasParameters()) { return true; } if (outputTaint.getRealInstanceClass() != null) { return true; } if (outputTaint.hasTags() || outputTaint.isRemovingTags()) { return true; } return false; }\n\n    ### Response: Checks if the summary needs to be saved or has no information value\n\n@return true if summary should be saved, false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; }\n\n    ### Response:", "ground_truth": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "predict": " Adds an item to the queue if the queue is not full and the item is not null.\n\n@return true if the item was added to the queue, false otherwise.\n\n    "}, {"ID": 56, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Weight(Weight.Unit.NORMAL) public static Disposable defer(@Nonnull final Disposable disposable) { assertNotNull(disposable); defer(new Deferred() { private static final long serialVersionUID = 7940162959962038010L; private final Disposable value = disposable; @Override public void executeDeferred() throws Exception { this.value.dispose(); } }); return disposable; }\n\n    ### Response: Defer execution of some disposable object.\n\n@param disposable some disposable object to be processed.\n@return the same object from arguments\n@throws AssertionError if the disposable object is null\n@see Disposable.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable public Disposable get() { Disposable d = resource.get(); if (d == DisposableHelper.DISPOSED) { return Disposables.disposed(); } return d; }\n\n    ### Response:", "ground_truth": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "predict": " Get the disposable object from the resource.\n\n@return the disposable object from the resource or null if it has been disposed.\n@throws Exception if an error occurs while getting the disposable object.\n@see Disposable."}, {"ID": 57, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String readString(final JBBPByteOrder byteOrder) throws IOException { final int prefix = this.readByte(); final int len; if (prefix == 0) { len = 0; } else if (prefix == 0xFF) { len = -1; } else if (prefix < 0x80) { len = prefix; } else if ((prefix & 0xF0) == 0x80) { switch (prefix & 0x0F) { case 1: { len = this.readByte(); } break; case 2: { len = this.readUnsignedShort(byteOrder); } break; case 3: { int buffer; if (byteOrder == JBBPByteOrder.BIG_ENDIAN) { buffer = (this.readByte() << 16) | (this.readByte() << 8) | this.readByte(); } else { buffer = this.readByte() | (this.readByte() << 8) | (this.readByte() << 16); } len = buffer; } break; case 4: { len = this.readInt(byteOrder); } break; default: { throw makeIOExceptionForWrongPrefix(prefix); } } } else { throw makeIOExceptionForWrongPrefix(prefix); } final String result; if (len < 0) { result = null; } else if (len == 0) { result = \"\"; } else { result = JBBPUtils.utf8ToStr(this.readByteArray(len)); } return result; }\n\n    ### Response: Read string in UTF8 format.\n\n@param byteOrder byte order, must not be null\n@return read string, can be null\n@throws IOException it will be thrown for transport error or wrong format\n@see JBBPBitOutputStream#writeString(String, JBBPByteOrder)\n@since 1.4.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } }\n\n    ### Response:", "ground_truth": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "predict": " Completes the sequence with the given value.\n\n@param value the value to complete the sequence with, not null\n@throws NullPointerException if the value is null\n@since 1.4.0."}, {"ID": 58, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void open( String filename, int mode ) throws jsqlite.Exception { this.filename = filename; if ((mode & 0200) != 0) { mode = jsqlite.Constants.SQLITE_OPEN_READWRITE | jsqlite.Constants.SQLITE_OPEN_CREATE; } else if ((mode & 0400) != 0) { mode = jsqlite.Constants.SQLITE_OPEN_READONLY; } synchronized (this) { try { _open4(filename, mode, null, false); } catch (Exception | OutOfMemoryError se) { throw se; } catch (Throwable t) { _open(filename, mode); } } }\n\n    ### Response: Open an SQLite database file.\n\n@param filename the name of the database file\n@param mode open mode (e.g. SQLITE_OPEN_READONLY)\n@throws jsqlite.Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); }\n\n    ### Response:", "ground_truth": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "predict": " Reports an error to the downstream subscriber.\n\n@param t the exception to report\n@throws NullPointerException if the downstream is null"}, {"ID": 59, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int writeMethodParametersAttr(MethodSymbol m) { MethodType ty = m.externalType(types).asMethodType(); final int allparams = ty.argtypes.size(); if (m.params != null && allparams != 0) { final int attrIndex = writeAttr(names.MethodParameters); databuf.appendByte(allparams); // Write extra parameters first for (VarSymbol s : m.extraParams) { final int flags = ((int) s.flags() & (FINAL | SYNTHETIC | MANDATED)) | ((int) m.flags() & SYNTHETIC); databuf.appendChar(pool.put(s.name)); databuf.appendChar(flags); } // Now write the real parameters for (VarSymbol s : m.params) { final int flags = ((int) s.flags() & (FINAL | SYNTHETIC | MANDATED)) | ((int) m.flags() & SYNTHETIC); databuf.appendChar(pool.put(s.name)); databuf.appendChar(flags); } // Now write the captured locals for (VarSymbol s : m.capturedLocals) { final int flags = ((int) s.flags() & (FINAL | SYNTHETIC | MANDATED)) | ((int) m.flags() & SYNTHETIC); databuf.appendChar(pool.put(s.name)); databuf.appendChar(flags); } endAttr(attrIndex); return 1; } else return 0; }\n\n    ### Response: Write method parameter names attribute..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); }\n\n    ### Response:", "ground_truth": "Complete the target without any value.", "predict": " Complete the stream by fusing it and calling the downstream onComplete method."}, {"ID": 60, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <R> StreamEx<R> mapPartial(Function<? super T, ? extends Optional<? extends R>> mapper) { return new StreamEx<>(stream().map(value -> mapper.apply(value).orElse(null)).filter(Objects::nonNull), context); }\n\n    ### Response: Performs a mapping of the stream content to a partial function\nremoving the elements to which the function is not applicable.\n\n\nIf the mapping function returns {@link Optional#empty()}, the original\nvalue will be removed from the resulting stream. The mapping function\nmay not return null.\n\n\nThis is an intermediate\noperation.\n\n\nThe {@code mapPartial()} operation has the effect of applying a\none-to-zero-or-one transformation to the elements of the stream, and then\nflattening the resulting elements into a new stream.\n\n@param  The element type of the new stream\n@param mapper a non-interfering ,\nstateless\npartial function to apply to each element which returns a present optional\nif it's applicable, or an empty optional otherwise\n@return the new stream\n@since 0.6.8.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) { return concatMapDelayError(mapper, 2, true); }\n\n    ### Response:", "ground_truth": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that may throw an {@code IllegalStateException} when that\n{@code Publisher} completes.\nScheduler:\n{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "predict": "Concats the elements of the current stream with the elements of the resulting stream produced by applying the given function to each element of the current stream.\n\nThe resulting stream is ordered and the error from the current stream is propagated to the resulting stream.\n\n@param <R> the element type of the resulting stream\n@param mapper a non-interfering ,\nstateless\nfunction to apply to each element which returns a Publisher\n@return the new Flowable instance\n@since 2.0\n\n    "}, {"ID": 61, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final <U, R> Maybe<R> zipWith(MaybeSource<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) { ObjectHelper.requireNonNull(other, \"other is null\"); return zip(this, other, zipper); }\n\n    ### Response: Waits until this and the other MaybeSource signal a success value then applies the given BiFunction\nto those values and emits the BiFunction's resulting value to downstream.\n\n\n\nIf either this or the other MaybeSource is empty or signals an error, the resulting Maybe will\nterminate immediately and dispose the other source.\n\n\nScheduler:\n{@code zipWith} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of items emitted by the {@code other} MaybeSource\n@param \nthe type of items emitted by the resulting Maybe\n@param other\nthe other MaybeSource\n@param zipper\na function that combines the pairs of items from the two MaybeSources to generate the items to\nbe emitted by the resulting Maybe\n@return the new Maybe instance\n@see ReactiveX operators documentation: Zip.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) { return concatMapIterable(mapper, 2); }\n\n    ### Response:", "ground_truth": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.\nScheduler:\n{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see ReactiveX operators documentation: FlatMap", "predict": "Converts each item emitted by the source Publisher into an Iterable of items, concatenates them into a single Flowable, and emits the resulting items.\n\n\nThe number of concurrent concatenated iterables is determined by the second parameter to the method.\n\n\nIf the source Publisher signals an error, the resulting Flowable terminates immediately and disposes the source Publisher.\n\n\nScheduler:\n{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of items emitted by the source Publisher\n@param \nthe type of items emitted by the resulting Flowable\n@param mapper\na function that converts each item emitted by the source Publisher into an Iterable of items\n@param maxConcurrency\nthe maximum number of concurrent concatenated iterables\n@return the new Flowable instance\n@see ReactiveX operators documentation: ConcatMapIterable."}, {"ID": 62, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) { if (times < 0) { throw new IllegalArgumentException(\"times >= 0 required but it was \" + times); } ObjectHelper.requireNonNull(predicate, \"predicate is null\"); return RxJavaPlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate)); }\n\n    ### Response: Retries at most times or until the predicate returns false, whichever happens first.\n\n\nBackpressure:\nThe operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\nIf this expectation is violated, the operator may throw an {@code IllegalStateException}.\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to repeat\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Flowable instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction\"); return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); }\n\n    ### Response:", "ground_truth": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nBackpressure:\nThe operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "predict": "Sorts the elements of the source {@code Publisher} in natural order or according to a specified comparator.\n\nBackpressure:\nThe operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\nIf this expectation is violated, the operator may throw an {@code IllegalStateException}.\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n@param sortFunction the comparator to determine the order of the elements or {@code null} to use natural order\n@return the new Flowable instance."}, {"ID": 63, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T waitForRequest(long maxWait) { long start = System.currentTimeMillis(); try { while (requestsReceived.get() < 1 && (System.currentTimeMillis() - start) < maxWait) { try { Thread.sleep(50); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } } finally { stopServer(); } return getResponse(); }\n\n    ### Response: Waits until at least one request is received, and then stops the server.\n@param maxWait ms to wait at most.\n@return response with last request filled, if at least one was received..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PerfAsyncConsumer await(int count) { if (count <= 1000) { while (getCount() != 0) { } } else { try { await(); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } return this; }\n\n    ### Response:", "ground_truth": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "predict": "Waits for the specified number of messages to be received. If the count is less than or equal to 1000, it waits for the count to be zero. Otherwise, it waits indefinitely until the count is zero.\n@param count number of messages to wait for.\n@return this PerfAsyncConsumer instance.\n\n    "}, {"ID": 64, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setSSLParameters(SSLParameters params) { String[] s; s = params.getCipherSuites(); if (s != null) { setEnabledCipherSuites(s); } s = params.getProtocols(); if (s != null) { setEnabledProtocols(s); } if (params.getNeedClientAuth()) { setNeedClientAuth(true); } else if (params.getWantClientAuth()) { setWantClientAuth(true); } else { setWantClientAuth(false); } }\n\n    ### Response: Applies SSLParameters to newly accepted connections.\n\nThis means:\n\nIf {@code params.getCipherSuites()} is non-null,\n{@code setEnabledCipherSuites()} is called with that value.\nIf {@code params.getProtocols()} is non-null,\n{@code setEnabledProtocols()} is called with that value.\nIf {@code params.getNeedClientAuth()} or\n{@code params.getWantClientAuth()} return {@code true},\n{@code setNeedClientAuth(true)} and\n{@code setWantClientAuth(true)} are called, respectively;\notherwise {@code setWantClientAuth(false)} is called.\nIf {@code params.getServerNames()} is non-null, the socket will\nconfigure its server names with that value.\nIf {@code params.getSNIMatchers()} is non-null, the socket will\nconfigure its SNI matchers with that value.\n\n\n@param params the parameters\n@throws IllegalArgumentException if the setEnabledCipherSuites() or\nthe setEnabledProtocols() call fails\n\n@see #getSSLParameters()\n\n@since 1.7.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void request(long n) { Subscription s = this.upstream; if (s != null) { s.request(n); } }\n\n    ### Response:", "ground_truth": "Requests from the upstream Subscription.\n@param n the request amount, positive", "predict": "Requests the specified number of elements from the upstream publisher.\n\nThis means:\n\nIf the upstream publisher is non-null, the specified number of elements\nis requested from it using the {@code request()} method of the\n{@code Subscription} interface.\n\n@param n the number of elements to request\n@throws IllegalArgumentException if {@code n} is negative\n\n@see #cancel()"}, {"ID": 65, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func NewLexerBytes(b []byte) *Lexer { z := &Lexer{ buf: b, } n := len(b) if n == 0 { z.buf = nullBuffer } else if b[n-1] != 0 { // Append NULL to buffer, but try to avoid reallocation if cap(b) > n { // Overwrite next byte but restore when done b = b[:n+1] c := b[n] b[n] = 0 z.buf = b z.restore = func() { b[n] = c } } else { z.buf = append(b, 0) } } return z }\n\n    ### Response: // NewLexerBytes returns a new Lexer for a given byte slice, and appends NULL at the end.\n// To avoid reallocation, make sure the capacity has room for one more byte..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean add(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n + 1]; System.arraycopy(a, 0, b, 0, n); b[n] = ps; if (subscribers.compareAndSet(a, b)) { return true; } } }\n\n    ### Response:", "ground_truth": "Tries to add the given subscriber to the subscribers array atomically\nor returns false if the subject has terminated.\n@param ps the subscriber to add\n@return true if successful, false if the subject has terminated", "predict": " // add adds a PublishDisposable to the subscribers array.\n// Returns true if successful, false if terminated."}, {"ID": 66, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"SameParameterValue\") private static void insertionSort(int[] order, double[] values, int start, int n, int limit) { for (int i = start + 1; i < n; i++) { int t = order[i]; double v = values[order[i]]; int m = Math.max(i - limit, start); for (int j = i; j >= m; j--) { if (j == 0 || values[order[j - 1]] <= v) { if (j < i) { System.arraycopy(order, j, order, j + 1, i - j); order[j] = t; } break; } } } }\n\n    ### Response: Limited range insertion sort.  We assume that no element has to move more than limit steps\nbecause quick sort has done its thing.\n\n@param order  The permutation index\n@param values The values we are sorting\n@param start  Where to start the sort\n@param n      How many elements to sort\n@param limit  The largest amount of disorder.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") void remove(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED || a == EMPTY) { return; } int n = a.length; int j = -1; for (int i = 0; i < n; i++) { if (a[i] == ps) { j = i; break; } } if (j < 0) { return; } PublishDisposable<T>[] b; if (n == 1) { b = EMPTY; } else { b = new PublishDisposable[n - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, n - j - 1); } if (subscribers.compareAndSet(a, b)) { return; } } }\n\n    ### Response:", "ground_truth": "Atomically removes the given subscriber if it is subscribed to the subject.\n@param ps the subject to remove", "predict": " Removes a PublishDisposable from the list of subscribers.\n\n@param ps The PublishDisposable to remove."}, {"ID": 67, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) { if (times < 0) { throw new IllegalArgumentException(\"times >= 0 required but it was \" + times); } ObjectHelper.requireNonNull(predicate, \"predicate is null\"); return RxJavaPlugins.onAssembly(new FlowableRetryPredicate<T>(this, times, predicate)); }\n\n    ### Response: Retries at most times or until the predicate returns false, whichever happens first.\n\n\nBackpressure:\nThe operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.\nIf this expectation is violated, the operator may throw an {@code IllegalStateException}.\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to repeat\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Flowable instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); }\n\n    ### Response:", "ground_truth": "Child Subscribers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param cf the ConnectableFlowable to wrap\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "Observes the elements of the source {@code ConnectableFlowable} on a specified {@link Scheduler} and returns a {@code ConnectableFlowable} that replays the elements to any subsequent {@link Subscriber}.\n\n@param scheduler the {@link Scheduler} to observe the elements on\n@return the new {@code ConnectableFlowable} instance\n\n    "}, {"ID": 68, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) { Assert.notNull(method, \"method must not be null\"); Type returnType = method.getReturnType(); Type genericReturnType = method.getGenericReturnType(); if (returnType.equals(genericIfc)) { if (genericReturnType instanceof ParameterizedType) { ParameterizedType targetType = (ParameterizedType) genericReturnType; Type[] actualTypeArguments = targetType.getActualTypeArguments(); Type typeArg = actualTypeArguments[0]; if (!(typeArg instanceof WildcardType)) { return (Class<?>) typeArg; } } else { return null; } } return resolveTypeArgument((Class<?>) returnType, genericIfc); }\n\n    ### Response: Resolve the single type argument of the given generic interface against the given\ntarget method which is assumed to return the given interface or an implementation\nof it.\n@param method the target method to check the return type of\n@param genericIfc the generic interface or superclass to resolve the type argument from\n@return the resolved parameter type of the method return type, or {@code null}\nif not resolvable or if the single argument is of type {@link WildcardType}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \"'\" + getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } if (responseType == Response.class) { throw methodError(method, \"Response must include generic type (e.g., Response<String>)\"); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\"HEAD\") && !Void.class.equals(responseType)) { throw methodError(method, \"HEAD method must use Void as response type.\"); } Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable); } }\n\n    ### Response:", "ground_truth": "Inspects the annotations on an interface method to construct a reusable service method that\nspeaks HTTP. This requires potentially-expensive reflection so it is best to build each service\nmethod only once and reuse it.", "predict": " Parse the Retrofit annotations on the given method to create a new {@link HttpServiceMethod} instance.\n\n@param retrofit the Retrofit instance\n@param method the target method to parse annotations for\n@param requestFactory the {@link RequestFactory} to use for creating the request\n@return a new {@link HttpServiceMethod} instance\n@throws IllegalArgumentException if the method has invalid annotations or if the response type is not a valid type for the given method\n@throws IllegalStateException if the method is a Kotlin suspend function and the return type is not a {@link Response} with a generic type parameter\n\n    "}, {"ID": 69, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClientConfig setIdleConnectionTimeout(long idleConnectionTimeout, TimeUnit unit) { if (idleConnectionTimeout <= 0) { this.idleConnectionTimeoutMs = -1; } else { if(unit.toMinutes(idleConnectionTimeout) < 10) { throw new IllegalArgumentException(\"idleConnectionTimeout should be minimum of 10 minutes\"); } this.idleConnectionTimeoutMs = unit.toMillis(idleConnectionTimeout); } return this; }\n\n    ### Response: Set the timeout for idle connections. Voldemort client caches all\nconnections to the Voldemort server. This setting allows the a connection\nto be dropped, if it is idle for more than this time.\n\nThis could be useful in the following cases 1) Voldemort client is not\ndirectly connected to the server and is connected via a proxy or\nfirewall. The Proxy or firewall could drop the connection silently. If\nthe connection is dropped, then client will see operations fail with a\ntimeout. Setting this property enables the Voldemort client to tear down\nthe connection before a firewall could drop it. 2) Voldemort server\ncaches the connection and each connection has an associated memory cost.\nSetting this property on all clients, enable the clients to prune the\nconnections and there by freeing up the server connections.\n\nthrows IllegalArgumentException if the timeout is less than 10 minutes.\n\nCurrently it can't be set below 10 minutes to avoid the racing risk of\ncontention between connection checkout and selector trying to close it.\nThis is intended for low throughput scenarios.\n\n@param idleConnectionTimeout\nzero or negative number to disable the feature ( default -1)\ntimeout\n@param unit {@link TimeUnit}\n@return ClientConfig object for chained set\n\nthrows {@link IllegalArgumentException} if the timeout is greater\nthan 0, but less than 10 minutes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDelay(long amount, TimeUnit unit) { if (amount < 0) { throw new IllegalArgumentException(\"Amount must be positive value.\"); } this.delayMs = unit.toMillis(amount); }\n\n    ### Response:", "ground_truth": "Set the network round trip delay.", "predict": " Set the delay for the operation.\n\n@param amount\ndelay time in the specified unit\n@param unit {@link TimeUnit}\n@throws IllegalArgumentException if the amount is negative.\n\n    "}, {"ID": 70, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private synchronized void refreshFlow() { try { initialize(); } catch (Exception e) { throw new IllegalStateException(\"Error while initializing wizard\", e); } int currentFlowPointer = this.flowPointer; try { this.flowPointer = 0; while (canMoveToNextStep()) { try { next().initialize(); } catch (Exception e) { throw new IllegalStateException(\"Error while moving to the next wizard step\", e); } } cleanSubsequentStalePages(); } finally { this.flowPointer = currentFlowPointer; } }\n\n    ### Response: Refreshes the current flow so it's possible to eagerly fetch all the steps.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Response<?> createErrorResponse() { Response<?> call; try { call = errorFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; }\n\n    ### Response:", "ground_truth": "The HTTP error to be used when an error is triggered.", "predict": " Creates an error response object.\n\n    "}, {"ID": 71, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean centerOnSquare(QrCode.Alignment pattern, float guessY, float guessX) { float step = 1; float bestMag = Float.MAX_VALUE; float bestX = guessX; float bestY = guessY; for (int i = 0; i < 10; i++) { for (int row = 0; row < 3; row++) { float gridy = guessY - 1f + row; for (int col = 0; col < 3; col++) { float gridx = guessX - 1f + col; samples[row*3+col] = reader.read(gridy,gridx); } } float dx = (samples[2]+samples[5]+samples[8])-(samples[0]+samples[3]+samples[6]); float dy = (samples[6]+samples[7]+samples[8])-(samples[0]+samples[1]+samples[2]); float r = (float)Math.sqrt(dx*dx + dy*dy); if( bestMag > r ) { // System.out.println(\"good step at \"+i); bestMag = r; bestX = guessX; bestY = guessY; } else { // System.out.println(\"bad step at \"+i); step *= 0.75f; } if( r > 0 ) { guessX = bestX + step * dx / r; guessY = bestY + step * dy / r; } else { break; } } pattern.moduleFound.x = bestX; pattern.moduleFound.y = bestY; reader.gridToImage((float)pattern.moduleFound.y,(float)pattern.moduleFound.x,pattern.pixel); return true; }\n\n    ### Response: If the initial guess is within the inner white circle or black dot this will ensure that it is centered\non the black dot.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long calculateDelay(TimeUnit unit) { float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta; // 0.2f --> 0.8f float upperBound = 1f + delta; // 0.2f --> 1.2f float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4) long callDelayMs = (long) (delayMs * delayPercent); return MILLISECONDS.convert(callDelayMs, unit); }\n\n    ### Response:", "ground_truth": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "predict": " This method calculates the delay between two calls to a remote service based on a random percentage of the variance. The variance is a percentage of the delay that is allowed to vary. The lowerBound and upperBound are calculated based on the variance. The delayPercent is calculated by adding a random float between the lowerBound and upperBound to the lowerBound. The callDelayMs is calculated by multiplying the delayMs by the delayPercent. The final result is converted to the specified time unit and returned as a long value."}, {"ID": 72, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean start(String home, File options) { File homeDirectory = new File(home); if (!homeDirectory.exists()) return false; stop(home); try { List<String> command = new ArrayList<String>(); command.add(java); command.add(\"-Dironjacamar.home=\" + home); if (options != null && options.exists()) command.add(\"-Dironjacamar.options=\" + options.getAbsolutePath()); command.add(\"-Djava.net.preferIPv4Stack=true\"); command.add(\"-Djgroups.bind_addr=127.0.0.1\"); command.add(\"-Dorg.jboss.logging.Logger.pluginClass=org.jboss.logging.logmanager.LoggerPluginImpl\"); command.add(\"-Dlog4j.defaultInitOverride=true\"); command.add(\"-jar\"); command.add(home + \"/bin/ironjacamar-sjc.jar\"); ProcessBuilder pb = new ProcessBuilder(command); pb.redirectErrorStream(true); Map<String, String> environment = pb.environment(); environment.put(\"ironjacamar.home\", home); Process p = pb.start(); instances.put(home, p); return true; } catch (Throwable t) { // Ignore } return false; }\n\n    ### Response: Start an instance\n@param home The home directory\n@param options The options\n@return True if started successfully; otherwise false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createSampleData(String username, String password) { Assert.notNull(documentDao, \"DocumentDao required\"); Assert.hasText(username, \"Username required\"); Authentication auth = new UsernamePasswordAuthenticationToken(username, password); try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder.getContext().setAuthentication(auth); // Create the home directory first Directory home = new Directory(username, Directory.ROOT_DIRECTORY); documentDao.create(home); addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN); addPermission(documentDao, home, \"ROLE_USER\", LEVEL_GRANT_READ); createFiles(documentDao, home); // Now create the confidential directory Directory confid = new Directory(\"confidential\", home); documentDao.create(confid); addPermission(documentDao, confid, \"ROLE_USER\", LEVEL_NEGATE_READ); createFiles(documentDao, confid); // Now create the shared directory Directory shared = new Directory(\"shared\", home); documentDao.create(shared); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_READ); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_WRITE); createFiles(documentDao, shared); } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder.clearContext(); } }\n\n    ### Response:", "ground_truth": "Creates a directory for the user, and a series of sub-directories. The root\ndirectory is the parent for the user directory. The sub-directories are\n\"confidential\" and \"shared\". The ROLE_USER will be given read and write access to\n\"shared\".", "predict": " Create sample data for a user\n@param username The username\n@param password The password\n\n    "}, {"ID": 73, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object getValue(Method method) throws VarExploderException { try { if (method == null) { return null; } return method.invoke(source); } catch (IllegalArgumentException e) { throw new VarExploderException(e); } catch (IllegalAccessException e) { throw new VarExploderException(e); } catch (InvocationTargetException e) { throw new VarExploderException(e); } }\n\n    ### Response: Return the value of the property.\n\n@param method\n@return\n@throws VarExploderException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; }\n\n    ### Response:", "ground_truth": "Provides a save way of obtaining the HttpMethod from a String. If the method is\ninvalid, returns null.\n\n@param method the HTTP method to use.\n\n@return the HttpMethod or null if method is invalid.", "predict": " Returns the enum constant of this type with the specified name.\n\n@param method\n@return the enum constant with the specified name\n@throws IllegalArgumentException if this enum type has no constant with the specified name"}, {"ID": 74, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized boolean pushSubject(String username) { if (securityService == null || username == null) { if (tc.isDebugEnabled()) { Tr.debug(tc, \"returning false because user or securityService is null,\" + \" user= \" + username + \" secsvc= \" + securityService); } return false; } AuthenticationService authenticationService = securityService.getAuthenticationService(); Subject tempSubject = new Subject(); Hashtable<String, Object> hashtable = new Hashtable<String, Object>(); if (!authenticationService.isAllowHashTableLoginWithIdOnly()) { hashtable.put(AuthenticationConstants.INTERNAL_ASSERTION_KEY, Boolean.TRUE); } hashtable.put(\"com.ibm.wsspi.security.cred.userId\", username); tempSubject.getPublicCredentials().add(hashtable); try { Subject new_subject = authenticationService.authenticate(JaasLoginConfigConstants.SYSTEM_WEB_INBOUND, tempSubject); return setRunAsSubject(new_subject); } catch (AuthenticationException e) { FFDCFilter.processException(e, TokenPropagationHelper.class.getName(), \"pushSubject\", new Object[] { username }); Tr.error(tc, \"ERROR_AUTHENTICATE\", new Object[] { e.getMessage() }); // CWWKS6103E return false; } catch (Exception e) { FFDCFilter.processException(e, TokenPropagationHelper.class.getName(), \"pushSubject\", new Object[] { username }); return false; } }\n\n    ### Response: Authenticate the username, create it's Subject and push it on to the thread.\nIt's up to the caller to save off the prior subject and make sure it gets restored,\nand guard against any threading issues.\n\n@param username\n@return true if successful.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public DirContextOperations searchForUser(String username) { if (logger.isDebugEnabled()) { logger.debug(\"Searching for user '\" + username + \"', with user search \" + this); } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate( contextSource); template.setSearchControls(searchControls); try { return template.searchForSingleEntry(searchBase, searchFilter, new String[] { username }); } catch (IncorrectResultSizeDataAccessException notFound) { if (notFound.getActualSize() == 0) { throw new UsernameNotFoundException(\"User \" + username + \" not found in directory.\"); } // Search should never return multiple results if properly configured, so just // rethrow throw notFound; } }\n\n    ### Response:", "ground_truth": "Return the LdapUserDetails containing the user's information\n\n@param username the username to search for.\n\n@return An LdapUserDetails object containing the details of the located user's\ndirectory entry\n\n@throws UsernameNotFoundException if no matching entry is found.", "predict": "Search for a user in the LDAP directory.\n\n@param username\n@return the user's attributes, or null if not found.\n\n    "}, {"ID": 75, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String daoName(SQLiteDaoDefinition value) { String classTableName = value.getName(); classTableName = classTableName + SUFFIX; return classTableName; }\n\n    ### Response: Dao name.\n\n@param value\nthe value\n@return typeName of dao.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(CharSequence rawPassword) { String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX; return digest(salt, rawPassword); }\n\n    ### Response:", "ground_truth": "Encodes the rawPass using a MessageDigest. If a salt is specified it will be merged\nwith the password before encoding.\n\n@param rawPassword The plain text password\n@return Hex string of password digest (or base64 encoded string if\nencodeHashAsBase64 is enabled.", "predict": " Encodes the raw password using the salt generator and the SHA-256 algorithm.\n\n@param rawPassword\nthe raw password to encode\n@return the encoded password\n\n    "}, {"ID": 76, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean fixSalt(Document doc) { Element root = doc.getDocumentElement(); String salt = root.getAttribute(\"salt\"); if (StringUtil.isEmpty(salt, true) || !Decision.isUUId(salt)) { // create salt root.setAttribute(\"salt\", CreateUUID.invoke()); return true; } return false; }\n\n    ### Response: make sure every context has a salt.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matches(CharSequence rawPassword, String encodedPassword) { String salt = extractSalt(encodedPassword); String rawPasswordEncoded = digest(salt, rawPassword); return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded); }\n\n    ### Response:", "ground_truth": "Takes a previously encoded password and compares it with a rawpassword after mixing\nin the salt and encoding that value\n\n@param rawPassword plain text password\n@param encodedPassword previously encoded password\n@return true or false", "predict": " extract salt from encoded password and encode raw password with salt to compare with encoded password."}, {"ID": 77, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void retrieveEngine() throws GeneralSecurityException, IOException { if (serverEngineFactory == null) { return; } engine = serverEngineFactory.retrieveHTTPServerEngine(nurl.getPort()); if (engine == null) { engine = serverEngineFactory.getHTTPServerEngine(nurl.getHost(), nurl.getPort(), nurl.getProtocol()); } assert engine != null; TLSServerParameters serverParameters = engine.getTlsServerParameters(); if (serverParameters != null && serverParameters.getCertConstraints() != null) { CertificateConstraintsType constraints = serverParameters.getCertConstraints(); if (constraints != null) { certConstraints = CertConstraintsJaxBUtils.createCertConstraints(constraints); } } // When configuring for \"http\", however, it is still possible that // Spring configuration has configured the port for https. if (!nurl.getProtocol().equals(engine.getProtocol())) { throw new IllegalStateException(\"Port \" + engine.getPort() + \" is configured with wrong protocol \\\"\" + engine.getProtocol() + \"\\\" for \\\"\" + nurl + \"\\\"\"); } }\n\n    ### Response: Post-configure retreival of server engine..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void performVersionChecks(String minSpringVersion) { if (minSpringVersion == null) { return; } // Check Spring Compatibility String springVersion = SpringVersion.getVersion(); String version = getVersion(); if (disableChecks(springVersion, version)) { return; } logger.info(\"You are running with Spring Security Core \" + version); if (new ComparableVersion(springVersion) .compareTo(new ComparableVersion(minSpringVersion)) < 0) { logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion); } }\n\n    ### Response:", "ground_truth": "Perform version checks with specific min Spring Version\n\n@param minSpringVersion", "predict": " Checks the Spring version compatibility.\n\n    "}, {"ID": 78, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isFormatDita(final String attrFormat) { if (attrFormat == null || attrFormat.equals(ATTR_FORMAT_VALUE_DITA)) { return true; } for (final String f : ditaFormat) { if (f.equals(attrFormat)) { return true; } } return false; }\n\n    ### Response: Check if format is DITA topic.\n\n@param attrFormat format attribute value, may be {@code null}\n@return {@code true} if DITA topic, otherwise {@code false}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\n\n    ### Response:", "ground_truth": "Disable if springVersion and springSecurityVersion are the same to allow working\nwith Uber Jars.\n\n@param springVersion\n@param springSecurityVersion\n@return", "predict": " Check if security checks should be disabled.\n\n@param springVersion Spring version, may be {@code null}\n@param springSecurityVersion Spring Security version, may be {@code null}\n@return {@code true} if security checks should be disabled, otherwise {@code false}."}, {"ID": 79, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getVersion() { Properties properties = new Properties(); try (InputStream ins = HttpRosetteAPI.class.getClassLoader().getResourceAsStream(\"version.properties\")) { properties.load(ins); } catch (IOException e) { // should not happen } return properties.getProperty(\"version\", \"undefined\"); }\n\n    ### Response: Returns the version of the binding.\n\n@return version of the binding.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getSpringVersion() { Properties properties = new Properties(); try { properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\")); } catch (IOException | NullPointerException e) { return null; } return properties.getProperty(\"org.springframework:spring-core\"); }\n\n    ### Response:", "ground_truth": "Loads the spring version or null if it cannot be found.\n@return", "predict": " Returns the version of the Spring Core library used by Spring Security.\n\n@return version of the Spring Core library used by Spring Security."}, {"ID": 80, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<? extends IPAddressSeqRange> prefixIterator(int prefixLength) { if(!isMultiple()) { return new Iterator<IPAddressSeqRange>() { IPAddressSeqRange orig = IPAddressSeqRange.this; @Override public boolean hasNext() { return orig != null; } @Override public IPAddressSeqRange next() { if(orig == null) { throw new NoSuchElementException(); } IPAddressSeqRange result = orig; orig = null; return result; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } return new Iterator<IPAddressSeqRange>() { Iterator<? extends IPAddress> prefixBlockIterator = prefixBlockIterator(prefixLength); private boolean first = true; @Override public boolean hasNext() { return prefixBlockIterator.hasNext(); } @Override public IPAddressSeqRange next() { IPAddress next = prefixBlockIterator.next(); if(first) { first = false; // next is a prefix block IPAddress lower = getLower(); if(hasNext()) { if(!lower.includesZeroHost(prefixLength)) { return create(lower, next.getUpper()); } } else { IPAddress upper = getUpper(); if(!lower.includesZeroHost(prefixLength) || !upper.includesMaxHost(prefixLength)) { return create(lower, upper); } } } else if(!hasNext()) { IPAddress upper = getUpper(); if(!upper.includesMaxHost(prefixLength)) { return create(next.getLower(), upper); } } return next.toSequentialRange(); } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response: Iterates through the range of prefixes in this range instance using the given prefix length.\n\n@param prefixLength\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AttributeExchangeConfigurer attributeExchange(String identifierPattern) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer( identifierPattern); this.attributeExchangeConfigurers.add(attributeExchangeConfigurer); return attributeExchangeConfigurer; }\n\n    ### Response:", "ground_truth": "", "predict": "Configures the attribute exchange for the given identifier pattern.\n\n@param identifierPattern\n@return the AttributeExchangeConfigurer instance for further configuration."}, {"ID": 81, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static LargeBlockTask getReleaseTask(BlockId blockId) { return new LargeBlockTask() { @Override public LargeBlockResponse call() throws Exception { Exception theException = null; try { LargeBlockManager.getInstance().releaseBlock(blockId); } catch (Exception exc) { theException = exc; } return new LargeBlockResponse(theException); } }; }\n\n    ### Response: Get a new \"release\" task\n@param blockId   The block id of the block to release\n@return  An instance of LargeBlockTask that will release a block.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception { OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>()); this.postProcess(configurer); return configurer; }\n\n    ### Response:", "ground_truth": "Configures OAuth 2.0 Client support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ClientConfigurer} for further customizations\n@throws Exception", "predict": " Configure OAuth2 client for the application\n@return  An instance of OAuth2ClientConfigurer that can be used to configure OAuth2 client for the application.\n\n    "}, {"ID": 82, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static LargeBlockTask getReleaseTask(BlockId blockId) { return new LargeBlockTask() { @Override public LargeBlockResponse call() throws Exception { Exception theException = null; try { LargeBlockManager.getInstance().releaseBlock(blockId); } catch (Exception exc) { theException = exc; } return new LargeBlockResponse(theException); } }; }\n\n    ### Response: Get a new \"release\" task\n@param blockId   The block id of the block to release\n@return  An instance of LargeBlockTask that will release a block.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception { OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); this.postProcess(configurer); return configurer; }\n\n    ### Response:", "ground_truth": "Configures OAuth 2.0 Resource Server support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ResourceServerConfigurer} for further customizations\n@throws Exception", "predict": " Configure OAuth2 resource server\n@return  An instance of OAuth2ResourceServerConfigurer that can be used to configure OAuth2 resource server.\n\n    "}, {"ID": 83, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ApplicationContext getApplicationContext(JobExecutionContext context) throws SchedulerException { final SchedulerContext schedulerContext = context.getScheduler().getContext(); ApplicationContext applicationContext = (ApplicationContext) schedulerContext.get(APPLICATION_CONTEXT_KEY); // show keys in context if(applicationContext==null) { logger.error(APPLICATION_CONTEXT_KEY+\" is empty in \"+ schedulerContext+\":\"); if(schedulerContext.getKeys()!=null) { for (String key : schedulerContext.getKeys()) { Object value = schedulerContext.get(key); String valueText = value!=null ? value.toString() : \"<NULL>\"; logger.info(\" {} = {}\", key, valueText); } } } return applicationContext; }\n\n    ### Response: Obtains Spring's application context.\n\n@param context    job execution context\n@return application context\n@throws SchedulerException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); }\n\n    ### Response:", "ground_truth": "Configures channel security. In order for this configuration to be useful at least\none mapping to a required channel must be provided.\n\nExample Configuration\n\nThe example below demonstrates how to require HTTPs for every request. Only\nrequiring HTTPS for some requests is supported, but not recommended since an\napplication that allows for HTTP introduces many security vulnerabilities. For one\nsuch example, read about Firesheep.\n\n\n\n\n@return the {@link ChannelSecurityConfigurer} for further customizations\n@throws Exception", "predict": "Configures channel security.\n\n@return channel request matcher registry\n@throws Exception."}, {"ID": 84, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<Map<String, String[]>> searchForMultipleAttributeValues(final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i=0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, String[]>> set = new HashSet<Map<String, String[]>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, String[]> record = new HashMap<String, String[]>(); for (String attributeName : attributeNames) { String[] values = adapter.getStringAttributes(attributeName); if (values == null || values.length == 0) { logger.debug(\"No attribute value found for '\" + attributeName + \"'\"); } else { record.put(attributeName, values); } } record.put(DN_KEY, new String[] {adapter.getDn().toString()}); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames); search(base, formattedFilter, ctls, roleMapper); return set; }\n\n    ### Response: Performs a search using the supplied filter and returns the values of each named attribute\nfound in all entries matched by the search. Note that one directory entry may have several values for the\nattribute. Intended for role searches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching entries.\nThe attribute name is the key for each set of values. In addition each map contains the DN as a String\nwith the key predefined key {@link #DN_KEY}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean compare(final String dn, final String attributeName, final Object value) { final String comparisonFilter = \"(\" + attributeName + \"={0})\"; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext(DirContext ctx) throws NamingException { SearchControls ctls = new SearchControls(); ctls.setReturningAttributes(NO_ATTRS); ctls.setSearchScope(SearchControls.OBJECT_SCOPE); NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls); Boolean match = Boolean.valueOf(results.hasMore()); LdapUtils.closeEnumeration(results); return match; } } Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback()); return matches.booleanValue(); }\n\n    ### Response:", "ground_truth": "Performs an LDAP compare operation of the value of an attribute for a particular\ndirectory entry.\n\n@param dn the entry who's attribute is to be used\n@param attributeName the attribute who's value we want to compare\n@param value the value to be checked against the directory value\n\n@return true if the supplied value matches that in the directory", "predict": " Compares the value of the specified attribute in the entry with the given value.\n\n@param dn the DN of the entry to compare\n@param attributeName the name of the attribute to compare\n@param value the value to compare the attribute with\n\n@return true if the attribute value matches the given value, false otherwise.\n\n    "}, {"ID": 85, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static List<String> loadDnsRecords(final String serviceName, final DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(serviceName, new String[] { \"SRV\" }); NamingEnumeration<?> servers = attrs.get(\"srv\").getAll(); List<String> records = new ArrayList<String>(); while (servers.hasMore()) { DnsRecord record = DnsRecord.fromString((String) servers.next()); records.add(record.getHost()); } return records; }\n\n    ### Response: Helper method to load a list of DNS SRV records.\n\n@param serviceName the service to locate.\n@param ctx the directory context to fetch from.\n@return the list of dns records\n@throws NamingException if something goes wrong during the load process..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) { return (DirContextOperations) executeReadOnly(new ContextExecutor() { public Object executeWithContext(DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve); // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace())); } }); }\n\n    ### Response:", "ground_truth": "Composes an object from the attributes of the given DN.\n\n@param dn the directory entry which will be read\n@param attributesToRetrieve the named attributes which will be retrieved from the\ndirectory entry.\n\n@return the object created by the mapper", "predict": " Retrieves a directory entry using the specified distinguished name and attributes.\n\n@param dn the distinguished name of the entry to retrieve.\n@param attributesToRetrieve the attributes to retrieve.\n@return the directory entry.\n@throws NamingException if an error occurs during the retrieval process."}, {"ID": 86, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<Map<String, String[]>> searchForMultipleAttributeValues(final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i=0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, String[]>> set = new HashSet<Map<String, String[]>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, String[]> record = new HashMap<String, String[]>(); for (String attributeName : attributeNames) { String[] values = adapter.getStringAttributes(attributeName); if (values == null || values.length == 0) { logger.debug(\"No attribute value found for '\" + attributeName + \"'\"); } else { record.put(attributeName, values); } } record.put(DN_KEY, new String[] {adapter.getDn().toString()}); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames); search(base, formattedFilter, ctls, roleMapper); return set; }\n\n    ### Response: Performs a search using the supplied filter and returns the values of each named attribute\nfound in all entries matched by the search. Note that one directory entry may have several values for the\nattribute. Intended for role searches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching entries.\nThe attribute name is the key for each set of values. In addition each map contains the DN as a String\nwith the key predefined key {@link #DN_KEY}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) { String[] attributeNames = new String[] { attributeName }; Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues( base, filter, params, attributeNames); Set<String> result = new HashSet<>(); for (Map<String, List<String>> map : multipleAttributeValues) { List<String> values = map.get(attributeName); if (values != null) { result.addAll(values); } } return result; }\n\n    ### Response:", "ground_truth": "Performs a search using the supplied filter and returns the union of the values of\nthe named attribute found in all entries matched by the search. Note that one\ndirectory entry may have several values for the attribute. Intended for role\nsearches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute who's values are to be retrieved.\n\n@return the set of String values for the attribute as a union of the values found\nin all the matching entries.", "predict": " Performs a search using the supplied filter and returns the values of the named attribute\nfound in all entries matched by the search. Note that one directory entry may have several values for the\nattribute. Intended for scenarios where only one attribute is expected to be returned.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute's value that is to be retrieved.\n\n@return the set of String values for the attribute found in all the matching entries."}, {"ID": 87, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<Map<String, String[]>> searchForMultipleAttributeValues(final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i=0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, String[]>> set = new HashSet<Map<String, String[]>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, String[]> record = new HashMap<String, String[]>(); for (String attributeName : attributeNames) { String[] values = adapter.getStringAttributes(attributeName); if (values == null || values.length == 0) { logger.debug(\"No attribute value found for '\" + attributeName + \"'\"); } else { record.put(attributeName, values); } } record.put(DN_KEY, new String[] {adapter.getDn().toString()}); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames); search(base, formattedFilter, ctls, roleMapper); return set; }\n\n    ### Response: Performs a search using the supplied filter and returns the values of each named attribute\nfound in all entries matched by the search. Note that one directory entry may have several values for the\nattribute. Intended for role searches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching entries.\nThe attribute name is the key for each set of values. In addition each map contains the DN as a String\nwith the key predefined key {@link #DN_KEY}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i = 0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, List<String>> record = new HashMap<String, List<String>>(); if (attributeNames == null || attributeNames.length == 0) { try { for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae .hasMore();) { Attribute attr = (Attribute) ae.next(); extractStringAttributeValues(adapter, record, attr.getID()); } } catch (NamingException x) { org.springframework.ldap.support.LdapUtils .convertLdapException(x); } } else { for (String attributeName : attributeNames) { extractStringAttributeValues(adapter, record, attributeName); } } record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter))); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null); search(base, formattedFilter, ctls, roleMapper); return set; }\n\n    ### Response:", "ground_truth": "Performs a search using the supplied filter and returns the values of each named\nattribute found in all entries matched by the search. Note that one directory entry\nmay have several values for the attribute. Intended for role searches and similar\nscenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching\nentries. The attribute name is the key for each set of values. In addition each map\ncontains the DN as a String with the key predefined key {@link #DN_KEY}.", "predict": " Performs a search using the supplied filter and returns the values of each named attribute\nfound in all entries matched by the search. Note that one directory entry may have several values for the\nattribute. Intended for role searches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching entries.\nThe attribute name is the key for each set of values. In addition each map contains the DN as a String\nwith the key predefined key {@link #DN_KEY}.."}, {"ID": 88, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addJarClasses(final Path location) { try (final JarFile jarFile = new JarFile(location.toFile())) { final Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { final JarEntry entry = entries.nextElement(); final String entryName = entry.getName(); if (entryName.endsWith(\".class\")) classes.add(toQualifiedClassName(entryName)); } } catch (IOException e) { throw new IllegalArgumentException(\"Could not read jar-file '\" + location + \"', reason: \" + e.getMessage()); } }\n\n    ### Response: Adds all classes in the given jar-file location to the set of known classes.\n\n@param location The location of the jar-file.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (DirContextAdapter) searchResult.getObject(); Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\"); if (logger.isDebugEnabled()) { logger.debug(\"Found DN: \" + dca.getDn()); } results.add(dca); } } catch (PartialResultException e) { LdapUtils.closeEnumeration(resultsEnum); logger.info(\"Ignoring PartialResultException\"); } if (results.size() == 0) { throw new IncorrectResultSizeDataAccessException(1, 0); } if (results.size() > 1) { throw new IncorrectResultSizeDataAccessException(1, results.size()); } return results.iterator().next(); }\n\n    ### Response:", "ground_truth": "Internal method extracted to avoid code duplication in AD search.", "predict": " Searches for a single entry in the directory using the specified search controls and filter.\n\n@param ctx The directory context to search in.\n@param searchControls The search controls to use for the search.\n@param base The base DN to search under.\n@param filter The filter expression to use for the search.\n@param params The parameters to use for the search.\n@return The DirContextOperations for the single entry found.\n@throws NamingException If the search fails.\n@throws IncorrectResultSizeDataAccessException If more than one entry is found."}, {"ID": 89, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Trivial private static String toKey(String name, String filter, SearchControls cons) { int length = name.length() + filter.length() + 100; StringBuffer key = new StringBuffer(length); key.append(name); key.append(\"|\"); key.append(filter); key.append(\"|\"); key.append(cons.getSearchScope()); key.append(\"|\"); key.append(cons.getCountLimit()); key.append(\"|\"); key.append(cons.getTimeLimit()); String[] attrIds = cons.getReturningAttributes(); if (attrIds != null) { for (int i = 0; i < attrIds.length; i++) { key.append(\"|\"); key.append(attrIds[i]); } } return key.toString(); }\n\n    ### Response: Returns a hash key for the name|filter|cons tuple used in the search\nquery-results cache.\n\n@param name The name of the object from which to retrieve attributes.\n@param filter the filter used in the search.\n@param cons The search controls used in the search.\n@throws NamingException If a naming exception is encountered..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static SearchControls buildControls(SearchControls originalControls) { return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag()); }\n\n    ### Response:", "ground_truth": "We need to make sure the search controls has the return object flag set to true, in\norder for the search to return DirContextAdapter instances.\n@param originalControls\n@return", "predict": " Builds a new search controls object with the same settings as the original controls object, except for the return type which is set to OBJECT_RESULTS.\n\n@param originalControls The original search controls object.\n@return A new search controls object with the same settings as the original controls object, except for the return type which is set to OBJECT_RESULTS."}, {"ID": 90, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Set<Long> getModelTrainingDifference(final DataModelIF<Long, Long> model, final Long user) { final Set<Long> items = new HashSet<Long>(); if (training.getUserItems(user) != null) { final Set<Long> trainingItems = new HashSet<>(); for (Long i : training.getUserItems(user)) { trainingItems.add(i); } for (Long item : model.getItems()) { if (!trainingItems.contains(item)) { items.add(item); } } } return items; }\n\n    ### Response: Get the items appearing in the training set and not in the data model.\n\n@param model The data model.\n@param user The user.\n@return The items not appearing in the training set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) { Assert.notNull(acls, \"ACLs are required\"); Assert.notEmpty(findNow, \"Items to find now required\"); String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size()); Set<Long> parentsToLookup = jdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { int i = 0; for (Long toFind : findNow) { i++; ps.setLong(i, toFind); } } }, new ProcessResultSet(acls, sids)); // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if (parentsToLookup.size() > 0) { lookupPrimaryKeys(acls, parentsToLookup, sids); } }\n\n    ### Response:", "ground_truth": "Locates the primary key IDs specified in \"findNow\", adding AclImpl instances with\nStubAclParents to the \"acls\" Map.\n\n@param acls the AclImpls (with StubAclParents)\n@param findNow Long-based primary keys to retrieve\n@param sids", "predict": " Lookup the primary keys of the given items in the ACLs.\n\n@param acls The ACLs.\n@param findNow The items to find now.\n@param sids The SIDs to lookup.\n\n    "}, {"ID": 91, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails buildDetails(PortletRequest context) { Collection<? extends GrantedAuthority> userGas = buildGrantedAuthorities(context); PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails(context, userGas); return result; }\n\n    ### Response: Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)\n@param context a {@link javax.portlet.PortletRequest} object.\n@return a {@link org.jasig.springframework.security.portlet.authentication.PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails} object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails( HttpServletRequest context) { Collection<String> j2eeUserRoles = getUserRoles(context); Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper .getGrantedAuthorities(j2eeUserRoles); if (logger.isDebugEnabled()) { logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\"); } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails( context, userGas); return result; }\n\n    ### Response:", "ground_truth": "Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)", "predict": " Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)\n@param context a {@link javax.servlet.http.HttpServletRequest} object.\n@return a {@link org.jasig.springframework.security.web.authentication.PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails} object."}, {"ID": 92, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Connection getConnection(final ICommandLine cl) throws SQLException, InstantiationException, IllegalAccessException, ClassNotFoundException { String database = DEFAULT_TABLE; if (cl.hasOption(\"database\")) { database = cl.getOptionValue(\"database\"); } String hostname = DEFAULT_HOSTNAME; if (cl.hasOption(\"hostname\") && !\"\".equals(cl.getOptionValue(\"hostname\"))) { hostname = cl.getOptionValue(\"hostname\"); } String port = DEFAULT_PORT; if (cl.hasOption(\"port\") && !\"\".equals(cl.getOptionValue(\"port\"))) { port = cl.getOptionValue(\"port\"); } String password = \"\"; if (cl.hasOption(\"password\")) { password = cl.getOptionValue(\"password\"); } String username = \"\"; if (cl.hasOption(\"logname\")) { username = cl.getOptionValue(\"logname\"); } String timeout = DEFAULT_TIMEOUT; if (cl.getOptionValue(\"timeout\") != null) { timeout = cl.getOptionValue(\"timeout\"); } Properties props = new Properties(); props.setProperty(\"user\", username); props.setProperty(\"password\", password); props.setProperty(\"timeout\", timeout); String url = \"jdbc:postgresql://\" + hostname + \":\" + port + \"/\" + database; DriverManager.registerDriver((Driver) Class.forName(\"org.postgresql.Driver\").newInstance()); return DriverManager.getConnection(url, props); }\n\n    ### Response: Connect to the server.\n\n@param cl\nThe command line\n@return The connection\n@throws SQLException\n-\n@throws InstantiationException\n-\n@throws IllegalAccessException\n-\n@throws ClassNotFoundException\n-.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); String suffix = element.getAttribute(ATT_ROOT_SUFFIX); if (!StringUtils.hasText(suffix)) { suffix = OPT_DEFAULT_ROOT_SUFFIX; } String port = element.getAttribute(ATT_PORT); if (!StringUtils.hasText(port)) { port = getDefaultPort(); if (logger.isDebugEnabled()) { logger.debug(\"Using default port of \" + port); } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder .rootBeanDefinition(CONTEXT_SOURCE_CLASS); contextSource.addConstructorArgValue(url); contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\"); contextSource.addPropertyValue(\"password\", \"secret\"); RootBeanDefinition apacheContainer = new RootBeanDefinition( \"org.springframework.security.ldap.server.ApacheDSContainer\", null, null); apacheContainer.setSource(source); apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix); String ldifs = element.getAttribute(ATT_LDIF_FILE); if (!StringUtils.hasText(ldifs)) { ldifs = OPT_DEFAULT_LDIF_FILE; } apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs); apacheContainer.getPropertyValues().addPropertyValue(\"port\", port); logger.info(\"Embedded LDAP server bean definition created for URL: \" + url); if (parserContext.getRegistry() .containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) { parserContext.getReaderContext().error( \"Only one embedded server bean is allowed per application context\", element); } parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer); return (RootBeanDefinition) contextSource.getBeanDefinition(); }\n\n    ### Response:", "ground_truth": "Will be called if no url attribute is supplied.\n\nRegisters beans to create an embedded apache directory server.\n\n@return the BeanDefinition for the ContextSource for the embedded server.\n\n@see ApacheDSContainer", "predict": " Create an embedded LDAP server.\n\n@param element\nThe element representing the embedded LDAP server\n@param parserContext\nThe parser context\n@return The bean definition for the embedded LDAP server\n@throws Exception\n-"}, {"ID": 93, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void seqeval() throws IOException { final String metric = this.parsedArguments.getString(\"metric\"); final String lang = this.parsedArguments.getString(\"language\"); final String model = this.parsedArguments.getString(\"model\"); final String testset = this.parsedArguments.getString(\"testset\"); final String corpusFormat = this.parsedArguments.getString(\"corpusFormat\"); final String netypes = this.parsedArguments.getString(\"types\"); final String clearFeatures = this.parsedArguments .getString(\"clearFeatures\"); final String unknownAccuracy = this.parsedArguments .getString(\"unknownAccuracy\"); final Properties props = setEvalProperties(lang, model, testset, corpusFormat, netypes, clearFeatures, unknownAccuracy); final SequenceLabelerEvaluate evaluator = new SequenceLabelerEvaluate( props); if (metric.equalsIgnoreCase(\"accuracy\")) { evaluator.evaluateAccuracy(); } else { if (this.parsedArguments.getString(\"evalReport\") != null) { if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"brief\")) { evaluator.evaluate(); } else if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"error\")) { evaluator.evalError(); } else if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"detailed\")) { evaluator.detailEvaluate(); } } else { evaluator.detailEvaluate(); } } }\n\n    ### Response: Main evaluation entry point for sequence labeling.\n\n@throws IOException\nthrows exception if test set not available.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createServletApiFilter(BeanReference authenticationManager) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\"; final String DEF_SERVLET_API_PROVISION = \"true\"; String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION); if (!StringUtils.hasText(provideServletApi)) { provideServletApi = DEF_SERVLET_API_PROVISION; } if (\"true\".equals(provideServletApi)) { servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class); servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager); } }\n\n    ### Response:", "ground_truth": "Adds the servlet-api integration filter if required", "predict": " Creates a filter that grants access to the Servlet API.\n\n@param authenticationManager the authentication manager to use for authentication and authorization\n@throws BeansException if the filter cannot be created"}, {"ID": 94, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void seqeval() throws IOException { final String metric = this.parsedArguments.getString(\"metric\"); final String lang = this.parsedArguments.getString(\"language\"); final String model = this.parsedArguments.getString(\"model\"); final String testset = this.parsedArguments.getString(\"testset\"); final String corpusFormat = this.parsedArguments.getString(\"corpusFormat\"); final String netypes = this.parsedArguments.getString(\"types\"); final String clearFeatures = this.parsedArguments .getString(\"clearFeatures\"); final String unknownAccuracy = this.parsedArguments .getString(\"unknownAccuracy\"); final Properties props = setEvalProperties(lang, model, testset, corpusFormat, netypes, clearFeatures, unknownAccuracy); final SequenceLabelerEvaluate evaluator = new SequenceLabelerEvaluate( props); if (metric.equalsIgnoreCase(\"accuracy\")) { evaluator.evaluateAccuracy(); } else { if (this.parsedArguments.getString(\"evalReport\") != null) { if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"brief\")) { evaluator.evaluate(); } else if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"error\")) { evaluator.evalError(); } else if (this.parsedArguments.getString(\"evalReport\") .equalsIgnoreCase(\"detailed\")) { evaluator.detailEvaluate(); } } else { evaluator.detailEvaluate(); } } }\n\n    ### Response: Main evaluation entry point for sequence labeling.\n\n@throws IOException\nthrows exception if test set not available.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createJaasApiFilter() { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\"; final String DEF_JAAS_API_PROVISION = \"false\"; String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION); if (!StringUtils.hasText(provideJaasApi)) { provideJaasApi = DEF_JAAS_API_PROVISION; } if (\"true\".equals(provideJaasApi)) { jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class); } }\n\n    ### Response:", "ground_truth": "Adds the jaas-api integration filter if required", "predict": " Creates a JAAS API integration filter if the \"jaas-api-provision\" attribute is set to \"true\". The default value is \"false\"."}, {"ID": 95, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected <T extends RepositoryResourceImpl> T createNewResource() { T result; if (null == getType()) { result = (T) createTestResource(getRepositoryConnection()); } else { result = ResourceFactory.getInstance().createResource(getType(), getRepositoryConnection(), null); } return result; }\n\n    ### Response: Creates a new resource using the same logon infomation as this resource\n\n@param \n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() { TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); result = result.init(JsonTypeInfo.Id.CLASS, null); result = result.inclusion(JsonTypeInfo.As.PROPERTY); return result; }\n\n    ### Response:", "ground_truth": "Creates a TypeResolverBuilder that performs whitelisting.\n@return a TypeResolverBuilder that performs whitelisting.", "predict": " Creates a new instance of a TypeResolverBuilder that will use a whitelist approach to determine which types are to be included in serialization.\n\n@param \n@return."}, {"ID": 96, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getContextPath(ServletContext servletContext) { String contextPath = DEFAULT_CONTEXT_PATH; // Get the context path if (servletContext != null) { contextPath = servletContext.getContextPath(); if (StringUtils.isEmpty(contextPath)) { contextPath = DEFAULT_CONTEXT_PATH; } } return contextPath; }\n\n    ### Response: Returns the context path associated to the servlet context\n\n@param servletContext\nthe servlet context\n@return the context path associated to the servlet context.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = DEFAULT_FILTER_NAME; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy( filterName); String contextAttribute = getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } registerFilter(servletContext, true, filterName, springSecurityFilterChain); }\n\n    ### Response:", "ground_truth": "Registers the springSecurityFilterChain\n@param servletContext the {@link ServletContext}", "predict": " Registers the Spring Security filter chain with the specified servlet context.\n\n@param servletContext\nthe servlet context\n@param registerDefaultFilter\nwhether to register the default filter chain or not (true by default)\n@param filterName\nthe name of the filter chain to register (default is \"springSecurityFilterChain\")\n@param filter\nthe filter chain to register\n\n    "}, {"ID": 97, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getParamInt(String paramName, int defaultValue) { Object paramValue = getParam(paramName); if (paramValue == null) { return defaultValue; } try { return Integer.parseInt(paramValue.toString()); } catch (Exception e) { throw new IllegalArgumentException(\"Value for parameter '\" + paramName + \"' must be an integer: \" + paramValue); } }\n\n    ### Response: Get the value of the parameter with the given name belonging to this service as an\ninteger. If the parameter is not found, the given default value is returned. If the\nparameter is found but cannot be converted to an integer, an\nIllegalArgumentException is thrown.\n\n@param paramName     Name of parameter to find.\n@param defaultValue  Value to return if parameter is not defined.\n@return              Defined or default value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) { try { return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() { public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException { return new PersistentRememberMeToken(rs.getString(1), rs .getString(2), rs.getString(3), rs.getTimestamp(4)); } }, seriesId); } catch (EmptyResultDataAccessException zeroResults) { if (logger.isDebugEnabled()) { logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults); } } catch (IncorrectResultSizeDataAccessException moreThanOne) { logger.error(\"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\"); } catch (DataAccessException e) { logger.error(\"Failed to load token for series \" + seriesId, e); } return null; }\n\n    ### Response:", "ground_truth": "Loads the token data for the supplied series identifier.\n\nIf an error occurs, it will be reported and null will be returned (since the result\nshould just be a failed persistent login).\n\n@param seriesId\n@return the token matching the series, or null if no match found or an exception\noccurred.", "predict": " Get the token for the given series identifier from the persistent token\nstorage. If no token is found, null is returned. If more than one token is found, an\nerror is logged and null is returned. If an error occurs while executing the query, an\nerror is logged and null is returned.\n\n@param seriesId  Identifier of the series to find the token for.\n@return          Token for the given series identifier, or null if no token is found."}, {"ID": 98, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<GrantedAuthority> buildAuthorities(final List<CommonProfile> profiles) { final List<GrantedAuthority> authorities = new ArrayList<>(); for (final CommonProfile profile : profiles) { final Set<String> roles = profile.getRoles(); for (final String role : roles) { authorities.add(new SimpleGrantedAuthority(role)); } } return authorities; }\n\n    ### Response: Build a list of authorities from a list of profiles.\n\n@param profiles a map of profiles\n@return a list of authorities.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { List<GrantedAuthority> result = new ArrayList<>(attributes.size()); for (String attribute : attributes) { result.add(getGrantedAuthority(attribute)); } return result; }\n\n    ### Response:", "ground_truth": "Map the given list of string attributes one-to-one to Spring Security\nGrantedAuthorities.", "predict": " Get a list of granted authorities from a collection of attributes.\n\n@param attributes a collection of attributes\n@return a list of granted authorities."}, {"ID": 99, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] encrypt(byte[] text, Key key, String algorithm) throws EncryptionException { Cipher cipher; try { LOGGER.trace(\"start encrypting text using {} cipher\", algorithm); cipher = Cipher.getInstance(algorithm); cipher.init(Cipher.ENCRYPT_MODE, key); LOGGER.trace(\"initialized encryption with key of type {}\", key.getClass()); } catch (GeneralSecurityException e) { throw new IllegalArgumentException(\"unable to initialize cipher for algorithm \" + algorithm, e); } try { return cipher.doFinal(text); } catch (GeneralSecurityException e) { throw new EncryptionException(\"unable to encrypt data using algorithm \" + algorithm, e); } }\n\n    ### Response: Encrypts the given data using the given key using the given algorithm. If you are encrypting data that is\nsupposed to be a string, consider encoding it in Base64.\n\n@throws EncryptionException if the string cannot be encrypted with the given key\n@throws IllegalArgumentException if the algorithm is not supported..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cipher newCipher(String algorithm) { try { return Cipher.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e); } catch (NoSuchPaddingException e) { throw new IllegalStateException(\"Should not happen\", e); } }\n\n    ### Response:", "ground_truth": "Constructs a new Cipher.", "predict": "Creates a new Cipher object for the given algorithm.\n\n@throws IllegalArgumentException if the algorithm is not supported.\n@throws IllegalStateException if the padding is not supported."}, {"ID": 100, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void afterPropertiesSet() throws ServletException { super.afterPropertiesSet(); Assert.notNull(generator, \"Metadata generator\"); Assert.notNull(manager, \"MetadataManager must be set\"); }\n\n    ### Response: Verifies that required entities were autowired or set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void afterPropertiesSet() { try { super.afterPropertiesSet(); } catch (ServletException e) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException(e); } Assert.notNull(authenticationManager, \"An AuthenticationManager must be set\"); }\n\n    ### Response:", "ground_truth": "Check whether all required properties have been set.", "predict": " Initializes the required entities and throws a RuntimeException if any exception occurs during initialization."}, {"ID": 101, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpServletRequest = WebFilter.request.get(); try { WebFilter.request.set((HttpServletRequest) request); chain.doFilter(request, response); } finally { WebFilter.request.set(httpServletRequest); } }\n\n    ### Response: Associates the current HTTP servlet request with the current thread until\nfilter chain ends.\n\n@param request The current {@code ServletRequest}.\n@param response The current {@code ServletResponse}.\n@param chain The current {@code FilterChain}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); }\n\n    ### Response:", "ground_truth": "Try to authenticate a pre-authenticated user with Spring Security if the user has\nnot yet been authenticated.", "predict": " Checks if the current HTTP request requires authentication and if so, performs authentication.\n\n@param request The current {@code ServletRequest}.\n@param response The current {@code ServletResponse}.\n@param chain The current {@code FilterChain}..\n\n    "}, {"ID": 102, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public User getLoggedInUser() { User user = null; final Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null) { final Object principal = authentication.getPrincipal(); // principal can be \"anonymousUser\" (String) if (principal instanceof UserDetails) { user = userDetailsConverter.convert((UserDetails) principal); } } return user; }\n\n    ### Response: get logged in user.\n\n@return UserData or null if no one is logged in.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) { Object principal = getPreAuthenticatedPrincipal(request); if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) { return false; } if (principal != null && principal.equals(currentAuthentication.getPrincipal())) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\"); } return true; }\n\n    ### Response:", "ground_truth": "Determines if the current principal has changed. The default implementation tries\n\n\nIf the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is a String, the {@link Authentication#getName()} is compared against the pre authenticated principal\nOtherwise, the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is compared against the {@link Authentication#getPrincipal()}\n\n\nSubclasses can override this method to determine when a principal has changed.\n\n\n@param request\n@param currentAuthentication\n@return true if the principal has changed, else false", "predict": " check if the principal has changed.\n\n@param request the current request\n@param currentAuthentication the current authentication\n@return true if the principal has changed, false otherwise\n\n    "}, {"ID": 103, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public User getLoggedInUser() { User user = null; final Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null) { final Object principal = authentication.getPrincipal(); // principal can be \"anonymousUser\" (String) if (principal instanceof UserDetails) { user = userDetailsConverter.convert((UserDetails) principal); } } return user; }\n\n    ### Response: get logged in user.\n\n@return UserData or null if no one is logged in.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Authentication authResult; Object principal = getPreAuthenticatedPrincipal(request); Object credentials = getPreAuthenticatedCredentials(request); if (principal == null) { if (logger.isDebugEnabled()) { logger.debug(\"No pre-authenticated principal found in request\"); } return; } if (logger.isDebugEnabled()) { logger.debug(\"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\"); } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken( principal, credentials); authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); authResult = authenticationManager.authenticate(authRequest); successfulAuthentication(request, response, authResult); } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); if (!continueFilterChainOnUnsuccessfulAuthentication) { throw failed; } } }\n\n    ### Response:", "ground_truth": "Do the actual authentication for a pre-authenticated user.", "predict": " authenticate the user.\n\n@param request the http request\n@param response the http response\n@throws IOException if an I/O error occurs\n@throws ServletException if a servlet error occurs"}, {"ID": 104, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void optimize(long fileLength) { final int availableProcessors = Runtime.getRuntime().availableProcessors(); final long free = Runtime.getRuntime().freeMemory() / 2; int workerSize = availableProcessors / 2; if (workerSize < 2) { workerSize = 2; } long bufferSize = free / workerSize; if (bufferSize > 1 * 1024 * 1024) { bufferSize = 1 * 1024 * 1024; } long blockSize = fileLength / workerSize; if (blockSize > 1 * 1024 * 1024) { blockSize = 1 * 1024 * 1024; } int iBlockSize = (int) blockSize; if (bufferSize > blockSize) { bufferSize = blockSize; } int iBufferSize = (int) bufferSize; this.setBlockSize(iBlockSize); this.setMaxNumOfThreads(workerSize); this.setBufferSizePerWorker(iBufferSize); this.setSubBufferSize(256); }\n\n    ### Response: Optimize threading and memory\n\n@param fileLength.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkContentLength(long contentLengthToWrite) { this.contentWritten += contentLengthToWrite; boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength; int bufferSize = getBufferSize(); boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize; if (isBodyFullyWritten || requiresFlush) { doOnResponseCommitted(); } }\n\n    ### Response:", "ground_truth": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if\nthe response should be written.\n\n@param contentLengthToWrite the size of the content that is about to be written.", "predict": " Check content length and flush buffer\n\n@param contentLengthToWrite."}, {"ID": 105, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<String> convertToGroups(List<? extends GrantedAuthority> authorities) { List<String> groups = new ArrayList<String>(); for (GrantedAuthority authority : authorities) { groups.add(authority.getAuthority()); } return groups; }\n\n    ### Response: Convert authorities to group names..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; }\n\n    ### Response:", "ground_truth": "Creates a mapping of the supplied authorities based on the case-conversion and\nprefix settings. The mapping will be one-to-one unless duplicates are produced\nduring the conversion. If a default authority has been set, this will also be\nassigned to each mapping.\n\n@param authorities the original authorities\n\n@return the converted set of authorities", "predict": " Map the authorities to a set of GrantedAuthority objects. If a default authority is provided, it will be added to the set as well."}, {"ID": 106, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<T> sample(final Iterator<T> input) { if (fraction == 0) { return emptyIterable; } return new SampledIterator<T>() { T current = null; @Override public boolean hasNext() { if (current == null) { current = getNextSampledElement(); } return current != null; } @Override public T next() { if (current == null) { return getNextSampledElement(); } else { T result = current; current = null; return result; } } private T getNextSampledElement() { if (fraction <= THRESHOLD) { double rand = random.nextDouble(); double u = Math.max(rand, EPSILON); int gap = (int) (Math.log(u) / Math.log(1 - fraction)); int elementCount = 0; if (input.hasNext()) { T element = input.next(); while (input.hasNext() && elementCount < gap) { element = input.next(); elementCount++; } if (elementCount < gap) { return null; } else { return element; } } else { return null; } } else { while (input.hasNext()) { T element = input.next(); if (random.nextDouble() <= fraction) { return element; } } return null; } } }; }\n\n    ### Response: Sample the input elements, for each input element, take a Bernoulli trail for sampling.\n\n@param input Elements to be sampled.\n@return The sampled result which is lazy computed upon input elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); }\n\n    ### Response:", "ground_truth": "Specifies the URL to validate the credentials.\n\n@param loginProcessingUrl the URL to validate username and password\n@return the {@link FormLoginConfigurer} for additional customization", "predict": " Set the login processing URL for the authentication filter.\n\n@param loginProcessingUrl The login processing URL to set.\n@return This object.\n\n    "}, {"ID": 107, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void AddLODSceneObject(GVRSceneObject currentSceneObject) { if (this.transformLODSceneObject != null) { GVRSceneObject levelOfDetailSceneObject = null; if ( currentSceneObject.getParent() == this.transformLODSceneObject) { levelOfDetailSceneObject = currentSceneObject; } else { GVRSceneObject lodSceneObj = root.getSceneObjectByName((currentSceneObject.getName() + TRANSFORM_TRANSLATION_)); if ( lodSceneObj != null ) { if (lodSceneObj.getParent() == this.transformLODSceneObject) { levelOfDetailSceneObject = lodSceneObj; } } if (levelOfDetailSceneObject == null) { lodSceneObj = root.getSceneObjectByName((currentSceneObject.getName() + TRANSFORM_ROTATION_)); if ( lodSceneObj != null ) { if (lodSceneObj.getParent() == this.transformLODSceneObject) { levelOfDetailSceneObject = lodSceneObj; } } } if (levelOfDetailSceneObject == null) { lodSceneObj = root.getSceneObjectByName((currentSceneObject.getName() + TRANSFORM_SCALE_)); if ( lodSceneObj != null ) { if (lodSceneObj.getParent() == this.transformLODSceneObject) { levelOfDetailSceneObject = lodSceneObj; } } } } if ( levelOfDetailSceneObject != null) { final GVRLODGroup lodGroup = (GVRLODGroup) this.transformLODSceneObject.getComponent(GVRLODGroup.getComponentType()); lodGroup.addRange(this.getMinRange(), levelOfDetailSceneObject); this.increment(); } } }\n\n    ### Response: Add the currentSceneObject to an active Level-of-Detail.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } if (failureHandler == null) { failureUrl(loginPage + \"?error\"); } final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) { logoutConfigurer.logoutSuccessUrl(loginPage + \"?logout\"); } }\n\n    ### Response:", "ground_truth": "Updates the default values for authentication.\n\n@throws Exception", "predict": " Update the default values for authentication."}, {"ID": 108, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static public void shutdownQuietly(HttpClient http) { if (http != null) { try { http.getConnectionManager().shutdown(); } catch (Exception ignore) { // do nothing } } }\n\n    ### Response: Quitely shuts down an HttpClient instance by shutting down its connection\nmanager and ignoring any errors that occur.\n@param http The HttpClient to shutdown.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void updateAccessDefaults(B http) { if (permitAll) { PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl); } }\n\n    ### Response:", "ground_truth": "Updates the default values for access.", "predict": " Updates the access defaults for the given HTTP client instance. If the permitAll flag is set, it will call the PermitAllSupport.permitAll() method to configure the HTTP client to allow access to all URLs without authentication.\n@param http The HTTP client instance to update."}, {"ID": 109, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean containWildcard(Object value) { if (!(value instanceof String)) { return false; } String casted = (String) value; return casted.contains(LIKE_WILDCARD.toString()); }\n\n    ### Response: Check if given value contains wildcard.\n\n@param value the value\n@return Return true if argument contains {@link #LIKE_WILDCARD}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String mapPassword(Object passwordValue) { if (!(passwordValue instanceof String)) { // Assume it's binary passwordValue = new String((byte[]) passwordValue); } return (String) passwordValue; }\n\n    ### Response:", "ground_truth": "Extension point to allow customized creation of the user's password from the\nattribute stored in the directory.\n\n@param passwordValue the value of the password attribute\n@return a String representation of the password.", "predict": " Map password value to string.\n\n@param passwordValue the password value\n@return Return the mapped password value as string."}, {"ID": 110, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String findRememberMeCookieValue(HttpServletRequest request, HttpServletResponse response) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY.equals(cookie.getName())) { return cookie.getValue(); } } return null; }\n\n    ### Response: Patched version of the super.autoLogin with a time-independent equality check for the token validation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String extractRememberMeCookie(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (cookieName.equals(cookie.getName())) { return cookie.getValue(); } } return null; }\n\n    ### Response:", "ground_truth": "Locates the Spring Security remember me cookie in the request and returns its\nvalue. The cookie is searched for by name and also by matching the context path to\nthe cookie path.\n\n@param request the submitted request which is to be authenticated\n@return the cookie value (if present), null otherwise.", "predict": " Extracts the remember-me cookie from the given HTTP request.\n\n    "}, {"ID": 111, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String getBar(long percentage) { StringBuilder sb = new StringBuilder(); sb.append(percentage); sb.append(\"% [\"); for (int i = 0; i < 100; i++) { if (percentage == 100 || i < percentage - 1) { sb.append(\"=\"); } else if (i == percentage - 1) { sb.append(\">\"); } else { sb.append(\" \"); } } sb.append(\"] \"); return sb.toString(); }\n\n    ### Response: Generates the progress bar for the given percentage\n\n@param percentage the progression percentage\n\n@return the progress bar as a string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String encodeCookie(String[] cookieTokens) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cookieTokens.length; i++) { try { sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString())); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage(), e); } if (i < cookieTokens.length - 1) { sb.append(DELIMITER); } } String value = sb.toString(); sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes()))); while (sb.charAt(sb.length() - 1) == '=') { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Inverse operation of decodeCookie.\n\n@param cookieTokens the tokens to be encoded.\n@return base64 encoding of the tokens concatenated with the \":\" delimiter.", "predict": " Encodes the given cookie tokens into a base64 string and returns it.\n\n@param cookieTokens the cookie tokens to be encoded\n\n@return the base64 encoded string\n\n    "}, {"ID": 112, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addCookie(String name, String value, HttpServletResponse response) { Cookie cookie = new Cookie(name, value); cookie.setHttpOnly(httpOnly); cookie.setSecure(secure); if (StringUtils.isNotEmpty(domain)) { cookie.setDomain(domain); } if (StringUtils.isNotEmpty(path)) { cookie.setPath(path); } if (maxAge != null) { cookie.setMaxAge(maxAge); } response.addCookie(cookie); logger.debug(LOG_KEY_ADDED_COOKIE, name); }\n\n    ### Response: Add a new cookie, using the configured domain, path and max age, to the response.\n\n@param name  the name of the cookie\n@param value the value of the cookie.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) { String cookieValue = encodeCookie(tokens); Cookie cookie = new Cookie(cookieName, cookieValue); cookie.setMaxAge(maxAge); cookie.setPath(getCookiePath(request)); if (cookieDomain != null) { cookie.setDomain(cookieDomain); } if (maxAge < 1) { cookie.setVersion(1); } if (useSecureCookie == null) { cookie.setSecure(request.isSecure()); } else { cookie.setSecure(useSecureCookie); } cookie.setHttpOnly(true); response.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "Sets the cookie on the response.\n\nBy default a secure cookie will be used if the connection is secure. You can set\nthe {@code useSecureCookie} property to {@code false} to override this. If you set\nit to {@code true}, the cookie will always be flagged as secure. By default the cookie\nwill be marked as HttpOnly.\n\n@param tokens the tokens which will be encoded to make the cookie value.\n@param maxAge the value passed to {@link Cookie#setMaxAge(int)}\n@param request the request\n@param response the response to add the cookie to.", "predict": " Set a new cookie with the given name and value, and set the max age, path, domain, secure flag, and httpOnly flag.\n\n@param tokens the tokens to encode into the cookie value\n@param maxAge the maximum age of the cookie in seconds, or 0 for a session cookie\n@param request the current request\n@param response the current response"}, {"ID": 113, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object tryGet() { Object o = null; if (head != null) { o = head.getContents(); head = head.getNext(); count--; if (head == null) { tail = null; count = 0; } } return o; }\n\n    ### Response: attempt to retrieve message from queue head.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); }\n\n    ### Response:", "ground_truth": "resolve the argument to inject into the controller parameter.\n@param parameter the method parameter.\n@param bindingContext the binding context.\n@param exchange the server web exchange.\n@return the reactive mono object result.", "predict": " resolve the security context and convert it to the required type."}, {"ID": 114, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private PathMatcher.PathMatch<VirtualHost.HostEntry> mapVirtualHost(final HttpServerExchange exchange) { final String context = exchange.getRelativePath(); if(modCluster.isUseAlias()) { final String hostName = exchange.getRequestHeaders().getFirst(Headers.HOST); if (hostName != null) { // Remove the port from the host int i = hostName.indexOf(\":\"); VirtualHost host; if (i > 0) { host = hosts.get(hostName.substring(0, i)); if (host == null) { host = hosts.get(hostName); } } else { host = hosts.get(hostName); } if (host == null) { return null; } PathMatcher.PathMatch<VirtualHost.HostEntry> result = host.match(context); if (result.getValue() == null) { return null; } return result; } } else { for(Map.Entry<String, VirtualHost> host : hosts.entrySet()) { PathMatcher.PathMatch<VirtualHost.HostEntry> result = host.getValue().match(context); if (result.getValue() != null) { return result; } } } return null; }\n\n    ### Response: Map a request to virtual host.\n\n@param exchange the http exchange.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) { final String query = request.getQueryString(); if (query == null) { return null; } final String result = artifactPattern.matcher(query).replaceFirst(\"\"); if (result.length() == 0) { return null; } // strip off the trailing & only if the artifact was the first query param return result.startsWith(\"&\") ? result.substring(1) : result; }\n\n    ### Response:", "ground_truth": "If present, removes the artifactParameterName and the corresponding value from the\nquery String.\n@param request\n@return the query String minus the artifactParameterName and the corresponding\nvalue.", "predict": " Get the query string from the request and remove any artifact parameter.\n\n@param request the http request.\n@param artifactPattern the pattern for the artifact parameter.\n\n    "}, {"ID": 115, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getTargetPort() { int port = getVirtualPort(); if (NOTSET == port) { port = (isIncoming()) ? getServiceContext().getLocalPort() : getServiceContext().getRemotePort(); } return port; }\n\n    ### Response: Find the target port of the request. This checks the VirtualPort data and\nfalls back on the socket port information if need be.\n\n@return int.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getServicePort(URL casServiceUrl) { int port = casServiceUrl.getPort(); if (port == -1) { port = casServiceUrl.getDefaultPort(); } return port; }\n\n    ### Response:", "ground_truth": "", "predict": " Get the port of the CAS service from the URL. If the port is not specified in the URL, use the default port for the protocol.\n\n@param casServiceUrl URL.\n@return int."}, {"ID": 116, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public User getLoggedInUser() { User user = null; final Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null) { final Object principal = authentication.getPrincipal(); // principal can be \"anonymousUser\" (String) if (principal instanceof UserDetails) { user = userDetailsConverter.convert((UserDetails) principal); } } return user; }\n\n    ### Response: get logged in user.\n\n@return UserData or null if no one is logged in.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPrincipal() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); if (authentication == null) { log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\"); return \"\"; } Object principal = authentication.getPrincipal(); if (principal instanceof LdapUserDetails) { LdapUserDetails details = (LdapUserDetails) principal; return details.getDn(); } else if (authentication instanceof AnonymousAuthenticationToken) { if (log.isDebugEnabled()) { log.debug(\"Anonymous Authentication, returning empty String as Principal\"); } return \"\"; } else { throw new IllegalArgumentException( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\"); } }\n\n    ### Response:", "ground_truth": "Get the principals of the logged in user, in this case the distinguished name.\n\n@return the distinguished name of the logged in user.", "predict": " get principal.\n\n@return the principal of the logged in user."}, {"ID": 117, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void clearSession(HttpServletRequest req) { SecurityContextHolder.clearContext(); if (req != null) { HttpSession session = req.getSession(false); if (session != null) { session.invalidate(); } } }\n\n    ### Response: Clears the session. Deletes cookies and clears the security context.\n@param req HTTP request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, \"HttpServletRequest required\"); if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(\"Invalidating session: \" + session.getId()); session.invalidate(); } } if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } SecurityContextHolder.clearContext(); }\n\n    ### Response:", "ground_truth": "Requires the request to be passed in.\n\n@param request from which to obtain a HTTP session (cannot be null)\n@param response not used (can be null)\n@param authentication not used (can be null)", "predict": " Logs out the user by invalidating the HTTP session and clearing the security context.\n@param request HTTP request.\n@param response HTTP response.\n@param authentication Authentication object."}, {"ID": 118, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<String> getUserRoles(Subject subject) { Set<String> userRoles = null; // get roles from specified classes Set<Principal> principals = subject.getPrincipals(); if (roleClassNames != null && roleClassNames.size() > 0) { for (Principal p : principals) { if (roleClassNames.contains(p.getClass().getName())) { if (userRoles == null) userRoles = new HashSet<String>(); userRoles.add(p.getName()); } } } // get roles from specified attributes Map<String, Set<String>> attributes = SubjectUtils.getAttributes(subject); for (String key : attributes.keySet()) { if (roleAttributeNames.contains(key)) { if (userRoles == null) userRoles = new HashSet<String>(); userRoles.addAll(attributes.get(key)); } } if (userRoles == null) userRoles = Collections.emptySet(); if (logger.isDebugEnabled()) { for (String r : userRoles) { logger.debug(\"found role: {}\", r); } } return userRoles; }\n\n    ### Response: Obtains the roles for the user based on the class names and attribute\nnames provided in the web.xml file.\n\n@param subject\nthe subject returned from authentication.\n@return a set of strings that represent the users roles..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Authentication authenticate(Authentication auth) throws AuthenticationException { if (!(auth instanceof UsernamePasswordAuthenticationToken)) { return null; } UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth; Set<GrantedAuthority> authorities; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext( new InternalCallbackHandler(auth)); // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext.login(); // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet<>(); // Get the subject principals and pass them to each of the AuthorityGranters Set<Principal> principals = loginContext.getSubject().getPrincipals(); for (Principal principal : principals) { for (AuthorityGranter granter : this.authorityGranters) { Set<String> roles = granter.grant(principal); // If the granter doesn't wish to grant any authorities, it should // return null. if ((roles != null) && !roles.isEmpty()) { for (String role : roles) { authorities.add(new JaasGrantedAuthority(role, principal)); } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken( request.getPrincipal(), request.getCredentials(), new ArrayList<>(authorities), loginContext); // Publish the success event publishSuccessEvent(result); // we're done, return the token. return result; } catch (LoginException loginException) { AuthenticationException ase = this.loginExceptionResolver .resolveException(loginException); publishFailureEvent(request, ase); throw ase; } }\n\n    ### Response:", "ground_truth": "Attempts to login the user given the Authentication objects principal and\ncredential\n\n@param auth The Authentication object to be authenticated.\n\n@return The authenticated Authentication object, with it's grantedAuthorities set.\n\n@throws AuthenticationException This implementation does not handle 'locked' or\n'disabled' accounts. This method only throws a AuthenticationServiceException, with\nthe message of the LoginException that will be thrown, should the\nloginContext.login() method fail.", "predict": " Authenticates the user based on the provided authentication object.\n\n@param auth\nthe authentication object to authenticate.\n@return the authenticated token.\n\n    "}, {"ID": 119, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); Validate.notNull(className, \"className must not be null.\"); if (className.endsWith(\"[]\")) { final StringBuilder classNameBuffer = new StringBuilder(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } final String abbreviation = abbreviationMap.get(className); if (abbreviation != null) { classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; }\n\n    ### Response: Converts a class name to a JLS style class name.\n\n@param className  the class name\n@return the converted name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String buildProviderUrl(List<String> urls, String baseDn) { Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\"); Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\"); String trimmedBaseDn = baseDn.trim(); StringBuilder providerUrl = new StringBuilder(); for (String serverUrl : urls) { String trimmedUrl = serverUrl.trim(); if (\"\".equals(trimmedUrl)) { continue; } providerUrl.append(trimmedUrl); if (!trimmedUrl.endsWith(\"/\")) { providerUrl.append(\"/\"); } providerUrl.append(trimmedBaseDn); providerUrl.append(\" \"); } return providerUrl.toString(); }\n\n    ### Response:", "ground_truth": "Builds a Spring LDAP-compliant Provider URL string, i.e. a space-separated list of\nLDAP servers with their base DNs. As the base DN must be identical for all servers,\nit needs to be supplied only once.\n\n@param urls A list of string values which are LDAP server URLs. An example would be\n\n\nldap://ldap.company.com:389\n\n\n. LDAPS URLs may be used as well, given that Spring Security is able to connect to\nthe server.\n@param baseDn The common Base DN for all provided servers, e.g.\n\n\ndc=company,dc=com\n\n\n.\n@return A Spring Security/Spring LDAP-compliant Provider URL string.", "predict": " Builds a provider URL for the Java Naming and Directory Interface (JNDI) API based on a list of LDAP server URLs and a base DN.\n\n@param urls  the list of LDAP server URLs\n@param baseDn  the base DN for the LDAP server\n@return the provider URL for the JNDI API"}, {"ID": 120, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setPreferredFormats(List<String> preferredFormats) { if (preferredFormats.isEmpty()) { throw new IllegalArgumentException(\"Preferred formats list must not be empty\"); } this.preferredFormats = new ArrayList<>(preferredFormats); }\n\n    ### Response: Set preferred video formats for this driver. First formats from the list are better and will\nbe selected if available..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setContextEnvironmentProperties(Map<String, Object> environment) { Assert.notEmpty(environment, \"environment must not be empty\"); this.contextEnvironmentProperties = new Hashtable<>(environment); }\n\n    ### Response:", "ground_truth": "Allows a custom environment properties to be used to create initial LDAP context.\n\n@param environment the additional environment parameters to use when creating the LDAP Context", "predict": " Set the context environment properties for this driver. The environment properties are used to\nconfigure the driver's behavior based on the context in which it is running."}, {"ID": 121, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Observable<AdvisorListResultInner> listByDatabaseAsync(String resourceGroupName, String serverName, String databaseName) { return listByDatabaseWithServiceResponseAsync(resourceGroupName, serverName, databaseName).map(new Func1<ServiceResponse<AdvisorListResultInner>, AdvisorListResultInner>() { @Override public AdvisorListResultInner call(ServiceResponse<AdvisorListResultInner> response) { return response.body(); } }); }\n\n    ### Response: Returns a list of database advisors.\n\n@param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n@param serverName The name of the server.\n@param databaseName The name of the database.\n@throws IllegalArgumentException thrown if parameters fail the validation\n@return the observable to the AdvisorListResultInner object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String getRedirectUrl() { return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString); }\n\n    ### Response:", "ground_truth": "Indicates the URL that the user agent used for this request.\n\n@return the full URL of this request", "predict": "Returns the redirect URL for the request.\n\n@return the redirect URL for the request."}, {"ID": 122, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int doEndTag() throws JspException { try { conn.commit(); } catch (SQLException e) { throw new JspTagException( Resources.getMessage(\"TRANSACTION_COMMIT_ERROR\", e.toString()), e); } return EVAL_PAGE; }\n\n    ### Response: Commits the transaction..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int doEndTag() throws JspException { try { if (!authorized && TagLibConfig.isUiSecurityDisabled()) { pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix()); } } catch (IOException e) { throw new JspException(e); } return EVAL_PAGE; }\n\n    ### Response:", "ground_truth": "Default processing of the end tag returning EVAL_PAGE.\n\n@return EVAL_PAGE\n@see Tag#doEndTag()", "predict": " Checks if the user is authorized and if the UI security is disabled. If not, it writes the secured UI suffix to the output stream."}, {"ID": 123, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initInternalListener(Context context) { mInternalListener = new PlaybackListener() { @Override protected void onPlay(SoundCloudTrack track) { super.onPlay(track); mState = STATE_PLAYING; for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onPlayerPlay(track, mPlayerPlaylist.getCurrentTrackIndex()); } } @Override protected void onPause() { super.onPause(); mState = STATE_PAUSED; for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onPlayerPause(); } } @Override protected void onPlayerDestroyed() { super.onPlayerDestroyed(); mState = STATE_STOPPED; for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onPlayerDestroyed(); } if (mDestroyDelayed) { CheerleaderPlayer.this.destroy(); } } @Override protected void onSeekTo(int milli) { super.onSeekTo(milli); for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onPlayerSeekTo(milli); } } @Override protected void onBufferingStarted() { super.onBufferingStarted(); for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onBufferingStarted(); } } @Override protected void onBufferingEnded() { super.onBufferingEnded(); for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onBufferingEnded(); } } @Override protected void onProgressChanged(int milli) { super.onProgressChanged(milli); for (CheerleaderPlayerListener listener : mCheerleaderPlayerListeners) { listener.onProgressChanged(milli); } } }; PlaybackService.registerListener(context, mInternalListener); }\n\n    ### Response: Initialize the internal listener.\n\n@param context context used to register the internal listener..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void initUserDetailsService() throws Exception { for (UserDetailsBuilder userBuilder : userBuilders) { getUserDetailsService().createUser(userBuilder.build()); } for (UserDetails userDetails : this.users) { getUserDetailsService().createUser(userDetails); } }\n\n    ### Response:", "ground_truth": "Populates the users that have been added.\n\n@throws Exception", "predict": " Initializes the user details service.\n\n@throws Exception if there is an error initializing the user details service."}, {"ID": 124, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initAspectRuleRegistry(ContextRuleAssistant assistant) { AspectRuleRegistry aspectRuleRegistry = assistant.getAspectRuleRegistry(); BeanRuleRegistry beanRuleRegistry = assistant.getBeanRuleRegistry(); TransletRuleRegistry transletRuleRegistry = assistant.getTransletRuleRegistry(); AspectAdviceRulePostRegister sessionScopeAspectAdviceRulePostRegister = new AspectAdviceRulePostRegister(); for (AspectRule aspectRule : aspectRuleRegistry.getAspectRules()) { PointcutRule pointcutRule = aspectRule.getPointcutRule(); if (pointcutRule != null) { Pointcut pointcut = PointcutFactory.createPointcut(pointcutRule); aspectRule.setPointcut(pointcut); } if (aspectRule.getJoinpointTargetType() == JoinpointTargetType.SESSION) { sessionScopeAspectAdviceRulePostRegister.register(aspectRule); } } AspectAdviceRulePreRegister preRegister = new AspectAdviceRulePreRegister(aspectRuleRegistry); preRegister.register(beanRuleRegistry); preRegister.register(transletRuleRegistry); // check invalid pointcut pattern boolean pointcutPatternVerifiable = assistant.isPointcutPatternVerifiable(); if (pointcutPatternVerifiable || log.isDebugEnabled()) { int invalidPointcutPatterns = 0; for (AspectRule aspectRule : aspectRuleRegistry.getAspectRules()) { Pointcut pointcut = aspectRule.getPointcut(); if (pointcut != null) { List<PointcutPatternRule> pointcutPatternRuleList = pointcut.getPointcutPatternRuleList(); if (pointcutPatternRuleList != null) { for (PointcutPatternRule ppr : pointcutPatternRuleList) { if (ppr.getBeanIdPattern() != null && ppr.getMatchedBeanCount() == 0) { invalidPointcutPatterns++; String msg = \"No beans matching to '\" + ppr.getBeanIdPattern() + \"'; aspectRule \" + aspectRule; if (pointcutPatternVerifiable) { log.error(msg); } else { log.debug(msg); } } if (ppr.getClassNamePattern() != null && ppr.getMatchedClassCount() == 0) { invalidPointcutPatterns++; String msg = \"No beans matching to '@class:\" + ppr.getClassNamePattern() + \"'; aspectRule \" + aspectRule; if (pointcutPatternVerifiable) { log.error(msg); } else { log.debug(msg); } } if (ppr.getMethodNamePattern() != null && ppr.getMatchedMethodCount() == 0) { invalidPointcutPatterns++; String msg = \"No beans have methods matching to '^\" + ppr.getMethodNamePattern() + \"'; aspectRule \" + aspectRule; if (pointcutPatternVerifiable) { log.error(msg); } else { log.debug(msg); } } } } } } if (invalidPointcutPatterns > 0) { String msg = \"Invalid pointcut detected: \" + invalidPointcutPatterns + \"; Please check the logs for more information\"; if (pointcutPatternVerifiable) { log.error(msg); throw new InvalidPointcutPatternException(msg); } else { log.debug(msg); } } } AspectAdviceRuleRegistry sessionScopeAarr = sessionScopeAspectAdviceRulePostRegister.getAspectAdviceRuleRegistry(); if (sessionScopeAarr != null) { aspectRuleRegistry.setSessionAspectAdviceRuleRegistry(sessionScopeAarr); } }\n\n    ### Response: Initialize the aspect rule registry.\n\n@param assistant the context rule assistant.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private UserDetailsService getUserDetailsService() { Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class); if (beans.size() == 0) { beans = getBeansOfType(UserDetailsService.class); } if (beans.size() == 0) { throw new ApplicationContextException(\"No UserDetailsService registered.\"); } else if (beans.size() > 1) { throw new ApplicationContextException( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\"); } return (UserDetailsService) beans.values().toArray()[0]; }\n\n    ### Response:", "ground_truth": "Obtains a user details service for use in RememberMeServices etc. Will return a\ncaching version if available so should not be used for beans which need to separate\nthe two.", "predict": " Get the user details service.\n\n@return the user details service."}, {"ID": 125, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<String, Object> getConfigParams(Class<?> clazz) { Map<String, Object> params = new HashMap<>(); for (Field field : clazz.getDeclaredFields()) { if (Modifier.isStatic(field.getModifiers()) && field.getName().endsWith(\"_CONFIG\")) { try { String key = field.get(null).toString(); String value = SpringUtil.getProperty(\"org.carewebframework.messaging.kafka.\" + key); if (value != null) { params.put(key, value); } } catch (Exception e) {} } } return params; }\n\n    ### Response: A bit of a hack to return configuration parameters from the Spring property store as a map,\nwhich is required to initialize Kafka consumers and producers. Uses reflection on the\nspecified class to enumerate static fields with a name ending in \"_CONFIG\". By Kafka\nconvention, these fields contain the names of configuration parameters.\n\n@param clazz Class defining configuration parameters as static fields.\n@return A map of configuration parameters with their values from the Spring property store..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) { String codeVerifier = this.codeVerifierGenerator.generateKey(); attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier); try { String codeChallenge = createCodeChallenge(codeVerifier); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\"); } catch (NoSuchAlgorithmException e) { additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier); } }\n\n    ### Response:", "ground_truth": "Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests\n\n@param attributes where {@link PkceParameterNames#CODE_VERIFIER} is stored for the token request\n@param additionalParameters where {@link PkceParameterNames#CODE_CHALLENGE} and, usually,\n{@link PkceParameterNames#CODE_CHALLENGE_METHOD} are added to be used in the authorization request.\n\n@since 5.2\n@see 1.1.  Protocol Flow\n@see 4.1.  Client Creates a Code Verifier\n@see 4.2.  Client Creates the Code Challenge", "predict": " Adds PKCE parameters to the provided attributes map and additional parameters map.\n\n@param attributes Map to which PKCE parameters should be added.\n@param additionalParameters Map to which additional parameters should be added.\n\n    "}, {"ID": 126, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { val accessTokenRequest = isAccessTokenRequest(request, response); if (!accessTokenRequest) { val extractor = extractAccessTokenGrantRequest(request); if (extractor.isPresent()) { val ext = extractor.get(); return ext.requestMustBeAuthenticated(); } } else { val extractor = extractAccessTokenGrantRequest(request); if (extractor.isPresent()) { val ext = extractor.get(); return ext.getResponseType() != OAuth20ResponseTypes.DEVICE_CODE; } } return false; }\n\n    ### Response: Request requires authentication.\n\n@param request  the request\n@param response the response\n@return true/false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { final boolean serviceTicketRequest = serviceTicketRequest(request, response); final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request)); if (logger.isDebugEnabled()) { logger.debug(\"requiresAuthentication = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Overridden to provide proxying capabilities.", "predict": " Checks if the request requires authentication.\n\n@param request  the request\n@param response the response\n@return true/false."}, {"ID": 127, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { val accessTokenRequest = isAccessTokenRequest(request, response); if (!accessTokenRequest) { val extractor = extractAccessTokenGrantRequest(request); if (extractor.isPresent()) { val ext = extractor.get(); return ext.requestMustBeAuthenticated(); } } else { val extractor = extractAccessTokenGrantRequest(request); if (extractor.isPresent()) { val ext = extractor.get(); return ext.getResponseType() != OAuth20ResponseTypes.DEVICE_CODE; } } return false; }\n\n    ### Response: Request requires authentication.\n\n@param request  the request\n@param response the response\n@return true/false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to process a service ticket. This method exists\nfor readability.\n@param request\n@param response\n@return", "predict": " Service ticket request.\n\n@param request  the request\n@param response the response\n@return true/false."}, {"ID": 128, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean stringEquals(@Nullable final String pStr1, @Nullable final String pStr2, final boolean pCaseSensitive) { boolean result = false; if (pStr1 == null && pStr2 == null) { result = true; } else if (pStr1 != null) { if (pCaseSensitive) { result = pStr1.equals(pStr2); } else { result = pStr1.equalsIgnoreCase(pStr2); } } return result; }\n\n    ### Response: Determine the equality of two Strings, optionally ignoring case.\n\n@param pStr1 the first String\n@param pStr2 the second String\n@param pCaseSensitive if the comparison should be case sensitive\n@return true if the String are equal, false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { if (serviceTicketRequest) { return false; } final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated(); if (logger.isDebugEnabled()) { logger.debug(\"proxyTicketRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to process a proxy ticket.\n@param request\n@return", "predict": " Determine if a proxy ticket request should be processed.\n\n@param serviceTicketRequest true if the request is for a service ticket\n@param request the current HTTP request\n@return true if the proxy ticket request should be processed, false otherwise."}, {"ID": 129, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean currentUserIsAuthenticated() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); return authentication != null && authentication.isAuthenticated() && !currentUserIsAnonymous(); }\n\n    ### Response: Returns whether the current user is authenticated and not the anonymous user.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean authenticated() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken); }\n\n    ### Response:", "ground_truth": "Determines if a user is already authenticated.\n@return", "predict": " Returns whether the current user is authenticated and not the anonymous user."}, {"ID": 130, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final boolean callbackCreateOptionsMenu(Menu menu) { if (DEBUG) Log.d(TAG, \"[callbackCreateOptionsMenu] menu: \" + menu); boolean result = true; if (mActivity instanceof OnCreatePanelMenuListener) { OnCreatePanelMenuListener listener = (OnCreatePanelMenuListener)mActivity; result = listener.onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, menu); } else if (mActivity instanceof OnCreateOptionsMenuListener) { OnCreateOptionsMenuListener listener = (OnCreateOptionsMenuListener)mActivity; result = listener.onCreateOptionsMenu(menu); } if (DEBUG) Log.d(TAG, \"[callbackCreateOptionsMenu] returning \" + result); return result; }\n\n    ### Response: Internal method to trigger the menu creation process.\n\n@return {@code true} if menu creation should proceed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to be processed as the proxy receptor.\n@param request\n@return", "predict": "Internal method to check if the given request should be handled by the proxy receptor.\n\n@param request the request to check\n@return {@code true} if the request should be handled by the proxy receptor, {@code false} otherwise."}, {"ID": 131, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void putAuthentication(final Authentication authentication, final RequestContext ctx) { ctx.getConversationScope().put(PARAMETER_AUTHENTICATION, authentication); }\n\n    ### Response: Put authentication into conversation scope.\n\n@param authentication the authentication\n@param ctx            the ctx.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MethodSecurityExpressionOperations createSecurityExpressionRoot( Authentication authentication, MethodInvocation invocation) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot( authentication); root.setThis(invocation.getThis()); root.setPermissionEvaluator(getPermissionEvaluator()); root.setTrustResolver(getTrustResolver()); root.setRoleHierarchy(getRoleHierarchy()); root.setDefaultRolePrefix(getDefaultRolePrefix()); return root; }\n\n    ### Response:", "ground_truth": "Creates the root object for expression evaluation.", "predict": " Create a security expression root for the given authentication and method invocation.\n\n@param authentication the authentication\n@param invocation     the method invocation\n@return the security expression root\n\n    "}, {"ID": 132, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private CompletableFuture<IteratorBatch<T>> fetch(int position) { return openFuture.thenCompose(initialBatch -> { if (!initialBatch.complete()) { return client.applyOn(partitionId, service -> nextFunction.next(service, initialBatch.id(), position)) .thenCompose(nextBatch -> { if (nextBatch == null) { return close().thenApply(v -> null); } return CompletableFuture.completedFuture(nextBatch); }); } return CompletableFuture.completedFuture(null); }); }\n\n    ### Response: Fetches the next batch of entries from the cluster.\n\n@param position the position from which to fetch the next batch\n@return the next batch of entries from the cluster.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Mono<JWKSet> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n\n    ### Response:", "ground_truth": "Updates the cached JWK set from the configured URL.\n\n@return The updated JWK set.\n\n@throws RemoteKeySourceException If JWK retrieval failed.", "predict": " Retrieves the JSON Web Key Set (JWK Set) from the specified URL and parses it into a JWK Set object.\n\n@return the JWK Set object parsed from the JSON Web Key Set retrieved from the specified URL."}, {"ID": 133, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode(String value) { if (value == null) { return value; } try { value = URLEncoder.encode(value, Constants.UTF_8); } catch (UnsupportedEncodingException e) { // Do nothing - UTF-8 should always be supported } return value; }\n\n    ### Response: Encodes the given string using URLEncoder and UTF-8 encoding.\n\n@param value\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String utf8UrlEncode(String value) { try { return URLEncoder.encode(value, \"UTF-8\"); } catch (UnsupportedEncodingException e) { Error err = new AssertionError( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\"); err.initCause(e); throw err; } }\n\n    ### Response:", "ground_truth": "Performs URL encoding with UTF-8\n\n@param value the value to URL encode\n@return the encoded value", "predict": " Encodes the given string using URLEncoder and UTF-8 encoding.\n\n@param value\n@return."}, {"ID": 134, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails buildDetails(PortletRequest context) { Collection<? extends GrantedAuthority> userGas = buildGrantedAuthorities(context); PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails(context, userGas); return result; }\n\n    ### Response: Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)\n@param context a {@link javax.portlet.PortletRequest} object.\n@return a {@link org.jasig.springframework.security.portlet.authentication.PreAuthenticatedGrantedAuthoritiesPortletAuthenticationDetails} object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() { List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser(); Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper .getGrantedAuthorities(webSphereGroups); if (logger.isDebugEnabled()) { logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas); } return userGas; }\n\n    ### Response:", "ground_truth": "Get a list of Granted Authorities based on the current user's WebSphere groups.\n\n@return authorities mapped from the user's WebSphere groups.", "predict": " Retrieves the WebSphere groups for the current user and maps them to granted authorities.\n\n@see org.jasig.springframework.security.portlet.authentication.WebSphereGroups2GrantedAuthoritiesMapper#getGrantedAuthorities(java.util.List)\n@param webSphereGroups a {@link java.util.List} object.\n@return a {@link java.util.Collection} object.\n\n    "}, {"ID": 135, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String determineIdentity(final OpenIdService service, final Assertion assertion) { if (assertion != null && OpenIdProtocolConstants.OPENID_IDENTIFIERSELECT.equals(service.getIdentity())) { return this.openIdPrefixUrl + '/' + assertion.getPrimaryAuthentication().getPrincipal().getId(); } return service.getIdentity(); }\n\n    ### Response: Determine identity.\n\n@param service   the service\n@param assertion the assertion\n@return the string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected UserDetails loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken( assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); }\n\n    ### Response:", "ground_truth": "Template method for retrieving the UserDetails based on the assertion. Default is\nto call configured userDetailsService and pass the username. Deployers can override\nthis method and retrieve the user based on any criteria they desire.\n\n@param assertion The CAS Assertion.\n@return the UserDetails.", "predict": " Load user by assertion.\n\n@param assertion the assertion\n@return the user details."}, {"ID": 136, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Principal getPrincipal() { final Object principal = requestContext.getProperty(\"Principal\"); if (principal != null) { return (Principal) principal; } else { return null; } }\n\n    ### Response: Returns the principal for who initiated the request.\n@return a Principal object\n@see alpine.model.ApiKey\n@see alpine.model.LdapUser\n@since 1.0.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = wasHelper.getCurrentUserName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated WebSphere principal: \" + principal); } return principal; }\n\n    ### Response:", "ground_truth": "Return the WebSphere user name.", "predict": " Returns the pre-authenticated principal for the current request.\n@param httpRequest the current HTTP request\n@return the pre-authenticated principal for the current request\n@since 1.0.0.\n\n    "}, {"ID": 137, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] join(List<byte[]> arrays) { int maxlength = 0; for (byte[] array : arrays) { maxlength += array.length; } byte[] rs = new byte[maxlength]; int pos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, rs, pos, array.length); pos += array.length; } return rs; }\n\n    ### Response: join multi array\n\n@param arrays\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] concatenate(byte[]... arrays) { int length = 0; for (byte[] array : arrays) { length += array.length; } byte[] newArray = new byte[length]; int destPos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, newArray, destPos, array.length); destPos += array.length; } return newArray; }\n\n    ### Response:", "ground_truth": "Combine the individual byte arrays into one array.", "predict": " concatenate multi array\n\n@param arrays\n@return."}, {"ID": 138, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) { int newSize = endIndexExclusive - startIndexInclusive; Class<?> type = array.getClass().getComponentType(); if (newSize <= 0) { return (Object[]) Array.newInstance(type, 0); } Object[] subarray = (Object[]) Array.newInstance(type, newSize); System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); return subarray; }\n\n    ### Response: originally licensed under ASL 2.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] subArray(byte[] array, int beginIndex, int endIndex) { int length = endIndex - beginIndex; byte[] subarray = new byte[length]; System.arraycopy(array, beginIndex, subarray, 0, length); return subarray; }\n\n    ### Response:", "ground_truth": "Extract a sub array of bytes out of the byte array.\n@param array the byte array to extract from\n@param beginIndex the beginning index of the sub array, inclusive\n@param endIndex the ending index of the sub array, exclusive", "predict": " originally licensed under ASL 2.0."}, {"ID": 139, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static List<XsdAttribute> filterAttributes(List<XsdAttribute> attributes) { List<String> attributeNames = attributes.stream() .map(XsdNamedElements::getName) .distinct() .collect(Collectors.toList()); List<XsdAttribute> filteredAttributes = new ArrayList<>(); attributeNames.forEach(attributeName -> { for (XsdAttribute attribute : attributes) { if (attribute.getName().equals(attributeName)){ filteredAttributes.add(attribute); break; } } }); return filteredAttributes; }\n\n    ### Response: Removes duplicate attribute names.\n@param attributes The {@link List} of {@link XsdAttribute} objects.\n@return The distinct {@link List} of {@link XsdAttribute}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { ArrayList<GrantedAuthority> gaList = new ArrayList<>(); for (String attribute : attributes) { Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap .get(attribute); if (c != null) { gaList.addAll(c); } } gaList.trimToSize(); return gaList; }\n\n    ### Response:", "ground_truth": "Map the given array of attributes to Spring Security GrantedAuthorities.", "predict": " Retrieves the granted authorities for the given attributes.\n@param attributes The collection of attributes.\n@return The list of granted authorities."}, {"ID": 140, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, String> serialize(Map<String, Object> map, String prefix) { if (map == null || map.isEmpty()) { return Collections.emptyMap(); } Map<String, String> flattened = flatten(map, new HashMap<String, String>(), new ArrayList<String>()); Map<String, String> result = new HashMap<>(); for (Map.Entry<String, String> entry : flattened.entrySet()) { result.put(prefix + \".\" + entry.getKey(), entry.getValue()); } return result; }\n\n    ### Response: Flatten a Map of String, Object into a Map of String, String where keys are '.' separated\nand prepends a key.\n\n@param map map to transform\n@param prefix key to prepend\n@return flattened map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) { Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>( orgMap.size()); for (Map.Entry<?, ?> entry : orgMap.entrySet()) { Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\"); result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue())); } return result; }\n\n    ### Response:", "ground_truth": "Preprocess the given map to convert all the values to GrantedAuthority collections\n\n@param orgMap The map to process\n@return the processed Map", "predict": " Preprocess a Map of any type to a Map of String, Collection<GrantedAuthority> where the key is cast to String and the value is converted to a Collection of GrantedAuthority.\n\n@param orgMap map to preprocess\n@return preprocessed map."}, {"ID": 141, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<GrantedAuthority> transformToSimpleAuthorities(Set<String> strAuthorities, boolean appendRolePrefix) { if (null != strAuthorities) { Collection<GrantedAuthority> authorities = new HashSet<>(strAuthorities.size()); for (String authority : strAuthorities) { if (!StringUtils.isEmpty(authority)) { String role = authority.trim().toUpperCase(Locale.ENGLISH); if (appendRolePrefix) { authorities.add(new SimpleGrantedAuthority(getRolePrefix() + role)); } else { authorities.add(new SimpleGrantedAuthority(role)); } } } return authorities; } return Collections.emptyList(); }\n\n    ### Response: transforms all authorities to upper case and append the prefix if appendRolePrefix = true\n\n@param strAuthorities\n@param appendRolePrefix\n@return Empty collection or collection of {@link SimpleGrantedAuthority}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) { Collection<GrantedAuthority> result = new ArrayList<>(); addGrantedAuthorityCollection(result, value); return result; }\n\n    ### Response:", "ground_truth": "Convert the given value to a collection of Granted Authorities\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " Returns a collection of granted authorities based on the input object. The input object can be a collection of strings, a collection of GrantedAuthority objects, or a single string or GrantedAuthority object. If the input object is a collection of strings, each string is converted to a SimpleGrantedAuthority object and added to the result collection. If the input object is a collection of GrantedAuthority objects, each object is added to the result collection. If the input object is a single string or GrantedAuthority object, it is added to the result collection as a single object."}, {"ID": 142, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static TypedConstant getConstant(Object value) { if (value == null) { return CstKnownNull.THE_ONE; } else if (value instanceof Boolean) { return CstBoolean.make((Boolean) value); } else if (value instanceof Byte) { return CstByte.make((Byte) value); } else if (value instanceof Character) { return CstChar.make((Character) value); } else if (value instanceof Double) { return CstDouble.make(Double.doubleToLongBits((Double) value)); } else if (value instanceof Float) { return CstFloat.make(Float.floatToIntBits((Float) value)); } else if (value instanceof Integer) { return CstInteger.make((Integer) value); } else if (value instanceof Long) { return CstLong.make((Long) value); } else if (value instanceof Short) { return CstShort.make((Short) value); } else if (value instanceof String) { return new CstString((String) value); } else if (value instanceof Class) { return new CstType(TypeId.get((Class<?>) value).ropType); } else if (value instanceof TypeId) { return new CstType(((TypeId) value).ropType); } else { throw new UnsupportedOperationException(\"Not a constant: \" + value); } }\n\n    ### Response: Returns a rop constant for the specified value.\n\n@param value null, a boxed primitive, String, Class, or TypeId..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) { if (value == null) { return; } if (value instanceof Collection<?>) { addGrantedAuthorityCollection(result, (Collection<?>) value); } else if (value instanceof Object[]) { addGrantedAuthorityCollection(result, (Object[]) value); } else if (value instanceof String) { addGrantedAuthorityCollection(result, (String) value); } else if (value instanceof GrantedAuthority) { result.add((GrantedAuthority) value); } else { throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Convert the given value to a collection of Granted Authorities, adding the result\nto the given result collection.\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " Adds the specified value to the result collection, if it is a granted authority.\n\n@param result the collection to add the granted authority to.\n@param value the value to add to the collection. Can be null, a collection, an array, a string, or a granted authority."}, {"ID": 143, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Principal getPrincipal() { final Object principal = requestContext.getProperty(\"Principal\"); if (principal != null) { return (Principal) principal; } else { return null; } }\n\n    ### Response: Returns the principal for who initiated the request.\n@return a Principal object\n@see alpine.model.ApiKey\n@see alpine.model.LdapUser\n@since 1.0.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest .getUserPrincipal().getName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated J2EE principal: \" + principal); } return principal; }\n\n    ### Response:", "ground_truth": "Return the J2EE user name.", "predict": " Returns the pre-authenticated principal for the given HTTP request.\n@param httpRequest the HTTP request\n@return the pre-authenticated principal or null if not available\n@since 1.0.0.\n\n    "}, {"ID": 144, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <C extends Capability> C getCapability(Class<C> capabilityType) { if (capabilityType.isInstance(this)) { return (C) this; } return null; }\n\n    ### Response: Default implementation checks if Repository implements Capability\ninterface, and if so, returns the Repository..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); }\n\n    ### Response:", "ground_truth": "Gets a shared Object. Note that object heirarchies are not considered.\n\n@param sharedType the type of the shared Object\n@return the shared Object or null if it is not found", "predict": " Retrieves a shared object of the specified type from the repository. If the shared object does not exist, returns null."}, {"ID": 145, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WebReply getHTTPSRedirectWebReply(HttpServletRequest req) { Integer httpsPort = (Integer) SRTServletRequestUtils.getPrivateAttribute(req, \"SecurityRedirectPort\"); if (httpsPort == null) { Tr.error(tc, \"SSL_PORT_IS_NULL\"); // return a 403 if we don't know what the port is return new DenyReply(\"Resource must be accessed with a secure connection try again using an HTTPS connection.\"); } URL originalURL = null; String urlString = null; try { urlString = req.getRequestURL().toString(); originalURL = new URL(urlString); } catch (MalformedURLException e) { Tr.error(tc, \"SSL_REQ_URL_MALFORMED_EXCEPTION\", urlString); // return a 403 if we can't construct the redirect URL return new DenyReply(\"Resource must be accessed with a secure connection try again using an HTTPS connection.\"); } String queryString = req.getQueryString(); try { URL redirectURL = new URL(\"https\", originalURL.getHost(), httpsPort, originalURL.getPath() + (queryString == null ? \"\" : \"?\" + queryString)); //don't add cookies during the redirect as this results in duplicated and incomplete //cookies on the client side return new RedirectReply(redirectURL.toString(), null); } catch (MalformedURLException e) { Tr.error(tc, \"SSL_REQ_URL_MALFORMED_EXCEPTION\", \"https\" + originalURL.getHost() + httpsPort + originalURL.getPath() + (queryString == null ? \"\" : \"?\" + queryString)); // return a 403 if we can't construct the redirect URL return new DenyReply(\"Resource must be accessed with a secure connection try again using an HTTPS connection.\"); } }\n\n    ### Response: Get the new URL for the redirect which contains the https port.\n\n@param req\n@return WebReply to the redirect URL, or a 403 is any unexpected behaviour occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException { int serverPort = portResolver.getServerPort(request); Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort)); if (httpsPort != null) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder(); urlBuilder.setScheme(\"https\"); urlBuilder.setServerName(request.getServerName()); urlBuilder.setPort(httpsPort.intValue()); urlBuilder.setContextPath(request.getContextPath()); urlBuilder.setServletPath(request.getServletPath()); urlBuilder.setPathInfo(request.getPathInfo()); urlBuilder.setQuery(request.getQueryString()); return urlBuilder.getUrl(); } // Fall through to server-side forward with warning message logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort); return null; }\n\n    ### Response:", "ground_truth": "Builds a URL to redirect the supplied request to HTTPS. Used to redirect the\ncurrent request to HTTPS, before doing a forward to the login page.", "predict": " Build the HTTPS redirect URL for the given request.\n\n@param request\n@return the HTTPS redirect URL, or null if no mapping found.\n\n    "}, {"ID": 146, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object next() { if (tc.isEntryEnabled()) { SibTr.entry(tc, \"next\"); } Object result; if (hasNext()) { AnycastInputHandler aih = (AnycastInputHandler) anycastIHIterator.next(); result = aih.getControlAdapter(); } else { result = null; } if (tc.isEntryEnabled()) { SibTr.exit(tc, \"next\", result); } return result; }\n\n    ### Response: This method returns the attached remote subscriber control or null if there isn't one.\n\n@return SIMPAttachedRemoteSubscriberControl\n\n@see java.util.Iterator#next().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); }\n\n    ### Response:", "ground_truth": "Method that is suitable for user with traditional AspectJ-code aspects.\n\n@param jp The AspectJ joint point being invoked which requires a security decision\n@param advisorProceed the advice-defined anonymous class that implements\n{@code AspectJCallback} containing a simple {@code return proceed();} statement\n\n@return The returned value from the method invocation", "predict": " This method is used to invoke the proceed method of the AspectJCallback object. It also handles the before and after invocation of the intercepted method.\n\n@param jp The JoinPoint object representing the intercepted method call.\n@param advisorProceed The AspectJCallback object that contains the proceed method to be invoked.\n@return The result of the proceed method invocation."}, {"ID": 147, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Class<?> getFieldRole(Field field, Requirement requirement) { Class<?> role; // Handle case of list or map if (isDependencyOfListType(field.getType())) { role = getGenericRole(field); } else { role = field.getType(); } return role; }\n\n    ### Response: Extract component role from the field to inject.\n\n@param field the field to inject\n@param requirement the Requirement attribute\n@return the role of the field to inject.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String hasRole(String role) { Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\"); return \"ROLE_\" + role; }\n\n    ### Response:", "ground_truth": "Creates a String for specifying a user requires a role.\n\n@param role the role that should be required which is prepended with ROLE_\nautomatically (i.e. USER, ADMIN, etc). It should not start with ROLE_\n@return the {@link ConfigAttribute} expressed as a String", "predict": " Check if the given role starts with \"ROLE_\" and prepend it if necessary.\n\n@param role the role to check\n@return the role with \"ROLE_\" prepended if necessary\n@throws IllegalArgumentException if the role starts with \"ROLE_\""}, {"ID": 148, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toRole(Object oRoles) throws PageException { if (oRoles instanceof String) { oRoles = ListUtil.listToArrayRemoveEmpty(oRoles.toString(), \",\"); } if (oRoles instanceof Array) { Array arrRoles = (Array) oRoles; String[] roles = new String[arrRoles.size()]; for (int i = 0; i < roles.length; i++) { roles[i] = Caster.toString(arrRoles.get(i + 1, \"\")); } return roles; } throw new ApplicationException(\"invalid roles definition for tag loginuser\"); }\n\n    ### Response: convert a Object to a String Array of Roles\n\n@param oRoles\n@return roles\n@throws PageException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String[] hasAnyRole(String... roles) { for (int i = 0; i < roles.length; i++) { roles[i] = \"ROLE_\" + roles[i]; } return roles; }\n\n    ### Response:", "ground_truth": "Creates a String for specifying that a user requires one of many roles.\n\n@param roles the roles that the user should have at least one of (i.e. ADMIN, USER,\netc). Each role should not start with ROLE_ since it is automatically prepended\nalready.\n@return the {@link ConfigAttribute} expressed as a String", "predict": " add the prefix \"ROLE_\" to each role in the array\n\n@param roles\n@return roles with prefix \"ROLE_\"\n\n    "}, {"ID": 149, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getToken(String inString, int index) throws Timecode.TimecodeException { inString = inString.trim(); String valid = \"0123456789\"; String token = \"\"; int count = 0; for (int i = 0; i < inString.length(); i++) { char current = inString.charAt(i); if (valid.indexOf(current) > -1) { token += current; } else { count++; if (count > index) break; // Found the token. token = \"\"; // Start reading the next token } } if (count < index || token.equals(\"\")) throw new Timecode.TimecodeException(\"Malformed timecode '\" + inString + \"', can't get index=\" + index); try { return Integer.parseInt(token); } catch (NumberFormatException ex) { throw new Timecode.TimecodeException(\"Malformed timecode '\" + inString + \"', '\" + token + \"' is not an integer\"); } }\n\n    ### Response: Breaks a string on any non-numeric character and returns the index token, zero indexed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { if (cookieTokens.length != 2) { throw new InvalidCookieException(\"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\"); } final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException( \"No persistent token found for series id: \" + presentedSeries); } // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( \"PersistentTokenBasedRememberMeServices.cookieStolen\", \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\")); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System .currentTimeMillis()) { throw new RememberMeAuthenticationException(\"Remember-me login has expired\"); } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) { logger.debug(\"Refreshing persistent login token for user '\" + token.getUsername() + \"', series '\" + token.getSeries() + \"'\"); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try { tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); } catch (Exception e) { logger.error(\"Failed to update token: \", e); throw new RememberMeAuthenticationException( \"Autologin failed due to data access problem\"); } return getUserDetailsService().loadUserByUsername(token.getUsername()); }\n\n    ### Response:", "ground_truth": "Locates the presented cookie data in the token repository, using the series id. If\nthe data compares successfully with that in the persistent store, a new token is\ngenerated and stored with the same series. The corresponding cookie value is set on\nthe response.\n\n@param cookieTokens the series and token values\n\n@throws RememberMeAuthenticationException if there is no stored token corresponding\nto the submitted cookie, or if the token in the persistent store has expired.\n@throws InvalidCookieException if the cookie doesn't have two tokens as expected.\n@throws CookieTheftException if a presented series value is found, but the stored\ntoken is different from the one presented.", "predict": " Processes the autologin cookie and returns the user details.\n\n    "}, {"ID": 150, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String requestedPath = \"\".equals(jawrConfig.getServletMapping()) ? request.getServletPath() : request.getPathInfo(); processRequest(requestedPath, request, response); } catch (Exception e) { if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"ServletException : \", e); } throw new ServletException(e); } }\n\n    ### Response: Handles a resource request by getting the requested path from the request\nobject and invoking processRequest.\n\n@param request\nthe request\n@param response\nthe response\n@throws ServletException\nif a servlet exception occurs\n@throws IOException\nif an IO exception occurs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); logger.debug(\"Creating new persistent login for user \" + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try { tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } catch (Exception e) { logger.error(\"Failed to save persistent token \", e); } }\n\n    ### Response:", "ground_truth": "Creates a new persistent login token with a new series number, stores the data in\nthe persistent token repository and adds the corresponding cookie to the response.", "predict": " Handles a successful login by creating a new persistent login for the user.\n\n@param request\nthe request\n@param response\nthe response\n@param successfulAuthentication\nthe successful authentication object\n\n    "}, {"ID": 151, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Properties loadProperties(Resource resource, String filename) throws IOException { InputStream is = resource.getInputStream(); Properties props = new Properties(); try { if (resource.getFilename().endsWith(XML_SUFFIX)) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.loadFromXml(props, is); } else { String encoding = null; if (this.fileEncodings != null) { encoding = this.fileEncodings.getProperty(filename); } if (encoding == null) { encoding = this.defaultEncoding; } if (encoding != null) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\"); } this.propertiesPersister.load(props, new InputStreamReader(is, encoding)); } else { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.load(props, is); } } return props; } finally { is.close(); } }\n\n    ### Response: Load the properties from the given resource.\n@param resource the resource to load from\n@param filename the original bundle filename (basename + Locale)\n@return the populated Properties instance\n@throws IOException if properties loading failed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest; String username = request.getParameter(this.usernameParameter); if (username == null) { username = \"\"; } if (this.logger.isDebugEnabled()) { this.logger.debug(\"Attempt to switch to user [\" + username + \"]\"); } UserDetails targetUser = this.userDetailsService.loadUserByUsername(username); this.userDetailsChecker.check(targetUser); // OK, create the switch user token targetUserRequest = createSwitchUserToken(request, targetUser); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\"); } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser)); } return targetUserRequest; }\n\n    ### Response:", "ground_truth": "Attempt to switch to another user. If the user does not exist or is not active,\nreturn null.\n\n@return The new Authentication request if successfully switched to\nanother user, null otherwise.\n\n@throws UsernameNotFoundException If the target user is not found.\n@throws LockedException if the account is locked.\n@throws DisabledException If the target user is disabled.\n@throws AccountExpiredException If the target user account is expired.\n@throws CredentialsExpiredException If the target user credentials are expired.", "predict": " Attempt to switch the current user to the user identified by the given username parameter.\n@param request the current HTTP request\n@return the Authentication token for the target user, or null if the switch is not allowed\n@throws AuthenticationException if the switch failed due to an authentication error\n\n    "}, {"ID": 152, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public User getLoggedInUser() { User user = null; final Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null) { final Object principal = authentication.getPrincipal(); // principal can be \"anonymousUser\" (String) if (principal instanceof UserDetails) { user = userDetailsConverter.convert((UserDetails) principal); } } return user; }\n\n    ### Response: get logged in user.\n\n@return UserData or null if no one is logged in.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder.getContext().getAuthentication(); if (null == current) { throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noCurrentUser\", \"No current user associated with this request\")); } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication(current); if (original == null) { this.logger.debug(\"Could not find original user Authentication object!\"); throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noOriginalAuthentication\", \"Could not find original Authentication object\")); } // get the source user details UserDetails originalUser = null; Object obj = original.getPrincipal(); if ((obj != null) && obj instanceof UserDetails) { originalUser = (UserDetails) obj; } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent( new AuthenticationSwitchUserEvent(current, originalUser)); } return original; }\n\n    ### Response:", "ground_truth": "Authentication object or null\notherwise.\n\n@throws AuthenticationCredentialsNotFoundException If no\nAuthentication associated with this request.", "predict": " attempt to exit user.\n\n@return Authentication object representing the original user or null if no original user found.\n\n    "}, {"ID": 153, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function login($login, $api_key) { if (empty($login) || !is_string($login)) { throw new \\InvalidArgumentException('Argument \"login\" cannot be empty and must be a string'); } if (empty($login) || !is_string($api_key)) { throw new \\InvalidArgumentException('Argument \"api_key\" cannot be empty and must be a string'); } $this->auth = [ 'login' => $login, 'password_hash' => $api_key, ]; }\n\n    ### Response: Set login data globally\n\n@param $login\n@param $api_key\n\n@throws \\InvalidArgumentException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setExitUserUrl(String exitUserUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\"); this.exitUserMatcher = createMatcher(exitUserUrl); }\n\n    ### Response:", "ground_truth": "Set the URL to respond to exit user processing.\n\n@param exitUserUrl The exit user URL.", "predict": " Set the exit user URL\n\n@param exitUserUrl The URL to redirect to when the user logs out.\n\n@throws IllegalArgumentException if exitUserUrl is not a valid redirect URL."}, {"ID": 154, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @PreAuthorize( \"hasPermission('ALL', 'java.lang.String', new org.apereo.portal.spring.security.evaluator.AuthorizableActivity('UP_PERMISSIONS', 'VIEW_PERMISSIONS'))\") @RequestMapping(value = \"/permissions/owners.json\", method = RequestMethod.GET) public ModelAndView getOwners() { // get a list of all currently defined permission owners List<IPermissionOwner> owners = permissionOwnerDao.getAllPermissionOwners(); ModelAndView mv = new ModelAndView(); mv.addObject(\"owners\", owners); mv.setViewName(\"json\"); return mv; }\n\n    ### Response: Provide a JSON view of all known permission owners registered with uPortal..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n    ### Response:", "ground_truth": "The public index page, used for unauthenticated users.", "predict": " Display a randomly selected contact from the contact manager."}, {"ID": 155, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Autowired @Bean public WebSecurityConfigurerAdapter casConfigurationServerWebSecurityConfigurerAdapter(final ServerProperties serverProperties) { return new WebSecurityConfigurerAdapter() { @Override protected void configure(final HttpSecurity http) throws Exception { super.configure(http); val path = serverProperties.getServlet().getContextPath(); http.authorizeRequests().antMatchers(path + \"/decrypt/**\").authenticated().and().csrf().disable(); http.authorizeRequests().antMatchers(path + \"/encrypt/**\").authenticated().and().csrf().disable(); } }; }\n\n    ### Response: CAS configuration server web security configurer.\n\n@param serverProperties the server properties\n@return the web security configurer adapter.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n    ### Response:", "ground_truth": "Creates the Spring Security Filter Chain\n@return the {@link Filter} that represents the security filter chain\n@throws Exception", "predict": "Creates the default filter chain for Spring Security.\n\n@return the filter chain.\n\n    "}, {"ID": 156, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private synchronized Jwt getJwt(ICacheStrategy cacheStrategy, Jwt.Key key) { Jwt result = cacheStrategy.getCachedJwt(key); if(result == null) { //cache an empty JWT first. result = new Jwt(key); cacheStrategy.cacheJwt(key, result); } return result; }\n\n    ### Response: cache jwt if not exist.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); }\n\n    ### Response:", "ground_truth": "Decode and validate the JWT from its compact claims representation format\n\n@param token the JWT value\n@return a validated {@link Jwt}\n@throws JwtException", "predict": " decode jwt token."}, {"ID": 157, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ChatMember[] getChatAdministrators(ChatId chat_id) throws IOException { AnalyticsData data = new AnalyticsData(\"getChatAdministrators\"); IOException ioException = null; ChatMember[] admins = null; data.setValue(\"chat_id\", chat_id); try { admins = bot.getChatAdministrators(chat_id); data.setReturned(admins); } catch (IOException e) { ioException = e; data.setIoException(ioException); } analyticsWorker.putData(data); if (ioException != null) { throw ioException; } return admins; }\n\n    ### Response: Use this method to get a list of administrators in a chat.\n\n@param chat_id Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)\n@return On success, returns an Array of ChatMember objects that contains information about all chat administrators except other bots.\nIf the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned.\n@throws IOException an exception is thrown in case of any service call failures.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean authorizeUsingAccessExpression() throws IOException { if (SecurityContextHolder.getContext().getAuthentication() == null) { return false; } SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler(); Expression accessExpression; try { accessExpression = handler.getExpressionParser().parseExpression(getAccess()); } catch (ParseException e) { IOException ioException = new IOException(); ioException.initCause(e); throw ioException; } return ExpressionUtils.evaluateAsBoolean(accessExpression, createExpressionEvaluationContext(handler)); }\n\n    ### Response:", "ground_truth": "Make an authorization decision based on a Spring EL expression. See the\n\"Expression-Based Access Control\" chapter in Spring Security for details on what\nexpressions can be used.\n\n@return the result of the authorization decision\n@throws IOException", "predict": " This method is used to check if the current user is authorized to access a resource based on the access expression configured for the resource.\n\n@return true if the current user is authorized to access the resource, false otherwise.\n@throws IOException an exception is thrown in case of any service call failures.\n\n    "}, {"ID": 158, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean needsToBeSecure(ServletContext context, ServletRequest request, String uri, boolean stripContextPath) { // Get the web-app relative path for security check String secureCheck = uri; if (stripContextPath) { String contextPath = ((HttpServletRequest) request).getContextPath(); if (secureCheck.startsWith(contextPath)) { secureCheck = secureCheck.substring(contextPath.length()); } } boolean secure = false; if (secureCheck.indexOf('?') > -1) { secureCheck = secureCheck.substring(0, secureCheck.indexOf('?')); } SecurityProtocol sp = getSecurityProtocol(secureCheck, context, (HttpServletRequest) request); if (sp.equals(SecurityProtocol.UNSPECIFIED)) { secure = request.isSecure(); } else { secure = sp.equals(SecurityProtocol.SECURE); } return secure; }\n\n    ### Response: Tell whether a given URI should be written to be secure.\n@param context          the current ServletContext.\n@param request          the current HttpServletRequest.\n@param uri              the URI to check.\n@param stripContextPath if true, strip the webapp context path from the URI before\nprocessing it.\n@return true when:\n\nthe given URI is configured in the deployment descriptor to be secure (according to\n{@link SecurityProtocol}), or\nthe given URI is not configured in the deployment descriptor, and the current request\nis secure ({@link HttpServletRequest#isSecure} returns\ntrue).\n\nfalse when:\n\nthe given URI is configured explicitly in the deployment descriptor to be unsecure\n(according to {@link SecurityProtocol}), or\nthe given URI is not configured in the deployment descriptor, and the current request\nis unsecure ({@link HttpServletRequest#isSecure} returns\nfalse).\n.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean authorizeUsingUrlCheck() throws IOException { String contextPath = ((HttpServletRequest) getRequest()).getContextPath(); Authentication currentUser = SecurityContextHolder.getContext() .getAuthentication(); return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser); }\n\n    ### Response:", "ground_truth": "Make an authorization decision based on the URL and HTTP method attributes. True is\nreturned if the user is allowed to access the given URL as defined.\n\n@return the result of the authorization decision\n@throws IOException", "predict": " Check if the current user is authorized to access the given URL using the given HTTP method.\n@return true if the current user is authorized to access the given URL using the given HTTP method, false otherwise.\n@throws IOException if an error occurs while checking the authorization.\n.\n\n    "}, {"ID": 159, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated @Override public List<IServerInterceptor> getInterceptors_() { List<IServerInterceptor> retVal = getInterceptorService() .getAllRegisteredInterceptors() .stream() .filter(t -> t instanceof IServerInterceptor) .map(t -> (IServerInterceptor) t) .collect(Collectors.toList()); return Collections.unmodifiableList(retVal); }\n\n    ### Response: Returns a list of all registered server interceptors\n@deprecated As of HAPI FHIR 3.8.0, use {@link #getInterceptorService()} to access the interceptor service. You can register and unregister interceptors using this service..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Collection<GrantedAuthority> convert(Jwt jwt) { return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); }\n\n    ### Response:", "ground_truth": "Extracts the authorities\n@param jwt The {@link Jwt} token\n@return The {@link GrantedAuthority authorities} read from the token scopes", "predict": " Converts a JWT into a collection of granted authorities based on the scopes in the JWT.\n\n@param jwt the JWT to convert\n@return a collection of granted authorities based on the scopes in the JWT"}, {"ID": 160, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CsrfToken loadToken(HttpServletRequest request) { CsrfToken token = null; String ident = getIdentifierFromCookie(request); if (ident != null) { String key = ident.concat(parameterName); if (Config.isCacheEnabled()) { token = cache.get(Config.getRootAppIdentifier(), key); } else { Object[] arr = localCache.get(key); if (arr != null && arr.length == 2) { boolean expired = (((Long) arr[1]) + Config.SESSION_TIMEOUT_SEC * 1000) < System.currentTimeMillis(); if (expired) { localCache.remove(key); } else { token = (CsrfToken) arr[0]; } } } } return token; }\n\n    ### Response: Loads a CSRF token from cache.\n@param request HTTP request\n@return the token.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); }\n\n    ### Response:", "ground_truth": "Generates a new token\n@param request the {@link HttpServletRequest} to use. The\n{@link HttpServletRequest} must have the {@link HttpServletResponse} as an\nattribute with the name of HttpServletResponse.class.getName()", "predict": " Generates a CSRF token and wraps it in a CsrfToken object.\n@param request HTTP request\n@return the wrapped token.\n\n    "}, {"ID": 161, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @ResourceMapping(value = \"retrieveSearchJSONResults\") public ModelAndView showJSONSearchResults(PortletRequest request) { PortletPreferences prefs = request.getPreferences(); int maxTextLength = Integer.parseInt(prefs.getValue(AUTOCOMPLETE_MAX_TEXT_LENGTH_PREF_NAME, \"180\")); final Map<String, Object> model = new HashMap<>(); List<AutocompleteResultsModel> results = new ArrayList<>(); final PortletSession session = request.getPortletSession(); String queryId = (String) session.getAttribute(SEARCH_LAST_QUERY_ID); if (queryId != null) { final PortalSearchResults portalSearchResults = this.getPortalSearchResults(request, queryId); if (portalSearchResults != null) { final ConcurrentMap<String, List<Tuple<SearchResult, String>>> resultsMap = portalSearchResults.getResults(); results = collateResultsForAutoCompleteResponse(resultsMap, maxTextLength); } } model.put(\"results\", results); model.put(\"count\", results.size()); return new ModelAndView(\"json\", model); }\n\n    ### Response: Display AJAX autocomplete search results for the last query.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); }\n\n    ### Response:", "ground_truth": "Displays the permission admin page for a particular contact.", "predict": " Display the admin permission page for the specified contact."}, {"ID": 162, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @PreAuthorize( \"hasPermission('ALL', 'java.lang.String', new org.apereo.portal.spring.security.evaluator.AuthorizableActivity('UP_PERMISSIONS', 'VIEW_PERMISSIONS'))\") @RequestMapping(value = \"/permissions/owners/{owner}.json\", method = RequestMethod.GET) public ModelAndView getOwners( @PathVariable(\"owner\") String ownerParam, HttpServletResponse response) { IPermissionOwner owner; if (StringUtils.isNumeric(ownerParam)) { long id = Long.valueOf(ownerParam); owner = permissionOwnerDao.getPermissionOwner(id); } else { owner = permissionOwnerDao.getPermissionOwner(ownerParam); } // if the IPermissionOwner was found, add it to the JSON model if (owner != null) { ModelAndView mv = new ModelAndView(); mv.addObject(\"owner\", owner); mv.setViewName(\"json\"); return mv; } // otherwise return a 404 not found error code else { response.setStatus(HttpServletResponse.SC_NOT_FOUND); return null; } }\n\n    ### Response: Provide a detailed view of the specified IPermissionOwner. This view should contain a list of\nthe owner's defined activities..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); }\n\n    ### Response:", "ground_truth": "Displays the \"add permission\" page for a contact.", "predict": " This method displays the add permission page for a given contact. It takes a contact ID as a parameter and retrieves the corresponding contact object from the contact manager. It then creates a new AddPermission object and populates it with the contact object. It also adds a list of recipients and a list of permissions to the model. Finally, it returns a new ModelAndView object with the addPermission view and the populated model."}, {"ID": 163, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/setLayersForMap.action\", method = RequestMethod.POST) public @ResponseBody java.util.Map<String, Object> setLayersForMap( @RequestParam(\"mapModuleId\") Integer mapModuleId, @RequestParam(\"layerIds\") List<Integer> layerIds) { try { if (mapModuleId == null || layerIds == null || layerIds.isEmpty()) { throw new Exception(); } List<Layer> layers = this.service.setLayersForMap(mapModuleId, layerIds); return ResultSet.success(layers); } catch (Exception e) { return ResultSet.error(COULD_NOT_SET_ERROR_MSG); } }\n\n    ### Response: Set layers for map\n\n@param mapModuleId The map module id\n@param layerIds The list of layer ids\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } return \"redirect:/secure/index.htm\"; }\n\n    ### Response:", "ground_truth": "Handles submission of the \"add permission\" form.", "predict": " Add permission\n\n@param addPermission The add permission object\n@param result The binding result\n@param model The model map\n@return.\n\n    "}, {"ID": 164, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void authorize(Subject user, Class<?> protocol) throws AuthorizationException { Permission permission = protocolToPermissionMap.get(protocol); if (permission == null) { permission = new ConnectionPermission(protocol); protocolToPermissionMap.put(protocol, permission); } checkPermission(user, permission); }\n\n    ### Response: Authorize the user to access the protocol being used.\n\n@param user user accessing the service\n@param protocol service being accessed\n@throws AuthorizationException on authorization failure.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); }\n\n    ### Response:", "ground_truth": "Deletes a permission", "predict": " Delete the permission for the given contact and sid.\n\n@param contactId id of the contact\n@param sid sid of the user\n@param mask permission mask to be deleted\n@return a model and view object to display the result of the operation."}, {"ID": 165, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Class<?> getFieldRole(Field field, Requirement requirement) { Class<?> role; // Handle case of list or map if (isDependencyOfListType(field.getType())) { role = getGenericRole(field); } else { role = field.getType(); } return role; }\n\n    ### Response: Extract component role from the field to inject.\n\n@param field the field to inject\n@param requirement the Requirement attribute\n@return the role of the field to inject.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) { if (role == null) { return role; } if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) { return role; } if (role.startsWith(defaultRolePrefix)) { return role; } return defaultRolePrefix + role; }\n\n    ### Response:", "ground_truth": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if role\ndoes not already start with defaultRolePrefix.\n\n@param defaultRolePrefix\n@param role\n@return", "predict": " Get the role with the default prefix.\n\n@param defaultRolePrefix the default prefix for the role\n@param role the role to get with the prefix\n@return the role with the prefix if it doesn't already have it, otherwise the role itself."}, {"ID": 166, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static FilterParams fromString(String line) { StringValueMap map = StringValueMap.fromString(line); return new FilterParams(map); }\n\n    ### Response: Parses semicolon-separated key-value pairs and returns them as a\nFilterParams.\n\n@param line semicolon-separated key-value list to initialize FilterParams.\n@return a newly created FilterParams.\n\n@see StringValueMap#toString().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UserDetailsResourceFactoryBean fromString(String users) { InMemoryResource resource = new InMemoryResource(users); return fromResource(resource); }\n\n    ### Response:", "ground_truth": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean", "predict": " Creates a new UserDetailsResourceFactoryBean from a semicolon-separated list of users.\n\n@param users semicolon-separated list of users to initialize the factory bean.\n@return a newly created UserDetailsResourceFactoryBean.\n\n@see InMemoryResource#InMemoryResource(String)."}, {"ID": 167, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Row> getTable(String name) { List<Row> result = m_tables.get(name); if (result == null) { result = Collections.emptyList(); } return result; }\n\n    ### Response: Retrieve table data, return an empty result set if no table data is present.\n\n@param name table name\n@return table data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; }\n\n    ### Response:", "ground_truth": "Returns the values for a specific attribute\n\n@param name the attribute name\n@return a String array, never null but may be zero length", "predict": " Retrieve attribute values for a given attribute name, return an empty result set if no attribute values are present.\n\n@param name attribute name\n@return attribute values."}, {"ID": 168, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<ErrorReport> getErrorReportOrNull(final String body) { ObjectMapper objectMapper = new ObjectMapper(); try { JsonNode jsonNode = objectMapper.readValue(body, JsonNode.class); ErrorReport[] errors = objectMapper.readValue(jsonNode.get(\"errors\").toString(), ErrorReport[].class); List<ErrorReport> result = Arrays.asList(errors); if (result.isEmpty()) { return null; } return result; } catch (IOException e) { return null; } }\n\n    ### Response: Get the MessageBird error report data.\n\n@param body Raw request body.\n@return Error report, or null if the body can not be deserialized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getFirstAttributeValue(String name) { List<String> result = getAttributeValues(name); if (result.isEmpty()) { return null; } else { return result.get(0); } }\n\n    ### Response:", "ground_truth": "Returns the first attribute value for a specified attribute\n\n@param name\n@return the first attribute value for a specified attribute, may be null", "predict": " Get the first attribute value for the given name.\n\n@param name Attribute name.\n@return First attribute value, or null if there is no such attribute."}, {"ID": 169, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] toByteArray(String value) { if (value == null) { return null; } try { CharsetEncoder encoder = Charset.forName(\"UTF-8\").newEncoder().onMalformedInput(CodingErrorAction.REPORT) .onUnmappableCharacter(CodingErrorAction.REPORT); ByteBuffer buf = encoder.encode(CharBuffer.wrap(value)); // don't use ByteBuffer.array(), as it returns internal, and // possibly larger, byte array byte[] res = new byte[buf.remaining()]; buf.get(res); return res; } catch (CharacterCodingException e) { throw new RuntimeException(\"Unexpected exception\", e); } }\n\n    ### Response: Encodes the given string in UTF-8.\n\n@param value\nthe string to encode.\n\n@return A newly allocated array containing the encoding result..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] encode(CharSequence string) { try { ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string)); byte[] bytesCopy = new byte[bytes.limit()]; System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit()); return bytesCopy; } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } }\n\n    ### Response:", "ground_truth": "Get the bytes of the String in UTF-8 encoded form.", "predict": " Encodes the given character sequence using the default character set.\n\n@param string\nthe character sequence to encode.\n\n@return A newly allocated array containing the encoding result.\n\n    "}, {"ID": 170, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static protected SftpClient getSftpClient(MuleContext muleContext, String endpointName) throws IOException { ImmutableEndpoint endpoint = getImmutableEndpoint(muleContext, endpointName); try { SftpClient sftpClient = SftpConnectionFactory.createClient(endpoint); return sftpClient; } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } /* EndpointURI endpointURI = endpoint.getEndpointURI(); SftpClient sftpClient = new SftpClient(endpointURI.getHost()); SftpConnector sftpConnector = (SftpConnector) endpoint.getConnector(); if (sftpConnector.getIdentityFile() != null) { try { sftpClient.login(endpointURI.getUser(), sftpConnector.getIdentityFile(), sftpConnector.getPassphrase()); } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } } else { try { sftpClient.login(endpointURI.getUser(), endpointURI.getPassword()); } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } } return sftpClient; */ }\n\n    ### Response: Returns a SftpClient that is logged in to the sftp server that the\nendpoint is configured against.\n\n@param muleContext\n@param endpointName\n@return\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(byte[] bytes) { try { return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString(); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Decoding failed\", e); } }\n\n    ### Response:", "ground_truth": "Decode the bytes in UTF-8 form into a String.", "predict": " Decodes the given byte array into a string using the default character set.\n\n@param bytes\n@return\n@throws IllegalArgumentException if decoding fails."}, {"ID": 171, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object[] getParameters(FrameworkMethod fm) { Method m = fm.getMethod(); SecurityActions.setAccessible(m); Class<?>[] parameters = m.getParameterTypes(); Annotation[][] parameterAnnotations = m.getParameterAnnotations(); Object[] result = new Object[parameters.length]; for (int i = 0; i < parameters.length; i++) { Annotation[] parameterAnnotation = parameterAnnotations[i]; boolean inject = false; String name = null; for (int j = 0; j < parameterAnnotation.length; j++) { Annotation a = parameterAnnotation[j]; if (javax.inject.Inject.class.equals(a.annotationType())) { inject = true; } else if (javax.inject.Named.class.equals(a.annotationType())) { name = ((javax.inject.Named)a).value(); } } if (inject) { result[i] = resolveBean(name != null ? name : parameters[i].getSimpleName(), parameters[i]); } else { result[i] = null; } } return result; }\n\n    ### Response: Get parameter values for a method\n@param fm The FrameworkMethod\n@return The resolved parameters.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T extends AccessibleObject> String[] lookupParameterNames( ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; }\n\n    ### Response:", "ground_truth": "Gets the parameter names or null if not found.\n\n@param parameterNameFactory the {@link ParameterNameFactory} to use\n@param t the {@link AccessibleObject} to find the parameter names on (i.e. Method\nor Constructor)\n@return the parameter names or null", "predict": " Lookup parameter names for a method or constructor\n@param parameterNameFactory The ParameterNameFactory to use\n@param t The AccessibleObject to lookup parameter names for\n@return The parameter names, or null if none were found.\n\n    "}, {"ID": 172, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"api/edit/enable/custom\", method = RequestMethod.POST) public @ResponseBody String enableCustomResponse(Model model, String custom, int path_id, @RequestParam(defaultValue = Constants.PROFILE_CLIENT_DEFAULT_ID) String clientUUID) throws Exception { if (custom.equals(\"undefined\")) return null; editService.enableCustomResponse(custom, path_id, clientUUID); return null; }\n\n    ### Response: Enables a custom response\n\n@param model\n@param custom\n@param path_id\n@param clientUUID\n@return\n@throws Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; }\n\n    ### Response:", "ground_truth": "Handles the submission of the contact form, creating a new instance if the username\nand email are valid.", "predict": " Adds a new contact to the system\n\n@param form\n@param result\n@return \"add\" if there are validation errors, otherwise redirects to the secure index page.\n\n    "}, {"ID": 173, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean isOverridable(Method method, Class<?> targetClass) { if (Modifier.isPrivate(method.getModifiers())) { return false; } if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) { return true; } return (targetClass == null || getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass))); }\n\n    ### Response: Determine whether the given method is overridable in the given target class.\n\n@param method      the method to check\n@param targetClass the target class to check against.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) { if (targetClass == null) { return null; } return findAttributesSpecifiedAgainst(method, targetClass); }\n\n    ### Response:", "ground_truth": "Will walk the method inheritance tree to find the most specific declaration\napplicable.", "predict": " Find the security configuration attributes for the given method and target class.\n\n@param method      the method to find attributes for\n@param targetClass the target class to find attributes for\n\n    "}, {"ID": 174, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static ActivityContext getActivityContext(ServletContext servletContext, String attrName) { Object attr = servletContext.getAttribute(attrName); if (attr == null) { return null; } if (!(attr instanceof AspectranWebService)) { throw new IllegalStateException(\"Context attribute [\" + attr + \"] is not of type [\" + AspectranWebService.class.getName() + \"]\"); } return ((CoreService)attr).getActivityContext(); }\n\n    ### Response: Find the ActivityContext for this web aspectran service.\n\n@param servletContext ServletContext to find the web aspectran service for\n@param attrName the name of the ServletContext attribute to look for\n@return the ActivityContext for this web aspectran service.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) { Assert.notNull(method, \"RegisteredMethod required\"); Assert.notNull(attr, \"Configuration attribute required\"); if (logger.isInfoEnabled()) { logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\"); } this.methodMap.put(method, attr); }\n\n    ### Response:", "ground_truth": "Add configuration attributes for a secure method.\n\n@param method the method to be secured\n@param attr required authorities associated with the method", "predict": " Add a secure method to the registry.\n\n@param method the registered method to add\n@param attr the configuration attributes to associate with the method"}, {"ID": 175, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Collection<Attribute<?>> getAllAttributes() { List<Attribute<?>> allAttributes = new ArrayList<Attribute<?>>(); allAttributes.addAll(getAttributes()); Collection<ModelElementType> baseTypes = ModelUtil.calculateAllBaseTypes(this); for (ModelElementType baseType : baseTypes) { allAttributes.addAll(baseType.getAttributes()); } return allAttributes; }\n\n    ### Response: Returns a list of all attributes, including the attributes of all base types.\n\n@return the list of all attributes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; }\n\n    ### Response:", "ground_truth": "Obtains the configuration attributes explicitly defined against this bean.\n\n@return the attributes explicitly defined against this bean", "predict": " Returns a set of all config attributes for this method.\n\n@return the set of all config attributes."}, {"ID": 176, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean methodHasSyntheticTwin(String methodName, String methodSig) { for (Method m : cls.getMethods()) { if (m.isSynthetic() && m.getName().equals(methodName) && !m.getSignature().equals(methodSig)) { return true; } } return false; }\n\n    ### Response: returns whether this method has an equivalent method that is synthetic, which\nimplies this method is constrained by some Generified interface. We could\ncompare parameters but that is a bunch of work that probably doesn't make\nthis test any more precise, so just return true if method name and synthetic\nis found.\n\n@param methodName the method name to look for a synthetic twin of\n@param methodSig  the method signature to lookfor a synthetic twin of\n@return if a synthetic twin is found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isMatch(String methodName, String mappedName) { return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length()))); }\n\n    ### Response:", "ground_truth": "Return if the given method name matches the mapped name. The default implementation\nchecks for \"xxx\" and \"xxx\" matches.\n\n@param methodName the method name of the class\n@param mappedName the name in the descriptor\n\n@return if the names match", "predict": " checks if the given method name matches the mapped name. The mapped name can contain the wildcard characters '*' to match any number of characters.\n\n@param methodName the method name to match\n@param mappedName the mapped name to match against\n@return true if the method name matches the mapped name, false otherwise."}, {"ID": 177, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public C findChild(String id) { int index = getChildrenList().indexOf(id); if (index == ArrayUtils.INDEX_NOT_FOUND) { return null; } C child = null; try { Model dummy = (Model) childClazz.newInstance(); dummy.setContext(context); child = (C) dummy.find(id); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return child; }\n\n    ### Response: Find a specific object from the child list.\n\nTODO: Figure out how to make this accesible without...\ncreating a dummy instance.\n\n@param id Child's id\n@throws com.mauriciogiordano.easydb.exception.NoContextFoundException in case of null context.\n@return The child if found, null otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; }\n\n    ### Response:", "ground_truth": "Maps any request.\n\n@return the object that is chained after creating the {@link RequestMatcher}", "predict": " Configure the request matcher to match any request.\n\n@return The request matcher.\n@throws IllegalStateException if anyRequest has already been configured."}, {"ID": 178, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void exceptionCaught(IoSession session, Throwable cause) { log.error(\"Unhandled exception for: \" + String.valueOf(session), cause); if (this.disconnectOnException) { this._disconnect(); } }\n\n    ### Response: Called when an exception occurs on the session\n\n@param session\nthe session on which the exception occurred\n@param cause\nthe exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void handleBindException(String userDn, String username, Throwable cause) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to bind as \" + userDn + \": \" + cause); } }\n\n    ### Response:", "ground_truth": "Allows subclasses to inspect the exception thrown by an attempt to bind with a\nparticular DN. The default implementation just reports the failure to the debug\nlogger.", "predict": " Handles a bind exception for the specified user DN and username.\n\n@param userDn\nthe user DN to bind with\n@param username\nthe username to bind with\n@param cause\nthe exception that occurred during the bind operation.\n\n    "}, {"ID": 179, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void shuffle(List<?> list) { Random rnd = r; if (rnd == null) r = rnd = new Random(); // harmless race. shuffle(list, rnd); }\n\n    ### Response: Randomly permutes the specified list using a default source of\nrandomness.  All permutations occur with approximately equal\nlikelihood.\n\nThe hedge \"approximately\" is used in the foregoing description because\ndefault source of randomness is only approximately an unbiased source\nof independently chosen bits. If it were a perfect source of randomly\nchosen bits, then the algorithm would choose permutations with perfect\nuniformity.\n\nThis implementation traverses the list backwards, from the last\nelement up to the second, repeatedly swapping a randomly selected element\ninto the \"current position\".  Elements are randomly selected from the\nportion of the list that runs from the first element to the current\nposition, inclusive.\n\nThis method runs in linear time.  If the specified list does not\nimplement the {@link RandomAccess} interface and is large, this\nimplementation dumps the specified list into an array before shuffling\nit, and dumps the shuffled array back into the list.  This avoids the\nquadratic behavior that would result from shuffling a \"sequential\naccess\" list in place.\n\n@param  list the list to be shuffled.\n@throws UnsupportedOperationException if the specified list or\nits list-iterator does not support the set operation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); }\n\n    ### Response:", "ground_truth": "This is a public method.", "predict": "Returns a random contact from the database.\n\n@return a random contact from the database.\n@throws DataAccessException if there is a problem accessing the database."}, {"ID": 180, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void clearAuthenticationAttributes() { HttpSession session = http.getCurrentRequest().getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); }\n\n    ### Response: Removes temporary authentication-related data which may have been stored in the session\nduring the authentication process..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void clearAuthenticationAttributes(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); }\n\n    ### Response:", "ground_truth": "Removes temporary authentication-related data which may have been stored in the\nsession during the authentication process.", "predict": " Removes temporary authentication-related data which may have been stored in the session during the authentication process."}, {"ID": 181, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Field getField(Class<?> clazz, String fieldName) throws NoSuchFieldException { if (clazz == Object.class) { return null; } try { Field field = clazz.getDeclaredField(fieldName); return field; } catch (NoSuchFieldException e) { return getField(clazz.getSuperclass(), fieldName); } }\n\n    ### Response: Recursively find the field by name up to the top of class hierarchy.\n\n@param clazz the class object\n@param fieldName declared field name of specified class\n@return the field object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException { Assert.notNull(clazz, \"Class required\"); Assert.hasText(fieldName, \"Field name required\"); try { return clazz.getDeclaredField(fieldName); } catch (NoSuchFieldException nsf) { // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName); } throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz); } }\n\n    ### Response:", "ground_truth": "Attempts to locate the specified field on the class.\n\n@param clazz the class definition containing the field\n@param fieldName the name of the field to locate\n\n@return the Field (never null)\n\n@throws IllegalStateException if field could not be found", "predict": " Recursively find the field by name up to the top of class hierarchy.\n\n@param clazz the class object\n@param fieldName declared field name of specified class\n@return the field object."}, {"ID": 182, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void buildEcpFaultResponse(final HttpServletResponse response, final HttpServletRequest request, final Pair<RequestAbstractType, String> authenticationContext) { request.setAttribute(SamlIdPConstants.REQUEST_ATTRIBUTE_ERROR, authenticationContext.getValue()); getSamlProfileHandlerConfigurationContext().getSamlFaultResponseBuilder() .build(authenticationContext.getKey(), request, response, null, null, null, SAMLConstants.SAML2_PAOS_BINDING_URI, null); }\n\n    ### Response: Build ecp fault response.\n\n@param response              the response\n@param request               the request\n@param authenticationContext the authentication context.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) { return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId); }\n\n    ### Response:", "ground_truth": "Constructs a new Service Url. The default implementation relies on the CAS client\nto do the bulk of the work.\n@param request the HttpServletRequest\n@param response the HttpServlet Response\n@return the constructed service url. CANNOT be NULL.", "predict": " Create service url.\n\n@param request  the request\n@param response the response\n@return the service url."}, {"ID": 183, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String formatTranslationString(POBuildData buildData, final String translationString) { try { final Document doc = TopicUtilities.convertXMLStringToDocument(\"<temp>\" + translationString + \"</temp>\", buildData.getDocBookVersion().getId()); return XMLUtilities.convertNodeToString(doc.getDocumentElement(), false); } catch (Exception e) { return translationString; } }\n\n    ### Response: Formats a string so that it will be compatible with publicans expectations.\n\n\n@param buildData         Information and data structures for the build.\n@param translationString The string to be formatted.\n@return The formatted string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createRedirectUrl(final String serviceUrl) { return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false); }\n\n    ### Response:", "ground_truth": "Constructs the Url for Redirection to the CAS server. Default implementation relies\non the CAS client to do the bulk of the work.\n\n@param serviceUrl the service url that should be included.\n@return the redirect url. CANNOT be NULL.", "predict": " Creates a redirect URL for the specified service URL.\n\n\n@param serviceUrl The service URL to redirect to.\n@return The redirect URL.\n\n    "}, {"ID": 184, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getFileName(String fileName) { if (fileName != null) { int index = fileName.indexOf(':'); if (index < 0) { return fileName; } else { fileName = fileName.substring(index + 1); index = fileName.lastIndexOf('/'); if (index < 0) { return fileName; } else { return fileName.substring(index + 1); } } } return null; }\n\n    ### Response: get file name from resource\n\n@param fileName\n\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String extractPrefix(String encPass) { if (!encPass.startsWith(\"{\")) { return null; } int secondBrace = encPass.lastIndexOf('}'); if (secondBrace < 0) { throw new IllegalArgumentException( \"Couldn't find closing brace for SHA prefix\"); } return encPass.substring(0, secondBrace + 1); }\n\n    ### Response:", "ground_truth": "Returns the hash prefix or null if there isn't one.", "predict": " extract SHA prefix from encrypted password\n\n@param encPass\n\n@return SHA prefix.\n\n    "}, {"ID": 185, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void fail(HttpServletRequest request, HttpServletResponse response, AuthenticationException failure) throws IOException, ServletException { SecurityContextHolder.getContext().setAuthentication(null); if (log.isDebugEnabled()) { log.debug(failure); } authenticationEntryPoint.commence(request, response, failure); }\n\n    ### Response: Common logic for OAuth failed.\n\n@param request  The request.\n@param response The response.\n@param failure  The failure.\n@throws IOException thrown when there's an underlying IO exception\n@throws ServletException thrown in the case of an underlying Servlet exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); }\n\n    ### Response:", "ground_truth": "Always returns a 403 error code to the client.", "predict": " This method is called when authentication fails and the pre-authenticated entry point is used. It sends a 403 Forbidden response with a message \"Access Denied\".\n\n@param request  The request.\n@param response The response.\n@param arg2     The failure.\n@throws IOException thrown when there's an underlying IO exception\n@throws ServletException thrown in the case of an underlying Servlet exception."}, {"ID": 186, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized JarFile getFilteredJarFile(JarEntryFilter... filters) throws IOException { return new JarFile(this.rootFile, this.pathFromRoot, this.data, this.entries, filters); }\n\n    ### Response: Return a new jar based on the filtered contents of this file.\n\n@param filters the set of jar entry filters to be applied\n@return a filtered {@link JarFile}\n@throws IOException if the jar file cannot be read.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkFilterStack(List<Filter> filters) { checkForDuplicates(SecurityContextPersistenceFilter.class, filters); checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters); checkForDuplicates(SessionManagementFilter.class, filters); checkForDuplicates(BasicAuthenticationFilter.class, filters); checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters); checkForDuplicates(JaasApiIntegrationFilter.class, filters); checkForDuplicates(ExceptionTranslationFilter.class, filters); checkForDuplicates(FilterSecurityInterceptor.class, filters); }\n\n    ### Response:", "ground_truth": "Checks the filter list for possible errors and logs them", "predict": "Check the filter stack for duplicate instances of the specified filter type.\n\n@param filterType the filter type to check for duplicates\n@param filters the list of filters to check for duplicates\n@throws IllegalStateException if a duplicate filter is found\n\n    "}, {"ID": 187, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected List<Class<? extends Annotation>> createAnnotationTypeList(Class<?>... annotations) { final List<Class<? extends Annotation>> annotationList = new ArrayList<Class<? extends Annotation>>(); for (Class<?> annoType : annotations) { @SuppressWarnings(\"unchecked\") final Class<? extends Annotation> castType = (Class<? extends Annotation>) annoType; annotationList.add(castType); } return annotationList; }\n\n    ### Response: for Generic headache.\n@param annotations The array of annotation. (NotNull, EmptyAllowed)\n@return The list of annotation type. (NotNull, EmptyAllowed).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") final Class<? extends Throwable>[] getRegisteredTypes() { Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet(); return typeList.toArray(new Class[typeList.size()]); }\n\n    ### Response:", "ground_truth": "Returns an array containing the classes for which extractors are registered. The\norder of the classes is the order in which comparisons will occur for resolving a\nmatching extractor.\n\n@return the types for which extractors are registered", "predict": " for Generic headache.\n@return The array of registered types. (NotNull, EmptyAllowed)\n\n    "}, {"ID": 188, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static IdentifierHandler<? extends Identifier> getExtendedIdentifierHandlerFor(Element element) { if (!checkExtendedIdentityElement(element)) { return null; } String name = element.getAttribute(IfmapStrings.IDENTITY_ATTR_NAME); Document extendedDocument; try { extendedDocument = DomHelpers.parseEscapedXmlString(name); } catch (UnmarshalException e) { return null; } Element extendedElement = extendedDocument.getDocumentElement(); String nodeName = extendedElement.getLocalName(); // try to find the most specific handler for (Entry<Class<? extends Identifier>, IdentifierHandler<? extends Identifier>> entry : sIdentifierHandlers .entrySet()) { String simpleClassName = entry.getKey().getSimpleName(); if (simpleClassName.equalsIgnoreCase(nodeName)) { return entry.getValue(); } } return null; }\n\n    ### Response: If the element argument is an extended identity Identifier then try to find the most specific handler for this\nelement. Used the Element-LocalName to find the right handler.\n\n@param element\n@return The {@link IdentifierHandler} for the element or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Throwable extractCause(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractCause(throwable); } } return null; }\n\n    ### Response:", "ground_truth": "Extracts the cause of the given throwable using an appropriate extractor.\n\n@param throwable the Throwable (not null\n@return the cause, may be null if none could be resolved", "predict": " Extract the cause of the given throwable. The cause is extracted by iterating over the extractorMap and checking if the given throwable is an instance of the key class. If it is, then the corresponding value extractor is used to extract the cause. If no extractor is found for the given throwable, then null is returned.\n\n@param throwable\n@return The cause of the given throwable or null."}, {"ID": 189, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static BeanDefinition getCredentials(Element credentialsProviderElement, ParserContext parserContext) { BeanDefinitionBuilder builder = BeanDefinitionBuilder .rootBeanDefinition(\"com.amazonaws.auth.BasicAWSCredentials\"); builder.addConstructorArgValue(getAttributeValue(ACCESS_KEY_ATTRIBUTE_NAME, credentialsProviderElement, parserContext)); builder.addConstructorArgValue(getAttributeValue(SECRET_KEY_ATTRIBUTE_NAME, credentialsProviderElement, parserContext)); return builder.getBeanDefinition(); }\n\n    ### Response: Creates a bean definition for the credentials object. This methods creates a bean\ndefinition instead of the direct implementation to allow property place holder to\nchange any place holder used for the access or secret key.\n@param credentialsProviderElement - The element that contains the credentials\nattributes ACCESS_KEY_ATTRIBUTE_NAME and SECRET_KEY_ATTRIBUTE_NAME\n@param parserContext - Used to report any errors if there is no\nACCESS_KEY_ATTRIBUTE_NAME or SECRET_KEY_ATTRIBUTE_NAME available with a valid value\n@return - the bean definition with an\n{@link com.amazonaws.auth.BasicAWSCredentials} class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder .rootBeanDefinition(AffirmativeBased.class); ManagedList voters = new ManagedList(4); if (expressionVoter != null) { voters.add(expressionVoter); } voters.add(new RootBeanDefinition(RoleVoter.class)); voters.add(new RootBeanDefinition(AuthenticatedVoter.class)); if (jsr250Enabled) { voters.add(new RootBeanDefinition(Jsr250Voter.class)); } accessMgrBuilder.addConstructorArgValue(voters); BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition(); String id = pc.getReaderContext().generateBeanName(accessManager); pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id)); return id; }\n\n    ### Response:", "ground_truth": "Register the default AccessDecisionManager. Adds the special JSR 250 voter jsr-250\nis enabled and an expression voter if expression-based access control is enabled.\n@return", "predict": " Registers the access manager bean definition. This method creates a bean\ndefinition for the access manager that uses the affirmative based strategy with a\nlist of voters. The voters are added to the list in the order of expression voter, role\nvoter, authenticated voter, and if the jsr250Enabled is true, the jsr250 voter. The\naccess manager is then registered with the bean context and the id of the bean is\nreturned.\n@param pc - The parser context used to register the bean\n@param jsr250Enabled - A boolean flag to indicate if the jsr250 voter should be added\nto the voter list\n@param expressionVoter - The expression voter bean definition to be added to the voter\nlist\n@return - the id of the registered access manager bean definition\n\n    "}, {"ID": 190, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean isUserInRole(String role) { boolean inRole = false; Authentication authentication = getAuthentication(); if (authentication != null) { Collection<? extends GrantedAuthority> authorities = authentication .getAuthorities(); for (GrantedAuthority authority : authorities) { if (role.equals(authority.getAuthority())) { inRole = true; break; } } } return inRole; }\n\n    ### Response: Determine if the currently authenticated user has the role provided. Note\nthat role comparisons are case sensitive.\n\n@param role\nto check\n@return true if the user has the role requested.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) { Assert.notNull(userAuthorities, \"userAuthorities cannot be null\"); Set<String> set = new HashSet<>(userAuthorities.size()); for (GrantedAuthority authority : userAuthorities) { set.add(authority.getAuthority()); } return set; }\n\n    ### Response:", "ground_truth": "Converts an array of GrantedAuthority objects to a Set.\n@return a Set of the Strings obtained from each call to\nGrantedAuthority.getAuthority()", "predict": " Convert a collection of GrantedAuthority objects to a set of strings representing the authorities.\n\n@param userAuthorities\nthe collection of GrantedAuthority objects to convert\n@return a set of strings representing the authorities\n@throws IllegalArgumentException\nif userAuthorities is null"}, {"ID": 191, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean constantTimeEquals(byte[] a, byte[] b) { if (a.length != b.length) { return false; } int result = 0; for (int i = 0; i < a.length; i++) { result |= a[i] ^ b[i]; } return result == 0; }\n\n    ### Response: Checks if byte arrays a and be are equal in an algorithm that runs in\nconstant time provided that their lengths are equal.\n\n@param a the first byte array\n@param b the second byte array\n@return true if a and be are equal, else false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean matches(byte[] expected, byte[] actual) { if (expected.length != actual.length) { return false; } int result = 0; for (int i = 0; i < expected.length; i++) { result |= expected[i] ^ actual[i]; } return result == 0; }\n\n    ### Response:", "ground_truth": "Constant time comparison to prevent against timing attacks.", "predict": " Checks if byte arrays expected and actual are equal in an algorithm that runs in constant time provided that their lengths are equal.\n\n@param expected the expected byte array\n@param actual the actual byte array\n@return true if expected and actual are equal, else false."}, {"ID": 192, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Object unmarshal(Object obj) throws RpcException { if (obj == null) { return returnNullIfOptional(); } else if (obj.getClass() != String.class) { String msg = \"'\" + obj + \"' enum must be String, got: \" + obj.getClass().getSimpleName(); throw RpcException.Error.INVALID_PARAMS.exc(msg); } else if (e.getValues().contains((String)obj)) { try { Class clz = getTypeClass(); return java.lang.Enum.valueOf(clz, (String)obj); } catch (Exception e) { String msg = \"Could not set enum value '\" + obj + \"' - \" + e.getClass().getSimpleName() + \" - \" + e.getMessage(); throw RpcException.Error.INTERNAL.exc(msg); } } else { String msg = \"'\" + obj + \"' is not in enum: \" + e.getValues(); throw RpcException.Error.INVALID_PARAMS.exc(msg); } }\n\n    ### Response: Enforces that obj is a String contained in the Enum's values list.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDefaultFailureUrl(String defaultFailureUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\"); this.defaultFailureUrl = defaultFailureUrl; }\n\n    ### Response:", "ground_truth": "The URL which will be used as the failure destination.\n\n@param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".", "predict": "Sets the default failure URL for the application. The URL must be a valid redirect URL."}, {"ID": 193, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, Map<String, String>> merge( final Map<String, Map<String, String>> targetContext, final Map<String, Map<String, String>> newContext ) { final HashMap<String, Map<String, String>> result = deepCopy(targetContext); for (final Map.Entry<String, Map<String, String>> entry : newContext.entrySet()) { if (!targetContext.containsKey(entry.getKey())) { result.put(entry.getKey(), new HashMap<>()); } else { result.put(entry.getKey(), new HashMap<>(targetContext.get(entry.getKey()))); } result.get(entry.getKey()).putAll(entry.getValue()); } return result; }\n\n    ### Response: Merge one context onto another by adding or replacing values in a new map\n\n@param targetContext the target of the merge\n@param newContext    context to merge\n\n@return merged data in a new map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; }\n\n    ### Response:", "ground_truth": "Sets a Function used to resolve a Map of the hidden inputs where the key is the\nname of the input and the value is the value of the input. Typically this is used\nto resolve the CSRF token.\n@param resolveHiddenInputs the function to resolve the inputs", "predict": " Set the function to resolve hidden inputs in the request.\n\n@param resolveHiddenInputs the function to resolve hidden inputs in the request."}, {"ID": 194, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String buildMetricName(String process, String mbeanName, String mbeanPublishName, String attribute, String attrPublishName) { StringBuilder buf = new StringBuilder(); if (process != null) { buf.append(process); buf.append(\"_\"); } if (mbeanPublishName != null) { buf.append(mbeanPublishName); } else { buf.append(mbeanName); } buf.append(\"_\"); if (!\"\".equals(attrPublishName)) { buf.append(attrPublishName); } else { buf.append(attribute); } return buf.toString(); }\n\n    ### Response: Builds the metric name in ganglia\n\n@param process\nthe process name, or null if not used\n@param mbeanName\nthe mbean name\n@param mbeanPublishName\nthe mbean publish name, or null if not used\n@param attribute\nthe mbean attribute name\n@param attrPublishName\nthe mbean attribute publish name\n@return the metric name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String buildRequestUrl(String servletPath, String requestURI, String contextPath, String pathInfo, String queryString) { StringBuilder url = new StringBuilder(); if (servletPath != null) { url.append(servletPath); if (pathInfo != null) { url.append(pathInfo); } } else { url.append(requestURI.substring(contextPath.length())); } if (queryString != null) { url.append(\"?\").append(queryString); } return url.toString(); }\n\n    ### Response:", "ground_truth": "Obtains the web application-specific fragment of the URL.", "predict": " Builds the request URL string.\n\n@param servletPath\nthe servlet path, or null if not used\n@param requestURI\nthe request URI\n@param contextPath\nthe context path\n@param pathInfo\nthe path info, or null if not used\n@param queryString\nthe query string, or null if not used\n@return the request URL string."}, {"ID": 195, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final static boolean isValidURL(String url) { if (url == null) { return false; } else { return Patterns.WEB_URL.matcher(url).matches(); } }\n\n    ### Response: Uses androids android.util.Patterns.WEB_URL to check if an url is valid.\n\n@param url Address to check\n@return true if the url is a valid web address..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAbsoluteUrl(String url) { if (url == null) { return false; } final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE); return ABSOLUTE_URL.matcher(url).matches(); }\n\n    ### Response:", "ground_truth": "Decides if a URL is absolute based on whether it contains a valid scheme name, as\ndefined in RFC 1738.", "predict": " Checks if a given url is absolute or not.\n\n@param url Address to check\n@return true if the url is absolute."}, {"ID": 196, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<OpenIDAttribute> createAttributeList(String identifier) { List<OpenIDAttribute> list = new LinkedList<>(); if (identifier != null && identifier.matches(\"https://www.google.com/.*\")) { OpenIDAttribute email = new OpenIDAttribute(\"email\", \"http://axschema.org/contact/email\"); OpenIDAttribute first = new OpenIDAttribute(\"firstname\", \"http://axschema.org/namePerson/first\"); OpenIDAttribute last = new OpenIDAttribute(\"lastname\", \"http://axschema.org/namePerson/last\"); email.setCount(1); email.setRequired(true); first.setRequired(true); last.setRequired(true); list.add(email); list.add(first); list.add(last); } return list; }\n\n    ### Response: A list of OpenID attributes to send in a request.\n@param identifier a user identifier\n@return a list of attributes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<OpenIDAttribute> createAttributeList(String identifier) { for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) { if (entry.getKey().matcher(identifier).matches()) { return entry.getValue(); } } return Collections.emptyList(); }\n\n    ### Response:", "ground_truth": "Iterates through the patterns stored in the map and returns the list of attributes\ndefined for the first match. If no match is found, returns an empty list.", "predict": " A list of OpenID attributes to send in a request.\n@param identifier a user identifier\n@return a list of attributes."}, {"ID": 197, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function buildElementIdentifier(element) { if (element.id) { return `#${element.id}`; } let identifier = element.tagName.toLowerCase(); if (!element.parentNode) { return identifier; } const siblings = getSiblings(element); const childIndex = siblings.indexOf(element); if (!isOnlySiblingOfType(element, siblings) && childIndex !== -1) { identifier += `:nth-child(${childIndex + 1})`; } return identifier; }\n\n    ### Response: Build a unique CSS element identifier.\n@private\n@param {HTMLElement} element - An element to get a CSS element identifier for.\n@returns {String} Returns the CSS element identifier as a string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; }\n\n    ### Response:", "ground_truth": "Converts the raw type from the database into the right Java type. For most applications the 'raw type' will be Long, for some applications\nit could be String.\n@param identifier The identifier from the database\n@param resultSet  Result set of the query\n@return The identifier in the appropriate target Java type. Typically Long or UUID.\n@throws SQLException", "predict": " Get a serializable identifier from a result set.\n@param {Serializable} identifier - The identifier to get from the result set.\n@param {ResultSet} resultSet - The result set to get the identifier from.\n@returns {Serializable} Returns the identifier as a serializable object.\n@throws SQLException - If there is an error getting the identifier from the result set.\n\n    "}, {"ID": 198, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void batchImport() { m_jdbcTemplate.batchUpdate(createInsertQuery(), new BatchPreparedStatementSetter() { public void setValues( PreparedStatement ps, int i) throws SQLException { int j = 1; for (String property : m_propertyNames) { Map params = (Map) m_batch.get( i); ps.setObject(j++, params.get( property)); } } public int getBatchSize() { return m_batch.size(); } }); }\n\n    ### Response: Perform batch import into database..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createEntries(final MutableAcl acl) { if (acl.getEntries().isEmpty()) { return; } jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() { public int getBatchSize() { return acl.getEntries().size(); } public void setValues(PreparedStatement stmt, int i) throws SQLException { AccessControlEntry entry_ = acl.getEntries().get(i); Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\"); AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_; stmt.setLong(1, ((Long) acl.getId()).longValue()); stmt.setInt(2, i); stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true) .longValue()); stmt.setInt(4, entry.getPermission().getMask()); stmt.setBoolean(5, entry.isGranting()); stmt.setBoolean(6, entry.isAuditSuccess()); stmt.setBoolean(7, entry.isAuditFailure()); } }); }\n\n    ### Response:", "ground_truth": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl\nobject.\n\n@param acl containing the ACEs to insert", "predict": " Create entries in the ACL table."}, {"ID": 199, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PagingParams fromMap(AnyValueMap map) { Long skip = map.getAsNullableLong(\"skip\"); Long take = map.getAsNullableLong(\"take\"); boolean total = map.getAsBooleanWithDefault(\"total\", true); return new PagingParams(skip, take, total); }\n\n    ### Response: Creates a new PagingParams and sets it parameters from the AnyValueMap map\n\n@param map a AnyValueMap to initialize this PagingParams\n@return a newly created PagingParams..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createObjectIdentity(ObjectIdentity object, Sid owner) { Long sidId = createOrRetrieveSidPrimaryKey(owner, true); Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass()); jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId, Boolean.TRUE); }\n\n    ### Response:", "ground_truth": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity.\nThe Sid is also necessary, as acl_object_identity has defined the sid column as\nnon-null.\n\n@param object to represent an acl_object_identity for\n@param owner for the SID column (will be created if there is no acl_sid entry for\nthis particular Sid already)", "predict": " Creates a new ObjectIdentity and sets its parameters from the given object and owner.\n\n@param object the object to create the ObjectIdentity for\n@param owner the owner of the object\n@throws SQLException if an error occurs while creating the ObjectIdentity\n@throws DataAccessException if an error occurs while creating the ObjectIdentity\n\n    "}, {"ID": 200, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addParentKeyToDocument(String parentId, Document currentDoc, Class<?> clazz) { // if (parentId != null) if (clazz != null && parentId != null) { Field luceneField = new Field(IndexingConstants.PARENT_ID_FIELD, parentId, Field.Store.YES, Field.Index.ANALYZED_NO_NORMS); currentDoc.add(luceneField); Field fieldClass = new Field(IndexingConstants.PARENT_ID_CLASS, clazz.getCanonicalName().toLowerCase(), Field.Store.YES, Field.Index.ANALYZED); currentDoc.add(fieldClass); } }\n\n    ### Response: Index parent key.\n\n@param parentId\nthe parent id\n@param currentDoc\nthe current doc\n@param clazz\nthe clazz.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void updateObjectIdentity(MutableAcl acl) { Long parentId = null; if (acl.getParentAcl() != null) { Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl() .getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\"); ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl() .getObjectIdentity(); parentId = retrieveObjectIdentityPrimaryKey(oii); } Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\"); Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true); int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId()); if (count != 1) { throw new NotFoundException(\"Unable to locate ACL to update\"); } }\n\n    ### Response:", "ground_truth": "Updates an existing acl_object_identity row, with new information presented in the\npassed MutableAcl object. Also will create an acl_sid entry if needed for the Sid\nthat owns the MutableAcl.\n\n@param acl to modify (a row must already exist in acl_object_identity)\n\n@throws NotFoundException if the ACL could not be found to update.", "predict": " Update object identity.\n\n@param acl\nthe acl.\n\n    "}, {"ID": 201, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (anyRequestMatcher.matches(request) && !ajaxRequestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); HttpUtils.setStateParam(Config.RETURNTO_COOKIE, Utils.base64enc(savedRequest.getRedirectUrl().getBytes()), request, response); } }\n\n    ### Response: Saves a request in cache.\n@param request HTTP request\n@param response HTTP response.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (requestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); if (createSessionAllowed || request.getSession(false) != null) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request.getSession().setAttribute(this.sessionAttrName, savedRequest); logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest); } } else { logger.debug(\"Request not saved as configured RequestMatcher did not match\"); } }\n\n    ### Response:", "ground_truth": "Stores the current request, provided the configuration properties allow it.", "predict": " Saves a request in cache.\n@param request HTTP request\n@param response HTTP response."}, {"ID": 202, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsIgnoreCase(String name, Iterable<String> patterns) { for (String pattern : patterns) { if (name.equalsIgnoreCase(pattern)) { return true; } } return false; }\n\n    ### Response: Does the given column name equals ignore case with one of pattern given in parameter\n\n@param name     the column\n@param patterns table of patterns as strings\n@return true if the column name equals ignore case with one of the given patterns, false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); }\n\n    ### Response:", "ground_truth": "Creates a matcher that matches on the specific method and any of the provided patterns.\n@param method the method to match on. If null, any method will be matched\n@param patterns the patterns to match on\n@return the matcher to use", "predict": " Matches the given HTTP method and patterns using PathPatternParserServerWebExchangeMatcher.\n\n@param method the HTTP method\n@param patterns the patterns to match\n@return a ServerWebExchangeMatcher that matches the given HTTP method and patterns using PathPatternParserServerWebExchangeMatcher."}, {"ID": 203, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Mappings uniqueAtoms() { // we need the unique predicate to be reset for each new iterator - // otherwise multiple iterations are always filtered (seen before) return new Mappings(query, target, new Iterable<int[]>() { @Override public Iterator<int[]> iterator() { return Iterators.filter(iterable.iterator(), new UniqueAtomMatches()); } }); }\n\n    ### Response: Filter the mappings for those which cover a unique set of atoms in the\ntarget. The unique atom mappings are a subset of the unique bond\nmatches.\n\n@return fluent-api instance\n@see #uniqueBonds().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; }\n\n    ### Response:", "ground_truth": "Matches any exchange\n@return the matcher to use", "predict": "Create a matcher that matches any exchange.\n\n@return a matcher that matches any exchange\n@see #pathMatchers(String...)."}, {"ID": 204, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AndroidAesBytesEncryptor(password.toString(), salt, AndroidKeyGenerators.shared(16))); }\n\n    ### Response: Creates an encryptor for queryable text strings that uses standard password-based encryption. Uses a shared, or\nconstant 16 byte initialization vector so encrypting the same data results in the same encryption result. This is\ndone to allow encrypted data to be queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); }\n\n    ### Response:", "ground_truth": "Creates a text encryptor that uses \"stronger\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#stronger(CharSequence, CharSequence)", "predict": " Creates an encryptor for queryable text strings that uses stronger encryption than the standard password-based encryption. Uses a shared, or\nconstant 16 byte initialization vector so encrypting the same data results in the same encryption result. This is\ndone to allow encrypted data to be queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key."}, {"ID": 205, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AndroidAesBytesEncryptor(password.toString(), salt, AndroidKeyGenerators.shared(16))); }\n\n    ### Response: Creates an encryptor for queryable text strings that uses standard password-based encryption. Uses a shared, or\nconstant 16 byte initialization vector so encrypting the same data results in the same encryption result. This is\ndone to allow encrypted data to be queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); }\n\n    ### Response:", "ground_truth": "Creates a text encryptor that uses \"standard\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#standard(CharSequence, CharSequence)", "predict": " Creates an encryptor for text strings that uses standard password-based encryption. Uses a shared, or\nconstant 16 byte initialization vector so encrypting the same data results in the same encryption result. This is\ndone to allow encrypted data to be queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key."}, {"ID": 206, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AndroidAesBytesEncryptor(password.toString(), salt, AndroidKeyGenerators.shared(16))); }\n\n    ### Response: Creates an encryptor for queryable text strings that uses standard password-based encryption. Uses a shared, or\nconstant 16 byte initialization vector so encrypting the same data results in the same encryption result. This is\ndone to allow encrypted data to be queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt)); }\n\n    ### Response:", "ground_truth": "Creates an encryptor for queryable text strings that uses standard password-based\nencryption. Uses a 16-byte all-zero initialization vector so encrypting the same\ndata results in the same encryption result. This is done to allow encrypted data to\nbe queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the\nsecret key", "predict": " Creates an encryptor for queryable text strings that uses standard password-based encryption. Uses a random,\nsite-global salt value to generate the secret key. This is done to allow encrypted data to be queried against. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should not be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the secret key."}, {"ID": 207, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { String handler = getHandler(request); if (handler.startsWith(COMMAND_PATH)) { if (!checkForAjax(request, response)) { return; } StatusHandler.handleCommand(handler.substring(COMMAND_PATH.length() + 1), request, response); } else { handleStaticResources(handler, response); } }\n\n    ### Response: Handle GET http requests..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeHeaders(HttpServletRequest request, HttpServletResponse response) { if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) { String allowFromValue = this.allowFromStrategy.getAllowFromValue(request); if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode()); } } else if (allowFromValue != null) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFromValue); } } } else { response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode()); } }\n\n    ### Response:", "ground_truth": "Writes the X-Frame-Options header value, overwritting any previous value.\n\n@param request the servlet request\n@param response the servlet response", "predict": " Write headers to the response object."}, {"ID": 208, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException { super.onUnsuccessfulAuthentication(request, response, failed); LOGGER.log(Level.FINE, \"Login attempt failed\", failed); Authentication auth = failed.getAuthentication(); if (auth != null) { SecurityListener.fireFailedToLogIn(auth.getName()); } }\n\n    ### Response: Leave the information about login failure.\n\n\nOtherwise it seems like Acegi doesn't really leave the detail of the failure anywhere..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); }\n\n    ### Response:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc\n\n@since 5.2", "predict": " This method is a copy of the parent class's method with the same name and signature. It is not clear what the purpose of this method is or what it does."}, {"ID": 209, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void handle(RequestContext context, AuthenticationException e) throws SecurityProviderException, IOException { String targetUrl = getTargetUrl(); if (StringUtils.isNotEmpty(targetUrl)) { RedirectUtils.redirect(context.getRequest(), context.getResponse(), targetUrl); } else { sendError(e, context); } }\n\n    ### Response: Redirects the response to target URL if target URL is not empty. If not, a 401 UNAUTHORIZED error is sent.\n\n@param context the request context\n@param e       the exception that caused the login to fail..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available String targetUrl = null; if (targetUrlParameter != null) { targetUrl = request.getParameter(targetUrlParameter); if (StringUtils.hasText(targetUrl)) { logger.debug(\"Found targetUrlParameter in request: \" + targetUrl); return targetUrl; } } if (useReferer && !StringUtils.hasLength(targetUrl)) { targetUrl = request.getHeader(\"Referer\"); logger.debug(\"Using Referer header: \" + targetUrl); } if (!StringUtils.hasText(targetUrl)) { targetUrl = defaultTargetUrl; logger.debug(\"Using default Url: \" + targetUrl); } return targetUrl; }\n\n    ### Response:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc.", "predict": " Determines the target URL for the login page. If the \"alwaysUseDefaultTargetUrl\" property is set to true, the default target URL is returned. Otherwise, the following steps are taken:\n\n1. Check if the target URL parameter is present in the request. If it is, use that as the target URL.\n2. If the \"useReferer\" property is set to true and the target URL parameter is not present, check the \"Referer\" header for the target URL.\n3. If the target URL is still not available, use the default target URL.\n\n@param request  the current HTTP request\n@param response the current HTTP response\n@return the target URL for the login page."}, {"ID": 210, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void validatePluginDescriptor(PluginDescriptor descriptor) throws PluginException { if (StringUtils.isNullOrEmpty(descriptor.getPluginId())) { throw new PluginException(\"Field 'id' cannot be empty\"); } if (descriptor.getVersion() == null) { throw new PluginException(\"Field 'version' cannot be empty\"); } }\n\n    ### Response: Override this to change the validation criteria.\n\n@param descriptor the plugin descriptor to validate\n@throws PluginException if validation fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; }\n\n    ### Response:", "ground_truth": "If this property is set, the current request will be checked for this a parameter\nwith this name and the value used as the target URL if present.\n\n@param targetUrlParameter the name of the parameter containing the encoded target\nURL. Defaults to null.", "predict": " Sets the name of the URL parameter that will be used to pass the target URL to the login page.\n\n@param targetUrlParameter the name of the URL parameter that will be used to pass the target URL to the login page."}, {"ID": 211, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<Directory> collectExistingRoots(final Directory pNewRoot) { final Path parentPath = pNewRoot.getPath(); final Collection<Directory> pathsToRebase = new LinkedList<>(); dirs.entrySet().forEach(e -> { final Path childPath = e.getKey(); if (childPath.startsWith(parentPath) && e.getValue().isRoot()) { pathsToRebase.add(e.getValue()); } }); return pathsToRebase; }\n\n    ### Response: Collects all existing root directories which are children of the new root directory specified specified.\n\n@param pNewRoot New root directory to match, must not be {@code null}\n@return Collection of directories, never {@code null}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Directory getDirectoryWithImmediateParentPopulated(final Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory); FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\"))); return directory; } }); }\n\n    ### Response:", "ground_truth": "Executes recursive SQL as needed to build a full Directory hierarchy of objects", "predict": " Retrieves a directory with the specified ID and populates its parent directory recursively.\n\n@param id ID of the directory to retrieve, must not be {@code null}\n@return Directory with the specified ID, never {@code null}"}, {"ID": 212, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void parse(String path) { DnParser parser = DefaultDnParserFactory.createDnParser(unmangleCompositeName(path)); DistinguishedName dn; try { dn = parser.dn(); } catch (ParseException e) { throw new BadLdapGrammarException(\"Failed to parse DN\", e); } catch (TokenMgrError e) { throw new BadLdapGrammarException(\"Failed to parse DN\", e); } this.names = dn.names; }\n\n    ### Response: Parse the supplied String and make this instance represent the\ncorresponding distinguished name.\n\n@param path the LDAP path to parse..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DistinguishedName buildDn(String username) { DistinguishedName dn = new DistinguishedName(userDnBase); dn.add(usernameAttribute, username); return dn; }\n\n    ### Response:", "ground_truth": "Assembles the Distinguished Name that should be used the given username.", "predict": " Build a DistinguishedName object for the given username, using the\nconfigured base DN and attribute name.\n\n@param username the username to build the DN for."}, {"ID": 213, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Map<Class<? extends Annotation>, Set<Locale>> getAnnotationToLocaleMapping() { Map<Class<? extends Annotation>, Set<Locale>> res = new HashMap<Class<? extends Annotation>, Set<Locale>>(); for (Entry<Class<? extends Annotation>, C10NAnnotationBinder> entry : annotationBinders.entrySet()) { Set<Locale> locales = getLocales(entry.getKey(), res); locales.add(entry.getValue().getLocale()); } return res; }\n\n    ### Response: For each annotation bound in this configuration find all\nlocales it has been bound to.\n\n@return annotation -&gt; set of locale mapping.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<Class<? extends Object>, Object> createSharedObjects() { Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>(); sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects()); sharedObjects.put(UserDetailsService.class, userDetailsService()); sharedObjects.put(ApplicationContext.class, context); sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy); sharedObjects.put(AuthenticationTrustResolver.class, trustResolver); return sharedObjects; }\n\n    ### Response:", "ground_truth": "Creates the shared objects\n\n@return the shared Objects", "predict": " Create a map of shared objects for the Spring Security\nFilterChainProxy.\n\n@return map of shared objects for the Spring Security FilterChainProxy."}, {"ID": 214, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parse() { template = text; if (StringUtils.isEmptyTrimmed(template)) return; int index = 0; while (template.indexOf(\"${\") != -1) { int from = template.lastIndexOf(\"${\"); int to = template.indexOf(\"}\", from + 2); if (to == -1) { template = text; complex = false; entities.clear(); return; } int dv = template.indexOf(\":\", from + 2); if (dv != -1 && dv > to) { dv = -1; } String systemProperty = null; String defaultValue = null; String s = template.substring(from + 2, to); if (\"/\".equals(s)) { systemProperty = File.separator; } else if (\":\".equals(s)) { systemProperty = File.pathSeparator; dv = -1; } else { systemProperty = SecurityActions.getSystemProperty(s); } if (dv != -1) { s = template.substring(from + 2, dv); systemProperty = SecurityActions.getSystemProperty(s); defaultValue = template.substring(dv + 1, to); } String prefix = \"\"; String postfix = \"\"; String key = StringUtils.createKey(index++); updateComplex(defaultValue); entities.put(key, new Expression(s, defaultValue, systemProperty)); if (from != 0) { prefix = template.substring(0, from); } if (to + 1 < template.length()) { postfix = template.substring(to + 1); } template = prefix + key + postfix; } updateComplex(template); }\n\n    ### Response: Parse a text and get a template and expression entities.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void configureJaasUsingLoop() throws IOException { String loginConfigUrl = convertLoginConfigToUrl(); boolean alreadySet = false; int n = 1; final String prefix = \"login.config.url.\"; String existing; while ((existing = Security.getProperty(prefix + n)) != null) { alreadySet = existing.equals(loginConfigUrl); if (alreadySet) { break; } n++; } if (!alreadySet) { String key = prefix + n; log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl); Security.setProperty(key, loginConfigUrl); } }\n\n    ### Response:", "ground_truth": "Loops through the login.config.url.1,login.config.url.2 properties looking for the\nlogin configuration. If it is not set, it will be set to the last available\nlogin.config.url.X property.", "predict": " Configure JAAS using a loop to set the login configuration URL.\n\n    "}, {"ID": 215, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getCurrentDate() { synchronized (FORMAT) { long now = System.currentTimeMillis(); return FORMAT.format(new Date(now)); } }\n\n    ### Response: Get the current date in HTTP format.\n\n@return the HTTP date..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getCurrentDate() { long now = System.currentTimeMillis(); if ((now - currentDateGenerated) > 1000) { synchronized (format) { if ((now - currentDateGenerated) > 1000) { currentDateGenerated = now; currentDate = format.format(new Date(now)); } } } return currentDate; }\n\n    ### Response:", "ground_truth": "Gets the current date in HTTP format.\n\n@return Current date in HTTP format", "predict": " Get the current date in HTTP format.\n\n@return the HTTP date."}, {"ID": 216, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long parseDate(String value) { Date date = null; for (SimpleDateFormat format : FORMATS_TEMPLATE) { try { date = format.parse(value); } catch (ParseException e) { // Nothing. } } if (date == null) return -1L; return date.getTime(); }\n\n    ### Response: Try to parse the given date as a HTTP date.\n\n@param value the HTTP date.\n\n@return the date as a long..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Long internalParseDate(String value, DateFormat[] formats) { Date date = null; for (int i = 0; (date == null) && (i < formats.length); i++) { try { date = formats[i].parse(value); } catch (ParseException ignored) { } } if (date == null) { return null; } return new Long(date.getTime()); }\n\n    ### Response:", "ground_truth": "Parses date with given formatters.\n\n@param value The string to parse\n@param formats Array of formats to use\n\n@return Parsed date (or null if no formatter mached)", "predict": " Parse the given date using the given date formats.\n\n@param value the date to parse.\n@param formats the date formats to use.\n\n@return the parsed date as a Long or null if it could not be parsed."}, {"ID": 217, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static synchronized void addToCache(Cache cache, byte[] encoding, Object value) { if (encoding.length > ENC_MAX_LENGTH) { return; } Object key = new Cache.EqualByteArray(encoding); cache.put(key, value); }\n\n    ### Response: Add the X509CertImpl or X509CRLImpl to the cache..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private static void updateCache(HashMap cache, Object key, Object value) { if (value == null) { return; } if (cache.size() > 1000) { cache.clear(); } cache.put(key, value); }\n\n    ### Response:", "ground_truth": "Updates cache.\n\n@param cache Cache to be updated\n@param key Key to be updated\n@param value New value", "predict": " Update the cache with the given key and value. If the value is null, do not update the cache. If the cache size exceeds 1000, clear the cache."}, {"ID": 218, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initBinder(final HttpServletRequest request, final ServletRequestDataBinder binder) { if (serviceValidateConfigurationContext.isRenewEnabled()) { binder.setRequiredFields(CasProtocolConstants.PARAMETER_RENEW); } }\n\n    ### Response: Initialize the binder with the required fields.\n\n@param request the request\n@param binder  the binder.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); }\n\n    ### Response:", "ground_truth": "Provided so that subclasses may configure what is put into the authentication\nrequest's details property.\n\n@param request that an authentication request is being created for\n@param authRequest the authentication request object that should have its details\nset", "predict": " Set the details of the authentication request.\n\n@param request the request\n@param authRequest the authentication request."}, {"ID": 219, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String resolveIdentity(SocketAddress address, IoSessionEx session) { if (address instanceof ResourceAddress) { Subject subject = session.getSubject(); if (subject == null) { subject = new Subject(); } return resolveIdentity((ResourceAddress) address, subject); } return null; }\n\n    ### Response: Method performing identity resolution - attempts to extract a subject from the current\nIoSessionEx session\n@param address\n@param session\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getSecurityName(final Subject subject) { if (logger.isDebugEnabled()) { logger.debug(\"Determining Websphere security name for subject \" + subject); } String userSecurityName = null; if (subject != null) { // SEC-803 Object credential = subject.getPublicCredentials(getWSCredentialClass()) .iterator().next(); if (credential != null) { userSecurityName = (String) invokeMethod(getSecurityNameMethod(), credential); } } if (logger.isDebugEnabled()) { logger.debug(\"Websphere security name is \" + userSecurityName + \" for subject \" + subject); } return userSecurityName; }\n\n    ### Response:", "ground_truth": "Get the security name for the given subject.\n\n@param subject The subject for which to retrieve the security name\n@return String the security name for the given subject", "predict": " Method to retrieve the Websphere security name for a given subject\n@param subject\n@return the Websphere security name for the given subject.\n\n    "}, {"ID": 220, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private java.util.Iterator findParentGroupsForEntity(String memberKey, int type) throws GroupsException { Connection conn = null; Collection groups = new ArrayList(); IEntityGroup eg = null; try { conn = RDBMServices.getConnection(); String sql = getFindParentGroupsForEntitySql(); PreparedStatement ps = conn.prepareStatement(sql); try { ps.setString(1, memberKey); ps.setInt(2, type); if (LOG.isDebugEnabled()) LOG.debug( \"RDBMEntityGroupStore.findParentGroupsForEntity(): \" + ps + \" (\" + memberKey + \", \" + type + \", memberIsGroup = F)\"); ResultSet rs = ps.executeQuery(); try { while (rs.next()) { eg = instanceFromResultSet(rs); groups.add(eg); } } finally { rs.close(); } } finally { ps.close(); } } catch (Exception e) { LOG.error(\"RDBMEntityGroupStore.findParentGroupsForEntity(): \" + e); throw new GroupsException(\"Problem retrieving containing groups: \" + e); } finally { RDBMServices.releaseConnection(conn); } return groups.iterator(); }\n\n    ### Response: Find the groups associated with this member key.\n\n@param memberKey\n@param type\n@return java.util.Iterator.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception e) { logger.error(\"Exception occured while looking up groups for user\", e); throw new RuntimeException( \"Exception occured while looking up groups for user\", e); } finally { try { if (ic != null) { ic.close(); } } catch (NamingException e) { logger.debug(\"Exception occured while closing context\", e); } } }\n\n    ### Response:", "ground_truth": "Get the WebSphere group names for the given security name.\n\n@param securityName The security name for which to retrieve the WebSphere group\nnames\n@return the WebSphere group names for the given security name", "predict": " Get the WebSphere groups for the given security name.\n\n@param securityName\n@return List<String>."}, {"ID": 221, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void changePassword(final String oldPassword, final String newPassword) { final Authentication currentUser = SecurityContextHolder.getContext().getAuthentication(); final String username = currentUser.getName(); if (authenticationManager == null) { logger.debug( \"No authentication manager set. can't change Password!\"); return; } else { logger.debug(\"Re-authenticating user '\" + username + \"' for password change request.\"); authenticationManager.authenticate( new UsernamePasswordAuthenticationToken(username, oldPassword)); } logger.debug(\"Changing password for user '\" + username + \"'\"); final SecurityUser user = (SecurityUser) loadUserByUsername(username); user.setPassword(passwordEncoder.encode(newPassword)); users.add(user); }\n\n    ### Response: Change password of current user.\n\n@param oldPassword old password\n@param newPassword new password.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void changePassword(final String oldPassword, final String newPassword) { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); Assert.notNull( authentication, \"No authentication object found in security context. Can't change current user's password!\"); String username = authentication.getName(); logger.debug(\"Changing password for user '\" + username); DistinguishedName userDn = usernameMapper.buildDn(username); if (usePasswordModifyExtensionOperation) { changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword); } else { changePasswordUsingAttributeModification(userDn, oldPassword, newPassword); } }\n\n    ### Response:", "ground_truth": "Changes the password for the current user. The username is obtained from the\nsecurity context.\n\nThere are two supported strategies for modifying the user's password depending on\nthe capabilities of the corresponding LDAP server.\n\n\nConfigured one way, this method will modify the user's password via the\n\nLDAP Password Modify Extended Operation\n.\n\nSee {@link LdapUserDetailsManager#setUsePasswordModifyExtensionOperation(boolean)} for details.\n\n\nBy default, though, if the old password is supplied, the update will be made by rebinding as the user,\nthus modifying the password using the user's permissions. If\noldPassword is null, the update will be attempted using a standard\nread/write context supplied by the context source.\n\n\n@param oldPassword the old password\n@param newPassword the new value of the password.", "predict": " Change password of current user.\n\n@param oldPassword old password\n@param newPassword new password."}, {"ID": 222, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void parse(String path) { DnParser parser = DefaultDnParserFactory.createDnParser(unmangleCompositeName(path)); DistinguishedName dn; try { dn = parser.dn(); } catch (ParseException e) { throw new BadLdapGrammarException(\"Failed to parse DN\", e); } catch (TokenMgrError e) { throw new BadLdapGrammarException(\"Failed to parse DN\", e); } this.names = dn.names; }\n\n    ### Response: Parse the supplied String and make this instance represent the\ncorresponding distinguished name.\n\n@param path the LDAP path to parse..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DistinguishedName buildGroupDn(String group) { DistinguishedName dn = new DistinguishedName(groupSearchBase); dn.add(groupRoleAttributeName, group.toLowerCase()); return dn; }\n\n    ### Response:", "ground_truth": "Creates a DN from a group name.\n\n@param group the name of the group\n@return the DN of the corresponding group, including the groupSearchBase", "predict": " Build a distinguished name for the specified group.\n\n@param group the name of the group to build the distinguished name for.\n\n    "}, {"ID": 223, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean send(String topic, String message) throws IOException { List<Session> sessions = topicSubscribers.get(topic); if (sessions != null) { for (Session session : sessions) { session.getBasicRemote().sendText(message); } } return sessions != null; }\n\n    ### Response: Returns true if any subscribers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\")); } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null; for (SessionInformation session : sessions) { if ((leastRecentlyUsed == null) || session.getLastRequest() .before(leastRecentlyUsed.getLastRequest())) { leastRecentlyUsed = session; } } leastRecentlyUsed.expireNow(); }\n\n    ### Response:", "ground_truth": "Allows subclasses to customise behaviour when too many sessions are detected.\n\n@param sessions either null or all unexpired sessions associated with\nthe principal\n@param allowableSessions the number of concurrent sessions the user is allowed to\nhave\n@param registry an instance of the SessionRegistry for subclass use", "predict": " This method is called when the maximum number of allowable sessions has been exceeded for a particular principal. It will invalidate the least recently used session and throw a SessionAuthenticationException if the exceptionIfMaximumExceeded flag is set to true. Otherwise, it will simply log a warning message."}, {"ID": 224, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Authentication createAuthentication(HttpServletRequest request, ConsumerAuthentication authentication, OAuthAccessProviderToken authToken) { if (authToken != null) { Authentication userAuthentication = authToken.getUserAuthentication(); if (userAuthentication instanceof AbstractAuthenticationToken) { //initialize the details with the consumer that is actually making the request on behalf of the user. ((AbstractAuthenticationToken) userAuthentication).setDetails(new OAuthAuthenticationDetails(request, authentication.getConsumerDetails())); } return userAuthentication; } return authentication; }\n\n    ### Response: Default implementation returns the user authentication associated with the auth token, if the token is provided. Otherwise, the consumer authentication\nis returned.\n\n@param request The request that was successfully authenticated.\n@param authentication The consumer authentication (details about how the request was authenticated).\n@param authToken The OAuth token associated with the authentication. This token MAY be null if no authenticated token was needed to successfully\nauthenticate the request (for example, in the case of 2-legged OAuth).\n@return The authentication..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void copyDetails(Authentication source, Authentication dest) { if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) { AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest; token.setDetails(source.getDetails()); } }\n\n    ### Response:", "ground_truth": "Copies the authentication details from a source Authentication object to a\ndestination one, provided the latter does not already have one set.\n\n@param source source authentication\n@param dest the destination authentication object", "predict": "Copies the details from the source authentication to the destination authentication, if the destination authentication is an instance of AbstractAuthenticationToken and the details are null.\n\n@param source The source authentication.\n@param dest The destination authentication."}, {"ID": 225, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<PortletFilter> getFilters(PortletRequest request) { for (PortletSecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; }\n\n    ### Response: Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Filter> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; }\n\n    ### Response:", "ground_truth": "Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain", "predict": " Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain."}, {"ID": 226, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Filter> getAllFiltersForField(String field) { List<Filter> foundFilters = new ArrayList<>(); for (Filter filter : this.filters) { if (filter.getField().equals(field)) { foundFilters.add(filter); } } return Collections.unmodifiableList(foundFilters); }\n\n    ### Response: Returns all filters for a field\n\n@param field name of the field\n@return a collection of filters for the field. Empty collection if no filter exists.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Filter> getFilters(String url) { return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest()))); }\n\n    ### Response:", "ground_truth": "Convenience method, mainly for testing.\n\n@param url the URL\n@return matching filter list", "predict": " Returns all filters for a given URL\n\n@param url the URL for which to get the filters\n@return a collection of filters for the URL. Empty collection if no filter exists."}, {"ID": 227, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TemplatedURLFormatter getTemplatedURLFormatter( ServletContext servletContext ) { assert servletContext != null : \"The ServletContext cannot be null.\"; if ( servletContext == null ) { throw new IllegalArgumentException( \"The ServletContext cannot be null.\" ); } return ( TemplatedURLFormatter ) servletContext.getAttribute( TEMPLATED_URL_FORMATTER_ATTR ); }\n\n    ### Response: Gets the TemplatedURLFormatter instance from a ServletContext attribute.\n\n@param servletContext the current ServletContext.\n@return the TemplatedURLFormatter instance from the ServletContext..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ApplicationContext getContext(PageContext pageContext) { ServletContext servletContext = pageContext.getServletContext(); return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext); }\n\n    ### Response:", "ground_truth": "Allows test cases to override where application context obtained from.\n\n@param pageContext so the ServletContext can be accessed as required\nby Spring's WebApplicationContextUtils\n\n@return the Spring application context (never null)", "predict": " Gets the ApplicationContext instance from a PageContext.\n\n@param pageContext the current PageContext.\n@return the ApplicationContext instance from the PageContext."}, {"ID": 228, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DistinguishedName immutableDistinguishedName() { List listWithImmutableRdns = new ArrayList(names.size()); for (Iterator iterator = names.iterator(); iterator.hasNext();) { LdapRdn rdn = (LdapRdn) iterator.next(); listWithImmutableRdns.add(rdn.immutableLdapRdn()); } return new DistinguishedName(Collections.unmodifiableList(listWithImmutableRdns)); }\n\n    ### Response: Return an immutable copy of this instance. It will not be possible to add\nor remove any Rdns to or from the returned instance, and the respective\nRdns will also be immutable in turn.\n\n@return a copy of this instance backed by an immutable list.\n@since 1.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException { DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace()); if (dn.contains(baseDn)) { return dn; } baseDn.append(dn); return baseDn; }\n\n    ### Response:", "ground_truth": "Gets the full dn of a name by prepending the name of the context it is relative to.\nIf the name already contains the base name, it is returned unaltered.", "predict": " Returns a new DistinguishedName that is the concatenation of the base DistinguishedName and the provided DistinguishedName. If the provided DistinguishedName already contains the base DistinguishedName, the provided DistinguishedName is returned unchanged.\n\n@param dn the DistinguishedName to append to the base DistinguishedName\n@param baseCtx the Context to use as the base DistinguishedName\n@return a new DistinguishedName that is the concatenation of the base DistinguishedName and the provided DistinguishedName\n@throws NamingException if an error occurs while retrieving the base DistinguishedName from the Context"}, {"ID": 229, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setSessionAttributes(Map<String, Object> sessionAttributes) { if (requestEnvelope.getSession() == null) { throw new IllegalStateException(\"Attempting to set session attributes for out of session request\"); } this.sessionAttributes = sessionAttributes; }\n\n    ### Response: Sets session attributes, replacing any existing attributes already present in the session. An exception is thrown\nif this method is called while processing an out of session request. Use this method when bulk replacing attributes\nis desired.\n\n@param sessionAttributes session attributes to set\n@throws IllegalStateException if attempting to retrieve session attributes from an out of session request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) { notNull(sessionAttributes, \"sessionAttributes\"); parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes); return this; }\n\n    ### Response:", "ground_truth": "Set session attributes.\n\n@param sessionAttributes the session attributes", "predict": " Adds session attributes to the request specification. If the request is an out of session request, an exception is thrown.\n\n@param sessionAttributes session attributes to add\n@return the updated request specification\n@throws IllegalStateException if attempting to add session attributes to an out of session request."}, {"ID": 230, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private AuthData generateDirectoryAuthData(String userName, String password) { if(password != null && ! password.isEmpty()){ byte[] secret = ObfuscatUtil.base64Encode(password.getBytes()); return new AuthData(AuthScheme.DIRECTORY, userName, secret, true); } else { return new AuthData(AuthScheme.DIRECTORY, userName, null, false); } }\n\n    ### Response: Generate the obfuscated auth data.\n\n@param userName\nthe user name.\n@param password\nthe password.\n@return\nthe AuthData..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AuthenticationScheme basic(String userName, String password) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme(); preemptiveBasicAuthScheme.setUserName(userName); preemptiveBasicAuthScheme.setPassword(password); return preemptiveBasicAuthScheme; }\n\n    ### Response:", "ground_truth": "", "predict": " Generate the preemptive basic authentication scheme.\n\n@param userName\nthe user name.\n@param password\nthe password.\n@return\nthe PreemptiveBasicAuthScheme."}, {"ID": 231, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> void initialize(final Log log, final List<Filter<T>> filters) { // Check sanity Validate.notNull(log, \"log\"); Validate.notNull(filters, \"filters\"); for (Filter<T> current : filters) { current.initialize(log); } }\n\n    ### Response: Initializes the supplied Filters by assigning the given Log.\n\n@param log     The active Maven Log.\n@param filters The List of Filters to initialize.\n@param      The Filter type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void filters(List<Filter> filters) { Validate.notNull(filters, \"Filter list cannot be null\"); RestAssured.filters.addAll(filters); }\n\n    ### Response:", "ground_truth": "Add default filters that will be applied to each request.\n\n@param filters The filter list", "predict": " Adds the given List of Filters to the RestAssured global Filter list.\n\n@param filters The List of Filters to add."}, {"ID": 232, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void validate() { if (host.isEmpty()) { throw new IllegalArgumentException(\"host cannot be null\"); } if (catalog == null) { throw new IllegalArgumentException(\"namespace cannot be null\"); } if (table == null) { throw new IllegalArgumentException(\"set cannot be null\"); } if (portList.isEmpty()) { if(port>0){ port(port); }else{ throw new IllegalArgumentException(\"port cannot be null\"); } } if (host.size() != portList.size()) { throw new IllegalArgumentException(\"Host and ports cardinality must be the same\"); } }\n\n    ### Response: Validates connection parameters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void filters(Filter filter, Filter... additionalFilters) { Validate.notNull(filter, \"Filter cannot be null\"); RestAssured.filters.add(filter); if (additionalFilters != null) { Collections.addAll(RestAssured.filters, additionalFilters); } }\n\n    ### Response:", "ground_truth": "Add default filters to apply to each request.\n\n@param filter            The filter to add\n@param additionalFilters An optional array of additional filters to add", "predict": " Adds a filter to the RestAssured filter list.\n\n    "}, {"ID": 233, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRequestScheme(HttpServletRequest req) { String scheme; if (req.getScheme() != null) scheme = req.getScheme().toUpperCase(); else scheme = AuditEvent.REASON_TYPE_HTTP; return scheme; }\n\n    ### Response: Get the scheme from the request - generally \"HTTP\" or HTTPS\"\n\n@param req\n@return the scheme.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme basic(String userName, String password) { final BasicAuthScheme scheme = new BasicAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); return scheme; }\n\n    ### Response:", "ground_truth": "", "predict": " Create a basic authentication scheme with the given username and password.\n\n@param userName\n@param password\n@return the basic authentication scheme."}, {"ID": 234, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRequestScheme(HttpServletRequest req) { String scheme; if (req.getScheme() != null) scheme = req.getScheme().toUpperCase(); else scheme = AuditEvent.REASON_TYPE_HTTP; return scheme; }\n\n    ### Response: Get the scheme from the request - generally \"HTTP\" or HTTPS\"\n\n@param req\n@return the scheme.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) { final NTLMAuthScheme scheme = new NTLMAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setWorkstation(workstation); scheme.setDomain(domain); return scheme; }\n\n    ### Response:", "ground_truth": "Create a NTLM authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@param workstation The NTLM workstation.\n@param domain The NTLM workstation.\n@return The authentication scheme", "predict": " Create a new NTLM authentication scheme with the given user name, password, workstation, and domain.\n\n@param userName\n@param password\n@param workstation\n@param domain\n@return the NTLM authentication scheme."}, {"ID": 235, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addUser(String userName, String userRealm, char[] password, String... groups) { if (userName == null) { throw new IllegalArgumentException(\"userName is null\"); } if (userRealm == null) { throw new IllegalArgumentException(\"userRealm is null\"); } if (password == null) { throw new IllegalArgumentException(\"password is null\"); } final String canonUserRealm = userRealm.toLowerCase().trim(); final String canonUserName = userName.toLowerCase().trim(); synchronized (map) { Map<String, Entry> realmMap = map.get(canonUserRealm); if (realmMap == null) { realmMap = new HashMap<String, Entry>(); map.put(canonUserRealm, realmMap); } realmMap.put(canonUserName, new Entry(canonUserName, canonUserRealm, password, groups != null ? groups : new String[0])); } }\n\n    ### Response: Add a user to the authentication table.\n\n@param userName\nthe user name\n@param userRealm\nthe user realm\n@param password\nthe password\n@param groups\nthe groups the user belongs to.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; }\n\n    ### Response:", "ground_truth": "Use form authentication with the supplied configuration.\n\n@param userName The user name.\n@param password The password.\n@param config   The form authentication config\n@return The authentication scheme", "predict": " Create a new form authentication scheme.\n\n@param userName\nthe user name\n@param password\nthe password\n@param config\nthe form authentication configuration\n\n    "}, {"ID": 236, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String formatKey(URI uri) throws URISyntaxException { if (uri == null) { throw new URISyntaxException(\"\",\"URI specified is null\"); } return formatKey(uri.getHost(), uri.getPort()); }\n\n    ### Response: Converts a well-formed URI containing a hostname and port into\nstring which allows for lookups in the Security Domain table\n@param uri URI to convert\n@return A string with \"host:port\" concatenated\n@throws URISyntaxException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void proxy(URI uri) { if (uri == null) { throw new IllegalArgumentException(\"Proxy URI cannot be null\"); } proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme())); }\n\n    ### Response:", "ground_truth": "Instruct REST Assured to connect to a proxy using a URI.\n\n@param uri The URI of the proxy", "predict": " Sets up a proxy for the specified URI\n@param uri URI to use for proxy configuration\n@throws IllegalArgumentException if the URI is null or invalid\n\n    "}, {"ID": 237, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nonnull public List<String> getRemainingLines(boolean trimAndSkipEmpty) throws IOException { List<String> out = new ArrayList<>(); StringBuilder builder = new StringBuilder(); while (bufferOffset <= bufferLimit || !bufferLineEnd) { if (!readNextChar()) { break; } if (lastChar == '\\n') { String line = builder.toString(); if (!trimAndSkipEmpty || !line.trim().isEmpty()) { out.add(trimAndSkipEmpty ? line.trim() : line); } builder = new StringBuilder(); } else { builder.append((char) lastChar); } } if (builder.length() > 0) { String line = builder.toString(); if (!trimAndSkipEmpty || !line.trim().isEmpty()) { out.add(builder.toString()); } } return out; }\n\n    ### Response: Read the rest of input from the reader, and get the lines from there.\nThis will consume the rest of the content of the reader.\n\n@param trimAndSkipEmpty If lines should be trimmed and empty lines should\nbe skipped.\n@return List of lines after the current.\n@throws IOException When failing to read stream to end..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if (shouldPrettyPrint) { responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody); } else { responseBodyToAppend = responseBody.asString(); } if (logDetail == ALL && !isBlank(responseBodyToAppend)) { builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR); } builder.append(responseBodyToAppend); } String response = builder.toString(); stream.println(response); return response; }\n\n    ### Response:", "ground_truth": "Prints the response to the print stream\n\n@return A string of representing the response", "predict": " Print the response to the given stream.\n\n@param responseOptions The response options to print.\n@param responseBody The response body to print.\n@param stream The stream to print to.\n@param logDetail The log detail to print.\n@param shouldPrettyPrint If the response body should be pretty printed.\n@return The printed response."}, {"ID": 238, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function getEntityConfig(string $entity): array { if (!array_key_exists($entity, $this->configValues['entities'])) { throw new \\InvalidArgumentException(\"$entity is not set in config\"); } return $this->configValues['entities'][$entity]; }\n\n    ### Response: Get config values for an entity\n\n@param  string $entity\n\n@throws \\InvalidArgumentException\n@return array            Config Values.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredConfig redirect(RedirectConfig redirectConfig) { notNull(redirectConfig, \"Redirect config\"); return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); }\n\n    ### Response:", "ground_truth": "Set the redirect config.\n\n@param redirectConfig The {@link RedirectConfig} to set\n@return An updated RestAssuredConfiguration", "predict": " Set the redirect config for RestAssured\n\n@param  RedirectConfig redirectConfig\n\n@return RestAssuredConfig  New RestAssuredConfig with the redirect config set."}, {"ID": 239, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Part<T> charset(Charset charset) { requireNonNull(charset); return new Part<>(name, fileName, body, contentType, charset, partWriter); }\n\n    ### Response: The charset of this part's content. Each part of MultiPart body can has it's own charset set.\nDefault not set.\n\n@param charset the charset\n@return self.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EncoderConfig defaultQueryParameterCharset(String charset) { return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true); }\n\n    ### Response:", "ground_truth": "Specify the default charset for query parameters\n\n@param charset The charset to use.\n@return A new instance of {@link EncoderConfig}", "predict": " The default query parameter charset to use when encoding query parameters.\n\n@param charset the charset\n@return self."}, {"ID": 240, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function any(\\Closure $function = null, array $args = []) { if ($this->isMatched) { return new static($this->value, $this->isMatched); } if (is_null($function)) { return new static($this->value, true); } return new static($this->callFunction($function, $this->value, $args), true); }\n\n    ### Response: Match anything. Usually called last in Match chain\n\n@param callable|\\Closure $function\n@param array $args Optional additional arguments to function\n@return Match.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); }\n\n    ### Response:", "ground_truth": "Creates an object mapper configuration that uses the specified object mapper as default.\n\n@param defaultObjectMapperType The object mapper to use. If null then classpath scanning will be used.", "predict": " Set the default ObjectMapper type.\n\n@param ObjectMapperType defaultObjectMapperType The default ObjectMapper type to set.\n@return ObjectMapperConfig."}, {"ID": 241, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function any(\\Closure $function = null, array $args = []) { if ($this->isMatched) { return new static($this->value, $this->isMatched); } if (is_null($function)) { return new static($this->value, true); } return new static($this->callFunction($function, $this->value, $args), true); }\n\n    ### Response: Match anything. Usually called last in Match chain\n\n@param callable|\\Closure $function\n@param array $args Optional additional arguments to function\n@return Match.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); }\n\n    ### Response:", "ground_truth": "Specify a custom JAXB object mapper factory.\n\n@param jaxbObjectMapperFactory The object mapper factory", "predict": " Configure ObjectMapper for Jaxb.\n\n@param JAXBObjectMapperFactory jaxbObjectMapperFactory\n@return ObjectMapperConfig."}, {"ID": 242, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) { notNull(logConfig, \"Log config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Log config.\n\n@param logConfig The {@link LogConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Creates a new RestAssuredMockMvcConfig with the given logConfig.\n@param logConfig The log configuration to use."}, {"ID": 243, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) { notNull(sessionConfig, \"Session config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the session config.\n\n@param sessionConfig The {@link SessionConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Creates a new RestAssuredMockMvcConfig with the specified session config.\n@param sessionConfig The session config to use."}, {"ID": 244, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) { notNull(objectMapperConfig, \"Object mapper config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the object mapper config.\n\n@param objectMapperConfig The {@link ObjectMapperConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig.\n@param logConfig The LogConfig to use.\n@param encoderConfig The EncoderConfig to use.\n@param decoderConfig The DecoderConfig to use.\n@param sessionConfig The SessionConfig to use.\n@param objectMapperConfig The ObjectMapperConfig to use.\n@param jsonConfig The JsonConfig to use.\n@param xmlConfig The XmlConfig to use.\n@param headerConfig The HeaderConfig to use.\n@param asyncConfig The AsyncConfig to use.\n@param multiPartConfig The MultiPartConfig to use.\n@param mockMvcConfig The MockMvcConfig to use.\n@param paramConfig The ParamConfig to use.\n@param matcherConfig The MatcherConfig to use.\n\n    "}, {"ID": 245, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) { notNull(jsonConfig, \"JsonConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Json config.\n\n@param jsonConfig The {@link JsonConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig.\n@param jsonConfig The JsonConfig to use."}, {"ID": 246, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) { notNull(xmlConfig, \"XmlConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Xml config.\n\n@param xmlConfig The {@link XmlConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig.\n@param xmlConfig The XmlConfig to use."}, {"ID": 247, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) { notNull(encoderConfig, \"EncoderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the encoder config\n\n@param encoderConfig The {@link EncoderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig.\n@param encoderConfig The EncoderConfig to use."}, {"ID": 248, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) { notNull(headerConfig, \"HeaderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the header config\n\n@param headerConfig The {@link HeaderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Creates a new RestAssuredMockMvcConfig with the given headerConfig.\n@param headerConfig The header config to use."}, {"ID": 249, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) { notNull(asyncConfig, AsyncConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the async config\n\n@param asyncConfig The {@link AsyncConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig with AsyncConfig.\n@param asyncConfig The AsyncConfig to use."}, {"ID": 250, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) { notNull(mockMvcConfig, MockMvcConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the MockMVC config\n\n@param mockMvcConfig The {@link MockMvcConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig.\n@param mockMvcConfig The MockMvcConfig to use."}, {"ID": 251, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) { notNull(multiPartConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the multi-part config\n\n@param multiPartConfig The {@link MultiPartConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Creates a new RestAssuredMockMvcConfig with the given MultiPartConfig.\n@param multiPartConfig The MultiPartConfig to use."}, {"ID": 252, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) { notNull(paramConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the parameter config\n\n@param paramConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig with additional parameter for MockMvcParamConfig.\n@param paramConfig The MockMvcParamConfig to use."}, {"ID": 253, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure(String xmlConfig, File voltroot) { try { Class<?> loggerClz = Class.forName(\"org.voltcore.logging.VoltLog4jLogger\"); assert(loggerClz != null); Method configureMethod = loggerClz.getMethod(\"configure\", String.class, File.class); configureMethod.invoke(null, xmlConfig, voltroot); } catch (Exception e) {} }\n\n    ### Response: Static method to change the Log4j config globally. This fails\nif you're not using Log4j for now.\n@param xmlConfig The text of a Log4j config file.\n@param voltroot The VoltDB root path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) { notNull(matcherConfig, MatcherConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the matcher config\n\n@param matcherConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Constructor for RestAssuredMockMvcConfig with a MatcherConfig parameter.\n@param matcherConfig The MatcherConfig to use for matching requests and responses."}, {"ID": 254, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean waitForServerUp(int zkPort, boolean secureZk, String trustStore, String keyStore, String keyStorePasswordPath, String trustStorePasswordPath) { val address = LOOPBACK_ADDRESS + \":\" + zkPort; if (secureZk) { return waitForSSLServerUp(address, LocalBookKeeper.CONNECTION_TIMEOUT, trustStore, keyStore, keyStorePasswordPath, trustStorePasswordPath); } else { return LocalBookKeeper.waitForServerUp(address, LocalBookKeeper.CONNECTION_TIMEOUT); } }\n\n    ### Response: Blocks the current thread and awaits ZooKeeper to start running locally on the given port.\n\n@param zkPort The ZooKeeper Port.\n@param secureZk Flag to notify whether the ZK is secure.\n@param trustStore Location of the trust store.\n@param keyStore Location of the key store.\n@param keyStorePasswordPath Location of password path for key store.\nEmpty string if `secureZk` is false or a password does not exist.\n@param trustStorePasswordPath Location of password path for trust store.\nEmpty string if `secureZk` is false or a password does not exist.\n@return True if ZooKeeper started within a specified timeout, false otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CertificateAuthSettings allowAllHostnames() { return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory); }\n\n    ### Response:", "ground_truth": "", "predict": " Creates a new CertificateAuthSettings object with the given parameters.\n\n@param keystoreType The keystore type.\n@param trustStoreType The truststore type.\n@param port The port to connect to.\n@param trustStore The location of the truststore.\n@param keyStore The location of the keystore.\n@param sslSocketFactory The SSLSocketFactory to use.\n@return A new CertificateAuthSettings object with the given parameters."}, {"ID": 255, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Document parse(Reader reader, boolean validating, boolean namespaceAware) throws SAXException, IOException, ParserConfigurationException { return parse(reader, validating, namespaceAware, false); }\n\n    ### Response: Creates a DocumentBuilder and uses it to parse the XML text read from the given reader, allowing\nparser validation and namespace awareness to be controlled. Documents are not allowed to contain\nDOCYTYPE declarations.\n\n@param reader         the reader to read the XML text from\n@param validating     whether to validate the XML\n@param namespaceAware whether the parser should be namespace aware\n@return the root node of the parsed tree of Nodes\n@throws SAXException                 Any SAX exception, possibly wrapping another exception.\n@throws IOException                  An IO exception from the parser, possibly from a byte\nstream or character stream supplied by the application.\n@throws ParserConfigurationException if a DocumentBuilder cannot be created which satisfies\nthe configuration requested..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); }\n\n    ### Response:", "ground_truth": "Specify declared namespaces that will be used when parsing XML.\n\n@param namespacesToDeclare A map containing features that will be used by the underlying {@link groovy.util.XmlSlurper}.\n@return A new instance of XmlPathConfig\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Creates a new XmlPathConfig object with the given parameters.\n\n@param jaxbObjectMapperFactory the JaxbObjectMapperFactory to use for creating ObjectMapper instances\n@param defaultParserType       the default parser type to use for parsing XML\n@param defaultDeserializer     the default deserializer to use for deserializing XML\n@param charset                 the charset to use for parsing XML\n@param features                the features to use for parsing XML\n@param namespacesToDeclare     the namespaces to declare in the XML\n@param properties              the properties to use for parsing XML\n@param validating              whether to validate the XML\n@param namespaceAware          whether the parser should be namespace aware\n@param allowDocTypeDeclaration whether to allow DOCTYPE declarations in the XML\n@return a new XmlPathConfig object with the given parameters."}, {"ID": 256, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Writer sheet(String sheetName) { if (StringUtil.isEmpty(sheetName)) { throw new IllegalArgumentException(\"sheet cannot be empty\"); } this.sheetName = sheetName; return this; }\n\n    ### Response: Configure the name of the sheet to be written. The default is Sheet0.\n\n@param sheetName sheet name\n@return Writer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) { Validate.notEmpty(prefix, \"Prefix cannot be empty\"); Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\"); Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces); updatedNamespaces.put(prefix, namespaceURI); return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration); }\n\n    ### Response:", "ground_truth": "Declares a namespace.\n\n@param prefix       The feature name, which is a fully-qualified URI.\n@param namespaceURI The requested value of the feature (true or false).\n@return A new XmlPathConfig instance\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Add a declared namespace to the configuration.\n\n@param prefix namespace prefix\n@param namespaceURI namespace URI\n@return XmlPathConfig."}, {"ID": 257, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object executeWithArgs(ExecutionType executionType, Object[] args) throws CommandActionExecutionException { if(ExecutionType.ASYNCHRONOUS == executionType){ Closure closure = AsyncClosureFactory.getInstance().createClosure(metaHolder, method, object, args); return executeClj(closure.getClosureObj(), closure.getClosureMethod()); } return execute(object, method, args); }\n\n    ### Response: Invokes the method. Also private method also can be invoked.\n\n@return result of execution.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); }\n\n    ### Response:", "ground_truth": "Make an HTTP request to the default URI, and parse using the default\ncontent-type.\n\n@param method        {@link HttpRequestFactory HTTP method}\n@param configClosure request configuration options\n@return whatever value was returned by the executed response handler.\n@throws ClientProtocolException\n@throws IOException\n@see #request(Object, HttpRequestFactory, Object, Closure)", "predict": " Sends a request to the server.\n\n@param method HTTP method to use for the request.\n@param hasBody true if the request has a body, false otherwise.\n@param configClosure closure that can be used to configure the request.\n@return the response from the server.\n\n    "}, {"ID": 258, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties getFieldsAsProperties(Object obj, Class<?>[] clazzes) throws Exception { Properties props = new Properties(); for (Field field : obj.getClass().getDeclaredFields()) { if (Modifier.isStatic(field.getModifiers())) continue; field.setAccessible(true); Class<?> type = field.getType(); if (clazzes == null || contains(type, clazzes)) { Object val = field.get(obj); if (val != null) props.put(field.getName(), val.toString()); } } return props; }\n\n    ### Response: Get fields as properties\n@param obj the object to get fields for\n@param clazzes the classes to use for reflection and properties.\nT\n@return the fields as properties.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setHeaders(Map<?, ?> headers) { this.defaultRequestHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultRequestHeaders.put(key.toString(), val.toString()); } }\n\n    ### Response:", "ground_truth": "Set the default headers to add to all requests made by this builder\ninstance.  These values will replace any previously set default headers.\n\n@param headers map of header names & values.", "predict": " Set headers\n@param headers the headers to set\n@throws IllegalArgumentException if the headers are null or if the key or value is not a string.\n\n    "}, {"ID": 259, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setProxy(String host, int port, String user, String pwd) { this.proxy = new Proxy(host, port, user, pwd); }\n\n    ### Response: sets proxy, optionally using basic authentication\n\n@param host\tproxy host\n@param port\tproxy port\n@param user\tproxy user or null when no authentication is needed\n@param pwd\tproxy password or null when no authentication is needed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); }\n\n    ### Response:", "ground_truth": "null for the default\n@see HttpHost#HttpHost(String, int, String)", "predict": " sets proxy for the client\n\n@param host\tproxy host\n@param port\tproxy port\n@param scheme\tproxy scheme (e.g. \"http\", \"https\", \"socks\")"}, {"ID": 260, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Writer sheet(String sheetName) { if (StringUtil.isEmpty(sheetName)) { throw new IllegalArgumentException(\"sheet cannot be empty\"); } this.sheetName = sheetName; return this; }\n\n    ### Response: Configure the name of the sheet to be written. The default is Sheet0.\n\n@param sheetName sheet name\n@return Writer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartSpecBuilder controlName(String controlName) { Validate.notEmpty(controlName, \"Control name cannot be empty\"); this.controlName = controlName; this.isControlNameExplicit = true; return this; }\n\n    ### Response:", "ground_truth": "Specify the control name of this multi-part.\n\n@param controlName The control name to use. Default is file.\n@return An instance of MultiPartSpecBuilder", "predict": " Set the control name for the multi-part upload.\n\n@param controlName control name\n@return MultiPartSpecBuilder."}, {"ID": 261, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getHeaders(HttpServletResponse response) { String headerString = \"\"; Collection<String> headerNames = response.getHeaderNames(); for (String headerName : headerNames) { // there may be multiple headers per header name for (String headerValue : response.getHeaders(headerName)) { if (headerString.length() != 0) { headerString += \"\\n\"; } headerString += headerName + \": \" + headerValue; } } return headerString; }\n\n    ### Response: Obtain newline-delimited headers from response\n\n@param response HttpServletResponse to scan\n@return newline-delimited headers.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartSpecBuilder header(String name, String value) { Validate.notEmpty(name, \"Header name cannot be empty\"); Validate.notEmpty(value, \"Header value cannot be empty\"); // Replace previous header if exists final Set<String> headerNames = headers.keySet(); final String trimmedName = name.trim(); for (String headerName : headerNames) { if (headerName.equalsIgnoreCase(trimmedName)) { headers.remove(headerName); } } // Put the name header in the header list headers.put(name, value); return this; }\n\n    ### Response:", "ground_truth": "Add a header to this multipart specification.\n\n@param name The name of the header\n@param value The value of the header\n@return An instance of MultiPartSpecBuilder", "predict": " Add a header to the MultiPartSpecBuilder\n\n@param name Name of the header\n@param value Value of the header\n@return This MultiPartSpecBuilder instance\n@throws IllegalArgumentException If the name or value is empty or null"}, {"ID": 262, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reloadPolicies(String protocol, String user, String pass) throws IOException { getServerResponse(protocol, user, pass, \"/management/control?action=reloadPolicies\"); }\n\n    ### Response: Signals for the server to reload its policies..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void basic(String host, int port, String user, String pass) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new UsernamePasswordCredentials(user, pass) ); }\n\n    ### Response:", "ground_truth": "Set authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass", "predict": " Sets the credentials for the client to use for authentication."}, {"ID": 263, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setProxy(String host, int port, String user, String pwd) { this.proxy = new Proxy(host, port, user, pwd); }\n\n    ### Response: sets proxy, optionally using basic authentication\n\n@param host\tproxy host\n@param port\tproxy port\n@param user\tproxy user or null when no authentication is needed\n@param pwd\tproxy password or null when no authentication is needed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void ntlm(String host, int port, String user, String pass, String workstation, String domain) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain) ); }\n\n    ### Response:", "ground_truth": "Set NTLM authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass\n@param workstation\n@param domain", "predict": " sets NTLM authentication credentials for the specified proxy host and port\n\n@param host\tproxy host\n@param port\tproxy port\n@param user\tNTLM user\n@param pass\tNTLM password\n@param workstation\tNTLM workstation\n@param domain\tNTLM domain"}, {"ID": 264, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private RawResponse getResponse(URL url, HttpURLConnection conn, CookieJar cookieJar, String method) throws IOException { // read result int status = conn.getResponseCode(); String host = url.getHost().toLowerCase(); String statusLine = null; // headers and cookies List<Header> headerList = new ArrayList<>(); List<Cookie> cookies = new ArrayList<>(); int index = 0; while (true) { String key = conn.getHeaderFieldKey(index); String value = conn.getHeaderField(index); if (value == null) { break; } index++; //status line if (key == null) { statusLine = value; continue; } headerList.add(new Header(key, value)); if (key.equalsIgnoreCase(NAME_SET_COOKIE)) { Cookie c = Cookies.parseCookie(value, host, Cookies.calculatePath(url.getPath())); if (c != null) { cookies.add(c); } } } Headers headers = new Headers(headerList); InputStream input; try { input = conn.getInputStream(); } catch (IOException e) { input = conn.getErrorStream(); } if (input == null) { input = InputStreams.empty(); } // update session cookieJar.storeCookies(cookies); return new RawResponse(method, url.toExternalForm(), status, statusLine == null ? \"\" : statusLine, cookies, headers, input, conn); }\n\n    ### Response: Wrap response, deal with headers and cookies.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Headers headers(Header header, Header... additionalHeaders) { notNull(header, \"Header\"); final List<Header> headerList = new LinkedList<Header>(); headerList.add(header); if (additionalHeaders != null) { Collections.addAll(headerList, additionalHeaders); } return new Headers(headerList); }\n\n    ### Response:", "ground_truth": "An alternative way to create a Headers object from the constructor.\n\n@param header            The header to be included\n@param additionalHeaders Additional headers to be included (optional)\n@return A new headers object containing the specified headers", "predict": " Create a new Headers object with the given header and additional headers."}, {"ID": 265, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { this.formatMode = null; this.roundMode = NumberRoundMode.ROUND; this.grouping = null; this.minimumIntegerDigits = null; this.maximumFractionDigits = null; this.minimumFractionDigits = null; this.maximumSignificantDigits = null; this.minimumSignificantDigits = null; }\n\n    ### Response: Reset the options to their defaults..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\n    ### Response:", "ground_truth": "Reset all static configurations to their default values.", "predict": " Reset the options to their defaults."}, {"ID": 266, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpLogEntry withRequestHeader(String name, String value) { requestHeaders.add(new Header(name, value)); return this; }\n\n    ### Response: Add a header that was on the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; }\n\n    ### Response:", "ground_truth": "Set a specific header\n\n@return The builder", "predict": " Set a header on the response."}, {"ID": 267, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function validateBody(err, body) { body = tryParse(body); if (err || !body) { return next(err || new Error('Unparsable response with statusCode ' + statusCode)); } if (statusCode !== 200) { return next(new Error(body.message || 'Invalid status code ' + statusCode)); } next(null, body); }\n\n    ### Response: If a callback is passed, validate the returned body.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; }\n\n    ### Response:", "ground_truth": "Build the actual response\n\n@return The response object", "predict": " Builds a RestAssured Response object by copying the headers, cookies, and body from the underlying RestAssured Response object. The status code is validated to ensure it falls within the range of valid status codes. If the status code is missing, it is set to the default value of 200. The response parser registrar is set to a default instance."}, {"ID": 268, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Function<Optional<Descriptor>, String> concat( final Function<? super Optional<Descriptor>, String> function1, final Function<? super Optional<Descriptor>, String> function2) { return new Function<Optional<Descriptor>, String>() { @Override public String apply(Optional<Descriptor> optDescriptor) { return function1.apply(optDescriptor) + function2.apply(optDescriptor); } }; }\n\n    ### Response: Returns a function which concatenates the outputs of the two input functions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether value of cookie satisfies specified matcher.\n@param valueMatcher value assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed value property assertion", "predict": " Sets the matcher for the value of the cookie.\n\n    "}, {"ID": 269, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Function<Optional<Descriptor>, String> concat( final Function<? super Optional<Descriptor>, String> function1, final Function<? super Optional<Descriptor>, String> function2) { return new Function<Optional<Descriptor>, String>() { @Override public String apply(Optional<Descriptor> optDescriptor) { return function1.apply(optDescriptor) + function2.apply(optDescriptor); } }; }\n\n    ### Response: Returns a function which concatenates the outputs of the two input functions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether comment of cookie satisfies specified matcher.\n@param commentMatcher comment assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed comment property assertion", "predict": " Returns a new matcher that matches cookies with a comment that matches the given matcher.\n\n    "}, {"ID": 270, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<Integer, Date> getShards(TableDefinition tableDef) { checkServiceState(); if (tableDef.isSharded()) { return m_shardCache.getShardMap(tableDef); } else { return new HashMap<>(); } }\n\n    ### Response: Get all known shards for the given table. Each shard is defined in a column in the\n\"_shards\" row of the table's Terms store. If the given table is not sharded, an\nempty map is returned.\n\n@param tableDef  Sharded table to get current shards for.\n@return          Map of shard numbers to shard start dates. May be empty but will\nnot be null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether expiry date of cookie satisfies specified matcher.\n@param expiryDateMatcher expiry date assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed expiry date property assertion", "predict": " Create a new DetailedCookieMatcher that matches cookies with an expiry date that matches the given matcher.\n\n@param expiryDateMatcher  Matcher to match the expiry date of the cookie.\n@return                   New DetailedCookieMatcher that matches cookies with an expiry date that matches the given matcher."}, {"ID": 271, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Function<Optional<Descriptor>, String> concat( final Function<? super Optional<Descriptor>, String> function1, final Function<? super Optional<Descriptor>, String> function2) { return new Function<Optional<Descriptor>, String>() { @Override public String apply(Optional<Descriptor> optDescriptor) { return function1.apply(optDescriptor) + function2.apply(optDescriptor); } }; }\n\n    ### Response: Returns a function which concatenates the outputs of the two input functions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether domain of cookie satisfies specified matcher.\n@param domainMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed domain property assertion", "predict": " Returns a new matcher that matches cookies with a domain that matches the given matcher.\n\n    "}, {"ID": 272, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Function<Optional<Descriptor>, String> concat( final Function<? super Optional<Descriptor>, String> function1, final Function<? super Optional<Descriptor>, String> function2) { return new Function<Optional<Descriptor>, String>() { @Override public String apply(Optional<Descriptor> optDescriptor) { return function1.apply(optDescriptor) + function2.apply(optDescriptor); } }; }\n\n    ### Response: Returns a function which concatenates the outputs of the two input functions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether path of cookie satisfies specified matcher.\n@param pathMatcher assertion for path property\n@return A {@link DetailedCookieMatcher} instance with and-composed path property assertion", "predict": " Adds a matcher for the path property to the matcher chain.\n\n    "}, {"ID": 273, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean every(Func1<? super T, Boolean> predicate) { for (T item : this) { if (!predicate.call(item)) return false; } return true; }\n\n    ### Response: Returns true if all of stream items satisfy a given condition.\n\n@param predicate a condition to test.\n@return true if all of stream items satisfy a given condition..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether secured property of cookie satisfies specified matcher.\n@param securedMatcher assertion for secured property\n@return A {@link DetailedCookieMatcher} instance with and-composed secured property assertion", "predict": " Returns a new matcher that matches cookies that satisfy the given condition on the \"secured\" property.\n\n@param securedMatcher a matcher to test the \"secured\" property.\n@return a new matcher that matches cookies that satisfy the given condition on the \"secured\" property."}, {"ID": 274, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean every(Func1<? super T, Boolean> predicate) { for (T item : this) { if (!predicate.call(item)) return false; } return true; }\n\n    ### Response: Returns true if all of stream items satisfy a given condition.\n\n@param predicate a condition to test.\n@return true if all of stream items satisfy a given condition..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); }\n\n    ### Response:", "ground_truth": "", "predict": " Returns a new matcher that matches cookies with a specific httpOnly value.\n\n@param httpOnlyMatcher the matcher to apply to the httpOnly property of the cookie.\n@return a new matcher that matches cookies with a specific httpOnly value."}, {"ID": 275, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Factory public static <E> Matcher<? super Collection<? extends E>> hasSize(Matcher<? super Integer> size) { return new IsCollectionWithSize<E>(size); }\n\n    ### Response: Does collection size satisfy a given matcher?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether version of cookie satisfies specified matcher.\n@param versionMatcher assertion for version property\n@return A {@link DetailedCookieMatcher} instance with and-composed version property assertion", "predict": " Matches a detailed cookie with a given version matcher."}, {"ID": 276, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Factory public static <E> Matcher<? super Collection<? extends E>> hasSize(Matcher<? super Integer> size) { return new IsCollectionWithSize<E>(size); }\n\n    ### Response: Does collection size satisfy a given matcher?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether max age of cookie satisfies specified matcher.\n@param maxAgeMatcher assertion for max age property\n@return A {@link DetailedCookieMatcher} instance with and-composed max age property assertion", "predict": " Matches a cookie with a maximum age that satisfies a given matcher."}, {"ID": 277, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Result with(String headerName, String headerContent) { headers.put(headerName, headerContent); return this; }\n\n    ### Response: Sets a header. If this header was already set, the value is overridden.\n\n@param headerName    the header name\n@param headerContent the header value\n@return the current result..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) { spec.header(headerName, expectedValueMatcher); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response header matches the supplied header name and hamcrest matcher.\n\n@param headerName           The name of the expected header\n@param expectedValueMatcher The Hamcrest matcher that must conform to the value\n@return The builder", "predict": " Adds an expected header to the response specification. If the header is not present in the response, the test will fail.\n\n@param headerName           the header name\n@param expectedValueMatcher the matcher to use to validate the header value\n@return the current response specification builder."}, {"ID": 278, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Condition value(final String expectedValue) { return new Condition(\"value\") { @Override public boolean apply(Driver driver, WebElement element) { return Html.text.contains(getAttributeValue(element, \"value\"), expectedValue); } @Override public String toString() { return name + \" '\" + expectedValue + \"'\"; } }; }\n\n    ### Response: Assert that element has given \"value\" attribute as substring\nNB! Ignores difference in non-visible characters like spaces, non-breakable spaces, tabs, newlines  etc.\n\nSample: $(\"input\").shouldHave(value(\"12345 666 77\"));\n\n@param expectedValue expected value of \"value\" attribute.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) { spec.header(headerName, expectedValue); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response header matches the supplied name and value.\n\n@param headerName    The name of the expected header\n@param expectedValue The value of the expected header\n@return The builder", "predict": " Adds a header to the response spec with the given name and expected value.\n\nSample: response.expectHeader(\"Content-Type\", \"application/json\");\n\n@param headerName name of the header to add.\n@param expectedValue expected value of the header."}, {"ID": 279, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Condition value(final String expectedValue) { return new Condition(\"value\") { @Override public boolean apply(Driver driver, WebElement element) { return Html.text.contains(getAttributeValue(element, \"value\"), expectedValue); } @Override public String toString() { return name + \" '\" + expectedValue + \"'\"; } }; }\n\n    ### Response: Assert that element has given \"value\" attribute as substring\nNB! Ignores difference in non-visible characters like spaces, non-breakable spaces, tabs, newlines  etc.\n\nSample: $(\"input\").shouldHave(value(\"12345 666 77\"));\n\n@param expectedValue expected value of \"value\" attribute.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) { spec.cookie(cookieName, expectedValue); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response cookie matches the supplied name and value.\n\n@param cookieName    The name of the expected cookie\n@param expectedValue The value of the expected cookie\n@return The builder", "predict": " Adds a cookie expectation to the response spec.\n\nSample: response.expectCookie(\"myCookie\", \"12345 666 77\");\n\n@param cookieName name of the cookie to expect.\n@param expectedValue expected value of the cookie."}, {"ID": 280, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public UrlBuilder withHost(String host) { if (host == null || host.isEmpty()) { this.host = null; } else { with(host, UrlTokenizerState.SCHEME_OR_HOST); } return this; }\n\n    ### Response: Set the host that will be used to build the final URL.\n@param host The host that will be used to build the final URL.\n@return This UrlBuilder so that multiple setters can be chained together..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProxySpecification withHost(String host) { return new ProxySpecification(host, port, scheme, username, password); }\n\n    ### Response:", "ground_truth": "Specify the hostname of the proxy.\n\n@param host The hostname of the proxy.\n@return A new ProxySpecification instance", "predict": " Create a new ProxySpecification with the given host, port, scheme, username, and password.\n@param host The host of the proxy server.\n@param port The port of the proxy server.\n@param scheme The scheme of the proxy server (e.g. http, https).\n@param username The username to authenticate with the proxy server.\n@param password The password to authenticate with the proxy server.\n@return A new ProxySpecification with the given values."}, {"ID": 281, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Reader createReader(byte[] cachedBytes) throws IOException { if (cachedBytes != null) { return new InputStreamReader(new ByteArrayInputStream(cachedBytes)); } if (inputStream != null) { return new InputStreamReader(inputStream, charset); } if (reader != null) { return reader; } return new InputStreamReader(new FileInputStream(file), charset); }\n\n    ### Response: If cachedBytes are not null, returns a Reader created from the cachedBytes.\nOtherwise, returns a Reader from the underlying source..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); }\n\n    ### Response:", "ground_truth": "Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.\n\n@param numberReturnType The choice.\n@return A new instance of JsonPathConfig with the given configuration", "predict": " Sets the numberReturnType for the JsonPathConfig object.\n\n    "}, {"ID": 282, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Reader createReader(byte[] cachedBytes) throws IOException { if (cachedBytes != null) { return new InputStreamReader(new ByteArrayInputStream(cachedBytes)); } if (inputStream != null) { return new InputStreamReader(inputStream, charset); } if (reader != null) { return reader; } return new InputStreamReader(new FileInputStream(file), charset); }\n\n    ### Response: If cachedBytes are not null, returns a Reader created from the cachedBytes.\nOtherwise, returns a Reader from the underlying source..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonPathConfig defaultParserType(JsonParserType defaultParserType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); }\n\n    ### Response:", "ground_truth": "Creates an json path configuration that uses the specified parser type as default.\n\n@param defaultParserType The parser type to use. If null then classpath scanning will be used.", "predict": " Sets the default parser type to the specified value.\n\n    "}, {"ID": 283, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected function handleStaticPageCase($path, $filter) { if (isset($filter['paths'][$path])) { return array_keys($filter['paths'][$path] + $filter['excluded'], true, true); } return array_keys($filter['excluded'], true, true); }\n\n    ### Response: It checks which blocks should be displayed for specific static page\n\n@param string $path   Static page named route\n@param array  $filter Array with all filters\n\n@return array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LogConfig defaultStream(PrintStream printStream) { return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true); }\n\n    ### Response:", "ground_truth": "Specify a new default stream to the print to.\n\n@param printStream The stream\n@return A new LogConfig instance", "predict": " It sets the default log configuration for the given print stream.\n\n@param PrintStream printStream The print stream to set the default log configuration for.\n\n@return LogConfig."}, {"ID": 284, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (service *Service) EvaluateLogConfigTemplate(gs GetService, fc FindChildService, instanceID int) (err error) { log.WithFields(log.Fields{ \"servicename\": service.Name, \"serviceid\": service.ID, \"instanceid\": instanceID, }).Debug(\"Evaluating LogConfig Files\") // evaluate the template for the LogConfig as well as the tags for i, logConfig := range service.LogConfigs { // Path err, result := service.evaluateTemplate(gs, fc, instanceID, logConfig.Path) if err != nil { return err } if result != \"\" { service.LogConfigs[i].Path = result } // Type err, result = service.evaluateTemplate(gs, fc, instanceID, logConfig.Type) if err != nil { return err } if result != \"\" { service.LogConfigs[i].Type = result } // Tags for j, tag := range logConfig.LogTags { err, result = service.evaluateTemplate(gs, fc, instanceID, tag.Value) if err != nil { return err } if result != \"\" { service.LogConfigs[i].LogTags[j].Value = result } } } return }\n\n    ### Response: // EvaluateLogConfigTemplate parses and evals the Path, Type and all the values for the tags of the log\n// configs. This happens for each LogConfig on the service..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); }\n\n    ### Response:", "ground_truth": "Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail\n\n@param logDetail The log detail to show in the log\n@return A new LogConfig instance", "predict": " // enableLoggingOfRequestAndResponseIfValidationFails creates a new LogConfig with the given logDetail and sets the flag to enable logging of request and response if validation fails."}, {"ID": 285, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected HttpRequestBase createHttpRequest(InternalRequest request) { String uri = request.getUri().toASCIIString(); String encodedParams = HttpUtils.getCanonicalQueryString(request.getParameters(), false); if (encodedParams.length() > 0) { uri += \"?\" + encodedParams; } HttpRequestBase httpRequest; long contentLength = -1; String contentLengthString = request.getHeaders().get(Headers.CONTENT_LENGTH); if (contentLengthString != null) { contentLength = Long.parseLong(contentLengthString); } if (request.getHttpMethod() == HttpMethodName.GET) { httpRequest = new HttpGet(uri); } else if (request.getHttpMethod() == HttpMethodName.PUT) { HttpPut putMethod = new HttpPut(uri); httpRequest = putMethod; if (request.getContent() != null) { putMethod.setEntity(new InputStreamEntity(request.getContent(), contentLength)); } } else if (request.getHttpMethod() == HttpMethodName.POST) { HttpPost postMethod = new HttpPost(uri); httpRequest = postMethod; if (request.getContent() != null) { postMethod.setEntity(new InputStreamEntity(request.getContent(), contentLength)); } } else if (request.getHttpMethod() == HttpMethodName.DELETE) { httpRequest = new HttpDelete(uri); } else if (request.getHttpMethod() == HttpMethodName.HEAD) { httpRequest = new HttpHead(uri); } else { throw new BceClientException(\"Unknown HTTP method name: \" + request.getHttpMethod()); } httpRequest.addHeader(Headers.HOST, HttpUtils.generateHostHeader(request.getUri())); // Copy over any other headers already in our request for (Entry<String, String> entry : request.getHeaders().entrySet()) { /* * HttpClient4 fills in the Content-Length header and complains if it's already present, so we skip it here. * We also skip the Host header to avoid sending it twice, which will interfere with some signing schemes. */ if (entry.getKey().equalsIgnoreCase(Headers.CONTENT_LENGTH) || entry.getKey().equalsIgnoreCase(Headers.HOST)) { continue; } httpRequest.addHeader(entry.getKey(), entry.getValue()); } checkNotNull(httpRequest.getFirstHeader(Headers.CONTENT_TYPE), Headers.CONTENT_TYPE + \" not set\"); return httpRequest; }\n\n    ### Response: Creates HttpClient method object based on the specified request and\npopulates any parameters, headers, etc. from the internal request.\n\n@param request The request to convert to an HttpClient method object.\n@return The converted HttpClient method object with any parameters, headers, etc. from the original request set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) { String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\"); Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method); final HttpRequestBase httpRequest; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) { httpRequest = new CustomHttpMethod(method, uri); } else { try { httpRequest = type.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } httpRequest.setURI(uri); } return httpRequest; }\n\n    ### Response:", "ground_truth": "Get the HttpRequest class that represents this request type.\n\n@return a non-abstract class that implements {@link HttpRequest}", "predict": " Creates an instance of the appropriate HttpRequestBase subclass based on the specified URI and HTTP method.\n\n@param uri The URI to use for the request.\n@param httpMethod The HTTP method to use for the request.\n@param hasBody Whether or not the request has a body.\n@return An instance of the appropriate HttpRequestBase subclass based on the specified URI and HTTP method."}, {"ID": 286, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function any(\\Closure $function = null, array $args = []) { if ($this->isMatched) { return new static($this->value, $this->isMatched); } if (is_null($function)) { return new static($this->value, true); } return new static($this->callFunction($function, $this->value, $args), true); }\n\n    ### Response: Match anything. Usually called last in Match chain\n\n@param callable|\\Closure $function\n@param array $args Optional additional arguments to function\n@return Match.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartConfig defaultBoundary(String defaultBoundary) { return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true); }\n\n    ### Response:", "ground_truth": "Specify an explicit default multipart boundary to use when sending multi-part data.\n\n@param defaultBoundary The boundary to set\n@return An updated MultiPartConfig", "predict": " Set the default boundary for multipart requests.\n\n@param defaultBoundary The default boundary to use for multipart requests.\n@return MultiPartConfig."}, {"ID": 287, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AttributesBuilder attribute(String attributeName, Object attributeValue) { this.attributes.setAttribute(attributeName, attributeValue); return this; }\n\n    ### Response: Sets custom or unlisted attribute\n\n@param attributeName\n@param attributeValue\n@return this instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) { spec.attribute(attributeName, attributeValue); return this; }\n\n    ### Response:", "ground_truth": "Add request attribute\n\n@param attributeName  The attribute name\n@param attributeValue The attribute value\n@return The request specification builder", "predict": " Adds a custom or unlisted attribute to the request specification.\n\n@param attributeName\n@param attributeValue\n@return this instance."}, {"ID": 288, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public B addHeader(final String headerName, final String headerValue) { httpParams.addHeader(headerName, headerValue); return self(); }\n\n    ### Response: Adds a header to this upload request.\n\n@param headerName header name\n@param headerValue header value\n@return self instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) { spec.header(headerName, headerValue); return this; }\n\n    ### Response:", "ground_truth": "Add a header to be sent with the request\n\n@param headerName  The header name\n@param headerValue The header value\n@return The request specification builder", "predict": " Adds a header to the request specification.\n\n@param headerName header name\n@param headerValue header value\n@return this instance."}, {"ID": 289, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void addHeaders(HttpUriRequest req, String mimeType) { if (POST.equalsIgnoreCase(req.getMethod())) { req.addHeader(CONTENT_TYPE, FORM_ENCODED); } if (mimeType != null) req.setHeader(ACCEPT, mimeType); }\n\n    ### Response: Add headers to a request.\n@param req The request to set the headers on..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) { spec.multiPart(controlName, mimeType); return this; }\n\n    ### Response:", "ground_truth": "Specify a string to send to the server using multi-part form data with a specific mime-type.\n\n@param controlName Defines the control name of the body part. In HTML this is the attribute name of the input tag.\n@param contentBody The string to send\n@param mimeType    The mime-type\n@return The request specification", "predict": " Add a multi-part request part to the builder.\n@param controlName The name of the control to add.\n@param contentBody The content of the request part.\n@param mimeType The MIME type of the request part."}, {"ID": 290, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, R> Supplier<R> andThen(Supplier<T> supplier, Function<T, R> resultHandler, Function<Exception, R> exceptionHandler){ return () -> { try{ T result = supplier.get(); return resultHandler.apply(result); }catch (Exception exception){ return exceptionHandler.apply(exception); } }; }\n\n    ### Response: Returns a composed function that first applies the Supplier and then applies\neither the resultHandler or exceptionHandler.\n\n@param  return type of after\n@param resultHandler the function applied after Supplier was successful\n@param exceptionHandler the function applied after Supplier has failed\n@return a function composed of supplier and handler.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.resultHandlers(resultHandler, additionalResultHandlers); return this; }\n\n    ### Response:", "ground_truth": "Add a result handler\n\n@param resultHandler The result handler\n@return MockMvcRequestSpecBuilder", "predict": " Adds the given result handlers to the list of result handlers to be applied to the generated response.\n\n@param resultHandler the result handler to add\n@param additionalResultHandlers additional result handlers to add\n@return this builder instance for further customization"}, {"ID": 291, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DefaultListOperation<T> set(String parameterName, String parameterValue) { queryParameters.add(parameterName, parameterValue); return this; }\n\n    ### Response: Add an arbitrary query parameter\n\n@param parameterName\nname of query parameter\n@param parameterValue\nvalue for query parameter\n@return this.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> HttpClientConfig setParam(String parameterName, T parameterValue) { notNull(parameterName, \"Parameter name\"); final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams); newParams.put(parameterName, parameterValue); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "            The parameter type\n@return An updated HttpClientConfig", "predict": " Set a parameter for the HttpClientConfig\n\n@param parameterName\nname of parameter\n@param parameterValue\nvalue of parameter\n@return new HttpClientConfig with updated parameter\n\nNote: This method returns a new instance of HttpClientConfig with the updated parameter."}, {"ID": 292, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CliEnvironment createMainEnvironment(final AtomicReference<InputReader> dynamicInputReaderRef, final AtomicReference<History> dynamicHistoryAtomicReference) { final Map<String, ?> data = new HashMap<String, Object>(); return new CliEnv() { @Override public History history() { return dynamicHistoryAtomicReference.get(); } @Override public InputReader reader() { return dynamicInputReaderRef.get(); } @Override public Map<String, ?> userData() { return data; } }; }\n\n    ### Response: java 8 would have use Supplier which is cleaner.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "", "predict": " This method adds the given parameters to the existing parameters and returns a new instance of HttpClientConfig with the updated parameters. The method is not thread-safe and should not be called concurrently."}, {"ID": 293, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"deprecation\") public static InputStream fetchFile( final URI uri, final ClientConfiguration config) throws IOException { HttpParams httpClientParams = new BasicHttpParams(); HttpProtocolParams.setUserAgent( httpClientParams, getUserAgent(config, null)); HttpConnectionParams.setConnectionTimeout( httpClientParams, getConnectionTimeout(config)); HttpConnectionParams.setSoTimeout( httpClientParams, getSocketTimeout(config)); DefaultHttpClient httpclient = new DefaultHttpClient(httpClientParams); if (config != null) { String proxyHost = config.getProxyHost(); int proxyPort = config.getProxyPort(); if (proxyHost != null && proxyPort > 0) { HttpHost proxy = new HttpHost(proxyHost, proxyPort); httpclient.getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, proxy); if (config.getProxyUsername() != null && config.getProxyPassword() != null) { httpclient.getCredentialsProvider().setCredentials( new AuthScope(proxyHost, proxyPort), new NTCredentials(config.getProxyUsername(), config.getProxyPassword(), config.getProxyWorkstation(), config.getProxyDomain())); } } } HttpResponse response = httpclient.execute(new HttpGet(uri)); if (response.getStatusLine().getStatusCode() != 200) { throw new IOException(\"Error fetching file from \" + uri + \": \" + response); } return new HttpClientWrappingInputStream( httpclient, response.getEntity().getContent()); }\n\n    ### Response: Fetches a file from the URI given and returns an input stream to it.\n\n@param uri the uri of the file to fetch\n@param config optional configuration overrides\n@return an InputStream containing the retrieved data\n@throws IOException on error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "", "predict": "Creates a new instance of HttpClientConfig with the given parameters.\n\n@param httpClientFactory the HttpClientFactory to use for creating the HttpClient\n@param httpClientParams the HttpClientParams to use for configuring the HttpClient\n@param httpMultipartMode the HttpMultipartMode to use for configuring the HttpClient\n@param shouldReuseHttpClientInstance whether to reuse the HttpClient instance or create a new one for each request\n@param httpClient the HttpClient instance to use, or null to create a new one\n@param shouldCloseHttpClient whether to close the HttpClient instance when the HttpClientConfig is closed\n@return a new instance of HttpClientConfig\n\n    "}, {"ID": 294, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"deprecation\") public static InputStream fetchFile( final URI uri, final ClientConfiguration config) throws IOException { HttpParams httpClientParams = new BasicHttpParams(); HttpProtocolParams.setUserAgent( httpClientParams, getUserAgent(config, null)); HttpConnectionParams.setConnectionTimeout( httpClientParams, getConnectionTimeout(config)); HttpConnectionParams.setSoTimeout( httpClientParams, getSocketTimeout(config)); DefaultHttpClient httpclient = new DefaultHttpClient(httpClientParams); if (config != null) { String proxyHost = config.getProxyHost(); int proxyPort = config.getProxyPort(); if (proxyHost != null && proxyPort > 0) { HttpHost proxy = new HttpHost(proxyHost, proxyPort); httpclient.getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, proxy); if (config.getProxyUsername() != null && config.getProxyPassword() != null) { httpclient.getCredentialsProvider().setCredentials( new AuthScope(proxyHost, proxyPort), new NTCredentials(config.getProxyUsername(), config.getProxyPassword(), config.getProxyWorkstation(), config.getProxyDomain())); } } } HttpResponse response = httpclient.execute(new HttpGet(uri)); if (response.getStatusLine().getStatusCode() != 200) { throw new IOException(\"Error fetching file from \" + uri + \": \" + response); } return new HttpClientWrappingInputStream( httpclient, response.getEntity().getContent()); }\n\n    ### Response: Fetches a file from the URI given and returns an input stream to it.\n\n@param uri the uri of the file to fetch\n@param config optional configuration overrides\n@return an InputStream containing the retrieved data\n@throws IOException on error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); }\n\n    ### Response:", "ground_truth": "", "predict": " Creates a new HttpClientConfig with the given HttpMultipartMode.\n\n@param httpMultipartMode the HttpMultipartMode to use\n@return a new HttpClientConfig with the given HttpMultipartMode\n\n    "}, {"ID": 295, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T get(String key, Class<T> type) { Object value = this.data.get(key); if (value != null && type.isAssignableFrom(value.getClass())) { return (T) value; } return null; }\n\n    ### Response: Access an attribute.\n\n@param type the attribute's type, not {@code null}\n@param key  the attribute's key, not {@code null}\n@return the attribute value, or {@code null}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T get(String path) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a boolean.\n\n@param path The Object path.\n@return The object matching the Object path. This may be any primitive type, a List or a Map.  A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Access a JSON object.\n\n@param path the JSON object's path, not {@code null}\n@return the JSON object, or {@code null} if the object does not exist."}, {"ID": 296, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Boolean extractToBoolean(final DeviceAttribute deviceAttributeRead) throws DevFailed { final Object value = AttributeHelper.extract(deviceAttributeRead); int boolValue = 0; Boolean argout = Boolean.FALSE; ; if (value instanceof Short) { boolValue = ((Short) value).intValue(); } else if (value instanceof String) { try { if (Boolean.getBoolean((String) value)) { boolValue = 1; } } catch (final Exception e) { Except.throw_exception(\"TANGO_WRONG_DATA_ERROR\", \"output type \" + value + \" is not a boolean\", \"AttributeHelper.extractToBoolean(deviceAttributeWritten)\"); } } else if (value instanceof Integer) { boolValue = ((Integer) value).intValue(); } else if (value instanceof Long) { boolValue = ((Long) value).intValue(); } else if (value instanceof Float) { boolValue = ((Float) value).intValue(); } else if (value instanceof Boolean) { if (((Boolean) value).booleanValue()) { boolValue = 1; } } else if (value instanceof Double) { boolValue = ((Double) value).intValue(); } else if (value instanceof DevState) { boolValue = ((DevState) value).value(); } else { Except.throw_exception(\"TANGO_WRONG_DATA_ERROR\", \"output type \" + value.getClass() + \" not supported\", \"AttributeHelper.extractToBoolean(Object value,deviceAttributeWritten)\"); } if (boolValue == 1) { argout = Boolean.TRUE; } return argout; }\n\n    ### Response: Extract data from DeviceAttribute to a Boolean.\n\n@param deviceAttributeRead\nthe DeviceAttribute attribute to read\n@return Boolean the result in Boolean format\n@throws DevFailed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as an int.\n\n@param path The Object path.\n@return The int matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the integer value of the specified path in the configuration.\n\n@param path\nthe path to the integer value\n@return the integer value\n@throws ConfigurationException."}, {"ID": 297, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object prepare(final Object value) { if (value == null || value instanceof String || !stringify) { return value; } else { if (value instanceof Boolean) { return PREFIX_BOOLEAN.concat(value.toString()); } else if (value instanceof Integer) { return PREFIX_INT.concat(value.toString()); } else if (value instanceof Long) { return PREFIX_LONG.concat(value.toString()); } else if (value instanceof Date) { return PREFIX_DATE.concat(newSdf().format((Date) value)); } else if (value instanceof URI) { return PREFIX_URI.concat(value.toString()); } else { return PREFIX_SB64.concat(serializationHelper.serializeToBase64((Serializable) value)); } } }\n\n    ### Response: Before saving the attribute into the attributes map.\n\n@param value the original value\n@return the prepared value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte getByte(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Byte) { return (Byte) value; } else if (value instanceof Long) { return ((Long) value).byteValue(); } else if (value instanceof Integer) { return ((Integer) value).byteValue(); } else { return ObjectConverter.convertObjectTo(value, Byte.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a byte.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Retrieves the value at the specified path as a byte.\n\n@param path the path to the value to retrieve\n@return the value at the specified path as a byte\n\n    "}, {"ID": 298, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object prepare(final Object value) { if (value == null || value instanceof String || !stringify) { return value; } else { if (value instanceof Boolean) { return PREFIX_BOOLEAN.concat(value.toString()); } else if (value instanceof Integer) { return PREFIX_INT.concat(value.toString()); } else if (value instanceof Long) { return PREFIX_LONG.concat(value.toString()); } else if (value instanceof Date) { return PREFIX_DATE.concat(newSdf().format((Date) value)); } else if (value instanceof URI) { return PREFIX_URI.concat(value.toString()); } else { return PREFIX_SB64.concat(serializationHelper.serializeToBase64((Serializable) value)); } } }\n\n    ### Response: Before saving the attribute into the attributes map.\n\n@param value the original value\n@return the prepared value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a short.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Retrieves the value at the specified path as a short.\n\n@param path the path to the value to retrieve\n@return the value at the specified path as a short\n\n    "}, {"ID": 299, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public double getDouble(int index) { Object value = _values[index - 1]; if (value instanceof Double) { return (Double) value; } else if (value instanceof Float) { return (Float) value; } else if (value instanceof Number) { return (Double) ((Number) value); } else { return Double.valueOf(value.toString()); } }\n\n    ### Response: Returns the column as a double.\n\n@param index 1-based\n@return column as a double.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public float getFloat(String path) { final Object value = get(path); //Groovy will always return a Double for floating point values. if (value instanceof Double) { return ((Double) value).floatValue(); } else { return ObjectConverter.convertObjectTo(value, Float.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a float.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Returns the value at the specified path as a float.\n\n@param path the path to the value\n@return value at the specified path as a float."}, {"ID": 300, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public double getDouble(int index) { Object value = _values[index - 1]; if (value instanceof Double) { return (Double) value; } else if (value instanceof Float) { return (Float) value; } else if (value instanceof Number) { return (Double) ((Number) value); } else { return Double.valueOf(value.toString()); } }\n\n    ### Response: Returns the column as a double.\n\n@param index 1-based\n@return column as a double.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public double getDouble(String path) { final Object value = get(path); if (value instanceof Double) { return (Double) value; } return ObjectConverter.convertObjectTo(value, Double.class); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a double.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Returns the value at the specified path as a double.\n\n@param path the path to the value to retrieve\n@return the value at the specified path as a double."}, {"ID": 301, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long getLong(int index) { Object value = _values[index - 1]; if (value instanceof Long) { return (Long) value; } else if (value instanceof Integer) { return (Integer) value; } else { return Long.valueOf(value.toString()); } }\n\n    ### Response: Returns the column as a long.\n\n@param index 1-based\n@return column as a long.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a long.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Returns the value at the specified path as a long.\n\n@param path the path to the value to retrieve\n@return the value at the specified path as a long."}, {"ID": 302, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> copy(final List<T> list) { if (list == null) { return null; } TypeEnum elementType = null; List<T> copy = new ArrayList<T>(); for (T element : list) { T elementCopy = null; if (element != null) { if (elementType == null) { elementType = TypeEnum.dataTypeOf(element.getClass()); } elementCopy = copy(element, elementType); } copy.add(elementCopy); } return copy; }\n\n    ### Response: Returns a deep copy of a pdef list..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> List<T> getList(String path, Class<T> genericType) { if (genericType == null) { throw new IllegalArgumentException(\"Generic type cannot be null\"); } final List<T> original = get(path); final List<T> newList = new LinkedList<T>(); if (original != null) { for (T t : original) { T e; if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) { // TODO Avoid double parsing String str = objectToString(t); //noinspection unchecked e = (T) jsonStringToObject(str, genericType); } else { e = ObjectConverter.convertObjectTo(t, genericType); } newList.add(e); } } return Collections.unmodifiableList(newList); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a list.\n\n@param path        The Object path.\n@param genericType The generic list type\n@param          The type\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Returns a list of objects of the specified generic type from the specified path in the pdef store. The list is a deep copy of the original list, with each element converted to the specified generic type. If the original list is null, an empty list is returned. If the generic type is null, an IllegalArgumentException is thrown."}, {"ID": 303, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> Map<K, V> getMap(String prefix, Function<String, K> keyFactory, Function<String, V> valueFactory) { Map<K, V> map = new HashMap<>(); for (String property : properties.stringPropertyNames()) { if (property.startsWith(prefix + \".\")) { map.put(keyFactory.apply(property.substring(prefix.length() + 1)), valueFactory.apply(properties.getProperty(property))); } } return map; }\n\n    ### Response: Returns a map of properties for a given prefix.\n\n@param prefix The prefix for which to return a map of property values.\n@param keyFactory A converter function to convert the map keys.\n@param valueFactory A converter function to convert the map values.\n@param  The map key type.\n@param  The map value type.\n@return The map..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> Map<K, V> getMap(String path) { return get(path); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a map.\n\n@param path The Object path.\n@param   The type of the expected key\n@param   The type of the expected value\n@return The map matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Returns a map of properties for a given path.\n\n@param path The path for which to return a map of property values.\n@param  The map key type.\n@param  The map value type.\n@return The map."}, {"ID": 304, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T getObject(String key, Class<T> clazz) { EDBObjectEntry entry = get(key); return entry == null ? null : (T) entry.getValue(); }\n\n    ### Response: Returns the value of the EDBObjectEntry for the given key, casted as the given class. Returns null if there is no\nelement for the given key, or the value for the given key is null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); }\n\n    ### Response:", "ground_truth": "Get an XML document as a Java Object.\n\n@param objectType The type of the java object.\n@param         The type of the java object\n@return A Java object representation of the XML document", "predict": " Returns the object at the given path, casted as the given class. Returns null if there is no object at the given path, or if the object at the given path is null.\n\n    "}, {"ID": 305, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String getServerIdFromHandshake(ChannelBuffer handshakeBuffer, ObjectMapper mapper) throws IOException { Handshake handshake = getHandshakeFromBuffer(handshakeBuffer, mapper); return handshake.getServerId(); }\n\n    ### Response: Extract the unique id of the Raft server that sent a handshake\nmessage from its wire representation.\n\n@param handshakeBuffer instance of {@code ChannelBuffer} that contains\nthe encoded handshake message\n@param mapper instance of {@code ObjectMapper} used to map handshake fields\nin the encoded message to their corresponding Java representation\n@return unique id of the Raft server that sent the handshake message\n@throws IOException if a valid handshake cannot be read from the {@code handshakeBuffer}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; }\n\n    ### Response:", "ground_truth": "", "predict": " Set the request body to the specified object using the specified\n{@code ObjectMapper}.\n\n@param object the object to set as the request body\n@param mapper the {@code ObjectMapper} to use for serialization\n@return this {@code RequestSpecBuilder} instance for chaining\n@throws IllegalArgumentException if the specified object cannot be serialized\nusing the specified {@code ObjectMapper}"}, {"ID": 306, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CrawlerPack addCookie(String domain, String name, String value, String path, Date expires, boolean secure) { if( null == name ) { log.warn(\"addCookie: Cookie name null.\"); return this; } cookies.add(new Cookie(domain, name, value, path, expires, secure)); return this; }\n\n    ### Response: Creates a cookie with the given name, value, domain attribute,\npath attribute, expiration attribute, and secure attribute\n\n@param name    the cookie name\n@param value   the cookie value\n@param domain  the domain this cookie can be sent to\n@param path    the path prefix for which this cookie can be sent\n@param expires the {@link Date} at which this cookie expires,\nor null if the cookie expires at the end\nof the session\n@param secure if true this cookie can only be sent over secure\nconnections.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { spec.cookie(key, value, cookieNameValuePairs); return this; }\n\n    ### Response:", "ground_truth": "Add a cookie to be sent with the request.\n\n@param key                  The cookie key\n@param value                The cookie value\n@param cookieNameValuePairs Additional cookies values. This will actually create two cookies with the same name but with different values.\n@return The request specification builder", "predict": " Adds a cookie to the request specification with the given name and value.\n\n@param key the name of the cookie\n@param value the value of the cookie\n@param cookieNameValuePairs additional name-value pairs to include in the cookie, such as path, domain, and secure attributes.\n\n    "}, {"ID": 307, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object invoke(Object source, Method method, Object[] parameterValues) throws MethodException { try { return method.invoke(source, parameterValues); } catch (Exception e) { throw new MethodException(INVOKE_METHOD_FAILED, e); } }\n\n    ### Response: Invokes given method on the given source object with the specified\nparameters.\n\n@param source\nthe object which you want to handle.\n@param method\nthe method which you want to call.\n@param parameterValues\nthe parameter values of the method which you want to call.\n@return an object which is invoked method returns.\n@throws MethodException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) { spec.param(parameterName, parameterValues); return this; }\n\n    ### Response:", "ground_truth": "Add a parameter to be sent with the request.\n\n@param parameterName   The parameter name\n@param parameterValues Zero to many parameter values for this parameter name.\n@return The request specification builder", "predict": " Adds a parameter to the request specification.\n\n@param parameterName\nthe name of the parameter.\n@param parameterValues\nthe values of the parameter.\n@return the updated request specification builder."}, {"ID": 308, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object invoke(Object source, Method method, Object[] parameterValues) throws MethodException { try { return method.invoke(source, parameterValues); } catch (Exception e) { throw new MethodException(INVOKE_METHOD_FAILED, e); } }\n\n    ### Response: Invokes given method on the given source object with the specified\nparameters.\n\n@param source\nthe object which you want to handle.\n@param method\nthe method which you want to call.\n@param parameterValues\nthe parameter values of the method which you want to call.\n@return an object which is invoked method returns.\n@throws MethodException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) { spec.param(parameterName, parameterValues); return this; }\n\n    ### Response:", "ground_truth": "Add a multi-value parameter to be sent with the request.\n\n@param parameterName   The parameter key\n@param parameterValues The parameter values\n@return The request specification builder", "predict": " Adds a parameter to the request specification with the given name and values.\n\n@param parameterName\nthe name of the parameter.\n@param parameterValues\nthe values of the parameter.\n@return the updated request specification builder."}, {"ID": 309, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function any(\\Closure $function = null, array $args = []) { if ($this->isMatched) { return new static($this->value, $this->isMatched); } if (is_null($function)) { return new static($this->value, true); } return new static($this->callFunction($function, $this->value, $args), true); }\n\n    ### Response: Match anything. Usually called last in Match chain\n\n@param callable|\\Closure $function\n@param array $args Optional additional arguments to function\n@return Match.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) { return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true); }\n\n    ### Response:", "ground_truth": "Set form parameter update strategy to the given value.\n\n@param updateStrategy The update strategy to use for form parameters\n@return A new instance of {@link MockMvcParamConfig}", "predict": " Set the formParams update strategy.\n\n@param UpdateStrategy updateStrategy The update strategy to use for formParams\n@return MockMvcParamConfig."}, {"ID": 310, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Matcher<T> jsonPartMatches(String path, Matcher<?> matcher) { return new MatcherApplyingMatcher<>(path, matcher); }\n\n    ### Response: Applies matcher to the part of the JSON..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); }\n\n    ### Response:", "ground_truth": "Create a new logging filter without using the \"new\" operator.\nWill make the DSL look nicer.\n\n@param stream The print stream to log to\n@param matcher The matcher that must be fulfilled in order for logging to occur\n@return a new instance of the filter", "predict": " Logs the response to the specified stream if the response code matches the specified matcher."}, {"ID": 311, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Cookie> cookies(){ javax.servlet.http.Cookie[] servletCookies = RequestContext.getHttpRequest().getCookies(); if(servletCookies == null) return new ArrayList<>(); List<Cookie> cookies = new ArrayList<>(); for (javax.servlet.http.Cookie servletCookie: servletCookies) { Cookie cookie = Cookie.fromServletCookie(servletCookie); cookies.add(cookie); } return cookies; }\n\n    ### Response: Returns collection of all cookies browser sent.\n\n@return collection of all cookies browser sent..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Cookies(cookieList); }\n\n    ### Response:", "ground_truth": "An alternative way to create a Cookies object from the constructor.\n\n@param cookie            The cookie to be included\n@param additionalCookies Additional cookies to be included (optional)\n@return A new cookies object containing the specified cookies", "predict": " Creates a new instance of Cookies with the given cookie and additional cookies.\n\n@param cookie the primary cookie\n@param additionalCookies additional cookies\n@return a new instance of Cookies with the given cookie and additional cookies."}, {"ID": 312, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LifecycleListener createLifecycleListener() { return new LifecycleListener() { @Override public void onForegrounded(Context context) { synchronized (lock) { if (!isForegrounded) { isForegrounded = true; connectSocket(); if (receiver == null) { receiver = new InternetConnectionReceiver(socketConnection); } context.registerReceiver(receiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)); } lock.notifyAll(); } } @Override public void onBackgrounded(Context context) { synchronized (lock) { if (isForegrounded) { isForegrounded = false; disconnectSocket(); if (receiver != null && !isForegrounded) { context.unregisterReceiver(receiver); } } lock.notifyAll(); } } }; }\n\n    ### Response: creates application lifecycle and network connectivity callbacks.\n\n@return Application lifecycle and network connectivity callbacks..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) { synchronized (lock) { for (KeyAndSource keyAndSource : keysAndSources) { Multiset<Object> set = backingMap.get(keyAndSource.key); if (set != null) { set.remove(keyAndSource.source); if (set.isEmpty()) { backingMap.remove(keyAndSource.key); } } } } }\n\n    ### Response:", "ground_truth": "There may be multiple child injectors blacklisting a certain key so only remove the source\nthat's relevant.", "predict": " Removes the given keys and sources from the backing map if they are present.\n\n    "}, {"ID": 313, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addTypes(Injector injector, List<Class<?>> types) { for (Binding<?> binding : injector.getBindings().values()) { Key<?> key = binding.getKey(); Type type = key.getTypeLiteral().getType(); if (hasAnnotatedMethods(type)) { types.add(((Class<?>)type)); } } if (injector.getParent() != null) { addTypes(injector.getParent(), types); } }\n\n    ### Response: Adds steps types from given injector and recursively its parent\n\n@param injector the current Inject\n@param types the List of steps types.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } }\n\n    ### Response:", "ground_truth": "Indexes bindings by type.", "predict": " Indexes the bindings in the current level of the state.\n\n@param state the current state\n@param bindingsMultimap the multimap to store the bindings"}, {"ID": 314, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> BindingAmp<T> findBinding(Key<T> key) { BindingSet<T> set = (BindingSet) _bindingSetMap.get(key.rawClass()); if (set != null) { BindingAmp<T> binding = set.find(key); if (binding != null) { return binding; } } return null; }\n\n    ### Response: Finds a producer for the given target type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); }\n\n    ### Response:", "ground_truth": "Gets a binding implementation. First, it check to see if the parent has a binding. If the\nparent has a binding and the binding is scoped, it will use that binding. Otherwise, this\nchecks for an explicit binding. If no explicit binding is found, it looks for a just-in-time\nbinding.", "predict": " Gets a binding for the given key, or throws an exception if none is found.\n\n    "}, {"ID": 315, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T castToType(final Class<T> type, final Object val) throws DevFailed { T result; if (val == null) { result = null; } else if (type.isAssignableFrom(val.getClass())) { result = (T) val; } else { LOGGER.debug(\"converting {} to {}\", val.getClass().getCanonicalName(), type.getCanonicalName()); // if input is not an array and we want to convert it to an array. // Put // the value in an array Object array = val; if (!val.getClass().isArray() && type.isArray()) { array = Array.newInstance(val.getClass(), 1); Array.set(array, 0, val); } final Transmorph transmorph = new Transmorph(creatConv()); try { result = transmorph.convert(array, type); } catch (final ConverterException e) { LOGGER.error(\"convertion error\", e); throw DevFailedUtils.newDevFailed(e); } } return result; }\n\n    ### Response: Convert an object to another object.\n\n@see Transmorph\n@param \n@param type\n@param val\n@return\n@throws DevFailed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException { // Find a constant string binding. Key<String> stringKey = key.ofType(STRING_TYPE); BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey); if (stringBinding == null || !stringBinding.isConstant()) { return null; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @SuppressWarnings(\"unchecked\") String stringValue = ((InstanceBinding<String>) stringBinding).getInstance(); Object source = stringBinding.getSource(); // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type); if (converted == null) { throw errors .converterReturnedNull(stringValue, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(stringValue, source, type, typeConverterBinding, converted) .toException(); } return new ConvertedConstantBindingImpl<T>( this, key, converted, stringBinding, typeConverterBinding); } catch (ErrorsException e) { throw e; } catch (RuntimeException e) { throw errors .conversionError(stringValue, source, type, typeConverterBinding, e) .toException(); } }\n\n    ### Response:", "ground_truth": "Converts a constant string binding to the required type.\n\n@return the binding if it could be resolved, or null if the binding doesn't exist\n@throws com.google.inject.internal.ErrorsException if there was an error resolving the binding", "predict": " Convert a constant string binding to a constant binding of a different type.\n\n@see BindingImpl\n@param key\n@param errors\n@return A constant binding of the desired type, or null if no such binding exists.\n@throws ErrorsException If there is a problem with the input or output types or values."}, {"ID": 316, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int parseVariant() { int oldBlen = buffer.length(); boolean start = true; boolean needSeparator = true; boolean skipping = false; char c; boolean firstPass = true; while ((c = next()) != DONE) { if (c == DOT) { start = false; skipping = true; } else if (c == KEYWORD_SEPARATOR) { if (haveKeywordAssign()) { break; } skipping = false; start = false; needSeparator = true; // add another underscore if we have more text } else if (start) { start = false; if (c != UNDERSCORE && c != HYPHEN) { index--; } } else if (!skipping) { if (needSeparator) { needSeparator = false; if (firstPass && !hadCountry) { // no country, we'll need two addSeparator(); ++oldBlen; // for sure } addSeparator(); if (firstPass) { // only for the first separator ++oldBlen; firstPass = false; } } c = AsciiUtil.toUpper(c); if (c == HYPHEN || c == COMMA) { c = UNDERSCORE; } append(c); } } --index; // unget return oldBlen; }\n\n    ### Response: Advance index past variant, and accumulate normalized variant in buffer.  This ignores\nthe codepage information from POSIX ids.  Index must be immediately after the country\nor script.  Index is left at the keyword separator or at the end of the text.  Return\nthe start of the variant code in the buffer.\n\nIn standard form, we can have the following forms:\nll__VVVV\nll_CC_VVVV\nll_Ssss_VVVV\nll_Ssss_CC_VVVV\n\nThis also handles POSIX ids, which can have the following forms (pppp is code page id):\nll_CC.pppp          --> ll_CC\nll_CC.pppp@VVVV     --> ll_CC_VVVV\nll_CC@VVVV          --> ll_CC_VVVV\n\nWe identify this use of '@' in POSIX ids by looking for an '=' following\nthe '@'.  If there is one, we consider '@' to start a keyword list, instead of\nbeing part of a POSIX id.\n\nNote:  since it was decided that we want an option to not handle POSIX ids, this\nbecomes a bit more complex..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if (failed) { removeFailedJitBinding(depBinding, ip); bindingFailed = true; } } else if (state.getExplicitBinding(depKey) == null) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true; } } } return bindingFailed; }\n\n    ### Response:", "ground_truth": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "predict": " This method recursively cleans up any JIT bindings that are no longer valid.  It starts by getting the internal dependencies of the given binding, and then iterating over them.  For each dependency, it checks if the key has already been encountered.  If not, it adds the key to the encountered set and recursively calls cleanup on the binding.  If the binding fails, it removes the binding from the JIT cache and sets the bindingFailed flag to true.  If the key was explicitly bound, it ignores it and continues to the next key.  If neither JIT nor explicit binding exists for a key, it sets the bindingFailed flag to true.  Finally, it returns the bindingFailed flag."}, {"ID": 317, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static InetAddress getInetAddress(String ip) { if (ip == null) return null; InetAddress addr = null; try { addr = InetAddress.getByName(ip); } catch (UnknownHostException e) { Log.err(e); H2O.exit(-1); } return addr; }\n\n    ### Response: Get address for given IP.\n@param ip  textual representation of IP (host)\n@return IPv4 or IPv6 address which matches given IP and is in specified range.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) { failedJitBindings.add(binding.getKey()); jitBindings.remove(binding.getKey()); membersInjectorStore.remove(binding.getKey().getTypeLiteral()); provisionListenerStore.remove(binding); if (ip != null) { constructors.remove(ip); } }\n\n    ### Response:", "ground_truth": "Cleans up any state that may have been cached when constructing the JIT binding.", "predict": " Remove failed JIT binding from the JIT bindings list and remove the binding from the members injector store, provision listener store, and constructor store.\n@param binding  binding to remove\n@param ip  injection point for the binding (optional)"}, {"ID": 318, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> Provider<T> lookupProvider(Key<T> key) { BindingInject<T> bean = findBean(key); if (bean != null) { return bean.provider(); } BindingAmp<T> binding = findBinding(key); if (binding != null) { return binding.provider(); } binding = findObjectBinding(key); if (binding != null) { return binding.provider(InjectionPoint.of(key)); } return null; }\n\n    ### Response: Search for a matching provider for a key..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) { if (binding instanceof ConstructorBindingImpl) { return ((ConstructorBindingImpl) binding).getInternalDependencies(); } else if (binding instanceof HasDependencies) { return ((HasDependencies) binding).getDependencies(); } else { return ImmutableSet.of(); } }\n\n    ### Response:", "ground_truth": "Safely gets the dependencies of possibly not initialized bindings.", "predict": " Get the internal dependencies of a binding.\n\n    "}, {"ID": 319, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> T readObject(JsonNode source, Class<T> clazz, boolean handleRelationships) throws IOException, IllegalAccessException, InstantiationException { String identifier = createIdentifier(source); T result = (T) resourceCache.get(identifier); if (result == null) { Class<?> type = getActualType(source, clazz); if (source.has(ATTRIBUTES)) { result = (T) objectMapper.treeToValue(source.get(ATTRIBUTES), type); } else { if (type.isInterface()) { result = null; } else { result = (T) objectMapper.treeToValue(objectMapper.createObjectNode(), type); } } // Handle meta if (source.has(META)) { Field field = configuration.getMetaField(type); if (field != null) { Class<?> metaType = configuration.getMetaType(type); Object metaObject = objectMapper.treeToValue(source.get(META), metaType); field.set(result, metaObject); } } // Handle links if (source.has(LINKS)) { Field linkField = configuration.getLinksField(type); if (linkField != null) { linkField.set(result, new Links(mapLinks(source.get(LINKS)))); } } if (result != null) { // Add parsed object to cache resourceCache.cache(identifier, result); // Set object id setIdValue(result, source.get(ID)); if (handleRelationships) { // Handle relationships handleRelationships(source, result); } } } return result; }\n\n    ### Response: Converts provided input into a target object. After conversion completes any relationships defined are resolved.\n@param source JSON source\n@param clazz target type\n@param  type\n@return converted target object\n@throws IOException\n@throws IllegalAccessException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException { Class<?> rawType = key.getTypeLiteral().getRawType(); ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class); // Don't try to inject arrays or enums annotated with @ImplementedBy. if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) { throw errors.missingImplementationWithHint(key, this).toException(); } // Handle TypeLiteral<T> by binding the inner type if (rawType == TypeLiteral.class) { @SuppressWarnings(\"unchecked\") // we have to fudge the inner type as Object BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors); return binding; } // Handle @ImplementedBy if (implementedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createImplementedByBinding(key, scoping, implementedBy, errors); } // Handle @ProvidedBy. ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class); if (providedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createProvidedByBinding(key, scoping, providedBy, errors); } return ConstructorBindingImpl.create( this, key, null, /* use default constructor */ source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired); }\n\n    ### Response:", "ground_truth": "Creates a binding for an injectable type with the given scope. Looks for a scope on the type if\nnone is specified.", "predict": " Creates a binding for the given key, scoping, and source. This method handles the following cases:\n\n1. If the key's raw type is an array or an enum annotated with @ImplementedBy, an exception is thrown.\n2. If the key's raw type is TypeLiteral, a binding for the inner type is created.\n3. If the key's raw type is annotated with @ImplementedBy, a binding for the implementation class is created.\n4. If the key's raw type is annotated with @ProvidedBy, a binding for the provider class is created.\n5. Otherwise, a binding for the key's default constructor is created.\n\n@param key the key for which to create a binding\n@param scoping the scoping for the binding\n@param source the source for the binding\n@param errors the errors object to which any errors should be reported\n@param jitBinding whether to create a JIT binding or a normal binding\n@return the created binding\n@throws ErrorsException if there is an error creating the binding"}, {"ID": 320, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object[] getAll(final Supplier<?>... suppliers) { if (suppliers == null) { return null; } final Object[] result = new Object[suppliers.length]; for (int i = 0; i < result.length; i++) { result[i] = get(suppliers[i]); } return result; }\n\n    ### Response: Converts an array of lambda expressions into an array of their evaluation results.\n\n@param suppliers an array of lambda expressions or {@code null}\n@return an array containing the results of evaluating the lambda expressions (or {@code null} if the suppliers\narray was {@code null}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException { if (parameterInjectors == null) { return NO_ARGUMENTS; } int size = parameterInjectors.length; Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) { parameters[i] = parameterInjectors[i].inject(context); } return parameters; }\n\n    ### Response:", "ground_truth": "Returns an array of parameter values.", "predict": " Injects the dependencies into the parameters of a method or constructor using the given context.\n\n@param context the context to use for injection\n@param parameterInjectors an array of injectors for the parameters of the method or constructor, or {@code null}\n@return an array containing the injected parameters, or {@code null} if the parameter injectors array was\n{@code null}\n@throws InternalProvisionException if there is a problem injecting the parameters\n\nNote: This method is used internally by Dagger and should not be called directly by client code."}, {"ID": 321, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); try { Key<org.slf4j.Logger> slf4jKey = Key.get(org.slf4j.Logger.class); SLF4JLoggerFactory slf4jLoggerFactory = new SLF4JLoggerFactory(injector); injector.state.putBinding(slf4jKey, new ProviderInstanceBindingImpl<org.slf4j.Logger>(injector, slf4jKey, SourceProvider.UNKNOWN_SOURCE, slf4jLoggerFactory, Scoping.UNSCOPED, slf4jLoggerFactory, ImmutableSet.<InjectionPoint>of())); } catch (Throwable e) {} }\n\n    ### Response: The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindInjector(InjectorImpl injector) { Key<Injector> key = Key.get(Injector.class); InjectorFactory injectorFactory = new InjectorFactory(injector); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Injector>( injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of())); }\n\n    ### Response:", "ground_truth": "The Injector is a special case because we allow both parent and child injectors to both have a\nbinding for that key.", "predict": " The Injector is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this."}, {"ID": 322, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); try { Key<org.slf4j.Logger> slf4jKey = Key.get(org.slf4j.Logger.class); SLF4JLoggerFactory slf4jLoggerFactory = new SLF4JLoggerFactory(injector); injector.state.putBinding(slf4jKey, new ProviderInstanceBindingImpl<org.slf4j.Logger>(injector, slf4jKey, SourceProvider.UNKNOWN_SOURCE, slf4jLoggerFactory, Scoping.UNSCOPED, slf4jLoggerFactory, ImmutableSet.<InjectionPoint>of())); } catch (Throwable e) {} }\n\n    ### Response: The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); }\n\n    ### Response:", "ground_truth": "The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this.", "predict": " This method binds the Logger to the injector. It creates a new LoggerFactory and a new Key for the Logger. It then creates a new ProviderInstanceBindingImpl for the Logger and adds it to the injector's state. The Logger knows the injection point of the injected member, so it doesn't need to be added to the injector's state separately."}, {"ID": 323, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Matcher<ClassTree> hasMethod(final Matcher<MethodTree> methodMatcher) { return new Matcher<ClassTree>() { @Override public boolean matches(ClassTree t, VisitorState state) { for (Tree member : t.getMembers()) { if (member instanceof MethodTree) { if (methodMatcher.matches((MethodTree) member, state)) { return true; } } } return false; } }; }\n\n    ### Response: Matches a class in which at least one method matches the given methodMatcher.\n\n@param methodMatcher A matcher on MethodTrees to run against all methods in this class.\n@return True if some method in the class matches the given methodMatcher..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) { Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation( errors, member, ((AnnotatedElement) member).getAnnotations()); if (misplacedBindingAnnotation == null) { return false; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if (member instanceof Method) { try { if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) { return false; } } catch (NoSuchFieldException ignore) { } } errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation); return true; }\n\n    ### Response:", "ground_truth": "Returns true if the binding annotation is in the wrong place.", "predict": " Checks if a member has a misplaced binding annotation and issues a warning if so.\n\n@param member The member to check.\n@param errors The error report to use.\n@return True if a misplaced binding annotation was found and reported.\n\n    "}, {"ID": 324, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean nodeListsAreEqual(final NodeList a, final NodeList b) { if (a == b) { return true; } if ((a == null) || (b == null)) { return false; } if (a.getLength() != b.getLength()) { return false; } for (int i = 0; i < a.getLength(); ++i) { if (!nodesAreEqual(a.item(i), b.item(i))) { return false; } } return true; }\n\n    ### Response: NodelLists are equal if and only if their size is equal and the containing nodes at the same\nindexes are equal.\n\n@param a\n@param b\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean overrides(Method a, Method b) { // See JLS section 8.4.8.1 int modifiers = b.getModifiers(); if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) { return true; } if (Modifier.isPrivate(modifiers)) { return false; } // b must be package-private return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage()); }\n\n    ### Response:", "ground_truth": "Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\nclass is a subclass of b's declaring class.", "predict": "This method determines if a method overrides another method. It does this by checking the\naccess modifiers of the two methods. If the access modifier of b is public or protected, then a is\nassumed to override b. If the access modifier of b is private, then a is not assumed to override b.\nIf the access modifier of b is package-private, then a is assumed to override b if the two methods are\nin the same package.\n\n@param a\n@param b\n@return."}, {"ID": 325, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDelegate(Object delegate) { this.delegate = delegate; this.metaClass = InvokerHelper.getMetaClass(delegate.getClass()); }\n\n    ### Response: Sets the delegation target..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initializeDelegate(MembersInjector<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); }\n\n    ### Response:", "ground_truth": "Sets the actual members injector.\n\n@throws IllegalStateException if the delegate is already set", "predict": " Initializes the delegation target."}, {"ID": 326, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> Iterable<T> annotateEmptyStrings(Iterable<T> items) { if (Iterables.contains(items, \"\")) { List<T> annotatedItems = Lists.newArrayList(); for (T item : items) { if (Objects.equal(item, \"\")) { // This is a safe cast because know that at least one instance of T (this item) is a // String. @SuppressWarnings(\"unchecked\") T newItem = (T) HUMAN_UNDERSTANDABLE_EMPTY_STRING; annotatedItems.add(newItem); } else { annotatedItems.add(item); } } return annotatedItems; } else { return items; } }\n\n    ### Response: Returns an iterable with all empty strings replaced by a non-empty human understandable\nindicator for an empty string.\n\nReturns the given iterable if it contains no empty strings..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") final TypeLiteral<Provider<T>> providerType() { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())); }\n\n    ### Response:", "ground_truth": "Gets the type of this type's provider.", "predict": " Returns a type literal for a provider of the type of this object.\n\nThis method is annotated with @SuppressWarnings(\"unchecked\") to suppress a warning that would otherwise be generated if the type parameter of Type were used in the cast."}, {"ID": 327, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void Backward(double[] data) { double[] result = new double[data.length]; double sum; double scale = Math.sqrt(2.0 / data.length); for (int t = 0; t < data.length; t++) { sum = 0; for (int j = 0; j < data.length; j++) { double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length)); sum += alpha(j) * data[j] * cos; } result[t] = scale * sum; } for (int i = 0; i < data.length; i++) { data[i] = result[i]; } }\n\n    ### Response: 1-D Backward Discrete Cosine Transform.\n\n@param data Data..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<TypeLiteral<?>> resolveAll(Type[] types) { TypeLiteral<?>[] result = new TypeLiteral<?>[types.length]; for (int t = 0; t < types.length; t++) { result[t] = resolve(types[t]); } return ImmutableList.copyOf(result); }\n\n    ### Response:", "ground_truth": "Returns an immutable list of the resolved types.", "predict": "Resolves all the given types to their corresponding TypeLiteral instances.\n\n@param types Types to resolve.\n@return List of TypeLiteral instances corresponding to the given types."}, {"ID": 328, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> Optional<Key<T>> resolveDefaultQualifier(Map<Key<?>, Class<?>> bindings, ClassConfiguration<?> classConfiguration, String property, Class<?> qualifiedClass, TypeLiteral<T> genericInterface) { Key<T> key = null; if (classConfiguration != null && !classConfiguration.isEmpty()) { String qualifierName = classConfiguration.get(property); if (qualifierName != null && !\"\".equals(qualifierName)) { try { ClassLoader classLoader = ClassLoaders.findMostCompleteClassLoader(BusinessUtils.class); Class<?> qualifierClass = classLoader.loadClass(qualifierName); if (Annotation.class.isAssignableFrom(qualifierClass)) { key = Key.get(genericInterface, (Class<? extends Annotation>) qualifierClass); } else { throw BusinessException.createNew(BusinessErrorCode.CLASS_IS_NOT_AN_ANNOTATION) .put(\"class\", qualifiedClass) .put(\"qualifier\", qualifierName); } } catch (ClassNotFoundException e) { key = Key.get(genericInterface, Names.named(qualifierName)); } } } if (key == null || bindings.containsKey(Key.get(key.getTypeLiteral()))) { return Optional.empty(); } else { return Optional.of(key); } }\n\n    ### Response: Returns the Guice key qualified with the default qualifier configured for the specified class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { Type type = typeLiteral.getType(); if (!isFullySpecified(type)) { Errors errors = new Errors().keyNotFullySpecified(typeLiteral); throw new ConfigurationException(errors.getMessages()); } if (typeLiteral.getRawType() == javax.inject.Provider.class) { ParameterizedType parameterizedType = (ParameterizedType) type; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @SuppressWarnings(\"unchecked\") TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0])); return guiceProviderType; } @SuppressWarnings(\"unchecked\") TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral); if (wrappedPrimitives != null) { return wrappedPrimitives; } // If we know this isn't a subclass, return as-is. if (typeLiteral.getClass() == TypeLiteral.class) { return typeLiteral; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @SuppressWarnings(\"unchecked\") TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType()); return recreated; }\n\n    ### Response:", "ground_truth": "Returns an type that's appropriate for use in a key.\n\nIf the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a\n{@code com.google.inject.Provider} with the same type parameters.\n\nIf the type is a primitive, the corresponding wrapper type will be returned.\n\n@throws ConfigurationException if {@code type} contains a type variable", "predict": " Returns a canonicalized TypeLiteral for the specified type. If the type is not fully specified, a ConfigurationException is thrown. If the type is a Provider, a TypeLiteral for the Guice Provider is returned. If the type is a primitive, a TypeLiteral for its wrapper is returned. If the type is already a TypeLiteral, it is returned as-is."}, {"ID": 329, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DFALearner<I> asDFALearner() { return new DFALearner<I>() { @Override public String toString() { return NLStarLearner.this.toString(); } @Override public void startLearning() { NLStarLearner.this.startLearning(); } @Override public boolean refineHypothesis(DefaultQuery<I, Boolean> ceQuery) { return NLStarLearner.this.refineHypothesis(ceQuery); } @Override public CompactDFA<I> getHypothesisModel() { return NLStarLearner.this.getDeterminizedHypothesis(); } }; }\n\n    ### Response: Retrieves a view of this learner as a DFA learner. The DFA is obtained by determinizing and minimizing the NFA\nhypothesis.\n\n@return a DFA learner view of this learner\n\n@see #getDeterminizedHypothesis().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \"TypeConverter<Character>\"; } }); convertToClasses( injector, Matchers.subclassesOf(Enum.class), new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { return Enum.valueOf((Class) toType.getRawType(), value); } @Override public String toString() { return \"TypeConverter<E extends Enum<E>>\"; } }); internalConvertToTypes( injector, new AbstractMatcher<TypeLiteral<?>>() { @Override public boolean matches(TypeLiteral<?> typeLiteral) { return typeLiteral.getRawType() == Class.class; } @Override public String toString() { return \"Class<?>\"; } }, new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new RuntimeException(e.getMessage()); } } @Override public String toString() { return \"TypeConverter<Class<?>>\"; } }); }\n\n    ### Response:", "ground_truth": "Installs default converters for primitives, enums, and class literals.", "predict": "Configures the built-in type converters for the given injector.\n\n@param injector the injector to configure\n\n@see #convertToPrimitiveType(InjectorImpl, Class, Class)\n@see #convertToClass(InjectorImpl, Class, TypeConverter)\n@see #convertToClasses(InjectorImpl, Matcher, TypeConverter)\n@see #internalConvertToTypes(InjectorImpl, Matcher, TypeConverter)\n\n    "}, {"ID": 330, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassLoader getClassLoader() { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); return (classLoader != null) ? classLoader : ClassLoaderUtils.class.getClassLoader(); }\n\n    ### Response: Load the available ClassLoader\n\n@return ClassLoader.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static ClassLoader canonicalize(ClassLoader classLoader) { return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent(); }\n\n    ### Response:", "ground_truth": "Attempts to canonicalize null references to the system class loader. May return null if for\nsome reason the system loader is unavailable.", "predict": " Get the canonical ClassLoader for the specified ClassLoader.\n\n@param classLoader the ClassLoader to canonicalize\n@return the canonical ClassLoader for the specified ClassLoader, or the system ClassLoader if the specified ClassLoader is null."}, {"ID": 331, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> classForName(String className, ClassLoader classLoader) { try { Class<?> c = null; try { c = Class.forName(className, true, ReflectUtils.class.getClassLoader()); } catch (ClassNotFoundException e) { try { c = Class.forName(className); } catch (ClassNotFoundException e1) { if (classLoader == null) { throw e1; } else { c = classLoader.loadClass(className); } } } return c; } catch (ClassNotFoundException e) { throw new KunderaException(e); } }\n\n    ### Response: Loads class with className using classLoader.\n\n@param className\nthe class name\n@param classLoader\nthe class loader\n@return the class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasSameVersionOfCglib(ClassLoader classLoader) { Class<?> fc = net.sf.cglib.reflect.FastClass.class; try { return classLoader.loadClass(fc.getName()) == fc; } catch (ClassNotFoundException e) { return false; } }\n\n    ### Response:", "ground_truth": "Returns true if the types classloader has the same version of cglib that BytecodeGen has. This\nonly returns false in strange OSGI situations, but it prevents us from using FastClass for non\npublic members.", "predict": " Checks if the given class loader has the same version of Cglib as the one used by Kundera.\n\n@param classLoader\nthe class loader\n@return true if the class loader has the same version of Cglib as the one used by Kundera, false otherwise."}, {"ID": 332, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean isDesignerMethod(Method method) { Class<?>[] parameterTypes = method.getParameterTypes(); for (Class<?> parameterType : parameterTypes) { if (parameterType.isAssignableFrom(TestDesigner.class)) { return true; } } return false; }\n\n    ### Response: Searches for method parameter of type test designer.\n@param method\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean isPubliclyCallable(Member member) { if (!Modifier.isPublic(member.getModifiers())) { return false; } Class<?>[] parameterTypes; if (member instanceof Constructor) { parameterTypes = ((Constructor) member).getParameterTypes(); } else { Method method = (Method) member; if (!Modifier.isPublic(method.getReturnType().getModifiers())) { return false; } parameterTypes = method.getParameterTypes(); } for (Class<?> type : parameterTypes) { if (!Modifier.isPublic(type.getModifiers())) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Returns true if the member can be called by a fast class generated in a different classloader.", "predict": " Checks if a member is publicly callable.\n@param member\n@return true if the member is publicly callable, false otherwise."}, {"ID": 333, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getAttachment(String key) { return key == null ? null : attachments.get(key); }\n\n    ### Response: get attachment.\n\n@param key the key\n@return attachment attachment.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); }\n\n    ### Response:", "ground_truth": "Replace annotation instances with annotation types, this is only appropriate for testing if a\nkey is bound and not for injecting.\n\n", "predict": " fix annotations.\n\n@param key the key\n@return fixed key with annotations fixed."}, {"ID": 334, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getPropertyValue(Object instance, boolean forceDirect) { try { if (instance == null) { return dflt == null || !isSerializable() ? null : getPropertyType().getSerializer().deserialize(dflt); } if (!forceDirect && instance instanceof IPropertyAccessor) { return ((IPropertyAccessor) instance).getPropertyValue(this); } Method method = PropertyUtil.findGetter(getter, instance, null); return method == null ? null : method.invoke(instance); } catch (Exception e) { throw MiscUtil.toUnchecked(e); } }\n\n    ### Response: Returns the property value for a specified object instance.\n\n@param instance The object instance.\n@param forceDirect If true, a forces a direct read on the instance even if it implements\nIPropertyAccessor\n@return The object's property value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> Initializable<T> requestInjection( InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Member injection could not be requested after validation is started\"); ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding); // short circuit if the object has no injections or listeners. if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return Initializables.of(instance); } if (initializablesCache.containsKey(instance)) { @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T> Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance); return cached; } InjectableReference<T> injectableReference = new InjectableReference<T>( injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass())); initializablesCache.put(instance, injectableReference); pendingInjections.add(injectableReference); return injectableReference; }\n\n    ### Response:", "ground_truth": "Registers an instance for member injection when that step is performed.\n\n@param instance an instance that optionally has members to be injected (each annotated\nwith @Inject).\n@param binding the binding that caused this initializable to be created, if it exists.\n@param source the source location that this injection was requested", "predict": " Requests injection for a specified instance.\n\n@param injector The injector to use for injection.\n@param instance The instance to inject.\n@param binding The binding to use for injection.\n@param source The source of the injection request.\n@param injectionPoints The injection points to use for injection.\n@return An Initializable that can be used to track the injection process.\n\n    "}, {"ID": 335, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void start() throws Exception { if (running) { return; } List<Connector> startedConnectors = new ArrayList<Connector>(); for (Connector each : this.connectors) { try { each.setServer( this ); each.start(); startedConnectors.add( each ); } catch (Exception e) { for (Connector stop : startedConnectors) { try { stop.stop(); } catch (Exception e2) { } } throw e; } } running = true; }\n\n    ### Response: Start this server.\n\n@throws Throwable.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } }\n\n    ### Response:", "ground_truth": "Prepares member injectors for all injected instances. This prompts Guice to do static analysis\non the injected instances.", "predict": " Validate any outstanding injections.\n\n@throws ErrorsException if there are any validation errors."}, {"ID": 336, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Object proceed(InvocationContext ctx) throws Throwable { try { return ctx.proceed(); } catch (InvocationTargetException e) { throw e.getCause(); } }\n\n    ### Response: Proceed further.\n\n@param ctx {@link InvocationContext}\n@return method return value\n@throws Throwable if intercepted method throws exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T newInstance(Object[] args) throws Throwable { constructor.setAccessible(true); try { return constructor.newInstance(args); } catch (InvocationTargetException e) { throw e.getCause(); } }\n\n    ### Response:", "ground_truth": "Returns an instance of T, constructed using this constructor, with the supplied arguments.", "predict": " Create a new instance of the class.\n\n@param args array of arguments to be passed to the constructor\n@return new instance of the class\n@throws Throwable if constructor throws exception."}, {"ID": 337, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException, ServletException { final HttpServletRequest request = (HttpServletRequest) servletRequest; final String path = ServletUtils.getContextRelativePath(request); final boolean serve = shouldServe(path); //invocations of the chain end at the first matched servlet if (serve) { doService(servletRequest, servletResponse); } //return false if no servlet matched (so we can proceed down to the web.xml servlets) return serve; }\n\n    ### Response: Wrapper around the service chain to ensure a servlet is servicing what it must and provides it\nwith a wrapped request.\n\n@return Returns true if this servlet triggered for the given request. Or false if guice-servlet\nshould continue dispatching down the servlet pipeline.\n@throws IOException If thrown by underlying servlet\n@throws ServletException If thrown by underlying servlet.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"JavaDoc\", \"deprecation\"}) private ServletRequest withDispatcher( ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if (!servletPipeline.hasServletsMapped()) { return servletRequest; } HttpServletRequest request = (HttpServletRequest) servletRequest; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper(request) { @Override public RequestDispatcher getRequestDispatcher(String path) { final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path); return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path); } }; }\n\n    ### Response:", "ground_truth": "Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular\npipeline based on uri-path match. This proxy also provides minimal forwarding support.\n\nWe cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline\nis not called again). However, we can wrap requests with our own dispatcher to forward the\n*other* way. web.xml Servlets/JSPs can forward to themselves as per normal.\n\nThis is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,\nincrementally, but not the other way around (which, we should actively discourage).", "predict": " Wraps the given request with a request wrapper that delegates to the given\nservlet pipeline for request dispatching.\n\n@param servletRequest The request to wrap\n@param servletPipeline The servlet pipeline to delegate to\n@return The wrapped request, or the original request if no servlets are mapped\n@throws ServletException If the request wrapper cannot be created due to a servlet error"}, {"ID": 338, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> T pickPluck (Iterable<? extends T> iterable, T ifEmpty, boolean remove) { if (iterable instanceof Collection) { // optimized path for Collection @SuppressWarnings(\"unchecked\") Collection<? extends T> coll = (Collection<? extends T>)iterable; int size = coll.size(); if (size == 0) { return ifEmpty; } if (coll instanceof List) { // extra-special optimized path for Lists @SuppressWarnings(\"unchecked\") List<? extends T> list = (List<? extends T>)coll; int idx = _r.nextInt(size); if (remove) { // ternary conditional causes warning here with javac 1.6, :( return list.remove(idx); } return list.get(idx); } // for other Collections, we must iterate Iterator<? extends T> it = coll.iterator(); for (int idx = _r.nextInt(size); idx > 0; idx--) { it.next(); } try { return it.next(); } finally { if (remove) { it.remove(); } } } if (!remove) { return pick(iterable.iterator(), ifEmpty); } // from here on out, we're doing a pluck with a complicated two-iterator solution Iterator<? extends T> it = iterable.iterator(); if (!it.hasNext()) { return ifEmpty; } Iterator<? extends T> lagIt = iterable.iterator(); T pick = it.next(); lagIt.next(); for (int count = 2, lag = 1; it.hasNext(); count++, lag++) { T next = it.next(); if (0 == _r.nextInt(count)) { pick = next; // catch up lagIt so that it has just returned 'pick' as well for ( ; lag > 0; lag--) { lagIt.next(); } } } lagIt.remove(); // remove 'pick' from the lagging iterator return pick; }\n\n    ### Response: Shared code for pick and pluck..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> InternalFactory<? extends T> scope( Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) { if (scoping.isNoScope()) { return creator; } Scope scope = scoping.getScopeInstance(); // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here. If you change the type make sure to update // SingletonScope as well. Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)); return new InternalFactoryToProviderAdapter<T>(scoped, source); }\n\n    ### Response:", "ground_truth": "Scopes an internal factory.", "predict": "Provides a scoped instance of a creator.\n\n    "}, {"ID": 339, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean inScope(final Injector injector, final Binding<?> binding, final Class<? extends Annotation> scope) { return binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>() { @Override public Boolean visitEagerSingleton() { return scope == Singleton.class || scope == javax.inject.Singleton.class; } @Override public Boolean visitNoScoping() { return false; } @Override public Boolean visitScope(Scope guiceScope) { return injector.getScopeBindings().get(scope) == guiceScope; } @Override public Boolean visitScopeAnnotation(Class<? extends Annotation> scopeAnnotation) { return scopeAnnotation == scope; } }); }\n\n    ### Response: Returns true if the binding is in the specified scope, false otherwise.\n@param binding the binding to inspect\n@param scope the scope to look for\n@return true if the binding is in the specified scope, false otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) { Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation(); if (scopeAnnotation == null) { return scoping; } ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation); if (scope != null) { return forInstance(scope.getScope()); } errors.scopeNotFound(scopeAnnotation); return UNSCOPED; }\n\n    ### Response:", "ground_truth": "Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance\nmap. If the scope annotation has no corresponding instance, an error will be added and unscoped\nwill be retuned.", "predict": " Creates a new scoping object that injects dependencies into the specified scope.\n@param scoping the scoping object to wrap\n@param injector the injector to use for scoping\n@param errors the error reporter to use\n@return a new scoping object that injects dependencies into the specified scope.\n\n    "}, {"ID": 340, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String joinElementsToId(List<String> elements) { Preconditions.checkNotNull(elements, \"elements argument\"); StringBuilder sb = new StringBuilder(); for (String el : elements) { // Skip null elements if (el == null) { continue; } // Trim the elements and skip any empty ones String trimmedEl = el.trim(); if (trimmedEl.length() < 1) { continue; } // \\ -> \\\\ trimmedEl = MATCH_BACKSLASH.matcher(trimmedEl).replaceAll(\"\\\\\\\\\\\\\\\\\"); // : -> \\: trimmedEl = MATCH_COLON.matcher(trimmedEl).replaceAll(\"\\\\\\\\:\"); if (sb.length() > 0) { sb.append(SEPARATOR); } sb.append(trimmedEl); } return sb.toString(); }\n\n    ### Response: Joins a list of elements into a resource id, escaping\nspecial characters if required.\n\nSee {@link #splitIdIntoElements(String)} for details.\n\n@param elements a list of elements\n@return the resource id.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String normalizePath(String path) { StringBuilder sb = new StringBuilder(path.length()); int queryStart = path.indexOf('?'); String query = null; if (queryStart != -1) { query = path.substring(queryStart); path = path.substring(0, queryStart); } // Normalize the path. we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List<String> segments = new ArrayList<>(); for (String segment : SLASH_SPLITTER.split(path)) { // This decodes all non-special characters from the path segment. so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false)); if (\".\".equals(normalized)) { // skip } else if (\"..\".equals(normalized)) { if (segments.size() > 1) { segments.remove(segments.size() - 1); } } else { segments.add(normalized); } } SLASH_JOINER.appendTo(sb, segments); if (query != null) { sb.append(query); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Normalizes a path by unescaping all safe, percent encoded characters.", "predict": "Normalizes a path by decoding percent-encoded characters, interpreting dangerous sequences, and preserving encoded characters.\n\n@param path the path to normalize\n@return the normalized path."}, {"ID": 341, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T create(Class<T> annotationType) { return new Builder<T>(annotationType).create(); }\n\n    ### Response: Convenience method that constructs an annotation instance with no elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); }\n\n    ### Response:", "ground_truth": "Generates an Annotation for the annotation class. Requires that the annotation is all\noptionals.", "predict": " Returns an instance of the specified annotation type, creating it if necessary. The annotation is created using the default constructor and cached for future use. The method first checks that the annotation type has only default methods, as specified by the Java Language Specification. If the annotation type does not have only default methods, a runtime exception is thrown."}, {"ID": 342, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A extends Annotation> boolean isAnnotationPresent(Class<?> clazz, Class<A> annotationType) { if (findAnnotation(clazz, annotationType) != null) return true; return false; }\n\n    ### Response: Verifies if an annotation is present at a class type hierarchy.\n\n@param  The annotation type.\n@param clazz The class.\n@param annotationType The annotation.\n@return Whether the annotation is present at the class hierarchy or not.\n@since 0.3.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) { Retention retention = annotationType.getAnnotation(Retention.class); return retention != null && retention.value() == RetentionPolicy.RUNTIME; }\n\n    ### Response:", "ground_truth": "Returns true if the given annotation is retained at runtime.", "predict": " Checks if an annotation is retained at runtime.\n\n@param annotationType The annotation type.\n@return Whether the annotation is retained at runtime or not.\n@since 0.3.0."}, {"ID": 343, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> Class<? extends Annotation> matchAnnotationToScope(Annotation[] annotations) { for (Annotation next : annotations) { Class<? extends Annotation> nextType = next.annotationType(); if (nextType.getAnnotation(BindingScope.class) != null) { return nextType; } } return DefaultBinding.class; }\n\n    ### Response: Helper method for matching and returning a scope annotation\n@param annotations Annotations to inspect for a scope annotation\n@return The matched annotation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<? extends Annotation> findScopeAnnotation( Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; }\n\n    ### Response:", "ground_truth": "Returns the scoping annotation, or null if there isn't one.", "predict": " Helper method for finding a scope annotation\n@param errors Error reporter\n@param annotations Annotations to inspect for a scope annotation\n@return The matched annotation.\n\n    "}, {"ID": 344, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Key<?> getKey(Type type, Annotation bindingAnnotation) throws ProvisionException { if (bindingAnnotation == null) { return Key.get(type); } else { return Key.get(type, bindingAnnotation); } }\n\n    ### Response: Gets the Guice binding key for a given Java type with optional\nannotations.\n\n@param type Java type to convert in to a key\n@param bindingAnnotation binding annotation for this key\n@return Guice Key instance for this type/annotations\n@throws ProvisionException in case of any failure.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); }\n\n    ### Response:", "ground_truth": "Gets a key for the given type, member and annotations.", "predict": " Gets the Guice binding key for a given Java type with optional\nannotations.\n\n@param type Java type to convert in to a key\n@param member member that is annotated with the binding annotation\n@param annotations array of annotations on the member\n@param errors error collector for any errors\n@return Guice Key instance for this type/annotations\n@throws ErrorsException in case of any errors."}, {"ID": 345, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T getAnnotation(final Class<?> componentClass, final Class<T> annotationClass) { T annotation = componentClass.getAnnotation(annotationClass); if (annotation != null) { return annotation; } for (final Class<?> ifc : componentClass.getInterfaces()) { annotation = getAnnotation(ifc, annotationClass); if (annotation != null) { return annotation; } } if (!Annotation.class.isAssignableFrom(componentClass)) { for (final Annotation ann : componentClass.getAnnotations()) { annotation = getAnnotation(ann.annotationType(), annotationClass); if (annotation != null) { return annotation; } } } final Class<?> superClass = componentClass.getSuperclass(); if (superClass == null || superClass.equals(Object.class)) { return null; } return getAnnotation(superClass, annotationClass); }\n\n    ### Response: Search for the given annotationClass in the given componentClass and return it if search was\nsuccessful.\n\n@param \nthe generic type\n@param componentClass\nthe component class\n@param annotationClass\nthe annotation class\n@return the annotation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } }\n\n    ### Response:", "ground_truth": "Returns the name the binding should use. This is based on the annotation. If the annotation has\nan instance and is not a marker annotation, we ask the annotation for its toString. If it was a\nmarker annotation or just an annotation type, we use the annotation's name. Otherwise, the name\nis the empty string.", "predict": " Returns the name of the annotation associated with the given key. If the key has no annotation, returns the name of the annotation type if it is not a marker annotation, or an empty string otherwise.\n\n@param key\nthe key\n@return the name of the annotation associated with the key, or an empty string if there is no annotation or if it is a marker annotation."}, {"ID": 346, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDelegate(Object delegate) { this.delegate = delegate; this.metaClass = InvokerHelper.getMetaClass(delegate.getClass()); }\n\n    ### Response: Sets the delegation target..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); }\n\n    ### Response:", "ground_truth": "Sets the actual provider.\n\n@throws IllegalStateException if the delegate is already set", "predict": " Initializes the delegation target."}, {"ID": 347, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void configureFormatterPreferences(Binder binder) { binder.bind(IPreferenceValuesProvider.class).annotatedWith(FormatterPreferences.class).to(FormatterPreferenceValuesProvider.class); }\n\n    ### Response: contributed by org.eclipse.xtext.xtext.generator.formatting.Formatter2Fragment2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); }\n\n    ### Response:", "ground_truth": "Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate\nbindings.", "predict": " contributed by org.eclipse.xtext.xtext.generator.java.JavaGeneratorFragment2."}, {"ID": 348, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ParseException create(List<ParseError> errors) { if (errors.size() == 1) { return new ParseException(errors.get(0).getMessage(), errors); } else if (errors.size() > 1) { return new ParseException(String.format(\"%d errors occured. First: %s\", errors.size(), errors.get(0).getMessage()), errors); } else { return new ParseException(\"An unknown error occured\", errors); } }\n\n    ### Response: Creates a new exception based on the list of errors.\n\n@param errors the errors which occurred while processing the user input\n@return a new ParseException which can be thrown.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); }\n\n    ### Response:", "ground_truth": "Returns a new complete constructor injector with injection listeners registered.", "predict": " Retrieves the cached constructor injector for the given injection point and errors.\n\n@param constructorInjector the injection point for which to retrieve the cached constructor injector\n@param errors the errors which occurred while processing the user input\n@return the cached constructor injector for the given injection point and errors\n@throws ErrorsException if there is an error retrieving the cached constructor injector\n\n    "}, {"ID": 349, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasAnnotation(Annotation[] parameterAnnotations, Class<? extends Annotation> annotationClass) { for (Annotation annotation : parameterAnnotations) { if (annotation.annotationType().equals(annotationClass)) { return true; } } return false; }\n\n    ### Response: Returns true if any annotation in parameterAnnotations matches annotationClass.\n\n@param parameterAnnotations Annotations to inspect.\n@param annotationClass      Annotation to find.\n\n@return  true if any annotation in parameterAnnotations matches annotationClass, else false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasScope(Class<? extends Interceptor> interceptorClass) { for (Annotation annotation : interceptorClass.getAnnotations()) { if (Annotations.isScopeAnnotation(annotation.annotationType())) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Returns true if the given class has a scope annotation.", "predict": " Returns true if the interceptorClass has a scope annotation.\n\n@param interceptorClass  Interceptor class to inspect.\n\n@return  true if the interceptorClass has a scope annotation, else false."}, {"ID": 350, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <K, V> int computeMapSize(int order, Map<K, V> map, com.google.protobuf.WireFormat.FieldType keyType, K defaultKey, com.google.protobuf.WireFormat.FieldType valueType, V defalutValue) { int size = 0; for (java.util.Map.Entry<K, V> entry : map.entrySet()) { com.baidu.bjf.remoting.protobuf.MapEntry<K, V> valuesDefaultEntry = com.baidu.bjf.remoting.protobuf.MapEntry .<K, V> newDefaultInstance(null, keyType, defaultKey, valueType, defalutValue); com.baidu.bjf.remoting.protobuf.MapEntry<K, V> values = valuesDefaultEntry.newBuilderForType().setKey(entry.getKey()).setValue(entry.getValue()).build(); size += com.google.protobuf.CodedOutputStream.computeMessageSize(order, values); } return size; }\n\n    ### Response: Compute map size.\n\n@param  the key type\n@param  the value type\n@param order the order\n@param map the map\n@param keyType the key type\n@param defaultKey the default key\n@param valueType the value type\n@param defalutValue the defalut value\n@return the int.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <K, V> RealMapBinder<K, V> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) { binder = binder.skipSources(RealMapBinder.class); TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral(); return newRealMapBinder( binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder( binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType)))); }\n\n    ### Response:", "ground_truth": "since it's an easy way to group a type and an optional annotation type or instance.", "predict": " Create a new real map binder.\n\n@param binder the binder\n@param keyType the key type\n@param valueType the value type\n@param mapType the map type\n@param valueSetBinder the value set binder\n@return the real map binder."}, {"ID": 351, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int delete(CMAApiKey key) { assertNotNull(key, \"key\"); final String space = getSpaceIdOrThrow(key, \"key\"); final String id = getResourceIdOrThrow(key, \"key\"); return service.delete(space, id).blockingFirst().code(); }\n\n    ### Response: Delete a given api key from the configured space.\n\n@param key the key to be deleted.\n@return 204 upon success.\n@throws IllegalArgumentException if key is null.\n@throws IllegalArgumentException if key's spaceId is null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Key<V> getKeyForNewValue(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey)); return valueKey; }\n\n    ### Response:", "ground_truth": "Adds a binding to the map for the given key.", "predict": " Get a new key for a new value in the map.\n\n@param key the key for which a new value is being added.\n@return a new key for the new value.\n@throws IllegalArgumentException if key is null.\n@throws IllegalStateException if the MapBinder has already been initialized."}, {"ID": 352, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object invokeInTransactionAndUnitOfWork(MethodInvocation methodInvocation) throws Throwable { boolean unitOfWorkAlreadyStarted = unitOfWork.isActive(); if (!unitOfWorkAlreadyStarted) { unitOfWork.begin(); } Throwable originalThrowable = null; try { return dslContextProvider.get().transactionResult(() -> { try { return methodInvocation.proceed(); } catch (Throwable e) { if (e instanceof RuntimeException) { throw (RuntimeException) e; } throw new RuntimeException(e); } }); } catch (Throwable t) { originalThrowable = t; throw t; } finally { if (!unitOfWorkAlreadyStarted) { endUnitOfWork(originalThrowable); } } }\n\n    ### Response: Invokes the method wrapped within a unit of work and a transaction.\n\n@param methodInvocation the method to be invoked within a transaction\n@return the result of the call to the invoked method\n@throws Throwable if an exception occurs during the method invocation, transaction, or unit of\nwork.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return t; } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor(cause) .addSource(constructionProxy.getInjectionPoint()); } finally { constructionContext.removeCurrentReference(); } }\n\n    ### Response:", "ground_truth": "Provisions a new T.", "predict": " Provisions an instance of the type parameter T using the given context and construction context.\n\n@param context the context to use for provision\n@param constructionContext the construction context to use for provision\n@return the provisioned instance\n@throws InternalProvisionException if an error occurs during provision"}, {"ID": 353, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object[] getParameterValues(ControlBeanContext context, Method method, Object[] args) { Object value = getParameterValue(context, method, args); if (value instanceof JdbcControl.ComplexSqlFragment) { JdbcControl.SQLParameter[] params = ((JdbcControl.ComplexSqlFragment)value).getParameters(); Object[] values = new Object[params.length]; for (int i = 0; i < params.length; i++) { values[i] = params[i].value; } return values; } return new Object[]{value}; }\n\n    ### Response: Get the value of this parameter.\n\n@param context ControlBeanContext instance to evaluate the parameter's value against.\n@param method  Method instance to evaluate against.\n@param args    Method argument values\n@return All parameter object values contained within this fragment.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object writeReplace() throws ObjectStreamException { Object[] sourcesAsStrings = sources.toArray(); for (int i = 0; i < sourcesAsStrings.length; i++) { sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString(); } return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause); }\n\n    ### Response:", "ground_truth": "When serialized, we eagerly convert sources to strings. This hurts our formatting, but it\nguarantees that the receiving end will be able to read the message.", "predict": " Serialize this object for transmission or persistence.\n\n@return Serialized representation of this object."}, {"ID": 354, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Module combineAndOverride(List<? extends Module> modules) { Iterator<? extends Module> iter = modules.iterator(); Module current = Modules.EMPTY_MODULE; if (iter.hasNext()) { current = iter.next(); if (iter.hasNext()) { current = Modules.override(current).with(iter.next()); } } return current; }\n\n    ### Response: Generate a single module that is produced by accumulating and overriding\neach module with the next.\n\n\n{@code\nGuice.createInjector(ModuleUtils.combineAndOverride(moduleA, moduleAOverrides, moduleB));\n}\n\n\n@param modules\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Module forModule(Module module) { // avoid infinite recursion, since installing a module always installs itself if (module instanceof CheckedProviderMethodsModule) { return Modules.EMPTY_MODULE; } return new CheckedProviderMethodsModule(module); }\n\n    ### Response:", "ground_truth": "Returns a module which creates bindings for provider methods from the given module.", "predict": "Create a new module that wraps the given module, but only if it is not already a CheckedProviderMethodsModule. This is to avoid infinite recursion, since installing a module always installs itself."}, {"ID": 355, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> Map<E, Double> asMap(final Counter<E> counter) { return new AbstractMap<E, Double>() { @Override public int size() { return counter.size(); } @Override public Set<Entry<E, Double>> entrySet() { return counter.entrySet(); } @Override @SuppressWarnings(\"unchecked\") public boolean containsKey(Object key) { return counter.containsKey((E) key); } @Override @SuppressWarnings(\"unchecked\") public Double get(Object key) { return counter.getCount((E) key); } @Override public Double put(E key, Double value) { double last = counter.getCount(key); counter.setCount(key, value); return last; } @Override @SuppressWarnings(\"unchecked\") public Double remove(Object key) { return counter.remove((E) key); } @Override public Set<E> keySet() { return counter.keySet(); } }; }\n\n    ### Response: Returns a map view of the given counter..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings(\"unchecked\") public Collection<AssistedMethod> getAssistedMethods() { return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values(); }\n\n    ### Response:", "ground_truth": "the collection is immutable.", "predict": " Returns a collection of all the assist data for the methods in the class."}, {"ID": 356, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isSingleResult() { if (result == null) { return false; } else { if (singleResult == null) { if (result.size() == 1 && result.values().iterator().next().size() == 1) { singleResult = true; } else { singleResult = false; } } return singleResult; } }\n\n    ### Response: Returns true if the search resulted in a single result in a single layer.\nfalse in all other cases. Also returns false when search has not yet been\nrun.\n\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) { Collection<Message> messages = ce.getErrorMessages(); if (messages.size() == 1) { Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages()); return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage()); } else { return false; } }\n\n    ### Response:", "ground_truth": "Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully\nspecified.", "predict": " Checks if the type specified in the configuration is not specified.\n\n@param typeLiteral. The type literal that was not fully specified.\n@param ce. The configuration exception that occurred.\n@return. True if the type is not specified, false otherwise."}, {"ID": 357, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String[] extractConstructorParameters(Key<?> factoryKey, TypeLiteral<?> implementation, Constructor constructor, List<Key<?>> methodParams, Errors errors, Set<Dependency> dependencyCollector) throws ErrorsException { // Get parameters with annotations. List<TypeLiteral<?>> ctorParams = implementation.getParameterTypes(constructor); Annotation[][] ctorParamAnnotations = constructor.getParameterAnnotations(); int p = 0; String[] parameterNames = new String[ctorParams.size()]; Set<Key<?>> keySet = new LinkedHashSet<Key<?>>(); for (TypeLiteral<?> ctorParam : ctorParams) { Key<?> ctorParamKey = getKey(ctorParam, constructor, ctorParamAnnotations[p], errors); if (ctorParamKey.getAnnotationType() == Assisted.class) { if (!keySet.add(ctorParamKey)) { errors.addMessage(PrettyPrinter.format( \"%s has more than one parameter of type %s annotated with @Assisted(\\\"%s\\\"). \" + \"Please specify a unique value with the annotation to avoid confusion.\", implementation, ctorParamKey.getTypeLiteral().getType(), ((Assisted) ctorParamKey.getAnnotation()).value())); } int location = methodParams.indexOf(ctorParamKey); // This should never happen since the constructor was already checked // in #[inject]constructorHasMatchingParams(..). Preconditions.checkState(location != -1); parameterNames[p] = ReflectUtil.formatParameterName(location); } else { dependencyCollector.add(new Dependency(factoryKey, ctorParamKey, false, true, constructor.toString())); } p++; } return parameterNames; }\n\n    ### Response: Matches constructor parameters to method parameters for injection and\nrecords remaining parameters as required keys..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean constructorHasMatchingParams( TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException { List<TypeLiteral<?>> params = type.getParameterTypes(constructor); Annotation[][] paramAnnotations = constructor.getParameterAnnotations(); int p = 0; List<Key<?>> constructorKeys = Lists.newArrayList(); for (TypeLiteral<?> param : params) { Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors); constructorKeys.add(paramKey); } // Require that every key exist in the constructor to match up exactly. for (Key<?> key : paramList) { // If it didn't exist in the constructor set, we can't use it. if (!constructorKeys.remove(key)) { return false; } } // If any keys remain and their annotation is Assisted, we can't use it. for (Key<?> key : constructorKeys) { if (key.getAnnotationType() == Assisted.class) { return false; } } // All @Assisted params match up to the method's parameters. return true; }\n\n    ### Response:", "ground_truth": "Matching logic for constructors annotated with AssistedInject. This returns true if and only if\nall @Assisted parameters in the constructor exactly match (in any order) all @Assisted\nparameters the method's parameter.", "predict": " Checks if the constructor has the same number of parameters as the method's parameter list. If not, it returns false. Otherwise, it checks if each parameter in the method's parameter list exists in the constructor. If not, it returns false. If any parameter in the constructor is annotated with @Assisted, it returns false. Otherwise, it returns true."}, {"ID": 358, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Collection<String> getVariableNames() { ImmutableSet.Builder<String> builder = ImmutableSet.builder(); for ( ConfigurationKeyPart p : parts ) { if ( p.isVariable() ) { builder.add(p.getValue()); } } return builder.build(); }\n\n    ### Response: Return the names of the variables specified in the key if any\n\n@return names (might be zero sized).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); builder.addAll(ctorPoint.getDependencies()); if (!implementation.getRawType().isInterface()) { for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) { builder.addAll(ip.getDependencies()); } } return builder.build(); }\n\n    ### Response:", "ground_truth": "Calculates all dependencies required by the implementation and constructor.", "predict": "Return the set of dependencies required to satisfy the constructor of the given type and any instance methods or fields of the implementation type.\n\n@param ctorPoint the injection point for the constructor of the given type\n@param implementation the implementation type\n@return the set of dependencies required to satisfy the constructor and instance methods/fields of the implementation type."}, {"ID": 359, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function _recursiveDeps(graph, name, deps) { return Object.keys(deps).forEach((key) => { const dep = deps[key]; if (PLUGIN.test(dep)) { return; } if (typeof dep === 'string') { if (!graph.hasNode(dep)) { graph.addNode(dep); } graph.addDependency(name, dep); } else if (typeof dep === 'object') { _recursiveDeps(graph, name, deps[key]); } }); }\n\n    ### Response: Add recursive dependencies to dependency graph\n@param  {DepGraph} graph\n@param  {String} name - current node name\n@param  {Object} deps - dependency map\n@private.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); for (Dependency<?> dep : deps) { Class<?> annotationType = dep.getKey().getAnnotationType(); if (annotationType == null || !annotationType.equals(Assisted.class)) { builder.add(dep); } } return builder.build(); }\n\n    ### Response:", "ground_truth": "Return all non-assisted dependencies.", "predict": " Remove assisted dependencies from set\n@param  {Set<Dependency<?>>>} deps - set of dependencies\n@return {Set<Dependency<?>>>} set of dependencies without assisted dependencies\n@private."}, {"ID": 360, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean getBooleanProperty(String key, String defaultValue, StringBuilder errors) { boolean booleanValue = false; String stringValue = null; boolean valueCorrect = false; // Pull the key from the property map Object objectValue = this.properties.get(key); if (objectValue != null) { if (objectValue instanceof Boolean) { booleanValue = ((Boolean) objectValue).booleanValue(); if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) { Tr.debug(tc, \"Property \" + key + \" set to \" + booleanValue); } return booleanValue; } else if (objectValue instanceof String) { stringValue = (String) objectValue; } } else { // Key is not in map. if (defaultValue != null) { stringValue = defaultValue; } else { // No default provided. Error. errors.append(key); errors.append(':'); errors.append(stringValue); errors.append('\\n'); return false; } } // If we get this far, we have a non null string value to work with. May be the default. // Verify the value. if (stringValue != null) { if (stringValue.equals(\"true\")) { booleanValue = true; valueCorrect = true; } else if (stringValue.equals(\"false\")) { booleanValue = false; valueCorrect = true; } } if (valueCorrect) { if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) { Tr.debug(tc, \"Property \" + key + \" set to \" + booleanValue); } } else { if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) { Tr.debug(tc, \"Property \" + key + \" has invalid value \" + stringValue); } errors.append(key); errors.append(':'); errors.append(stringValue); errors.append('\\n'); } return booleanValue; }\n\n    ### Response: Extract String value from property list and convert to boolean.\n\n@param key key to look up in the property map\n@param defaultValue used if keynot found in map.\n@param errors list of error string accumulating from reading invalid properties\n@return value found for key in property map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { Set<Dependency<?>> badDeps = null; // optimization: create lazily for (Dependency<?> dep : dependencies) { if (isInjectorOrAssistedProvider(dep)) { if (badDeps == null) { badDeps = Sets.newHashSet(); } badDeps.add(dep); } } if (badDeps != null && !badDeps.isEmpty()) { logger.log( Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!) \" + \"The exact offending deps are: {2}\", new Object[] {factoryType, implementation, badDeps}); return false; } return true; }\n\n    ### Response:", "ground_truth": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "predict": " Check if the given set of dependencies contains any dependencies that are either the Injector or an Assisted Provider. If so, log a warning and return false. Otherwise, return true.\n\n@param dependencies set of dependencies to check\n@param implementation class that the factory will create instances of\n@param factoryType type of the factory\n@return true if the dependencies are valid for optimized assisted inject, false otherwise."}, {"ID": 361, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void linkRequested() { assertLockHeld(); Binding<?> binding; while ((binding = toLink.poll()) != null) { if (binding instanceof DeferredBinding) { DeferredBinding deferred = (DeferredBinding) binding; String key = deferred.deferredKey; boolean mustHaveInjections = deferred.mustHaveInjections; if (bindings.containsKey(key)) { continue; // A binding for this key has since been linked. } try { Binding<?> resolvedBinding = createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections); resolvedBinding.setLibrary(binding.library()); resolvedBinding.setDependedOn(binding.dependedOn()); // Fail if the type of binding we got wasn't capable of what was requested. if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) { throw new IllegalStateException(\"Unable to create binding for \" + key); } // Enqueue the JIT binding so its own dependencies can be linked. Binding<?> scopedBinding = scope(resolvedBinding); toLink.add(scopedBinding); putBinding(scopedBinding); } catch (InvalidBindingException e) { addError(e.type + \" \" + e.getMessage() + \" required by \" + binding.requiredBy); bindings.put(key, Binding.UNRESOLVED); } catch (UnsupportedOperationException e) { addError(\"Unsupported: \" + e.getMessage() + \" required by \" + binding.requiredBy); bindings.put(key, Binding.UNRESOLVED); } catch (IllegalArgumentException e) { addError(e.getMessage() + \" required by \" + binding.requiredBy); bindings.put(key, Binding.UNRESOLVED); } catch (RuntimeException e) { throw e; } catch (Exception e) { throw new RuntimeException(e); } } else { // Attempt to attach the binding to its dependencies. If any dependency // is not available, the attach will fail. We'll enqueue creation of // that dependency and retry the attachment later. attachSuccess = true; binding.attach(this); if (attachSuccess) { binding.setLinked(); } else { toLink.add(binding); } } } try { errorHandler.handleErrors(errors); } finally { errors.clear(); } }\n\n    ### Response: Links all requested bindings plus their transitive dependencies. This\ncreates JIT bindings as necessary to fill in the gaps.\n\n@throws AssertionError if this method is not called within a synchronized block which\nholds this {@link Linker} as the lock object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey).toProvider(Providers.of(args[p++])); } } else { for (Key<?> paramKey : data.paramTypes) { // Bind to our ThreadLocalProviders. binder.bind((Key) paramKey).toProvider(data.providers.get(p++)); } } Constructor constructor = data.constructor; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if (constructor != null) { binder .bind(returnKey) .toConstructor(constructor, (TypeLiteral) data.implementationType) .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type } } }; Injector forCreate = injector.createChildInjector(assistedModule); Binding<?> binding = forCreate.getBinding(returnKey); // If we have providers cached in data, cache the binding for future optimizations. if (data.optimized) { data.cachedBinding = binding; } return binding; }\n\n    ### Response:", "ground_truth": "Creates a child injector that binds the args, and returns the binding for the method's result.", "predict": "Returns a binding for the given method and arguments, creating a new injector\nwith an assisted module that provides the necessary dependencies.\n\n@param method the method to create a binding for\n@param args the arguments to the method\n@param data the assist data for the method\n@return a binding for the given method and arguments\n@throws IllegalStateException if the injector has not been initialized yet\n@throws IllegalArgumentException if the method is not annotated with {@link AssistedInject}"}, {"ID": 362, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object invoke(Object self, Method method, Method proceed, Object[] args) throws Throwable { if (\"destroy\".equals(method.getName()) && Marker.isMarker(0, method, args)) { if (bean.getEjbDescriptor().isStateful()) { if (!reference.isRemoved()) { reference.remove(); } } return null; } if (!bean.isClientCanCallRemoveMethods() && isRemoveMethod(method)) { throw BeanLogger.LOG.invalidRemoveMethodInvocation(method); } Class<?> businessInterface = getBusinessInterface(method); if (reference.isRemoved() && isToStringMethod(method)) { return businessInterface.getName() + \" [REMOVED]\"; } Object proxiedInstance = reference.getBusinessObject(businessInterface); if (!Modifier.isPublic(method.getModifiers())) { throw new EJBException(\"Not a business method \" + method.toString() +\". Do not call non-public methods on EJB's.\"); } Object returnValue = Reflections.invokeAndUnwrap(proxiedInstance, method, args); BeanLogger.LOG.callProxiedMethod(method, proxiedInstance, args, returnValue); return returnValue; }\n\n    ### Response: Looks up the EJB in the container and executes the method on it\n\n@param self    the proxy instance.\n@param method  the overridden method declared in the super class or\ninterface.\n@param proceed the forwarder method for invoking the overridden method. It\nis null if the overridden method is abstract or declared in the\ninterface.\n@param args    an array of objects containing the values of the arguments\npassed in the method invocation on the proxy instance. If a\nparameter type is a primitive type, the type of the array\nelement is a wrapper class.\n@return the resulting value of the method invocation.\n@throws Throwable if the method invocation fails..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if (methodHandleByMethod.containsKey(method)) { return methodHandleByMethod.get(method).invokeWithArguments(args); } if (method.getDeclaringClass().equals(Object.class)) { if (\"equals\".equals(method.getName())) { return proxy == args[0]; } else if (\"hashCode\".equals(method.getName())) { return System.identityHashCode(proxy); } else { return method.invoke(this, args); } } AssistData data = assistDataByMethod.get(method); checkState(data != null, \"No data for method: %s\", method); Provider<?> provider; if (data.cachedBinding != null) { // Try to get optimized form... provider = data.cachedBinding.getProvider(); } else { provider = getBindingFromNewInjector(method, args, data).getProvider(); } try { int p = 0; for (ThreadLocalProvider tlp : data.providers) { tlp.set(args[p++]); } return provider.get(); } catch (ProvisionException e) { // if this is an exception declared by the factory method, throw it as-is if (e.getErrorMessages().size() == 1) { Message onlyError = getOnlyElement(e.getErrorMessages()); Throwable cause = onlyError.getCause(); if (cause != null && canRethrow(method, cause)) { throw cause; } } throw e; } finally { for (ThreadLocalProvider tlp : data.providers) { tlp.remove(); } } }\n\n    ### Response:", "ground_truth": "When a factory method is invoked, we create a child injector that binds all parameters, then\nuse that to get an instance of the return type.", "predict": " Invokes the method on the target object.\n\n@param proxy  the proxy instance.\n@param method the method to be invoked.\n@param args   an array of objects containing the values of the arguments\npassed in the method invocation on the proxy instance. If a\nparameter type is a primitive type, the type of the array\nelement is a wrapper class.\n@return the resulting value of the method invocation.\n@throws Throwable if the method invocation fails."}, {"ID": 363, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String fetchNextRecord(final BufferedReader br, final char qual, final char delim) throws IOException { String line = null; final StringBuilder lineData = new StringBuilder(); boolean processingMultiLine = false; while ((line = br.readLine()) != null) { lineCount++; final String trimmed = line.trim(); final int trimmedLen = trimmed.length(); if (!processingMultiLine && trimmed.length() == 0) { // empty line skip past it, as long as it // is not part of the multiline continue; } // ******************************************************** // new functionality as of 2.1.0 check to see if we have // any line breaks in the middle of the record, this will only // be checked if we have specified a delimiter // ******************************************************** final char[] chrArry = trimmed.toCharArray(); if (!processingMultiLine && delim > 0 && qual != FPConstants.NO_QUALIFIER) { processingMultiLine = ParserUtils.isMultiLine(chrArry, delim, qual); } // check to see if we have reached the end of the linebreak in // the record final String trimmedLineData = lineData.toString().trim(); if (processingMultiLine && trimmedLineData.length() > 0 && trimmedLen > 0) { // need to do one last check here. it is possible that the \" // could be part of the data // excel will escape these with another quote; here is some // data \"\" This would indicate // there is more to the multiline if (trimmed.charAt(trimmed.length() - 1) == qual && !trimmed.endsWith(\"\" + qual + qual)) { // it is safe to assume we have reached the end of the // line break processingMultiLine = false; lineData.append(LINE_BREAK).append(line); } else { // check to see if this is the last line of the record // looking for a qualifier followed by a delimiter lineData.append(LINE_BREAK).append(line); boolean qualiFound = false; for (final char element : chrArry) { if (qualiFound) { if (element == ' ') { continue; } else if (element == delim) { processingMultiLine = ParserUtils.isMultiLine(chrArry, delim, qual); break; } qualiFound = false; } else if (element == qual) { qualiFound = true; } } // check to see if we are still in multi line mode, if // so grab the next line if (processingMultiLine) { continue; } } } else { // throw the line into lineData var. // need to check to see if we need to insert a line break. // The buffered reader excludes the breaks lineData.append(trimmedLen == 0 ? LINE_BREAK : line); if (processingMultiLine) { continue; // if we are working on a multiline rec, get // the data on the next line } } break; } if (line == null && lineData.length() == 0) { // eof return null; } return lineData.toString(); }\n\n    ### Response: Reads a record from a delimited file.  This will account for records which\ncould span multiple lines.\nNULL will be returned when the end of the file is reached\n\n@param br\nOpen reader being used to read through the file\n@param qual\nQualifier being used for parse\n@param delim\nDelimiter being used for parse\n@return String\nRecord from delimited file\n@throws IOException if any problem with the stream of data (e.g. file reader).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb.append(format(\"%n * %s\", sameTypes.get(i).getKey())); } int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED; if (remaining > 0) { String plural = (remaining == 1) ? \"\" : \"s\"; sb.append(format(\"%n %d more binding%s with other annotations.\", remaining, plural)); } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type.toString(); Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings(); for (Key<?> bindingKey : bindingMap.keySet()) { String have = bindingKey.getTypeLiteral().toString(); if (have.contains(want) || want.contains(have)) { Formatter fmt = new Formatter(); Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource()); String match = String.format(\"%s bound%s\", convert(bindingKey), fmt.toString()); possibleMatches.add(match); // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) { // Early exit if we have found more than we need. break; } } } if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) { sb.append(format(\"%n Did you mean?\")); for (String possibleMatch : possibleMatches) { sb.append(format(\"%n %s\", possibleMatch)); } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotation() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) { // We don't recommend using such simple types without annotations. sb.append(format(\"%nThe key seems very generic, did you forget an annotation?\")); } return addMessage(sb.toString()); }\n\n    ### Response:", "ground_truth": "Within guice's core, allow for better missing binding messages", "predict": " Returns an error message indicating that an implementation for the given key was not found.  This method also provides suggestions for other keys that may be intended.\n\n@param key\nThe key for which an implementation was not found\n@param injector\nThe injector being used to find the implementation\n@return Errors\nAn error message indicating that an implementation for the given key was not found.\n\n    "}, {"ID": 364, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> MapBinder<String, T> optionBinder(Binder binder, Key<T> interfaceKey) { final TypeLiteral<T> interfaceType = interfaceKey.getTypeLiteral(); if (interfaceKey.getAnnotation() != null) { return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType, interfaceKey.getAnnotation()); } else if (interfaceKey.getAnnotationType() != null) { Class<? extends Annotation> annotationType = interfaceKey.getAnnotationType(); return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType, annotationType); } else { return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType); } }\n\n    ### Response: Binds an option for a specific choice.  The choice must already be registered on the injector for this to work.\n\n@param binder the binder for the injector that is being configured\n@param interfaceKey the interface that will have an option added to it.  This must equal the\nKey provided to createChoice\n@param  interface type\n@return A MapBinder that can be used to create the actual option bindings..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); RealMultibinder<T> result = new RealMultibinder<>(binder, key); binder.install(result); return result; }\n\n    ### Response:", "ground_truth": "Implementation of newSetBinder.", "predict": " Creates a new multibinder for a set of real implementations of a given type.\n\n@param binder the binder to install the new multibinder into\n@param key the key for the type of object that will be bound\n@return a new RealMultibinder that can be used to add real implementations to the set."}, {"ID": 365, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public synchronized void initialize(Manager manager) { if (this.manager != null) { throw new IllegalStateException(\"Callback was already initialized\"); } this.manager = manager; for (Callback callback : callbacks) { try { callback.initialize(manager); } catch (Exception e) { onManagerWarning(\"Callback initialization error\", e); } } }\n\n    ### Response: Calls initialize on all children..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Key<T> getKeyForNewItem() { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Key.get( bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\")); }\n\n    ### Response:", "ground_truth": "Adds a new entry to the set and returns the key for it.", "predict": " Returns a new key for a new item in the multibinder."}, {"ID": 366, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Filter getFilter(String layerFilter, String[] featureIds) throws GeomajasException { Filter filter = null; if (null != layerFilter) { filter = filterService.parseFilter(layerFilter); } if (null != featureIds) { Filter fidFilter = filterService.createFidFilter(featureIds); if (null == filter) { filter = fidFilter; } else { filter = filterService.createAndFilter(filter, fidFilter); } } return filter; }\n\n    ### Response: Build filter for the request.\n\n@param layerFilter layer filter\n@param featureIds features to include in report (null for all)\n@return filter\n@throws GeomajasException filter could not be parsed/created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Filter findNextFilter(HttpServletRequest request) { while (++index < filterDefinitions.length) { Filter filter = filterDefinitions[index].getFilterIfMatching(request); if (filter != null) { return filter; } } return null; }\n\n    ### Response:", "ground_truth": "Iterates over the remaining filter definitions. Returns the first applicable filter, or null if\nnone apply.", "predict": " Find the next filter that matches the request.\n\n@param request http request\n@return filter or null if no match found.\n\n    "}, {"ID": 367, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasModification(MonomerNotationUnitRNA monomerNotation) { if (monomerNotation.getUnit().contains(\"[\") || monomerNotation.getUnit().contains(\"(X)\") || monomerNotation.getUnit().endsWith(\")\")) { return true; } return false; }\n\n    ### Response: method to check if the MonomerNotationUnitRNA contains modification\n\n@param monomerNotation\nMonomerNotationUnitRNA\n@return true, if the MonomerNotationUnitRNA contains modification, false\notherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasAtInject(Constructor cxtor) { return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class); }\n\n    ### Response:", "ground_truth": "Returns true if the inject annotation is on the constructor.", "predict": " method to check if the Constructor has @Inject annotation\n\n@param cxtor\nConstructor\n@return true, if the Constructor has @Inject annotation, false otherwise."}, {"ID": 368, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Long getId() { if (this.genericRecordAttributes.getId() != null) { return this.genericRecordAttributes.getId(); } else if (this.typeARecordAttributes.getId() != null) { return this.typeARecordAttributes.getId(); } else if (this.typeAAAARecordAttributes.getId() != null) { return this.typeAAAARecordAttributes.getId(); } else if (this.typeNSRecordAttributes.getId() != null) { return this.typeNSRecordAttributes.getId(); } else if (this.typeSOARecordAttributes.getId() != null) { return this.typeSOARecordAttributes.getId(); } else if (this.typeMXRecordAttributes.getId() != null) { return this.typeMXRecordAttributes.getId(); } else if (this.typePTRRecordAttributes.getId() != null) { return this.typePTRRecordAttributes.getId(); } else if (this.typeTXTRecordAttributes.getId() != null) { return this.typeTXTRecordAttributes.getId(); } else { return null; } }\n\n    ### Response: FIXME Better way of accessing the variables?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    InjectionPoint getInternalConstructor() { if (factory.constructorInjector != null) { return factory.constructorInjector.getConstructionProxy().getInjectionPoint(); } else { return constructorInjectionPoint; } }\n\n    ### Response:", "ground_truth": "Returns an injection point that can be used to clean up the constructor store.", "predict": " FIXME Better way of accessing the variables?."}, {"ID": 369, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @VisibleForTesting static Context parse(String text) { Queue<String> parts = Lists.newLinkedList(Arrays.asList(text.split(\" \"))); Context.Builder builder = HTML_PCDATA.toBuilder(); builder.withState(HtmlContext.valueOf(parts.remove())); if (!parts.isEmpty()) { try { builder.withElType(ElementType.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { try { builder.withAttrType(AttributeType.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { try { builder.withDelimType(AttributeEndDelimiter.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { try { builder.withSlashType(JsFollowingSlash.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { try { builder.withUriPart(UriPart.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { try { builder.withUriType(UriType.valueOf(parts.element())); parts.remove(); } catch (IllegalArgumentException ex) { // OK } } if (!parts.isEmpty()) { String part = parts.element(); String prefix = \"templateNestDepth=\"; if (part.startsWith(prefix)) { try { builder.withTemplateNestDepth(Integer.parseInt(part.substring(prefix.length()))); parts.remove(); } catch (NumberFormatException ex) { // OK } } } if (!parts.isEmpty()) { String part = parts.element(); String prefix = \"jsTemplateLiteralNestDepth=\"; if (part.startsWith(prefix)) { try { builder.withJsTemplateLiteralNestDepth(Integer.parseInt(part.substring(prefix.length()))); parts.remove(); } catch (NumberFormatException ex) { // OK } } } if (!parts.isEmpty()) { throw new IllegalArgumentException( \"Unable to parse context \\\"\" + text + \"\\\". Unparsed portion: \" + parts); } Context result = builder.build(); return result; }\n\n    ### Response: Parses a condensed string version of a context, for use in tests..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Set<Dependency<?>> getInternalDependencies() { ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder(); if (factory.constructorInjector == null) { builder.add(constructorInjectionPoint); // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder.addAll( InjectionPoint.forInstanceMethodsAndFields( constructorInjectionPoint.getDeclaringType())); } catch (ConfigurationException ignored) { } } else { builder.add(getConstructor()).addAll(getInjectableMembers()); } return Dependency.forInjectionPoints(builder.build()); }\n\n    ### Response:", "ground_truth": "Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.", "predict": " Returns the internal dependencies of this component. Internal dependencies are dependencies that are not exposed to the outside world, but are used by the component itself. This method returns a set of dependencies, where each dependency is represented by an injection point. The set includes the constructor injection point, if there is one, and all injectable members of the component. If the component has no constructor, or if the constructor throws a ConfigurationException, then the set will only include the constructor injection point."}, {"ID": 370, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int zip(OutputStream out, DirScanner scanner) throws IOException, InterruptedException { return archive(ArchiverFactory.ZIP, out, scanner); }\n\n    ### Response: Uses the given scanner on 'this' directory to list up files and then archive it to a zip stream..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) { return forObject(module, false, scanner); }\n\n    ### Response:", "ground_truth": "Returns a module which creates bindings methods in the module that match the scanner.", "predict": " Returns a module object for the given module object or class. The scanner is used to scan for annotated methods and to create module dependencies."}, {"ID": 371, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T getAnnotation(final Class<?> componentClass, final Class<T> annotationClass) { T annotation = componentClass.getAnnotation(annotationClass); if (annotation != null) { return annotation; } for (final Class<?> ifc : componentClass.getInterfaces()) { annotation = getAnnotation(ifc, annotationClass); if (annotation != null) { return annotation; } } if (!Annotation.class.isAssignableFrom(componentClass)) { for (final Annotation ann : componentClass.getAnnotations()) { annotation = getAnnotation(ann.annotationType(), annotationClass); if (annotation != null) { return annotation; } } } final Class<?> superClass = componentClass.getSuperclass(); if (superClass == null || superClass.equals(Object.class)) { return null; } return getAnnotation(superClass, annotationClass); }\n\n    ### Response: Search for the given annotationClass in the given componentClass and return it if search was\nsuccessful.\n\n@param \nthe generic type\n@param componentClass\nthe component class\n@param annotationClass\nthe annotation class\n@return the annotation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; }\n\n    ### Response:", "ground_truth": "Returns the annotation that is claimed by the scanner, or null if there is none.", "predict": " This method searches for the annotation on the given method and returns it if found. If the method is a bridge or synthetic method, it returns null. If there are multiple annotations claimed by the scanner on the method, it adds an error to the binder and returns null.\n\n@param binder\nthe binder\n@param method\nthe method\n@return the annotation or null if not found."}, {"ID": 372, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private function tpl(): string { if (interface_exists($this->type)) { return 'Return value of %s must implement interface %s, %s returned'; } if (class_exists($this->type)) { return 'Return value of %s must be an instance of %s, %s returned'; } if ($this->type == 'callable') { return 'Return value of %s must be %s, %s returned'; } return 'Return value of %s must be of the type %s, %s returned'; }\n\n    ### Response: Return the template of the error message accoring to the expected type.\n\n@return string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Integer getLineNumber(Member member) { Preconditions.checkArgument( type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type); return lines.get(memberKey(member)); }\n\n    ### Response:", "ground_truth": "Get the line number associated with the given member.\n\n@param member a field, constructor, or method belonging to the class used during construction\n@return the wrapped line number, or null if not available\n@throws IllegalArgumentException if the member does not belong to the class used during\nconstruction", "predict": " Get the line number of a member in the source code.\n\n@param member The member to get the line number for.\n@return The line number of the member in the source code."}, {"ID": 373, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setErrors(java.util.Collection<String> errors) { if (errors == null) { this.errors = null; return; } this.errors = new java.util.ArrayList<String>(errors); }\n\n    ### Response: A list of errors that might have been generated from processes on this flow.\n\n@param errors\nA list of errors that might have been generated from processes on this flow..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void initialize(Errors errors) { injector.lookups = injector; new LookupProcessor(errors).process(injector, lookups); }\n\n    ### Response:", "ground_truth": "Initialize the specified lookups, either immediately or when the injector is created.", "predict": " Initializes the injector with the given errors and sets up the lookup processor to process the injector's lookups.\n\n@param errors\nThe errors to use for error reporting."}, {"ID": 374, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Collection<MemberResponse<T>> executeOptimistic(IExecutorService execSvc, Set<Member> members, Callable<T> callable) { return executeOptimistic(execSvc, members, callable, 60, TimeUnit.SECONDS); }\n\n    ### Response: Will wait a maximum of 1 minute for each node to response with their result.  If an error occurs on any\nmember, we will always attempt to continue execution and collect as many results as possible.\n\n@param execSvc\n@param members\n@param callable\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); }\n\n    ### Response:", "ground_truth": "Wraps the given callable in a contextual callable that \"continues\" the HTTP request in another\nthread. This acts as a way of transporting request context data from the request processing\nthread to to worker threads.\n\nThere are some limitations:\n\n\nDerived objects (i.e. anything marked @RequestScoped will not be transported.\nState changes to the HttpServletRequest after this method is called will not be seen in the\ncontinued thread.\nOnly the HttpServletRequest, ServletContext and request parameter map are available in the\ncontinued thread. The response and session are not available.\n\nThe returned callable will throw a {@link ScopingException} when called if the HTTP request\nscope is still active on the current thread.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@param seedMap the initial set of scoped instances for Guice to seed the request scope with. To\nseed a key with null, use {@code null} as the value.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 3.0\n@deprecated You probably want to use {@code transferRequest} instead", "predict": " This method is deprecated and will be removed in a future release.  Please use the continueRequest method in the Continuation class instead.\n\n@param callable\n@param seedMap\n@return."}, {"ID": 375, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> decorateWithBarrier(CyclicBarrier barrier, Callable<T> callable) { return new BarrierCallableDecorator<T>(barrier, callable); }\n\n    ### Response: Create a callable that waits on a barrier before starting execution\n@param barrier\n@param callable\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); }\n\n    ### Response:", "ground_truth": "Wraps the given callable in a contextual callable that \"transfers\" the request to another\nthread. This acts as a way of transporting request context data from the current thread to a\nfuture thread.\n\nAs opposed to {@link #continueRequest}, this method propagates all existing scoped objects.\nThe primary use case is in server implementations where you can detach the request processing\nthread while waiting for data, and reattach to a different thread to finish processing at a\nlater time.\n\nBecause request-scoped objects are not typically thread-safe, the callable returned by this\nmethod must not be run on a different thread until the current request scope has terminated.\nThe returned callable will block until the current thread has released the request scope.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 4.0", "predict": " Wraps the given callable with a transfer request wrapper.\n@param callable\n@return.\n\n    "}, {"ID": 376, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean getBoolean(String key) throws JSONException { Object object = this.get(key); if (object.equals(Boolean.FALSE) || (object instanceof String && ((String) object) .equalsIgnoreCase(\"false\"))) { return false; } else if (object.equals(Boolean.TRUE) || (object instanceof String && ((String) object) .equalsIgnoreCase(\"true\"))) { return true; } throw new JSONException(\"JSONObject[\" + quote(key) + \"] is not a Boolean.\"); }\n\n    ### Response: Get the boolean value associated with a key.\n\n@param key\nA key string.\n@return The truth.\n@throws JSONException\nif the value is not a Boolean or the String \"true\" or\n\"false\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; }\n\n    ### Response:", "ground_truth": "Validates the key and object, ensuring the value matches the key type, and canonicalizing null\nobjects to the null sentinel.", "predict": " Validate and canonicalize a value for a given key.\n\n@param key\nThe key to validate and canonicalize the value for.\n@param object\nThe value to validate and canonicalize.\n@return The canonicalized value.\n@throws IllegalArgumentException\nif the value is not compatible with the key."}, {"ID": 377, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function checkFeatureChildNode(node, restrictedPatterns, errors) { checkNameAndDescription(node, restrictedPatterns, errors); node.steps.forEach(function(step) { // Use the node type of the parent to determine which rule configuration to use checkStepNode(step, restrictedPatterns[node.type], errors); }); }\n\n    ### Response: Background, Scenarios and Scenario Outlines are children of a feature.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") // the MembersInjector type always agrees with the passed type public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException { return (MembersInjectorImpl<T>) cache.get(key, errors); }\n\n    ### Response:", "ground_truth": "Returns a new complete members injector with injection listeners registered.", "predict": " This method retrieves a MembersInjector instance for the given TypeLiteral. It first checks the cache for a previously created instance, and if none is found, creates a new one using the Injector's MembersInjectorFactory."}, {"ID": 378, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Iterable<Binding<?>> getBindings(Injector injector, Set<Key<?>> root) { Set<Key<?>> keys = Sets.newHashSet(root); Set<Key<?>> visitedKeys = Sets.newHashSet(); List<Binding<?>> bindings = Lists.newArrayList(); TransitiveDependencyVisitor keyVisitor = new TransitiveDependencyVisitor(); while (!keys.isEmpty()) { Iterator<Key<?>> iterator = keys.iterator(); Key<?> key = iterator.next(); iterator.remove(); if (!visitedKeys.contains(key)) { try { Binding<?> binding = injector.getBinding(key); bindings.add(binding); visitedKeys.add(key); keys.addAll(binding.acceptTargetVisitor(keyVisitor)); } catch (ConfigurationException e) { System.out.println(\"Missing binding for : \" + key); visitedKeys.add(key); } } } return bindings; }\n\n    ### Response: Returns the bindings for the root keys and their transitive dependencies..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Set<InjectionPoint> injectionPoints; try { injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type); } catch (ConfigurationException e) { errors.merge(e.getErrorMessages()); injectionPoints = e.getPartialValue(); } ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors); errors.throwIfNewErrors(numErrorsBefore); EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups); Set<TypeListener> alreadySeenListeners = Sets.newHashSet(); for (TypeListenerBinding binding : typeListenerBindings) { TypeListener typeListener = binding.getListener(); if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) { alreadySeenListeners.add(typeListener); try { typeListener.hear(type, encounter); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } encounter.invalidate(); errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(injector, type, encounter, injectors); }\n\n    ### Response:", "ground_truth": "Creates a new members injector and attaches both injection listeners and method aspects.", "predict": " Creates a new MembersInjector for the given type, using the given errors object to report errors. The MembersInjector will use the Injector to fulfill the injection requests for the given type. Any errors encountered during the creation of the MembersInjector will be reported to the errors object."}, {"ID": 379, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Set<Dependency<?>> forInjectionPoints(Set<InjectionPoint> injectionPoints) { List<Dependency<?>> dependencies = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { dependencies.addAll(injectionPoint.getDependencies()); } return ImmutableSet.copyOf(dependencies); }\n\n    ### Response: Returns the dependencies from the given injection points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); }\n\n    ### Response:", "ground_truth": "Returns the injectors for the specified injection points.", "predict": " Returns the injectors for the given injection points."}, {"ID": 380, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> Key<T> manualRefToKey(final Class<T> type, final Object id) { return id == null ? null : new Key<T>(type, getCollectionName(type), id); }\n\n    ### Response: Creates a Key for a type and an ID value\n\n@param type the Class of the entity\n@param id   the ID value\n@param   the type of the entity\n@return the Key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); }\n\n    ### Response:", "ground_truth": "Gets a key for an injection type and an annotation strategy.", "predict": " Creates a Key for a type and an annotation strategy\n\n@param type the Class of the entity\n@param annotationStrategy the annotation strategy to use\n@return the Key."}, {"ID": 381, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized Set<Class<?>> getTypesAnnotatedWith(final Class<? extends Annotation> annotation) { Assert.requireNonNull(annotation, \"annotation\"); return reflections.getTypesAnnotatedWith(annotation); }\n\n    ### Response: Returns a set that contains all classes in the classpath that are annotated with the given annotation\n@param annotation the annotation\n@return the set of annotated classes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static AnnotationStrategy strategyFor(Annotation annotation) { checkNotNull(annotation, \"annotation\"); Class<? extends Annotation> annotationType = annotation.annotationType(); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); if (Annotations.isMarker(annotationType)) { return new AnnotationTypeStrategy(annotationType, annotation); } return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation)); }\n\n    ### Response:", "ground_truth": "Gets the strategy for an annotation.", "predict": " Returns the strategy for the given annotation.\n@param annotation the annotation\n@return the strategy for the annotation.\n\n    "}, {"ID": 382, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Method> getAllMethodsShallow(Class<?> c, Class<? extends Annotation> annotationType) { List<Method> annotated = new ArrayList<>(); for (Method m : c.getDeclaredMethods()) { if (m.isAnnotationPresent(annotationType)) annotated.add(m); } return annotated; }\n\n    ### Response: Returns a set of Methods that contain the given method annotation.  This includes all public, protected, package\nand private methods, but not those of superclasses and interfaces.\n\n@param c              class to inspect\n@param annotationType the type of annotation to look for\n@return List of Method objects that require injection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, null); }\n\n    ### Response:", "ground_truth": "Gets the strategy for an annotation type.", "predict": " Returns the strategy for the given annotation type.\n\n@param annotationType the annotation type to look up\n@return the strategy for the annotation type\n@throws NullPointerException if the annotation type is null\n@throws IllegalArgumentException if the annotation type is not retained at runtime or is not a binding annotation"}, {"ID": 383, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getStackTrace(final Throwable exception) { if (exception != null) { StringBuilder sb = new StringBuilder(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement element : stackTrace) { sb.append(element.toString()); sb.append('\\n'); } if (exception.getCause() != null) { StackTraceElement[] stackTraceCause = exception.getCause().getStackTrace(); for (StackTraceElement element : stackTraceCause) { sb.append(element.toString()); sb.append('\\n'); } } return sb.toString(); } return null; }\n\n    ### Response: Gets stacktrace as a String.\n\n@param exception Exception for which the stacktrace should be returned.\n@return Stacktrace as a String..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pruneStacktrace(Throwable throwable) { for (Throwable t = throwable; t != null; t = t.getCause()) { StackTraceElement[] stackTrace = t.getStackTrace(); List<StackTraceElement> pruned = Lists.newArrayList(); for (StackTraceElement element : stackTrace) { String className = element.getClassName(); if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) { pruned.add(element); } } t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()])); } }\n\n    ### Response:", "ground_truth": "Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace\nand any causes it may have.", "predict": " Removes AOP-related classes and anonymous classes from the stacktrace.\n\n@param throwable Throwable for which the stacktrace should be pruned."}, {"ID": 384, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object toNeo4JProperty(Object source) { if (source instanceof BigDecimal || source instanceof BigInteger) { return source.toString(); } else if ((source instanceof Calendar) || (source instanceof GregorianCalendar)) { return PropertyAccessorHelper.fromSourceToTargetClass(String.class, Date.class, ((Calendar) source).getTime()); } if (source instanceof Date) { Class<?> sourceClass = source.getClass(); return PropertyAccessorHelper.fromSourceToTargetClass(String.class, sourceClass, source); } return source; }\n\n    ### Response: Converts a given field value to an object that is Neo4J compatible\n\n@param source\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getBindingSource() { if (source instanceof Class) { return StackTraceElements.forType((Class) source).toString(); } else if (source instanceof Member) { return StackTraceElements.forMember((Member) source).toString(); } else { return source.toString(); } }\n\n    ### Response:", "ground_truth": "Returns a string describing where this dependency was bound. If the binding was just-in-time,\nthere is no valid binding source, so this describes the class in question.", "predict": " Returns the source of the binding.\n\n@return the source of the binding."}, {"ID": 385, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String format(String heading, Collection<ErrorMessage> errorMessages) { @SuppressWarnings(\"resource\") Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; for (ErrorMessage errorMessage : errorMessages) { fmt.format(\"%s) %s%n\", index++, errorMessage.getMessage()); Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { StringWriter writer = new StringWriter(); cause.printStackTrace(new PrintWriter(writer)); fmt.format(\"Caused by: %s\", writer.getBuffer()); } fmt.format(\"%n\"); } if (errorMessages.size() == 1) fmt.format(\"1 error\"); else fmt.format(\"%s errors\", errorMessages.size()); return fmt.toString(); }\n\n    ### Response: Returns the formatted message for an exception with the specified messages..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause); if (!causes.containsKey(causeEquivalence)) { causes.put(causeEquivalence, thisIdx); fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause)); } else { int causeIdx = causes.get(causeEquivalence); fmt.format( \"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx); } } fmt.format(\"%n\"); } if (errorMessages.size() == 1) { fmt.format(\"1 error\"); } else { fmt.format(\"%s errors\", errorMessages.size()); } return fmt.toString(); }\n\n    ### Response:", "ground_truth": "Returns the formatted message for an exception with the specified messages.", "predict": " Returns the formatted message for a collection of messages with the specified heading."}, {"ID": 386, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void fail(boolean expression, String messageFormat, Object... args) { assertTrue(!expression, messageFormat, args); }\n\n    ### Response: Fails if expression is true.\n\n@param expression\nthe expression\n@param messageFormat\nthe message format\n@param args\nthe args.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); }\n\n    ### Response:", "ground_truth": "Creates a new Message without a cause.\n\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a message with the specified message format and arguments.\n\n@param messageFormat\nthe message format\n@param arguments\nthe arguments."}, {"ID": 387, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void fail(boolean expression, String messageFormat, Object... args) { assertTrue(!expression, messageFormat, args); }\n\n    ### Response: Fails if expression is true.\n\n@param expression\nthe expression\n@param messageFormat\nthe message format\n@param args\nthe args.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create(Throwable cause, String messageFormat, Object... arguments) { return create(cause, ImmutableList.of(), messageFormat, arguments); }\n\n    ### Response:", "ground_truth": "Creates a new Message with the given cause.\n\n@param cause The exception that caused the error\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a message with the given cause, message format, and arguments.\n\n@param cause\nthe cause\n@param messageFormat\nthe message format\n@param arguments\nthe arguments."}, {"ID": 388, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void infoDebugf(final Throwable cause, final String message, final Object... args) { logDebugf(Level.INFO, cause, message, args); }\n\n    ### Response: Logs a formatted message and stack trace if DEBUG logging is enabled\nor a formatted message and exception description if INFO logging is enabled.\n\n@param cause   an exception to print stack trace of if DEBUG logging is enabled\n@param message a format string\n@param args    arguments referenced by the format specifiers in the format string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Message(sources, message, cause); }\n\n    ### Response:", "ground_truth": "Creates a new Message with the given cause and a binding source stack.\n\n@param cause The exception that caused the error\n@param sources The binding sources for the source stack\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a new message with the specified sources, message format, and arguments.\n\n@param cause         the exception that caused this message to be created\n@param sources       the sources of this message\n@param messageFormat the format string for the message\n@param arguments     the arguments referenced by the format specifiers in the message format string."}, {"ID": 389, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T toUnpooled(T o) { if (o instanceof ByteBufHolder) { o = copyAndRelease((ByteBufHolder) o); } else if (o instanceof ByteBuf) { o = copyAndRelease((ByteBuf) o); } return o; }\n\n    ### Response: Converts the given object to an unpooled copy and releases the given object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Object convert(Object o) { ElementSource source = null; if (o instanceof ElementSource) { source = (ElementSource) o; o = source.getDeclaringSource(); } return convert(o, source); }\n\n    ### Response:", "ground_truth": "Formats an object in a user friendly way.", "predict": " Converts the given object to a suitable representation for the given source. If the object is an instance of ElementSource, it is assumed to be a source object and its declaring source is extracted. The resulting object is then converted using the source's converter."}, {"ID": 390, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isLoneBlock(Node n) { Node parent = n.getParent(); if (parent != null && (parent.isScript() || (parent.isBlock() && !parent.isSyntheticBlock() && !parent.isAddedBlock()))) { return !n.isSyntheticBlock() && !n.isAddedBlock(); } return false; }\n\n    ### Response: A lone block is a non-synthetic, not-added BLOCK that is a direct child of\nanother non-synthetic, not-added BLOCK or a SCRIPT node..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean shouldBeSkipped(String className) { return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className); }\n\n    ### Response:", "ground_truth": "Returns true if the className should be skipped.", "predict": " This method checks if a class should be skipped or not. It returns true if the class is a direct child of another class that should be skipped or if the class is in the list of classes to skip."}, {"ID": 391, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Deferred<List<String>> resolveAggTags(final Set<byte[]> tagks) { if (aggregated_tags != null) { return Deferred.fromResult(null); } aggregated_tags = new ArrayList<String>(tagks.size()); final List<Deferred<String>> names = new ArrayList<Deferred<String>>(tagks.size()); for (final byte[] tagk : tagks) { names.add(tsdb.tag_names.getNameAsync(tagk)); } /** Adds the names to the aggregated_tags list */ final class ResolveCB implements Callback<List<String>, ArrayList<String>> { @Override public List<String> call(final ArrayList<String> names) throws Exception { for (final String name : names) { aggregated_tags.add(name); } return aggregated_tags; } } return Deferred.group(names).addCallback(new ResolveCB()); }\n\n    ### Response: Resolves the set of tag keys to their string names.\n@param tagks The set of unique tag names\n@return a deferred to wait on for all of the tag keys to be resolved. The\nresult should be null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; }\n\n    ### Response:", "ground_truth": "Returns the non-skipped module class name.", "predict": " Retrieves the source information for the given list of module class names.\n@param moduleClassNames The list of module class names to retrieve the source information for.\n@return The source information for the first module class name that is not skipped. If none of the module class names are not skipped, then UNKNOWN_SOURCE is returned.\n\n    "}, {"ID": 392, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(String[] args) throws IOException { if (args.length != 1) { System.out.println(\"Usage: java java \" + \"-Djava.protocol.handler.pkgs=org.archive.net \" + \"org.archive.net.rsync.Handler RSYNC_URL\"); System.exit(1); } URL u = new URL(args[0]); URLConnection connect = u.openConnection(); // Write download to stdout. final int bufferlength = 4096; byte [] buffer = new byte [bufferlength]; InputStream is = connect.getInputStream(); try { for (int count = is.read(buffer, 0, bufferlength); (count = is.read(buffer, 0, bufferlength)) != -1;) { System.out.write(buffer, 0, count); } System.out.flush(); } finally { is.close(); } }\n\n    ### Response: Main dumps rsync file to STDOUT.\n@param args\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\"); System.err.println(\"Then run 'jconsole' to connect.\"); System.exit(1); } Module module = (Module) Class.forName(args[0]).newInstance(); Injector injector = Guice.createInjector(module); manage(args[0], injector); System.out.println(\"Press Ctrl+C to exit...\"); // Sleep forever. Thread.sleep(Long.MAX_VALUE); }\n\n    ### Response:", "ground_truth": "Run with no arguments for usage instructions.", "predict": " Main method for starting the application.\n@param args\n@throws Exception.\n\n    "}, {"ID": 393, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors) { List<BindingImpl<?>> candidateBindings = new ArrayList<>(); @SuppressWarnings(\"unchecked\") // casting Collection<Binding> to Collection<BindingImpl> is safe Collection<BindingImpl<?>> bindingsAtThisLevel = (Collection) injector.state.getExplicitBindingsThisLevel().values(); candidateBindings.addAll(bindingsAtThisLevel); synchronized (injector.state.lock()) { // jit bindings must be accessed while holding the lock. candidateBindings.addAll(injector.jitBindings.values()); } InternalContext context = injector.enterContext(); try { for (BindingImpl<?> binding : candidateBindings) { if (isEagerSingleton(injector, binding, stage)) { Dependency<?> dependency = Dependency.get(binding.getKey()); Dependency previous = context.pushDependency(dependency, binding.getSource()); try { binding.getInternalFactory().get(context, dependency, false); } catch (InternalProvisionException e) { errors.withSource(dependency).merge(e); } finally { context.popStateAndSetDependency(previous); } } } } finally { context.close(); } }\n\n    ### Response: Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered\nwhile we're binding these singletons are not be eager..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Dependency<?> pushDependency(Dependency<?> dependency, Object source) { Dependency<?> previous = this.dependency; this.dependency = dependency; doPushState(dependency, source); return previous; }\n\n    ### Response:", "ground_truth": "Sets the new current dependency & adds it to the state.", "predict": " Pushes a dependency onto the stack of dependencies, returning the previous one. This method is used to implement the scoping of dependencies. The source parameter is used to provide more information about where the dependency was pushed, for debugging purposes."}, {"ID": 394, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @VisibleForTesting public void setSource(PropertyKey key, Source source) { mSources.put(key, source); }\n\n    ### Response: Sets the source for a given key.\n\n@param key property key\n@param source the source.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); }\n\n    ### Response:", "ground_truth": "Adds to the state without setting the dependency.", "predict": " Pushes a new state onto the stack.\n\n@param key the key for the state\n@param source the source for the state."}, {"ID": 395, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Provider<T> ofInstance(final T instance) { return new Provider<T>() { @Override public T get() { return instance; } }; }\n\n    ### Response: Creates a provider which always returns the same getInstance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> Initializable<T> of(final T instance) { return new Initializable<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; }\n\n    ### Response:", "ground_truth": "Returns an initializable for an instance that requires no initialization.", "predict": " Creates an Initializable which always returns the same instance and has a toString method that returns the instance as a string."}, {"ID": 396, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T getAnnotation(Method method, Class<T> annotationClass) { T t = method.getAnnotation(annotationClass); if (t == null) { t = getAnnotation(method.getDeclaringClass(), annotationClass); } return t; }\n\n    ### Response: Extract the annotation from the method or the declaring class.\n\n@param method\n@param annotationClass\n@param \n@return the annotation or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T provision( Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { T t = provider.get(); if (t == null && !dependency.isNullable()) { InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency); } constructionContext.setProxyDelegates(t); return t; }\n\n    ### Response:", "ground_truth": "Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as\nErrorsExceptions.", "predict": " Provision the dependency using the provider.\n\n@param provider\n@param dependency\n@param constructionContext\n@return the provisioned dependency.\n\n    "}, {"ID": 397, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void update(IEntityGroup group) throws GroupsException { Connection conn = null; boolean exists = existsInDatabase(group); try { conn = RDBMServices.getConnection(); setAutoCommit(conn, false); try { if (exists) { primUpdate(group, conn); } else { primAdd(group, conn); } primUpdateMembers((EntityGroupImpl) group, conn); commit(conn); } catch (Exception ex) { rollback(conn); throw new GroupsException(\"Problem updating \" + this + ex); } } catch (SQLException sqlex) { throw new GroupsException(sqlex); } finally { if (conn != null) { try { setAutoCommit(conn, true); } catch (SQLException sqle) { throw new GroupsException(sqle); } finally { RDBMServices.releaseConnection(conn); } } } }\n\n    ### Response: Commit this entity AND ITS MEMBERSHIPS to the underlying store.\n\n@param group IEntityGroup.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } }\n\n    ### Response:", "ground_truth": "Dispatch events.\n\n@param type\n@param remoteAddr\n@param conn", "predict": "Process the given connection event.\n\n@param type ConnectionEventType.\n@param remoteAddr String.\n@param conn Connection."}, {"ID": 398, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Architecture getArchitecture() { if (Architecture.UNKNOWN == myArchitecture) { final Processor processor = getProcessor(); if (Processor.UNKNOWN != processor) { final String name = System.getProperty(OS_NAME).toLowerCase(Locale.US); if (name.indexOf(\"nix\") >= 0 || name.indexOf(\"nux\") >= 0) { if (Processor.INTEL_32 == processor) { myArchitecture = Architecture.LINUX_32; } else if (Processor.INTEL_64 == processor) { myArchitecture = Architecture.LINUX_64; } else if (Processor.ARM == processor) { myArchitecture = Architecture.LINUX_ARM; } } else if (name.indexOf(\"win\") >= 0) { if (Processor.INTEL_32 == processor) { myArchitecture = Architecture.WINDOWS_32; } else if (Processor.INTEL_64 == processor) { myArchitecture = Architecture.WINDOWS_64; } } else if (name.indexOf(\"mac\") >= 0) { if (Processor.INTEL_32 == processor) { myArchitecture = Architecture.OSX_32; } else if (Processor.INTEL_64 == processor) { myArchitecture = Architecture.OSX_64; } else if (Processor.PPC == processor) { myArchitecture = Architecture.OSX_PPC; } } } } LOGGER.debug(MessageCodes.UTIL_023, myArchitecture, System.getProperty(OS_NAME).toLowerCase(Locale.US)); return myArchitecture; }\n\n    ### Response: Gets the architecture of the machine running the JVM.\n\n@return The architecture of the machine running the JVM.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList == null) { this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1)); processorList = this.processors.get(type); } processorList.add(processor); }\n\n    ### Response:", "ground_truth": "Add event processor.\n\n@param type\n@param processor", "predict": " Adds a connection event processor for the specified connection event type.\n\n@param type The connection event type for which the processor is being added.\n@param processor The connection event processor to be added."}, {"ID": 399, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized <T> T fromJson(String jsonString, Class<T> clazz) throws JsonException { if (jsonString == null) { return null; } Reader reader = new StringReader(jsonString); try { return mapper.readValue(reader, clazz); } catch (JsonParseException e) { throw new JsonException(e.getMessage(), e); } catch (JsonMappingException e) { throw new JsonException(e.getMessage(), e); } catch (IOException e) { throw new JsonException(e.getMessage(), e); } }\n\n    ### Response: Converts a given string into an object of the given class.\n\n@param clazz      The class to which the returned object should belong\n@param jsonString the jsonstring representing the object to be parsed\n@param         the type of the returned object\n@return an instantiated object of class T corresponding to the given jsonstring\n@throws JsonException If deserialization failed or if the object of class T could for some reason not be\nconstructed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) { T t = null; if (null != task) { try { t = task.getAfterRun(); } catch (InterruptedException e) { logger.error(\"Future task interrupted!\", e); } catch (ExecutionException e) { logger.error(\"Future task execute failed!\", e); } catch (FutureTaskNotRunYetException e) { logger.error(\"Future task has not run yet!\", e); } catch (FutureTaskNotCompleted e) { logger.error(\"Future task has not completed!\", e); } } return t; }\n\n    ### Response:", "ground_truth": "get the result of a future task\n\nNotice: the run method of this task should have been called at first.\n\n@param task\n@param \n@return", "predict": " Retrieves the result of a FutureTask that has been executed.\n\n@param task   The FutureTask to retrieve the result from\n@param logger The logger to use for logging any errors that occur during execution\n@return The result of the FutureTask, or null if the FutureTask has not yet been executed or has not completed successfully\n@throws FutureTaskNotRunYetException If the FutureTask has not yet been executed\n@throws FutureTaskNotCompleted If the FutureTask has not completed successfully\n@throws InterruptedException If the calling thread was interrupted while waiting for the FutureTask to complete\n@throws ExecutionException If the FutureTask threw an exception during execution"}, {"ID": 400, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static RuntimeException cancelThrow(ClientCall<?, ?> call, Throwable t) { try { call.cancel(null, t); } catch (Throwable e) { assert e instanceof RuntimeException || e instanceof Error; logger.log(Level.SEVERE, \"RuntimeException encountered while closing call\", e); } if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } // should be impossible throw new AssertionError(t); }\n\n    ### Response: Cancels a call, and throws the exception.\n\n@param t must be a RuntimeException or Error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void launderThrowable(Throwable t) { if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new IllegalStateException(\"Not unchecked!\", t); } }\n\n    ### Response:", "ground_truth": "launder the throwable\n\n@param t", "predict": " Throws the given Throwable, if it is a RuntimeException or Error, or wraps it in an IllegalStateException with a message indicating that it is not unchecked."}, {"ID": 401, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerSpecialVariableProcessor(@Nonnull final SpecialVariableProcessor processor) { assertNotNull(\"Processor is null\", processor); for (final String varName : processor.getVariableNames()) { assertNotNull(\"A Special Var name is null\", varName); if (mapVariableNameToSpecialVarProcessor.containsKey(varName)) { throw new IllegalStateException(\"There is already defined processor for \" + varName); } mapVariableNameToSpecialVarProcessor.put(varName, processor); } }\n\n    ### Response: It allows to register a special variable processor which can process some special global variables\n\n@param processor a variable processor to be registered, it must not be null\n@see SpecialVariableProcessor.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); }\n\n    ### Response:", "ground_truth": "Register processor to process command that has the command code of cmdCode.\n\n@param cmdCode\n@param processor", "predict": " It allows to register a processor for a specific command code.\n\n@param cmdCode the command code for which the processor is registered\n@param processor the processor to be registered, it must not be null\n@see RemotingProcessor."}, {"ID": 402, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setProcessor(final Processor processor) throws BuildException, NullPointerException { if (processor == null) { throw new NullPointerException(\"processor\"); } if (isReference()) { throw super.tooManyAttributes(); } if (this.env == null && !this.newEnvironment) { this.processor = processor; } else { this.processor = processor.changeEnvironment(this.newEnvironment, this.env); } }\n\n    ### Response: Sets the processor\n\n@param processor\nprocessor, may not be null.\n@throws BuildException\nif ProcessorDef is a reference\n@throws NullPointerException\nif processor is null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerDefaultProcessor(RemotingProcessor<?> processor) { if (this.defaultProcessor == null) { this.defaultProcessor = processor; } else { throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass()); } }\n\n    ### Response:", "ground_truth": "Register the default processor to process command with no specific processor registered.\n\n@param processor", "predict": " Registers the default processor\n\n@param processor\nthe default processor, may not be null.\n@throws IllegalStateException\nif the default processor has already been registered."}, {"ID": 403, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected AbstractChainedGlobalProcessor<GlobalPostProcessingContext> buildProcessorByKey(String key) { AbstractChainedGlobalProcessor<GlobalPostProcessingContext> processor = null; if (key.equals(JawrConstant.GLOBAL_GOOGLE_CLOSURE_POSTPROCESSOR_ID)) { processor = new ClosureGlobalPostProcessor(); } return processor; }\n\n    ### Response: Build the global preprocessor from the ID given in parameter\n\n@param key\nthe ID of the preprocessor\n@return a global preprocessor.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RemotingProcessor<?> getProcessor(CommandCode cmdCode) { RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode); if (processor != null) { return processor; } return this.defaultProcessor; }\n\n    ### Response:", "ground_truth": "Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.\n\n@param cmdCode\n@return", "predict": " Get the processor for the given command code.\n\n@param cmdCode\nthe command code\n@return the processor for the given command code. If no processor is found for the given command code, return the default processor."}, {"ID": 404, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Url setUrl(String url) { Url prop = (url == null) ? null : new Url(url); setUrl(prop); return prop; }\n\n    ### Response: Sets a URL to a resource that contains additional information about the\njournal entry.\n@param url the URL (e.g. \"http://example.com/resource.ics\") or null to\nremove\n@return the property that was created\n@see RFC 5545\np.116-7\n@see RFC 2445\np.110-1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); }\n\n    ### Response:", "ground_truth": "try get from cache\n\n@param url\n@return", "predict": " Retrieves a URL from the cache of parsed URLs.\n@param url the URL to retrieve\n@return the parsed URL or null if it was not found in the cache\n@see RFC 5545\np.116-7\n@see RFC 2445\np.110-1."}, {"ID": 405, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String decodeString(ByteBuf in) throws UnsupportedEncodingException { if (in.readableBytes() < 2) { return null; } //int strLen = Utils.readWord(in); int strLen = in.readUnsignedShort(); if (in.readableBytes() < strLen) { return null; } byte[] strRaw = new byte[strLen]; in.readBytes(strRaw); return new String(strRaw, \"UTF-8\"); }\n\n    ### Response: Load a string from the given buffer, reading first the two bytes of len\nand then the UTF-8 bytes of the string.\n\n@return the decoded string or null if NEED_DATA.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ProtocolCode decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; }\n\n    ### Response:", "ground_truth": "decode the protocol code\n\n@param in input byte buf\n@return an instance of ProtocolCode", "predict": " Decode the protocol code from the given buffer.\n\n@return the decoded protocol code or null if not enough bytes are available."}, {"ID": 406, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    ServerSessionManager unregisterConnection(Connection connection) { Iterator<Map.Entry<String, Connection>> iterator = connections.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, Connection> entry = iterator.next(); if (entry.getValue().equals(connection)) { ServerSessionContext session = clients.get(entry.getKey()); if (session != null) { session.setConnection(null); } iterator.remove(); } } return this; }\n\n    ### Response: Unregisters a connection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Map<String, List<Connection>> getAll() { Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>(); Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this .getConnPools().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); if (null != pool) { allConnections.put(entry.getKey(), pool.getAll()); } } return allConnections; }\n\n    ### Response:", "ground_truth": "Get all connections of all poolKey.\n\n@return a map with poolKey as key and a list of connections in ConnectionPool as value", "predict": " Retrieves all connections for all pools."}, {"ID": 407, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeEntriesStartingWith(String key) { synchronized (eventMap) { Iterator<String> iter = eventMap.keySet().iterator(); while (iter.hasNext()) { String str = iter.next(); if (str.startsWith(key)) { iter.remove(); } } } }\n\n    ### Response: Remove all entries starting with the given key\n\n@param key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void scan() { if (null != this.connTasks && !this.connTasks.isEmpty()) { Iterator<String> iter = this.connTasks.keySet().iterator(); while (iter.hasNext()) { String poolKey = iter.next(); ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey)); if (null != pool) { pool.scan(); if (pool.isEmpty()) { if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) { iter.remove(); logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey); } } } } } }\n\n    ### Response:", "ground_truth": "in case of cache pollution and connection leak, to do schedule scan\n\n@see com.alipay.remoting.Scannable#scan()", "predict": " Scan all connection pools and remove expired pools.\n\n@param poolKey.\n@param pool."}, {"ID": 408, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function getConnection(connectionString) { return new Promise(function(resolve, reject) { // If connectionString is null or undefined, return an error. if (_.isEmpty(connectionString)) { return reject('getConnection must be called with a mongo connection string'); } // Check if a connection already exists for the provided connectionString. var pool = _.findWhere(connections, { connectionString: connectionString }); // If a connection pool was found, resolve the promise with it. if (pool) { return resolve(pool.db); } // If the connection pool has not been instantiated, // instantiate it and return the connection. MongoClient.connect(connectionString, function(err, database) { if (err) { return reject(err); } // Store the connection in the connections array. connections.push({ connectionString: connectionString, db: database }); return resolve(database); }); }); }\n\n    ### Response: Gets a Mongo connection from the pool.\n\nIf the connection pool has not been instantiated yet, it is first\ninstantiated and a connection is returned.\n\n@returns {Promise|Db} - A promise object that resolves to a Mongo db object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; } }\n\n    ### Response:", "ground_truth": "If no task cached, create one and initialize the connections.\n\n@see ConnectionManager#getAndCreateIfAbsent(Url)", "predict": " Gets a connection from the pool or creates a new one if it does not exist.\n\n@param url - The URL of the connection to get or create.\n@return - A connection object.\n\n    "}, {"ID": 409, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void purgeThreadLocal() { // if thread local pools exist, check to see if we have one created and // therefore need to tell it to purge if (null != threadLocals) { LocalThreadObjectPool pool = threadLocals.get(); if (null != pool) { Object[] data = pool.purge(); if (0 < data.length) { mainPool.putBatch(data); } } } }\n\n    ### Response: This is used to purge the ThreadLocal level information back to the main\ngroup when the thread is being killed off..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); } }\n\n    ### Response:", "ground_truth": "If no task cached, create one and initialize the connections.\nIf task cached, check whether the number of connections adequate, if not then heal it.\n\n@param url\n@return\n@throws InterruptedException\n@throws RemotingException", "predict": " This method is used to create a connection pool with initialized connections and then heal it if it is needed. If the connection pool is null, it means there is a bug in the code and it should be notified."}, {"ID": 410, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void purgeThreadLocal() { // if thread local pools exist, check to see if we have one created and // therefore need to tell it to purge if (null != threadLocals) { LocalThreadObjectPool pool = threadLocals.get(); if (null != pool) { Object[] data = pool.purge(); if (0 < data.length) { mainPool.putBatch(data); } } } }\n\n    ### Response: This is used to purge the ThreadLocal level information back to the main\ngroup when the thread is being killed off..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeTask(String poolKey) { RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey); if (null != task) { ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger); if (null != pool) { pool.removeAllAndTryClose(); } } }\n\n    ### Response:", "ground_truth": "remove task and remove all connections\n\n@param poolKey", "predict": " This method is used to remove a task from the connection pool task map. It first retrieves the task from the map and then checks if the task is null. If it is not null, it retrieves the result of the task using the FutureTaskUtil class and checks if the result is null. If the result is not null, it removes all the connections from the pool and tries to close it."}, {"ID": 411, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MessageProducer getOrCreateProducer(final String topic) { if (!this.shareProducer) { FutureTask<MessageProducer> task = this.producers.get(topic); if (task == null) { task = new FutureTask<MessageProducer>(new Callable<MessageProducer>() { @Override public MessageProducer call() throws Exception { MessageProducer producer = MetaqTemplate.this.messageSessionFactory.createProducer(); producer.publish(topic); if (!StringUtils.isBlank(MetaqTemplate.this.defaultTopic)) { producer.setDefaultTopic(MetaqTemplate.this.defaultTopic); } return producer; } }); FutureTask<MessageProducer> oldTask = this.producers.putIfAbsent(topic, task); if (oldTask != null) { task = oldTask; } else { task.run(); } } try { MessageProducer producer = task.get(); return producer; } catch (ExecutionException e) { throw ThreadUtils.launderThrowable(e.getCause()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } else { if (this.sharedProducer == null) { synchronized (this) { if (this.sharedProducer == null) { this.sharedProducer = this.messageSessionFactory.createProducer(); if (!StringUtils.isBlank(this.defaultTopic)) { this.sharedProducer.setDefaultTopic(this.defaultTopic); } } } } this.sharedProducer.publish(topic); return this.sharedProducer; } throw new IllegalStateException(\"Could not create producer for topic '\" + topic + \"'\"); }\n\n    ### Response: Returns or create a message producer for topic.\n\n@param topic\n@return\n@since 1.4.5.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException { String poolKey = url.getUniqueKey(); // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) { FutureTask<Integer> task = this.healTasks.get(poolKey); if (null == task) { task = new FutureTask<Integer>(new HealConnectionCall(url, pool)); task = this.healTasks.putIfAbsent(poolKey, task); if (null == task) { task = this.healTasks.get(poolKey); task.run(); } } try { int numAfterHeal = task.get(); if (logger.isDebugEnabled()) { logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup()); } } catch (InterruptedException e) { this.healTasks.remove(poolKey); throw e; } catch (ExecutionException e) { this.healTasks.remove(poolKey); Throwable cause = e.getCause(); if (cause instanceof RemotingException) { throw (RemotingException) cause; } else { FutureTaskUtil.launderThrowable(cause); } } // heal task is one-off, remove from cache directly after run this.healTasks.remove(poolKey); } }\n\n    ### Response:", "ground_truth": "execute heal connection tasks if the actual number of connections in pool is less than expected\n\n@param pool\n@param url", "predict": " Heals the connection pool if needed.\n\n@param pool\n@param url\n@throws RemotingException\n@throws InterruptedException\n\n    "}, {"ID": 412, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static StackTraceElement getTraceElementAt(int level) { if (level < 0) { return null; } try { final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); int j = -1; boolean found = false; Class<?> type; for (int i = 0; i < stackTrace.length; ++i) { if (found) { if ((i - j) == level) { return stackTrace[i]; } } else { type = loadClass(stackTrace[i].getClassName()); if (type != null && Caller.class.isAssignableFrom(type)) { j = i + 1; } else if (j >= 0) { // First ocurrence of a class in the stack, after the // inner invocation of StackTraceCaller found = true; if ((i - j) == level) { return stackTrace[i]; } } } } } catch (AssertionError e) { throw e; } catch (Throwable exception) { // } return null; }\n\n    ### Response: Replies the stack trace element for the given level.\n\nThe given {@code level} permits to specify which class to reply:\n\n{@code 0}: the class where is defined the function ({@code f0})\nthat has called one function of {@code Caller}\n{@code 1}: the class where is defined the function ({@code f1})\nthat has called {@code f0}\n{@code 2}: the class where is defined the function ({@code f2})\nthat has called {@code f1}\netc.\n\n\n@param level is the desired level.\n@return the stack trace element; or {@code null}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException { final int actualNum = pool.size(); final int expectNum = url.getConnNum(); if (actualNum < expectNum) { if (logger.isDebugEnabled()) { logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName); } if (url.isConnWarmup()) { for (int i = actualNum; i < expectNum; ++i) { Connection connection = create(url); pool.add(connection); } } else { if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) { throw new IllegalArgumentException( \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\"); } // create connection in sync way if (syncCreateNumWhenNotWarmup > 0) { for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) { Connection connection = create(url); pool.add(connection); } if (syncCreateNumWhenNotWarmup == url.getConnNum()) { return; } } // initialize executor in lazy way initializeExecutor(); pool.markAsyncCreationStart();// mark the start of async try { this.asyncCreateConnectionExecutor.execute(new Runnable() { @Override public void run() { try { for (int i = pool.size(); i < url.getConnNum(); ++i) { Connection conn = null; try { conn = create(url); } catch (RemotingException e) { logger .error( \"Exception occurred in async create connection thread for {}, taskName {}\", url.getUniqueKey(), taskName, e); } pool.add(conn); } } finally { pool.markAsyncCreationDone();// mark the end of async } } }); } catch (RejectedExecutionException e) { pool.markAsyncCreationDone();// mark the end of async when reject throw e; } } // end of NOT warm up } // end of if }\n\n    ### Response:", "ground_truth": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "predict": " Creates a connection to the specified URL.\n\n@param url the URL to connect to.\n@return the created connection.\n@throws RemotingException if failed to create the connection."}, {"ID": 413, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getUrlAsString(final Class<? extends Page> pageClass) { final Url pageUrl = getPageUrl(pageClass); final Url url = getBaseUrl(pageClass); url.resolveRelative(pageUrl); final String contextPath = getContextPath(); return String.format(\"%s/%s\", contextPath, url); }\n\n    ### Response: Gets the url as string from the given WebPage class object.\n\n@param pageClass\nthe page class\n@return the url as string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void closeConnection(String addr) { Url url = this.addressParser.parse(addr); this.connectionManager.remove(url.getUniqueKey()); }\n\n    ### Response:", "ground_truth": "Close all connections of a address\n\n@param addr", "predict": " Closes the connection for the given address.\n\n@param addr\nthe address of the connection to be closed."}, {"ID": 414, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void update(Registry registry) { Iterator<Map.Entry<Id, Object>> iter = registry.state().entrySet().iterator(); while (iter.hasNext()) { Map.Entry<Id, Object> entry = iter.next(); if (entry.getValue() instanceof AbstractMeterState) { AbstractMeterState tuple = (AbstractMeterState) entry.getValue(); tuple.doUpdate(registry); if (tuple.hasExpired()) { iter.remove(); } } } }\n\n    ### Response: Force the polling of all meters associated with the registry..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }\n\n    ### Response:", "ground_truth": "Do something when closing.", "predict": "Close all the active connections and remove them from the connection pool."}, {"ID": 415, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ChannelFuture connect(final SocketAddress remoteAddress) { if (!(remoteAddress instanceof InetSocketAddress)) { throw new IllegalArgumentException(\"expecting InetSocketAddress\"); } final SettableChannelFuture settableChannelFuture = new SettableChannelFuture(); super.connect(socksProxyAddr).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { settableChannelFuture.setChannel(future.getChannel()); if (future.isSuccess()) { socksConnect(future.getChannel(), (InetSocketAddress) remoteAddress).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture innerFuture) throws Exception { if (innerFuture.isSuccess()) { settableChannelFuture.setSuccess(); } else { settableChannelFuture.setFailure(innerFuture.getCause()); } } }); } else { settableChannelFuture.setFailure(future.getCause()); } } }); return settableChannelFuture; }\n\n    ### Response: Hijack the connect method to connect to socks proxy and then\nsend the connection handshake once connection to proxy is established.\n\n@return returns a ChannelFuture, it will be ready once the connection to\nsocks and the remote address is established ( i.e. after the handshake completes ).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } }\n\n    ### Response:", "ground_truth": "Close the connection.", "predict": "Close the connection to the remote address. If the connection is not established, it will return immediately. If the connection is established, it will send a close request to the remote address and wait for the response. If the response is received, it will close the connection. If the response is not received in a specified time, it will close the connection anyway. If there is any exception caught during the process, it will log a warning message."}, {"ID": 416, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object put(Object key, Object value) { mCacheMap.put(key, value); return mBackingMap.put(key, value); }\n\n    ### Response: Puts the entry into both the cache and backing map. The old value in\nthe backing map is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); }\n\n    ### Response:", "ground_truth": "set attribute if key absent.\n\n@param key\n@param value\n@return", "predict": " Sets the attribute with the given key to the given value if the attribute is not already present. If the attribute is already present, the existing value is returned."}, {"ID": 417, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addProcessor(String nodeName, NodeProcessor processor) { if (null == processor) { throw new IllegalArgumentException(\"Processor should not be null.\"); } if (IS_EMPTY.test(nodeName)) { throw new IllegalArgumentException(\"The node name should not be empty.\"); } getActionPool().put(nodeName, processor); }\n\n    ### Response: Add a specific processing that will be applied to nodes having the matching name.\n\n@param nodeName\nthe name of nodes that will be processed.\n@param processor\nthe processor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (processor instanceof MultiInterestUserProcessor) { registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors); } else { if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } }\n\n    ### Response:", "ground_truth": "Help register single-interest user processor.\n\n@param processor  the processor need to be registered\n@param userProcessors   the map of user processors", "predict": " Register a user processor to the server.\n\n@param processor\nthe user processor to be registered.\n@param userProcessors\nthe map of user processors.\n\n    "}, {"ID": 418, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addTaggedComponent(final String tag, final WComponent component) { if (Util.empty(tag)) { throw new IllegalArgumentException(\"A tag must be provided.\"); } if (component == null) { throw new IllegalArgumentException(\"A component must be provided.\"); } TemplateModel model = getOrCreateComponentModel(); if (model.taggedComponents == null) { model.taggedComponents = new HashMap<>(); } else { if (model.taggedComponents.containsKey(tag)) { throw new IllegalArgumentException(\"The tag [\" + tag + \"] has already been added.\"); } if (model.taggedComponents.containsValue(component)) { throw new IllegalArgumentException(\"Component has already been added.\"); } } model.taggedComponents.put(tag, component); add(component); }\n\n    ### Response: Add a tagged component to be included in the template. The component will be rendered in place of the\ncorresponding tag in the template.\n\n@param tag the tag for this component in the template\n@param component the component to add.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) { throw new RuntimeException(\"Processor interest should not be blank!\"); } for (String interest : processor.multiInterest()) { UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } }\n\n    ### Response:", "ground_truth": "Help register multi-interest user processor.\n\n@param processor  the processor with multi-interest need to be registered\n@param userProcessors    the map of user processors", "predict": " Register a user processor for the given multi-interest.\n\n@param processor the user processor to register\n@param userProcessors the map of user processors keyed by their interests"}, {"ID": 419, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void handleItem(final String name) { if (name.endsWith(\".class\")) { final String classname = toClassName(name); try { final Class<?> type = loader.loadClass(classname); if (parentType.isAssignableFrom(type)) { this.classes.add(type); } } catch (Throwable t) { log.debug(\"could not load class: \" + classname, t); } } }\n\n    ### Response: Checks an item to see if it is a class and is annotated with the specified\nannotation.  If so, adds it to the set, otherwise ignores it.\n@param name the path equivelant to the package + class/item name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) { final int id = cmd.getId(); final byte type = cmd.getType(); // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass()); if (processor instanceof AsyncUserProcessor) { try { processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject()); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } else { try { Object responseObject = processor .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), cmd.getRequestObject()); sendResponseIfNecessary(ctx, type, this.getCommandFactory().createResponse(responseObject, cmd)); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } }\n\n    ### Response:", "ground_truth": "dispatch request command to user processor\n@param ctx remoting context\n@param cmd rpc request command", "predict": " Dispatches the given request to the appropriate user processor based on the request class.  If the processor is an instance of AsyncUserProcessor, it will be processed asynchronously, otherwise it will be processed synchronously.  If an exception occurs during processing, an appropriate response will be sent back to the client.\n@param ctx the remoting context\n@param cmd the rpc request command"}, {"ID": 420, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean runExample(final Callable<Boolean> example) { boolean result; try { result = example.call(); } catch (Exception e) { LOG.error(\"Exception running test: \" + example, e); result = false; } CliUtils.printPassInfo(result); return result; }\n\n    ### Response: Runs an example.\n\n@param example the example to run\n@return whether the example completes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) { boolean result; try { cmd.deserialize(level); result = true; } catch (DeserializationException e) { logger .error( \"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e)); result = false; } catch (Throwable t) { String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" + cmd.getId() + \", deserializeLevel=\" + level; logger.error(errMsg, t); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), t, errMsg)); result = false; } return result; }\n\n    ### Response:", "ground_truth": "deserialize request command\n\n@return true if deserialize success; false if exception catched", "predict": " Deserializes a RpcRequestCommand.\n\n@param ctx the remoting context\n@param cmd the RpcRequestCommand to deserialize\n@param level the deserialize level\n@return whether the deserialization is successful"}, {"ID": 421, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long interpolateTimeSinceUpdate(TrackPositionUpdate update, long currentTimestamp) { if (!update.playing) { return update.milliseconds; } long elapsedMillis = (currentTimestamp - update.timestamp) / 1000000; long moved = Math.round(update.pitch * elapsedMillis); if (update.reverse) { return update.milliseconds - moved; } return update.milliseconds + moved; }\n\n    ### Response: Figure out, based on how much time has elapsed since we received an update, and the playback position,\nspeed, and direction at the time of that update, where the player will be now.\n\n@param update the most recent update received from a player\n@param currentTimestamp the nanosecond timestamp representing when we want to interpolate the track's position\n\n@return the playback position we believe that player has reached now.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); }\n\n    ### Response:", "ground_truth": "pre process remoting context, initial some useful infos and pass to biz\n\n@param ctx remoting context\n@param cmd rpc request command\n@param currentTimestamp current timestamp", "predict": " This method pre-processes the remoting context before invoking a remote method. It sets the arrival timestamp, timeout, and RPC command type on the context, and also sets the wait time for the bolt process on the invoke context.\n\n@param ctx the remoting context to be pre-processed\n@param cmd the RPC request command that triggered the invocation\n@param currentTimestamp the current timestamp in nanoseconds\n\n    "}, {"ID": 422, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isValid(final String expectedAudience, final String expectedIssuer, final long timeDrift) { if (!this.audience.equalsIgnoreCase(expectedAudience)) { LOGGER.warn(\"Audience [{}] is invalid where the expected audience should be [{}]\", this.audience, expectedAudience); return false; } if (!this.issuer.equalsIgnoreCase(expectedIssuer)) { LOGGER.warn(\"Issuer [{}] is invalid since the expected issuer should be [{}]\", this.issuer, expectedIssuer); return false; } val retrievedOnTimeDrift = this.getRetrievedOn().minus(timeDrift, ChronoUnit.MILLIS); if (this.issuedOn.isBefore(retrievedOnTimeDrift)) { LOGGER.warn(\"Ticket is issued before the allowed drift. Issued on [{}] while allowed drift is [{}]\", this.issuedOn, retrievedOnTimeDrift); return false; } val retrievedOnTimeAfterDrift = this.retrievedOn.plus(timeDrift, ChronoUnit.MILLIS); if (this.issuedOn.isAfter(retrievedOnTimeAfterDrift)) { LOGGER.warn(\"Ticket is issued after the allowed drift. Issued on [{}] while allowed drift is [{}]\", this.issuedOn, retrievedOnTimeAfterDrift); return false; } if (this.retrievedOn.isAfter(this.notOnOrAfter)) { LOGGER.warn(\"Ticket is too late because it's retrieved on [{}] which is after [{}].\", this.retrievedOn, this.notOnOrAfter); return false; } LOGGER.debug(\"WsFed Credential is validated for [{}] and [{}].\", expectedAudience, expectedIssuer); return true; }\n\n    ### Response: isValid validates the credential.\n\n@param expectedAudience the audience that the token was issued to (CAS Server)\n@param expectedIssuer   the issuer of the token (the IdP)\n@param timeDrift        the amount of acceptable time drift\n@return true if the credentials are valid, otherwise false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); }\n\n    ### Response:", "ground_truth": "print some log when request timeout and discarded in io thread.", "predict": "timeoutLog logs the timeout of the Rpc request.\n\n@param cmd the Rpc request command\n@param currentTimestamp the current timestamp\n@param ctx the RemotingContext\n@return void\n\n    "}, {"ID": 423, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long interpolateTimeSinceUpdate(TrackPositionUpdate update, long currentTimestamp) { if (!update.playing) { return update.milliseconds; } long elapsedMillis = (currentTimestamp - update.timestamp) / 1000000; long moved = Math.round(update.pitch * elapsedMillis); if (update.reverse) { return update.milliseconds - moved; } return update.milliseconds + moved; }\n\n    ### Response: Figure out, based on how much time has elapsed since we received an update, and the playback position,\nspeed, and direction at the time of that update, where the player will be now.\n\n@param update the most recent update received from a player\n@param currentTimestamp the nanosecond timestamp representing when we want to interpolate the track's position\n\n@return the playback position we believe that player has reached now.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } }\n\n    ### Response:", "ground_truth": "print some debug log when receive request", "predict": " Log the details of an incoming RPC request, including the request ID, the remote address of the sender, the current timestamp, the arrival time of the request, the server cost, and the timeout.\n\n@param ctx the remoting context of the incoming request\n@param cmd the RPC request command\n@param currentTimestamp the current timestamp in nanoseconds\n\n@return nothing."}, {"ID": 424, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception { if (msg instanceof RemoteInputChannel) { boolean triggerWrite = inputChannelsWithCredit.isEmpty(); inputChannelsWithCredit.add((RemoteInputChannel) msg); if (triggerWrite) { writeAndFlushNextMessageIfPossible(ctx.channel()); } } else { ctx.fireUserEventTriggered(msg); } }\n\n    ### Response: Triggered by notifying credit available in the client handler pipeline.\n\nEnqueues the input channel and will trigger write&flush unannounced credits\nfor this input channel if it is the first one in the queue..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } }\n\n    ### Response:", "ground_truth": "Process the remoting command with its own executor or with the defaultExecutor if its own if null.\n\n@param ctx\n@param msg\n@param defaultExecutor\n@throws Exception", "predict": " Processes the message in a separate thread or executor. If the executor is not set, the default executor will be used."}, {"ID": 425, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void executeOnGdx (final Runnable runnable) { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Exception> exceptionAt = new AtomicReference<Exception>(); Gdx.app.postRunnable(new Runnable() { @Override public void run () { try { runnable.run(); } catch (Exception e) { exceptionAt.set(e); } finally { latch.countDown(); } } }); try { latch.await(); final Exception e = exceptionAt.get(); if (e != null) { failed(e); } } catch (InterruptedException e) { failed(e); } }\n\n    ### Response: Executes runnable on main GDX thread. This methods blocks until runnable has finished executing. Note that this\nrunnable will also block main render thread..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), invokeCallback); conn.addInvokeFuture(future); final int requestId = request.getId(); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(requestId); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn .getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture cf) throws Exception { if (!cf.isSuccess()) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse( conn.getRemoteAddress(), cf.cause())); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause()); } } }); } catch (Exception e) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e)); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } }\n\n    ### Response:", "ground_truth": "Invocation with callback.\n\n@param conn\n@param request\n@param invokeCallback\n@param timeoutMillis\n@throws InterruptedException", "predict": " Sends the given request to the given connection and registers a callback to be executed when the response is received. The method blocks until the response is received or the timeout is reached. If the response is received successfully, the callback is executed on the main GDX thread. If the response is not received within the specified timeout, the callback is executed on the main GDX thread with a TimeoutException. If an exception occurs during the request sending, the callback is executed on the main GDX thread with the exception."}, {"ID": 426, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ChannelFuture connect(final SocketAddress remoteAddress) { if (!(remoteAddress instanceof InetSocketAddress)) { throw new IllegalArgumentException(\"expecting InetSocketAddress\"); } final SettableChannelFuture settableChannelFuture = new SettableChannelFuture(); super.connect(socksProxyAddr).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { settableChannelFuture.setChannel(future.getChannel()); if (future.isSuccess()) { socksConnect(future.getChannel(), (InetSocketAddress) remoteAddress).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture innerFuture) throws Exception { if (innerFuture.isSuccess()) { settableChannelFuture.setSuccess(); } else { settableChannelFuture.setFailure(innerFuture.getCause()); } } }); } else { settableChannelFuture.setFailure(future.getCause()); } } }); return settableChannelFuture; }\n\n    ### Response: Hijack the connect method to connect to socks proxy and then\nsend the connection handshake once connection to proxy is established.\n\n@return returns a ChannelFuture, it will be ready once the connection to\nsocks and the remote address is established ( i.e. after the handshake completes ).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } }\n\n    ### Response:", "ground_truth": "Oneway invocation.\n\n@param conn\n@param request\n@throws InterruptedException", "predict": "This method is used to send a one-way request to the remote server. It will not wait for the response. If there is any exception during the sending process, it will log the error message."}, {"ID": 427, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void validateTypes(byte[] types) { if (types == null) { throw new IllegalArgumentException(\"types is null\"); } for (int i = 0; i < types.length; ++i) { if (types[i] < TYPE_MIN || types[i] > TYPE_MAX) { throw new IllegalArgumentException(\"illegal type value at \" + i + \": \" + types[i]); } } for (int i = 0; i < types.length - 1; ++i) { if (types[i] == B) { throw new IllegalArgumentException(\"B type before end of paragraph at index: \" + i); } } }\n\n    ### Response: Throw exception if type array is invalid..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; }\n\n    ### Response:", "ground_truth": "from bit set to byte\n@param bs\n@return byte represent the bit set", "predict": " Convert a BitSet to a byte value.\n\n    "}, {"ID": 428, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static ByteBuf encodeRemainingLength(int value) throws CorruptedFrameException { if (value > MAX_LENGTH_LIMIT || value < 0) { throw new CorruptedFrameException(\"Value should in range 0..\" + MAX_LENGTH_LIMIT + \" found \" + value); } ByteBuf encoded = Unpooled.buffer(4); byte digit; do { digit = (byte) (value % 128); value = value / 128; // if there are more digits to encode, set the top bit of this digit if (value > 0) { digit = (byte) (digit | 0x80); } encoded.writeByte(digit); } while (value > 0); return encoded; }\n\n    ### Response: Encode the value in the format defined in specification as variable length\narray.\n\n@throws IllegalArgumentException if the value is not in the specification bounds\n[0..268435455]..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; }\n\n    ### Response:", "ground_truth": "from byte to bit set\n@param value\n@return bit set represent the byte", "predict": " Convert the integer value to a BitSet representation.\n\n@throws IllegalArgumentException if the value is out of byte range, should be limited between [Byte.MIN_VALUE] to [Byte.MAX_VALUE]"}, {"ID": 429, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void add(final Writer writer, final LogEntry logEntry) { Task task = new Task(writer, logEntry); synchronized (mutex) { tasks.add(task); } }\n\n    ### Response: Adds a log entry for writing.\n\n@param writer\nWriter to write given log entry\n@param logEntry\nLog entry to write.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); }\n\n    ### Response:", "ground_truth": "add reconnect task\n\n@param url", "predict": " Adds a reconnect task for the given URL.\n\n@param url\nURL to reconnect to."}, {"ID": 430, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void stop() { if (!monitorActive) { return; } monitorActive = false; resetAccounting(milliSecondFromNano()); if (trafficShapingHandler != null) { trafficShapingHandler.doAccounting(this); } if (scheduledFuture != null) { scheduledFuture.cancel(true); } }\n\n    ### Response: Stop the monitoring process..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop() { if (!this.started) { return; } this.started = false; healConnectionThreads.interrupt(); this.tasks.clear(); this.canceled.clear(); }\n\n    ### Response:", "ground_truth": "stop reconnect thread", "predict": " Stop the monitoring process."}, {"ID": 431, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updated(Dictionary<?, ?> props) { String value = (String) props.get(PROP_IDNAME); if (null != value) { this.idName = value.trim(); } value = (String) props.get(PROP_USE_URLS); if (null != value && Boolean.parseBoolean(value.trim())) { this.urlRewritingMarker = \";\" + getIDName() + \"=\" + getSessionVersion(); } value = (String) props.get(PROP_USE_COOKIES); if (null != value) { this.enableCookies = Boolean.parseBoolean(value.trim()); } if (this.enableCookies) { // we're using cookies for session information value = (String) props.get(PROP_COOKIE_SECURE); if (null != value) { this.cookieSecure = Boolean.parseBoolean(value.trim()); } value = (String) props.get(PROP_COOKIE_PATH); if (null != value) { this.cookiePath = value.trim(); } value = (String) props.get(PROP_COOKIE_DOMAIN); if (null != value) { this.cookieDomain = value.trim(); } value = (String) props.get(PROP_COOKIE_MAXAGE); if (null != value) { try { this.cookieMaxAge = Integer.parseInt(value.trim()); } catch (NumberFormatException nfe) { if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) { Tr.event(tc, \"Ignoring incorrect max-age [\" + value + \"]\", nfe.getMessage()); } } } } if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) { Tr.event(tc, \"Config: id name [\" + this.idName + \"]\"); if (isURLRewriting()) { Tr.event(tc, \"Config: use URL rewriting [\" + this.urlRewritingMarker + \"]\"); } if (this.enableCookies) { Tr.event(tc, \"Config: cookie max-age [\" + this.cookieMaxAge + \"]\"); Tr.event(tc, \"Config: cookie secure [\" + this.cookieSecure + \"]\"); Tr.event(tc, \"Config: cookie domain [\" + this.cookieDomain + \"]\"); Tr.event(tc, \"Config: cookie path [\" + this.cookiePath + \"]\"); } else { Tr.event(tc, \"Config: cookies disabled\"); } } }\n\n    ### Response: Session configuration has been updated with the provided properties.\n\n@param props.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException { RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request); if (null != invokeContext) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER); if (null != clientCustomSerializer) { try { command.setSerializer((Byte) clientCustomSerializer); } catch (ClassCastException e) { throw new IllegalArgumentException( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\"); } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE); if (null != crcSwitch && crcSwitch) { command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } } else { // enable crc by default, if there is no invoke context. command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } command.setTimeout(timeoutMillis); command.setRequestClass(request.getClass().getName()); command.setInvokeContext(invokeContext); command.serialize(); logDebugInfo(command); return command; }\n\n    ### Response:", "ground_truth": "Convert application request object to remoting request command.\n\n@param request\n@param conn\n@param timeoutMillis\n@return\n@throws CodecException", "predict": " Convert the given request object to a RemotingCommand object.\n\n@param request the request object to be converted.\n@param conn the connection to send the command.\n@param invokeContext the invoke context of the request.\n@param timeoutMillis the timeout of the request.\n@return the RemotingCommand object.\n@throws SerializationException if the request object cannot be serialized."}, {"ID": 432, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final static List<ConnectionNotation> getAllEdgeConnections(List<ConnectionNotation> connections) { List<ConnectionNotation> listEdgeConnection = new ArrayList<ConnectionNotation>(); for (ConnectionNotation connection : connections) { if (!(connection.getrGroupSource().equals(\"pair\"))) { listEdgeConnection.add(connection); } } return listEdgeConnection; }\n\n    ### Response: method to get all edge connections of a given List of ConnectionNotation\n\n@param connections List of ConnectionNotation objects\n@return all edge connections.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Map<String, List<Connection>> filter(List<Connection> connections) { List<Connection> serviceOnConnections = new ArrayList<Connection>(); List<Connection> serviceOffConnections = new ArrayList<Connection>(); Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>(); for (Connection connection : connections) { String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS); if (serviceStatus != null) { if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) { serviceOffConnections.add(connection); } } else { serviceOnConnections.add(connection); } } filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections); filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections); return filteredConnections; }\n\n    ### Response:", "ground_truth": "Filter connections to monitor\n\n@param connections", "predict": " method to filter the given list of connections based on the service status attribute\n\n@param connections List of Connection objects\n@return a map of filtered connections based on the service status attribute."}, {"ID": 433, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) { String resultSuffix = \"\"; String suffix = null; StructuralNode child = null; try { for (int i = 0; i < staticSuffixList.length; i++) { suffix = staticSuffixList[i]; Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); try { if (child.getURI().getPath().endsWith(suffix)) { return suffix; } } catch (Exception e) { } } } if (performRecursiveCheck) { Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); resultSuffix = getChildSuffix(child, performRecursiveCheck); if (!resultSuffix.equals(\"\")) { return resultSuffix; } } } } catch (Exception e) { } return resultSuffix; }\n\n    ### Response: Get a suffix from the children which exists in staticSuffixList. An\noption is provided to check recursively. Note that the immediate children\nare always checked first before further recursive check is done.\n\n@param\tnode the node used to obtain the suffix\n@param\tperformRecursiveCheck\tTrue = get recursively the suffix from all\nthe children.\n@return\tThe suffix \".xxx\" is returned. If there is no suffix found, an\nempty string is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) { try { if (null != connPools && !connPools.isEmpty()) { Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools .entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter .next(); String poolKey = entry.getKey(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); List<Connection> connections = pool.getAll(); Map<String, List<Connection>> filteredConnectons = this.filter(connections); List<Connection> serviceOnConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_ON); List<Connection> serviceOffConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_OFF); if (serviceOnConnections.size() > CONNECTION_THRESHOLD) { Connection freshSelectConnect = serviceOnConnections.get(random .nextInt(serviceOnConnections.size())); freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF); Connection lastSelectConnect = freshSelectConnections.remove(poolKey); freshSelectConnections.put(poolKey, freshSelectConnect); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } else { if (freshSelectConnections.containsKey(poolKey)) { Connection lastSelectConnect = freshSelectConnections.remove(poolKey); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } if (logger.isInfoEnabled()) { logger .info( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD); } } for (Connection offConn : serviceOffConnections) { if (offConn.isFine()) { offConn.close(); } } } } } catch (Exception e) { logger.error(\"ScheduledDisconnectStrategy monitor error\", e); } }\n\n    ### Response:", "ground_truth": "Monitor connections and close connections with status is off\n\n@param connPools", "predict": " Monitor the connection pools and close the connections which are not fine. If the size of serviceOnConnections is greater than CONNECTION_THRESHOLD, randomly select a connection from serviceOnConnections and close the other connections in serviceOffConnections. If the size of serviceOnConnections is less than or equal to CONNECTION_THRESHOLD, close the last selected connection in serviceOffConnections.\n\n@param\tconnPools\tThe connection pools to be monitored.\n@return\tNone."}, {"ID": 434, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void runFlow() throws Exception { this.logger.info(\"Starting flows\"); runReadyJob(this.flow); updateFlow(); while (!this.flowFinished) { synchronized (this.mainSyncObj) { if (this.flowPaused) { try { this.mainSyncObj.wait(CHECK_WAIT_MS); } catch (final InterruptedException e) { } continue; } else { if (this.retryFailedJobs) { retryAllFailures(); } else if (!progressGraph()) { try { this.mainSyncObj.wait(CHECK_WAIT_MS); } catch (final InterruptedException e) { } } } } } this.logger.info(\"Finishing up flow. Awaiting Termination\"); this.executorService.shutdown(); updateFlow(); this.logger.info(\"Finished Flow\"); }\n\n    ### Response: Main method that executes the jobs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException { if (null != lastSelectConnect) { if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { Thread.sleep(RETRY_DETECT_PERIOD); if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { if (logger.isInfoEnabled()) { logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel())); } } } } }\n\n    ### Response:", "ground_truth": "close the connection of the fresh select connections\n\n@param lastSelectConnect\n@param serviceOffConnections\n@throws InterruptedException", "predict": " Closes the fresh select connections and adds them to the list of connections to be closed.\n\n    "}, {"ID": 435, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getSettingForApp(App app, String key, String defaultValue) { if (app != null) { Map<String, Object> settings = app.getSettings(); if (settings.containsKey(key)) { return String.valueOf(settings.getOrDefault(key, defaultValue)); } else if (app.isRootApp()) { return Config.getConfigParam(key, defaultValue); } } return defaultValue; }\n\n    ### Response: Returns the value of the app setting, read from from app.settings or from the config file if app is root.\n@param app the app in which to look for these keys\n@param key setting key\n@param defaultValue default value\n@return the value of the configuration property as string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean getBool(String key, String defaultValue) { return Boolean.parseBoolean(System.getProperty(key, defaultValue)); }\n\n    ### Response:", "ground_truth": "~~~ public helper methods to retrieve system property", "predict": " Returns the boolean value of the system property with the given key, or the default value if the property is not set or cannot be parsed as a boolean.\n@param key the key of the system property to look up\n@param defaultValue the default value to use if the property is not set or cannot be parsed as a boolean\n@return the boolean value of the system property with the given key, or the default value if the property is not set or cannot be parsed as a boolean."}, {"ID": 436, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void linkUp(Mtp2 link) { if (link.mtp2Listener != null) { link.mtp2Listener.linkUp(); } linkset.add(link); if (linkset.isActive() && this.mtp3Listener != null) { try { mtp3Listener.linkUp(); } catch (Exception e) { e.printStackTrace(); } } if (logger.isInfoEnabled()) { logger.info(String.format(\"(%s) Link now IN_SERVICE\", link.getName())); } }\n\n    ### Response: Notify that link is up.\n\n@param link.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void infoLog(String format, String addr) { if (logger.isInfoEnabled()) { if (StringUtils.isNotEmpty(addr)) { logger.info(format, addr); } else { logger.info(format, \"UNKNOWN-ADDR\"); } } }\n\n    ### Response:", "ground_truth": "print info log\n@param format\n@param addr", "predict": " Log information about the given address.\n\n@param format.\n@param addr."}, {"ID": 437, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isTypeGenerifiedBy(String type) { if (typeGenericName.length > 2 && typeGenericName[2].equals(type)) { return true; } if (typeGenericName.length > 1 && typeGenericName[1].equals(type)) { return true; } if (typeGenericName.length > 0 && typeGenericName[0].equals(type)) { return true; } return false; }\n\n    ### Response: Checks if the type specified is one of the bean's type parameters.\n@param type  the type\n@return true if a type parameter of this bean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isRequestTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; }\n\n    ### Response:", "ground_truth": "whether this request already timeout\n\n@return", "predict": " Checks if the request has timed out.\n@return true if the request has timed out."}, {"ID": 438, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean hidden(String className) { className = removeTemplate(className); ClassInfo ci = classnames.get(className); return ci != null ? ci.hidden : optionProvider.getOptionsFor(className).matchesHideExpression(className); }\n\n    ### Response: Return true if the class name is associated to an hidden class or matches a hide expression.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public UserProcessor<?> getUserProcessor(String className) { return StringUtils.isBlank(className) ? null : this.userProcessors.get(className); }\n\n    ### Response:", "ground_truth": "Get user processor for class name.\n\n@param className\n@return", "predict": " Get the user processor for the given class name. If the class name is blank or not found, return null."}, {"ID": 439, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Project findProjectInDirectory(Resource<?> target, ProjectProvider projectProvider, Predicate<Project> filter) { Project result = null; Imported<ProjectCache> caches = getCaches(); if (projectProvider.containsProject(target)) { boolean cached = false; for (ProjectCache cache : caches) { result = cache.get(target); if (result != null && !filter.accept(result)) { result = null; } if (result != null) { cached = true; break; } } if (result == null) { result = projectProvider.createProject(target); } if (result != null && !filter.accept(result)) { result = null; } if (result != null && !cached) { registerAvailableFacets(result); cacheProject(result); } } return result; }\n\n    ### Response: Returns project residing in given directory, if no such is found then null is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; }\n\n    ### Response:", "ground_truth": "get one connection randomly\n\n@param conns\n@return", "predict": " Returns a random connection from the given list of connections. If the list is null or empty, then null is returned. If the connection is not fine, then it is discarded and another connection is tried. The maximum number of tries is set to 10."}, {"ID": 440, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T get(String key, Class<T> valueClass) { return (T) values.get(key); }\n\n    ### Response: Gets a shared value by it's key\n\n Automatically casts the value to the desired type \n\n@param key        the key\n@param valueClass the class of the value\n@param         the type of the value\n@return the shared value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; }\n\n    ### Response:", "ground_truth": "get and use default if not found\n\n@param key\n@param defaultIfNotFound\n@param \n@return", "predict": " Gets a shared value by it's key. If the value is not found, returns the default value.\n\n@param key                the key\n@param defaultIfNotFound  the default value to return if the value is not found\n@param         the type of the value\n@return the shared value or the default value if not found."}, {"ID": 441, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getProperty(String key) { key = UniformUtils.checkPropertyNameAndLowerCase(key); if (properties == null) { return null; } return properties.get(key); }\n\n    ### Response: Returns a property of this tag by key, if present.\n\n@param key Property key\n@return Property value or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getProperty(String key) { if (properties == null) { return null; } return properties.getProperty(key); }\n\n    ### Response:", "ground_truth": "Get property value according to property key\n\n@param key\n@return property value", "predict": " Returns a property of this tag by key, if present.\n\n@param key Property key\n@return Property value or null."}, {"ID": 442, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InetAddress getByAddress(String host, byte[] addr, int scopeId) throws UnknownHostException { if (host != null && host.length() > 0 && host.charAt(0) == '[') { if (host.charAt(host.length()-1) == ']') { host = host.substring(1, host.length() -1); } } if (addr != null) { if (addr.length == Inet4Address.INADDRSZ) { return new Inet4Address(host, addr); } else if (addr.length == Inet6Address.INADDRSZ) { byte[] newAddr = IPAddressUtil.convertFromIPv4MappedAddress(addr); if (newAddr != null) { return new Inet4Address(host, newAddr); } else { return new Inet6Address(host, addr, scopeId); } } } throw new UnknownHostException(\"addr is of illegal length\"); }\n\n    ### Response: Do not delete. Called from native code..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException { preProcess(responseCommand, addr); if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return toResponseObject(responseCommand); } else { String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId()); logger.warn(msg); if (responseCommand.getCause() != null) { throw new InvokeException(msg, responseCommand.getCause()); } else { throw new InvokeException(msg + \", please check the server log for more.\"); } } }\n\n    ### Response:", "ground_truth": "Analyze the response command and generate the response object.\n\n@param responseCommand response command\n@param addr response address\n@return response object", "predict": " Do not delete. Called from native code.."}, {"ID": 443, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object deserialize(String json, String containerType, Class cls, NestedContent nestedContent) throws ApiException { try{ if((\"List\".equals(containerType) || \"Array\".equals(containerType)) && nestedContent != null){ if(NestedContent.CONTEXT.equals(nestedContent)){ JavaType typeInfo = JsonUtil.getJsonMapper().getTypeFactory().constructFromCanonical(\"java.util.List<java.util.List<io.cortical.rest.model.Context>>\"); Object response = (java.lang.Object) JsonUtil.getJsonMapper().readValue(json, typeInfo); return response; }else if(NestedContent.TERM.equals(nestedContent)){ JavaType typeInfo = JsonUtil.getJsonMapper().getTypeFactory().constructFromCanonical(\"java.util.List<java.util.List<io.cortical.rest.model.Term>>\"); Object response = (java.lang.Object) JsonUtil.getJsonMapper().readValue(json, typeInfo); return response; }else{ return null; } } else if(\"List\".equals(containerType) || \"Array\".equals(containerType)) { JavaType typeInfo = JsonUtil.getJsonMapper().getTypeFactory().constructCollectionType(List.class, cls); List response = (List<?>) JsonUtil.getJsonMapper().readValue(json, typeInfo); return response; } else if(String.class.equals(cls)) { if(json != null && json.startsWith(\"\\\"\") && json.endsWith(\"\\\"\") && json.length() > 1) return json.substring(1, json.length() - 2); else return json; } else { return JsonUtil.getJsonMapper().readValue(json, cls); } } catch (IOException e) { throw new ApiException(500, e.getMessage()); } }\n\n    ### Response: Deserialize a received response String.\n@param json the received json String\n@param containerType the containerType\n@param cls the class of the object\n@param nestedContent contains the name of the Pojo, contained in a List of Lists. null if no nested content is present.\n@throws APIException if an exception occurs during deserialization.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); }\n\n    ### Response:", "ground_truth": "Convert remoting response command to application response object.", "predict": " Converts a ResponseCommand to a response object.\n@param responseCommand the ResponseCommand to convert\n@return the response object\n@throws CodecException if an exception occurs during deserialization."}, {"ID": 444, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Throwable getPreviousException() throws ExceptionInstantiationException { Throwable ex = null; if (previousExceptionObject != null) return previousExceptionObject; if (previousException != null) { try { final ByteArrayInputStream bais = new ByteArrayInputStream(previousException); ObjectInputStream ois = (ObjectInputStream) AccessController.doPrivileged(new PrivilegedExceptionAction() { @Override public Object run() throws IOException { return new ObjectInputStream(bais); } }); ex = (Throwable) ois.readObject(); } catch (PrivilegedActionException pae) { throw new ExceptionInstantiationException(pae.getException()); } catch (Exception e) { throw new ExceptionInstantiationException(e); } } return ex; }\n\n    ### Response: Retrieves the previous exception\n\n@exception com.ibm.websphere.exception.ExceptionInstantiationException\nAn exception occurred while trying to instantiate an exception object.\nIf this exception is thrown, the relevant information can be retrieved\nby using the getPreviousExceptionInfo() method.\n\n\n@return java.lang.Throwable.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; }\n\n    ### Response:", "ground_truth": "Convert remoting response command to throwable if it is a throwable, otherwise return null.", "predict": " Converts a ResponseCommand to a Throwable object.\n\n@param responseCommand The ResponseCommand to convert.\n@return java.lang.Throwable.\n@exception com.ibm.ws.rsadapter.codec.CodecException\nAn exception occurred while trying to deserialize the response object."}, {"ID": 445, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String formatId(long id) { long[] arr = parseId(id); String tmf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date(arr[0])); return String.format(\"%s, #%d, @(%d,%d)\", tmf, arr[3], arr[1], arr[2]); }\n\n    ### Response: extract and display time stamp, datacenterId, workerId and sequence number\ninformation from the given id in humanization format\n\n@param id\nsnowflake id in Long format\n@return snowflake id in String format.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } }\n\n    ### Response:", "ground_truth": "Detail your error msg with the error msg returned from response command", "predict": " extract and display detailed error message from the given response command\n\n@param clientErrMsg\nerror message in String format\n@param responseCommand\nRpcResponseCommand object\n@return detailed error message in String format."}, {"ID": 446, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UnitResponse createMissingParam(Object theMissingParameters, String errMsg) { return UnitResponse.createError(Group.CODE_LACK_OF_PARAMETER, theMissingParameters, errMsg); }\n\n    ### Response: create a new unit response when missingParam\n\n@param theMissingParameters theMissingParameters array, leave it null, if you dont know which parameter is missing.\n@return the newly created response object describing the missed parameters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; }\n\n    ### Response:", "ground_truth": "create server exception using error msg and fill the stack trace using the stack trace of throwable.\n\n@param t the origin throwable to fill the stack trace of rpc server exception\n@param errMsg additional error msg, null is allowed\n@return an instance of RpcServerException", "predict": " create a new RpcServerException with the given error message and the stack trace of the given Throwable.\n\n@param t the Throwable that caused the error.\n@param errMsg the error message to be included in the RpcServerException.\n@return the newly created RpcServerException object."}, {"ID": 447, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Integer max(Connection connection, String table, String column, String where, String[] args) { Integer max = null; if (count(connection, table, where, args) > 0) { StringBuilder maxQuery = new StringBuilder(); maxQuery.append(\"select max(\") .append(CoreSQLUtils.quoteWrap(column)).append(\") from \") .append(CoreSQLUtils.quoteWrap(table)); if (where != null) { maxQuery.append(\" where \").append(where); } String sql = maxQuery.toString(); max = querySingleInteger(connection, sql, args, false); } return max; }\n\n    ### Response: Get the max query result\n\n@param connection\nconnection\n@param table\ntable name\n@param column\ncolumn name\n@param where\nwhere clause\n@param args\nwhere arguments\n@return max or null\n@since 1.1.1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } }\n\n    ### Response:", "ground_truth": "print trace log\n@param traceId\n@param invokeContext", "predict": " Print connection trace log\n\n@param logger\nlogger\n@param traceId\ntrace id\n@param invokeContext\ninvoke context\n@since 1.1.1."}, {"ID": 448, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), threadFactory); }\n\n    ### Response: Creates a thread pool that creates new threads as needed, but\nwill reuse previously constructed threads when they are\navailable, and uses the provided\nThreadFactory to create new threads when needed.\n@param threadFactory the factory to use when creating new threads\n@return the newly created thread pool\n@throws NullPointerException if threadFactory is null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) { return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory); }\n\n    ### Response:", "ground_truth": "Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.\n\n@param nThreads\n@param threadFactory\n@return an EventLoopGroup suitable for the current platform", "predict": " Creates a new event loop group with the specified number of threads and the given thread factory.\n@param nThreads the number of threads in the event loop group\n@param threadFactory the factory to use when creating new threads\n@return the newly created event loop group\n@throws IllegalArgumentException if nThreads is less than or equal to zero\n@throws NullPointerException if threadFactory is null."}, {"ID": 449, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final public SelectionKey getKey(SocketChannel channel) { if (null == channel) { return null; } return channel.keyFor(this.selector); }\n\n    ### Response: Access the possible SelectionKey on this selector for the provided\nchannel.\n\n@param channel\n@return SelectionKey, null if not registered.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); }\n\n    ### Response:", "ground_truth": "Parse the remote address of the channel.\n\n@param channel\n@return", "predict": " Parse the remote address of the provided channel.\n\n@param channel\n@return String, parsed remote address.\n\n    "}, {"ID": 450, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final public SelectionKey getKey(SocketChannel channel) { if (null == channel) { return null; } return channel.keyFor(this.selector); }\n\n    ### Response: Access the possible SelectionKey on this selector for the provided\nchannel.\n\n@param channel\n@return SelectionKey, null if not registered.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); }\n\n    ### Response:", "ground_truth": "Parse the local address of the channel.\n\n@param channel\n@return", "predict": " Parse the local address of the provided channel.\n\n@param channel\n@return String, empty if null or not available.\n\n    "}, {"ID": 451, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String readInstrumentationKeyFromConfiguration() { try (final InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream( CONFIGURATION_FILE)) { final String configuration = IOUtils.toString(inputStream); final Matcher matcher = INSTRUMENTATION_KEY_PATTERN.matcher(configuration); if (matcher.find()) { return matcher.group(1); } else { return StringUtils.EMPTY; } } catch (IOException exception) { return StringUtils.EMPTY; } }\n\n    ### Response: Get instrumentation key from ApplicationInsights.xml.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the remote host ip of the channel.\n\n@param channel\n@return", "predict": " Get the remote IP address from the channel."}, {"ID": 452, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String readInstrumentationKeyFromConfiguration() { try (final InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream( CONFIGURATION_FILE)) { final String configuration = IOUtils.toString(inputStream); final Matcher matcher = INSTRUMENTATION_KEY_PATTERN.matcher(configuration); if (matcher.find()) { return matcher.group(1); } else { return StringUtils.EMPTY; } } catch (IOException exception) { return StringUtils.EMPTY; } }\n\n    ### Response: Get instrumentation key from ApplicationInsights.xml.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the remote hostname of the channel.\n\nNote: take care to use this method, for a reverse name lookup takes uncertain time in {@link InetAddress#getHostName}.\n\n@param channel\n@return", "predict": " Get the remote host name from the channel."}, {"ID": 453, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String readInstrumentationKeyFromConfiguration() { try (final InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream( CONFIGURATION_FILE)) { final String configuration = IOUtils.toString(inputStream); final Matcher matcher = INSTRUMENTATION_KEY_PATTERN.matcher(configuration); if (matcher.find()) { return matcher.group(1); } else { return StringUtils.EMPTY; } } catch (IOException exception) { return StringUtils.EMPTY; } }\n\n    ### Response: Get instrumentation key from ApplicationInsights.xml.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the local host ip of the channel.\n\n@param channel\n@return", "predict": " Get local IP address from Channel.\n\n    "}, {"ID": 454, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getElapsed(final String taskTitle) { final long currentTimeMillis = System.currentTimeMillis(); if (StringUtils.isBlank(taskTitle)) { return -1; } final Stopwatch root = STOPWATCH.get(); if (null == root) { return -1; } final Stopwatch stopwatch = get(root, taskTitle); if (null == stopwatch) { return -1; } if (stopwatch.isEnded()) { return stopwatch.getElapsedTime(); } return currentTimeMillis - stopwatch.getStartTime(); }\n\n    ### Response: Gets elapsed time from the specified parent stopwatch with the specified task title.\n\n@param taskTitle the specified task title\n@return \n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#getElapsedTime() elapsed time} of the found task if it\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#isEnded() is ended}\n{@linkplain System#currentTimeMillis() the current time} subtracts\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#startTime the start time} of the found task if it\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#isRunning() is running} \n{@code -1} if not found any stopwatch corresponding to the specified task title\n.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; }\n\n    ### Response:", "ground_truth": "Parse the remote host port of the channel.\n\n@param channel\n@return int", "predict": " Parses the remote port from the specified channel.\n\n@param channel the specified channel\n@return the remote port of the specified channel if it is an instance of {@linkplain java.net.InetSocketAddress InetSocketAddress}\n{@code -1} if not found any remote port"}, {"ID": 455, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getElapsed(final String taskTitle) { final long currentTimeMillis = System.currentTimeMillis(); if (StringUtils.isBlank(taskTitle)) { return -1; } final Stopwatch root = STOPWATCH.get(); if (null == root) { return -1; } final Stopwatch stopwatch = get(root, taskTitle); if (null == stopwatch) { return -1; } if (stopwatch.isEnded()) { return stopwatch.getElapsedTime(); } return currentTimeMillis - stopwatch.getStartTime(); }\n\n    ### Response: Gets elapsed time from the specified parent stopwatch with the specified task title.\n\n@param taskTitle the specified task title\n@return \n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#getElapsedTime() elapsed time} of the found task if it\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#isEnded() is ended}\n{@linkplain System#currentTimeMillis() the current time} subtracts\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#startTime the start time} of the found task if it\n{@linkplain org.b3log.latke.util.Stopwatchs.Stopwatch#isRunning() is running} \n{@code -1} if not found any stopwatch corresponding to the specified task title\n.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; }\n\n    ### Response:", "ground_truth": "Parse the local host port of the channel.\n\n@param channel\n@return int", "predict": " Parses local port from the specified channel.\n\n@param channel the specified channel\n@return local port of the specified channel if it is an instance of {@linkplain java.net.InetSocketAddress InetSocketAddress}\n{@code -1} if not found any local port"}, {"ID": 456, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getHostName(SocketAddress socketAddress) { if (socketAddress == null) { return null; } if (socketAddress instanceof InetSocketAddress) { InetAddress addr = ((InetSocketAddress) socketAddress).getAddress(); if(addr != null){ return addr.getHostAddress(); } } return null; }\n\n    ### Response: return ip to avoid lookup dns.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseSocketAddressToHostIp(SocketAddress socketAddress) { final InetSocketAddress addrs = (InetSocketAddress) socketAddress; if (addrs != null) { InetAddress addr = addrs.getAddress(); if (null != addr) { return addr.getHostAddress(); } } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the host ip of socket address.\n\ne.g. /127.0.0.1:1234 -> 127.0.0.1\n\n@param socketAddress\n@return String", "predict": " return ip to avoid lookup dns."}, {"ID": 457, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void signOff(String key, WebSocketConnection connection) { ConcurrentMap<WebSocketConnection, WebSocketConnection> connections = registry.get(key); if (null == connections) { return; } connections.remove(connection); }\n\n    ### Response: Detach a connection from a key.\n\n@param key\nthe key\n@param connection\nthe connection.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.addIfAbsent(connection); if (res) { connection.increaseRef(); } }\n\n    ### Response:", "ground_truth": "add a connection\n\n@param connection", "predict": " Add a connection to the set.\n\n@param connection\nthe connection to add.\n\n    "}, {"ID": 458, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void dispose() { final JdbcTransaction jdbcTransaction = TX.get(); if (null != jdbcTransaction && jdbcTransaction.getConnection() != null) { jdbcTransaction.dispose(); } final Connection connection = CONN.get(); if (null != connection) { try { connection.close(); } catch (final SQLException e) { throw new RuntimeException(\"Close connection failed\", e); } finally { CONN.set(null); } } }\n\n    ### Response: Disposes the resources..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } }\n\n    ### Response:", "ground_truth": "removeAndTryClose a connection\n\n@param connection", "predict": " Removes the connection from the list and tries to close it if it has no more references."}, {"ID": 459, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Connection getFrom() { final List<Connection> list = getIncomingConnections(org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE); if (list.size() == 0) { return null; } if (list.size() == 1) { return list.get(0); } if (\"true\".equals(System.getProperty(\"jbpm.enable.multi.con\"))) { return list.get(0); } else { throw new IllegalArgumentException( \"Trying to retrieve the from connection but multiple connections are present\"); } }\n\n    ### Response: Helper method for nodes that have at most one default incoming connection.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Connection get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } }\n\n    ### Response:", "ground_truth": "get a connection\n\n@return", "predict": " Helper method for nodes that have multiple incoming connections.\n\n    "}, {"ID": 460, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void register(Class type, Serializer serializer) { if (type == null) { throw new IllegalArgumentException(\"Class type information is required!\"); } if (serializer.getTypeId() <= 0) { throw new IllegalArgumentException( \"Type ID must be positive! Current: \" + serializer.getTypeId() + \", Serializer: \" + serializer); } safeRegister(type, createSerializerAdapter(serializer, this)); }\n\n    ### Response: endregion Serialization Service.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerCustomSerializer(String className, CustomSerializer serializer) { CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Register custom serializer for class name.\n\n@param className\n@param serializer\n@return", "predict": " Registers a custom serializer for the specified class. If a custom serializer has already been registered for the specified class, a RuntimeException will be thrown."}, {"ID": 461, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> safeClassForName(ClassLoader classLoader, String className) { try { if (className.startsWith(\"com.sun.\") || className.startsWith(\"com.apple.\")) { return null; } else { return Class.forName(className, true, classLoader); } } catch (ClassNotFoundException e) { return null; } catch (NoClassDefFoundError e) { return null; } }\n\n    ### Response: Get the class for the given className via the given classLoader\n\n@param classLoader classloader to be used\n@param className fully qualified class name\n@return {@code Class} instance matching the class name or null if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CustomSerializer getCustomSerializer(String className) { if (!classCustomSerializer.isEmpty()) { return classCustomSerializer.get(className); } return null; }\n\n    ### Response:", "ground_truth": "Get the custom serializer for class name.\n\n@param className\n@return", "predict": " Get the custom serializer for the given class name\n\n@param className fully qualified class name\n@return custom serializer instance for the given class name or null if not found."}, {"ID": 462, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void register(Class type, Serializer serializer) { if (type == null) { throw new IllegalArgumentException(\"Class type information is required!\"); } if (serializer.getTypeId() <= 0) { throw new IllegalArgumentException( \"Type ID must be positive! Current: \" + serializer.getTypeId() + \", Serializer: \" + serializer); } safeRegister(type, createSerializerAdapter(serializer, this)); }\n\n    ### Response: endregion Serialization Service.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) { CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Register custom serializer for command code.\n\n@param code\n@param serializer\n@return", "predict": " Registers a custom serializer for a specific command code. If a custom serializer has already been registered for the given command code, a RuntimeException will be thrown."}, {"ID": 463, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static CloudErrorType toCloudErrorType(String code) { if (\"Throttling\".equals(code)) { return CloudErrorType.THROTTLING; } else if (\"TooManyBuckets\".equals(code)) { return CloudErrorType.QUOTA; } else if (\"SignatureDoesNotMatch\".equals(code)) { return CloudErrorType.AUTHENTICATION; } else { return CloudErrorType.GENERAL; } }\n\n    ### Response: Converts AWS error code to dasein cloud error type\n\n@param code AWS error code\n@return dasein cloud error type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CustomSerializer getCustomSerializer(CommandCode code) { if (!commandCustomSerializer.isEmpty()) { return commandCustomSerializer.get(code); } return null; }\n\n    ### Response:", "ground_truth": "Get the custom serializer for command code.\n\n@param code\n@return", "predict": " Returns the custom serializer for the given command code.\n\n@param code command code\n@return custom serializer for the given command code or null if not found."}, {"ID": 464, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Future<?> scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit) { Preconditions.checkState(isOpen.get(), \"CloseableExecutorService is closed\"); ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(task, initialDelay, delay, unit); return new InternalScheduledFutureTask(scheduledFuture); }\n\n    ### Response: Creates and executes a periodic action that becomes enabled first\nafter the given initial delay, and subsequently with the\ngiven delay between the termination of one execution and the\ncommencement of the next.  If any execution of the task\nencounters an exception, subsequent executions are suppressed.\nOtherwise, the task will only terminate via cancellation or\ntermination of the executor.\n\n@param task      the task to execute\n@param initialDelay the time to delay first execution\n@param delay        the delay between the termination of one\nexecution and the commencement of the next\n@param unit         the time unit of the initialDelay and delay parameters\n@return a Future representing pending completion of\nthe task, and whose get() method will throw an\nexception upon cancellation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager.conn_monitor_initial_delay(); /** period of schedule task, unit: ms*/ long period = ConfigManager.conn_monitor_period(); this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy()); MonitorTask monitorTask = new MonitorTask(); this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS); }\n\n    ### Response:", "ground_truth": "Start schedule task", "predict": "Starts the connection monitor thread. The thread will run indefinitely, periodically checking the connection status of all registered connections. The initial delay and period are read from the configuration file. The thread is named \"ConnectionMonitorThread\" and is a daemon thread. If the thread is interrupted, it will attempt to close all registered connections and exit."}, {"ID": 465, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isConnected(String clusterName) { boolean isConnected = false; synchronized (connections) { if (connections.containsKey(clusterName)) { isConnected = connections.get(clusterName).isConnected(); } } return isConnected; }\n\n    ### Response: Return if a connection is connected.\n\n@param clusterName the connection name.\n@return true if the connection is connected. False in other case..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isConnected(String remoteAddr) { Url url = this.rpcRemoting.addressParser.parse(remoteAddr); return this.isConnected(url); }\n\n    ### Response:", "ground_truth": "check whether a client address connected\n\n@param remoteAddr\n@return", "predict": " Return if a connection is connected.\n\n@param remoteAddr the remote address.\n@return true if the connection is connected. False in other case."}, {"ID": 466, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long getAppendHighWatermark(ExtractType extractType) { LOG.debug(\"Getting append high water mark\"); if (this.isFullDump()) { LOG.info(\"Overriding high water mark with end value:\" + ConfigurationKeys.SOURCE_QUERYBASED_END_VALUE); long highWatermark = this.state.getPropAsLong(ConfigurationKeys.SOURCE_QUERYBASED_END_VALUE, 0); if (highWatermark != 0) { // User specifies SOURCE_QUERYBASED_END_VALUE hasUserSpecifiedHighWatermark = true; } return highWatermark; } return this.getAppendWatermarkCutoff(extractType); }\n\n    ### Response: Get append high water mark\n\n@param extractType Extract type\n@return append high water mark.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initWriteBufferWaterMark() { int lowWaterMark = this.netty_buffer_low_watermark(); int highWaterMark = this.netty_buffer_high_watermark(); if (lowWaterMark > highWaterMark) { throw new IllegalArgumentException( String .format( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\", highWaterMark, lowWaterMark)); } else { logger.warn( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\", lowWaterMark, highWaterMark); } this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( lowWaterMark, highWaterMark)); }\n\n    ### Response:", "ground_truth": "init netty write buffer water mark", "predict": " Initializes the write buffer water mark for the Netty channel.\n\n@param lowWaterMark The low water mark for the write buffer\n@param highWaterMark The high water mark for the write buffer\n@throws IllegalArgumentException If the high water mark is smaller than the low water mark\n@throws Exception If there is an error initializing the write buffer water mark"}, {"ID": 467, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toOpcodeName(int opcode) { switch (opcode) { case CONTINUATION: return \"CONTINUATION\"; case TEXT: return \"TEXT\"; case BINARY: return \"BINARY\"; case CLOSE: return \"CLOSE\"; case PING: return \"PING\"; case PONG: return \"PONG\"; default: break; } if (0x1 <= opcode && opcode <= 0x7) { return String.format(\"DATA(0x%X)\", opcode); } if (0x8 <= opcode && opcode <= 0xF) { return String.format(\"CONTROL(0x%X)\", opcode); } return String.format(\"0x%X\", opcode); }\n\n    ### Response: Convert a WebSocket opcode into a string representation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } }\n\n    ### Response:", "ground_truth": "Get a frame with a specific opcode\n\n@param opcode the opcode representing the frame\n@return the frame with a specific opcode", "predict": " Get a FramedataImpl1 instance based on the specified opcode.\n\n    "}, {"ID": 468, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nonnull private List<MixinMatch> getRules( CssFormatter formatter ) throws LessException { if( mixinRules != null && stackID == formatter.stackID() ) { return mixinRules; } List<Rule> rules = formatter.getMixin( name ); if( rules == null ) { rules = mixins.get( name ); } if( rules == null ) { int idx = name.indexOf( '>' ); // mixin with namespace? if( idx > 0 ) { String mainName = name.substring( 0, idx ).trim(); rules = mixins.get( mainName ); if( rules != null ) { rules = rules.get( 0 ).getMixin( name.substring( idx + 1 ).trim() ); } } else { idx = name.indexOf( '.' ); // mixin with namespace? if( idx > 0 ) { String mainName = name.substring( 0, idx ).trim(); rules = mixins.get( mainName ); if( rules != null ) { rules = rules.get( 0 ).getMixin( name.substring( idx ).trim() ); } } } if( rules == null ) { throw createException( \"Undefined mixin: \" + name ); } } stackID = formatter.stackID(); mixinRules = new ArrayList<>(); boolean paramMatch = false; List<Rule> defaultMixins = null; for( Rule rule : rules ) { MixinMatch matching = rule.match( formatter, paramValues, false ); if( matching != null ) { paramMatch = true; if( matching.getGuard() ) { mixinRules.add( matching ); } else if( matching.wasDefault() ) { if( defaultMixins == null ) { defaultMixins = new ArrayList<>(); } defaultMixins.add( rule ); } } } if( !paramMatch ) { throw createException( \"No matching definition was found for: \" + name ); } if( mixinRules.size() == 0 && defaultMixins != null ) { for( Rule rule : defaultMixins ) { MixinMatch matching = rule.match( formatter, paramValues, true ); if( matching != null && matching.getGuard() ) { mixinRules.add( matching ); } } } return mixinRules; }\n\n    ### Response: Get the rules of the mixin\n@param formatter the formatter\n@return the rules, can be empty if no condition matched but not null\n@throws LessException if no rule match the name of the mixin..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if( buffer == null ) { if( sockchannel instanceof WrappedByteChannel ) { c = (WrappedByteChannel) sockchannel; if( c.isNeedWrite() ) { c.writeMore(); } } } else { do {// FIXME writing as much as possible is unfair!! /*int written = */sockchannel.write( buffer ); if( buffer.remaining() > 0 ) { return false; } else { ws.outQueue.poll(); // Buffer finished. Remove it. buffer = ws.outQueue.peek(); } } while ( buffer != null ); } if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {// ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); }\n\n    ### Response:", "ground_truth": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "predict": " Send the data in the output queue to the socket channel.\n@param ws the WebSocketImpl\n@param sockchannel the socket channel\n@return true if all data has been sent, false otherwise\n@throws IOException if an I/O error occurs\n\n    "}, {"ID": 469, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function(name, type, filename, code) { this.name = name; this.type = type; this.filename = filename; this.code = code; }\n\n    ### Response: Represents a single System\n@param {string} name     - Name of the System\n@param {string} type     - System, RenderSystem, or BehaviorSystem\n@param {string} filename - File path\n@param {string} code     - Code generated for the System\n@constructor.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setCode(int code) { this.code = code; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = \"\"; } updatePayload(); }\n\n    ### Response:", "ground_truth": "Set the close code for this close frame\n@param code the close code", "predict": " Sets the code for the WebSocket connection.\n@param {int} code - The code to set.\n@throws {IllegalArgumentException} If the code is not a valid WebSocket close code."}, {"ID": 470, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] getContent() throws IOException { InputStream is = null; try { MessageDigest digest = MessageDigest.getInstance( \"MD5\" ); digest.reset(); byte[] buffer = new byte[8192]; int read; try { is = entry.getInputStream(); while ( ( read = is.read( buffer ) ) > 0 ) { digest.update( buffer, 0, read ); } } catch ( IOException e ) { if ( is != null ) { throw e; } } final String md5 = StringUtils.leftPad( new BigInteger( 1, digest.digest() ).toString( 16 ), 32, \"0\" ); return md5.getBytes(); } catch ( NoSuchAlgorithmException e ) { IOException ioe = new IOException( \"Unable to calculate hash\" ); ioe.initCause( e ); throw ioe; } finally { IOUtils.closeQuietly( is ); } }\n\n    ### Response: Generates the digest.\n\n@return the digest.\n@throws IOException if the backing entry could not be read.\n@since 1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position( payload.position() + 2 ); reason = Charsetfunctions.stringUtf8( payload ); } catch ( IllegalArgumentException e ) { throw new InvalidDataException( CloseFrame.NO_UTF8 ); } finally { payload.position( mark ); } }\n\n    ### Response:", "ground_truth": "Validate the payload to valid utf8\n@param mark the current mark\n@param payload the current payload\n@throws InvalidDataException the current payload is not a valid utf8", "predict": " Validates the UTF-8 encoding of the payload.\n\n@param payload the payload to validate.\n@param mark the position to reset the buffer to after validation.\n@throws InvalidDataException if the payload is not valid UTF-8.\n@since 1.0."}, {"ID": 471, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unused\") private ByteBuffer readBuffer(final RandomAccessFile raf) throws IOException { final int startPos = getCheckBytesFrom(); if (startPos > raf.length()) { return null; } raf.seek(startPos); ByteBuffer buf; switch (getType()) { case MagicMimeEntry.STRING_TYPE: { int len = 0; // Lets check if its a between test final int index = this.typeStr.indexOf(\">\"); if (index != -1) { len = Integer.parseInt(this.typeStr.substring(index + 1, this.typeStr.length() - 1)); this.isBetween = true; } else { len = getContent().length(); } buf = ByteBuffer.allocate(len + 1); raf.read(buf.array(), 0, len); break; } case MagicMimeEntry.SHORT_TYPE: case MagicMimeEntry.LESHORT_TYPE: case MagicMimeEntry.BESHORT_TYPE: { buf = ByteBuffer.allocate(2); raf.read(buf.array(), 0, 2); break; } case MagicMimeEntry.LELONG_TYPE: case MagicMimeEntry.BELONG_TYPE: { buf = ByteBuffer.allocate(4); raf.read(buf.array(), 0, 4); break; } case MagicMimeEntry.BYTE_TYPE: { buf = ByteBuffer.allocate(1); raf.read(buf.array(), 0, 1); } default: { buf = null; break; } } return buf; }\n\n    ### Response: Read buffer.\n\n@param raf the raf\n@return the byte buffer\n@throws IOException Signals that an I/O exception has occurred..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); }\n\n    ### Response:", "ground_truth": "Update the payload to represent the close code and the reason", "predict": " Update payload.\n\n@param reason the reason\n@param code the code\n\n    "}, {"ID": 472, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Expression getVariable( String name ) { for( int i = state.stackIdx - 1; i >= 0; i-- ) { Expression variable = state.stack.get( i ).getVariable( name ); if( variable != null ) { return variable; } } if( name.equals( \"@arguments\" ) ) { for( int i = state.stackIdx - 1; i >= 0; i-- ) { Scope scope = state.stack.get( i ); if( scope.parameters != null ) { Operation params = new Operation( scope.mixin, ' ' ); for( Expression expr : scope.parameters.values() ) { if( expr.getClass() == Operation.class && scope.parameters.size() == 1 ) { return expr; } params.addOperand( expr ); } return params; } } } return null; }\n\n    ### Response: Get a variable expression from the current stack\n\n@param name\nthe name of the variable starting with @\n@return the expression or null if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; }\n\n    ### Response:", "ground_truth": "Check if the requested protocol is part of this draft\n@param requestedProtocol the requested protocol\n@return MATCHED if it is matched, otherwise NOT_MATCHED", "predict": " Check if the provided protocol is supported by the known protocols\n\n@param requestedProtocol\nthe protocol provided by the client\n@return the handshake state\n\n    "}, {"ID": 473, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Location downstream( int length ) { if( length < 0 ) { throw new IllegalArgumentException( \"Parameter must be >= 0; is=\" + length ); } if( Math.signum( mEnd + length) == Math.signum( mEnd ) || 0 == Math.signum( mEnd + length ) ) { return new Location( mEnd, mEnd + length ); } else { throw new IndexOutOfBoundsException( \"Specified length causes crossing of origin: \" + length + \"; \" + toString() ); } }\n\n    ### Response: Return the adjacent location of specified length directly downstream of this location.\n\n@return The downstream location.\n@param length The length of the downstream location.\n@throws IndexOutOfBoundsException Specified length causes crossing of origin..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if( length > Integer.MAX_VALUE ) { log.trace(\"Limit exedeed: Payloadsize is to big...\"); throw new LimitExceededException(\"Payloadsize is to big...\"); } if( length > maxFrameSize) { log.trace( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize, length); throw new LimitExceededException( \"Payload limit reached.\", maxFrameSize ); } if( length < 0 ) { log.trace(\"Limit underflow: Payloadsize is to little...\"); throw new LimitExceededException(\"Payloadsize is to little...\"); } }\n\n    ### Response:", "ground_truth": "Check if the frame size exceeds the allowed limit\n@param length the current payload length\n@throws LimitExceededException if the payload length is to big", "predict": " Check if the length of the payload is within the allowed limits.\n\n@param length The length of the payload.\n@throws LimitExceededException If the length exceeds the allowed limits.\n\n    "}, {"ID": 474, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    char read() { try { if( cachePos < cache.length() ) { return incLineColumn( cache.charAt( cachePos++ ) ); } int ch = readCharBlockMarker(); if( ch == -1 ) { throw createException( \"Unexpected end of Less data\" ); } return incLineColumn( ch ); } catch( IOException ex ) { throw new LessException( ex ); } }\n\n    ### Response: Read a single character from reader or from back buffer\n\n@return a character or -1 if EOF\n@throws LessException\nIf an I/O error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } }\n\n    ### Response:", "ground_truth": "Check if the max packet size is smaller than the real packet size\n@param maxpacketsize the max packet size\n@param realpacketsize the real packet size\n@throws IncompleteException if the maxpacketsize is smaller than the realpackagesize", "predict": " Check if the packet size is less than the maximum packet size\n\n@param maxpacketsize the maximum packet size\n@param realpacketsize the actual packet size\n@throws IncompleteException if the packet size is less than the maximum packet size\n\n    "}, {"ID": 475, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String hashSHA( String str ) { byte[] b = str.getBytes(); MessageDigest md = null; try { md = MessageDigest.getInstance( \"SHA1\" ); md.update( b ); } catch ( NoSuchAlgorithmException e ) { e.printStackTrace(); // it's got to be there } return toHexString( md.digest() ); }\n\n    ### Response: Returns the SHA hash of a String.\n\n@param  str  Description of the Parameter\n@return      Description of the Return Value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String generateFinalKey( String in ) { String seckey = in.trim(); String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance( \"SHA1\" ); } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException( e ); } return Base64.encodeBytes( sh1.digest( acc.getBytes() ) ); }\n\n    ### Response:", "ground_truth": "Generate a final key from a input string\n@param in the input string\n@return a final key", "predict": " Generates the final key for a WebSocket connection.\n\n@param  in  Description of the Parameter\n@return     Description of the Return Value."}, {"ID": 476, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nonnull private List<MixinMatch> getRules( CssFormatter formatter ) throws LessException { if( mixinRules != null && stackID == formatter.stackID() ) { return mixinRules; } List<Rule> rules = formatter.getMixin( name ); if( rules == null ) { rules = mixins.get( name ); } if( rules == null ) { int idx = name.indexOf( '>' ); // mixin with namespace? if( idx > 0 ) { String mainName = name.substring( 0, idx ).trim(); rules = mixins.get( mainName ); if( rules != null ) { rules = rules.get( 0 ).getMixin( name.substring( idx + 1 ).trim() ); } } else { idx = name.indexOf( '.' ); // mixin with namespace? if( idx > 0 ) { String mainName = name.substring( 0, idx ).trim(); rules = mixins.get( mainName ); if( rules != null ) { rules = rules.get( 0 ).getMixin( name.substring( idx ).trim() ); } } } if( rules == null ) { throw createException( \"Undefined mixin: \" + name ); } } stackID = formatter.stackID(); mixinRules = new ArrayList<>(); boolean paramMatch = false; List<Rule> defaultMixins = null; for( Rule rule : rules ) { MixinMatch matching = rule.match( formatter, paramValues, false ); if( matching != null ) { paramMatch = true; if( matching.getGuard() ) { mixinRules.add( matching ); } else if( matching.wasDefault() ) { if( defaultMixins == null ) { defaultMixins = new ArrayList<>(); } defaultMixins.add( rule ); } } } if( !paramMatch ) { throw createException( \"No matching definition was found for: \" + name ); } if( mixinRules.size() == 0 && defaultMixins != null ) { for( Rule rule : defaultMixins ) { MixinMatch matching = rule.match( formatter, paramValues, true ); if( matching != null && matching.getGuard() ) { mixinRules.add( matching ); } } } return mixinRules; }\n\n    ### Response: Get the rules of the mixin\n@param formatter the formatter\n@return the rules, can be empty if no condition matched but not null\n@throws LessException if no rule match the name of the mixin..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if( curop != Opcode.CONTINUOUS ) { processFrameIsNotFin(frame); } else if( frame.isFin() ) { processFrameIsFin(webSocketImpl, frame); } else if( currentContinuousFrame == null ) { log.error( \"Protocol error: Continuous frame sequence was not started.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } //Check if the whole payload is valid utf8, when the opcode indicates a text if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) { log.error( \"Protocol error: Payload is not UTF8\" ); throw new InvalidDataException( CloseFrame.NO_UTF8 ); } //Checking if the current continuous frame contains a correct payload with the other frames combined if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) { addToBufferList(frame.getPayloadData()); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a continuous frame or the fin bit is not set\n@param webSocketImpl the websocket implementation to use\n@param frame the current frame\n@param curop the current Opcode\n@throws InvalidDataException if there is a protocol error", "predict": " Process a frame that is not a continuous frame or a continuous frame that is the last frame of the sequence.\n@param webSocketImpl the web socket implementation\n@param frame the frame to process\n@param curop the current opcode\n\n    "}, {"ID": 477, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object invoke( MethodHandle method, Object target ) { try { return method.invokeWithArguments( target ); } catch ( RuntimeException | Error e ) { throw e; } catch ( Throwable e ) { throw new RuntimeException( e ); } }\n\n    ### Response: Invoke the given method handle with the specified single argument. Handles the exceptions declared by\nMethodHandle allowing this method to be used in a context where no checked exceptions may be thrown.\n\n@param method the method handle to invoke.\n@param target the argument to pass to the method.\n@return the result of invoking the method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a binary frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Process the given binary frame.\n\n@param webSocketImpl the WebSocketImpl instance that received the frame.\n@param frame the binary frame to process.\n\n    "}, {"ID": 478, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object invoke( MethodHandle method, Object target ) { try { return method.invokeWithArguments( target ); } catch ( RuntimeException | Error e ) { throw e; } catch ( Throwable e ) { throw new RuntimeException( e ); } }\n\n    ### Response: Invoke the given method handle with the specified single argument. Handles the exceptions declared by\nMethodHandle allowing this method to be used in a context where no checked exceptions may be thrown.\n\n@param method the method handle to invoke.\n@param target the argument to pass to the method.\n@return the result of invoking the method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { log.error( \"Runtime exception during onWebsocketMessage\", e ); webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e ); }\n\n    ### Response:", "ground_truth": "Log the runtime exception to the specific WebSocketImpl\n@param webSocketImpl the implementation of the websocket\n@param e the runtime exception", "predict": " Logs a runtime exception that occurred during the processing of a WebSocket message.\n\n@param webSocketImpl the WebSocket implementation that received the message.\n@param e the runtime exception that occurred."}, {"ID": 479, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object invoke( MethodHandle method, Object target ) { try { return method.invokeWithArguments( target ); } catch ( RuntimeException | Error e ) { throw e; } catch ( Throwable e ) { throw new RuntimeException( e ); } }\n\n    ### Response: Invoke the given method handle with the specified single argument. Handles the exceptions declared by\nMethodHandle allowing this method to be used in a context where no checked exceptions may be thrown.\n\n@param method the method handle to invoke.\n@param target the argument to pass to the method.\n@return the result of invoking the method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a text frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Process the given frame data as text.\n\n@param webSocketImpl the WebSocketImpl instance that received the frame.\n@param frame the frame data to process.\n@throws InvalidDataException if the frame data is not valid text.\n\n    "}, {"ID": 480, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> loadClass(String className, ClassLoader classLoader) { Class cls = (Class) classes.get( className ); if ( cls == null ) { try { cls = Class.forName( className ); } catch ( Exception e ) { //swallow } //ConfFileFinder if ( cls == null && classLoader != null ) { try { cls = classLoader.loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassUtils.class.getClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = Thread.currentThread().getContextClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassLoader.getSystemClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls != null ) { classes.put( className, cls ); } else { throw new RuntimeException( \"Unable to load class '\" + className + \"'\" ); } } return cls; }\n\n    ### Response: This method will attempt to load the specified Class. It uses\na syncrhonized HashMap to cache the reflection Class lookup..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if( currentContinuousFrame == null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); }\n\n    ### Response:", "ground_truth": "Process the frame if it is the last frame\n@param webSocketImpl the websocket impl\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": " This method processes a received frame as part of a continuous frame sequence. It first checks if the current continuous frame sequence has been started. If not, it logs a protocol error and throws an InvalidDataException. It then adds the received frame to a buffer list and checks if the buffer limit has been reached. If so, it clears the buffer list and starts a new continuous frame sequence. If the received frame is a text frame, it sets the payload of the current continuous frame to the concatenated payloads of all the frames in the buffer list. If the received frame is a binary frame, it sets the payload of the current continuous frame to the concatenated payloads of all the frames in the buffer list. It then validates the current continuous frame and sends it to the WebSocketListener. If there is a runtime exception thrown during the onWebsocketMessage call, it logs the exception. Finally, it clears the buffer list and resets the current continuous frame to null."}, {"ID": 481, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean setFrameIndex(int frame) { if(frame < INITIAL_FRAME_POINTER || frame >= getFrameCount()) { return false; } framePointer = frame; return true; }\n\n    ### Response: Sets the frame pointer to a specific frame\n\n@return boolean true if the move was successful.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if( currentContinuousFrame != null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" ); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); }\n\n    ### Response:", "ground_truth": "Process the frame if it is not the last frame\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": " Processes a frame that is not the final frame in a continuous sequence.\n\n@param frame the frame to process\n@throws InvalidDataException if the frame is invalid or cannot be processed.\n\n    "}, {"ID": 482, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function deleteCoupon( $code, $removecode = false ) { $products = array(); if( isset( $this->_coupons[$code] ) ) { $this->_notifyListeners( 'deleteCoupon.before', $code ); $products = $this->_coupons[$code]; foreach( $products as $product ) { if( ( $key = array_search( $product, $this->_products, true ) ) !== false ) { unset( $this->_products[$key] ); } } if( $removecode === true ) { unset( $this->_coupons[$code] ); } else { $this->_coupons[$code] = array(); } $this->_modified = true; $this->_notifyListeners( 'deleteCoupon.after' ); } return $products; }\n\n    ### Response: Removes a coupon and the related product items from the basket.\n\n@param string $code Coupon code\n@param boolean $removecode If the coupon code should also be removed\n@return array List of affected product items implementing MShop_Order_Item_Base_Product_Interface\nor an empty list if no products are affected by a coupon.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = \"\"; if( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) { // complete the close handshake by disconnecting webSocketImpl.closeConnection( code, reason, true ); } else { // echo close handshake if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY ) webSocketImpl.close( code, reason, true ); else webSocketImpl.flushAndClose( code, reason, false ); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a closing frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Processes a closing frame received from the client.\n\n@param WebSocketImpl webSocketImpl The WebSocketImpl instance that received the closing frame.\n@param Framedata frame The closing frame received from the client."}, {"ID": 483, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void getSizeInfo(AlluxioURI path, List<URIStatus> statuses, boolean readable, boolean summarize, boolean addMemory) { if (summarize) { long totalSize = 0; long sizeInAlluxio = 0; long sizeInMem = 0; for (URIStatus status : statuses) { if (!status.isFolder()) { long size = status.getLength(); totalSize += size; sizeInMem += size * status.getInMemoryPercentage(); sizeInAlluxio += size * status.getInMemoryPercentage(); } } String sizeMessage = readable ? FormatUtils.getSizeFromBytes(totalSize) : String.valueOf(totalSize); String inAlluxioMessage = getFormattedValues(readable, sizeInAlluxio / 100, totalSize); String inMemMessage = addMemory ? getFormattedValues(readable, sizeInMem / 100, totalSize) : \"\"; printInfo(sizeMessage, inAlluxioMessage, inMemMessage, path.toString()); } else { for (URIStatus status : statuses) { if (!status.isFolder()) { long totalSize = status.getLength(); String sizeMessage = readable ? FormatUtils.getSizeFromBytes(totalSize) : String.valueOf(totalSize); String inAlluxioMessage = getFormattedValues(readable, status.getInAlluxioPercentage() * totalSize / 100, totalSize); String inMemMessage = addMemory ? getFormattedValues(readable, status.getInMemoryPercentage() * totalSize / 100, totalSize) : \"\"; printInfo(sizeMessage, inAlluxioMessage, inMemMessage, status.getPath()); } } } }\n\n    ### Response: Gets and prints the size information of the input path according to options.\n\n@param path the path to get size info of\n@param statuses the statuses of files and folders\n@param readable whether to print info of human readable format\n@param summarize whether to display the aggregate summary lengths\n@param addMemory whether to display the memory size and percentage information.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if( totalSize > maxFrameSize ) { clearBufferList(); log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize); throw new LimitExceededException(maxFrameSize); } }\n\n    ### Response:", "ground_truth": "Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size\n@throws LimitExceededException if the current size is bigger than the allowed size", "predict": " Checks if the total size of the byte buffer list is greater than the maximum frame size. If it is, clears the buffer list and throws a LimitExceededException.\n\n@param maxFrameSize the maximum frame size allowed\n@throws LimitExceededException if the total size of the byte buffer list is greater than the maximum frame size."}, {"ID": 484, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sendMessage(Message message) throws IOException { logger.debug(\"Sending> {}\", message); int totalSize = 0; for (Field field : message.fields) { totalSize += field.getBytes().remaining(); } ByteBuffer combined = ByteBuffer.allocate(totalSize); for (Field field : message.fields) { logger.debug(\"..sending> {}\", field); combined.put(field.getBytes()); } combined.flip(); Util.writeFully(combined, channel); }\n\n    ### Response: Sends a message to the dbserver, first assembling it into a single byte buffer so that it can be sent as\na single packet.\n\n@param message the message to be sent\n\n@throws IOException if there is a problem sending it.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate( (int) totalSize ); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put( buffer ); } } resultingByteBuffer.flip(); return resultingByteBuffer; }\n\n    ### Response:", "ground_truth": "Method to generate a full bytebuffer out of all the fragmented frame payload\n@return a bytebuffer containing all the data\n@throws LimitExceededException will be thrown when the totalSize is bigger then Integer.MAX_VALUE due to not being able to allocate more", "predict": " Retrieves the payload from a list of byte buffers, concatenating them into a single byte buffer.\n\n@return the resulting byte buffer containing the payload\n\n@throws LimitExceededException if the total size of the payload exceeds the limit."}, {"ID": 485, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getDirLogicalSize(List<FileStatus> lfs) { long totalSize = 0L; if (null == lfs) { return totalSize; } for (FileStatus fsStat : lfs) { totalSize += fsStat.getLen(); } return totalSize; }\n\n    ### Response: Get the total logical size in the directory\n@param lfs the Files under the directory\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; }\n\n    ### Response:", "ground_truth": "Get the current size of the resulting bytebuffer in the bytebuffer list\n@return the size as long (to not get an integer overflow)", "predict": " Get the total size of the ByteBuffers in the list\n@return the total size of the ByteBuffers in the list."}, {"ID": 486, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void validateReadRequest(alluxio.grpc.ReadRequest request) throws InvalidArgumentException { if (request.getBlockId() < 0) { throw new InvalidArgumentException( String.format(\"Invalid blockId (%d) in read request.\", request.getBlockId())); } if (request.getOffset() < 0 || request.getLength() <= 0) { throw new InvalidArgumentException( String.format(\"Invalid read bounds in read request %s.\", request.toString())); } }\n\n    ### Response: Validates a read request.\n\n@param request the block read request\n@throws InvalidArgumentException if the request is invalid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return clienthandshake; }\n\n    ### Response:", "ground_truth": "Checking the handshake for the role as server\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Translates a handshake request from the HTTP server to the Alluxio client.\n\n@param firstLineTokens the first line of the HTTP request\n@param line the entire HTTP request\n@return a handshake builder for the Alluxio client\n@throws InvalidHandshakeException if the request is invalid."}, {"ID": 487, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private HttpCode readStatusLine() throws IOException { // Read a line of text, which should be in the format HTTP/<version <code> <reason> String statusLine = readHeader(); String[] parts = statusLine.split(\" +\"); if (parts.length < 3) { throw new IOException(\"Badly formed response status line: \" + statusLine); } try { // Attempt to convert the return code into an enum. int code = Integer.parseInt(parts[1]); HttpCode result = HttpCode.findByCode(code); if (result == null) { throw new IOException(\"Unrecognized result code: \" + code); } return result; } catch (NumberFormatException e) { // Turn into a bad response line error. throw new IOException(\"Badly formed response status line: \" + statusLine); } }\n\n    ### Response: Read a REST response status line and return the status code from it..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] ); return handshake; }\n\n    ### Response:", "ground_truth": "Checking the handshake for the role as client\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " Translates the HTTP handshake response from the server to a HandshakeBuilder object."}, {"ID": 488, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function save_settings() { if ( isset( $_POST['geot_nonce'] ) && wp_verify_nonce( $_POST['geot_nonce'], 'geot_save_settings' ) ) { $settings = $_POST['geot_settings'] ; if ( isset( $_FILES['geot_settings_json'] ) && 'application/json' == $_FILES['geot_settings_json']['type'] ) { $file = file_get_contents( $_FILES['geot_settings_json']['tmp_name'] ); $settings = json_decode( $file, true ); } // trim fields if ( is_array( $settings ) ) { $settings = array_filter( $settings, function ( $a ) { if ( is_string( $a ) ) { return trim( $a ); } return $a; } ); } // update license field if ( ! empty( $settings['license'] ) ) { $license = esc_attr( $settings['license'] ); $this->is_valid_license( $license ); } // old settings $old_settings = geot_settings(); // checkboxes dirty hack $inputs = [ 'maxmind', 'ip2location', 'wpengine', 'kinsta', 'cache_mode', 'debug_mode', 'license', 'api_secret', 'fallback_country_ips', 'bots_country_ips', ]; if( ! isset($_GET['view']) || ( isset($_GET['view']) && 'general' == $_GET['view'] ) ){ foreach ($inputs as $input ) { if( ! isset($settings[$input]) || empty($settings[$input]) ) { $settings[$input] = ''; } } } if( isset($_GET['view']) && 'regions' == $_GET['view']){ foreach ([ 'region', 'city_region'] as $input ) { if( ! isset($settings[$input]) || empty($settings[$input]) ) { $settings[$input] = null; } } } if( ! is_array( $settings ) ) { $settings = $old_settings; } else if( is_array( $old_settings ) ) { $settings = array_merge( $old_settings, $settings ); } if( apply_filters('geot/enable_predefined_regions', true) ) { // check if any region was named already like a continent $continents = wp_list_pluck( geot_predefined_regions(), 'name' ); if( isset($settings['region']) && count($settings['region']) > 0 ) { foreach($settings['region'] as $id => $regions) { if( in_array( $regions['name'], $continents ) ) $settings['region'][$id]['name'] = $regions['name'].'-'.rand(10,99); } } } update_option( 'geot_settings', $settings ); } }\n\n    ### Response: Save the settings page\n@since 1.0.0\n@return void.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time if( socketBuffer.hasRemaining() ) { decodeFrames( socketBuffer ); } else if( tmpHandshakeBytes.hasRemaining() ) { decodeFrames( tmpHandshakeBytes ); } } } }\n\n    ### Response:", "ground_truth": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "predict": " Decode the incoming data from the socket.\n@param socketBuffer the incoming data from the socket.\n@return void."}, {"ID": 489, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void write( Object data, Map<String, Object> output, WalkedPath walkedPath ) { List<String> evaledPaths = evaluate( walkedPath ); if ( evaledPaths != null ) { traversr.set( output, evaledPaths, data ); } }\n\n    ### Response: Use the supplied WalkedPath, in the evaluation of each of our PathElements to\nbuild a concrete output path.  Then use that output path to write the given\ndata to the output.\n\n@param data data to write\n@param output data structure we are going to write the data to\n@param walkedPath reference used to lookup reference values like \"&1(2)\".\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); }\n\n    ### Response:", "ground_truth": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem", "predict": " This method is called when the server receives an invalid handshake from a client.  We generate an HTTP response with a 404 status code and write it to the output.  We also flush and close the connection with the given close code and message.\n\n@param exception the exception that caused the invalid handshake\n@throws IOException if an error occurs while writing the HTTP response or closing the connection\n\n    "}, {"ID": 490, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void hideLoadingPopup() { final Element e = RootPanel.get(\"loading\").getElement(); new Animation() { @Override protected void onUpdate( double progress ) { e.getStyle().setOpacity( 1.0 - progress ); } @Override protected void onComplete() { e.getStyle().setVisibility( Style.Visibility.HIDDEN ); } }.run( 500 ); }\n\n    ### Response: Fade out the \"Loading application\" pop-up.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeConnectionDueToInternalServerError( RuntimeException exception ) { write( generateHttpResponseDueToError( 500 ) ); flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false ); }\n\n    ### Response:", "ground_truth": "Close the connection if there was a server error by a RuntimeException\n\n@param exception the RuntimeException causing this problem", "predict": "Close the connection due to an internal server error."}, {"ID": 491, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CStorageException buildCStorageException( CResponse response, String message, CPath path ) { switch ( response.getStatus() ) { case 401: return new CAuthenticationException( message, response ); case 404: message = \"No file found at URL \" + shortenUrl( response.getUri() ) + \" (\" + message + \")\"; return new CFileNotFoundException( message, path ); default: return new CHttpException( message, response ); } }\n\n    ### Response: Some common code between providers. Handles the different status codes, and generates a nice exception\n\n@param response The wrapped HTTP response\n@param message The error message (provided by the server or by the application)\n@param path The file requested (which failed)\n@return The exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); }\n\n    ### Response:", "ground_truth": "", "predict": " Generates an HTTP response with the given error code.\n\n@param errorCode The error code to generate the response for\n@return The HTTP response as a ByteBuffer."}, {"ID": 492, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void send( String message ) { if( ! this.enabled.get()) { this.logger.finest( \"Notifications were disabled by the DM.\" ); } else if( message == null ) { this.logger.finest( \"No message to send to web socket clients.\" ); } else synchronized( SESSIONS ) { for( Session session : SESSIONS ) { try { this.logger.finest( \"Sending a message to a web socket client...\" ); session.getRemote().sendString( message ); } catch( IOException e ) { StringBuilder sb = new StringBuilder( \"A notification could not be propagated for session \" ); sb.append( session.getRemoteAddress()); sb.append( \".\" ); if( ! Utils.isEmptyOrWhitespaces( e.getMessage())) sb.append( \" \" + e.getMessage()); this.logger.severe( sb.toString()); Utils.logException( this.logger, e ); } } } }\n\n    ### Response: Sends a message to all the connected sessions.\n@param message the message to send.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); }\n\n    ### Response:", "ground_truth": "Send Text data to the other end.\n\n@throws WebsocketNotConnectedException websocket is not yet connected", "predict": " Sends the specified text to the WebSocket.\n@param text the text to send."}, {"ID": 493, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> loadClass(String className, ClassLoader classLoader) { Class cls = (Class) classes.get( className ); if ( cls == null ) { try { cls = Class.forName( className ); } catch ( Exception e ) { //swallow } //ConfFileFinder if ( cls == null && classLoader != null ) { try { cls = classLoader.loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassUtils.class.getClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = Thread.currentThread().getContextClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassLoader.getSystemClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls != null ) { classes.put( className, cls ); } else { throw new RuntimeException( \"Unable to load class '\" + className + \"'\" ); } } return cls; }\n\n    ### Response: This method will attempt to load the specified Class. It uses\na syncrhonized HashMap to cache the reflection Class lookup..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\"); } try { closeBlocking(); if( writeThread != null ) { this.writeThread.interrupt(); this.writeThread = null; } if( connectReadThread != null ) { this.connectReadThread.interrupt(); this.connectReadThread = null; } this.draft.reset(); if( this.socket != null ) { this.socket.close(); this.socket = null; } } catch ( Exception e ) { onError( e ); engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() ); return; } connectLatch = new CountDownLatch( 1 ); closeLatch = new CountDownLatch( 1 ); this.engine = new WebSocketImpl( this, this.draft ); }\n\n    ### Response:", "ground_truth": "Reset everything relevant to allow a reconnect\n@since 1.3.8", "predict": " This method resets the WebSocket instance to its initial state. It first checks if the current thread is the same as the writeThread or connectReadThread. If it is, it throws an IllegalStateException. It then attempts to close the socket, interrupt the writeThread and connectReadThread, and reset the draft. If any of these operations fail, it calls onError and closes the connection with an ABNORMAL_CLOSE code and the exception message. Finally, it creates a new WebSocketImpl instance and sets the engine field."}, {"ID": 494, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void put( Object key, URLConnection conn ) { synchronized( this ) // ensure no ConcurrentModificationException can occur. { Entry entry = new Entry( conn ); m_hardStore.put( key, entry ); if( m_thread == null ) { m_thread = new Thread( this, \"ConnectionCache-cleaner\" ); m_thread.setDaemon( true ); m_thread.start(); } } }\n\n    ### Response: Stores a URLConnection in association with a key.\n\n@param key  The key that is associated to the URLConnection.\n@param conn The URLConnection that should be stored in association with the key..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void connect() { if( connectReadThread != null ) throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" ); connectReadThread = new Thread( this ); connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() ); connectReadThread.start(); }\n\n    ### Response:", "ground_truth": "Initiates the websocket connection. This method does not block.", "predict": " Connects to the WebSocket server.\n\n@throws IllegalStateException If the WebSocketClient object is not reuseable.\n\n    "}, {"ID": 495, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProxySettings setServer(URI uri) { if (uri == null) { return this; } String scheme = uri.getScheme(); String userInfo = uri.getUserInfo(); String host = uri.getHost(); int port = uri.getPort(); return setServer(scheme, userInfo, host, port); }\n\n    ### Response: Set the proxy server by a URI. The parameters are updated as\ndescribed below.\n\n\n\nSecure\n\nIf the URI contains the scheme part and its value is\neither {@code \"http\"} or {@code \"https\"} (case-insensitive),\nthe {@code secure} parameter is updated to {@code false}\nor to {@code true} accordingly. In other cases, the parameter\nis not updated.\n\nID &amp; Password\n\nIf the URI contains the userinfo part and the ID embedded\nin the userinfo part is not an empty string, the {@code\nid} parameter and the {@code password} parameter are updated\naccordingly. In other cases, the parameters are not updated.\n\nHost\n\nThe {@code host} parameter is always updated by the given URI.\n\nPort\n\nThe {@code port} parameter is always updated by the given URI.\n\n\n\n\n@param uri\nThe URI of the proxy server. If {@code null} is given,\nnone of the parameters is updated.\n\n@return\n{@code this} object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getPort() { int port = uri.getPort(); if( port == -1 ) { String scheme = uri.getScheme(); if( \"wss\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_WSS_PORT; } else if( \"ws\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_PORT; } else { throw new IllegalArgumentException( \"unknown scheme: \" + scheme ); } } return port; }\n\n    ### Response:", "ground_truth": "Extract the specified port\n@return the specified port or the default port for the specific scheme", "predict": " Get the port number of the proxy server. If the port number is not specified in the URI, the default port number for the scheme (80 for HTTP, 443 for HTTPS, and 80 for WebSocket) is returned.\n\n\n\n@return\nThe port number of the proxy server.\n\n    "}, {"ID": 496, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void loadInfosFromSettings( ScmProviderRepositoryWithHost repo ) { if ( username == null || password == null ) { String host = repo.getHost(); int port = repo.getPort(); if ( port > 0 ) { host += \":\" + port; } Server server = this.settings.getServer( host ); if ( server != null ) { setPasswordIfNotEmpty( repo, decrypt( server.getPassword(), host ) ); setUserIfNotEmpty( repo, server.getUsername() ); } } }\n\n    ### Response: Load username password from settings..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if( part1 == null || part1.length() == 0 ) path = \"/\"; else path = part1; if( part2 != null ) path += '?' + part2; int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? \":\" + port : \"\" ); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor( path ); handshake.put( \"Host\", host ); if( headers != null ) { for( Map.Entry<String,String> kv : headers.entrySet() ) { handshake.put( kv.getKey(), kv.getValue() ); } } engine.startHandshake( handshake ); }\n\n    ### Response:", "ground_truth": "Create and send the handshake to the other endpoint\n@throws InvalidHandshakeException  a invalid handshake was created", "predict": " Send handshake to server..\n\n    "}, {"ID": 497, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clientDisconnect() { try { OutHttpApp responseStream = _responseStream; if (responseStream != null) { responseStream.close(); } } catch (Exception e) { log.log(Level.FINER, e.toString(), e); } ConnectionTcp conn = connTcp(); if (conn != null) { conn.clientDisconnect(); } killKeepalive(\"client disconnect\"); }\n\n    ### Response: Called when the client has disconnected.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setConnectionLostTimeout( int connectionLostTimeout ) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); return; } if (this.websocketRunning) { log.trace(\"Connection lost timer restarted\"); //Reset all the pings try { ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { log.error(\"Exception during connection lost restart\", e); } restartConnectionLostTimer(); } } }\n\n    ### Response:", "ground_truth": "Setter for the interval checking for lost connections\nA value lower or equal 0 results in the check to be deactivated\n\n@param connectionLostTimeout the interval in seconds\n@since 1.3.4", "predict": " Sets the connection lost timeout in seconds. If the timeout is less than or equal to zero, the connection lost timer is stopped. If the websocket is running, the connection lost timer is restarted."}, {"ID": 498, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void stopInactivityTimer() { try (Lock ignored = locker.lockIfNotHeld()) { if (sessionInactivityTimer != null) { sessionInactivityTimer.setIdleTimeout(-1); sessionInactivityTimer = null; if (log.isDebugEnabled()) { log.debug(\"Session inactivity timer stopped\"); } } } }\n\n    ### Response: Stop the session inactivity timer..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); } } }\n\n    ### Response:", "ground_truth": "Stop the connection lost timer\n@since 1.3.4", "predict": " Stop the connection lost timer."}, {"ID": 499, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized void cancel(TimerTask task) { if (task == null) { return; } task.cancel(); usageCount.decrementAndGet(); if (usageCount.get() == 0) { timer.cancel(); timer = null; } }\n\n    ### Response: Remove the specified eviction task from the timer.\n\n@param task Task to be scheduled.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } }\n\n    ### Response:", "ground_truth": "Start the connection lost timer\n@since 1.3.4", "predict": " Start the connection lost timer.\n\n@param connectionLostTimeout Connection lost timeout in seconds."}, {"ID": 500, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { for ( QueueGroups group : QueueGroups.values() ) { final DelayQueue<ActivityHolder> thisQueue = queues.get(group); service.submit ( new Runnable() { @Override public void run() { try { while ( !Thread.currentThread().isInterrupted() ) { ActivityHolder holder = thisQueue.take(); try { Boolean result = holder.activity.call(); holder.activity.completed((result != null) && result); } catch ( Throwable e ) { log.error(\"Unhandled exception in background task\", e); } } } catch ( InterruptedException dummy ) { Thread.currentThread().interrupt(); } } } ); } }\n\n    ### Response: The queue must be started.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"connectionLostChecker\")); Runnable connectionLostChecker = new Runnable() { /** * Keep the connections in a separate list to not cause deadlocks */ private ArrayList<WebSocket> connections = new ArrayList<WebSocket>( ); @Override public void run() { connections.clear(); try { connections.addAll( getConnections() ); long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 )); for( WebSocket conn : connections ) { executeConnectionLostDetection(conn, minimumPongTime); } } catch ( Exception e ) { //Ignore this exception } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); }\n\n    ### Response:", "ground_truth": "This methods allows the reset of the connection lost timer in case of a changed parameter\n@since 1.3.4", "predict": " This method is responsible for restarting the connection lost timer. It creates a new single thread executor and schedules a runnable that checks for connection lost every connectionLostTimeout nanoseconds. The runnable keeps a list of connections in a separate list to avoid deadlocks. The list is cleared after the runnable completes."}, {"ID": 501, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commit() throws PersistenceException { try { if( connection == null ) { if( dirty ) { throw new PersistenceException(\"Attempt to commit a committed or aborted transaction.\"); } return; } state = \"COMMITTING\"; try { connection.commit(); state = \"CLOSING CONNECTIONS\"; connection.close(); connection = null; if (logger.isDebugEnabled()) { logger.debug(connectionCloseLog()); } if (tracking) { connections.decrementAndGet(); } close(); } catch( SQLException e ) { throw new PersistenceException(e.getMessage()); } finally { if( connection != null ) { logger.warn(\"Commit failed: \" + transactionId); rollback(); } dirty = true; } } finally { } }\n\n    ### Response: Commits the transaction to the database and closes the transaction.\nThe transaction should not be used or referenced after calling\nthis method.\n@throws org.dasein.persist.PersistenceException either you are trying\nto commit to a used up transaction or a database error occurred\nduring the commit.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if( webSocketImpl.getLastPong() < minimumPongTime ) { log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl); webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ); } else { if( webSocketImpl.isOpen() ) { webSocketImpl.sendPing(); } else { log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl); } } }\n\n    ### Response:", "ground_truth": "Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping\n@param webSocket the websocket instance\n@param minimumPongTime the lowest/oldest allowable last pong time (in nanoTime) before we consider the connection to be lost", "predict": "Detects if a WebSocket connection has been lost and closes it if necessary.\n@param webSocket the WebSocket connection to check\n@param minimumPongTime the minimum time in milliseconds that must have passed since the last pong to consider the connection lost\n@see org.java_websocket.WebSocket#getLastPong()\n@see org.java_websocket.WebSocket#closeConnection(int, String)"}, {"ID": 502, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void remove( Token token ) { if( token == first ) { first = first.next; } if( token == last ) { last = last.previous; } if( token.next != null ) { token.next.previous = token.previous; } if( token.previous != null ) { token.previous.next = token.next; } token.next = token.previous = null; size--; }\n\n    ### Response: Removes the token from the list\n@param token Token which is to be removed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cancelConnectionLostTimer() { if( connectionLostCheckerService != null ) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } }\n\n    ### Response:", "ground_truth": "Cancel any running timer for the connection lost detection\n@since 1.3.4", "predict": " Cancels the connection lost timer\n@throws InterruptedException If the thread is interrupted while waiting for the timer to cancel."}, {"ID": 503, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<OWLEntity> getChangeSignature() { Set<OWLEntity> result = new HashSet<OWLEntity>(); final OWLOntologyChangeDataVisitor<Set<OWLEntity>, RuntimeException> visitor = new OWLOntologyChangeDataVisitor<Set<OWLEntity>, RuntimeException>() { @Override public Set<OWLEntity> visit(AddAxiomData data) throws RuntimeException { return data.getAxiom().getSignature(); } @Override public Set<OWLEntity> visit(RemoveAxiomData data) throws RuntimeException { return data.getAxiom().getSignature(); } @Override public Set<OWLEntity> visit(AddOntologyAnnotationData data) throws RuntimeException { return data.getAnnotation().getSignature(); } @Override public Set<OWLEntity> visit(RemoveOntologyAnnotationData data) throws RuntimeException { return data.getAnnotation().getSignature(); } @Override public Set<OWLEntity> visit(SetOntologyIDData data) throws RuntimeException { return Collections.emptySet(); } @Override public Set<OWLEntity> visit(AddImportData data) throws RuntimeException { return Collections.emptySet(); } @Override public Set<OWLEntity> visit(RemoveImportData data) throws RuntimeException { return Collections.emptySet(); } }; for(OWLOntologyChangeRecord record : changeRecords) { result.addAll(record.getData().accept(visitor)); } return result; }\n\n    ### Response: Gets the signature in the set of change records in this list.\n@return The signature..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); }\n\n    ### Response:", "ground_truth": "This default implementation does not do anything. Go ahead and overwrite it.\n\n@see org.java_websocket.WebSocketListener#onWebsocketHandshakeReceivedAsServer(WebSocket, Draft, ClientHandshake)", "predict": "This method is called when the server receives a WebSocket handshake request from a client. It returns a ServerHandshakeBuilder that will be used to build the response to the handshake request. The default implementation returns a HandshakeImpl1Server object, which is an implementation of the ServerHandshakeBuilder interface."}, {"ID": 504, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeConnection( Connection conn, Logger logger ) { try { if( conn != null ) conn.close(); } catch( SQLException e ) { // Not important. Utils.logException( logger, e ); } }\n\n    ### Response: Closes a connection to a database.\n@param conn\n@param logger.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void onWebsocketPing( WebSocket conn, Framedata f ) { conn.sendFrame( new PongFrame( (PingFrame)f ) ); }\n\n    ### Response:", "ground_truth": "This default implementation will send a pong in response to the received ping.\nThe pong frame will have the same payload as the ping frame.\n\n@see org.java_websocket.WebSocketListener#onWebsocketPing(WebSocket, Framedata)", "predict": "Handles a ping frame from the client.\n@param conn\n@param f."}, {"ID": 505, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean checkEdgeCount( SquareGrid grid ) { int left = 0, right = grid.columns-1; int top = 0, bottom = grid.rows-1; for (int row = 0; row < grid.rows; row++) { boolean skip = grid.get(row,0) == null; for (int col = 0; col < grid.columns; col++) { SquareNode n = grid.get(row,col); if( skip ) { if ( n != null ) return false; } else { boolean horizontalEdge = col == left || col == right; boolean verticalEdge = row == top || row == bottom; boolean outer = horizontalEdge || verticalEdge; int connections = n.getNumberOfConnections(); if( outer ) { if( horizontalEdge && verticalEdge ) { if( connections != 1 ) return false; } else if( connections != 2 ) return false; } else { if( connections != 4 ) return false; } } skip = !skip; } } return true; }\n\n    ### Response: Looks at the edge count in each node and sees if it has the expected number.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop( int timeout ) throws InterruptedException { if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections return; } List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList<WebSocket>( connections ); } for( WebSocket ws : socketsToClose ) { ws.close( CloseFrame.GOING_AWAY ); } wsf.close(); synchronized ( this ) { if( selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join( timeout ); } } }\n\n    ### Response:", "ground_truth": "Closes all connected clients sockets, then closes the underlying\nServerSocketChannel, effectively killing the server socket selectorthread,\nfreeing the port the server was bound to and stops all internal workerthreads.\n\nIf this method is called before the server is started it will never start.\n\n@param timeout\nSpecifies how many milliseconds the overall close handshaking may take altogether before the connections are closed without proper close handshaking.\n\n@throws InterruptedException Interrupt", "predict": " This method stops the WebSocket server and closes all the connections. It first sets the closed flag to true to prevent any further connections from being added to the connections list. It then copies the connections in a list to prevent any potential deadlocks. Finally, it closes all the connections, closes the server socket, and waits for the selector thread to terminate within the specified timeout."}, {"ID": 506, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getPort() { if (port != null && port != 0) { return port; } return urlParser != null ? urlParser.getHostAddresses().get(0).port : 3306; }\n\n    ### Response: Returns the port number.\n\n@return the port number.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getPort() { int port = getAddress().getPort(); if( port == 0 && server != null ) { port = server.socket().getLocalPort(); } return port; }\n\n    ### Response:", "ground_truth": "Gets the port number that this server listens on.\n\n@return The port number.", "predict": " Returns the port number.\n\n@return the port number.\n\n    "}, {"ID": 507, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] getContent() throws IOException { InputStream is = null; try { MessageDigest digest = MessageDigest.getInstance( \"MD5\" ); digest.reset(); byte[] buffer = new byte[8192]; int read; try { is = entry.getInputStream(); while ( ( read = is.read( buffer ) ) > 0 ) { digest.update( buffer, 0, read ); } } catch ( IOException e ) { if ( is != null ) { throw e; } } final String md5 = StringUtils.leftPad( new BigInteger( 1, digest.digest() ).toString( 16 ), 32, \"0\" ); return md5.getBytes(); } catch ( NoSuchAlgorithmException e ) { IOException ioe = new IOException( \"Unable to calculate hash\" ); ioe.initCause( e ); throw ioe; } finally { IOUtils.closeQuietly( is ); } }\n\n    ### Response: Generates the digest.\n\n@return the digest.\n@throws IOException if the backing entry could not be read.\n@since 1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while ( !iqueue.isEmpty() ) { conn = iqueue.remove( 0 ); WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() ); ByteBuffer buf = takeBuffer(); try { if( SocketChannelIOHelper.readMore( buf, conn, c ) ) iqueue.add( conn ); if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } } }\n\n    ### Response:", "ground_truth": "Do an additional read\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " Pushes the buffer back to the queue.\n\n@param buf the buffer to push back to the queue.\n@throws InterruptedException if the thread is interrupted while waiting to push the buffer back to the queue.\n@throws IOException if an I/O error occurs while pushing the buffer back to the queue."}, {"ID": 508, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void setWidget( Widget w ) { // Validate if( w == widget ) return; // Detach new child. if( w != null ) w.removeFromParent(); // Remove old child. if( widget != null ) remove( widget ); // Logical attach. widget = w; if( w != null ) { // Physical attach. DOM.appendChild( containerElement, widget.getElement() ); adopt( w ); } }\n\n    ### Response: Sets this panel's widget. Any existing child widget will be removed.\n\n@param w\nthe panel's new widget, or null to clear the\npanel.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if( !onConnect( key ) ) { key.cancel(); return; } SocketChannel channel = server.accept(); if(channel==null){ return; } channel.configureBlocking( false ); Socket socket = channel.socket(); socket.setTcpNoDelay( isTcpNoDelay() ); socket.setKeepAlive( true ); WebSocketImpl w = wsf.createWebSocket( this, drafts ); w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w )); try { w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() )); i.remove(); allocateBuffers( w ); } catch (IOException ex) { if( w.getSelectionKey() != null ) w.getSelectionKey().cancel(); handleIOException( w.getSelectionKey(), null, ex ); } }\n\n    ### Response:", "ground_truth": "Execute a accept operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@throws InterruptedException  thrown by taking a buffer\n@throws IOException if an error happened during accept", "predict": " Accepts a new connection and creates a new WebSocket instance for it.\n\n@param key\nthe selection key for the new connection\n@param i\nan iterator over the selection keys\n@throws IOException\nif an I/O error occurs\n@throws InterruptedException\nif the thread is interrupted while waiting for a new connection\n\n    "}, {"ID": 509, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream prepareInputStream( final URL url, final boolean acceptAnyCertificate ) throws IOException { final URLConnection conn = url.openConnection(); prepareForAuthentication( conn ); prepareHttpHeaders( conn ); if( acceptAnyCertificate ) { prepareForSSL( conn ); } return conn.getInputStream(); }\n\n    ### Response: Prepare url for authentication and ssl if necessary and returns the input stream from the url.\n\n@param url                  url to prepare\n@param acceptAnyCertificate true if the certicate check should be skipped\n\n@return input stream from url\n\n@throws IOException re-thrown.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if(conn.getChannel() == null){ key.cancel(); handleIOException( key, conn, new IOException() ); return false; } try { if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) { if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); i.remove(); if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) { iqueue.add( conn ); } } else { pushBuffer(buf); } } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } return true; }\n\n    ### Response:", "ground_truth": "Execute a read operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@return true, if the read was successful, or false if there was an error\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " Reads data from the channel associated with the given key and puts it into the input queue of the WebSocket connection.\n\n@param key selection key associated with the channel to read from\n@param i   iterator over the selection keys\n\n@return true if there is more data to read, false otherwise\n\n@throws InterruptedException if the thread is interrupted while waiting for data\n@throws IOException          if an I/O error occurs while reading from the channel"}, {"ID": 510, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private KieServerHttpRequest closeOutput() throws IOException { if( connection == null ) { throw new KieServerHttpRequestException(\"Please execute a HTTP method first on the request.\"); } if( output == null ) { return this; } if( ignoreCloseExceptions ) { try { output.close(); } catch( IOException ignored ) { // Ignored } } else { output.close(); } output = null; return this; }\n\n    ### Response: Close output stream\n\n@return this request\n@throws KieServerHttpRequestException\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doWrite(SelectionKey key) throws IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) { if( key.isValid() ) { key.interestOps(SelectionKey.OP_READ); } } }\n\n    ### Response:", "ground_truth": "Execute a write operation\n@param key the selectionkey to write on\n@throws IOException if an error happened during batch", "predict": " Write to the socket channel\n\n@param key the selection key\n@throws IOException if an I/O error occurs"}, {"ID": 511, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function cleanDir( path ) { var files = FS.readdirSync( path ); try { files.forEach( function ( file ) { var fullpath = Path.join( path, file ); if ( !FS.existsSync( fullpath ) ) return; var stat = FS.statSync( fullpath ); try { if ( stat.isDirectory() ) PathUtils.rmdir( fullpath ); else FS.unlinkSync( fullpath ); } catch ( ex ) { console.error( \"Unable to delete `\" + fullpath + \"`!\" ); console.error( ex ); } } ); } catch ( ex ) { fatal( \"Fatal error in function `files`!\\n\" + JSON.stringify( ex, null, ' ' ) ); } }\n\n    ### Response: Remove all the files and folder in `path`, but not `path` itself..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doSetupSelectorAndServerThread() { selectorthread.setName( \"WebSocketSelector-\" + selectorthread.getId() ); try { server = ServerSocketChannel.open(); server.configureBlocking( false ); ServerSocket socket = server.socket(); socket.setReceiveBufferSize( WebSocketImpl.RCVBUF ); socket.setReuseAddress( isReuseAddr() ); socket.bind( address ); selector = Selector.open(); server.register( selector, server.validOps() ); startConnectionLostTimer(); for( WebSocketWorker ex : decoders ){ ex.start(); } onStart(); } catch ( IOException ex ) { handleFatal( null, ex ); return false; } return true; }\n\n    ### Response:", "ground_truth": "Setup the selector thread as well as basic server settings\n@return true, if everything was successful, false if some error happened", "predict": " Set up the selector and server thread for WebSocket connections.\n\n    "}, {"ID": 512, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized boolean hasNext() { while( nexting ) { if( logger.isInfoEnabled() ) { logger.info(\"[\" + this + \"] Waiting for another thread to pull item...\"); } try { wait(150L); } catch( InterruptedException e ) { /* ignore */ } } if( loadException != null ) { throw new JiteratorLoadException(loadException); } nexting = true; try { if( waiting == null ) { return false; } if( !waiting.isEmpty() ) { return true; } waitForPush(); if( loadException != null ) { throw new JiteratorLoadException(loadException); } return (waiting != null && !waiting.isEmpty()); } finally { nexting = false; notifyAll(); } }\n\n    ### Response: Checks to see if there are more elements to be processed in the jiterator. If this method\nis called prior to the jiterator being loaded with an item, it will hang until\neither an item is added into the jiterator or the jiterator is marked as complete.\n@return true if there are more elements to be processed\n@throws JiteratorLoadException an error occurred during the load of the jiterator.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doEnsureSingleThread() { synchronized ( this ) { if( selectorthread != null ) throw new IllegalStateException( getClass().getName() + \" can only be started once.\" ); selectorthread = Thread.currentThread(); if( isclosed.get() ) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "The websocket server can only be started once\n@return true, if the server can be started, false if already a thread is running", "predict": "Ensures that the jiterator can only be started once.\n@return true if the jiterator can be started, false if it has already been started.\n@throws IllegalStateException if the jiterator has already been started."}, {"ID": 513, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> loadClass(String className, ClassLoader classLoader) { Class cls = (Class) classes.get( className ); if ( cls == null ) { try { cls = Class.forName( className ); } catch ( Exception e ) { //swallow } //ConfFileFinder if ( cls == null && classLoader != null ) { try { cls = classLoader.loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassUtils.class.getClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = Thread.currentThread().getContextClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassLoader.getSystemClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls != null ) { classes.put( className, cls ); } else { throw new RuntimeException( \"Unable to load class '\" + className + \"'\" ); } } return cls; }\n\n    ### Response: This method will attempt to load the specified Class. It uses\na syncrhonized HashMap to cache the reflection Class lookup..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doServerShutdown() { stopConnectionLostTimer(); if( decoders != null ) { for( WebSocketWorker w : decoders ) { w.interrupt(); } } if( selector != null ) { try { selector.close(); } catch ( IOException e ) { log.error( \"IOException during selector.close\", e ); onError( null, e ); } } if( server != null ) { try { server.close(); } catch ( IOException e ) { log.error( \"IOException during server.close\", e ); onError( null, e ); } } }\n\n    ### Response:", "ground_truth": "Clean up everything after a shutdown", "predict": " This method will attempt to close the WebSocket server. It will stop the connection lost timer, interrupt any WebSocketWorker threads, close the selector and server sockets.\n\n    "}, {"ID": 514, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Connection createConnection() { if (mConnInfo != null) { DBConnCreator dbConnCreator = new DBConnCreator(mConnInfo); Connection conn = dbConnCreator.createDBConnection(); return conn; } else if (mDbcpPropertyFile != null) { Properties properties = new Properties(); InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(mDbcpPropertyFile); try { properties.load(is); DataSource ds; ds = BasicDataSourceFactory.createDataSource(properties); Connection conn = ds.getConnection(); return conn; } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } return null; }\n\n    ### Response: Get the DB connection\n\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Socket getSocket( WebSocket conn ) { WebSocketImpl impl = (WebSocketImpl) conn; return ( (SocketChannel) impl.getSelectionKey().channel() ).socket(); }\n\n    ### Response:", "ground_truth": "Getter to return the socket used by this specific connection\n@param conn The specific connection\n@return The socket used by this connection", "predict": " Get the socket for the WebSocket connection\n\n@return."}, {"ID": 515, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unbind() { if (itemView == null || controller == null) { return; } if (data != null) { this.controller.unmountView(data, itemView); } }\n\n    ### Response: unbind the data, make the view re-usable.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); }\n\n    ### Response:", "ground_truth": "Send a byte array to a specific collection of websocket connections\n@param data the data to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Broadcast the data to the specified clients."}, {"ID": 516, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeEncodedWord(String text, Usage usage, int usedCharacters, Charset charset, Encoding encoding) { if (text == null) throw new IllegalArgumentException(); if (usedCharacters < 0 || usedCharacters > MAX_USED_CHARACTERS) throw new IllegalArgumentException(); if (charset == null) charset = determineCharset(text); String mimeCharset = charset.name(); // no canonical names needed if (mimeCharset == null) { // cannot happen if charset was originally null throw new IllegalArgumentException(\"Unsupported charset\"); } byte[] bytes = encode(text, charset); if (encoding == null) encoding = determineEncoding(bytes, usage); if (encoding == Encoding.B) { String prefix = ENC_WORD_PREFIX + mimeCharset + \"?B?\"; return encodeB(prefix, text, usedCharacters, charset, bytes); } else { String prefix = ENC_WORD_PREFIX + mimeCharset + \"?Q?\"; return encodeQ(prefix, text, usage, usedCharacters, charset, bytes); } }\n\n    ### Response: Encodes the specified text into an encoded word or a sequence of encoded\nwords separated by space. The text is separated into a sequence of encoded\nwords if it does not fit in a single one.\n\n@param text\ntext to encode.\n@param usage\nwhether the encoded-word is to be used to replace a text token or\na word entity (see RFC 822).\n@param usedCharacters\nnumber of characters already used up (\n0 ).\n@param charset\nthe Java charset that should be used to encode the specified\nstring into a byte array. A suitable charset is detected\nautomatically if this parameter is null.\n@param encoding\nthe encoding to use for the encoded-word (either B or Q). A\nsuitable encoding is automatically chosen if this parameter is\nnull.\n@return the encoded word (or sequence of encoded words if the given text\ndoes not fit in a single encoded word).\n@see #hasToBeEncoded(String, int).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); }\n\n    ### Response:", "ground_truth": "Send a text to a specific collection of websocket connections\n@param text the text to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Broadcasts the specified text to the specified collection of WebSocket clients.\n\n@param text\nthe text to broadcast.\n@param clients\nthe collection of WebSocket clients to broadcast the text to.\n@throws IllegalArgumentException\nif the text or the collection of clients is null."}, {"ID": 517, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> loadClass(String className, ClassLoader classLoader) { Class cls = (Class) classes.get( className ); if ( cls == null ) { try { cls = Class.forName( className ); } catch ( Exception e ) { //swallow } //ConfFileFinder if ( cls == null && classLoader != null ) { try { cls = classLoader.loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassUtils.class.getClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = Thread.currentThread().getContextClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls == null ) { try { cls = ClassLoader.getSystemClassLoader().loadClass( className ); } catch ( Exception e ) { //swallow } } if ( cls != null ) { classes.put( className, cls ); } else { throw new RuntimeException( \"Unable to load class '\" + className + \"'\" ); } } return cls; }\n\n    ### Response: This method will attempt to load the specified Class. It uses\na syncrhonized HashMap to cache the reflection Class lookup..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doBroadcast(Object data, Collection<WebSocket> clients) { String sData = null; if (data instanceof String) { sData = (String)data; } ByteBuffer bData = null; if (data instanceof ByteBuffer) { bData = (ByteBuffer)data; } if (sData == null && bData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>(); for( WebSocket client : clients ) { if( client != null ) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, sData, bData); try { client.sendFrame( draftFrames.get( draft ) ); } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } }\n\n    ### Response:", "ground_truth": "Private method to cache all the frames to improve memory footprint and conversion time\n@param data the data to broadcast\n@param clients the clients to send the message to", "predict": " This method will broadcast the specified data to the specified clients. It first checks if the data is a String or a ByteBuffer. If it is a String, it converts it to a ByteBuffer using the default charset. It then creates a Map to store the frames for each client based on their draft. It then loops through the clients and fills the frames for each client based on their draft and the data. Finally, it sends the frames to each client using their sendFrame method. If a client is not connected, it ignores the exception and continues with the next client."}, {"ID": 518, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MediaFrame readFrame() throws JavaAVException { MediaFrame mediaFrame = new MediaFrame(); while (mediaFrame != null && !mediaFrame.hasFrame()) { if (av_read_frame(formatContext, avPacket) < 0) { if (videoDecoders.get(avPacket.stream_index()) != null) { // video codec may have buffered some frames avPacket.data(null); avPacket.size(0); } else { return null; } } MediaPacket mediaPacket = new MediaPacket(avPacket); Decoder decoder; if ((decoder = videoDecoders.get(avPacket.stream_index())) != null) { mediaFrame = decoder.decodeVideo(mediaPacket); } else if ((decoder = audioDecoders.get(avPacket.stream_index())) != null) { mediaFrame = decoder.decodeAudio(mediaPacket); } av_free_packet(avPacket); mediaPacket.clear(); } return mediaFrame; }\n\n    ### Response: Consecutively retrieves media frames from previously specified input source.\nThe media type of the returned frame may alter between consecutive calls. One\ncall may return an audio frame and the next call may return a video frame.\n\n@return a media frame of audio or video ready to play.\n\n@throws JavaAVException if media frame could not be retrieved..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { if( !draftFrames.containsKey( draft ) ) { List<Framedata> frames = null; if (sData != null) { frames = draft.createFrames( sData, false ); } if (bData != null) { frames = draft.createFrames( bData, false ); } if (frames != null) { draftFrames.put(draft, frames); } } }\n\n    ### Response:", "ground_truth": "Fills the draftFrames with new data for the broadcast\n@param draft The draft to use\n@param draftFrames The list of frames per draft to fill\n@param sData the string data, can be null\n@param bData the bytebuffer data, can be null", "predict": "Populates the draftFrames map with the frames of the specified draft.\n\n@param draft the draft for which to create frames.\n@param draftFrames the map to populate with the frames.\n@param sData the string data to create frames from.\n@param bData the byte buffer data to create frames from."}, {"ID": 519, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Key<byte[]> start( final PGPPrivateKey key, int algorithm ) { BcPGPContentSignerBuilder contentSignerBuilder = new BcPGPContentSignerBuilder( algorithm, SHA1 ); final PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator( contentSignerBuilder ); try { signatureGenerator.init( BINARY_DOCUMENT, key ); } catch ( PGPException e ) { throw new RuntimeException( \"Could not initialize PGP signature generator\", e ); } final Key<byte[]> object = new Key<byte[]>(); consumers.put( object, new Consumer<byte[]>() { public void consume( final ByteBuffer buffer ) { if ( !buffer.hasRemaining() ) { return; } try { write( buffer ); } catch ( SignatureException e ) { throw new RuntimeException( \"Could not write buffer to PGP signature generator.\", e ); } } private void write( ByteBuffer buffer ) throws SignatureException { if ( buffer.hasArray() ) { byte[] bufferBytes = buffer.array(); int offset = buffer.arrayOffset(); int position = buffer.position(); int limit = buffer.limit(); signatureGenerator.update( bufferBytes, offset + position, limit - position ); buffer.position( limit ); } else { int length = buffer.remaining(); byte[] bytes = new byte[Util.getTempArraySize( length )]; while ( length > 0 ) { int chunk = Math.min( length, bytes.length ); buffer.get( bytes, 0, chunk ); signatureGenerator.update( bytes, 0, chunk ); length -= chunk; } } } public byte[] finish() { try { return signatureGenerator.generate().getEncoded(); } catch ( Exception e ) { throw new RuntimeException( \"Could not generate signature.\", e ); } } }); return object; }\n\n    ### Response: Initialize a PGP signatue on the channel\n\n@param key       the private key to use in signing this data stream.\n@param algorithm the algorithm to use. Can be extracted from public key.\n@return reference to the new key added to the consumers.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } }\n\n    ### Response:", "ground_truth": "Transfer from one ByteBuffer to another ByteBuffer\n\n@param source the ByteBuffer to copy from\n@param dest   the ByteBuffer to copy to\n@return the number of transferred bytes", "predict": " Transfer the contents of one ByteBuffer to another.\n\n@param source the source ByteBuffer to transfer from.\n@param dest   the destination ByteBuffer to transfer to.\n@return the number of bytes transferred."}, {"ID": 520, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GrpcServer start() throws IOException { RetryUtils.retry(\"Starting gRPC server\", () -> mServer.start(), new ExponentialBackoffRetry(100, 500, 5)); mStarted = true; return this; }\n\n    ### Response: Start serving.\n\n@return this instance of {@link GrpcServer}\n@throws IOException when unable to start serving.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JPAApi start() { jpaConfig .persistenceUnits() .forEach( persistenceUnit -> emfs.put( persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName))); return this; }\n\n    ### Response:", "ground_truth": "Initialise JPA entity manager factories.", "predict": " Start the JPA API.\n\n@return this instance of {@link JPAApi}\n\n    "}, {"ID": 521, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected EntityManagerFactory getEntityManagerFactory(OpenEntityManager openEntityManager) { final CacheKey key = this.createEntityManagerFactoryKey(openEntityManager); EntityManagerFactory emf = this.entityManagerFactories.get(key); if (emf == null) { emf = this.lookupEntityManagerFactory(openEntityManager); this.entityManagerFactories.put(key, emf); } return emf; }\n\n    ### Response: Get the EntityManagerFactory that this filter should use.\n\n@return the EntityManagerFactory to use\n@see #lookupEntityManagerFactory(OpenEntityManager).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EntityManager em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return emf.createEntityManager(); }\n\n    ### Response:", "ground_truth": "Get a newly created EntityManager for the specified persistence unit name.\n\n@param name The persistence unit name", "predict": " Get the EntityManager for the given persistence unit name.\n\n@param name the name of the persistence unit\n@return the EntityManager for the given persistence unit name, or null if none exists\n@see #emfs"}, {"ID": 522, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeServerFromCache(long serverId) { servers.computeIfPresent(serverId, (key, server) -> { ((Cleanupable) server).cleanup(); return null; }); nonReadyServers.computeIfPresent(serverId, (key, server) -> { ((Cleanupable) server).cleanup(); return null; }); }\n\n    ### Response: Removes the given server from the cache.\n\n@param serverId The id of the server to remove..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void withTransaction(Consumer<EntityManager> block) { withTransaction( em -> { block.accept(em); return null; }); }\n\n    ### Response:", "ground_truth": "Run a block of code with a newly created EntityManager for the default Persistence Unit.\n\n@param block Block of code to execute", "predict": " Executes the given block of code within a transaction.\n\n@param block The code to execute within the transaction. The code should accept an EntityManager as its parameter and return a value."}, {"ID": 523, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean and(EvaluationContext ctx, Object... args) { for (Object arg : args) { if (!Conversions.toBoolean(arg, ctx)) { return false; } } return true; }\n\n    ### Response: Returns TRUE if and only if all its arguments evaluate to TRUE.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Seq<Object> convertArgsToScalaBuffer(final Object... args) { return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args)) .asScala() .toList(); }\n\n    ### Response:", "ground_truth": "Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate list\nif necessary\n\n@param args the message arguments\n@return scala type for message processing", "predict": " Converts an array of objects to a Scala Seq of objects.\n\n    "}, {"ID": 524, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> getUnique(Collection<T> collection) { HashSet<T> set = new HashSet<>(); List<T> out = new ArrayList<>(); for (T t : collection) { if (!set.contains(t)) { out.add(t); set.add(t); } } return out; }\n\n    ### Response: Returns a list containing only unique values in a collection.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; }\n\n    ### Response:", "ground_truth": "Wraps arguments passed into a list if necessary.\n\nReturns the first value as is if it is the only argument and a subtype of `java.util.List`\nOtherwise, it calls Arrays.asList on args\n\n@param args arguments as a List", "predict": " Wraps the input arguments into a list if they are not already a list.\n\n    "}, {"ID": 525, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Transformer(requireTemplate = true) public static String i18n(Object key, Object... args) { return i18n(null, key, args); }\n\n    ### Response: Transformer method. Return i18n message of a given key and args.\n\n@param key\n@param args\n@return the i18n message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(play.api.i18n.Lang lang, String key, Object... args) { Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(key, scalaArgs, lang); }\n\n    ### Response:", "ground_truth": "Translates a message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get method. Return the i18n message of a given key and args for a given language.\n\n@param lang\n@param key\n@param args\n@return the i18n message."}, {"ID": 526, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String determineLanguage(FacesContext fc, DataTable dataTable) { final List<String> availableLanguages = Arrays.asList(\"de\", \"en\", \"es\", \"fr\", \"hu\", \"it\", \"nl\", \"pl\", \"pt\", \"ru\"); if (BsfUtils.isStringValued(dataTable.getCustomLangUrl())) { return dataTable.getCustomLangUrl(); } else if (BsfUtils.isStringValued(dataTable.getLang())) { String lang = dataTable.getLang(); if (availableLanguages.contains(lang)) { return determineLanguageUrl(fc, lang); } } else { String lang = fc.getViewRoot().getLocale().getLanguage(); if (availableLanguages.contains(lang)) { return determineLanguageUrl(fc, lang); } } return null; }\n\n    ### Response: Determine if the user specify a lang Otherwise return null to avoid language\nsettings.\n\n@param fc\n@param dataTable\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) { Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala(); Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(keyArgs.toSeq(), scalaArgs, lang); }\n\n    ### Response:", "ground_truth": "Translates the first defined message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get the message for the specified language and keys.\n\n@param lang\n@param keys\n@param args\n@return.\n\n    "}, {"ID": 527, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties setTokenizeProperties(final String lang, final String normalize, final String untokenizable, final String hardParagraph) { final Properties annotateProperties = new Properties(); annotateProperties.setProperty(\"language\", lang); annotateProperties.setProperty(\"normalize\", normalize); annotateProperties.setProperty(\"untokenizable\", untokenizable); annotateProperties.setProperty(\"hardParagraph\", hardParagraph); return annotateProperties; }\n\n    ### Response: Creates the Properties object required to construct a Sentence Segmenter\nand a Tokenizer.\n\n@param lang\nit is required to provide a language code\n@param normalize\nthe normalization option\n@param untokenizable\nprint untokenizable tokens\n@param hardParagraph\ndo not segment paragraph marks\n@return the properties object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); }\n\n    ### Response:", "ground_truth": "Check if a message key is defined.\n\n@param lang the message lang\n@param key the message key\n@return a Boolean", "predict": " Checks if a message is defined for a given language and key.\n\n@param lang\nthe language for which the message is defined\n@param key\nthe message key\n@return true if the message is defined, false otherwise."}, {"ID": 528, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Message peek() throws IOException { Messages msgs = peek(1); Message msg; try { msg = msgs.getMessage(0); } catch (IndexOutOfBoundsException e) { throw new EmptyQueueException(); } return msg; }\n\n    ### Response: Peeking at a queue returns the next messages on the queue, but it does not reserve them.\nIf there are no items on the queue, an EmptyQueueException is thrown.\n\n@throws io.iron.ironmq.EmptyQueueException If the queue is empty.\n@throws io.iron.ironmq.HTTPException       If the IronMQ service returns a status other than 200 OK.\n@throws java.io.IOException         If there is an error accessing the IronMQ server..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); }\n\n    ### Response:", "ground_truth": "Get a messages context appropriate for the given candidates.\n\nWill select a language from the candidates, based on the languages available, and fallback\nto the default language if none of the candidates are available.\n\n@param candidates the candidate languages\n@return the most appropriate Messages instance given the candidate languages", "predict": "Returns a new Messages object with the preferred language from the given candidates.\n\n@param candidates The candidates for the preferred language.\n@return A new Messages object with the preferred language.\n@throws java.lang.IllegalArgumentException If the candidates collection is empty."}, {"ID": 529, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Message peek() throws IOException { Messages msgs = peek(1); Message msg; try { msg = msgs.getMessage(0); } catch (IndexOutOfBoundsException e) { throw new EmptyQueueException(); } return msg; }\n\n    ### Response: Peeking at a queue returns the next messages on the queue, but it does not reserve them.\nIf there are no items on the queue, an EmptyQueueException is thrown.\n\n@throws io.iron.ironmq.EmptyQueueException If the queue is empty.\n@throws io.iron.ironmq.HTTPException       If the IronMQ service returns a status other than 200 OK.\n@throws java.io.IOException         If there is an error accessing the IronMQ server..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); }\n\n    ### Response:", "ground_truth": "Get a messages context appropriate for the given request.\n\nWill select a language from the request, based on the languages available, and fallback to\nthe default language if none of the candidates are available.\n\n@param request the incoming request\n@return the preferred messages context for the request", "predict": "Returns the preferred messages for the given request.\n\n@param request The HTTP request header.\n@return The preferred messages for the given request.\n@throws java.lang.IllegalArgumentException If the request header is null.\n@throws java.lang.RuntimeException         If there is an error accessing the messages."}, {"ID": 530, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (c *Controller) RenderTemplate(templatePath string) Result { c.setStatusIfNil(http.StatusOK) // Get the Template. lang, _ := c.ViewArgs[CurrentLocaleViewArg].(string) template, err := MainTemplateLoader.TemplateLang(templatePath, lang) if err != nil { return c.RenderError(err) } return &RenderTemplateResult{ Template: template, ViewArgs: c.ViewArgs, } }\n\n    ### Response: // RenderTemplate method does less magical way to render a template.\n// Renders the given template, using the current ViewArgs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); }\n\n    ### Response:", "ground_truth": "Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.\n\n@param result the result where the lang will be set.\n@param lang the lang to set on the result\n@return a new result with the lang.", "predict": " // setLang method sets the language for the given Result object.\n// It returns the modified Result object with the language set."}, {"ID": 531, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Injector createInjectorAndDoEMFRegistration(Module... modules) { doPreSetup(); final Injector injector = createInjector(modules); register(injector); return injector; }\n\n    ### Response: Create the injector based on the given set of modules and prepare the EMF infrastructure.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Add bindings from guiceable modules.\n\n@param modules the set of modules to bind\n@return a copy of this builder configured with those modules", "predict": " Create a new builder based on the given set of modules and delegate the bindings to the given module.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return a new builder.\n@since 0.8\n@see GuiceableModule."}, {"ID": 532, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Injector createInjectorAndDoEMFRegistration(Module... modules) { doPreSetup(); final Injector injector = createInjector(modules); register(injector); return injector; }\n\n    ### Response: Create the injector based on the given set of modules and prepare the EMF infrastructure.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Add bindings from Play modules.\n\n@param modules the set of Guice modules whose bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " Bind the given set of modules to the current application.\n\n@param modules the modules to bind.\n@return the current application.\n@since 0.8\n@see play.api.inject.guice.Guiceable.modules()"}, {"ID": 533, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SPARQLBindings getSPARQLBindings(SPARQLQueryBindingSet bindings) { SPARQLBindings sps = new SPARQLBindingsImpl(); for (Binding binding : bindings) { sps.bind(binding.getName(), binding.getValue().stringValue()); } return sps; }\n\n    ### Response: converts Sesame BindingSet to java api client SPARQLBindings\n\n@param bindings\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Add Play bindings.\n\n@param bindings the set of play bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " Binds the specified bindings to this application.\n\n@param bindings the bindings to bind\n@return a new application with the specified bindings bound to it."}, {"ID": 534, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Injector createInjectorAndDoEMFRegistration(Module... modules) { doPreSetup(); final Injector injector = createInjector(modules); register(injector); return injector; }\n\n    ### Response: Create the injector based on the given set of modules and prepare the EMF infrastructure.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(GuiceableModule... modules) { return newBuilder(delegate.overrides(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Override bindings using guiceable modules.\n\n@param modules the set of Guice modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": "Create a new builder that overrides the given modules.\n\n@param modules the modules to override.\n@return a new builder that overrides the given modules.\n@since 0.8\n@see GuiceableModule."}, {"ID": 535, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Injector createInjectorAndDoEMFRegistration(Module... modules) { doPreSetup(); final Injector injector = createInjector(modules); register(injector); return injector; }\n\n    ### Response: Create the injector based on the given set of modules and prepare the EMF infrastructure.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override bindings using Play modules.\n\n@param modules the set of Play modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": "Create a new instance of Self with the given set of modules.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return a new instance of Self with the given set of modules.\n@since 0.8\n@see play.api.inject.guice.Guiceable.modules()"}, {"ID": 536, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SPARQLBindings getSPARQLBindings(SPARQLQueryBindingSet bindings) { SPARQLBindings sps = new SPARQLBindingsImpl(); for (Binding binding : bindings) { sps.bind(binding.getName(), binding.getValue().stringValue()); } return sps; }\n\n    ### Response: converts Sesame BindingSet to java api client SPARQLBindings\n\n@param bindings\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Override bindings using Play bindings.\n\n@param bindings a set of Play bindings that override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " creates a new Self instance with the given bindings.\n\n@param bindings the bindings to override\n@return a new Self instance with the given bindings."}, {"ID": 537, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function (items, options) { options = options || {}; var isArr = isArray(items), Self = this; return this._checkTransaction(options, function () { return asyncArray(items) .map(function (o) { if (!isInstanceOf(o, Self)) { o = new Self(o); } return o.save(null, options); }) .chain(function (res) { return isArr ? res : res[0]; }); }); }\n\n    ### Response: Save either a new model or list of models to the database.\n\n@example\nvar Student = patio.getModel(\"student\");\nStudent.save([\n{\nfirstName:\"Bob\",\nlastName:\"Yukon\",\ngpa:3.689,\nclassYear:\"Senior\"\n},\n{\nfirstName:\"Greg\",\nlastName:\"Horn\",\ngpa:3.689,\nclassYear:\"Sohpmore\"\n},\n{\nfirstName:\"Sara\",\nlastName:\"Malloc\",\ngpa:4.0,\nclassYear:\"Junior\"\n},\n{\nfirstName:\"John\",\nlastName:\"Favre\",\ngpa:2.867,\nclassYear:\"Junior\"\n},\n{\nfirstName:\"Kim\",\nlastName:\"Bim\",\ngpa:2.24,\nclassYear:\"Senior\"\n},\n{\nfirstName:\"Alex\",\nlastName:\"Young\",\ngpa:1.9,\nclassYear:\"Freshman\"\n}\n]).chain(function(users){\n//work with the users\n});\n\nSave a single record\nMyModel.save(m1);\n\n@param {patio.Model|Object|patio.Model[]|Object[]} record the record/s to save.\n@param {Object} [options] additional options.\n@param {Boolean} [options.transaction] boolean indicating if a transaction should be used when\nsaving the models.\n\n@return {comb.Promise} called back with the saved record/s..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); }\n\n    ### Response:", "ground_truth": "Disable modules by class.\n\n@param moduleClasses the module classes whose bindings should be disabled\n@return a copy of this builder configured to ignore the provided module classes", "predict": " Disables the specified modules for this object.\n\n@param moduleClasses the modules to disable.\n@return a new instance of this object with the specified modules disabled."}, {"ID": 538, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String emitDataTypes() { StringBuilder dtDefs = new StringBuilder(); while (emittedDatatypes.size() < datatypes.size()) { for (String dt : new HashSet<String>(datatypes)) { if (!emittedDatatypes.contains(dt)) { StructureDefinition sd = context.fetchResource(StructureDefinition.class, ProfileUtilities.sdNs(dt, null)); // TODO: Figure out why the line below doesn't work // if (sd != null && !uniq_structures.contains(sd)) if(sd != null && !uniq_structure_urls.contains(sd.getUrl())) dtDefs.append(\"\\n\").append(genShapeDefinition(sd, false)); emittedDatatypes.add(dt); } } } return dtDefs.toString(); }\n\n    ### Response: Generate a shape definition for the current set of datatypes\n@return stringified data type definitions.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); }\n\n    ### Response:", "ground_truth": "the\nmigration guide for more details.", "predict": " Deprecated method to handle incoming requests. This method will be removed in the next release."}, {"ID": 539, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Result compile(String[] args) { Context context = new Context(); JavacFileManager.preRegister(context); // can't create it until Log has been set up Result result = compile(args, context); if (fileManager instanceof JavacFileManager) { try { // A fresh context was created above, so jfm must be a JavacFileManager ((JavacFileManager)fileManager).close(); } catch (IOException ex) { bugMessage(ex); } } return result; }\n\n    ### Response: Programmatic interface for main function.\n@param args  the command line parameters\n@return the result of the compilation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CompletionStage<Result> call( Request req) { // TODO: Make this method abstract after removing call(Context) return Context.safeCurrent() .map( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS)); Context.setCurrent(newCtx); return call(newCtx); }) .orElseGet( () -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents); ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>()); return call(ctx); }); }\n\n    ### Response:", "ground_truth": "", "predict": " Programmatic interface for main function.\n@param req  the request object\n@return the result of the call."}, {"ID": 540, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean shouldConfigureVirtualenv() { if(this.configureVirtualenv == ConfigureVirtualenv.NO) { return false; } else if(this.configureVirtualenv == ConfigureVirtualenv.YES) { return true; } else { final Optional<File> whichVirtualenv = this.which(\"virtualenv\"); return whichVirtualenv.isPresent(); } }\n\n    ### Response: Determines if a virtualenv should be created for Galaxy.\n@return True iff a virtualenv should be created..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); }\n\n    ### Response:", "ground_truth": "Retrieves a file relative to the application root path. This method returns an Optional, using\nempty if the file was not found.\n\n@param relativePath relative path of the file to fetch\n@return an existing file", "predict": " Gets an existing file from the environment.\n@param relativePath The path to the file, relative to the working directory.\n@return An optional containing the file if it exists, or an empty optional otherwise."}, {"ID": 541, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A extends Annotation> boolean isAnnotationPresent(Class<?> clazz, Class<A> annotationType) { if (findAnnotation(clazz, annotationType) != null) return true; return false; }\n\n    ### Response: Verifies if an annotation is present at a class type hierarchy.\n\n@param  The annotation type.\n@param clazz The class.\n@param annotationType The annotation.\n@return Whether the annotation is present at the class hierarchy or not.\n@since 0.3.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> Binding<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); }\n\n    ### Response:", "ground_truth": "Configure the scope for this binding.", "predict": "Binds the underlying provider to a specific scope.\n\n@param scope The scope to bind to.\n@return A new provider that is bound to the specified scope.\n@since 0.3.0."}, {"ID": 542, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static <A, B> Entry<A, B> createEntry(A text, B field) { return new SimpleImmutableEntry<>(text, field); }\n\n    ### Response: Helper method to create an immutable entry.\n\n@param text  the text, not null\n@param field  the field, not null\n@return the entry, not null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); }\n\n    ### Response:", "ground_truth": "Constructs a tuple of A,B\n\n@param a The a value\n@param b The b value\n@param  a's type\n@param  b's type\n@return The tuple", "predict": " Helper method to create a tuple.\n\n@param a  the first element, not null\n@param b  the second element, not null\n@return the tuple, not null."}, {"ID": 543, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A, B, C, D> Tuple4<A, B, C, D> of(A a, B b, C c, D d) { return new Tuple4<>(a, b, c, d); }\n\n    ### Response: Of tuple 4.\n\n@param  the type parameter\n@param  the type parameter\n@param  the type parameter\n@param  the type parameter\n@param a   the a\n@param b   the b\n@param c   the c\n@param d   the d\n@return the tuple 4.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); }\n\n    ### Response:", "ground_truth": "Constructs a tuple of A,B,C,D,E\n\n@param a The a value\n@param b The b value\n@param c The c value\n@param d The d value\n@param e The e value\n@param  a's type\n@param  b's type\n@param  c's type\n@param  d's type\n@param  e's type\n@return The tuple", "predict": " Tuple 5.\n\n@param  the type parameter\n@param  the type parameter\n@param  the type parameter\n@param  the type parameter\n@param  the type parameter\n@param a   the a\n@param b   the b\n@param c   the c\n@param d   the d\n@param e   the e\n@return the tuple 5."}, {"ID": 544, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static @CheckForNull Executor currentExecutor() { Thread t = Thread.currentThread(); if (t instanceof Executor) return (Executor) t; return IMPERSONATION.get(); }\n\n    ### Response: Returns the executor of the current thread or null if current thread is not an executor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Executor toExecutor(ExecutionContext ec) { ExecutionContext prepared = ec.prepare(); if (prepared instanceof Executor) { return (Executor) prepared; } else { return prepared::execute; } }\n\n    ### Response:", "ground_truth": "Converts the execution context to an executor, preparing it first.\n\n@param ec the execution context.\n@return the Java Executor.", "predict": " Converts the given execution context to an executor. If the execution context is already an executor, it is returned as is. Otherwise, a lambda expression is returned that executes the given execution context's execute method on the current thread."}, {"ID": 545, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ZooKeeperUpdatingListener of(String zkConnectionStr, String zNodePath) { return new ZooKeeperUpdatingListenerBuilder(zkConnectionStr, zNodePath).build(); }\n\n    ### Response: Creates a ZooKeeper server listener, which registers server into ZooKeeper.\n\nIf you need a fully customized {@link ZooKeeperUpdatingListener} instance, use\n{@link ZooKeeperUpdatingListenerBuilder} instead.\n\n@param zkConnectionStr ZooKeeper connection string\n@param zNodePath       ZooKeeper node path(under which this server will be registered).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig of(String name, String unitName) { return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName)); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration with the given name and unit name.\n\n@param name the name for the entity manager factory\n@param unitName the persistence unit name as used in `persistence.xml`\n@return a default JPA configuration", "predict": " Creates a JPA configuration object with the given name and unit name.\n\n@param name     Name of the persistence unit\n@param unitName Name of the persistence unit"}, {"ID": 546, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean sameResource(URIReference u1, String u2) { return u1.getURI().toString().equals(u2); }\n\n    ### Response: Tells whether the given resources are equivalent, with one given as a URI\nstring.\n\n@param u1\nfirst resource.\n@param u2\nsecond resource, given as a URI string.\n@return true if equivalent, false otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig of(String n1, String u1, String n2, String u2) { return new DefaultJPAConfig( new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2)); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration with the given names and unit names.\n\n@param n1 Name of the first entity manager factory\n@param u1 Name of the first unit\n@param n2 Name of the second entity manager factory\n@param u2 Name of the second unit\n@return a default JPA configuration with the provided persistence units.", "predict": " Creates a new JPAConfig object with two persistence units.\n\n@param n1\nname of the first persistence unit.\n@param u1\nURL of the first persistence unit.\n@param n2\nname of the second persistence unit.\n@param u2\nURL of the second persistence unit.\n@return a new JPAConfig object with two persistence units."}, {"ID": 547, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setHeaders(Map<String, String> map) { headers = new MetadataMap<String, String>(); for (Map.Entry<String, String> entry : map.entrySet()) { String[] values = entry.getValue().split(\",\"); for (String v : values) { if (v.length() != 0) { headers.add(entry.getKey(), v); } } } }\n\n    ### Response: Sets the headers new proxy or WebClient instances will be\ninitialized with.\n\n@param map the headers.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig from(Map<String, String> map) { ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>(); for (Map.Entry<String, String> entry : map.entrySet()) { persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue())); } return new DefaultJPAConfig(persistenceUnits.build()); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration from a map of names to unit names.\n\n@param map Map of entity manager factory names to unit names\n@return a JPAConfig configured with the provided mapping", "predict": " Creates a new JPAConfig instance from the given map of persistence units.\n\n@param map the map of persistence units.\n\n    "}, {"ID": 548, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Resource resolveConfigLocation() { if (this.config == null) { return null; } Assert.isTrue(this.config.exists(), () -> \"Hazelcast configuration does not \" + \"exist '\" + this.config.getDescription() + \"'\"); return this.config; }\n\n    ### Response: Resolve the config location if set.\n@return the location or {@code null} if it is not set\n@throws IllegalArgumentException if the config attribute is set to an unknown\nlocation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Flow<String, ByteString, NotUsed> string(String callbackName) { return Flow.of(String.class) .map( str -> { return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\"); }) .via(flow(callbackName)); }\n\n    ### Response:", "ground_truth": "Produces a Flow of escaped ByteString from a series of String elements. Calls out to Comet.flow\ninternally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": "Create a flow that converts a string to a byte string and then passes it to the specified callback.\n@param callbackName the name of the callback to pass the byte string to\n@return the created flow\n@throws IllegalArgumentException if the callback name is null or empty"}, {"ID": 549, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String json(String text) { if (text == null || text.isEmpty()) { return text; } return StringEscapeUtils.escapeJson(text); }\n\n    ### Response: JSON Encodes the provided text.\n\n@param text the text to encode\n@return the JSON encoded text.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) { return Flow.of(JsonNode.class) .map( json -> { return ByteString.fromString(Json.stringify(json)); }) .via(flow(callbackName)); }\n\n    ### Response:", "ground_truth": "Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode. Calls out to\nComet.flow internally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Converts a JSON object to a ByteString.\n\n@param callbackName the name of the callback function to include in the JSONP response\n@return a Flow that converts a JSON object to a ByteString and includes the callback function name in the response."}, {"ID": 550, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T extends CMAResource> T setId(String id) { getSystem().setId(id); return (T) this; }\n\n    ### Response: Sets the ID for this CMAResource.\n\n@param id  to be set.\n@param  resource type to be returned.\n@return this {@code CMAResource} instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) { validators.put(key, () -> constraintValidator); return this; }\n\n    ### Response:", "ground_truth": "Adds validator as a singleton.\n\n@param key the constraint validator type\n@param constraintValidator the constraint validator instance\n@param  the type of constraint validator implementation\n@return {@link MappedConstraintValidatorFactory} with the given constraint validator added.", "predict": " Adds a constraint validator to the factory.\n\n@param key  the constraint validator key.\n@param constraintValidator  the constraint validator instance.\n@return this {@code MappedConstraintValidatorFactory} instance."}, {"ID": 551, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Trainable> T load(Class<T> aClass, String storageName, Configuration configuration) { try { Constructor<T> constructor = aClass.getDeclaredConstructor(String.class, Configuration.class); constructor.setAccessible(true); return constructor.newInstance(storageName, configuration); } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) { throw new RuntimeException(ex); } }\n\n    ### Response: Loads an algorithm from the storage.\n\n@param \n@param aClass\n@param storageName\n@param configuration\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) { try { return key.getDeclaredConstructor().newInstance(); } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) { throw new RuntimeException(ex); } }\n\n    ### Response:", "ground_truth": "need to do so.", "predict": " Creates a new instance of the specified constraint validator.\n\n@param key The constraint validator class to create an instance of.\n@return A new instance of the specified constraint validator."}, {"ID": 552, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method getMethod(Class<?> clazz, final String methodName, final Class<?>... parameterTypes) { final String internedName = methodName.intern(); return traverseHierarchy(clazz, new TraverseTask<Method>() { @Override public Method run(Class<?> clazz) { Method[] methods = clazz.getDeclaredMethods(); Method res = null; for (int i = 0; i < methods.length; i++) { Method m = methods[i]; if (m.getName() == internedName && arrayContentsEq(parameterTypes, m.getParameterTypes()) && (res == null || res.getReturnType().isAssignableFrom(m.getReturnType()))) { res = m; } } return res; } }); }\n\n    ### Response: Returns the method object found for the given method name in the given\nclass. This method traverses through the super classes of the given class\nand tries to find the method as declared method within these classes.\nWhen the object class is reached the traversing stops. If the method can\nnot be found, null is returned.\n\n@param clazz          The class within to look for the method with the given method\nname\n@param methodName     The name of the method to be returned\n@param parameterTypes The accepting parameter types of the method\n@return The method object with the given method name if the method can be\nfound, otherwise null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method getMatchingAccessibleMethod( final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { try { final Method method = cls.getMethod(methodName, parameterTypes); MemberUtils.setAccessibleWorkaround(method); return method; } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null; final Method[] methods = cls.getMethods(); for (final Method method : methods) { // compare name and parameters if (method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod(method); if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) { bestMatch = accessibleMethod; } } } if (bestMatch != null) { MemberUtils.setAccessibleWorkaround(bestMatch); } if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) { final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes(); final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType(); final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName(); final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName(); final String parameterTypeSuperClassName = parameterTypes[parameterTypes.length - 1].getSuperclass().getName(); if (!methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) { return null; } } return bestMatch; }\n\n    ### Response:", "ground_truth": "Finds an accessible method that matches the given name and has compatible parameters.\nCompatible parameters mean that every method parameter is assignable from the given parameters.\nIn other words, it finds a method with the given name that will take the parameters given.\n\nThis method can match primitive parameter by passing in wrapper classes. For example, a\n{@code Boolean} will match a primitive {@code boolean} parameter.\n\n@param cls find method in this class\n@param methodName find method with this name\n@param parameterTypes find method with most compatible parameters\n@return The accessible method", "predict": " Returns the accessible method object found for the given method name and parameter types in the given class. This method first tries to find the method as declared method within the given class. If the method can not be found, it searches through all methods of the class and returns the accessible method with the best matching signature. If no matching method is found, null is returned.\n\n@param cls             The class within to look for the method with the given method name and parameter types\n@param methodName      The name of the method to be returned\n@param parameterTypes  The accepting parameter types of the method\n@return The accessible method object with the given method name and parameter types if the method can be found, otherwise null."}, {"ID": 553, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpStatus getStatusCode() { final Object statusCode = getHeader(HttpMessageHeaders.HTTP_STATUS_CODE); if (statusCode != null) { if (statusCode instanceof HttpStatus) { return (HttpStatus) statusCode; } else if (statusCode instanceof Integer) { return HttpStatus.valueOf((Integer) statusCode); } else { return HttpStatus.valueOf(Integer.valueOf(statusCode.toString())); } } return null; }\n\n    ### Response: Gets the Http response status code.\n\n@return The status code of the message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } }\n\n    ### Response:", "ground_truth": "Invoked when a client error occurs, that is, an error in the 4xx series.\n\nThe base implementation calls onBadRequest, onForbidden, onNotFound, or onOtherClientError\ndepending on the HTTP status code.\n\n@param request The request that caused the client error.\n@param statusCode The error status code. Must be greater or equal to 400, and less than 500.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " Handles client errors.\n\n@param request The request header.\n@param statusCode The status code of the error.\n@param message The error message.\n@return A completion stage of the result.\n\n    "}, {"ID": 554, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String formatOutputMessageInternal(final String message) { try { return EncodingUtils.urlEncode(message); } catch (final Exception e) { LOGGER.warn(\"Unable to encode URL \" + message, e); } return message; }\n\n    ### Response: Encodes the message in UTF-8 format in preparation to send.\n\n@param message Message to format and encode\n@return The encoded message..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.badRequest( views.html.defaultpages.badRequest.render( request.method(), request.uri(), message, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked when a client makes a bad request.\n\nReturns Results.badRequest (400) with the included template from {@code\nviews.html.defaultpages.badRequest} as the content.\n\n@param request The request that was bad.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " Handles bad requests by rendering the badRequest page with the given message.\n\n@param request The request header\n@param message The error message to display\n@return A CompletionStage that completes with a Result object that renders the badRequest page with the given message."}, {"ID": 555, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String handleError(final String message) { notifier().error(formatMessage(message)); return formatMessage(message); }\n\n    ### Response: Handle invalid helper data without exception details or because none was thrown.\n\n@param message message to log and return\n@return a message which will be used as content.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onForbidden(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked when a client makes a request that was forbidden.\n\nReturns Results.forbidden (401) with the included template from {@code\nviews.html.defaultpages.unauthorized} as the content.\n\n@param request The forbidden request.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " Handle unauthorized access to the resource.\n\n@param request the request header\n@param message the error message\n@return a completion stage with a forbidden result."}, {"ID": 556, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void handle(HttpRequest request, HttpResponder responder) { if (urlRewriter != null) { try { request.setUri(URI.create(request.uri()).normalize().toString()); if (!urlRewriter.rewrite(request, responder)) { return; } } catch (Throwable t) { responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR, String.format(\"Caught exception processing request. Reason: %s\", t.getMessage())); LOG.error(\"Exception thrown during rewriting of uri {}\", request.uri(), t); return; } } try { String path = URI.create(request.uri()).normalize().getPath(); List<PatternPathRouterWithGroups.RoutableDestination<HttpResourceModel>> routableDestinations = patternRouter.getDestinations(path); PatternPathRouterWithGroups.RoutableDestination<HttpResourceModel> matchedDestination = getMatchedDestination(routableDestinations, request.method(), path); if (matchedDestination != null) { //Found a httpresource route to it. HttpResourceModel httpResourceModel = matchedDestination.getDestination(); // Call preCall method of handler hooks. boolean terminated = false; HandlerInfo info = new HandlerInfo(httpResourceModel.getMethod().getDeclaringClass().getName(), httpResourceModel.getMethod().getName()); for (HandlerHook hook : handlerHooks) { if (!hook.preCall(request, responder, info)) { // Terminate further request processing if preCall returns false. terminated = true; break; } } // Call httpresource method if (!terminated) { // Wrap responder to make post hook calls. responder = new WrappedHttpResponder(responder, handlerHooks, request, info); if (httpResourceModel.handle(request, responder, matchedDestination.getGroupNameValues()).isStreaming()) { responder.sendString(HttpResponseStatus.METHOD_NOT_ALLOWED, String.format(\"Body Consumer not supported for internalHttpResponder: %s\", request.uri())); } } } else if (routableDestinations.size() > 0) { //Found a matching resource but could not find the right HttpMethod so return 405 responder.sendString(HttpResponseStatus.METHOD_NOT_ALLOWED, String.format(\"Problem accessing: %s. Reason: Method Not Allowed\", request.uri())); } else { responder.sendString(HttpResponseStatus.NOT_FOUND, String.format(\"Problem accessing: %s. Reason: Not Found\", request.uri())); } } catch (Throwable t) { responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR, String.format(\"Caught exception processing request. Reason: %s\", t.getMessage())); LOG.error(\"Exception thrown during request processing for uri {}\", request.uri(), t); } }\n\n    ### Response: Call the appropriate handler for handling the httprequest. 404 if path is not found. 405 if path is found but\nhttpMethod does not match what's configured.\n\n@param request instance of {@code HttpRequest}\n@param responder instance of {@code HttpResponder} to handle the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onNotFound(RequestHeader request, String message) { if (environment.isProd()) { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.notFound.render( request.method(), request.uri(), request.asScala()))); } else { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.devNotFound.render( request.method(), request.uri(), Some.apply(routes.get()), request.asScala()))); } }\n\n    ### Response:", "ground_truth": "Invoked when a handler or resource is not found.\n\nIf the environment's mode is production, then returns Results.notFound (404) with the\nincluded template from `views.html.defaultpages.notFound` as the content.\n\nOtherwise, Results.notFound (404) is rendered with {@code\nviews.html.defaultpages.devNotFound} template.\n\n@param request The request that no handler was found to handle.\n@param message A message, which is not used by the default implementation.\n@return a CompletionStage containing the Result.", "predict": " This method is called when a request is not found. It returns a CompletionStage of a Result object. The Result object is a not found page with details of the request. If the application is in production mode, it returns a not found page with a generic message. If the application is in development mode, it returns a not found page with details of the routes and the request."}, {"ID": 557, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object read(JSONReader r, JsonParser p) throws IOException { if (p.isExpectedStartObjectToken()) { final Object bean; try { bean = create(); } catch (Exception e) { return _reportFailureToCreate(p, e); } p.setCurrentValue(bean); return _readBean(r, p, bean); } try { switch (p.currentTokenId()) { case JsonTokenId.ID_NULL: return null; case JsonTokenId.ID_STRING: return create(p.getText()); case JsonTokenId.ID_NUMBER_INT: return create(p.getLongValue()); default: } } catch (Exception e) { return _reportFailureToCreate(p, e); } throw JSONObjectException.from(p, \"Can not create a %s instance out of %s\", _type.getName(), _tokenDesc(p)); }\n\n    ### Response: Method used for deserialization; will read an instance of the bean\ntype using given parser..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return CompletableFuture.completedFuture(Results.internalServerError()); } }\n\n    ### Response:", "ground_truth": "Invoked when a server error occurs.\n\nBy default, the implementation of this method delegates to [[onProdServerError()]] when in\nprod mode, and [[onDevServerError()]] in dev mode. It is recommended, if you want Play's debug\ninfo on the error page in dev mode, that you override [[onProdServerError()]] instead of this\nmethod.\n\n@param request The request that triggered the server error.\n@param exception The server error.\n@return a CompletionStage containing the Result.", "predict": " Method used to handle server errors. It takes in the request header and the exception that occurred. It logs the error and then based on the environment mode, it either returns a production error or a development error. If an error occurs while handling the error, it logs the error and returns a 500 Internal Server Error."}, {"ID": 558, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void doHeaders(RenderRequest request, RenderResponse response) { try { doDispatch(request, response); } catch (IOException | PortletException ex) { logger.error( \"Exception rendering headers for portlet \" + getPortletName() + \". Aborting doHeaders\", ex); } }\n\n    ### Response: Used by the render method to set the response properties and headers.\n\nThe portlet should override this method and set its response header using this method in\norder to ensure that they are set before anything is written to the output stream.\n\n\n\n@param request the render request\n@param response the render response.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void logServerError(RequestHeader request, UsefulException usefulException) { logger.error( String.format( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException); }\n\n    ### Response:", "ground_truth": "Responsible for logging server errors.\n\nThe base implementation uses a SLF4J Logger. If a special annotation is desired for internal\nserver errors, you may want to use SLF4J directly with the Marker API to distinguish server\nerrors from application errors.\n\nThis can also be overridden to add additional logging information, eg. the id of the\nauthenticated user.\n\n@param request The request that triggered the server error.\n@param usefulException The server error.", "predict": " Logs an error message with the given useful exception and request information.\n\n@param request the request header\n@param usefulException the useful exception to log\n\n    "}, {"ID": 559, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void debug(String message, Throwable throwable) { final Log log = getLog(); if (log != null) log.debug(message, throwable); }\n\n    ### Response: Log given message and throwable at debug level\n\n@param message\n@param throwable.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final UsefulException throwableToUsefulException(final Throwable throwable) { return HttpErrorHandlerExceptions.throwableToUsefulException( sourceMapper.sourceMapper(), environment.isProd(), throwable); }\n\n    ### Response:", "ground_truth": "Convert the given exception to an exception that Play can report more information about.\n\nThis will generate an id for the exception, and in dev mode, will load the source code for\nthe code that threw the exception, making it possible to report on the location that the\nexception was thrown from.", "predict": " Convert the given throwable to a UsefulException object.\n\n@param throwable\n@return UsefulException object."}, {"ID": 560, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object doInvocation(TransactionLogger transactionLogger, MethodInvocation invocation, TransactionMetadata transactionMetadata, Object currentTransaction) throws Throwable { Object result = null; try { transactionLogger.log(\"invocation started\", transactionLogger); result = invocation.proceed(); transactionLogger.log(\"invocation ended\", transactionLogger); } catch (Exception exception) { doHandleException(transactionLogger, exception, transactionMetadata, currentTransaction); } return result; }\n\n    ### Response: This method call the wrapped transactional method.\n\n@param transactionLogger   The object that must be used to log transaction progress.\n@param invocation          the {@link MethodInvocation} denoting the transactional method.\n@param transactionMetadata the current transaction metadata.\n@param currentTransaction  the current transaction object if any.\n@return the return value of the transactional method.\n@throws Throwable if an exception occurs during the method invocation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked in dev mode when a server error occurs. Note that this method is where the URL set by\nplay.editor is used.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.devError}.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " This method handles the development server error.\n\n@param request   The request header.\n@param exception The exception that occurred.\n@return A completed future with the error page."}, {"ID": 561, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final int getLineNumber(final String lineNumber) { if (StringUtils.isNotBlank(lineNumber)) { try { return Integer.parseInt(lineNumber); } catch (NumberFormatException exception) { // ignore and return 0 } } return 0; }\n\n    ### Response: Converts a string line number to an integer value. If the string is not a\nvalid line number, then 0 is returned which indicates a warning at the\ntop of the file.\n\n@param lineNumber\nthe line number (as a string)\n@return the line number.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked in prod mode when a server error occurs.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.error} template.\n\nOverride this rather than [[onServerError()]] if you don't want to change Play's debug\noutput when logging errors in dev mode.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " Handles a server error that occurs on the production environment.\n\n@param request\nthe request header\n@param exception\nthe exception that occurred\n@return a completion stage that completes with a result\n\n    "}, {"ID": 562, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    JarFile getBootProxyJarIfCurrent() { File dataFile = bundleContext.getDataFile(\"boot-proxy.jar\"); if (!dataFile.exists()) { return null; } JarFile jarFile = null; try { jarFile = new JarFile(dataFile); Manifest manifest = jarFile.getManifest(); Attributes attrs = manifest.getMainAttributes(); String jarVersion = attrs.getValue(MONITORING_VERSION_MANIFEST_HEADER); if (!getCurrentVersion().equals(jarVersion)) { jarFile.close(); jarFile = null; } } catch (Exception e) { } return jarFile; }\n\n    ### Response: Get the boot proxy jar from the current data area if the code\nmatches the current bundle version.\n\n@return the proxy jar iff the proxy jar exits and matches this\nbundle's version.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); }\n\n    ### Response:", "ground_truth": "Create a BuildDocHandler that serves documentation from the given files, which could either be\ndirectories or jar files. The baseDir array must be the same length as the files array, and the\ncorresponding entry in there for jar files is used as a base directory to use resources from in\nthe jar.\n\n@param files The directories or jar files to serve documentation from.\n@param baseDirs The base directories for the jar files. Entries may be null.\n@return a BuildDocHandler.", "predict": " Create a BuildDocHandler from a set of resources and base directories.\n\n@param files the files or directories to load resources from\n@param baseDirs the base directories to use for each resource\n@return a BuildDocHandler that can be used to generate documentation\n\n@throws IOException if there is an error reading the resources"}, {"ID": 563, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<DesignDocument> fromDirectory(File directory) throws FileNotFoundException { List<DesignDocument> designDocuments = new ArrayList<DesignDocument>(); if (directory.isDirectory()) { Collection<File> files = FileUtils.listFiles(directory, null, true); for (File designDocFile : files) { designDocuments.add(fromFile(designDocFile)); } } else { designDocuments.add(fromFile(directory)); } return designDocuments; }\n\n    ### Response: Deserialize a directory of javascript design documents to a List of DesignDocument objects.\n\n@param directory the directory containing javascript files\n@return {@link DesignDocument}\n@throws FileNotFoundException if the file does not exist or cannot be read.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectory(File directory) { FileRepository repo = new FilesystemRepository(directory); return new DocumentationHandler(repo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given directory by wrapping a\nFilesystemRepository.\n\n@param directory The directory to serve the documentation from.", "predict": " Create a BuildDocHandler object from a directory of build documentation.\n\n@param directory the directory containing build documentation files\n@return a BuildDocHandler object\n\n    "}, {"ID": 564, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean indexJar(final Indexer indexer, final List<File> knownFiles, final File jarFile) { if (knownFiles.contains(jarFile)) { return false; } knownFiles.add(jarFile); try (final JarFile jar = new JarFile(jarFile)) { final Enumeration<JarEntry> entries = jar.entries(); while (entries.hasMoreElements()) { final JarEntry entry = entries.nextElement(); if (entry.getName().endsWith(\".class\")) { try (final InputStream stream = jar.getInputStream(entry)) { indexer.index(stream); } catch (final IOException ex) { throw new RuntimeException(\"Error indexing \" + entry.getName() + \" in \" + jarFile, ex); } } } } catch (final IOException ex) { throw new RuntimeException(\"Error indexing \" + jarFile, ex); } return true; }\n\n    ### Response: Indexes a single JAR, except it was already analyzed.\n\n@param indexer\nIndexer to use.\n@param knownFiles\nList of files already analyzed. New files will be added within this method.\n@param jarFile\nJAR to analyze.\n\n@return TRUE if the JAR was indexed or FALSE if it was ignored..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) { return fromDirectoryAndJar(directory, jarFile, base, false); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Creates a BuildDocHandler from a directory and a JAR file.\n\n@param directory\nDirectory containing the source files.\n@param jarFile\nJAR file containing the compiled classes.\n@param base\nBase package name.\n@param includeSubpackages\nWhether to include subpackages or not.\n\n@return A BuildDocHandler instance."}, {"ID": 565, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean indexJar(final Indexer indexer, final List<File> knownFiles, final File jarFile) { if (knownFiles.contains(jarFile)) { return false; } knownFiles.add(jarFile); try (final JarFile jar = new JarFile(jarFile)) { final Enumeration<JarEntry> entries = jar.entries(); while (entries.hasMoreElements()) { final JarEntry entry = entries.nextElement(); if (entry.getName().endsWith(\".class\")) { try (final InputStream stream = jar.getInputStream(entry)) { indexer.index(stream); } catch (final IOException ex) { throw new RuntimeException(\"Error indexing \" + entry.getName() + \" in \" + jarFile, ex); } } } } catch (final IOException ex) { throw new RuntimeException(\"Error indexing \" + jarFile, ex); } return true; }\n\n    ### Response: Indexes a single JAR, except it was already analyzed.\n\n@param indexer\nIndexer to use.\n@param knownFiles\nList of files already analyzed. New files will be added within this method.\n@param jarFile\nJAR to analyze.\n\n@return TRUE if the JAR was indexed or FALSE if it was ignored..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.\n@param fallbackToJar Whether the doc handler should fall back to the jar repo for docs.", "predict": " Creates a BuildDocHandler that can handle documentation from a directory and a JAR file.\n\n@param directory\nDirectory to search for documentation files.\n@param jarFile\nJAR file to search for documentation files.\n@param base\nBase path to use for documentation files in the JAR file.\n@param fallbackToJar\nIf TRUE, documentation files in the JAR file will be searched first, followed by documentation files in the directory. If FALSE, only documentation files in the directory will be searched.\n\n@return A BuildDocHandler that can handle documentation from the specified directory and JAR file."}, {"ID": 566, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URIResolver createSAXURIResolver(Resolver resolver) { final SAXResolver saxResolver = new SAXResolver(resolver); return new URIResolver() { public Source resolve(String href, String base) throws TransformerException { try { return saxResolver.resolve(href, base); } catch (SAXException e) { throw toTransformerException(e); } catch (IOException e) { throw new TransformerException(e); } } }; }\n\n    ### Response: Creates a URIResolver that returns a SAXSource.\n@param resolver\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromJar(JarFile jarFile, String base) { FileRepository repo = new JarRepository(jarFile, Option.apply(base)); return new DocumentationHandler(repo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a\nJarRepository.\n\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Creates a BuildDocHandler that reads documentation from a jar file.\n@param jarFile\n@param base\n@return."}, {"ID": 567, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setFinalTransformMatrix(Matrix4f finalTransform) { float[] mat = new float[16]; finalTransform.get(mat); NativeBone.setFinalTransformMatrix(getNative(), mat); }\n\n    ### Response: Sets the final transform of the bone during animation.\n\n@param finalTransform The transform matrix representing\nthe bone's pose after computing the skeleton..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); }\n\n    ### Response:", "ground_truth": "Consumes the data.\n\nThis method should be used carefully, since if the source represents an ephemeral stream,\nthen the entity may not be usable after this method is invoked.\n\n@param mat the application's materializer.\n@return a CompletionStage holding the data", "predict": "Consumes the data stream and returns a completion stage that completes with the concatenated byte string.\n\n@param mat The materializer to use for running the stream."}, {"ID": 568, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbAccessException createDbAccessException(HttpResponse hr) { JsonNode responseBody; try { InputStream content = hr.getContent(); if (content != null) { responseBody = responseBodyAsNode(IOUtils.toString(content)); } else { responseBody = NullNode.getInstance(); } } catch (Exception e) { responseBody = NullNode.getInstance(); } switch (hr.getCode()) { case HttpStatus.NOT_FOUND: return new DocumentNotFoundException(hr.getRequestURI(), responseBody); case HttpStatus.CONFLICT: return new UpdateConflictException(); default: String body; try { body = toPrettyString(responseBody); } catch (IOException e) { body = \"unavailable\"; } return new DbAccessException(hr.toString() + \"\\nURI: \" + hr.getRequestURI() + \"\\nResponse Body: \\n\" + body); } }\n\n    ### Response: Creates an DbAccessException which specific type is determined by the response code in the http response.\n@param hr\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); }\n\n    ### Response:", "ground_truth": "Create an entity from the given content.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " Creates a HttpEntity from the given Content object.\n@param content\n@param charset\n@return HttpEntity."}, {"ID": 569, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PrintWriter newPrintWriter(Path self, String charset) throws IOException { return new GroovyPrintWriter(newWriter(self, charset)); }\n\n    ### Response: Create a new PrintWriter for this file, using specified\ncharset.\n\n@param self    a Path\n@param charset the charset\n@return a PrintWriter\n@throws java.io.IOException if an IOException occurs.\n@since 2.3.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity fromString(String content, String charset) { return new Strict( ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset)); }\n\n    ### Response:", "ground_truth": "Create an entity from the given String.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " Create a new HttpEntity from the given string content and charset.\n\n@param content the content\n@param charset the charset\n@return a new HttpEntity\n@since 4.3.10\n\n    "}, {"ID": 570, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> JacksonParser<T> json(Class<T> contentType) { return new JacksonParser<>(null, contentType); }\n\n    ### Response: Creates typed parser\n@param contentType class of parsed object\n@param  type of parsed object\n@return parser of objects of given type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); }\n\n    ### Response:", "ground_truth": "Convert the given source of ByteStrings to a chunked entity.\n\n@param data The source.\n@param contentType The optional content type.\n@return The ByteStrings.", "predict": " Creates chunked entity\n@param data source of bytes\n@param contentType optional content type\n@return chunked entity with given data and content type.\n\n    "}, {"ID": 571, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode buildResponse(int status, String message, Object data) { return SerializationUtils.toJson(MapUtils.removeNulls(MapUtils.createMap(FIELD_STATUS, status, FIELD_MESSAGE, message, FIELD_DATA, data))); }\n\n    ### Response: Build Json-RPC's response in JSON format.\n\n\nJson-RPC response as the following format:\n\n\n\n{\n\"status\" : (int) response status/error code,\n\"message\": (string) response message,\n\"data\"   : (object) response data\n}\n\n\n@param status\n@param message\n@param data\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, JsonNode content) { return status(status, content, JsonEncoding.UTF8); }\n\n    ### Response:", "ground_truth": "Generates a simple result with json content and UTF8 encoding.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content as a play-json object\n@return the result", "predict": " Create a Result object with the given status and content.\n\n\n@param status\n@param content\n@param encoding\n@return.\n\n    "}, {"ID": 572, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getPayload(Message message) { try { String encoding = (String) message.get(Message.ENCODING); if (encoding == null) { encoding = \"UTF-8\"; } CachedOutputStream cos = message.getContent(CachedOutputStream.class); if (cos == null) { LOG.warning(\"Could not find CachedOutputStream in message.\" + \" Continuing without message content\"); return \"\"; } return new String(cos.getBytes(), encoding); } catch (IOException e) { throw new RuntimeException(e); } }\n\n    ### Response: Gets the message payload.\n\n@param message the message\n@return the payload.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, JsonNode content, JsonEncoding encoding) { if (content == null) { throw new NullPointerException(\"Null content\"); } return status(status).sendJson(content, encoding); }\n\n    ### Response:", "ground_truth": "Generates a simple result with json content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a play-json object\n@param encoding the encoding into which the json should be encoded\n@return the result", "predict": " Sends a JSON response with the given status code and content.\n\n@param status the HTTP status code\n@param content the JSON content\n@param encoding the encoding to use for the response\n@return the result object\n\n    "}, {"ID": 573, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyToClipboard(String content) { if (content == null) { return; } Clipboard cb = null; try { cb = new Clipboard(Display.getDefault()); cb.setContents(new String[] { content }, new TextTransfer[] { TextTransfer.getInstance() }); } finally { if (cb != null) { cb.dispose(); } } }\n\n    ### Response: Copies given string to the system clipboard\n\n@param content\nnon null String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, byte[] content) { if (content == null) { throw new NullPointerException(\"Null content\"); } return new Result( status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty())); }\n\n    ### Response:", "ground_truth": "Generates a simple result with byte-array content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a byte array\n@return the result", "predict": " Returns a Result object with the given status and content.\n\n@param status\nHTTP status code.\n@param content\nnon null byte array."}, {"ID": 574, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Response streamResponse(String type, InputStream inputStream, int contentLength) { return Response.ok(new StreamingOutputImpl(inputStream), type) .header(\"Content-Length\", contentLength) .build(); }\n\n    ### Response: Creates streamed response from input stream\n\n@param inputStream data\n@param type content type\n@param contentLength content length\n@return Response.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, InputStream content, long contentLength) { return status(status).sendInputStream(content, contentLength); }\n\n    ### Response:", "ground_truth": "Generates a chunked result.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the input stream containing data to chunk over\n@param contentLength the length of the provided content in bytes.\n@return the result", "predict": " Sends input stream as response with status code\n\n@param status HTTP status code\n@param content input stream\n@param contentLength content length\n@return Result."}, {"ID": 575, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Post withContent(final String content) { return new Post(id, slug, title, excerpt, content, authorId, author, publishTimestamp, modifiedTimestamp, status, parentId, guid, commentCount, metadata, type, mimeType, taxonomyTerms, children); }\n\n    ### Response: Replaces post content.\n@param content The new content.\n@return The post with content replaced..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, File content) { return status(status, content, StaticFileMimeTypes.fileMimeTypes()); }\n\n    ### Response:", "ground_truth": "Generates a result with file contents.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the file to send\n@return the result", "predict": " Returns a result with the given status and content.\n@param status The status code.\n@param content The content to return.\n@return The result with the given status and content.\n\n    "}, {"ID": 576, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function normalizeUserData() { function handler(req, res, next) { if (req.session && !req.session.user && req.session.auth && req.session.auth.loggedIn) { var user = {}; if (req.session.auth.github) { user.image = 'http://1.gravatar.com/avatar/'+req.session.auth.github.user.gravatar_id+'?s=48'; user.name = req.session.auth.github.user.name; user.id = 'github-'+req.session.auth.github.user.id; } if (req.session.auth.twitter) { user.image = req.session.auth.twitter.user.profile_image_url; user.name = req.session.auth.twitter.user.name; user.id = 'twitter-'+req.session.auth.twitter.user.id_str; } if (req.session.auth.facebook) { user.image = req.session.auth.facebook.user.picture; user.name = req.session.auth.facebook.user.name; user.id = 'facebook-'+req.session.auth.facebook.user.id; // Need to fetch the users image... https.get({ 'host': 'graph.facebook.com' , 'path': '/me/picture?access_token='+req.session.auth.facebook.accessToken }, function(response) { user.image = response.headers.location; req.session.user = user; next(); }).on('error', function(e) { req.session.user = user; next(); }); return; } req.session.user = user; } next(); } return handler; }\n\n    ### Response: Fetch and format data so we have an easy object with user data to work with..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private User findById(Long id) { if (id > 3) return null; User user = new User(); user.id = id; user.name = \"User \" + String.valueOf(id); return user; }\n\n    ### Response:", "ground_truth": "designed to be lightweight operation", "predict": " Find a user by id, if the id is greater than 3 return null. Otherwise, create a new user object with the given id and name."}, {"ID": 577, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<T> apply(Predicate<T> predicate, List<T> candidates) { List<T> filtered = new ArrayList<T>(candidates.size()); for(T entity : candidates) { if(predicate.appliesTo(entity)) filtered.add(entity); } return filtered; }\n\n    ### Response: Filter a list of entities through a predicate.\nIf the the predicate applies the entity will be included.\n\n@param predicate\n@param candidates\n@return a subset of the actual list of candidates.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); }\n\n    ### Response:", "ground_truth": "Select a preferred language, given the list of candidates.\n\nWill select the preferred language, based on what languages are available, or return the\ndefault language if none of the candidates are available.\n\n@param candidates The candidate languages\n@return The preferred language", "predict": " Get the preferred language from a collection of languages.\n\n@param candidates\n@return the preferred language."}, {"ID": 578, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function unique() : Collection { $temp = $this->toArray(); $rslt = []; foreach ($temp as $k => $v) { if (!in_array($v, $rslt, true)) { $rslt[$k] = $v; } } return new static($rslt); }\n\n    ### Response: Leave only unique items in the collection\n@return Collection.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); }\n\n    ### Response:", "ground_truth": "Append a unique identifier to the URL.\n\n@return a copy if this call with a unique identifier to this url", "predict": " Returns a new Call object with the same method, URL, and fragment as this one, but with any duplicate query parameters removed."}, {"ID": 579, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URI setFragment(final URI path, final String fragment) { try { if (path.getPath() != null) { return new URI(path.getScheme(), path.getUserInfo(), path.getHost(), path.getPort(), path.getPath(), path.getQuery(), fragment); } else { return new URI(path.getScheme(), path.getSchemeSpecificPart(), fragment); } } catch (final URISyntaxException e) { throw new RuntimeException(e.getMessage(), e); } }\n\n    ### Response: Create new URI with a given fragment.\n\n@param path URI to set fragment on\n@param fragment new fragment, {@code null} for no fragment\n@return new URI instance with given fragment.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); }\n\n    ### Response:", "ground_truth": "Returns a new Call with the given fragment.\n\n@param fragment the URL fragment\n@return a copy of this call that contains the fragment", "predict": " Create a new Call with a given fragment.\n\n@param fragment new fragment, {@code null} for no fragment\n@return new Call instance with given fragment."}, {"ID": 580, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String getRequestUriWithoutContextPath(HttpServletRequest request) { String uri = request.getRequestURI().substring(request.getContextPath().length()); if (!uri.isEmpty()) { return uri; } else { return \"/\"; } }\n\n    ### Response: Returns the request URI without the context path.\n\n@param request   the request where to get the URI from.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String absoluteURL(Http.Request request) { return absoluteURL(request.secure(), request.host()); }\n\n    ### Response:", "ground_truth": "Transform this call to an absolute URL.\n\n@param request used to identify the host and protocol that should base this absolute URL\n@return the absolute URL string", "predict": " Returns the absolute URL for the given request.\n\n@param request   the request where to get the URL from."}, {"ID": 581, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String getRequestUriWithoutContextPath(HttpServletRequest request) { String uri = request.getRequestURI().substring(request.getContextPath().length()); if (!uri.isEmpty()) { return uri; } else { return \"/\"; } }\n\n    ### Response: Returns the request URI without the context path.\n\n@param request   the request where to get the URI from.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String webSocketURL(Http.Request request) { return webSocketURL(request.secure(), request.host()); }\n\n    ### Response:", "ground_truth": "Transform this call to an WebSocket URL.\n\n@param request used as the base for forming the WS url\n@return the websocket url string", "predict": " Returns the WebSocket URL for the given request.\n\n@param request   the request where to get the WebSocket URL from."}, {"ID": 582, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static protected SftpClient getSftpClient(MuleContext muleContext, String endpointName) throws IOException { ImmutableEndpoint endpoint = getImmutableEndpoint(muleContext, endpointName); try { SftpClient sftpClient = SftpConnectionFactory.createClient(endpoint); return sftpClient; } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } /* EndpointURI endpointURI = endpoint.getEndpointURI(); SftpClient sftpClient = new SftpClient(endpointURI.getHost()); SftpConnector sftpConnector = (SftpConnector) endpoint.getConnector(); if (sftpConnector.getIdentityFile() != null) { try { sftpClient.login(endpointURI.getUser(), sftpConnector.getIdentityFile(), sftpConnector.getPassphrase()); } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } } else { try { sftpClient.login(endpointURI.getUser(), endpointURI.getPassword()); } catch (Exception e) { throw new RuntimeException(\"Login failed\", e); } } return sftpClient; */ }\n\n    ### Response: Returns a SftpClient that is logged in to the sftp server that the\nendpoint is configured against.\n\n@param muleContext\n@param endpointName\n@return\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new AbstractFunction1<Connection, BoxedUnit>() { public BoxedUnit apply(Connection connection) { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; }\n\n    ### Response:", "ground_truth": "Create a Scala function wrapper for ConnectionRunnable.\n\n@param block a Java functional interface instance to wrap\n@return a scala function that wraps the given block", "predict": " Returns a function that takes a Connection and runs the given ConnectionRunnable on it.\n\n@param block\n@return\n@throws java.sql.SQLException."}, {"ID": 583, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A> Mapper<A, A> identity() { return new Mapper<A, A>() { @Override public A map(A item) { return item; } }; }\n\n    ### Response: Gets the identity mapper.\n\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) { return new AbstractFunction1<Connection, A>() { public A apply(Connection connection) { try { return block.call(connection); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; }\n\n    ### Response:", "ground_truth": "Create a Scala function wrapper for ConnectionCallable.\n\n@param block a Java functional interface instance to wrap\n@param  the provided block's return type\n@return a scala function wrapping the given block", "predict": " Gets a connection function that executes the given block of code and returns the result.\n\n@param connection the connection to use for executing the block of code.\n@return the result of executing the block of code."}, {"ID": 584, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Router getRouter(Class<? extends Router> routerType) { return routers.computeIfAbsent(routerType, Routers::create); }\n\n    ### Response: Get router instance by a given router class. The class should have a default constructor.\nOtherwise no router can be created\n\n@param routerType the type of the Router.\n@return instance of the Router..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) { return new Builder().mode(mode).http(port).build(block); }\n\n    ### Response:", "ground_truth": "Create a server for the router returned by the given block.\n\n@param block The block which creates a router.\n@param mode The mode the server will run on.\n@param port The port the server will run on.\n@return The running server.", "predict": " Create a server instance with a given mode, port, and router block.\n\n@param mode the server mode.\n@param port the server port.\n@param block the router block.\n@return a server instance."}, {"ID": 585, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode toJson(final Object data) { if (data == null) { return newObject(); } try { return createObjectMapper().valueToTree(data); } catch (Exception e) { throw new ParseException(e); } }\n\n    ### Response: Convert an object to JsonNode.\n\n@param data Value to convert in Json.\n@return creates a new json object from given data object\n@throws ParseException to runtime if object can't be parsed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Converts an object to JsonNode.\n\n@param data Value to convert in Json.\n@return the JSON node.", "predict": " Convert an object to JsonNode.\n\n@param data Value to convert in Json.\n@return creates a new json object from given data object\n@throws RuntimeException to runtime if object can't be parsed."}, {"ID": 586, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T fromJsonString(String json, Class<T> clazz) { if (json == null) { return null; } try { return JsonUtils.objectMapper.readValue(json, clazz); } catch (Exception e) { throw new BceClientException(\"Unable to parse Json String.\", e); } }\n\n    ### Response: Returns the deserialized object from the given json string and target class; or null if the given json string is\nnull..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Converts a JsonNode to a Java value\n\n@param  the type of the return value.\n@param json Json value to convert.\n@param clazz Expected Java value type.\n@return the return value.", "predict": " Returns the deserialized object from the given json node and target class.\n\n    "}, {"ID": 587, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonNode parse(String src) { synchronized (lock) { try { return mapper.readValue(src, JsonNode.class); } catch (Exception t) { throw new RuntimeException(t); } } }\n\n    ### Response: Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON String\n@return the Json Node\n@throws java.lang.RuntimeException if the given string is not a valid JSON String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode parse(String src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } }\n\n    ### Response:", "ground_truth": "Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON string.\n@return the JSON node.", "predict": " Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON String\n@return the Json Node\n@throws java.lang.RuntimeException if the given string is not a valid JSON String."}, {"ID": 588, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonNode parse(String src) { synchronized (lock) { try { return mapper.readValue(src, JsonNode.class); } catch (Exception t) { throw new RuntimeException(t); } } }\n\n    ### Response: Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON String\n@return the Json Node\n@throws java.lang.RuntimeException if the given string is not a valid JSON String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } }\n\n    ### Response:", "ground_truth": "Parses a InputStream representing a json, and return it as a JsonNode.\n\n@param src the JSON input stream.\n@return the JSON node.", "predict": " Parses an input stream representing a json, and return it as a JsonNode.\n\n@param src the input stream containing the JSON data\n@return the Json Node\n@throws java.lang.RuntimeException if the given input stream is not a valid JSON data."}, {"ID": 589, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRelativeNodePath(String basePath, String targetPath) { // Both paths are equal if (basePath.equals(targetPath)) { return \".\"; } if (basePath.equals(PATH_SEP) && (targetPath.length() > 1)) { // Base path is root path return targetPath.substring(1); } String[] baseAncestors = FilenameUtils.normalizeNoEndSeparator(basePath).split(PATH_SEP); String[] targetAncestors = FilenameUtils.normalizeNoEndSeparator(targetPath).split(PATH_SEP); int length = (baseAncestors.length < targetAncestors.length) ? baseAncestors.length : targetAncestors.length; int lastCommonRoot = -1; int i; // Iterate over the shorter path for (i = 0; i < length; i++) { if (baseAncestors[i].equals(targetAncestors[i])) { lastCommonRoot = i; } else { break; } } // Last common root is the common base path if (lastCommonRoot != -1) { StringBuilder newRelativePath = new StringBuilder(); // How often must we go back from base path to common root? for (i = lastCommonRoot + 1; i < baseAncestors.length; i++) { if (baseAncestors[i].length() > 0) { newRelativePath.append(\"..\" + PATH_SEP); } } // How often must we go forth from common root to get to tagret path? for (i = lastCommonRoot + 1; i < targetAncestors.length; i++) { newRelativePath.append(targetAncestors[i]).append(PATH_SEP); } // newRelativePath.append(targetAncestors[targetAncestors.length - 1]); String result = newRelativePath.toString(); if (result.endsWith(PATH_SEP)) { result = result.substring(0, result.length() - 1); } return result; } return targetPath; }\n\n    ### Response: Assemble a relative path for the given absolute paths\n\n@param basePath\n@param targetPath\n@return relative node path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String relative(String startPath, String targetPath) { // If the start and target path's are the same then link to the current directory if (startPath.equals(targetPath)) { return CURRENT_DIR; } String[] start = toSegments(canonical(startPath)); String[] target = toSegments(canonical(targetPath)); // If start path has no trailing separator (a \"file\" path), then drop file segment if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1); // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = \"\"; if (!targetPath.endsWith(SEPARATOR)) { targetFile = target[target.length - 1]; target = Arrays.copyOfRange(target, 0, target.length - 1); } // Work out how much of the filepath is shared by start and path. String[] common = commonPrefix(start, target); String[] parents = toParentDirs(start.length - common.length); int relativeStartIdx = common.length; String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length); String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length); System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length); // If this is not a sibling reference append a trailing / to path String trailingSep = \"\"; if (relativePath.length > 0) trailingSep = SEPARATOR; return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR)) + trailingSep + targetFile; }\n\n    ### Response:", "ground_truth": "Create a path to targetPath that's relative to the given startPath.", "predict": " Generate a relative path from the start path to the target path.\n\n@param startPath\n@param targetPath\n@return relative path."}, {"ID": 590, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String checkinScriptCommand() { String exportModules = \"\"; if ((m_modulesToExport != null) && !m_modulesToExport.isEmpty()) { StringBuffer exportModulesParam = new StringBuffer(); for (String moduleName : m_modulesToExport) { exportModulesParam.append(\" \").append(moduleName); } exportModulesParam.replace(0, 1, \" \\\"\"); exportModulesParam.append(\"\\\" \"); exportModules = \" --modules \" + exportModulesParam.toString(); } String commitMessage = \"\"; if (m_commitMessage != null) { commitMessage = \" -msg \\\"\" + m_commitMessage.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\"; } String gitUserName = \"\"; if (m_gitUserName != null) { if (m_gitUserName.trim().isEmpty()) { gitUserName = \" --ignore-default-git-user-name\"; } else { gitUserName = \" --git-user-name \\\"\" + m_gitUserName + \"\\\"\"; } } String gitUserEmail = \"\"; if (m_gitUserEmail != null) { if (m_gitUserEmail.trim().isEmpty()) { gitUserEmail = \" --ignore-default-git-user-email\"; } else { gitUserEmail = \" --git-user-email \\\"\" + m_gitUserEmail + \"\\\"\"; } } String autoPullBefore = \"\"; if (m_autoPullBefore != null) { autoPullBefore = m_autoPullBefore.booleanValue() ? \" --pull-before \" : \" --no-pull-before\"; } String autoPullAfter = \"\"; if (m_autoPullAfter != null) { autoPullAfter = m_autoPullAfter.booleanValue() ? \" --pull-after \" : \" --no-pull-after\"; } String autoPush = \"\"; if (m_autoPush != null) { autoPush = m_autoPush.booleanValue() ? \" --push \" : \" --no-push\"; } String exportFolder = \" --export-folder \\\"\" + m_currentConfiguration.getModuleExportPath() + \"\\\"\"; String exportMode = \" --export-mode \" + m_currentConfiguration.getExportMode(); String excludeLibs = \"\"; if (m_excludeLibs != null) { excludeLibs = m_excludeLibs.booleanValue() ? \" --exclude-libs\" : \" --no-exclude-libs\"; } String commitMode = \"\"; if (m_commitMode != null) { commitMode = m_commitMode.booleanValue() ? \" --commit\" : \" --no-commit\"; } String ignoreUncleanMode = \"\"; if (m_ignoreUnclean != null) { ignoreUncleanMode = m_ignoreUnclean.booleanValue() ? \" --ignore-unclean\" : \" --no-ignore-unclean\"; } String copyAndUnzip = \"\"; if (m_copyAndUnzip != null) { copyAndUnzip = m_copyAndUnzip.booleanValue() ? \" --copy-and-unzip\" : \" --no-copy-and-unzip\"; } String configFilePath = m_currentConfiguration.getFilePath(); return \"\\\"\" + DEFAULT_SCRIPT_FILE + \"\\\"\" + exportModules + commitMessage + gitUserName + gitUserEmail + autoPullBefore + autoPullAfter + autoPush + exportFolder + exportMode + excludeLibs + commitMode + ignoreUncleanMode + copyAndUnzip + \" \\\"\" + configFilePath + \"\\\"\"; }\n\n    ### Response: Returns the command to run by the shell to normally run the checkin script.\n@return the command to run by the shell to normally run the checkin script..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String canonical(String url) { String[] urlPath = toSegments(url); Stack<String> canonical = new Stack<>(); for (String comp : urlPath) { if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue; if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp); else canonical.pop(); } String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\"; String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\"; return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep; }\n\n    ### Response:", "ground_truth": "Create a canonical path that does not contain parent directories, current directories, or\nsuperfluous directory separators.", "predict": " Returns the canonical form of the specified URL.\n@param url the URL to be converted to its canonical form\n@return the canonical form of the specified URL."}, {"ID": 591, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ImmutableMultimap<RelationDefinition, ExtensionalDataNode> extractDataNodeMap(IntermediateQuery query, InnerJoinNode joinNode) { return query.getChildren(joinNode).stream() .filter(c -> c instanceof ExtensionalDataNode) .map(c -> (ExtensionalDataNode) c) .map(c -> Maps.immutableEntry(c.getProjectionAtom().getPredicate().getRelationDefinition(), c)) .collect(ImmutableCollectors.toMultimap()); }\n\n    ### Response: Predicates not having a DatabaseRelationDefinition are ignored.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); }\n\n    ### Response:", "ground_truth": "Converts a set of constraints to human-readable values. Does not guarantee the order of the\nreturned constraints.\n\nThis method calls {@code displayableConstraint} under the hood.\n\n@param constraints the set of constraint descriptors.\n@return a list of pairs of tuples assembled from displayableConstraint.", "predict": " Returns a list of tuples, where the first element is the constraint name and the second element is a list of constraint values. The constraint values are converted to strings and wrapped in a list."}, {"ID": 592, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, List<Object>> buildMutableAttributeMap(final Map<String, List<Object>> attributes) { final Map<String, List<Object>> mutableValuesBuilder = this.createMutableAttributeMap(attributes.size()); for (final Map.Entry<String, List<Object>> attrEntry : attributes.entrySet()) { final String key = attrEntry.getKey(); List<Object> value = attrEntry.getValue(); if (value != null) { value = new ArrayList<>(value); } mutableValuesBuilder.put(key, value); } return mutableValuesBuilder; }\n\n    ### Response: Do a deep clone of an attribute Map to ensure it is completley mutable.\n\n@param attributes Attribute map\n@return Mutable attribute map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Tuple<String, List<Object>> displayableConstraint( ConstraintDescriptor<?> constraint) { final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class); return Tuple( displayAnnotation.name(), Collections.unmodifiableList( Stream.of(displayAnnotation.attributes()) .map(attr -> constraint.getAttributes().get(attr)) .collect(Collectors.toList()))); }\n\n    ### Response:", "ground_truth": "Converts a constraint to a human-readable value.\n\n@param constraint the constraint descriptor.\n@return A tuple containing the constraint's display name and the constraint attributes.", "predict": " Get the display name and attributes of a constraint descriptor.\n\n@param constraint Constraint descriptor\n@return Tuple of display name and attributes."}, {"ID": 593, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> ComposableFuture<T> withTimeout(final ComposableFuture<T> future, final long duration, final TimeUnit unit) { return future.withTimeout(SchedulerServiceHolder.INSTANCE, duration, unit); }\n\n    ### Response: adds a time cap to the provided future.\nif response do not arrive after the specified time a TimeoutException is returned from the returned future.\n\n@param future   the source future\n@param duration time duration before emitting a timeout\n@param unit     the duration time unit\n@param       the future type\n@return a new future with a timeout.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); }\n\n    ### Response:", "ground_truth": "Creates a CompletionStage that returns either the input stage, or a futures.\n\nNote that timeout is not the same as cancellation. Even in case of futures, the given\ncompletion stage will still complete, even though that completed value is not returned.\n\n@param stage the input completion stage that may time out.\n@param amount The amount (expressed with the corresponding unit).\n@param unit The time Unit.\n@param  the completion's result type.\n@return either the completed future, or a completion stage that failed with futures.", "predict": "overrides the timeout method of the CompletionStage interface to add a time cap to the provided completion stage.\nif response do not arrive after the specified time a TimeoutException is returned from the returned completion stage.\n\n@param stage   the source completion stage\n@param amount  time duration before emitting a timeout\n@param unit    the duration time unit\n@param        the completion stage type\n@return a new completion stage with a timeout."}, {"ID": 594, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean areMethodNameAndParameterTypesEqual(Method methodA, Method methodB) { if (!methodA.getName().equals(methodB.getName())) { return false; } Class<?>[] methodAParameterTypes = methodA.getParameterTypes(); Class<?>[] methodBParameterTypes = methodB.getParameterTypes(); if (methodAParameterTypes.length != methodBParameterTypes.length) { return false; } for (int i = 0; i < methodAParameterTypes.length; i++) { if (!methodAParameterTypes[i].equals(methodBParameterTypes[i])) { return false; } } return true; }\n\n    ### Response: Compares to methods for equality based on name and parameter types..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAssignable( Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) { return false; } if (classArray == null) { classArray = EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Checks if an array of Classes can be assigned to another array of Classes.\n\nThis method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in\nthe input arrays. It can be used to check if a set of arguments (the first parameter) are\nsuitably compatible with a set of method parameter types (the second parameter).\n\nUnlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into\naccount widenings of primitive classes and {@code null}s.\n\nPrimitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code\ndouble}. This method returns the correct result for these cases.\n\n{@code Null} may be assigned to any reference type. This method will return {@code true} if\n{@code null} is passed in and the toClass is non-primitive.\n\nSpecifically, this method tests whether the type represented by the specified {@code Class}\nparameter can be converted to the type represented by this {@code Class} object via an identity\nconversion widening primitive or widening reference conversion. See The Java Language Specification, sections\n5.1.1, 5.1.2 and 5.1.4 for details.\n\n@param classArray the array of Classes to check, may be {@code null}\n@param toClassArray the array of Classes to try to assign into, may be {@code null}\n@param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n@return {@code true} if assignment possible", "predict": " Checks if the classArray is assignable to the toClassArray. If autoboxing is true, it will also check if the classArray can be assigned to the toClassArray by unboxing."}, {"ID": 595, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AlluxioStatusException fromCheckedException(Throwable throwable) { try { throw throwable; } catch (IOException e) { return fromIOException(e); } catch (AlluxioException e) { return fromAlluxioException(e); } catch (InterruptedException e) { return new CancelledException(e); } catch (RuntimeException e) { throw new IllegalStateException(\"Expected a checked exception but got \" + e); } catch (Exception e) { return new UnknownException(e); } catch (Throwable t) { throw new IllegalStateException(\"Expected a checked exception but got \" + t); } }\n\n    ### Response: Converts checked throwables to Alluxio status exceptions. Unchecked throwables should not be\npassed to this method. Use Throwables.propagateIfPossible before passing a Throwable to this\nmethod.\n\n@param throwable a throwable\n@return the converted {@link AlluxioStatusException}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Date parseCRONExpression(String cron) { try { return new CronExpression(cron).getNextValidTimeAfter(new Date()); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } }\n\n    ### Response:", "ground_truth": "Parses a CRON expression.\n\n@param cron the CRON String\n@return the next Date that satisfies the expression", "predict": " Parses a CRON expression and returns the next valid date.\n\n@param cron the CRON expression to parse\n@return the next valid date\n@throws IllegalArgumentException if the CRON expression is invalid"}, {"ID": 596, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AlluxioStatusException fromCheckedException(Throwable throwable) { try { throw throwable; } catch (IOException e) { return fromIOException(e); } catch (AlluxioException e) { return fromAlluxioException(e); } catch (InterruptedException e) { return new CancelledException(e); } catch (RuntimeException e) { throw new IllegalStateException(\"Expected a checked exception but got \" + e); } catch (Exception e) { return new UnknownException(e); } catch (Throwable t) { throw new IllegalStateException(\"Expected a checked exception but got \" + t); } }\n\n    ### Response: Converts checked throwables to Alluxio status exceptions. Unchecked throwables should not be\npassed to this method. Use Throwables.propagateIfPossible before passing a Throwable to this\nmethod.\n\n@param throwable a throwable\n@return the converted {@link AlluxioStatusException}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long cronInterval(String cron, Date date) { try { return new CronExpression(cron).getNextInterval(date); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } }\n\n    ### Response:", "ground_truth": "Compute the number of milliseconds between the next valid date and the one after.\n\n@param cron the CRON String\n@param date the date to start search\n@return the number of milliseconds between the next valid date and the one after, with an\ninvalid interval between", "predict": " Computes the next interval of the given CRON expression starting from the given date.\n\n@param cron the CRON expression\n@param date the starting date\n@return the next interval in milliseconds\n@throws IllegalArgumentException if the CRON expression is invalid"}, {"ID": 597, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private IndexInfos createIndexInfos(Boolean system, IndexerIoModeHandler modeHandler, QueryHandlerEntry config, QueryHandler handler) throws RepositoryConfigurationException { try { // read RSYNC configuration RSyncConfiguration rSyncConfiguration = new RSyncConfiguration(config); // rsync configured if (rSyncConfiguration.getRsyncEntryName() != null) { return new RsyncIndexInfos(wsId, cache, system, modeHandler, handler.getContext() .getIndexDirectory(), rSyncConfiguration); } else { return new ISPNIndexInfos(wsId, cache, true, modeHandler); } } catch (RepositoryConfigurationException e) { return new ISPNIndexInfos(wsId, cache, true, modeHandler); } }\n\n    ### Response: Factory method for creating corresponding IndexInfos class. RSyncIndexInfos created if RSync configured\nand ISPNIndexInfos otherwise\n\n@param system\n@param modeHandler\n@param config\n@param handler\n@return\n@throws RepositoryConfigurationException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); }\n\n    ### Response:", "ground_truth": "Creates WS client manually from configuration, internally creating a new instance of\nAsyncHttpClient and managing its own thread pool.\n\nThis client is not managed as part of Play's lifecycle, and must be closed by calling\nws.close(), otherwise you will run into memory leaks.\n\n@param config a config object, usually from AhcWSClientConfigFactory\n@param cache if not null, provides HTTP caching.\n@param materializer an Akka materializer\n@return a new instance of AhcWSClient.", "predict": " Factory method for creating AhcWSClient.\n\n@param config\n@param cache\n@param materializer\n@return AhcWSClient instance."}, {"ID": 598, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void configure() { bind(Controller.class) .to(new AnnotationVisitorFactory() { public AnnotationVisitor newAnnotationVisitor(BindingContext context) { return new WisdomControllerVisitor(context.getWorkbench(), context.getReporter()); } }); bind(Service.class) .to(new AnnotationVisitorFactory() { public AnnotationVisitor newAnnotationVisitor(BindingContext context) { return new WisdomServiceVisitor(context.getWorkbench(), context.getReporter()); } }); bind(View.class) .when(on(ElementType.FIELD)) .to(new AnnotationVisitorFactory() { public AnnotationVisitor newAnnotationVisitor(BindingContext context) { return new WisdomViewVisitor(context.getWorkbench(), context.getReporter(), context.getFieldNode()); } }); bind(Model.class) .when(on(ElementType.FIELD)) .to(new AnnotationVisitorFactory() { public AnnotationVisitor newAnnotationVisitor(BindingContext context) { return new WisdomModelVisitor(context.getWorkbench(), context.getReporter(), context.getFieldNode()); } }); }\n\n    ### Response: Adds the Wisdom annotation to the iPOJO manipulator..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder builder(ApplicationLoader.Context context) { return initialBuilder .in(context.environment()) .loadConfig(context.initialConfig()) .overrides(overrides(context)); }\n\n    ### Response:", "ground_truth": "Construct a builder to use for loading the given context.\n\n@param context the context the returned builder will load\n@return the builder", "predict": " Initializes the Guice application builder with the specified environment and configuration."}, {"ID": 599, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Result findResultWithMaxEnd(List<Result> successResults) { return Collections.max( successResults, new Comparator<Result>() { @Override public int compare(Result o1, Result o2) { return Integer.valueOf(o1.end()).compareTo(o2.end()); } }); }\n\n    ### Response: Find the result with the maximum end position and use it as delegate..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); }\n\n    ### Response:", "ground_truth": "Generates a 501 NOT_IMPLEMENTED simple result.", "predict": " This method is not implemented yet. It should return a result with a status code of NOT_IMPLEMENTED and a view of the TODO page."}, {"ID": 600, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProperty(String key, String value) { local.get().cc.setProperty(key, value); }\n\n    ### Response: Sets the property to the configuration\n@param key\n@param value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static void session(String key, String value) { session().put(key, value); }\n\n    ### Response:", "ground_truth": "Puts a new value into the current session.\n\n@param key the key to set into the session\n@param value the value to set for key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " Saves the key-value pair in the session object\n@param key\n@param value."}, {"ID": 601, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void flash(String name, String value) { /*if (session().get(Context.FLASH_SESSION_KEYWORD) == null) { session().put(Context.FLASH_SESSION_KEYWORD, new HashMap<String, Object>()); } ((Map<String, Object>) session().get(Context.FLASH_SESSION_KEYWORD)).put(name, value);*/ //context.setFlash(name, value); context.getFlash().put(name, value); }\n\n    ### Response: Sends value to flash. Flash survives one more request.  Using flash is typical\nfor POST->REDIRECT->GET pattern,\n\n@param name name of value to flash\n@param value value to live for one more request in current session..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static void flash(String key, String value) { flash().put(key, value); }\n\n    ### Response:", "ground_truth": "Puts a new value into the flash scope.\n\n@param key the key to put into the flash scope\n@param value the value corresponding to key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": "Deprecated method. Use flash(String name, String value) instead.\n\n    "}, {"ID": 602, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> A annotation(Class<A> annotationClass) { return field.getAnnotation(annotationClass); }\n\n    ### Response: Returns the annotation instance for the given annotation type.\n\n@param annotationClass Tha annotation type to retrieve.\n@param  Type of the annotation.\n@return The annotation instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); }\n\n    ### Response:", "ground_truth": "Qualify this binding key with the given instance of an annotation.\n\nThis can be used to specify bindings with annotations that have particular values.", "predict": " Returns a new BindingKey with the given annotation instance added to the qualifiers.\n\n@param instance The annotation instance to add to the qualifiers.\n@param  Type of the annotation.\n@return A new BindingKey with the given annotation instance added to the qualifiers."}, {"ID": 603, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <A extends Annotation, AS extends Annotation> void registerInjectionProcessor (Class<? extends InjectionProcessor<A, AS>> processor, Class<A> annotation) throws InjectionException { if (OverrideInjectionProcessor.class.isAssignableFrom(processor)) // RTC114863 { throw new IllegalArgumentException(\"OverrideInjectionProcessor must be registered with an InjectionProcessorProvider\"); } registerInjectionProcessorProvider(new InjectionProcessorProviderImpl<A, AS>(annotation, processor)); }\n\n    ### Response: Registers the specified processor with the injection engine.\n\nIf a processor was already registered with the specified annotation, that class will be returned\notherwise a null will be returned.\n\n@param processor The processor class to be registered\n@param annotation The annotation class the processor is associated.\n@throws InjectionException if the provider is already registered.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation).asJava(); }\n\n    ### Response:", "ground_truth": "Qualify this binding key with the given annotation.\n\nFor example, you may have both a cached implementation, and a direct implementation of a\nservice. To differentiate between them, you may define a Cached annotation:\n\n{@code\nbindClass(Foo.class).qualifiedWith(Cached.class).to(FooCached.class),\nbindClass(Foo.class).to(FooImpl.class)\n\n...\n\nclass MyController {\n{@literal @}Inject\nMyController({@literal @}Cached Foo foo) {\n...\n}\n...\n}\n}\n\nIn the above example, the controller will get the cached {@code Foo} service.", "predict": "Returns a new BindingKey that is qualified with the specified annotation.\n\n@param annotation The annotation to qualify the BindingKey with.\n@return A new BindingKey that is qualified with the specified annotation."}, {"ID": 604, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isApplicable(Class<? extends T> targetType) { Class<? extends T> applicable = Functions.getTypeParameter(clazz,getP(),0); return applicable.isAssignableFrom(targetType); }\n\n    ### Response: Returns true if this property type is applicable to the\ngiven target type.\n\n\nThe default implementation of this method checks if the given node type is assignable\naccording to the parameterization, but subtypes can extend this to change this behavior.\n\n@return\ntrue to indicate applicable, in which case the property will be\ndisplayed in the configuration screen of the target, for example..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given implementation class.\n\nThis class will be instantiated and injected by the injection framework.", "predict": " Binds this property to the given implementation type.\n\n\nThe default implementation of this method creates a new binding with the given implementation\ntype, but subtypes can extend this to change this behavior.\n\n@param implementation\nthe implementation type to bind to\n@return\nthe new binding\n"}, {"ID": 605, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final <T> T fold(Function<? super L, ? extends T> left, Function<? super R, ? extends T> right) { if (isLeft()) { return left.apply(getLeft()); } else { return right.apply(getRight()); } }\n\n    ### Response: Applies either the left or the right function as appropriate..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given provider instance.\n\nThis provider instance will be invoked to obtain the implementation for the key.", "predict": " Binds the underlying value to the given provider and returns a Java Binding."}, {"ID": 606, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> A annotation(Class<A> annotationClass) { return field.getAnnotation(annotationClass); }\n\n    ### Response: Returns the annotation instance for the given annotation type.\n\n@param annotationClass Tha annotation type to retrieve.\n@param  Type of the annotation.\n@return The annotation instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given instance.", "predict": " Binds the given instance to the underlying binder.\n\n@param instance The instance to bind.\n@param <A> The type of the instance.\n@return The bound binding."}, {"ID": 607, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final <T> T fold(Function<? super L, ? extends T> left, Function<? super R, ? extends T> right) { if (isLeft()) { return left.apply(getLeft()); } else { return right.apply(getRight()); } }\n\n    ### Response: Applies either the left or the right function as appropriate..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to another binding key.", "predict": " Binds the underlying Scala Binding to the specified Java BindingKey."}, {"ID": 608, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <P extends Parameterizable> Set<P> getParameterizables(Package javaPackage, Class<P> clazz) throws IOException, FileNotFoundException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Set<P> parameterizables = new HashSet<>(50); for (Class<?> c : ClassHelper.fromPackage(javaPackage)) { if (clazz.isAssignableFrom(c) && !Modifier.isAbstract(c.getModifiers())) { P p = (P) c.newInstance(); ParamAnnotationProcessor.PAP.initParameters(p); parameterizables.add(p); } } return parameterizables; }\n\n    ### Response: Use this generic method in for example a gui that supports building a styling file.\n\n@param \n@param javaPackage\n@param clazz\n@return\n@throws IOException\n@throws FileNotFoundException\n@throws ClassNotFoundException\n@throws InstantiationException\n@throws IllegalAccessException\n@throws NoSuchMethodException\n@throws InvocationTargetException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) { return underlying.toProvider(provider).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given provider class.\n\nThe dependency injection framework will instantiate and inject this provider, and then\ninvoke its `get` method whenever an instance of the class is needed.", "predict": " This method is used to bind a type to a provider.\n\n@param <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider)\n\n    "}, {"ID": 609, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func Parse(src string) []*Language { var langs []*Language start := 0 for end, chr := range src { switch chr { case ',', ';', '.': tag := strings.TrimSpace(src[start:end]) if spec := GetPluralSpec(tag); spec != nil { langs = append(langs, &Language{NormalizeTag(tag), spec}) } start = end + 1 } } if start > 0 { tag := strings.TrimSpace(src[start:]) if spec := GetPluralSpec(tag); spec != nil { langs = append(langs, &Language{NormalizeTag(tag), spec}) } return dedupe(langs) } if spec := GetPluralSpec(src); spec != nil { langs = append(langs, &Language{NormalizeTag(src), spec}) } return langs }\n\n    ### Response: // Parse returns a slice of supported languages found in src or nil if none are found.\n// It can parse language tags and Accept-Language headers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Lang> availables(Application app) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables()); return availableLangs.stream().map(Lang::new).collect(toList()); }\n\n    ### Response:", "ground_truth": "Retrieve Lang availables from the application configuration.\n\n@param app the current application.\n@return the list of available Lang.", "predict": " // availables returns a list of available languages for the given application.\n// It uses the Langs component of the play framework to retrieve the available languages."}, {"ID": 610, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Predicate<Credential> newCredentialSelectionPredicate(final String selectionCriteria) { try { if (StringUtils.isBlank(selectionCriteria)) { return credential -> true; } if (selectionCriteria.endsWith(\".groovy\")) { val loader = new DefaultResourceLoader(); val resource = loader.getResource(selectionCriteria); val script = IOUtils.toString(resource.getInputStream(), StandardCharsets.UTF_8); val clz = AccessController.doPrivileged((PrivilegedAction<Class<Predicate>>) () -> { val classLoader = new GroovyClassLoader(Beans.class.getClassLoader(), new CompilerConfiguration(), true); return classLoader.parseClass(script); }); return clz.getDeclaredConstructor().newInstance(); } val predicateClazz = ClassUtils.getClass(selectionCriteria); return (Predicate<org.apereo.cas.authentication.Credential>) predicateClazz.getDeclaredConstructor().newInstance(); } catch (final Exception e) { val predicate = Pattern.compile(selectionCriteria).asPredicate(); return credential -> predicate.test(credential.getId()); } }\n\n    ### Response: Gets credential selection predicate.\n\n@param selectionCriteria the selection criteria\n@return the credential selection predicate.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); }\n\n    ### Response:", "ground_truth": "Guess the preferred lang in the langs set passed as argument. The first Lang that matches an\navailable Lang wins, otherwise returns the first Lang available in this application.\n\n@param app the currept application\n@param availableLangs the set of langs from which to guess the preferred\n@return the preferred lang.", "predict": " Gets preferred language for the given application and available languages.\n\n@param app the application\n@param availableLangs the available languages\n@return the preferred language for the given application and available languages."}, {"ID": 611, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static IAttributeMerger getAttributeMerger(final String mergingPolicy) { switch (mergingPolicy.toLowerCase()) { case \"multivalued\": case \"multi_valued\": case \"combine\": return new MultivaluedAttributeMerger(); case \"add\": return new NoncollidingAttributeAdder(); case \"replace\": case \"overwrite\": case \"override\": return new ReplacingAttributeAdder(); default: return new BaseAdditiveAttributeMerger() { @Override protected Map<String, List<Object>> mergePersonAttributes(final Map<String, List<Object>> toModify, final Map<String, List<Object>> toConsider) { return new LinkedHashMap<>(toModify); } }; } }\n\n    ### Response: Gets attribute merger.\n\n@param mergingPolicy the merging policy\n@return the attribute merger.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); }\n\n    ### Response:", "ground_truth": "Create an evolutions reader based on a simple map of database names to evolutions.\n\n@param evolutions The map of database names to evolutions.\n@return the evolutions reader.", "predict": " Creates a new EvolutionsReader from a map of evolutions.\n\n@param evolutions the map of evolutions\n@return the new EvolutionsReader"}, {"ID": 612, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, Object> from(Pair... pairs) { Map<String, Object> map = new HashMap<String, Object>(pairs.length); for (Pair p : pairs) { map.put(p.key, p.value); } return map; }\n\n    ### Response: construct me from the given pairs\n@param pairs\n@return the map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); }\n\n    ### Response:", "ground_truth": "Create an evolutions reader for the default database from a list of evolutions.\n\n@param evolutions The list of evolutions.\n@return the evolutions reader.", "predict": " construct me from the given evolutions\n@param evolutions\n@return the evolutions reader."}, {"ID": 613, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void generate(Elements elementUtils, Filer filer, SQLiteDatabaseSchema schema) throws Exception { BindDaoFactoryBuilder visitor = new BindDaoFactoryBuilder(elementUtils, filer, schema); visitor.buildDaoFactoryInterface(elementUtils, filer, schema); String daoFactoryName = BindDaoFactoryBuilder.generateDaoFactoryName(schema); BindDataSourceBuilder visitorDao = new BindDataSourceBuilder(elementUtils, filer, schema); visitorDao.buildDataSource(elementUtils, filer, schema, daoFactoryName); generateSchema(schema); }\n\n    ### Response: Generate database.\n\n@param elementUtils\nthe element utils\n@param filer\nthe filer\n@param schema\nthe schema\n@throws Exception\nthe exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cleanupEvolutions(Database database, boolean autocommit, String schema) { DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema); evolutions.evolve(evolutions.resetScripts(), autocommit); }\n\n    ### Response:", "ground_truth": "Cleanup evolutions for the given database.\n\nThis will run the down scripts for all the applied evolutions.\n\n@param database The database to apply the evolutions to.\n@param autocommit Whether autocommit should be used.\n@param schema The schema where all the play evolution tables are saved in", "predict": " Clean up evolutions.\n\n@param database\nthe database\n@param autocommit\nthe autocommit\n@param schema\nthe schema"}, {"ID": 614, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Builder newBuilder( TableId destinationTable, List<String> sourceUris, FormatOptions format) { return newBuilder(destinationTable, sourceUris).setFormatOptions(format); }\n\n    ### Response: Creates a builder for a BigQuery Load Job configuration given the destination table, format and\nsource URIs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); }\n\n    ### Response:", "ground_truth": "Set the initial configuration loader. Overrides the default or any previously configured\nvalues.\n\n@param load the configuration loader\n@return the configured application builder", "predict": " Configures the GuiceApplicationBuilder with a custom ConfigLoader that loads the application configuration from a custom ConfigLoader function."}, {"ID": 615, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Builder newBuilder( TableId destinationTable, List<String> sourceUris, FormatOptions format) { return newBuilder(destinationTable, sourceUris).setFormatOptions(format); }\n\n    ### Response: Creates a builder for a BigQuery Load Job configuration given the destination table, format and\nsource URIs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); }\n\n    ### Response:", "ground_truth": "Set the module loader. Overrides the default or any previously configured values.\n\n@param loader the configuration\n@return the configured application builder", "predict": " Configures the Guice application builder with a custom module loader. The loader function takes an Environment and Configuration object and returns a list of GuiceableModule objects. The modules are loaded and bound to the Guice application."}, {"ID": 616, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"static-method\") public Injector createInjector(Module... modules) { return Guice.createInjector(Modules.override(new SARLRuntimeModule()).with(modules)); }\n\n    ### Response: Create the injectors based on the given set of modules.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given guiceable modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Load the given set of modules into the application builder.\n\n@param modules the modules to load.\n@return the application builder.\n@since 0.8\n@see GuiceableModule."}, {"ID": 617, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"static-method\") public Injector createInjector(Module... modules) { return Guice.createInjector(Modules.override(new SARLRuntimeModule()).with(modules)); }\n\n    ### Response: Create the injectors based on the given set of modules.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(com.google.inject.Module... modules) { return load(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Guice modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Load the given set of modules into the application builder.\n\n@param modules the injection modules to load.\n@return the application builder.\n@since 0.8\n@see Guiceable.modules(Module...)."}, {"ID": 618, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"static-method\") public Injector createInjector(Module... modules) { return Guice.createInjector(Modules.override(new SARLRuntimeModule()).with(modules)); }\n\n    ### Response: Create the injectors based on the given set of modules.\n\n@param modules the injection modules that are overriding the standard SARL module.\n@return the injector.\n@since 0.8\n@see SARLRuntimeModule.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(play.api.inject.Module... modules) { return load(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Play modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Load the given set of modules into the application builder.\n\n@param modules the modules to load.\n@return the application builder.\n@since 0.8\n@see Guiceable.modules(Module...)."}, {"ID": 619, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SPARQLBindings getSPARQLBindings(SPARQLQueryBindingSet bindings) { SPARQLBindings sps = new SPARQLBindingsImpl(); for (Binding binding : bindings) { sps.bind(binding.getName(), binding.getValue().stringValue()); } return sps; }\n\n    ### Response: converts Sesame BindingSet to java api client SPARQLBindings\n\n@param bindings\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Play bindings.\n\n@param bindings the set of binding override\n@return an application builder that incorporates the overrides", "predict": " loads Guice bindings into the application builder.\n\n@param bindings the Guice bindings to load.\n@return the application builder with the Guice bindings loaded."}, {"ID": 620, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String qualifyType(VisitorState state, SuggestedFix.Builder fix, TypeMirror type) { return type.accept( new SimpleTypeVisitor8<String, SuggestedFix.Builder>() { @Override protected String defaultAction(TypeMirror e, Builder builder) { return e.toString(); } @Override public String visitArray(ArrayType t, Builder builder) { return t.getComponentType().accept(this, builder) + \"[]\"; } @Override public String visitDeclared(DeclaredType t, Builder builder) { String baseType = qualifyType(state, builder, ((Type) t).tsym); if (t.getTypeArguments().isEmpty()) { return baseType; } StringBuilder b = new StringBuilder(baseType); b.append('<'); boolean started = false; for (TypeMirror arg : t.getTypeArguments()) { if (started) { b.append(','); } b.append(arg.accept(this, builder)); started = true; } b.append('>'); return b.toString(); } }, fix); }\n\n    ### Response: Returns a human-friendly name of the given type for use in fixes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); }\n\n    ### Response:", "ground_truth": "Implementation of Self creation for GuiceBuilder.\n\n@return the application builder", "predict": " Creates a new GuiceApplicationBuilder with the given builder as the parent.\n\n    "}, {"ID": 621, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(URI uri, HttpCookie cookie) { // pre-condition : argument can't be null if (cookie == null) { throw new NullPointerException(\"cookie is null\"); } lock.lock(); try { if (cookie.getMaxAge() != 0) { addIndex(uriIndex, getEffectiveURI(uri), cookie); } } finally { lock.unlock(); } }\n\n    ### Response: Add one cookie into cookie store..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); encode(buf, cookie); return stripTrailingSeparator(buf); }\n\n    ### Response:", "ground_truth": "Encodes the specified cookie into a Cookie header value.\n\n@param cookie specified the cookie\n@return a Rfc6265 style Cookie header value", "predict": " Encode a cookie into a string.\n\n    "}, {"ID": 622, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private EntityManager getEM() throws IllegalStateException { if (!open) { throw new IllegalStateException(\"The JPA bridge has closed\"); } try { // Do we already have one on this thread? EntityManager em = perThreadEntityManager.get(); if (em != null) { return em; } // Nope, so we need to check if there actually is a transaction final Transaction transaction = transactionManager.getTransaction(); if (transaction == null) { throw new TransactionRequiredException(\"Cannot create an EM since no transaction active\"); } em = entityManagerFactory.createEntityManager(); try { // Register a callback at the end of the transaction transaction.registerSynchronization(new Synchronization() { @Override public void beforeCompletion() { if (!open) { throw new IllegalStateException( \"The Transaction Entity Manager was closed in the mean time\"); } } @Override public void afterCompletion(int arg0) { EntityManager em = perThreadEntityManager.get(); perThreadEntityManager.set(null); em.close(); } }); } catch (Exception e) { em.close(); throw new IllegalStateException(\"Registering synchronization to close EM\", e); } // Make it available for later calls on this thread perThreadEntityManager.set(em); // And make sure it joins the current transaction. em.joinTransaction(); return em; } catch (Exception e) { throw new IllegalStateException(\"Error while retrieving entity manager\", e); } }\n\n    ### Response: The delegated methods call this method to get the delegate. This method\nverifies if we're still open, if there already is an Entity Manager for\nthis thread and otherwise creates it and enlists it for auto close at the\ncurrent transaction.\n\n@return an Entity Manager.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EntityManager em() { Deque<EntityManager> ems = this.emStack(true); if (ems.isEmpty()) { Http.Context.safeCurrent() .map( ctx -> { throw new RuntimeException( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\"); }) .orElseGet( () -> { throw new RuntimeException( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\"); }); } return ems.peekFirst(); }\n\n    ### Response:", "ground_truth": "Get the default EntityManager for this thread.\n\n@throws RuntimeException if no EntityManager is bound to the current Http.Context or the\ncurrent Thread.\n@return the EntityManager", "predict": " This method retrieves the EntityManager from the context or throws an exception if it's not found. It uses a stack to keep track of the EntityManagers created during the request, so that they can be closed at the end of the request.\n\n@return an Entity Manager."}, {"ID": 623, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings(\"unchecked\") public Spliterator<E_OUT> spliterator() { if (linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; if (this == sourceStage) { if (sourceStage.sourceSpliterator != null) { @SuppressWarnings(\"unchecked\") Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSpliterator; sourceStage.sourceSpliterator = null; return s; } else if (sourceStage.sourceSupplier != null) { @SuppressWarnings(\"unchecked\") Supplier<Spliterator<E_OUT>> s = (Supplier<Spliterator<E_OUT>>) sourceStage.sourceSupplier; sourceStage.sourceSupplier = null; return lazySpliterator(s); } else { throw new IllegalStateException(MSG_CONSUMED); } } else { return wrap(this, () -> sourceSpliterator(0), isParallel()); } }\n\n    ### Response: Primitive specialization use co-variant overrides, hence is not final.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Deque<EntityManager> emStack(boolean threadLocalFallback) { return Http.Context.safeCurrent() .map( context -> { Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER); if (emsObject != null) { return (Deque<EntityManager>) emsObject; } else { Deque<EntityManager> ems = new ArrayDeque<>(); context.args.put(CURRENT_ENTITY_MANAGER, ems); return ems; } }) .orElseGet( () -> { // Not a web request if (threadLocalFallback) { return this.get(); } else { throw new RuntimeException( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\"); } }); }\n\n    ### Response:", "ground_truth": "Get the EntityManager stack.\n\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.\n@return the queue of entity managers.", "predict": " This method returns a deque of entity managers. It first checks if there is a Http.Context present, and if so, it retrieves the deque of entity managers from the context. If there is no Http.Context present, it checks if threadLocalFallback is true, and if so, it returns the deque of entity managers stored in the thread local. If threadLocalFallback is false, it throws a RuntimeException."}, {"ID": 624, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void process() throws InterruptedException { boolean alreadyInSync = Thread.currentThread() instanceof WebcamProcessor.ProcessorThread; if (alreadyInSync) { handle(); } else { if (doSync) { if (processor == null) { throw new RuntimeException(\"Driver should be synchronized, but processor is null\"); } processor.process(this); } else { handle(); } } }\n\n    ### Response: Process task by processor thread.\n\n@throws InterruptedException when thread has been interrupted.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } }\n\n    ### Response:", "ground_truth": "Pushes or pops the EntityManager stack depending on the value of the em argument. If em is\nnull, then the current EntityManager is popped. If em is non-null, then em is pushed onto the\nstack and becomes the current EntityManager.\n\n@param em the entity manager to push, if null then will pop one off the stack.\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.", "predict": " Push or pop the EntityManager from the thread-local stack.\n\n@param em the EntityManager to push or pop, or null to remove the top of the stack.\n@param threadLocalFallback whether to use the thread-local stack as a fallback if the stack for the current thread is empty."}, {"ID": 625, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AbstractBuild<?, ?> getRootBuild(AbstractBuild<?, ?> currentBuild) { AbstractBuild<?, ?> rootBuild = null; AbstractBuild<?, ?> parentBuild = getUpstreamBuild(currentBuild); while (parentBuild != null) { if (isPassIdentifiedDownstream(parentBuild)) { rootBuild = parentBuild; } parentBuild = getUpstreamBuild(parentBuild); } if (rootBuild == null && isPassIdentifiedDownstream(currentBuild)) { return currentBuild; } return rootBuild; }\n\n    ### Response: Get the root build which triggered the current build. The build root is considered to be the one furthest one\naway from the current build which has the isPassIdentifiedDownstream active, if no parent build exists, check\nthat the current build needs an upstream identifier, if it does return it.\n\n@param currentBuild The current build.\n@return The root build with isPassIdentifiedDownstream active. Null if no upstream or non is found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) { return bypassWith( Flow.<In>create().map(splitter::apply), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), flow); }\n\n    ### Response:", "ground_truth": "Bypass the given flow using the given splitter function.\n\nIf the splitter function returns Left, they will go through the flow. If it returns Right,\nthey will bypass the flow.\n\nUses onlyFirstCanFinishMerge(2) by default.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow\n@param flow the original flow\n@param splitter the splitter function to use\n@return the flow with a bypass.", "predict": " Bypass a flow with a splitter function. The splitter function takes an input and returns either a flow input or an output. If the input is a flow input, the flow is executed with the input, otherwise the output is returned.\n\n@param splitter The splitter function.\n@param flow The flow to bypass.\n@return The bypassed flow."}, {"ID": 626, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String asString(Map<?, ?> map) { if (map == null) { return NULL; } StringBuilder builder = new StringBuilder(); builder.append('{'); boolean first = true; for (Map.Entry<?, ?> entry : map.entrySet()) { if (first) { first = false; } else { builder.append(','); } builder.append(asString(entry.getKey())) .append(':') .append(asString(entry.getValue())); } builder.append('}'); return builder.toString(); }\n\n    ### Response: Make a minimal printable string value from a typed map.\n\n@param map The map to stringify.\n@return The resulting string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) { return splitter.via( Flow.fromGraph( GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true)); UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy); Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.left.isPresent()) { return x.left.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, Out, ?> collectOut = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.right.isPresent()) { return x.right.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel = play.api.libs.streams.AkkaStreams .<F.Either<FlowIn, Out>>ignoreAfterCancellation() .asJava(); // Normal flow builder .from(broadcast.out(0)) .via(builder.add(collectIn)) .via(builder.add(flow)) .toInlet(merge.in(0)); // Bypass flow, need to ignore downstream finish builder .from(broadcast.out(1)) .via(builder.add(blockCancel)) .via(builder.add(collectOut)) .toInlet(merge.in(1)); return new FlowShape<>(broadcast.in(), merge.out()); }))); }\n\n    ### Response:", "ground_truth": "Using the given splitter flow, allow messages to bypass a flow.\n\nIf the splitter flow produces Left, they will be fed into the flow. If it produces Right,\nthey will bypass the flow.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow.\n@param flow the original flow.\n@param splitter the splitter function.\n@param mergeStrategy the merge strategy (onlyFirstCanFinishMerge, ignoreAfterFinish,\nignoreAfterCancellation)\n@return the flow with a bypass.", "predict": " Bypass a flow with a splitter and merge strategy.\n\n@param splitter The splitter to use.\n@param mergeStrategy The merge strategy to use.\n@param flow The flow to bypass.\n@return The resulting flow.\n\n    "}, {"ID": 627, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> RingBuffer<E> createMultiProducer( EventFactory<E> factory, int bufferSize, WaitStrategy waitStrategy) { MultiProducerSequencer sequencer = new MultiProducerSequencer(bufferSize, waitStrategy); return new RingBuffer<E>(factory, sequencer); }\n\n    ### Response: Create a new multiple producer RingBuffer with the specified wait strategy.\n\n@param  Class of the event stored in the ring buffer.\n@param factory      used to create the events within the ring buffer.\n@param bufferSize   number of elements to create within the ring buffer.\n@param waitStrategy used to determine how to wait for new elements to become available.\n@return a constructed ring buffer.\n@throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2\n@see MultiProducerSequencer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); }\n\n    ### Response:", "ground_truth": "Create a flow that is handled by an actor.\n\nMessages can be sent downstream by sending them to the actor passed into the props function.\nThis actor meets the contract of the actor returned by {@link\nakka.stream.javadsl.Source#actorRef}.\n\nThe props function should return the props for an actor to handle the flow. This actor will\nbe created using the passed in {@link akka.actor.ActorRefFactory}. Each message received will\nbe sent to the actor - there is no back pressure, if the actor is unable to process the\nmessages, they will queue up in the actors mailbox. The upstream can be cancelled by the actor\nterminating itself.\n\n@param  the In type parameter for a Flow\n@param  the Out type parameter for a Flow\n@param props A function that creates the props for actor to handle the flow.\n@param bufferSize The maximum number of elements to buffer.\n@param overflowStrategy The strategy for how to handle a buffer overflow.\n@param factory The Actor Factory used to create the actor to handle the flow - for example, an\nActorSystem.\n@param mat The materializer to materialize the flow.\n@return the flow itself.", "predict": " Create a new Flow that wraps an ActorRef.\n\n@param props         function that takes an ActorRef and returns the Props to create the Actor.\n@param bufferSize    number of messages to buffer before the actor is asked to process them.\n@param overflowStrategy strategy to use when the buffer is full.\n@param factory       factory to create the ActorRef.\n@param mat           materializer to use for running the Actor.\n@return a constructed Flow.\n@see ActorFlow."}, {"ID": 628, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Pure @SuppressWarnings(\"static-method\") public List<Object> getOptionValues(String optionLabel) { final List<Object> options = getCommandLineOption(optionLabel); if (options == null) { return Collections.emptyList(); } return Collections.unmodifiableList(options); }\n\n    ### Response: Replies the values of the option.\n\n@param optionLabel is the name of the option\n@return the option values or null if the option is not present..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Object> convertErrorArguments(Object[] arguments) { if (arguments == null) { return Collections.emptyList(); } List<Object> converted = Arrays.stream(arguments) .filter( arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable)) .collect(Collectors.toList()); return Collections.unmodifiableList(converted); }\n\n    ### Response:", "ground_truth": "Convert the error arguments.\n\n@param arguments The arguments to convert.\n@return The converted arguments.", "predict": " Converts the error arguments to a list of objects.\n\n@param arguments the error arguments\n@return the converted list of objects."}, {"ID": 629, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public QueryHints with(QueryHint hint, Object value) { if (hint == null) { throw new IllegalArgumentException(\"Null hint\"); } if (value == null) { throw new IllegalArgumentException(\"Null value\"); } EnumMap<QueryHint, Object> map; if (mMap == null) { map = new EnumMap<QueryHint, Object>(QueryHint.class); } else { map = mMap.clone(); } map.put(hint, value); return new QueryHints(map); }\n\n    ### Response: Returns a new QueryHints object with the given hint and value.\n\n@throws IllegalArgumentException if hint or value is null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Form<T> fill(T value) { if (value == null) { throw new RuntimeException(\"Cannot fill a form with a null value\"); } return new Form<>( rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess); }\n\n    ### Response:", "ground_truth": "Populates this form with an existing value, used for edit forms.\n\n@param value existing value of type T used to fill this form\n@return a copy of this form filled with the new data", "predict": " Returns a new Form object with the given value filled in.\n\n@throws RuntimeException if value is null."}, {"ID": 630, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<ValidationError> validateInput() { List<ValidationError> errors = new ArrayList<ValidationError>(); for (FormSectionController section : getSections()) { for (FormElementController element : section.getElements()) { if (element instanceof LabeledFieldController) { LabeledFieldController field = (LabeledFieldController)element; errors.addAll(field.validateInput()); } } } return errors; }\n\n    ### Response: Returns a list of validation errors of the form's input\n\n@return a list of validation errors of the form's input.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<ValidationError> globalErrors() { return Collections.unmodifiableList( errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList())); }\n\n    ### Response:", "ground_truth": "Retrieve all global errors - errors without a key.\n\n@return All global errors.", "predict": " Returns a list of global validation errors of the form's input\n\n@return a list of global validation errors of the form's input."}, {"ID": 631, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<String, List<String>> parseQuery(String query) { Map<String, List<String>> queryParams = new LinkedHashMap<>(); if (query != null) { for (NameValuePair params : URLEncodedUtils.parse(query, StandardCharsets.UTF_8)) { String name = params.getName(); List<String> values = queryParams.get(name); if (values == null) { values = new ArrayList<>(); queryParams.put(name, values); } values.add(params.getValue()); } } return queryParams; }\n\n    ### Response: Parse a query string into a map of key-value pairs.\n\n@param query query string to be parsed\n@return a mapping of parameter names to values suitable e.g. to pass into {@link EscapeTool#url(Map)}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); }\n\n    ### Response:", "ground_truth": "Returns the form errors serialized as Json using the given Lang.\n\n@param lang the language to use.\n@return the JSON node containing the errors.", "predict": " Convert a list of validation errors into a JSON object.\n\n@param lang the language to use for error messages\n@return a JSON object representing the validation errors\n\n    "}, {"ID": 632, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Optional<String> value(String path, String key) { return Optional.ofNullable(paths.get(path)) .flatMap(map -> Optional.ofNullable(map.get(key))); }\n\n    ### Response: Return the value with the given path and key if it exists.\n\n@param path the path\n@param key the key\n@return the value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Optional<Object> value(String key) { return super.value().map(v -> v.getData().get(asNormalKey(key))); }\n\n    ### Response:", "ground_truth": "Gets the concrete value\n\n@param key the string key.\n@return the value", "predict": " Return the value with the given key if it exists.\n\n@param key the key\n@return the value."}, {"ID": 633, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<String, Object> toMap(CompositeData value) { Map<String, Object> data = new HashMap<String, Object>(); for(String key : value.getCompositeType().keySet()) { data.put(key, value.get(key)); } return data; }\n\n    ### Response: Returns the CompositeData value as a Map.\n\n@param value CompositeData value to format.\n\n@return the CompositeData value as a Map..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DynamicForm fill(Map<String, Object> value) { Form<Dynamic> form = super.fill(new Dynamic(value)); return new DynamicForm( form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null)); }\n\n    ### Response:", "ground_truth": "Fills the form with existing data.\n\n@param value the map of values to fill in the form.\n@return the modified form.", "predict": " Fills the form with the given Map value.\n\n@param value Map value to fill the form with.\n\n@return the filled DynamicForm."}, {"ID": 634, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T parse(String text, Class<T> clazz) { return gson.fromJson(text, clazz); }\n\n    ### Response: Parse json to POJO.\n\n@param text  Json string.\n@param clazz POJO Class.\n@return POJO object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); }\n\n    ### Response:", "ground_truth": "Parses this string as instance of the given class.\n\n@param text the text to parse\n@param clazz class representing the required type\n@param  the type to parse out of the text\n@return the parsed value", "predict": " Parse json to POJO.\n\n@param text  Json string.\n@param clazz POJO Class.\n@return POJO object.."}, {"ID": 635, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T fromXml(Class<T> clazz, String xml) { T object = (T) CLASS_2_XSTREAM_INSTANCE.get(clazz).fromXML(xml); return object; }\n\n    ### Response: xml -> pojo\n\n@param clazz\n@param xml\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T parse(Field field, String text) { return (T) conversion.convert(text, new TypeDescriptor(field)); }\n\n    ### Response:", "ground_truth": "Parses this string as instance of a specific field\n\n@param field the related field (custom formatters are extracted from this field annotation)\n@param text the text to parse\n@param  the type to parse out of the text\n@return the parsed value", "predict": " text -> pojo\n\n@param field\n@param text\n@return."}, {"ID": 636, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String coerceToString(final ELContext ctx, final Object obj) { if (ctx != null) { boolean originalIsPropertyResolved = ctx.isPropertyResolved(); try { Object result = ctx.getELResolver().convertToType(ctx, obj, String.class); if (ctx.isPropertyResolved()) { return (String) result; } } finally { ctx.setPropertyResolved(originalIsPropertyResolved); } } if (obj == null) { return \"\"; } else if (obj instanceof String) { return (String) obj; } else if (obj instanceof Enum<?>) { return ((Enum<?>) obj).name(); } else { return obj.toString(); } }\n\n    ### Response: Coerce an object to a string.\n@param ctx the context in which this conversion is taking place\n@param obj the object to convert\n@return the String value of the object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(T t) { if (t == null) { return \"\"; } if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } }\n\n    ### Response:", "ground_truth": "Computes the display string for any value.\n\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": " Convert an object to a string.\n@param t the object to convert\n@return the String value of the object."}, {"ID": 637, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T extends Throwable> T throwing(final String fqcn, final Level level, final T t) { if (isEnabled(level, THROWING_MARKER, (Object) null, null)) { logMessageSafely(fqcn, level, THROWING_MARKER, throwingMsg(t), t); } return t; }\n\n    ### Response: Logs a Throwable to be thrown.\n\n@param  the type of the Throwable.\n@param fqcn the fully qualified class name of this Logger implementation.\n@param level The logging Level.\n@param t The Throwable.\n@return the Throwable..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); }\n\n    ### Response:", "ground_truth": "Computes the display string for any value, for a specific field.\n\n@param field the related field - custom formatters are extracted from this field annotation\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "Prints the value of the given object to a String using the default format for the type of the object.\n\n@param field the Field to print.\n@param t the object to print.\n@return the String representation of the object."}, {"ID": 638, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String coerceToString(final ELContext ctx, final Object obj) { if (ctx != null) { boolean originalIsPropertyResolved = ctx.isPropertyResolved(); try { Object result = ctx.getELResolver().convertToType(ctx, obj, String.class); if (ctx.isPropertyResolved()) { return (String) result; } } finally { ctx.setPropertyResolved(originalIsPropertyResolved); } } if (obj == null) { return \"\"; } else if (obj instanceof String) { return (String) obj; } else if (obj instanceof Enum<?>) { return ((Enum<?>) obj).name(); } else { return obj.toString(); } }\n\n    ### Response: Coerce an object to a string.\n@param ctx the context in which this conversion is taking place\n@param obj the object to convert\n@return the String value of the object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(TypeDescriptor desc, T t) { if (t == null) { return \"\"; } if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) { return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class)); } else if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } }\n\n    ### Response:", "ground_truth": "Computes the display string for any value, for a specific type.\n\n@param desc the field descriptor - custom formatters are extracted from this descriptor.\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": " Convert an object to a string.\n@param desc the type descriptor of the object to convert\n@param t the object to convert\n@return the String value of the object."}, {"ID": 639, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean canBypassConvert(TypeDescriptor sourceType, TypeDescriptor targetType) { Assert.notNull(targetType, \"The targetType to convert to cannot be null\"); if (sourceType == null) { return true; } GenericConverter converter = getConverter(sourceType, targetType); return (converter == NO_OP_CONVERTER); }\n\n    ### Response: Returns true if conversion between the sourceType and targetType can be bypassed.\nMore precisely this method will return true if objects of sourceType can be\nconverted to the targetType by returning the source object unchanged.\n@param sourceType context about the source type to convert from (may be null if source is null)\n@param targetType context about the target type to convert to (required)\n@return true if conversion can be bypassed\n@throws IllegalArgumentException if targetType is null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Formatters registerOptional() { conversion.addConverter( new GenericConverter() { public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map( o -> conversion.convert( source, sourceType.getElementTypeDescriptor(), targetType)) .orElse(\"\"); } return null; } public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<ConvertiblePair> result = new HashSet<>(); result.add(new ConvertiblePair(Optional.class, String.class)); result.add(new ConvertiblePair(String.class, Optional.class)); return result; } }); return this; }\n\n    ### Response:", "ground_truth": "Converter for String -> Optional and Optional -> String", "predict": " Registers a converter that can convert between Optional and String.\n@param conversion the ConversionService to register the converter with\n@return this Formatters instance for chaining\n@throws IllegalStateException if the ConversionService is not initialized"}, {"ID": 640, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(final String key, final Locale locale) { return get(Keys.LANGUAGE, key, locale); }\n\n    ### Response: Gets a value with the specified key and locale.\n\n@param key    the specified key\n@param locale the specified locale\n@return value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; }\n\n    ### Response:", "ground_truth": "Registers a simple formatter.\n\n@param clazz class handled by this formatter\n@param  the type that this formatter will parse and print\n@param formatter the formatter to register\n@return the modified Formatters object.", "predict": " Registers a formatter for the specified class.\n\n@param clazz     the specified class\n@param formatter the specified formatter\n@return this object\n\n    "}, {"ID": 641, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String evaluate(CharSequence text) { if(text==null) return null; Matcher m = JS_PATTERN.matcher(text); StringBuffer ret = new StringBuffer(); final boolean isNas = scriptEngine.getFactory().getEngineName().toLowerCase().contains(\"nashorn\"); while(m.find()) { String source = (isNas ? \"load(\\\"nashorn:mozilla_compat.js\\\");\\nimportPackage(java.lang); \" : \"\\nimportPackage(java.lang); \" ) + m.group(1); try { Object obj = scriptEngine.eval(source, bindings); if(obj!=null) { //log(\"Evaled [%s] --> [%s]\", source, obj); m.appendReplacement(ret, obj.toString()); } else { m.appendReplacement(ret, \"\"); } } catch (Exception ex) { ex.printStackTrace(System.err); throw new IllegalArgumentException(\"Failed to evaluate expression [\" + text + \"]\"); } } m.appendTail(ret); return ret.toString(); }\n\n    ### Response: Evaluates JS expressions defines as configuration values\n@param text The value of a configuration item to evaluate for JS expressions\n@return The passed value with any embedded JS expressions evaluated and replaced.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) sourceType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.print(a, (T) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return \"@\" + annotationType.getName() + \" \" + clazz.getName() + \" -> \" + String.class.getName() + \": \" + formatter; } }); conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(String.class, clazz)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (targetType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) targetType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.parse(a, (String) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return String.class.getName() + \" -> @\" + annotationType.getName() + \" \" + clazz.getName() + \": \" + formatter; } }); return this; }\n\n    ### Response:", "ground_truth": "Registers an annotation-based formatter.\n\n@param clazz class handled by this formatter\n@param formatter the formatter to register\n@param  the annotation type\n@param  the type that will be parsed or printed\n@return the modified Formatters object.", "predict": " Registers a custom formatter for a specific annotation type and class.\n@param <A> The annotation type to register the formatter for\n@param <T> The class to register the formatter for\n@param clazz The class to register the formatter for\n@param formatter The formatter to register\n@return This instance for chaining\n@throws IllegalArgumentException if the formatter is not a valid instance of {@link AnnotationFormatter} or if the annotation type is not a valid annotation type for the specified class"}, {"ID": 642, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DefaultCookie convertWisdomCookieToNettyCookie(Cookie cookie) { DefaultCookie nettyCookie = new DefaultCookie(cookie.name(), cookie.value()); nettyCookie.setMaxAge(cookie.maxAge()); // Comments are not supported anymore by netty. if (cookie.domain() != null) { nettyCookie.setDomain(cookie.domain()); } if (cookie.isSecure()) { nettyCookie.setSecure(true); } if (cookie.path() != null) { nettyCookie.setPath(cookie.path()); } if (cookie.isHttpOnly()) { nettyCookie.setHttpOnly(true); } return nettyCookie; }\n\n    ### Response: Converts the Wisdom's cookie to a Netty's cookie.\n\n@param cookie the Wisdom's cookie\n@return the Netty's cookie with the same metadata and content than the input cookie..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } final String name = cookie.name(); final String value = cookie.value() != null ? cookie.value() : \"\"; validateCookie(name, value); StringBuilder buf = new StringBuilder(); if (cookie.wrap()) { addQuoted(buf, name, value); } else { add(buf, name, value); } if (cookie.maxAge() != Integer.MIN_VALUE) { add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge()); Date expires = cookie.maxAge() <= 0 ? new Date(0) // Set expires to the Unix epoch : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis()); add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires)); } if (cookie.sameSite() != null) { add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite()); } if (cookie.path() != null) { add(buf, CookieHeaderNames.PATH, cookie.path()); } if (cookie.domain() != null) { add(buf, CookieHeaderNames.DOMAIN, cookie.domain()); } if (cookie.isSecure()) { add(buf, CookieHeaderNames.SECURE); } if (cookie.isHttpOnly()) { add(buf, CookieHeaderNames.HTTPONLY); } return stripTrailingSeparator(buf); }\n\n    ### Response:", "ground_truth": "Encodes the specified cookie into a Set-Cookie header value.\n\n@param cookie the cookie\n@return a single Set-Cookie header value", "predict": " Encodes the specified cookie into a string suitable for use in a Cookie header.\n\n@param cookie the cookie to encode\n@return the encoded cookie string\n@throws NullPointerException if the cookie is null\n@throws IllegalArgumentException if the cookie name or value is invalid according to RFC 6265\n\n    "}, {"ID": 643, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Object> getLeafNodes(TreeModel treeModel, Object node) { List<Object> leafNodes = new ArrayList<Object>(); getLeafNodes(treeModel, node, leafNodes); return leafNodes; }\n\n    ### Response: Returns a list containing all leaf nodes from the given tree model\nthat are descendants of the given node. These are the nodes that\nhave 0 children.\n\n@param treeModel The tree model\n@param node The node to start the search from\n@return The leaf nodes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static NodeList selectNodes(String path, Object node) { return selectNodes(path, node, null); }\n\n    ### Response:", "ground_truth": "Select all nodes that are selected by this XPath expression. If multiple nodes match, multiple\nnodes will be returned. Nodes will be returned in document-order,\n\n@param path the xpath expression\n@param node the starting node\n@return result of evaluating the xpath expression against node", "predict": " Selects all nodes in the tree that match the given path.\n\n@param path The path to match\n@param node The node to start the search from\n@param filter An optional filter to apply to the nodes\n@return The matching nodes."}, {"ID": 644, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> emptyToNull(final List<T> list) { if (isEmpty(list)) { return null; } else { return list; } }\n\n    ### Response: Returns null, when the given list is empty or null\n\n@param list The list to process\n@return null when the list is empty or null, the given list otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) { return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList(); }\n\n    ### Response:", "ground_truth": "Converts a Java List to Scala Seq.\n\n@param list    the java list.\n@return the converted Seq.\n@param  the element type.", "predict": " Converts a Java List to a Scala immutable Seq.\n\n@param list The Java List to convert\n@return An immutable Scala Seq containing the elements of the Java List."}, {"ID": 645, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Collection<T> addAll(Collection<T> list, T... array) { for (T item : array) { list.add(item); } return list; }\n\n    ### Response: Adds array members to list\n@param \n@param list\n@param array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) { return toSeq(java.util.Arrays.asList(array)); }\n\n    ### Response:", "ground_truth": "Converts a Java Array to Scala Seq.\n\n@param array    the java array.\n@return the converted Seq.\n@param  the element type.", "predict": " Converts an array to a Scala sequence\n@param array The array to convert to a sequence\n@return A Scala sequence containing the elements of the array"}, {"ID": 646, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs public static <T> Set<T> asSet(T... array) { Set<T> set = null; if (array != null) { set = new HashSet<>(Arrays.asList(array)); } return set; }\n\n    ### Response: Creates a set from the array elements.\n\n@param array the array with the elements\n\n@return the set with the elements.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs public static <T> scala.collection.immutable.Seq<T> varargs(T... array) { return toSeq(array); }\n\n    ### Response:", "ground_truth": "Converts a Java varargs to Scala varargs.\n\n@param array    the java array.\n@return the Scala varargs\n@param  the element type.", "predict": " Converts the array to a Scala sequence.\n\n@param array the array with the elements\n\n@return the Scala sequence with the elements."}, {"ID": 647, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean removeNode(String path, boolean removeChildren) throws ZooKeeperException { try { if (removeChildren) { curatorFramework.delete().deletingChildrenIfNeeded().forPath(path); } else { curatorFramework.delete().forPath(path); } } catch (KeeperException.NotEmptyException e) { return false; } catch (KeeperException.NoNodeException e) { return true; } catch (Exception e) { if (e instanceof ZooKeeperException) { throw (ZooKeeperException) e; } else { throw new ZooKeeperException(e); } } _invalidateCache(path); return true; }\n\n    ### Response: Removes an existing node.\n\n@param path\n@param removeChildren\n{@code true} to indicate that child nodes should be removed\ntoo\n@return {@code true} if node has been removed successfully, {@code false}\notherwise (maybe node is not empty)\n@since 0.4.1\n@throws ZooKeeperException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); } catch (Exception e) { throw new RuntimeException(e); } }); }\n\n    ### Response:", "ground_truth": "Acceptor for JSON WebSockets.\n\n@param in The class of the incoming messages, used to decode them from the JSON.\n@param  The websocket's input type (what it receives from clients)\n@param  The websocket's output type (what it writes to clients)\n@return The WebSocket acceptor.", "predict": " Creates a WebSocket acceptor that maps incoming messages to objects of the specified type using JSON serialization.\n\n@param in\nthe type of incoming messages\n@return a WebSocket acceptor that maps incoming messages to objects of the specified type using JSON serialization\n@since 0.4.1"}, {"ID": 648, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean somethingMayHaveChanged(PhaseInterceptorChain pic) { Iterator<Interceptor<? extends Message>> it = pic.iterator(); Interceptor<? extends Message> last = null; while (it.hasNext()) { Interceptor<? extends Message> cur = it.next(); if (cur == this) { if (last instanceof DemoInterceptor) { return false; } return true; } last = cur; } return true; }\n\n    ### Response: as we know nothing has changed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get().map(outMapper::apply)); return F.Either.Right(flow); } }); } }; }\n\n    ### Response:", "ground_truth": "Helper to create handlers for WebSockets.\n\n@param inMapper Function to map input messages. If it produces left, the message will be passed\nto the WebSocket flow, if it produces right, the message will be sent back out to the\nclient - this can be used to send errors directly to the client.\n@param f The function to handle the WebSocket.\n@param outMapper Function to map output messages.\n@return The WebSocket handler.", "predict": " This method is responsible for accepting or returning a WebSocket connection. It takes in a PartialFunction to map incoming messages to either an In or a Message, a Function to handle the WebSocket connection, and a Function to map Out to a Message. The WebSocket connection is accepted or returned as a CompletionStage of Either a Result or a Flow of Messages."}, {"ID": 649, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T deepClone(final T o) { if (o == null) { return null; } if (!this.cloningEnabled) { return o; } if (this.dumpClonedClasses) { System.out.println(\"start>\" + o.getClass()); } final Map<Object, Object> clones = new IdentityHashMap<Object, Object>(16); try { return cloneInternal(o, clones); } catch (final IllegalAccessException e) { throw new RuntimeException(\"error during cloning of \" + o, e); } }\n\n    ### Response: deep clones \"o\".\n\n@param \nthe type of \"o\"\n@param o\nthe object to be deep-cloned\n@return a deep-clone of \"o\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static boolean setAccessibleWorkaround(final AccessibleObject o) { if (o == null || o.isAccessible()) { return false; } final Member m = (Member) o; if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { try { o.setAccessible(true); return true; } catch (final SecurityException e) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false; }\n\n    ### Response:", "ground_truth": "XXX Default access superclass workaround.\n\nWhen a {@code public} class has a default access superclass with {@code public} members,\nthese members are accessible. Calling them from compiled code works fine. Unfortunately, on\nsome JVMs, using reflection to invoke these members seems to (wrongly) prevent access even when\nthe modifier is {@code public}. Calling {@code setAccessible(true)} solves the problem but will\nonly work from sufficiently privileged code. Better workarounds would be gratefully accepted.\n\n@param o the AccessibleObject to set as accessible\n@return a boolean indicating whether the accessibility of the object was set to true.", "predict": " sets the accessible flag of the given AccessibleObject if it is not already accessible.\n\n@param o\nthe AccessibleObject to set accessible\n@return true if the accessible flag was set, false otherwise.\n\n    "}, {"ID": 650, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> getNamedClass(Object obj) { Class<?> cls = getClass(obj); while (cls != null && cls.isAnonymousClass()) { cls = cls.getEnclosingClass(); } return cls; }\n\n    ### Response: If the object is not a Class, get its Class. Otherwise get the object as a Class. If the\nclass is anonymous, get a non-anonymous enclosing class.\n\n@since 4.0.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getPrimitivePromotionCost( final Class<?> srcClass, final Class<?> destClass) { float cost = 0.0f; Class<?> cls = srcClass; if (!cls.isPrimitive()) { // slight unwrapping penalty cost += 0.1f; cls = ClassUtils.wrapperToPrimitive(cls); } for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { if (cls == ORDERED_PRIMITIVE_TYPES[i]) { cost += 0.1f; if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { cls = ORDERED_PRIMITIVE_TYPES[i + 1]; } } } return cost; }\n\n    ### Response:", "ground_truth": "Gets the number of steps required to promote a primitive number to another type.\n\n@param srcClass the (primitive) source class\n@param destClass the (primitive) destination class\n@return The cost of promoting the primitive", "predict": " Calculates the cost of promoting a primitive value to another primitive type. The cost is based on the number of primitive types between the source and destination types. The cost is a float value between 0.0 and 1.0, with 1.0 indicating the most expensive promotion.\n\n@since 4.0.0."}, {"ID": 651, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static boolean doesParameterTypesMatchForVarArgsInvocation(boolean isVarArgs, Class<?>[] parameterTypes, Object[] arguments) { if (isVarArgs && arguments != null && arguments.length >= 1 && parameterTypes != null && parameterTypes.length >= 1) { final Class<?> componentType = parameterTypes[parameterTypes.length - 1].getComponentType(); final Object lastArgument = arguments[arguments.length - 1]; if (lastArgument != null) { final Class<?> lastArgumentTypeAsPrimitive = getTypeAsPrimitiveIfWrapped(lastArgument); final Class<?> varArgsParameterTypeAsPrimitive = getTypeAsPrimitiveIfWrapped(componentType); isVarArgs = varArgsParameterTypeAsPrimitive.isAssignableFrom(lastArgumentTypeAsPrimitive); } } return isVarArgs && checkArgumentTypesMatchParameterTypes(isVarArgs, parameterTypes, arguments); }\n\n    ### Response: Does parameter types match for var args invocation.\n\n@param isVarArgs      the is var args\n@param parameterTypes the parameter types\n@param arguments      the arguments\n@return true, if successful.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getTotalTransformationCost( final Class<?>[] srcArgs, final Executable executable) { final Class<?>[] destArgs = executable.getParameterTypes(); final boolean isVarArgs = executable.isVarArgs(); // \"source\" and \"destination\" are the actual and declared args respectively. float totalCost = 0.0f; final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length; if (srcArgs.length < normalArgsLen) { return Float.MAX_VALUE; } for (int i = 0; i < normalArgsLen; i++) { totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]); } if (isVarArgs) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs.length < destArgs.length; final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray(); final float varArgsCost = 0.001f; final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType(); if (noVarArgsPassed) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost; } else if (explicitArrayForVarags) { final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType(); totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost; } else { // This is typical varargs case. for (int i = destArgs.length - 1; i < srcArgs.length; i++) { final Class<?> srcClass = srcArgs[i]; totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost; } } } return totalCost; }\n\n    ### Response:", "ground_truth": "Returns the sum of the object transformation cost for each class in the source argument list.\n\n@param srcArgs The source arguments\n@param executable The executable to calculate transformation costs for\n@return The total transformation cost", "predict": " Get total transformation cost.\n\n@param srcArgs        the source args\n@param executable     the executable\n@return the total transformation cost."}, {"ID": 652, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:returncount\"}) public static long estimateValueCost(Object value) { if (value == null) { return 0; } Class<?> clazz = value.getClass(); Integer cost = KNOWN_FINAL_CLASSES_COSTS.get(clazz); if (cost != null) { return cost; } if (value instanceof String) { return BASE_STRING_COST + ((String) value).length() * 2L; } if (value instanceof Timestamp) { return SQL_TIMESTAMP_COST; } if (value instanceof Date) { return DATE_COST; } if (clazz.isEnum()) { // enum values are shared, so they don't cost anything return 0; } if (value instanceof BigDecimal) { return ROUGH_BIG_DECIMAL_COST; } if (value instanceof BigInteger) { return ROUGH_BIG_INTEGER_COST; } return ROUGH_UNKNOWN_CLASS_COST; }\n\n    ### Response: Estimates the on-heap memory cost of the given value.\n\n@param value the value to estimate the cost of.\n@return the estimated value cost..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { if (destClass.isPrimitive()) { return getPrimitivePromotionCost(srcClass, destClass); } float cost = 0.0f; while (srcClass != null && !destClass.equals(srcClass)) { if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f; break; } cost++; srcClass = srcClass.getSuperclass(); } /* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if (srcClass == null) { cost += 1.5f; } return cost; }\n\n    ### Response:", "ground_truth": "Gets the number of steps required needed to turn the source class into the destination class.\nThis represents the number of steps in the object hierarchy graph.\n\n@param srcClass The source class\n@param destClass The destination class\n@return The cost of transforming an object", "predict": " Calculates the cost of transforming an object of the given source class to the given destination class.\n\n@param srcClass the source class of the object to transform.\n@param destClass the destination class to transform the object to.\n@return the cost of transforming the object.\n\n    "}, {"ID": 653, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getLocalizedString(String key, Object... args) { return getLocalizedString(currentLocale, key, args); }\n\n    ### Response: Gets the localized string corresponding to a key, formatted with a set of args..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String at(String key, Object... args) { return messagesApi.get(lang, key, args); }\n\n    ### Response:", "ground_truth": "Get the message at the given key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Gets the localized string corresponding to a key, formatted with a set of args, using the messagesApi and the current language."}, {"ID": 654, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getLocalizedString(String key, Object... args) { return getLocalizedString(currentLocale, key, args); }\n\n    ### Response: Gets the localized string corresponding to a key, formatted with a set of args..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String at(List<String> keys, Object... args) { return messagesApi.get(lang, keys, args); }\n\n    ### Response:", "ground_truth": "Get the message at the first defined key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Gets the localized string corresponding to a list of keys, formatted with a set of args."}, {"ID": 655, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DB open(String driver, String url, String user, String password) { return new DB(DB.DEFAULT_NAME).open(driver, url, user, password); }\n\n    ### Response: Opens a new connection based on JDBC properties and attaches it to a current thread.\n\n@param driver class name of driver\n@param url URL connection to DB\n@param user user name.\n@param password password..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Database createFrom( String driver, String url, Map<String, ? extends Object> config) { return createFrom(\"default\", driver, url, config); }\n\n    ### Response:", "ground_truth": "Create a pooled database named \"default\" with the given configuration.\n\n@param driver the database driver class\n@param url the database url\n@param config a map of extra database configuration\n@return a configured database", "predict": " Creates a new Database instance based on the provided driver, URL, and configuration properties.\n\n@param driver class name of driver\n@param url URL connection to DB\n@param config a map of configuration properties.\n\n    "}, {"ID": 656, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StringSwitcher create(String[] strings, int[] ints, boolean fixedInput) { Generator gen = new Generator(); gen.setStrings(strings); gen.setInts(ints); gen.setFixedInput(fixedInput); return gen.create(); }\n\n    ### Response: Helper method to create a StringSwitcher.\nFor finer control over the generated instance, use a new instance of StringSwitcher.Generator\ninstead of this static method.\n@param strings the array of String keys; must be the same length as the value array\n@param ints the array of integer results; must be the same length as the key array\n@param fixedInput if false, an unknown key will be returned from {@link #intValue} as -1; if true,\nthe result will be undefined, and the resulting code will be faster.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ParallelSorter create(Object[] arrays) { Generator gen = new Generator(); gen.setArrays(arrays); return gen.create(); }\n\n    ### Response:", "ground_truth": "Create a new ParallelSorter object for a set of arrays. You may\nsort the arrays multiple times via the same ParallelSorter object.\n@param arrays An array of arrays to sort. The arrays may be a mix\nof primitive and non-primitive types, but should all be the same\nlength.\n@param loader ClassLoader for generated class, uses \"current\" if null", "predict": " Helper method to create a ParallelSorter.\nFor finer control over the generated instance, use a new instance of ParallelSorter.Generator\ninstead of this static method.\n@param arrays the array of arrays to be sorted; each array must be of the same length and type\n@return a new ParallelSorter instance"}, {"ID": 657, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (g *Generator) Int(lo, hi int) int { if lo == hi { return lo } if lo > hi { lo, hi = hi, lo } n := g.rand.Intn(hi - lo + 1) return lo + n }\n\n    ### Response: // Int generates an int between lo and hi including\n// those values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void quickSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.quickSort(lo, hi - 1); }\n\n    ### Response:", "ground_truth": "Sort the arrays using the quicksort algorithm.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": " // quickSort sorts the array using the quicksort algorithm\n// and the given comparator.\n\n    "}, {"ID": 658, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (g *Generator) Int(lo, hi int) int { if lo == hi { return lo } if lo > hi { lo, hi = hi, lo } n := g.rand.Intn(hi - lo + 1) return lo + n }\n\n    ### Response: // Int generates an int between lo and hi including\n// those values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void mergeSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.mergeSort(lo, hi - 1); }\n\n    ### Response:", "ground_truth": "Sort the arrays using an in-place merge sort.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": " // mergeSort sorts the array from index lo to index hi using the\n// specified comparator."}, {"ID": 659, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object callConstructor(Class clazz, Object[] args) throws PageException { args = cleanArgs(args); try { return getConstructorInstance(clazz, args).invoke(); } catch (InvocationTargetException e) { Throwable target = e.getTargetException(); if (target instanceof PageException) throw (PageException) target; throw Caster.toPageException(e.getTargetException()); } catch (Exception e) { throw Caster.toPageException(e); } }\n\n    ### Response: call constructor of a class with matching arguments\n\n@param clazz Class to get Instance\n@param args Arguments for the Class\n@return invoked Instance\n@throws PageException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } }\n\n    ### Response:", "ground_truth": "Invoke the original method, on a different object of the same type.\n@param obj the compatible object; recursion will result if you use the object passed as the first\nargument to the MethodInterceptor (usually not what you want)\n@param args the arguments passed to the intercepted method; you may substitute a different\nargument array as long as the types are compatible\n@see MethodInterceptor#intercept\n@throws Throwable the bare exceptions thrown by the called method are passed through\nwithout wrapping in an InvocationTargetException", "predict": " invoke a method on an object with matching arguments\n\n@param obj Object to invoke method on\n@param args Arguments for the method\n@return result of the method invocation\n@throws Throwable."}, {"ID": 660, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Interval oddsFromTo(int from, int to) { if (from % 2 == 0) { if (from < to) { from++; } else { from--; } } if (to % 2 == 0) { if (to > from) { to--; } else { to++; } } return Interval.fromToBy(from, to, to > from ? 2 : -2); }\n\n    ### Response: Returns an Interval representing the odd values from the value from to the value to..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.LONG_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.L2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.L2F); } else { mv.visitInsn(Constants.L2I); cast_numeric(Type.INT_TYPE, to); } } else { if (to == Type.BYTE_TYPE) { mv.visitInsn(Constants.I2B); } else if (to == Type.CHAR_TYPE) { mv.visitInsn(Constants.I2C); } else if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.I2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.I2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.I2L); } else if (to == Type.SHORT_TYPE) { mv.visitInsn(Constants.I2S); } } } }\n\n    ### Response:", "ground_truth": "Casts from one primitive numeric type to another", "predict": " Casts the numeric value from the type from to the type to."}, {"ID": 661, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void resetHead(long index) { for (SegmentedJournalReader reader : readers) { if (reader.getNextIndex() < index) { reader.reset(index); } } }\n\n    ### Response: Resets journal readers to the given head.\n\n@param index The index at which to reset readers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); }\n\n    ### Response:", "ground_truth": "Pushes the specified argument of the current method onto the stack.\n@param index the zero-based index into the argument list", "predict": " Loads the argument at the given index into the local variable array.\n\n@param index The index of the argument to load."}, {"ID": 662, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void enterBinop(String name, Type left, Type right, Type res, int opcode) { predefClass.members().enter( new OperatorSymbol( makeOperatorName(name), new MethodType(List.of(left, right), res, List.<Type>nil(), methodClass), opcode, predefClass)); }\n\n    ### Response: Enter a binary operation into symbol table.\n@param name     The name of the operator.\n@param left     The type of the left operand.\n@param right    The type of the left operand.\n@param res      The operation's result type.\n@param opcode   The operation's bytecode instruction..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); }\n\n    ### Response:", "ground_truth": "package-protected for EmitUtils, try to fix", "predict": " Emit a field instruction.\n@param opcode   The field instruction's opcode.\n@param ctype    The class containing the field.\n@param name     The name of the field.\n@param ftype    The type of the field."}, {"ID": 663, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void unbox(GeneratorAdapter mg, Type type) { switch (type.getSort()) { case Type.VOID: return; case Type.BOOLEAN: mg.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\"); break; case Type.CHAR: mg.visitTypeInsn(CHECKCAST, \"java/lang/Character\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\"); break; case Type.BYTE: mg.visitTypeInsn(CHECKCAST, \"java/lang/Byte\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\"); break; case Type.SHORT: mg.visitTypeInsn(CHECKCAST, \"java/lang/Short\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\"); break; case Type.INT: mg.visitTypeInsn(CHECKCAST, \"java/lang/Integer\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\"); break; case Type.FLOAT: mg.visitTypeInsn(CHECKCAST, \"java/lang/Float\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\"); break; case Type.LONG: mg.visitTypeInsn(CHECKCAST, \"java/lang/Long\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\"); break; case Type.DOUBLE: mg.visitTypeInsn(CHECKCAST, \"java/lang/Double\"); mg.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\"); break; default: mg.checkCast(type); break; } }\n\n    ### Response: d369262.7.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } }\n\n    ### Response:", "ground_truth": "Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.", "predict": " d369262.8."}, {"ID": 664, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitTryCatchBlock(Label start, Label end, Label handler, String type) { if (type != null) { handlers.put(handler, type); } super.visitTryCatchBlock(start, end, handler, type); }\n\n    ### Response: Visit a try catch block. We will use this to determine the exception\nhandler labels for the try block.\n\n@param start\nthe beginning of the try block\n@param end\nthe end of the try block\n@param handler\nthe exception handler\n@param type\nthe internal name of the throwable being handled.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } }\n\n    ### Response:", "ground_truth": "Unboxes the object on the top of the stack. If the object is null, the\nunboxed primitive value becomes zero.", "predict": " Unbox or zero a value of a given type.\n\n@param type\nthe type of the value to unbox or zero."}, {"ID": 665, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Type resolveGenericArrayTypeVariables(final GenericArrayType type, final Map<String, Type> generics, final boolean countPreservedVariables) { final Type componentType = resolveTypeVariables( type.getGenericComponentType(), generics, countPreservedVariables); return ArrayTypeUtils.toArrayType(componentType); }\n\n    ### Response: May produce array class instead of generic array type. This is possible due to wildcard or parameterized type\nshrinking.\n\n@param type                    type to repackage\n@param generics                known generics\n@param countPreservedVariables true to replace {@link ExplicitTypeVariable} too\n@return type without {@link TypeVariable}'s.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) { Type componentType = TypeUtils.getComponentType(type); Local array = e.make_local(); Local loopvar = e.make_local(Type.INT_TYPE); Label loopbody = e.make_label(); Label checkloop = e.make_label(); e.store_local(array); e.push(0); e.store_local(loopvar); e.goTo(checkloop); e.mark(loopbody); e.load_local(array); e.load_local(loopvar); e.array_load(componentType); callback.processElement(componentType); e.iinc(loopvar, 1); e.mark(checkloop); e.load_local(loopvar); e.load_local(array); e.arraylength(); e.if_icmp(e.LT, loopbody); }\n\n    ### Response:", "ground_truth": "Process an array on the stack. Assumes the top item on the stack\nis an array of the specified type. For each element in the array,\nputs the element on the stack and triggers the callback.\n@param type the type of the array (type.isArray() must be true)\n@param callback the callback triggered for each element", "predict": " Processes an array of elements.\n\n@param e                       code emitter\n@param type                    array type\n@param callback                callback to process each element\n@throws CodeGenerationException if an error occurs during code generation"}, {"ID": 666, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void injectServletCallback(String method) { Label tryStart = new Label(); Label tryEnd = new Label(); Label catchStart = new Label(); Label catchEnd = new Label(); visitTryCatchBlock(tryStart, tryEnd, catchStart, \"java/lang/NoClassDefFoundError\"); mark(tryStart); // try { loadArgs(); invokeStatic(Type.getType(SERVLET_CALLBACK_TYPE), Method.getMethod(method)); mark(tryEnd); // } visitJumpInsn(GOTO, catchEnd); mark(catchStart); // catch() { pop(); mark(catchEnd); // } }\n\n    ### Response: Inject a callback to our servlet handler.\n\n@param method.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) { e.dup2(); Label nonNull = e.make_label(); Label oneNullHelper = e.make_label(); Label end = e.make_label(); e.ifnonnull(nonNull); e.ifnonnull(oneNullHelper); e.pop2(); e.goTo(bothNull); e.mark(nonNull); e.ifnull(oneNullHelper); e.goTo(end); e.mark(oneNullHelper); e.pop2(); e.goTo(oneNull); e.mark(end); }\n\n    ### Response:", "ground_truth": "If both objects on the top of the stack are non-null, does nothing.\nIf one is null, or both are null, both are popped off and execution\nbranches to the respective label.\n@param oneNull label to branch to if only one of the objects is null\n@param bothNull label to branch to if both of the objects are null", "predict": " Check if two objects are both null or not.\n\n@param e.\n@param oneNull.\n@param bothNull."}, {"ID": 667, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry)entryIter.next(); Class owner = (Class)entry.getKey(); Set bridges = (Set)entry.getValue(); try { new ClassReader(owner.getName()) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } catch(IOException ignored) {} } return resolved; }\n\n    ### Response: Finds all bridge methods that are being called with invokespecial &\nreturns them..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; }\n\n    ### Response:", "ground_truth": "Finds all bridge methods that are being called with invokespecial &\nreturns them.", "predict": " Finds all bridge methods that are being called with invokespecial &\nreturns them. It also checks if the class is present in the classloader and returns an empty map if it is not present."}, {"ID": 668, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Constructor<?> getWrapperProxyConstructor(BeanMetaData bmd, String proxyClassName, Class<?> interfaceClass, Method[] methods) // F58064 throws EJBConfigurationException, ClassNotFoundException { ClassLoader proxyClassLoader = getWrapperProxyClassLoader(bmd, interfaceClass); Class<?>[] interfaces = new Class<?>[] { interfaceClass }; Class<?> proxyClass = JITDeploy.generateEJBWrapperProxy(proxyClassLoader, proxyClassName, interfaces, methods, bmd.container.getEJBRuntime().getClassDefiner()); // F70650 try { return proxyClass.getConstructor(WrapperProxyState.class); } catch (NoSuchMethodException ex) { throw new IllegalStateException(ex); } }\n\n    ### Response: Defines a wrapper proxy class and obtains its constructor that accepts a\nWrapperProxyStte.\n\n@param bmd the bean metadata\n@param proxyClassName the wrapper proxy class name\n@param interfaceClass the interface class to proxy\n@param methods the methods to define on the proxy\n@return the constructor with a WrapperProxyState parameter\n@throws EJBConfigurationException if a class loader cannot be found\n@throws ClassNotFoundException if class generation fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void getMethods(Class superclass, Class[] interfaces, List methods) { getMethods(superclass, interfaces, methods, null, null); }\n\n    ### Response:", "ground_truth": "Finds all of the methods that will be extended by an\nEnhancer-generated class using the specified superclass and\ninterfaces. This can be useful in building a list of Callback\nobjects. The methods are added to the end of the given list.  Due\nto the subclassing nature of the classes generated by Enhancer,\nthe methods are guaranteed to be non-static, non-final, and\nnon-private. Each method signature will only occur once, even if\nit occurs in multiple classes.\n@param superclass the class that will be extended, or null\n@param interfaces the list of interfaces that will be implemented, or null\n@param methods the list into which to copy the applicable methods", "predict": " Retrieves all the methods from the superclass and interfaces and adds them to the methods list.\n\n@param superclass the superclass to retrieve methods from\n@param interfaces the interfaces to retrieve methods from\n@param methods the list to add the methods to\n@param excludeMethods the methods to exclude from the list\n@param includeMethods the methods to include in the list\n@throws NoSuchMethodException if a method cannot be found in the superclass or interface\n@throws SecurityException if a security exception occurs while retrieving the methods\n\n    "}, {"ID": 669, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized void suppressConstructor(Constructor<?>... constructors) { if (constructors == null) { throw new IllegalArgumentException(\"constructors cannot be null.\"); } for (Constructor<?> constructor : constructors) { MockRepository.addConstructorToSuppress(constructor); // Also suppress all parent constructors Class<?> declaringClass = constructor.getDeclaringClass(); if (declaringClass != null) { suppressConstructor((Class<?>) declaringClass.getSuperclass()); } } }\n\n    ### Response: Suppress constructor calls on specific constructors only..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void filterConstructors(Class sc, List constructors) { CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true)); if (constructors.size() == 0) throw new IllegalArgumentException(\"No visible constructors in \" + sc); }\n\n    ### Response:", "ground_truth": "Filter the list of constructors from the superclass. The\nconstructors which remain will be included in the generated\nclass. The default implementation is to filter out all private\nconstructors, but subclasses may extend Enhancer to override this\nbehavior.\n@param sc the superclass\n@param constructors the list of all declared constructors from the superclass\n@throws IllegalArgumentException if there are no non-private constructors", "predict": " Filter the constructors of a class to only include visible ones."}, {"ID": 670, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addSuperOuterPath(TypeDeclaration node) { TypeElement superclass = ElementUtil.getSuperclass(node.getTypeElement()); if (superclass != null && captureInfo.needsOuterParam(superclass)) { node.setSuperOuter(getOuterPathInherited(ElementUtil.getDeclaringClass(superclass))); } }\n\n    ### Response: type node because there may be implicit super invocations..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setSuperclass(Class superclass) { if (superclass != null && superclass.equals(Object.class)) { superclass = null; } this.superclass = superclass; }\n\n    ### Response:", "ground_truth": "Set the class which the generated class will extend. The class\nmust not be declared as final, and must have a non-private\nno-argument constructor.\n@param superclass class to extend, or null to extend Object", "predict": " type superclass because it is a parameter to the method."}, {"ID": 671, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void loadScript(Node node) throws Exception { ResourceId key = new NodeScriptKey(repository.getConfiguration().getName(), workspaceName, node); ObjectFactory<AbstractResourceDescriptor> resource = groovyScript2RestLoader.groovyPublisher.unpublishResource(key); if (resource != null) { groovyScript2RestLoader.groovyPublisher.publishPerRequest(node.getProperty(\"jcr:data\").getStream(), key, resource.getObjectModel().getProperties()); } else { groovyScript2RestLoader.groovyPublisher.publishPerRequest(node.getProperty(\"jcr:data\").getStream(), key, null); } }\n\n    ### Response: Load script form supplied node.\n\n@param node JCR node\n@throws Exception if any error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void getField(String[] names) throws Exception { final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null); e.load_this(); e.load_arg(0); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label end) { Type type = (Type)fields.get(key); e.getfield((String)key); e.box(type); e.return_value(); } public void processDefault() { e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\"); } }); e.end_method(); }\n\n    ### Response:", "ground_truth": "to avoid JVM hashcode implementation incompatibilities", "predict": " Get field value for the given field name.\n\n@param names array of field names\n@return field value\n@throws Exception if any error occurs."}, {"ID": 672, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addProjectMethod(final ProjectMethod method) { readWriteLock.writeLock().lock(); try { availableMethods.add(method); } finally { readWriteLock.writeLock().unlock(); } }\n\n    ### Response: Adds a project method to the pool.\n\n@param method The method to add.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Method method) { add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method)); }\n\n    ### Response:", "ground_truth": "Add a method signature to the interface. The method modifiers are ignored,\nsince interface methods are by definition abstract and public.\n@param method the method to add to the interface", "predict": " Adds a method to the pool.\n\n@param method The method to add."}, {"ID": 673, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int skipWhitespace() throws IOException { int c = 0; do { c = r.read(); if (c < 0) { return -1; } } while (Character.isWhitespace(c)); return c; }\n\n    ### Response: Reads characters from the stream until a non-whitespace character\nhas been found. Reads at least one character.\n@return the next non-whitespace character\n@throws IOException if the stream could not be read.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; }\n\n    ### Response:", "ground_truth": "If bit 31 is set then this method results in an infinite loop.\n\n@return the number of bits set to true in this TinyBitSet.", "predict": " Computes the number of bits set in the binary representation of the integer value.\n@return the number of bits set in the binary representation of the integer value."}, {"ID": 674, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:npathcomplexity\") public void setFrom(SARLConfiguration config) { if (this.input == null) { this.input = config.getInput(); } if (this.output == null) { this.output = config.getOutput(); } if (this.binOutput == null) { this.binOutput = config.getBinOutput(); } if (this.testInput == null) { this.testInput = config.getTestInput(); } if (this.testOutput == null) { this.testOutput = config.getTestOutput(); } if (this.testBinOutput == null) { this.testBinOutput = config.getTestBinOutput(); } if (this.inputCompliance == null) { this.inputCompliance = config.getInputCompliance(); } if (this.outputCompliance == null) { this.outputCompliance = config.getOutputCompliance(); } if (this.encoding == null) { this.encoding = config.getEncoding(); } }\n\n    ### Response: Set the uninitialized field with given configuration.\n\n@param config the configured values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setNamingPolicy(NamingPolicy namingPolicy) { if (namingPolicy == null) namingPolicy = DefaultNamingPolicy.INSTANCE; this.namingPolicy = namingPolicy; }\n\n    ### Response:", "ground_truth": "Override the default naming policy.\n@see DefaultNamingPolicy\n@param namingPolicy the custom policy, or null to use the default", "predict": " Set the naming policy for the generator.\n\n@param namingPolicy the naming policy to set. If null, the default naming policy will be used."}, {"ID": 675, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Method[] getMethodList(Class<?> clazz) { Method[] methods = null; try { // getDeclaredMethods may be rejected by the security manager // but getMethods is more expensive if (!sawSecurityException) methods = clazz.getDeclaredMethods(); } catch (SecurityException e) { // If we get an exception once, give up on getDeclaredMethods sawSecurityException = true; } if (methods == null) { methods = clazz.getMethods(); } int count = 0; for (int i=0; i < methods.length; i++) { if (sawSecurityException ? methods[i].getDeclaringClass() != clazz : !Modifier.isPublic(methods[i].getModifiers())) { methods[i] = null; } else { count++; } } Method[] result = new Method[count]; int j=0; for (int i=0; i < methods.length; i++) { if (methods[i] != null) result[j++] = methods[i]; } return result; }\n\n    ### Response: Returns all public methods declared by the specified class. This excludes\ninherited methods.\n\n@param clazz the class from which to pull public declared methods\n@return the public methods declared in the specified class\n@see Class#getDeclaredMethods().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) { Map map = new HashMap(); for (int i = 0; i < methods.length; i++) { Method method = methods[i]; map.put(method.getName() + Type.getMethodDescriptor(method), method); } Method[] result = new Method[namesAndDescriptors.length / 2]; for (int i = 0; i < result.length; i++) { result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]); if (result[i] == null) { // TODO: error? } } return result; }\n\n    ### Response:", "ground_truth": "used by MethodInterceptorGenerated generated code", "predict": " Finds the methods with the specified names and descriptors in the specified array of methods.\n\n@param namesAndDescriptors an array of method names and descriptors, in the format \"name1(descriptor1)name2(descriptor2)...\"\n@param methods the array of methods to search\n@return an array of methods with the specified names and descriptors, in the same order as the input array\n@throws NoSuchMethodException if a method with a specified name and descriptor is not found in the input array\n@see Class#getMethod(String, Class...)"}, {"ID": 676, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String relativePath(File parent, File child) { Path superPath = parent.toPath(); Path subPath = child.toPath(); if (!subPath.startsWith(superPath)) { throw new IllegalArgumentException(\"Not a subpath: \" + child); } return superPath.relativize(subPath).toString(); }\n\n    ### Response: Return the relative path between a parent directory and some child path\n\n@param parent\n@param child\n\n@return the relative path for the child\n\n@throws IllegalArgumentException if child is not a subpath.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Path resolve(final Path base, String child) { if (StringUtil.startsWithChar(child, File.separatorChar)) { child = child.substring(1); } return base.resolve(child); }\n\n    ### Response:", "ground_truth": "Resolves subpath in safer way. For some reason, if child starts with\na separator it gets resolved as a full path, ignoring the base.\nThis method acts different.", "predict": " Resolve a child path against a base path\n\n@param base the base path\n@param child the child path to resolve\n\n@return the resolved path\n\n@throws NullPointerException if either argument is null"}, {"ID": 677, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void loadSettings(String file) throws IOException { Path path = Paths.get(file); try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { Properties props = new Properties(); props.load(reader); loadSettings(props); } }\n\n    ### Response: Loads constant settings from a file in Properties format.\n@param file the path to the file to read from\n@throws IOException when file reading fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer); return writer.toString(); } }\n\n    ### Response:", "ground_truth": "Reads path content.", "predict": " Reads the contents of a file into a string.\n@param path the path to the file to read from\n@return the contents of the file as a string\n@throws IOException when file reading fails."}, {"ID": 678, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ConfigBuilder withHost(final String host) { if (host == null || \"\".equals(host)) { throw new IllegalArgumentException(\"host must not be null or empty: \" + host); } this.host = host; return this; }\n\n    ### Response: Configs created by this ConfigBuilder will have the given Redis hostname.\n\n@param host the Redis hostname\n@return this ConfigBuilder.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; }\n\n    ### Response:", "ground_truth": "Sets request host name.", "predict": " Sets the hostname for this HTTP request. If a Host header already exists, it will be overwritten with the new hostname.\n\n@param host the hostname for this HTTP request\n@return this HttpRequest."}, {"ID": 679, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Link create(final String text, final String ref) { return new Link(text, null, '#'+ref); }\n\n    ### Response: Create a new link to a given ref\n@param text the text content\n@param ref the ref\n@return the link.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest create(final String method, final String destination) { return new HttpRequest() .method(method.toUpperCase()) .set(destination); }\n\n    ### Response:", "ground_truth": "Generic request builder, usually used when method is a variable.\nOtherwise, use one of the other static request builder methods.", "predict": " Create a new HTTP request with the given method and destination\n@param method the HTTP method (GET, POST, PUT, DELETE, etc.)\n@param destination the URL to send the request to\n@return the HTTP request object."}, {"ID": 680, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirectionsApiRequest getDirections( GeoApiContext context, String origin, String destination) { return new DirectionsApiRequest(context).origin(origin).destination(destination); }\n\n    ### Response: Creates a new DirectionsApiRequest between the given origin and destination, using the defaults\nfor all other options.\n\n@param context Context that the DirectionsApiRequest will be executed against\n@param origin Origin address as text\n@param destination Destination address as text\n@return A newly constructed DirectionsApiRequest between the given points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest connect(final String destination) { return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a CONNECT request.", "predict": " Creates a new HttpRequest with the CONNECT method and sets the destination URL.\n\n@param destination Destination URL to connect to\n@return A newly constructed HttpRequest with the CONNECT method and the destination URL set."}, {"ID": 681, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Policy> defaultWorkerPolicies(String workspaceSid, String workerSid) { Policy activities = new Policy.Builder() .url(UrlUtils.activities(workspaceSid)) .method(HttpMethod.GET) .allowed(true) .build(); Policy tasks = new Policy.Builder() .url(UrlUtils.allTasks(workspaceSid)) .method(HttpMethod.GET) .allowed(true) .build(); Policy reservations = new Policy.Builder() .url(UrlUtils.allReservations(workspaceSid, workerSid)) .method(HttpMethod.GET) .allowed(true) .build(); Policy workerFetch = new Policy.Builder() .url(UrlUtils.worker(workspaceSid, workerSid)) .method(HttpMethod.GET) .allowed(true) .build(); return Lists.newArrayList(activities, tasks, reservations, workerFetch); }\n\n    ### Response: Build the default Polices for a Worker.\n\n@param workspaceSid Workspace sid of the worker\n@param workerSid Worker sid\n@return generated Policies.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest get(final String destination) { return new HttpRequest() .method(HttpMethod.GET) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a GET request.", "predict": " Create a new HttpRequest object with GET method and set the destination URL.\n\n@param destination URL to be set for the request\n@return a new HttpRequest object with GET method and destination URL set."}, {"ID": 682, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Router post(final String uriTemplate, final ContextHandler handler) { return route().post(uriTemplate, handler); }\n\n    ### Response: HTTP POST routing.\n\n@param uriTemplate the specified request URI template\n@param handler     the specified handler\n@return router.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest post(final String destination) { return new HttpRequest() .method(HttpMethod.POST) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a POST request.", "predict": " Creates a new HTTP POST request.\n\n@param destination the destination URI for the request\n@return the new HTTP POST request."}, {"ID": 683, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirectionsApiRequest getDirections( GeoApiContext context, String origin, String destination) { return new DirectionsApiRequest(context).origin(origin).destination(destination); }\n\n    ### Response: Creates a new DirectionsApiRequest between the given origin and destination, using the defaults\nfor all other options.\n\n@param context Context that the DirectionsApiRequest will be executed against\n@param origin Origin address as text\n@param destination Destination address as text\n@return A newly constructed DirectionsApiRequest between the given points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest put(final String destination) { return new HttpRequest() .method(HttpMethod.PUT) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a PUT request.", "predict": " Creates a new HttpRequest with the PUT method and sets the destination URL.\n\n@param destination Destination URL to set\n@return A newly constructed HttpRequest with the PUT method and the destination URL set."}, {"ID": 684, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirectionsApiRequest getDirections( GeoApiContext context, String origin, String destination) { return new DirectionsApiRequest(context).origin(origin).destination(destination); }\n\n    ### Response: Creates a new DirectionsApiRequest between the given origin and destination, using the defaults\nfor all other options.\n\n@param context Context that the DirectionsApiRequest will be executed against\n@param origin Origin address as text\n@param destination Destination address as text\n@return A newly constructed DirectionsApiRequest between the given points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest patch(final String destination) { return new HttpRequest() .method(HttpMethod.PATCH) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a PATCH request.", "predict": " Creates a new HttpRequest with the PATCH method and sets the destination URL.\n\n@param destination Destination URL for the request\n@return A newly constructed HttpRequest with the PATCH method and the destination URL set."}, {"ID": 685, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String delete(final String inString, final String pattern) { return StringUtils.replace(inString, pattern, \"\"); }\n\n    ### Response: Delete all occurrences of the given substring.\n\n@param inString the original {@code String}\n@param pattern the pattern to delete all occurrences of\n@return the resulting {@code String}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest delete(final String destination) { return new HttpRequest() .method(HttpMethod.DELETE) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a DELETE request.", "predict": " Delete the resource at the given destination.\n\n@param destination the URL of the resource to delete\n@return the resulting {@code HttpRequest} with the DELETE method and the destination URL set."}, {"ID": 686, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest head(final CharSequence baseUrl, final Map<?, ?> params, final boolean encode) { String url = append(baseUrl, params); return head(encode ? encode(url) : url); }\n\n    ### Response: Start a 'HEAD' request to the given URL along with the query params\n\n@param baseUrl\n@param params\nThe query parameters to include as part of the baseUrl\n@param encode\ntrue to encode the full URL\n\n@see #append(CharSequence, Map)\n@see #encode(CharSequence)\n\n@return request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest head(final String destination) { return new HttpRequest() .method(HttpMethod.HEAD) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a HEAD request.", "predict": " Start a 'HEAD' request to the given URL\n\n@param destination\nThe URL to send the request to\n\n@return request."}, {"ID": 687, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirectionsApiRequest getDirections( GeoApiContext context, String origin, String destination) { return new DirectionsApiRequest(context).origin(origin).destination(destination); }\n\n    ### Response: Creates a new DirectionsApiRequest between the given origin and destination, using the defaults\nfor all other options.\n\n@param context Context that the DirectionsApiRequest will be executed against\n@param origin Origin address as text\n@param destination Destination address as text\n@return A newly constructed DirectionsApiRequest between the given points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest trace(final String destination) { return new HttpRequest() .method(HttpMethod.TRACE) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a TRACE request.", "predict": " Sends a TRACE request to the given destination.\n\n@param destination The destination URL to send the TRACE request to\n@return A new HttpRequest object that can be used to send the TRACE request."}, {"ID": 688, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirectionsApiRequest getDirections( GeoApiContext context, String origin, String destination) { return new DirectionsApiRequest(context).origin(origin).destination(destination); }\n\n    ### Response: Creates a new DirectionsApiRequest between the given origin and destination, using the defaults\nfor all other options.\n\n@param context Context that the DirectionsApiRequest will be executed against\n@param origin Origin address as text\n@param destination Destination address as text\n@return A newly constructed DirectionsApiRequest between the given points..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest options(final String destination) { return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds an OPTIONS request.", "predict": " Creates a new HttpRequest with the OPTIONS method and sets the destination URL.\n\n@param destination Destination URL to set\n@return A newly constructed HttpRequest with the OPTIONS method and the destination URL set."}, {"ID": 689, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getLogicalModuleName(String path) // F743-23167 { int lastForwardSlash = path.lastIndexOf('/'); if (lastForwardSlash != -1) { path = path.substring(lastForwardSlash + 1); } int lastDot = path.lastIndexOf('.'); if (lastDot != -1) { path = path.substring(0, lastDot); } return path; }\n\n    ### Response: Parses the logical module name from a module path. The module path is a\nrelative path name using forward slashes. The logical module name is the\nbase name of the module name with the suffix removed.\n\n@param path the module path\n@return the logical module name of the module name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest path(String path) { // this must be the only place that sets the path if (!path.startsWith(StringPool.SLASH)) { path = StringPool.SLASH + path; } int ndx = path.indexOf('?'); if (ndx != -1) { String queryString = path.substring(ndx + 1); path = path.substring(0, ndx); query = HttpUtil.parseQuery(queryString, true); } else { query = HttpMultiMap.newCaseInsensitiveMap(); } this.path = path; return this; }\n\n    ### Response:", "ground_truth": "Sets request path. Query string is allowed.\nAdds a slash if path doesn't start with one.\nQuery will be stripped out from the path.\nPrevious query is discarded.\n@see #query()", "predict": " Sets the path of the request. If the path does not start with a slash, it is prepended with a slash. The query string, if present, is parsed and stored in the query map.\n\n@param path the path to set\n@return this request object\n\n    "}, {"ID": 690, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String composeMessage(List<ValidationResult> results) { StringBuilder builder = new StringBuilder(); builder.append(\"Validation failed\"); if (results != null && results.size() > 0) { boolean first = true; for (ValidationResult result : results) { if (result.getType() != ValidationResultType.Information) { if (!first) builder.append(\": \"); else builder.append(\", \"); builder.append(result.getMessage()); first = false; } } } return builder.toString(); }\n\n    ### Response: Composes human readable error message based on validation results.\n\n@param results a list of validation results.\n@return a composed error message.\n\n@see ValidationResult.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; }\n\n    ### Response:", "ground_truth": "Sets cookies to the request.", "predict": " Adds cookies to the request.\n\n@param cookies the cookies to add to the request.\n@return the updated request.\n\n@see Cookie."}, {"ID": 691, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getParametersAsString(final Object... parameters) { if (parameters == null || parameters.length == 0) { return \"\"; } final StringBuilder builder = new StringBuilder(); builder.append('['); for (int i = 0; i < parameters.length; i++) { builder.append(arrayToString(parameters[i])); if (i < parameters.length - 1) { builder.append(\", \"); } } return builder.append(']').toString(); }\n\n    ### Response: Convert array of given parameters to sting..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; }\n\n    ### Response:", "ground_truth": "Adds many query parameters at once. Although it accepts objects,\neach value will be converted to string.", "predict": " Add query parameters to the request.\n\n    "}, {"ID": 692, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ElementWithOptions setOptions(LinkedHashMap<String, String> options) { this.optionGroups.clear(); for (Map.Entry<String, String> entry : options.entrySet()) { this.addOption(entry.getKey(), entry.getValue()); } return this; }\n\n    ### Response: Replaces all options of this element.\n\n@param options Options to use. {@link LinkedHashMap} to keep options original ordering.\n@return This element.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest query(final Map<String, String> queryMap) { for (Map.Entry<String, String> entry : queryMap.entrySet()) { query.add(entry.getKey(), entry.getValue()); } return this; }\n\n    ### Response:", "ground_truth": "Adds all parameters from the provided map.", "predict": " Adds query parameters to the request.\n\n@param queryMap Query parameters to add.\n@return This request."}, {"ID": 693, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<PathSegment> decodePath(URI u, boolean decode) { String rawPath = u.getRawPath(); if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') { rawPath = rawPath.substring(1); } return decodePath(rawPath, decode); }\n\n    ### Response: Decode the path component of a URI as path segments.\n\n@param u      the URI. If the path component is an absolute path component\nthen the leading '/' is ignored and is not considered a delimiator\nof a path segment.\n@param decode true if the path segments of the path component\nshould be in decoded form.\n@return the list of path segments..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; }\n\n    ### Response:", "ground_truth": "Sets query from provided query string. Previous query values\nare discarded.", "predict": " Set the query string of the request.\n\n@param queryString the query string to set.\n@param decode      true if the query string should be decoded.\n@return this request."}, {"ID": 694, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseUrl(String urlStr, String partToExtract, String key) { if (!\"QUERY\".equals(partToExtract)) { return null; } String query = parseUrl(urlStr, partToExtract); if (query == null) { return null; } Pattern p = Pattern.compile(\"(&|^)\" + Pattern.quote(key) + \"=([^&]*)\"); Matcher m = p.matcher(query); if (m.find()) { return m.group(2); } return null; }\n\n    ### Response: Parse url and return various parameter of the URL.\nIf accept any null arguments, return null.\n\n@param urlStr        URL string.\n@param partToExtract must be QUERY, or return null.\n@param key           parameter name.\n@return target value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String queryString() { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); }\n\n    ### Response:", "ground_truth": "Generates query string. All values are URL encoded.", "predict": " Get the query string of the request.\n\n@return query string."}, {"ID": 695, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getAppURL(HttpServletRequest request) { StringBuffer url = new StringBuffer(); int port = request.getServerPort(); if (port < 0) { port = 80; // Work around java.net.URL bug } String scheme = request.getScheme(); url.append(scheme); url.append(\"://\"); url.append(request.getServerName()); if ((scheme.equals(\"http\") && (port != 80)) || (scheme.equals(\"https\") && (port != 443))) { url.append(':'); url.append(port); } return url.toString(); }\n\n    ### Response: Convenience method to get the application's URL based on request\nvariables..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); }\n\n    ### Response:", "ground_truth": "Returns just host url, without path and query.", "predict": " Returns the URL for the host, including protocol, host, and port. If the port is the default port for the protocol, it is not included in the URL."}, {"ID": 696, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Credentials getCredentials(HttpServletRequest request, String username, String password) { // If no username/password given, try Authorization header if (username == null && password == null) { String authorization = request.getHeader(\"Authorization\"); if (authorization != null && authorization.startsWith(\"Basic \")) { try { // Decode base64 authorization String basicBase64 = authorization.substring(6); String basicCredentials = new String( BaseEncoding.base64().decode(basicBase64), \"UTF-8\"); // Pull username/password from auth data int colon = basicCredentials.indexOf(':'); if (colon != -1) { username = basicCredentials.substring(0, colon); password = basicCredentials.substring(colon + 1); } else logger.debug(\"Invalid HTTP Basic \\\"Authorization\\\" header received.\"); } // UTF-8 support is required by the Java specification catch (UnsupportedEncodingException e) { throw new UnsupportedOperationException(\"Unexpected lack of UTF-8 support.\", e); } } } // end Authorization header fallback // Build credentials return new Credentials(username, password, request); }\n\n    ### Response: Returns the credentials associated with the given request, using the\nprovided username and password.\n\n@param request\nThe request to use to derive the credentials.\n\n@param username\nThe username to associate with the credentials, or null if the\nusername should be derived from the request.\n\n@param password\nThe password to associate with the credentials, or null if the\npassword should be derived from the request.\n\n@return\nA new Credentials object whose contents have been derived from the\ngiven request, along with the provided username and password..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest basicAuthentication(final String username, final String password) { if (username != null && password != null) { String data = username.concat(StringPool.COLON).concat(password); String base64 = Base64.encodeToString(data); headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64); } return this; }\n\n    ### Response:", "ground_truth": "Enables basic authentication by adding required header.", "predict": " Adds Basic Authentication header to the request with the given username and password.\n\n@param username\nThe username to use for authentication.\n\n@param password\nThe password to use for authentication.\n\n@return\nThe updated HttpRequest object."}, {"ID": 697, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String getUserIdentifier(IoSession session) { boolean isAcceptor = isAcceptor(session); SocketAddress hostPortAddress = isAcceptor ? session.getRemoteAddress() : session.getLocalAddress(); SocketAddress identityAddress = isAcceptor ? session.getLocalAddress() : session.getRemoteAddress(); String identity = resolveIdentity(identityAddress, (IoSessionEx)session); String hostPort = getHostPort(hostPortAddress); return identity == null ? hostPort : format(\"%s %s\", identity, hostPort); }\n\n    ### Response: Get a suitable identification for the user. For now this just consists of the TCP endpoint.\nthe HTTP-layer auth principal, etc.\n@param session\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest setHostHeader() { String hostPort = this.host; if (port != Defaults.DEFAULT_PORT) { hostPort += StringPool.COLON + port; } headerOverwrite(HEADER_HOST, hostPort); return this; }\n\n    ### Response:", "ground_truth": "Sets 'Host' header from current host and port.", "predict": " Set the Host header of the HTTP request.\n@param host the host name or IP address of the server\n@return the updated request object.\n\n    "}, {"ID": 698, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public LiveWebState handleRedirect(WaybackException e, WaybackRequest wbRequest, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException { if (statusLiveWebPolicy == null) { return LiveWebState.NOT_FOUND; } // Don't do any redirect for identity context or if no handler is set if ((wbRequest == null) || wbRequest.isIdentityContext() || (liveWebHandler == null)) { return LiveWebState.NOT_FOUND; } int status = e.getStatus(); String stateName = statusLiveWebPolicy.getProperty(String.valueOf(status)); if (stateName == null) { stateName = statusLiveWebPolicy.getProperty(DEFAULT); } RedirectType state = RedirectType.ALL; if (stateName != null) { state = RedirectType.valueOf(stateName); } String redirUrl = null; if (state == RedirectType.NONE) { return LiveWebState.NOT_FOUND; } // If embeds_only and not embed return if it was found if (state == RedirectType.EMBEDS_ONLY) { // boolean allowRedirect = wbRequest.isAnyEmbeddedContext(); // if (!allowRedirect) { // String referrer = wbRequest.getRefererUrl(); // String replayPrefix = wbRequest.getAccessPoint().getReplayPrefix(); // // if ((referrer != null) && (replayPrefix != null) && referrer.startsWith(replayPrefix)) { // allowRedirect = true; // } // } if (!wbRequest.isAnyEmbeddedContext()) { return LiveWebState.FOUND; } // if (!wbRequest.isAnyEmbeddedContext()) { // redirUrl = wbRequest.getRequestUrl(); // } } // Now try to do a redirect redirUrl = liveWebHandler.getLiveWebRedirect(httpRequest, wbRequest, e); // Don't redirect if redirUrl null if (redirUrl == null) { return LiveWebState.NOT_FOUND; } // If set to DEFAULT then compute the standard redir url if (redirUrl.equals(DEFAULT)) { redirUrl = getLiveWebPrefix() + wbRequest.getRequestUrl(); } httpResponse.sendRedirect(redirUrl); return LiveWebState.REDIRECTED; }\n\n    ### Response: Check the statusLiveWebType to see if, given the WaybackExceptions\nstatus code, should redirect ALL, NONE or EMBEDS_ONLY\n\nBefore redirecting, will always check with liveweb to see if it returns a 200 request,\nthen redirect to same request, resulting in 2 checks to liveweb\n\n\"default\" property is checked if no property is found for current access code\nor for other exceptions\n\nIf default property is missing, default is to not redirect\n\n@param e\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected Buffer buffer(final boolean fullRequest) { // INITIALIZATION // host port if (header(HEADER_HOST) == null) { setHostHeader(); } // form Buffer formBuffer = formBuffer(); // query string String queryString = queryString(); // user-agent if (header(\"User-Agent\") == null) { header(\"User-Agent\", Defaults.userAgent); } // POST method requires Content-Type to be set if (method.equals(\"POST\") && (contentLength() == null)) { contentLength(0); } // BUILD OUT Buffer request = new Buffer(); request.append(method) .append(SPACE) .append(path); if (query != null && !query.isEmpty()) { request.append('?'); request.append(queryString); } request.append(SPACE) .append(httpVersion) .append(CRLF); populateHeaderAndBody(request, formBuffer, fullRequest); return request; }\n\n    ### Response:", "ground_truth": "Prepares the request buffer.", "predict": "This method builds out the request buffer by appending the method, path, query string, http version, and headers and body to the buffer. If the fullRequest flag is set to true, the form buffer will also be appended to the buffer. The method also sets the host header if it is not already set. If the method is a POST and the content length is not already set, it will be set to 0.\n\n    @param fullRequest\n    @return Buffer."}, {"ID": 699, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <R> R collect(Func1<Iterable<T>, R> collector) { return collector.call(this); }\n\n    ### Response: Converts the current stream into any value with a given method.\n\n@param collector a method that should be used to return value.\n@param        a type of value to return.\n@return a value that has been returned by the given collecting method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); }\n\n    ### Response:", "ground_truth": "Syntax sugar.", "predict": " Sends an HTTP request and receives a response using a given response handler.\n\n@param responseHandler a method that should be used to handle the response.\n@param                a type of value to return.\n@return a value that has been returned by the given response handler."}, {"ID": 700, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Handler remove(Handler h, Label start, Label end) { if (h == null) { return null; } else { h.next = remove(h.next, start, end); } int hstart = h.start.position; int hend = h.end.position; int s = start.position; int e = end == null ? Integer.MAX_VALUE : end.position; // if [hstart,hend[ and [s,e[ intervals intersect... if (s < hend && e > hstart) { if (s <= hstart) { if (e >= hend) { // [hstart,hend[ fully included in [s,e[, h removed h = h.next; } else { // [hstart,hend[ minus [s,e[ = [e,hend[ h.start = end; } } else if (e >= hend) { // [hstart,hend[ minus [s,e[ = [hstart,s[ h.end = start; } else { // [hstart,hend[ minus [s,e[ = [hstart,s[ + [e,hend[ Handler g = new Handler(); g.start = end; g.end = h.end; g.handler = h.handler; g.desc = h.desc; g.type = h.type; g.next = h.next; h.end = start; h.next = g; } } return h; }\n\n    ### Response: Removes the range between start and end from the given exception\nhandlers.\n\n@param h\nan exception handler list.\n@param start\nthe start of the range to be removed.\n@param end\nthe end of the range to be removed. Maybe null.\n@return the exception handler list with the start-end range removed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Handler removeRange(final Handler firstHandler, final Label start, final Label end) { if (firstHandler == null) { return null; } else { firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end); } int handlerStart = firstHandler.startPc.bytecodeOffset; int handlerEnd = firstHandler.endPc.bytecodeOffset; int rangeStart = start.bytecodeOffset; int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) { return firstHandler; } if (rangeStart <= handlerStart) { if (rangeEnd >= handlerEnd) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler.nextHandler; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler(firstHandler, end, firstHandler.endPc); } } else if (rangeEnd >= handlerEnd) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler(firstHandler, firstHandler.startPc, start); } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = // [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc); return new Handler(firstHandler, firstHandler.startPc, start); } }\n\n    ### Response:", "ground_truth": "Removes the range between start and end from the Handler list that begins with the given\nelement.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@param start the start of the range to be removed.\n@param end the end of the range to be removed. Maybe {@literal null}.\n@return the exception handler list with the start-end range removed.", "predict": " Removes the range between start and end from the given exception\nhandlers.\n\n@param firstHandler\nan exception handler list.\n@param start\nthe start of the range to be removed.\n@param end\nthe end of the range to be removed. Maybe null.\n@return the exception handler list with the start-end range removed."}, {"ID": 701, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int skipWhitespace() { int length = 0; while (CharType.isWhitespace(charAt(offset + length))) { length++; } return offset + length; }\n\n    ### Response: skip whitespace.\n\n@return offset after whitespace skipped.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; }\n\n    ### Response:", "ground_truth": "Returns the number of elements of the Handler list that begins with the given element.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@return the number of elements of the Handler list that begins with 'handler'.", "predict": " get the length of the exception table.\n\n@param firstHandler the first handler in the exception table.\n@return the length of the exception table."}, {"ID": 702, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initInterceptors() { interceptors = new ArrayList<>(); ControllerUtils.collectRouteInterceptors(controllerMethod).forEach(handlerClass -> { try { interceptors.add(handlerClass.newInstance()); } catch (InstantiationException | IllegalAccessException e) { throw new PippoRuntimeException(e); } }); }\n\n    ### Response: Init interceptors from controller method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionInterceptors() { final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors(); interceptors = new ArrayList<>(); interceptors.addAll(interceptorValues); interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all interceptors.", "predict": " Collect action interceptors from interceptors manager.\n\n    "}, {"ID": 703, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void distributeShareFair( double total, final Collection<? extends Schedulable> schedulables) { BinarySearcher searcher = new BinarySearcher() { @Override protected double targetFunction(double x) { return totalShareWithRatio(schedulables, x); } }; double ratio = searcher.getSolution(total); for (Schedulable schedulable : schedulables) { schedulable.share = shareWithRatio(schedulable, ratio); } }\n\n    ### Response: Distribute the total share among the list of schedulables according to the\nFAIR model.\nFinds a way to distribute the share in such a way that all the\nmin and max reservations of the schedulables are satisfied\n@param total the share to be distributed\n@param schedulables the list of schedulables.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionFilters() { final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters(); filters = new ArrayList<>(); filters.addAll(filterValues); filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all filters.", "predict": " Collects all the action filters from the filters manager and stores them in a list.\n@param filtersManager the filters manager to retrieve the filters from.\n\n    "}, {"ID": 704, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> parseLetterLinks(Document aDocument) { final List<String> results = new ArrayList<>(); Elements links = aDocument.select(LETTER_URL_SELECTOR); links.forEach(element -> { if (element.hasAttr(ATTRIBUTE_HREF)) { String subpage = element.attr(ATTRIBUTE_HREF); results.add(OrfConstants.URL_BASE + subpage); } }); return results; }\n\n    ### Response: determines the links to the letter pages\n\n@param aDocument the html document with letter links\n@return list with urls.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all action results.", "predict": " collects the action results from the results manager and sorts them by class name.\n\n@return list of action results sorted by class name."}, {"ID": 705, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void runPostProcessorActions(Object controlledObject, boolean authorized) { String actions = getPostProcessorActionsToRun(); if( logger.isDebugEnabled() ) { logger.debug( \"Run post-processors actions: \" + actions ); } String[] actionIds = StringUtils.commaDelimitedListToStringArray(actions); for( int i = 0; i < actionIds.length; i++ ) { doPostProcessorAction( actionIds[i], controlledObject, authorized ); } }\n\n    ### Response: Run all the requested post-processor actions.\n@param controlledObject Object being controlled\n@param authorized state that has been installed on controlledObject.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); }\n\n    ### Response:", "ground_truth": "Collects all action runtime configurations.", "predict": " Collect all the runtime information for all actions.\n@return List of ActionRuntime objects for all actions."}, {"ID": 706, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void endVisit(PropertyAnnotation node) { FieldDeclaration field = (FieldDeclaration) node.getParent(); TypeMirror fieldType = field.getTypeMirror(); String getter = node.getGetter(); String setter = node.getSetter(); if (field.getFragments().size() > 1) { if (getter != null) { ErrorUtil.error(field, \"@Property getter declared for multiple fields\"); return; } if (setter != null) { ErrorUtil.error(field, \"@Property setter declared for multiple fields\"); return; } } else { // Check that specified accessors exist. TypeElement enclosingType = TreeUtil.getEnclosingTypeElement(node); if (getter != null) { if (ElementUtil.findMethod(enclosingType, getter) == null) { ErrorUtil.error(field, \"Non-existent getter specified: \" + getter); } } if (setter != null) { if (ElementUtil.findMethod( enclosingType, setter, TypeUtil.getQualifiedName(fieldType)) == null) { ErrorUtil.error(field, \"Non-existent setter specified: \" + setter); } } } }\n\n    ### Response: Make sure attempt isn't made to specify an accessor method for fields with multiple fragments,\nsince each variable needs unique accessors..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected void setSimpleProperty(final BeanProperty bp, final Object value) { Setter setter = bp.getSetter(isDeclared); // try: setter if (setter != null) { invokeSetter(setter, bp, value); return; } // try: put(\"property\", value) if (bp.isMap()) { ((Map) bp.bean).put(bp.name, value); return; } if (isSilent) { return; } throw new BeanException(\"Simple property not found: \" + bp.name, bp); }\n\n    ### Response:", "ground_truth": "Sets a value of simple property.", "predict": " This method sets a simple property on a bean. It first tries to find a setter method for the property, and if it finds one, it invokes it with the given value. If the property is a map, it simply puts the value into the map. If no setter or map is found, it throws a BeanException. The method is declared as protected, so it can be overridden by subclasses. The method uses the @SuppressWarnings annotation to suppress unchecked warnings, since the type of the setter method is not known at compile time."}, {"ID": 707, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T getProperty(Object bean, String name) throws SystemException { try { return (T)getNestedProperty(bean, name); } catch (Exception e) { throw new SystemException(\"Get property \\\"\"+name+\"\\\" ERROR:\"+e.getMessage(),e); } }\n\n    ### Response: Retrieve the bean property\n@param bean the bean\n@param name the property name\n@param  the type class of the property for casting\n@return the property\n@throws SystemException the an unknown error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <T> T getProperty(final Object bean, final String name) { BeanProperty beanProperty = new BeanProperty(this, bean, name); if (!isSilent) { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } else { try { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } catch (Exception ignore) { return null; } } }\n\n    ### Response:", "ground_truth": "Returns value of bean's property.", "predict": " Retrieve the bean property\n@param bean the bean\n@param name the property name\n@param  the type class of the property for casting\n@return the property\n\n    "}, {"ID": 708, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); }\n\n    ### Response:", "ground_truth": "Extract the first name of this reference.", "predict": " Extract the \"this\" reference from a property name.  This is typically used to extract the class name from a property name that includes the class name.  For example, if the property name is \"com.example.MyClass.myProperty\", this method would return \"com.example.MyClass\".\n\n@param propertyName the property name to extract the \"this\" reference from\n@return the \"this\" reference, or the full property name if no \"this\" reference is found."}, {"ID": 709, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected PrintWriter getPrintWriter() { if ( printWriter == null || printStream != ChorusOut.out) { printWriter = new PrintWriter(ChorusOut.out); printStream = ChorusOut.out; } return printWriter; }\n\n    ### Response: This is an extension point to change Chorus output\n\nThe user can provider their own OutputWriter which extends the default and\noverrides getPrintWriter() to return a writer configured for a different output stream\n\nn.b. this method will be called frequently so it is expected that the PrintWriter returned\nwill generally be cached and reused by the implementation, but in some circumstances it is\nuseful to be able to change the PrintWriter during the testing process so the details are\nleft to the implementation\n\n@return a PrintWriter to use for all logging.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; }\n\n    ### Response:", "ground_truth": "Returns buffered writer. Buffer will be created if not already used.", "predict": " This is an extension point to change Chorus output\n\nThe user can provider their own OutputWriter which extends the default and\noverrides getWriter() to return a writer configured for a different output stream\n\nn.b. this method will be called frequently so it is expected that the PrintWriter returned\nwill generally be cached and reused by the implementation, but in some circumstances it is\nuseful to be able to change the PrintWriter during the testing process so the details are\nleft to the implementation\n\n@return a PrintWriter to use for all logging."}, {"ID": 710, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void setFwkAttribute(final String name, final Object value) { if (attribMap == null) { attribMap = new HashMap<>(); } attribMap.put(name, value); }\n\n    ### Response: Reserved for internal framework use. Sets a framework attribute.\n\n@param name the attribute name.\n@param value the attribute value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setObjectReference(final String name, final Object object) { if (objectRefs == null) { objectRefs = new HashMap<>(); } objectRefs.put(name, object); }\n\n    ### Response:", "ground_truth": "Saves object reference.", "predict": " Sets an object reference.\n\n@param name the object reference name.\n@param object the object reference."}, {"ID": 711, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object getFwkAttribute(final String name) { if (attribMap == null) { return null; } return attribMap.get(name); }\n\n    ### Response: Reserved for internal framework use. Retrieves a framework attribute.\n\n@param name the attribute name.\n@return the framework attribute with the given name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); }\n\n    ### Response:", "ground_truth": "Returns object reference.", "predict": " Retrieves a reference to an object in the framework.\n\n@param name the object reference name.\n@return the object reference with the given name."}, {"ID": 712, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getInternal( String defaultValue, boolean required) { String value = properties.getProperty(path, defaultValue); if (value != null) { return value; } if (defaultValue == null) { value = getDefaultValue(); if (value != null) { return value; } } if (required) { throw new RuntimeException(\"Property \" + path + \" must be set\"); } return value; }\n\n    ### Response: Retrieves the value of a property, using a given default value, and\noptionally failing if there is no value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; }\n\n    ### Response:", "ground_truth": "Lookups for object reference and throws an exception if reference doesn't exist.", "predict": " Looks up an object by its reference, throwing a DbSqlBuilderException if the reference is invalid."}, {"ID": 713, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Optional<Throwable> findThrowableWithMessage(Throwable throwable, String searchMessage) { if (throwable == null || searchMessage == null) { return Optional.empty(); } Throwable t = throwable; while (t != null) { if (t.getMessage() != null && t.getMessage().contains(searchMessage)) { return Optional.of(t); } else { t = t.getCause(); } } return Optional.empty(); }\n\n    ### Response: Checks whether a throwable chain contains a specific error message and returns the corresponding throwable.\n\n@param throwable the throwable chain to check.\n@param searchMessage the error message to search for in the chain.\n@return Optional throwable containing the search message if available, otherwise empty.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityDescriptor getTableDescriptor(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.desc; }\n\n    ### Response:", "ground_truth": "Returns entity descriptor for provided table reference.", "predict": " Retrieves the descriptor for a table reference.\n\n@param tableRef the table reference to retrieve the descriptor for.\n@return the descriptor for the table reference, or null if not found."}, {"ID": 714, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String determineNetworkResolution(final BucketConfig config, final NetworkResolution nr, final Set<NetworkAddress> seedHosts) { if (nr.equals(NetworkResolution.DEFAULT)) { return null; } else if (nr.equals(NetworkResolution.AUTO)) { for (NodeInfo info : config.nodes()) { if (seedHosts.contains(info.hostname())) { return null; } Map<String, AlternateAddress> aa = info.alternateAddresses(); if (aa != null && !aa.isEmpty()) { for (Map.Entry<String, AlternateAddress> entry : aa.entrySet()) { AlternateAddress alternateAddress = entry.getValue(); if (alternateAddress != null && seedHosts.contains(alternateAddress.hostname())) { return entry.getKey(); } } } } return null; } else { return nr.name(); } }\n\n    ### Response: Helper method to figure out which network resolution should be used.\n\nif DEFAULT is selected, then null is returned which is equal to the \"internal\" or default\nconfig mode. If AUTO is used then we perform the select heuristic based off of the seed\nhosts given. All other resolution settings (i.e. EXTERNAL) are returned directly and are\nconsidered to be part of the alternate address configs.\n\n@param config the config to check against\n@param nr the network resolution setting from the environment\n@param seedHosts the seed hosts from bootstrap for autoconfig.\n@return the found setting if external is used, null if internal/default is used..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) { for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) { DbEntityDescriptor ded = entry.getValue().desc; if (ded.findByPropertyName(columnRef) != null) { return ded; } } return null; }\n\n    ### Response:", "ground_truth": "Finds entity descriptor of a table that contains provided column reference.", "predict": " Helper method to find the table descriptor based on a column reference.\n\n@param columnRef the column reference to search for\n@return the found table descriptor or null if not found.\n\n    "}, {"ID": 715, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Optional<Throwable> findThrowableWithMessage(Throwable throwable, String searchMessage) { if (throwable == null || searchMessage == null) { return Optional.empty(); } Throwable t = throwable; while (t != null) { if (t.getMessage() != null && t.getMessage().contains(searchMessage)) { return Optional.of(t); } else { t = t.getCause(); } } return Optional.empty(); }\n\n    ### Response: Checks whether a throwable chain contains a specific error message and returns the corresponding throwable.\n\n@param throwable the throwable chain to check.\n@param searchMessage the error message to search for in the chain.\n@return Optional throwable containing the search message if available, otherwise empty.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTableAlias(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.alias; }\n\n    ### Response:", "ground_truth": "Returns table alias for provided table reference.", "predict": " Retrieves the alias for a given table reference.\n\n@param tableRef the table reference to retrieve the alias for.\n@return the alias for the given table reference, or null if not found."}, {"ID": 716, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int sendRequest(final String methodName, final String url, final List<Header> hdrs, final String contentType, final int contentLen, final byte[] content) throws HttpException { int sz = 0; if (content != null) { sz = content.length; } if (debug()) { debug(\"About to send request: method=\" + methodName + \" url=\" + url + \" contentLen=\" + contentLen + \" content.length=\" + sz + \" contentType=\" + contentType); } try { URI u = new URI(url); if (!hostSpecified && (u.getHost() == null)) { if ((baseURI == null) && (baseURIValue != null)) { baseURI = new URI(baseURIValue); } if (baseURI == null) { throw new HttpException(\"No base URI specified for non-absolute URI \" + url); } if (baseURI.getHost() == null) { throw new HttpException(\"Base URI must be absolute: \" + baseURI); } u = baseURI.resolve(u); } if (debug()) { debug(\" url resolves to \" + u); } method = findMethod(methodName, u); if (credentials != null) { getCredentialsProvider().setCredentials(new AuthScope(u.getHost(), u.getPort()), credentials); } if (!Util.isEmpty(hdrs)) { for (final Header hdr: hdrs) { method.addHeader(hdr); } } if (method instanceof HttpEntityEnclosingRequestBase) { if (content != null) { if (contentType == null) { setContent(content, \"text/xml\"); } else { setContent(content, contentType); } } } response = execute(method); } catch (final HttpException he) { throw he; } catch (final Throwable t) { throw new HttpException(t.getLocalizedMessage(), t); } status = response.getStatusLine().getStatusCode(); return status; }\n\n    ### Response: Send a request to the server\n\n@param methodName the method, GET, PUT etc\n@param url the url\n@param hdrs may be null\n@param contentType\n@param contentLen\n@param content\n@return int    status code\n@throws HttpException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) { if (tableRefs == null) { tableRefs = new HashMap<>(); } TableRefData t = new TableRefData(ded, tableAlias); if (tableRefs.put(tableReference, t) != null) { throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference); } }\n\n    ### Response:", "ground_truth": "Registers table reference for provided entity.", "predict": " Register a table reference\n\n@param tableReference the table reference\n@param ded the DbEntityDescriptor\n@param tableAlias the table alias\n@throws DbSqlBuilderException if the table reference is duplicated."}, {"ID": 717, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String getAttribute(Node node, String name, boolean required) { NamedNodeMap attributes = node.getAttributes(); Node idNode = attributes.getNamedItem(name); if (idNode == null) { if (required) { throw new IllegalArgumentException(toPath(node) + \" has no \" + name + \" attribute\"); } else { return \"\"; } } else { String value = idNode.getNodeValue(); if (value == null) { return \"\"; } return value; } }\n\n    ### Response: Get an Attribute from the given node and throwing an exception in the case it is required but\nnot present\n\n@param node\n@param name\n@param required\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor lookupTableRef(final String tableRef) { DbEntityDescriptor ded = getTableDescriptor(tableRef); if (ded == null) { throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef); } return ded; }\n\n    ### Response:", "ground_truth": "Lookups for table reference and throws an exception if table reference not found.", "predict": " Lookup a table reference in the current query and return the corresponding DbEntityDescriptor.\n\n@param tableRef\n@return the corresponding DbEntityDescriptor.\n\n    "}, {"ID": 718, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function _hideHints() { var hints = this._targetElement.querySelectorAll('.introjs-hint'); if (hints && hints.length > 0) { for (var i = 0; i < hints.length; i++) { _hideHint.call(this, hints[i].getAttribute('data-step')); } } }\n\n    ### Response: Hide all hints\n\n@api private\n@method _hideHints.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); }\n\n    ### Response:", "ground_truth": "Registers a hint.", "predict": " Register a hint for the current step.\n\n@api public\n@method registerHint."}, {"ID": 719, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final boolean complete(Object value) { for (; ; ) { final Object oldState = state; if (isDone(oldState)) { warnIfSuspiciousDoubleCompletion(oldState, value); return false; } if (compareAndSetState(oldState, value)) { onComplete(); unblockAll(oldState, defaultExecutor); return true; } } }\n\n    ### Response: Can be called multiple times, but only the first answer will lead to the\nfuture getting triggered. All subsequent complete calls are ignored.\n\n@param value The type of response to offer.\n@return true if offered response, either a final response or an\ninternal response, is set/applied, false otherwise. If false\nis returned, that means offered response is ignored because a final response\nis already set to this future..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final boolean serialize(final JsonContext jsonContext, final T value) { if (jsonContext.pushValue(value)) { // prevent circular dependencies return false; } serializeValue(jsonContext, value); jsonContext.popValue(); return true; }\n\n    ### Response:", "ground_truth": "Detects circular dependencies and pushes value as current\ntype context.", "predict": "Serializes the given value to the given JsonContext.\n\n@param jsonContext The JsonContext to serialize the value to.\n@param value The value to serialize.\n@return true if the value was successfully serialized, false otherwise.\n\n    "}, {"ID": 720, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void handleInboundHttpHeaders(final SoapMessage message, final WebServiceEndpointConfiguration endpointConfiguration) { final TransportContext transportContext = TransportContextHolder.getTransportContext(); if (transportContext == null) { log.warn(\"Unable to get complete set of http request headers - no transport context available\"); return; } final WebServiceConnection connection = transportContext.getConnection(); if (connection instanceof HttpServletConnection) { final UrlPathHelper pathHelper = new UrlPathHelper(); final HttpServletConnection servletConnection = (HttpServletConnection) connection; final HttpServletRequest httpServletRequest = servletConnection.getHttpServletRequest(); message.setHeader(SoapMessageHeaders.HTTP_REQUEST_URI, pathHelper.getRequestUri(httpServletRequest)); message.setHeader(SoapMessageHeaders.HTTP_CONTEXT_PATH, pathHelper.getContextPath(httpServletRequest)); final String queryParams = pathHelper.getOriginatingQueryString(httpServletRequest); message.setHeader(SoapMessageHeaders.HTTP_QUERY_PARAMS, queryParams != null ? queryParams : \"\"); message.setHeader(SoapMessageHeaders.HTTP_REQUEST_METHOD, httpServletRequest.getMethod()); if (endpointConfiguration.isHandleAttributeHeaders()) { final Enumeration<String> attributeNames = httpServletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attributeName = attributeNames.nextElement(); final Object attribute = httpServletRequest.getAttribute(attributeName); message.setHeader(attributeName, attribute); } } } else { log.warn(\"Unable to get complete set of http request headers\"); try { message.setHeader(SoapMessageHeaders.HTTP_REQUEST_URI, connection.getUri()); } catch (final URISyntaxException e) { log.warn(\"Unable to get http request uri from http connection\", e); } } }\n\n    ### Response: Reads information from Http connection and adds them as Http marked headers to internal message representation.\n\n@param message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) { final Enumeration<String> attributeNames = servletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attrName = attributeNames.nextElement(); targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(attrName); if (name != null) { final Object attrValue = servletRequest.getAttribute(attrName); target.writeValue(name, attrValue, true); } }); } }\n\n    ### Response:", "ground_truth": "Injects request attributes.", "predict": " Injects attributes from the Http request to the target objects.\n\n@param servletRequest.\n@param targets."}, {"ID": 721, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initialiseParamValues(final Step step) { final HashMap<String, String> map = new HashMap<String, String>(); final String[] paramValues = Util.getArgs(this.parent.getPattern(), step.getLine(), null); if (paramValues != null) { for (int i = 0; i < paramValues.length; i++) { map.put(this.parent.getParamNames().get(i), paramValues[i]); } } this.paramValueMap = new ExampleParameter(step.getSourceLineNumber(), map); }\n\n    ### Response: only called by tests.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) { final boolean encode = encodeGetParams && servletRequest.getMethod().equals(\"GET\"); final Enumeration<String> paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = ServletUtil.prepareParameters( paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues != null) { if (encode) { for (int j = 0; j < paramValues.length; j++) { final String p = paramValues[j]; if (p != null) { final String encoding = madvocEncoding.getEncoding(); paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding); } } } final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]); target.writeValue(name, value, true); } } }); } }\n\n    ### Response:", "ground_truth": "Inject request parameters.", "predict": " injects parameters into the targets."}, {"ID": 722, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Element searchForNode(final Element root, final String searchKey, final String attrName, final DitaClass classValue) { if (root == null) { return null; } final Queue<Element> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { final Element pe = queue.poll(); final NodeList pchildrenList = pe.getChildNodes(); for (int i = 0; i < pchildrenList.getLength(); i++) { final Node node = pchildrenList.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { queue.offer((Element) node); } } if (pe.getAttribute(ATTRIBUTE_NAME_CLASS) == null || !classValue.matches(pe)) { continue; } final Attr value = pe.getAttributeNode(attrName); if (value == null) { continue; } if (searchKey.equals(value.getValue())) { return pe; } } return null; }\n\n    ### Response: Search for the special kind of node by specialized value. Equivalent to XPath\n\n$root//*[contains(@class, $classValue)][@*[name() = $attrName and . = $searchKey]]\n\n@param root       place may have the node.\n@param searchKey  keyword for search.\n@param attrName   attribute name for search.\n@param classValue class value for search.\n@return matching element, {@code null} if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) { if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } final Enumeration<String> paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { final FileUpload[] paramValues = multipartRequest.getFiles(paramName); if (ignoreInvalidUploadFiles) { for (int j = 0; j < paramValues.length; j++) { final FileUpload paramValue = paramValues[j]; if ((!paramValue.isValid()) || (!paramValue.isUploaded())) { paramValues[j] = null; } } } final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues); target.writeValue(name, value, true); } }); } }\n\n    ### Response:", "ground_truth": "Inject uploaded files from multipart request parameters.", "predict": " Inject uploaded files into the targets.\n\n@param servletRequest  the request object.\n@param targets          the targets to inject files into.\n@param ignoreInvalidUploadFiles  whether to ignore invalid or not uploaded files."}, {"ID": 723, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getHierarchyTable(ClassDescriptorDef classDef) { ArrayList queue = new ArrayList(); String tableName = null; queue.add(classDef); while (!queue.isEmpty()) { ClassDescriptorDef curClassDef = (ClassDescriptorDef)queue.get(0); queue.remove(0); if (curClassDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true)) { if (tableName != null) { if (!tableName.equals(curClassDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE))) { return null; } } else { tableName = curClassDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE); } } for (Iterator it = curClassDef.getExtentClasses(); it.hasNext();) { curClassDef = (ClassDescriptorDef)it.next(); if (curClassDef.getReference(\"super\") == null) { queue.add(curClassDef); } } } return tableName; }\n\n    ### Response: Tries to return the single table to which all classes in the hierarchy with the given\nclass as the root map.\n\n@param classDef The root class of the hierarchy\n@return The table name or null if the classes map to more than one table\nor no class in the hierarchy maps to a table.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String convertPropertyNameToColumnName(final String propertyName) { StringBuilder tableName = new StringBuilder(propertyName.length() * 2); if (splitCamelCase) { String convertedTableName = Format.fromCamelCase(propertyName, separatorChar); tableName.append(convertedTableName); } else { tableName.append(propertyName); } if (!changeCase) { return tableName.toString(); } return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString(); }\n\n    ### Response:", "ground_truth": "Converts property name to column name.", "predict": "Converts a property name to a column name according to the current settings.\n\n@param propertyName The property name to convert\n@return The column name according to the current settings.\n\n    "}, {"ID": 724, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String patternToRegex(String pattern) { if (pattern == null) { return \".*\"; } else { StringBuilder result = new StringBuilder(pattern.length()); boolean escaped = false; for (int i = 0, len = pattern.length(); i < len; i++) { char c = pattern.charAt(i); if (escaped) { if (c != SEARCH_STRING_ESCAPE) { escaped = false; } result.append(c); } else { if (c == SEARCH_STRING_ESCAPE) { escaped = true; continue; } else if (c == '%') { result.append(\".*\"); } else if (c == '_') { result.append('.'); } else { result.append(Character.toLowerCase(c)); } } } return result.toString(); } }\n\n    ### Response: Convert a SQL search pattern into an equivalent Java Regex.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@code getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String convertColumnNameToPropertyName(final String columnName) { StringBuilder propertyName = new StringBuilder(columnName.length()); int len = columnName.length(); if (splitCamelCase) { boolean toUpper = false; for (int i = 0; i < len; i++) { char c = columnName.charAt(i); if (c == separatorChar) { toUpper = true; continue; } if (toUpper) { propertyName.append(Character.toUpperCase(c)); toUpper = false; } else { propertyName.append(Character.toLowerCase(c)); } } return propertyName.toString(); } return columnName; }\n\n    ### Response:", "ground_truth": "Converts column name to property name.", "predict": " Convert a column name to a property name.\n\n@param columnName the column name to convert\n@return the property name equivalent to the column name. If the column name\nis already in property form, it is returned unchanged. If the column name\ncontains separator characters, they are used to split the name into words,\nand each word is capitalized and concatenated with the next word. If the\n{@code splitCamelCase} flag is set to false, the column name is returned\nunchanged."}, {"ID": 725, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String propertyNameFromMethodName(Configuration configuration, String name) { String propertyName = null; if (name.startsWith(\"get\") || name.startsWith(\"set\")) { propertyName = name.substring(3); } else if (name.startsWith(\"is\")) { propertyName = name.substring(2); } if ((propertyName == null) || propertyName.isEmpty()){ return \"\"; } return propertyName.substring(0, 1).toLowerCase(configuration.getLocale()) + propertyName.substring(1); }\n\n    ### Response: A convenience method to get property name from the name of the\ngetter or setter method.\n@param name name of the getter or setter method.\n@return the name of the property of the given setter of getter..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String applyToColumnName(final String columnName) { String propertyName = convertColumnNameToPropertyName(columnName); return convertPropertyNameToColumnName(propertyName); }\n\n    ### Response:", "ground_truth": "Applies column naming strategy to given column name hint.\nReturns full column name.", "predict": " A convenience method to convert a column name to a property name and then to a column name.\n@param columnName the name of the column to convert.\n@return the name of the column corresponding to the given property name.\n\n    "}, {"ID": 726, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setObjectForStatement(PreparedStatement stmt, int index, Object value, int sqlType) throws SQLException { if (value == null) { m_platform.setNullForStatement(stmt, index, sqlType); } else { m_platform.setObjectForStatement(stmt, index, value, sqlType); } }\n\n    ### Response: Sets object for statement at specific index, adhering to platform- and null-rules.\n@param stmt the statement\n@param index the current parameter index\n@param value the value to set\n@param sqlType the JDBC SQL-type of the value\n@throws SQLException on platform error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException { T t = TypeConverterManager.get().convertType(value, sqlType); set(st, index, t, dbSqlType); }\n\n    ### Response:", "ground_truth": "Stores value in database. Value is casted to sql type.", "predict": " Stores a value in a prepared statement at a specific index, adhering to platform- and null-rules.\n@param st the statement\n@param index the current parameter index\n@param value the value to store\n@param dbSqlType the JDBC SQL-type of the value\n@throws SQLException on platform error.\n\n    "}, {"ID": 727, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E findById(final Class<E> entityClass, final Object primaryKey) { E e = find(entityClass, primaryKey); if (e == null) { return null; } // Return a copy of this entity return (E) (e); }\n\n    ### Response: Find object based on primary key either form persistence cache or from\ndatabase\n\n@param entityClass\n@param primaryKey\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected <E> E prepareGetValue(final T t, final Class<E> destinationType) { if (t == null) { return null; } if (destinationType == null) { return (E) t; } return TypeConverterManager.get().convertType(t, destinationType); }\n\n    ### Response:", "ground_truth": "Once when value is read from result set, prepare it to match destination type.\n@param t get value\n@param destinationType destination type", "predict": " Prepare the value for the given entity and destination type.\n\n@param t\n@param destinationType\n@return."}, {"ID": 728, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> Set<T> difference(Set<T> u, Set<T> a) { Set<T> set = new HashSet<>(u); set.removeAll(a); return set; }\n\n    ### Response: Set difference of U and A, denoted U \\ A, is the set of all members of U\nthat are not members of A\n@param \n@param u\n@param a\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Set<T> getAll() { final Set<T> set = new HashSet<>(wrappers.size()); set.addAll(wrappers.values()); return set; }\n\n    ### Response:", "ground_truth": "Returns all action wrappers. Returns a copy in new set.", "predict": " Get all the elements in the set.\n@return a set containing all the elements in the set."}, {"ID": 729, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object resolveWrapperProxy(EJSLocalWrapperProxy proxy) { WrapperProxyState state = proxy.ivState; Object wrapper = state.ivWrapper; if (wrapper == null) { do { state = state.reconnect(); wrapper = state.ivWrapper; } while (wrapper == null); proxy.ivState = state; } else { if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) Tr.debug(tc, \"resolveWrapperProxy: \" + state); } return wrapper; }\n\n    ### Response: Resolves the wrapper for a local object wrapper proxy.\n\n@param proxy the proxy state\n@return the wrapper\n@throws EJBException if the proxy cannot be reconnected.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; }\n\n    ### Response:", "ground_truth": "Resolves single wrapper. Creates new wrapper instance if not already registered.\nDoes not expand the wrappers.", "predict": "Resolves a wrapper for the specified class.\n\n@param wrapperClass the wrapper class\n@return the wrapper\n@throws EJBException if the wrapper cannot be resolved or created."}, {"ID": 730, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public IEntityGroupStore newInstance() throws GroupsException { try { return new RDBMEntityGroupStore(); } catch (Exception ex) { log.error(\"ReferenceEntityGroupStoreFactory.newInstance(): \" + ex); throw new GroupsException(ex); } }\n\n    ### Response: Return an instance of the group store implementation.\n\n@return IEntityGroupStore\n@exception GroupsException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } }\n\n    ### Response:", "ground_truth": "Creates new wrapper.", "predict": " Create a new instance of the specified wrapper class.\n\n@param wrapperClass the wrapper class to create an instance of\n@return a new instance of the specified wrapper class\n@exception MadvocException if the wrapper class cannot be created."}, {"ID": 731, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ObjectReference getObjectRefByPath(final String path) { if (path == null) { return null; } return new ObjectReference().withSelector(path); }\n\n    ### Response: Gets object ref by path.\n\n@param path the path\n@return the object ref by path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } }\n\n    ### Response:", "ground_truth": "Converts all separators to the system separator.\n\n@param path  the path to be changed, null ignored\n@return the updated path", "predict": " Converts separators to system.\n\n@param path the path\n@return the path with system separators.\n\n    "}, {"ID": 732, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getFullPath(String filename) { if (filename == null) { return null; } int index = indexOfLastSeparator(filename); if (index < 0) { return StringUtils.EMPTY; } return filename.substring(0, index); }\n\n    ### Response: Gets the path from a full filename.\n\n@param filename a full filename\n@return the path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String doGetPath(final String filename, final int separatorAdd) { if (filename == null) { return null; } int prefix = getPrefixLength(filename); if (prefix < 0) { return null; } int index = indexOfLastSeparator(filename); int endIndex = index + separatorAdd; if (prefix >= filename.length() || index < 0 || prefix >= endIndex) { return StringPool.EMPTY; } return filename.substring(prefix, endIndex); }\n\n    ### Response:", "ground_truth": "Does the work of getting the path.\n\n@param filename  the filename\n@param separatorAdd  0 to omit the end separator, 1 to return it\n@return the path", "predict": " Gets the path from a full filename.\n\n@param filename a full filename\n@param separatorAdd the number of additional separators to add to the end of the path\n@return the path."}, {"ID": 733, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Pure @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static URL getParentURL(URL url) throws MalformedURLException { if (url == null) { return url; } String path = url.getPath(); final String prefix; final String parentStr; switch (URISchemeType.getSchemeType(url)) { case JAR: final int index = path.indexOf(JAR_URL_FILE_ROOT); assert index > 0; prefix = path.substring(0, index + 1); path = path.substring(index + 1); parentStr = URL_PATH_SEPARATOR; break; case FILE: prefix = null; parentStr = \"..\" + URL_PATH_SEPARATOR; //$NON-NLS-1$ break; //$CASES-OMITTED$ default: prefix = null; parentStr = URL_PATH_SEPARATOR; } if (path == null || \"\".equals(path)) { //$NON-NLS-1$ path = parentStr; } int index = path.lastIndexOf(URL_PATH_SEPARATOR_CHAR); if (index == -1) { path = parentStr; } else if (index == path.length() - 1) { index = path.lastIndexOf(URL_PATH_SEPARATOR_CHAR, index - 1); if (index == -1) { path = parentStr; } else { path = path.substring(0, index + 1); } } else { path = path.substring(0, index + 1); } if (prefix != null) { path = prefix + path; } return new URL(url.getProtocol(), url.getHost(), url.getPort(), path); }\n\n    ### Response: Replies the parent URL for the given URL.\n\n@param url the URL.\n@return the parent URL\n@throws MalformedURLException if the parent URL cannot be built..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } return new String[] {prefix, path, baseName, extension}; }\n\n    ### Response:", "ground_truth": "Splits filename into a array of four Strings containing prefix, path, basename and extension.\nPath will contain ending separator.", "predict": " Splits the given filename into its prefix, path, base name, and extension components.\n\n@param filename the filename to split.\n@return an array of four strings: the prefix, path, base name, and extension components.\n\n    "}, {"ID": 734, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String inlineCssImports(final String css, final String basePath) { String retValue = css; int start; while ((start = retValue.indexOf(CSS_IMPORT_START)) != -1) { int end = retValue.indexOf(CSS_IMPORT_END, start); if (end != -1) { final String filePath = retValue.substring(start + CSS_IMPORT_START.length(), end); final String fileData = FileUtilities.readFileContents(new File(basePath + \"/\" + filePath)); retValue = retValue.replace(CSS_IMPORT_START + filePath + CSS_IMPORT_END, fileData); } } return retValue; }\n\n    ### Response: Finds any reference to an external CSS scripts that themselves have been\nreferenced in a CSS script using an import statement and replaces the\nnode with inline CSS data.\n\n@param doc      The document that holds the XHTML\n@param basePath The base path where the CSS scripts can be found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String relativePath(final String targetPath, final String basePath) { return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString(); }\n\n    ### Response:", "ground_truth": "Calculates relative path of target path on base path.", "predict": " Returns the relative path from the base path to the target path.\n\n@param targetPath The path to the target file or directory\n@param basePath   The base path where the relative path should be calculated from."}, {"ID": 735, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public TypeDescription getArrayType() { Class<?> c = getTeaToolsUtils().getArrayType(mType); if (mType == c) { return this; } return getTeaToolsUtils().createTypeDescription(c); }\n\n    ### Response: Returns the array type.  Returns this if it is not an\narray type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; }\n\n    ### Response:", "ground_truth": "Registers additional Madvoc components after the registration of default components.", "predict": " Registers a component with the web application.  The component must not be null.\n\n    "}, {"ID": 736, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <A extends Annotation> A findAnnotation(TypeElement element, Class<A> anno) { final A annotation = element.getAnnotation(anno); if (annotation != null) { return annotation; } final TypeMirror typeMirror = element.getSuperclass(); if (typeMirror.getKind() == TypeKind.NONE) { return null; } final TypeElement element1 = (TypeElement)typeUtils.asElement(typeMirror); return findAnnotation(element1, anno); }\n\n    ### Response: Find the annotation searching the inheritance hierarchy..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; }\n\n    ### Response:", "ground_truth": "Configures the action configurations.", "predict": " Registers an action configuration with the ActionConfigManager. The action configuration is identified by the given actionConfigType and the actionConfigConsumer is used to configure the action."}, {"ID": 737, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private synchronized void removeExpiredEntriesSynced(long pTime) { if (pTime > nextExpiryTime) { //// long next = Long.MAX_VALUE; nextExpiryTime = next; // Avoid multiple runs... for (Iterator<Entry<K, V>> iterator = new EntryIterator(); iterator.hasNext();) { TimedEntry<K, V> entry = (TimedEntry<K, V>) iterator.next(); //// long expires = entry.expires(); if (expires < next) { next = expires; } //// } //// nextExpiryTime = next; } }\n\n    ### Response: Okay, I guess this do resemble DCL...\n\n@todo Write some exhausting multi-threaded unit-tests.\n\n@param pTime now.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WebApp start() { log = LoggerFactory.getLogger(WebApp.class); log.debug(\"Initializing Madvoc WebApp\"); //// params & props for (final Map<String, Object> params : paramsList) { madvocContainer.defineParams(params); } for (final Props props : propsList) { madvocContainer.defineParams(props); } propsList = null; //// components registerMadvocComponents(); madvocComponents.forEach( madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer())); madvocComponents = null; madvocComponentInstances.forEach(madvocContainer::registerComponentInstance); madvocComponentInstances = null; configureDefaults(); //// listeners madvocContainer.fireEvent(Init.class); //// component configuration componentConfigs.accept(madvocContainer); componentConfigs = null; initialized(); madvocContainer.fireEvent(Start.class); if (!madvocRouterConsumers.isEmpty()) { final MadvocRouter madvocRouter = MadvocRouter.create(); madvocContainer.registerComponentInstance(madvocRouter); madvocRouterConsumers.accept(madvocRouter); } madvocRouterConsumers = null; started(); madvocContainer.fireEvent(Ready.class); ready(); return this; }\n\n    ### Response:", "ground_truth": "Initializes and starts web application.", "predict": "This method is responsible for starting the Madvoc web application. It does the following:\n\n1. Initializes the logger.\n2. Defines parameters and properties for the Madvoc container.\n3. Registers Madvoc components with the container.\n4. Registers component instances with the container.\n5. Configures default values for the Madvoc container.\n6. Fires the Init event.\n7. Applies component configurations to the Madvoc container.\n8. Initializes the Madvoc container.\n9. Fires the Start event.\n10. Creates and registers a Madvoc router with the container if there are any Madvoc router consumers.\n11. Fires the Ready event.\n12. Returns the Madvoc web application instance.\n\n@todo Write some exhausting multi-threaded unit-tests."}, {"ID": 738, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void selectSREFromConfig(ILaunchConfiguration config) { final boolean notify = this.sreBlock.getNotify(); final boolean changed; try { this.sreBlock.setNotify(false); if (this.accessor.getUseSystemSREFlag(config)) { changed = this.sreBlock.selectSystemWideSRE(); } else if (this.accessor.getUseProjectSREFlag(config)) { changed = this.sreBlock.selectProjectSRE(); } else { final String sreId = this.accessor.getSREId(config); final ISREInstall sre = SARLRuntime.getSREFromId(Strings.nullToEmpty(sreId)); changed = this.sreBlock.selectSpecificSRE(sre); } } finally { this.sreBlock.setNotify(notify); } if (changed) { updateLaunchConfigurationDialog(); } }\n\n    ### Response: Loads the SARL runtime environment from the launch configuration's preference store.\n\n@param config the config to load the runtime environment from.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void configureDefaults() { final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class); actionConfigManager.registerAnnotation(Action.class); actionConfigManager.registerAnnotation(RestAction.class); }\n\n    ### Response:", "ground_truth": "Configure defaults.", "predict": "Configures the default annotations for the Madvoc framework.\n\n@param madvocContainer the Madvoc container to configure."}, {"ID": 739, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void parseErrorPages(final ErrorPageType errorPageType, final WebApp webApp) { final WebAppErrorPage errorPage = new WebAppErrorPage(); if (errorPageType.getErrorCode() != null) { errorPage.setErrorCode(errorPageType.getErrorCode().getValue().toString()); } if (errorPageType.getExceptionType() != null) { errorPage.setExceptionType(errorPageType.getExceptionType().getValue()); } if (errorPageType.getLocation() != null) { errorPage.setLocation(errorPageType.getLocation().getValue()); } if (errorPage.getErrorCode() == null && errorPage.getExceptionType() == null) { errorPage.setExceptionType(ErrorPageModel.ERROR_PAGE); } webApp.addErrorPage(errorPage); }\n\n    ### Response: Parses error pages out of web.xml.\n\n@param errorPageType errorPageType element from web.xml\n@param webApp        model for web.xml.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerMadvocComponents() { if (madvocContainer == null) { throw new MadvocException(\"Madvoc WebApp not initialized.\"); } log.debug(\"Registering Madvoc WebApp components\"); madvocContainer.registerComponent(MadvocEncoding.class); madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext)); madvocContainer.registerComponent(ActionConfigManager.class); madvocContainer.registerComponent(ActionMethodParamNameResolver.class); madvocContainer.registerComponent(ActionMethodParser.class); madvocContainer.registerComponent(ActionPathRewriter.class); madvocContainer.registerComponent(ActionsManager.class); madvocContainer.registerComponent(ContextInjectorComponent.class); madvocContainer.registerComponent(InterceptorsManager.class); madvocContainer.registerComponent(FiltersManager.class); madvocContainer.registerComponent(MadvocController.class); madvocContainer.registerComponent(RootPackages.class); madvocContainer.registerComponent(ResultsManager.class); madvocContainer.registerComponent(ResultMapper.class); madvocContainer.registerComponent(ScopeResolver.class); madvocContainer.registerComponent(ScopeDataInspector.class); madvocContainer.registerComponent(AsyncActionExecutor.class); madvocContainer.registerComponent(FileUploader.class); }\n\n    ### Response:", "ground_truth": "Registers default Madvoc components.", "predict": " Registers Madvoc components.\n\n@throws MadvocException if Madvoc WebApp not initialized."}, {"ID": 740, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassGraph whitelistModules(final String... moduleNames) { for (final String moduleName : moduleNames) { scanSpec.moduleWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePackageOrClassName(moduleName)); } return this; }\n\n    ### Response: Whitelist one or more modules to scan.\n\n@param moduleNames\nThe names of the modules that should be scanned. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner excludeJars(final String... excludedJars) { for (final String excludedJar : excludedJars) { rulesJars.exclude(excludedJar); } return this; }\n\n    ### Response:", "ground_truth": "Specify excluded jars.", "predict": " Exclude one or more jars from the scan.\n\n@param excludedJars\nThe names of the jars that should be excluded from the scan. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)."}, {"ID": 741, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassGraph whitelistModules(final String... moduleNames) { for (final String moduleName : moduleNames) { scanSpec.moduleWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePackageOrClassName(moduleName)); } return this; }\n\n    ### Response: Whitelist one or more modules to scan.\n\n@param moduleNames\nThe names of the modules that should be scanned. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner includeJars(final String... includedJars) { for (final String includedJar : includedJars) { rulesJars.include(includedJar); } return this; }\n\n    ### Response:", "ground_truth": "Specify included jars.", "predict": " Include one or more jars in the scan.\n\n@param includedJars\nThe names of the jars that should be included in the scan. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)."}, {"ID": 742, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassGraph whitelistModules(final String... moduleNames) { for (final String moduleName : moduleNames) { scanSpec.moduleWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePackageOrClassName(moduleName)); } return this; }\n\n    ### Response: Whitelist one or more modules to scan.\n\n@param moduleNames\nThe names of the modules that should be scanned. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; }\n\n    ### Response:", "ground_truth": "Sets included set of names that will be considered during configuration.\n@see InExRules", "predict": " Include one or more entries in the scan.\n\n@param includedEntries\nThe entries that should be included in the scan. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining).."}, {"ID": 743, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassGraph whitelistModules(final String... moduleNames) { for (final String moduleName : moduleNames) { scanSpec.moduleWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePackageOrClassName(moduleName)); } return this; }\n\n    ### Response: Whitelist one or more modules to scan.\n\n@param moduleNames\nThe names of the modules that should be scanned. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner excludeEntries(final String... excludedEntries) { for (final String excludedEntry : excludedEntries) { rulesEntries.exclude(excludedEntry); } return this; }\n\n    ### Response:", "ground_truth": "Sets excluded names that narrows included set of packages.\n@see InExRules", "predict": " Exclude one or more entries from the scan.\n\n@param excludedEntries\nThe entries that should be excluded from the scan. May contain a wildcard glob ({@code '*'}).\n@return this (for method chaining).."}, {"ID": 744, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void unzip(final File file, final String outputDir) throws IOException { try (final ZipFile zipFile = new ZipFile(file)) { final Enumeration<? extends ZipEntry> entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry entry = entries.nextElement(); final File targetFile = new File(outputDir, entry.getName()); if (entry.isDirectory()) { targetFile.mkdirs(); } else { targetFile.getParentFile().mkdirs(); InputStream in = zipFile.getInputStream(entry); try (OutputStream out = new FileOutputStream(targetFile)) { IOUtils.copy(in, out); IOUtils.closeQuietly(in); } } } } }\n\n    ### Response: Unzip given file to given output directory.\n\n@param file\n@param outputDir\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void scanJarFile(final File file) { final ZipFile zipFile; try { zipFile = new ZipFile(file); } catch (IOException ioex) { if (!ignoreException) { throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex); } return; } final Enumeration entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry zipEntry = (ZipEntry) entries.nextElement(); final String zipEntryName = zipEntry.getName(); try { if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) { final String entryName = prepareEntryName(zipEntryName, true); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } else if (includeResources) { final String entryName = prepareEntryName(zipEntryName, false); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } } catch (RuntimeException rex) { if (!ignoreException) { ZipUtil.close(zipFile); throw rex; } } } ZipUtil.close(zipFile); }\n\n    ### Response:", "ground_truth": "Scans classes inside single JAR archive. Archive is scanned as a zip file.\n@see #onEntry(ClassPathEntry)", "predict": " Scan the given jar file and extract all the class files and resources.\n\n@param file\n@throws FindFileException.\n\n    "}, {"ID": 745, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void handleResourceLoader(final Object resourceLoader, final ClassLoader classLoader, final ClasspathOrder classpathOrderOut, final ScanSpec scanSpec, final LogNode log) { if (resourceLoader == null) { return; } // PathResourceLoader has root field, which is a Path object final Object root = ReflectionUtils.getFieldVal(resourceLoader, \"root\", false); // type VirtualFile final File physicalFile = (File) ReflectionUtils.invokeMethod(root, \"getPhysicalFile\", false); String path = null; if (physicalFile != null) { final String name = (String) ReflectionUtils.invokeMethod(root, \"getName\", false); if (name != null) { // getParentFile() removes \"contents\" directory final File file = new File(physicalFile.getParentFile(), name); if (FileUtils.canRead(file)) { path = file.getAbsolutePath(); } else { // This is an exploded jar or classpath directory path = physicalFile.getAbsolutePath(); } } else { path = physicalFile.getAbsolutePath(); } } else { path = (String) ReflectionUtils.invokeMethod(root, \"getPathName\", false); if (path == null) { // Try Path or File final File file = root instanceof Path ? ((Path) root).toFile() : root instanceof File ? (File) root : null; if (file != null) { path = file.getAbsolutePath(); } } } if (path == null) { final File file = (File) ReflectionUtils.getFieldVal(resourceLoader, \"fileOfJar\", false); if (file != null) { path = file.getAbsolutePath(); } } if (path != null) { classpathOrderOut.addClasspathEntry(path, classLoader, scanSpec, log); } else { if (log != null) { log.log(\"Could not determine classpath for ResourceLoader: \" + resourceLoader); } } }\n\n    ### Response: Handle a resource loader.\n\n@param resourceLoader\nthe resource loader\n@param classLoader\nthe classloader\n@param classpathOrderOut\nthe classpath order\n@param scanSpec\nthe scan spec\n@param log\nthe log.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void scanClassPath(final File root) { String rootPath = root.getAbsolutePath(); if (!rootPath.endsWith(File.separator)) { rootPath += File.separatorChar; } final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath); File file; while ((file = ff.nextFile()) != null) { final String filePath = file.getAbsolutePath(); try { if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) { scanClassFile(filePath, rootPath, file, true); } else if (includeResources) { scanClassFile(filePath, rootPath, file, false); } } catch (RuntimeException rex) { if (!ignoreException) { throw rex; } } } }\n\n    ### Response:", "ground_truth": "Scans single classpath directory.\n@see #onEntry(ClassPathEntry)", "predict": " Scan the class path.\n\n@param root\nthe root directory.\n\n    "}, {"ID": 746, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int extactLookupId(final HBaseClient client, final byte[] table, final short idwidth, final String kind, final byte[] id) { final UniqueId uid = new UniqueId(client, table, kind, (int) idwidth); try { final String name = uid.getName(id); System.out.println(kind + ' ' + name + \": \" + Arrays.toString(id)); return 0; } catch (NoSuchUniqueId e) { LOG.error(e.getMessage()); return 1; } }\n\n    ### Response: Looks up an ID for a given kind, and prints it if found.\n@param client The HBase client to use.\n@param table The name of the HBase table to use.\n@param idwidth Number of bytes on which the UIDs should be.\n@param kind The 'kind' of the ID (must not be {@code null}).\n@param id The ID to look for.\n@return 0 if the ID for this kind was found, 1 otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] bytecodeSignatureOfType(final Class type) { final String name = 'L' + type.getName().replace('.', '/') + ';'; return name.getBytes(); }\n\n    ### Response:", "ground_truth": "Returns type signature bytes used for searching in class file.", "predict": " Returns the bytecode signature of a given type.\n@param type The type to get the signature for.\n@return The bytecode signature of the type."}, {"ID": 747, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassGraph whitelistPaths(final String... paths) { for (final String path : paths) { final String pathNormalized = WhiteBlackList.normalizePath(path); // Whitelist path final String packageName = WhiteBlackList.pathToPackageName(pathNormalized); scanSpec.packageWhiteBlackList.addToWhitelist(packageName); scanSpec.pathWhiteBlackList.addToWhitelist(pathNormalized + \"/\"); if (pathNormalized.isEmpty()) { scanSpec.pathWhiteBlackList.addToWhitelist(\"\"); } if (!pathNormalized.contains(\"*\")) { // Whitelist sub-directories / nested paths if (pathNormalized.isEmpty()) { scanSpec.packagePrefixWhiteBlackList.addToWhitelist(\"\"); scanSpec.pathPrefixWhiteBlackList.addToWhitelist(\"\"); } else { scanSpec.packagePrefixWhiteBlackList.addToWhitelist(packageName + \".\"); scanSpec.pathPrefixWhiteBlackList.addToWhitelist(pathNormalized + \"/\"); } } } return this; }\n\n    ### Response: Scan one or more specific paths, and their sub-directories or nested paths.\n\n@param paths\nThe paths to scan, relative to the package root of the classpath element (with '/' as a\nseparator). May include a glob wildcard ({@code '*'}).\n@return this (for method chaining)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner scan(final String... paths) { for (final String path : paths) { filesToScan.add(new File(path)); } return this; }\n\n    ### Response:", "ground_truth": "Scans provided paths.", "predict": " Scan one or more specific files or directories.\n\n@param paths\nThe paths to scan, relative to the package root of the classpath element (with '/' as a\nseparator). May include a glob wildcard ({@code '*'}).\n@return this (for method chaining).."}, {"ID": 748, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void listAllFiles(final Set<String> setOfPaths, final String inputPath) { if (inputPath == null) { return; } File[] files = new File(inputPath).listFiles(); if (files == null) { return; } for (File file : files) { if (file.isDirectory()) { listAllFiles(setOfPaths, file.getAbsolutePath()); } else if (file.getName().contains(\"_train.dat\")) { setOfPaths.add(file.getAbsolutePath().replaceAll(\"_train.dat\", \"\")); } } }\n\n    ### Response: List all files at a certain path.\n\n@param setOfPaths the set of files at a certain path\n@param inputPath the path to check.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { if (detectEntriesMode) { rulesEntries.detectMode(); } filesToScan.forEach(file -> { final String path = file.getAbsolutePath(); if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) { if (!acceptJar(file)) { return; } scanJarFile(file); } else if (file.isDirectory()) { scanClassPath(file); } }); }\n\n    ### Response:", "ground_truth": "Starts with the scanner.", "predict": " Start the scanning process.\n\n@param detectEntriesMode whether to detect entries mode or not\n@param filesToScan the list of files to scan\n@param acceptJar the function to accept or reject a jar file\n@param scanJarFile the function to scan a jar file\n@param scanClassPath the function to scan a class path"}, {"ID": 749, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) { if (!ScriptRuntime.hasTopCall(cx)) { return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args, idata.isStrict); } return Interpreter.interpret(this, cx, scope, thisObj, args); }\n\n    ### Response: Calls the function.\n@param cx the current context\n@param scope the scope used for the call\n@param thisObj the value of \"this\"\n@param args function arguments. Must not be null. You can use\n{@link ScriptRuntime#emptyArgs} to pass empty arguments.\n@return the result of the function call..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) { return new DbJtxTransaction(this, tm, scope, active); }\n\n    ### Response:", "ground_truth": "Builds new transaction instance.", "predict": " Creates a new transaction.\n@param tm the transaction mode\n@param scope the scope for the transaction\n@param active whether the transaction is active or not\n@return the new transaction."}, {"ID": 750, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <S extends T> S get(String name, Class<S> c) { return (S) get(name); }\n\n    ### Response: Convenience method that allows specification of return ISetting type so that you can nest the call to\naccess the setting value.\n\n{@code\nSettingManager manager = ...;\nmanger.add(new BooleanIOSetting(\"Setting\", ...));\n\nif(manager.get(\"Setting\", BooleanIOSetting.class).isSet()){\n// do something\n}\n\n}\n\n@param name name of the setting to retrieve\n@param c    the class of the setting (matching generic return type). This is need\nas due to type erasure we don't know the class of 'S' at runtime\n@param   type that will be return\n\n@return instance of the setting\n\n@see #get(String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass); }\n\n    ### Response:", "ground_truth": "Lookups the scope instance of given scope annotation.\nIf instance does not exist, it will be created, cached and returned.", "predict": "Returns the default scope or the scope of the specified class.\n\n@param scopeClass the class of the scope to retrieve. If null, the default scope will be returned.\n@return the scope of the specified class or the default scope if scopeClass is null.\n\n@see #getOrInitScope(Class)"}, {"ID": 751, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private State getState(final Class<? extends State> stateClass) throws NotAvailableException { if (!stateMap.containsKey(stateClass)) { try { final State state; try { state = stateClass.getConstructor().newInstance(); } catch (IllegalAccessException | IllegalArgumentException | InstantiationException | NoSuchMethodException | SecurityException | InvocationTargetException ex) { throw new CouldNotPerformException(\"Could not create instance of \" + stateClass.getName(), ex); } stateMap.put(stateClass, state); return state; } catch (CouldNotPerformException ex) { throw new NotAvailableException(stateClass, ex); } } return stateMap.get(stateClass); }\n\n    ### Response: Method loads the state referred by the state class.\n\nOnce the state is loaded it will be cached and next time the state is requested the cached instance will be returned out of performance reasons.\n\n@param stateClass the class defining the state to load.\n@return an new or cached instance of the state..\n@throws NotAvailableException is thrown if the state could not be loaded..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) { for (final MadvocScope s : allScopes) { if (s.getClass().equals(madvocScopeType)) { return s; } } // new scope detected final MadvocScope newScope; try { newScope = madpc.createBean(madvocScopeType); } catch (Exception ex) { throw new MadvocException(\"Unable to create scope: \" + madvocScopeType, ex); } allScopes.add(newScope); return newScope; }\n\n    ### Response:", "ground_truth": "Performs search for the scope class and returns it's instance.", "predict": " Method retrieves or initializes a MadvocScope instance.\n\nThe method first checks if there is already a MadvocScope instance of the specified type in the list of all scopes. If there is, it returns that instance. If not, it creates a new instance of the specified type using the Madvoc instance's createBean method. If the creation fails, it throws a MadvocException.\n\n@param madvocScopeType the type of MadvocScope to retrieve or initialize.\n@return a MadvocScope instance of the specified type.\n@throws MadvocException if the MadvocScope instance could not be created."}, {"ID": 752, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initBeforeList() { final List<ProcessAdvice> beforeRequestProcessAdvices = new ArrayList<>(); final Method invokeHolder = getInvokeHolder(); final Class<?> processorClass = invokeHolder.getDeclaringClass(); // 1. process class advice if (null != processorClass && processorClass.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = processorClass.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } // 2. process method advice if (invokeHolder.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = invokeHolder.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } this.beforeRequestProcessAdvices = beforeRequestProcessAdvices; }\n\n    ### Response: Initializes before process advices..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) { final MadvocScope scope = getOrInitScope(scopeType); madvocScopeConsumer.accept(scope); }\n\n    ### Response:", "ground_truth": "Finds a given scope and consumes it.", "predict": " Retrieves or initializes the specified scope and passes it to the specified consumer."}, {"ID": 753, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] decode(char[] src, int[] table, char pad) { int len = src.length; if (len == 0) return new byte[0]; int padCount = (src[len - 1] == pad ? (src[len - 2] == pad ? 2 : 1) : 0); int bytes = (len * 6 >> 3) - padCount; int blocks = (bytes / 3) * 3; byte[] dst = new byte[bytes]; int si = 0, di = 0; while (di < blocks) { int n = table[src[si++]] << 18 | table[src[si++]] << 12 | table[src[si++]] << 6 | table[src[si++]]; dst[di++] = (byte) (n >> 16); dst[di++] = (byte) (n >> 8); dst[di++] = (byte) n; } if (di < bytes) { int n = 0; switch (len - si) { case 4: n |= table[src[si+3]]; case 3: n |= table[src[si+2]] << 6; case 2: n |= table[src[si+1]] << 12; case 1: n |= table[src[si]] << 18; } for (int r = 16; di < bytes; r -= 8) { dst[di++] = (byte) (n >> r); } } return dst; }\n\n    ### Response: Decode base64 chars to bytes using the supplied decode table and padding\ncharacter.\n\n@param src   Base64 encoded data.\n@param table Decode table.\n@param pad   Padding character.\n\n@return Decoded bytes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] decode(final char[] arr) { int length = arr.length; if (length == 0) { return new byte[0]; } int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0; int len = ((cnt - sepCnt) * 6 >> 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) { int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx++]] << 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i >> 16); dest[d++] = (byte) (i >> 8); dest[d++] = (byte) i; if (sepCnt > 0 && ++cc == 19) { sndx += 2; cc = 0; } } if (d < len) { int i = 0; for (int j = 0; sndx <= endx - pad; j++) { i |= INV[arr[sndx++]] << (18 - j * 6); } for (int r = 16; d < len; r -= 8) { dest[d++] = (byte) (i >> r); } } return dest; }\n\n    ### Response:", "ground_truth": "Decodes a BASE64 encoded char array.", "predict": " Decode base64 chars to bytes using the default decode table and padding character.\n\n@param arr Base64 encoded data.\n\n@return Decoded bytes."}, {"ID": 754, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getSystemProperty(String name, String defaultValue) { String value; value = System.getProperty(name, null); if (value != null) { return value; } value = System.getenv(name); if (value != null) { return value; } return defaultValue; }\n\n    ### Response: Replies the value of the system property.\n\n@param name\n- name of the property.\n@param defaultValue\n- value to reply if the these is no property found\n@return the value, or defaultValue..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static String prepareCsrfToken(final HttpSession session, final int timeToLive) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if (tokenSet == null) { tokenSet = new HashSet<>(); session.setAttribute(CSRF_TOKEN_SET, tokenSet); } String value; boolean unique; do { value = RandomString.get().randomAlphaNumeric(32); assureSize(tokenSet); unique = tokenSet.add(new Token(value, timeToLive)); } while (!unique); return value; }\n\n    ### Response:", "ground_truth": "Generates new CSRF token and puts it in the session. Returns generated token value.", "predict": " Generates a CSRF token for the given session and timeToLive.\n\n@param session\n- the session to generate the token for.\n@param timeToLive\n- the time in seconds the token should be valid for.\n@return the generated token.\n\n    "}, {"ID": 755, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void discardTombstones() { if (activeTransactions.isEmpty()) { Iterator<Map.Entry<K, MapEntryValue>> iterator = entries().entrySet().iterator(); while (iterator.hasNext()) { MapEntryValue value = iterator.next().getValue(); if (value.type() == MapEntryValue.Type.TOMBSTONE) { iterator.remove(); } } } else { long lowWaterMark = activeTransactions.values().stream() .mapToLong(TransactionScope::version) .min().getAsLong(); Iterator<Map.Entry<K, MapEntryValue>> iterator = entries().entrySet().iterator(); while (iterator.hasNext()) { MapEntryValue value = iterator.next().getValue(); if (value.type() == MapEntryValue.Type.TOMBSTONE && value.version < lowWaterMark) { iterator.remove(); } } } }\n\n    ### Response: Discards tombstones no longer needed by active transactions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static void assureSize(final Set<Token> tokenSet) { if (tokenSet.size() < maxTokensPerSession) { return; } long validUntilMin = Long.MAX_VALUE; Token tokenToRemove = null; Iterator<Token> iterator = tokenSet.iterator(); while (iterator.hasNext()) { Token token = iterator.next(); if (token.isExpired()) { iterator.remove(); continue; } if (token.validUntil < validUntilMin) { validUntilMin = token.validUntil; tokenToRemove = token; } } if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) { tokenSet.remove(tokenToRemove); } }\n\n    ### Response:", "ground_truth": "Removes expired tokens if token set is full.\n@see #setMaxTokensPerSession(int)", "predict": " Ensures that the token set size is less than or equal to the maximum allowed tokens per session. If the size is greater than the maximum allowed tokens per session, it removes the token with the earliest expiration time."}, {"ID": 756, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean eventsEqual(@Nullable final List<CommonEvent> eventsA, @Nullable final List<CommonEvent> eventsB) { if ((eventsA == null) && (eventsB == null)) { return true; } if ((eventsA == null) && (eventsB != null)) { return false; } if ((eventsA != null) && (eventsB == null)) { return false; } if (eventsA.size() != eventsB.size()) { return false; } int currentIdx = eventsA.size() - 1; int appendIdx = eventsB.size() - 1; while (appendIdx >= 0) { final CommonEvent current = eventsA.get(currentIdx); final CommonEvent append = eventsB.get(appendIdx); if (!current.equals(append)) { return false; } currentIdx--; appendIdx--; } return true; }\n\n    ### Response: Tests if both lists contain the same events.\n\n@param eventsA\nFirst event list.\n@param eventsB\nSecond event list.\n\n@return TRUE if both lists have the same size and all event identifiers are equal..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if ((tokenSet == null) && (tokenValue == null)) { return true; } if ((tokenSet == null) || (tokenValue == null)) { return false; } boolean found = false; Iterator<Token> it = tokenSet.iterator(); while (it.hasNext()) { Token t = it.next(); if (t.isExpired()) { it.remove(); continue; } if (t.getValue().equals(tokenValue)) { it.remove(); found = true; } } return found; }\n\n    ### Response:", "ground_truth": "Checks token value.\nC", "predict": " Checks if the CSRF token is valid and removes it from the session if it is.\n\n@param session\nThe HTTP session.\n@param tokenValue\nThe CSRF token value.\n\n@return TRUE if the token is valid and removed from the session, FALSE otherwise."}, {"ID": 757, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object toNeo4JProperty(Object source) { if (source instanceof BigDecimal || source instanceof BigInteger) { return source.toString(); } else if ((source instanceof Calendar) || (source instanceof GregorianCalendar)) { return PropertyAccessorHelper.fromSourceToTargetClass(String.class, Date.class, ((Calendar) source).getTime()); } if (source instanceof Date) { Class<?> sourceClass = source.getClass(); return PropertyAccessorHelper.fromSourceToTargetClass(String.class, sourceClass, source); } return source; }\n\n    ### Response: Converts a given field value to an object that is Neo4J compatible\n\n@param source\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BeanCopy from(final Object source) { BeanCopy beanCopy = new BeanCopy(source); beanCopy.isSourceMap = source instanceof Map; return beanCopy; }\n\n    ### Response:", "ground_truth": "Defines source, detects a map.", "predict": " Creates a new instance of BeanCopy with the given source object.\n\n@param source\n@return a new instance of BeanCopy."}, {"ID": 758, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void copy() { if (elems.nonEmpty()) { List<A> orig = elems; elems = last = List.of(orig.head); while ((orig = orig.tail).nonEmpty()) { last.tail = List.of(orig.head); last = last.tail; } } }\n\n    ### Response: Copy list and sets last..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void copy() { beanUtil = new BeanUtilBean() .declared(declared) .forced(forced) .silent(true); visit(); }\n\n    ### Response:", "ground_truth": "Performs the copying.", "predict": " Copy beanutil and set properties."}, {"ID": 759, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean updatePomProperty(Properties properties, String name, Object value, boolean updated) { if (value != null) { Object oldValue = properties.get(name); if (!Objects.equal(oldValue, value)) { getLOG().debug(\"Updating pom.xml property: \" + name + \" to \" + value); properties.put(name, value); return true; } } return updated; }\n\n    ### Response: Updates the given maven property value if value is not null and returns true if the pom has been changed\n\n@return true if the value changed and was non null or updated was true.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected boolean visitProperty(String name, final Object value) { if (isTargetMap) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } beanUtil.setProperty(destination, name, value); return true; }\n\n    ### Response:", "ground_truth": "Copies single property to the destination.\nExceptions are ignored, so copying continues if\ndestination does not have some of the sources properties.", "predict": " Visits the given property and sets it on the destination object using beanutils.\n\n@param name the name of the property to visit\n@param value the value of the property to set on the destination object\n@return true to continue visiting properties, false to stop."}, {"ID": 760, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void restoreState(final FacesContext context, final Object state) { if (state == null) { return; } final Object values[] = (Object[]) state; super.restoreState(context, values[0]); final Object restoredSubmittedValues = values[1]; final Object restoredLocalValues = values[2]; final Object restoredInvalidUpdates = values[3]; final Object restoredColMappings = values[4]; final Object restoredSortedList = values[5]; final Object restoredRowMap = values[6]; final Object restoredRowNumbers = values[7]; if (restoredSubmittedValues == null) { submittedValues.clear(); } else { submittedValues = (Map<SheetRowColIndex, String>) restoredSubmittedValues; } if (restoredLocalValues == null) { localValues.clear(); } else { localValues = (Map<SheetRowColIndex, Object>) restoredLocalValues; } if (restoredInvalidUpdates == null) { getInvalidUpdates().clear(); } else { invalidUpdates = (List<SheetInvalidUpdate>) restoredInvalidUpdates; } if (restoredColMappings == null) { columnMapping = null; } else { columnMapping = (Map<Integer, Integer>) restoredColMappings; } if (restoredSortedList == null) { getFilteredValue().clear(); } else { setFilteredValue((List<Object>) restoredSortedList); } if (restoredRowMap == null) { rowMap = null; } else { rowMap = (Map<String, Object>) restoredRowMap; } if (restoredRowNumbers == null) { rowNumbers = null; } else { rowNumbers = (Map<String, Integer>) restoredRowNumbers; } }\n\n    ### Response: Restores the state for the submitted, local and bad values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final TemplateData templateData) { super.init(templateData); if (entity != null) { ded = lookupType(entity); } else { Object object = templateData.getObjectReference(entityName); if (object != null) { ded = lookupType(resolveClass(object)); } else { ded = lookupName(entityName); } } String tableReference = this.tableReference; if (tableReference == null) { tableReference = tableAlias; } if (tableReference == null) { tableReference = entityName; } if (tableReference == null) { tableReference = ded.getEntityName(); } templateData.registerTableReference(tableReference, ded, tableAlias); }\n\n    ### Response:", "ground_truth": "Resolves and registers table references.", "predict": " Initializes the component with the given template data.\n\n    "}, {"ID": 761, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <S extends Scope> Set<S> getScopesByType(Class<S> scopeType) { Set<S> typedScopes = new HashSet<>(); for (Scope scope : getScopes()) { if (scopeType.isInstance(scope)) { typedScopes.add((S) scope); } } return typedScopes; }\n\n    ### Response: Filters the scopes corresponding to a type\n\n@param        the type of the scope to filter.\n@param scopeType the type of scope\n@return the scopes of the given type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <S extends Scope> S resolveScope(final Class<S> scopeType) { S scope = (S) scopes.get(scopeType); if (scope == null) { try { scope = newInternalInstance(scopeType, (PetiteContainer) this); } catch (Exception ex) { throw new PetiteException(\"Invalid Petite scope: \" + scopeType.getName(), ex); } registerScope(scopeType, scope); scopes.put(scopeType, scope); } return scope; }\n\n    ### Response:", "ground_truth": "Resolves and registers scope from a scope type.", "predict": " Resolves a scope of a given type.\n\n@param        the type of the scope to resolve.\n@param scopeType the type of scope\n@return the resolved scope.\n\n    "}, {"ID": 762, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ViewDispatcher getViewDispatcher(Activity activity) throws ViewDispatcherException { if (dispatchRule.getViewDispatcher() != null) { return dispatchRule.getViewDispatcher(); } try { String dispatcherName; if (dispatchRule.getDispatcherName() != null) { dispatcherName = dispatchRule.getDispatcherName(); } else { dispatcherName = activity.getSetting(ViewDispatcher.VIEW_DISPATCHER_SETTING_NAME); if (dispatcherName == null) { throw new IllegalArgumentException(\"The settings name '\" + ViewDispatcher.VIEW_DISPATCHER_SETTING_NAME + \"' has not been specified in the default response rule\"); } } ViewDispatcher viewDispatcher = cache.get(dispatcherName); if (viewDispatcher == null) { if (dispatcherName.startsWith(BeanRule.CLASS_DIRECTIVE_PREFIX)) { String dispatcherClassName = dispatcherName.substring(BeanRule.CLASS_DIRECTIVE_PREFIX.length()); Class<?> dispatcherClass = activity.getEnvironment().getClassLoader().loadClass(dispatcherClassName); viewDispatcher = (ViewDispatcher)activity.getBean(dispatcherClass); } else { viewDispatcher = activity.getBean(dispatcherName); } if (viewDispatcher == null) { throw new IllegalArgumentException(\"No bean named '\" + dispatcherName + \"' is defined\"); } if (viewDispatcher.isSingleton()) { ViewDispatcher existing = cache.putIfAbsent(dispatcherName, viewDispatcher); if (existing != null) { viewDispatcher = existing; } else { if (log.isDebugEnabled()) { log.debug(\"Caching \" + viewDispatcher); } } } } return viewDispatcher; } catch(Exception e) { throw new ViewDispatcherException(\"Unable to determine ViewDispatcher\", e); } }\n\n    ### Response: Determine the view dispatcher.\n\n@param activity the current Activity\n@throws ViewDispatcherException if ViewDispatcher can not be determined.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> BeanDefinition<T> registerPetiteBean( final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer ) { if (name == null) { name = resolveBeanName(type); } if (wiringMode == null) { wiringMode = annotationResolver.resolveBeanWiringMode(type); } if (wiringMode == WiringMode.DEFAULT) { wiringMode = petiteConfig.getDefaultWiringMode(); } if (scopeType == null) { scopeType = annotationResolver.resolveBeanScopeType(type); } if (scopeType == null) { scopeType = SingletonScope.class; } // remove existing bean BeanDefinition existing = removeBean(name); if (existing != null) { if (petiteConfig.getDetectDuplicatedBeanNames()) { throw new PetiteException( \"Duplicated bean name detected while registering class '\" + type.getName() + \"'. Petite bean class '\" + existing.type.getName() + \"' is already registered with the name: \" + name); } } // check if type is valid if (type.isInterface()) { throw new PetiteException(\"PetiteBean can not be an interface: \" + type.getName()); } // registration if (log.isDebugEnabled()) { log.info(\"Petite bean: [\" + name + \"] --> \" + type.getName() + \" @ \" + scopeType.getSimpleName() + \":\" + wiringMode.toString()); } // register Scope scope = resolveScope(scopeType); BeanDefinition<T> beanDefinition = createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); registerBean(name, beanDefinition); // providers ProviderDefinition[] providerDefinitions = petiteResolvers.resolveProviderDefinitions(type, name); if (providerDefinitions != null) { for (ProviderDefinition providerDefinition : providerDefinitions) { providers.put(providerDefinition.name, providerDefinition); } } // define if (define) { beanDefinition.ctor = petiteResolvers.resolveCtorInjectionPoint(beanDefinition.type()); beanDefinition.properties = PropertyInjectionPoint.EMPTY; beanDefinition.methods = MethodInjectionPoint.EMPTY; beanDefinition.initMethods = InitMethodPoint.EMPTY; beanDefinition.destroyMethods = DestroyMethodPoint.EMPTY; } // return return beanDefinition; }\n\n    ### Response:", "ground_truth": "Registers or defines a bean.\n\n@param type bean type, must be specified\n@param name bean name, if null it will be resolved from the class (name or annotation)\n@param scopeType bean scope, if null it will be resolved from the class (annotation or default one)\n@param wiringMode wiring mode, if null it will be resolved from the class (annotation or default one)\n@param define when set to true bean will be defined - all injection points will be set to none", "predict": " Register a new Petite bean.\n\n@param type the bean type\n@param name the bean name (optional)\n@param scopeType the bean scope type (optional)\n@param wiringMode the bean wiring mode (optional)\n@param define if true, the bean will be defined immediately after registration\n@param consumer the bean consumer (optional)\n@return the registered bean definition\n\n    "}, {"ID": 763, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void inspectGetters(Method method) { String methodName = method.getName(); int prefixLength = 0; if (methodName.startsWith(GET_PREFIX)) { prefixLength = GET_PREFIX.length(); } if (methodName.startsWith(IS_PREIX)) { prefixLength = IS_PREIX.length(); } if(prefixLength == 0) { return; } String name = decapitalize(methodName.substring(prefixLength)); if(!isValidProperty(name)) { return; } // Check that the return type is not null or void Class propertyType = method.getReturnType(); if (propertyType == null || propertyType == void.class) { return; } // isXXX return boolean if (prefixLength == 2) { if (!(propertyType == boolean.class)) { return; } } // validate parameter types Class[] paramTypes = method.getParameterTypes(); if (paramTypes.length > 1 || (paramTypes.length == 1 && paramTypes[0] != int.class)) { return; } if (!method.isAnnotationPresent(UriTransient.class) && !\"class\".equals(name)) { Object value = getValue(method); if (method.isAnnotationPresent(VarName.class)) { name = method.getAnnotation(VarName.class).value(); } if (value != null) { pairs.put(name, value); } } }\n\n    ### Response: A lite version of the introspection logic performed by the BeanInfo introspector.\n@param method.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerBean(final String name, final BeanDefinition beanDefinition) { beans.put(name, beanDefinition); if (!petiteConfig.isUseAltBeanNames()) { return; } Class type = beanDefinition.type(); if (annotationResolver.beanHasAnnotationName(type)) { return; } Class[] interfaces = ClassUtil.resolveAllInterfaces(type); for (Class anInterface : interfaces) { String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames()); if (name.equals(altName)) { continue; } if (beans.containsKey(altName)) { continue; } if (beansAlt.containsKey(altName)) { BeanDefinition existing = beansAlt.get(altName); if (existing != null) { beansAlt.put(altName, null); // store null as value to mark that alt name is duplicate } } else { beansAlt.put(altName, beanDefinition); } } }\n\n    ### Response:", "ground_truth": "Registers bean definition by putting it in the beans map. If bean does\nnot have petite name explicitly defined, alternative bean names\nwill be registered.", "predict": " Registers a new bean definition with the given name and bean definition. If the petite configuration specifies that alternative bean names should be used, this method will also register alternative bean names for the given bean definition's type."}, {"ID": 764, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clear() { for (Bean bean : beans.values()) { if (null != bean.destructionCallback) { bean.destructionCallback.run(); } } beans.clear(); }\n\n    ### Response: Clear all beans and call the destruction callback..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeBean(final Class type) { // collect bean names Set<String> beanNames = new HashSet<>(); for (BeanDefinition def : beans.values()) { if (def.type.equals(type)) { beanNames.add(def.name); } } // remove collected bean names for (String beanName : beanNames) { removeBean(beanName); } }\n\n    ### Response:", "ground_truth": "Removes all petite beans of provided type. Bean name is not resolved from a type!\nInstead, all beans are iterated and only beans with equal types are removed.\n@see #removeBean(String)", "predict": " Remove all beans of the specified type."}, {"ID": 765, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parseMultipartParameters(Map<String, List<FileItem>> fileItemListMap, RequestAdapter requestAdapter) { String encoding = requestAdapter.getEncoding(); MultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>(); MultiValueMap<String, FileParameter> fileParameterMap = new LinkedMultiValueMap<>(); for (Map.Entry<String, List<FileItem>> entry : fileItemListMap.entrySet()) { String fieldName = entry.getKey(); List<FileItem> fileItemList = entry.getValue(); if (fileItemList != null && !fileItemList.isEmpty()) { for (FileItem fileItem : fileItemList) { if (fileItem.isFormField()) { String value = getString(fileItem, encoding); parameterMap.add(fieldName, value); } else { String fileName = fileItem.getName(); // Skip file uploads that don't have a file name - meaning that // no file was selected. if (StringUtils.isEmpty(fileName)) { continue; } boolean valid = FilenameUtils.isValidFileExtension(fileName, allowedFileExtensions, deniedFileExtensions); if (!valid) { continue; } MemoryMultipartFileParameter fileParameter = new MemoryMultipartFileParameter(fileItem); fileParameterMap.add(fieldName, fileParameter); if (log.isDebugEnabled()) { log.debug(\"Found multipart file [\" + fileParameter.getFileName() + \"] of size \" + fileParameter.getFileSize() + \" bytes, stored \" + fileParameter.getStorageDescription()); } } } } } if (!parameterMap.isEmpty()) { for (Map.Entry<String, List<String>> entry : parameterMap.entrySet()) { String name = entry.getKey(); List<String> list = entry.getValue(); String[] values = list.toArray(new String[0]); requestAdapter.setParameter(name, values); } } if (!fileParameterMap.isEmpty()) { for (Map.Entry<String, List<FileParameter>> entry : fileParameterMap.entrySet()) { String name = entry.getKey(); List<FileParameter> list = entry.getValue(); FileParameter[] values = list.toArray(new FileParameter[0]); requestAdapter.setFileParameter(name, values); } } }\n\n    ### Response: Parse form fields and file items.\n\n@param fileItemListMap the file item list map\n@param requestAdapter the request adapter.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] resolveBeanNamesForType(final Class type) { String[] beanNames = beanCollections.get(type); if (beanNames != null) { return beanNames; } ArrayList<String> list = new ArrayList<>(); for (Map.Entry<String, BeanDefinition> entry : beans.entrySet()) { BeanDefinition beanDefinition = entry.getValue(); if (ClassUtil.isTypeOf(beanDefinition.type, type)) { String beanName = entry.getKey(); list.add(beanName); } } if (list.isEmpty()) { beanNames = StringPool.EMPTY_ARRAY; } else { beanNames = list.toArray(new String[0]); } beanCollections.put(type, beanNames); return beanNames; }\n\n    ### Response:", "ground_truth": "Resolves bean names for give type.", "predict": " Resolve bean names for the given type.\n\n@param type the type\n@return the array of bean names for the given type."}, {"ID": 766, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Constructor getConstructor(final String name) throws ClassNotFoundException, NoSuchMethodException { Constructor constructor = constructorsCache.get(name); if (constructor == null) { synchronized (constructorsCache) { constructor = constructorsCache.get(name); if (constructor == null) { ClassLoader tccl = Thread.currentThread().getContextClassLoader(); if (tccl == null) { constructor = Class.forName(name).getDeclaredConstructor(); } else { constructor = Class.forName(name, true, tccl).getDeclaredConstructor(); } constructorsCache.put(name, constructor); } } } return constructor; }\n\n    ### Response: Get the constructor of the class.\n\n@param name the name of the class\n@return the constructor\n@throws ClassNotFoundException class not found\n@throws NoSuchMethodException method not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Constructor constructor = null; if (paramTypes == null) { CtorDescriptor[] ctors = cd.getAllCtorDescriptors(); if (ctors != null && ctors.length > 0) { if (ctors.length > 1) { throw new PetiteException(ctors.length + \" suitable constructor found as injection point for: \" + beanDefinition.type.getName()); } constructor = ctors[0].getConstructor(); } } else { CtorDescriptor ctorDescriptor = cd.getCtorDescriptor(paramTypes, true); if (ctorDescriptor != null) { constructor = ctorDescriptor.getConstructor(); } } if (constructor == null) { throw new PetiteException(\"Constructor not found: \" + beanDefinition.type.getName()); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(constructor, references); beanDefinition.ctor = new CtorInjectionPoint(constructor, ref); }\n\n    ### Response:", "ground_truth": "Registers constructor injection point.\n\n@param beanName bean name\n@param paramTypes constructor parameter types, may be null\n@param references references for arguments", "predict": " Register a petite constructor injection point for a bean.\n\n@param beanName the name of the bean\n@param paramTypes the parameter types of the constructor\n@param references the references to be injected into the constructor\n@throws PetiteException if there is an error registering the injection point"}, {"ID": 767, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(String propertyName) { final PropertyDescriptor propertyDescriptor = findPropertyDescriptor(propertyName); if (propertyDescriptor == null) { throw new PropertyNotFoundException(beanClass, propertyName); } return propertyDescriptor; }\n\n    ### Response: Get the property descriptor for the named property. Throws an exception if the property does not exist.\n\n@param propertyName property name\n@return the PropertyDescriptor for the named property\n@throws PropertyNotFoundException if the named property does not exist on the bean\n@see #findPropertyDescriptor(String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference); PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref); beanDefinition.addPropertyInjectionPoint(pip); }\n\n    ### Response:", "ground_truth": "Registers property injection point.\n\n@param beanName bean name\n@param property property name\n@param reference explicit injection reference, may be null", "predict": " Register a property injection point for the specified bean and property.\n\n@param beanName the name of the bean\n@param property the name of the property\n@param reference the reference to inject\n@throws PetiteException if the property is not found or if the bean definition is not found for the specified bean name"}, {"ID": 768, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(String propertyName) { final PropertyDescriptor propertyDescriptor = findPropertyDescriptor(propertyName); if (propertyDescriptor == null) { throw new PropertyNotFoundException(beanClass, propertyName); } return propertyDescriptor; }\n\n    ### Response: Get the property descriptor for the named property. Throws an exception if the property does not exist.\n\n@param propertyName property name\n@return the PropertyDescriptor for the named property\n@throws PropertyNotFoundException if the named property does not exist on the bean\n@see #findPropertyDescriptor(String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteSetInjectionPoint(final String beanName, final String property) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor); beanDefinition.addSetInjectionPoint(sip); }\n\n    ### Response:", "ground_truth": "Registers set injection point.\n\n@param beanName bean name\n@param property set property name", "predict": " Register a set injection point for the specified property of the specified bean.\n\n@param beanName the name of the bean\n@param property the name of the property to inject\n@throws PetiteException if the property does not exist or is not of a collection type"}, {"ID": 769, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int sendRequest(final String methodName, final String url, final List<Header> hdrs, final String contentType, final int contentLen, final byte[] content) throws HttpException { int sz = 0; if (content != null) { sz = content.length; } if (debug()) { debug(\"About to send request: method=\" + methodName + \" url=\" + url + \" contentLen=\" + contentLen + \" content.length=\" + sz + \" contentType=\" + contentType); } try { URI u = new URI(url); if (!hostSpecified && (u.getHost() == null)) { if ((baseURI == null) && (baseURIValue != null)) { baseURI = new URI(baseURIValue); } if (baseURI == null) { throw new HttpException(\"No base URI specified for non-absolute URI \" + url); } if (baseURI.getHost() == null) { throw new HttpException(\"Base URI must be absolute: \" + baseURI); } u = baseURI.resolve(u); } if (debug()) { debug(\" url resolves to \" + u); } method = findMethod(methodName, u); if (credentials != null) { getCredentialsProvider().setCredentials(new AuthScope(u.getHost(), u.getPort()), credentials); } if (!Util.isEmpty(hdrs)) { for (final Header hdr: hdrs) { method.addHeader(hdr); } } if (method instanceof HttpEntityEnclosingRequestBase) { if (content != null) { if (contentType == null) { setContent(content, \"text/xml\"); } else { setContent(content, contentType); } } } response = execute(method); } catch (final HttpException he) { throw he; } catch (final Throwable t) { throw new HttpException(t.getLocalizedMessage(), t); } status = response.getStatusLine().getStatusCode(); return status; }\n\n    ### Response: Send a request to the server\n\n@param methodName the method, GET, PUT etc\n@param url the url\n@param hdrs may be null\n@param contentType\n@param contentLen\n@param content\n@return int    status code\n@throws HttpException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Method method = null; if (arguments == null) { MethodDescriptor[] methods = cd.getAllMethodDescriptors(methodName); if (methods != null && methods.length > 0) { if (methods.length > 1) { throw new PetiteException(methods.length + \" suitable methods found as injection points for: \" + beanDefinition.type.getName() + '#' + methodName); } method = methods[0].getMethod(); } } else { MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md != null) { method = md.getMethod(); } } if (method == null) { throw new PetiteException(\"Method not found: \" + beanDefinition.type.getName() + '#' + methodName); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(method, references); MethodInjectionPoint mip = new MethodInjectionPoint(method, ref); beanDefinition.addMethodInjectionPoint(mip); }\n\n    ### Response:", "ground_truth": "Registers method injection point.\n\n@param beanName bean name\n@param methodName method name\n@param arguments method arguments, may be null\n@param references injection references", "predict": "Register a method injection point for a bean\n\n@param beanName the name of the bean\n@param methodName the name of the method to inject\n@param arguments the argument types of the method, may be null\n@param references the references to inject, may be null\n@throws PetiteException if the method cannot be found or if there are multiple suitable methods."}, {"ID": 770, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void getLogicalToVisualRunsMap() { if (isGoodLogicalToVisualRunsMap) { return; } int count = countRuns(); if ((logicalToVisualRunsMap == null) || (logicalToVisualRunsMap.length < count)) { logicalToVisualRunsMap = new int[count]; } int i; long[] keys = new long[count]; for (i = 0; i < count; i++) { keys[i] = ((long)(runs[i].start)<<32) + i; } Arrays.sort(keys); for (i = 0; i < count; i++) { logicalToVisualRunsMap[i] = (int)(keys[i] & 0x00000000FFFFFFFF); } isGoodLogicalToVisualRunsMap = true; }\n\n    ### Response: Compute the logical to visual run mapping.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (initMethodNames == null) { initMethodNames = StringPool.EMPTY_ARRAY; } int total = initMethodNames.length; InitMethodPoint[] initMethodPoints = new InitMethodPoint[total]; int i; for (i = 0; i < initMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Init method not found: \" + beanDefinition.type.getName() + '#' + initMethodNames[i]); } initMethodPoints[i] = new InitMethodPoint(md.getMethod(), i, invocationStrategy); } beanDefinition.addInitMethodPoints(initMethodPoints); }\n\n    ### Response:", "ground_truth": "Registers init method.\n\n@param beanName bean name\n@param invocationStrategy moment of invocation\n@param initMethodNames init method names", "predict": " Register petite init methods for a bean definition."}, {"ID": 771, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void getLogicalToVisualRunsMap() { if (isGoodLogicalToVisualRunsMap) { return; } int count = countRuns(); if ((logicalToVisualRunsMap == null) || (logicalToVisualRunsMap.length < count)) { logicalToVisualRunsMap = new int[count]; } int i; long[] keys = new long[count]; for (i = 0; i < count; i++) { keys[i] = ((long)(runs[i].start)<<32) + i; } Arrays.sort(keys); for (i = 0; i < count; i++) { logicalToVisualRunsMap[i] = (int)(keys[i] & 0x00000000FFFFFFFF); } isGoodLogicalToVisualRunsMap = true; }\n\n    ### Response: Compute the logical to visual run mapping.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (destroyMethodNames == null) { destroyMethodNames = StringPool.EMPTY_ARRAY; } int total = destroyMethodNames.length; DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total]; int i; for (i = 0; i < destroyMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Destroy method not found: \" + beanDefinition.type.getName() + '#' + destroyMethodNames[i]); } destroyMethodPoints[i] = new DestroyMethodPoint(md.getMethod()); } beanDefinition.addDestroyMethodPoints(destroyMethodPoints); }\n\n    ### Response:", "ground_truth": "Registers destroy method.\n\n@param beanName bean name\n@param destroyMethodNames destroy method names", "predict": " Register petite destroy methods."}, {"ID": 772, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void resetBean(MethodSpec.Builder methodBuilder, TypeName beanClass, String beanName, ModelProperty property, String cursorName, String indexName) { SQLTransform transform = lookup(property.getElement().asType()); if (transform == null) { throw new IllegalArgumentException(\"Transform of \" + property.getElement().asType() + \" not supported\"); } transform.generateResetProperty(methodBuilder, beanClass, beanName, property, cursorName, indexName); }\n\n    ### Response: Reset bean.\n\n@param methodBuilder\nthe method builder\n@param beanClass\nthe bean class\n@param beanName\nthe bean name\n@param property\nthe property\n@param cursorName\nthe cursor name\n@param indexName\nthe index name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) { BeanDefinition beanDefinition = lookupBeanDefinition(beanName); if (beanDefinition == null) { throw new PetiteException(\"Bean not found: \" + beanName); } Class beanType = beanDefinition.type; ClassDescriptor cd = ClassIntrospector.get().lookup(beanType); MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + methodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod()); providers.put(providerName, providerDefinition); }\n\n    ### Response:", "ground_truth": "Registers instance method provider.\n\n@param providerName provider name\n@param beanName bean name\n@param methodName instance method name\n@param arguments method argument types", "predict": " Register a petite provider.\n\n@param providerName\nthe provider name\n@param beanName\nthe bean name\n@param methodName\nthe method name\n@param arguments\nthe arguments."}, {"ID": 773, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object get(final Object bean, final String property) { try { if (property.indexOf(\".\") >= 0) { final Object subBean = ClassMockUtils.get(bean, property.substring(0, property.indexOf(\".\"))); if (subBean == null) { return null; } final String newProperty = property.substring(property.indexOf(\".\") + 1); return ClassMockUtils.get(subBean, newProperty); } Method method = null; try { method = bean.getClass().getMethod(ClassMockUtils.propertyToGetter(property), new Class[] {}); } catch (final NoSuchMethodException e) { method = bean.getClass().getMethod(ClassMockUtils.propertyToGetter(property, true), new Class[] {}); } return method.invoke(bean, new Object[] {}); } catch (final Exception e) { throw new RuntimeException(\"Can't get property \" + property + \" in the class \" + bean.getClass().getName(), e); } }\n\n    ### Response: Access the value in the property of the bean.\n\n@param bean\nto inspect\n@param property\nthe name of the property to be access\n@return the value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + staticMethodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod()); providers.put(providerName, providerDefinition); }\n\n    ### Response:", "ground_truth": "Registers static method provider.\n\n@param providerName provider name\n@param type class type\n@param staticMethodName static method name\n@param arguments method argument types", "predict": " Registers a provider for the specified type.\n\n@param providerName\nthe name of the provider\n@param type\nthe type for which the provider is registered\n@param staticMethodName\nthe name of the static method that returns the provider instance\n@param arguments\nthe arguments of the provider method"}, {"ID": 774, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean incSlotLimit(JobInfo info, TaskType type, LimitType limit) { switch (limit) { case MIN: if (type == TaskType.MAP) { if (info.minMaps < runnableTasks(info, type)) { info.minMaps += 1; return true; } } else { if (info.minReduces < runnableTasks(info, type)) { info.minReduces += 1; return true; } } return false; case MAX: if (type == TaskType.MAP) { if (info.maxMaps < runnableTasks(info, type)) { info.maxMaps += 1; return true; } } else { if (info.maxReduces < runnableTasks(info, type)) { info.maxReduces += 1; return true; } } return false; } // Never come here return false; }\n\n    ### Response: Increment the slot limit of a job\n@param info The JobInfo of the job\n@param type Map or Reduce\n@param limit Max or Min\n@return true if we can increment.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) { forEachBean(bd -> { if (ClassUtil.isTypeOf(bd.type, type)) { beanNameConsumer.accept(bd.name); } }); }\n\n    ### Response:", "ground_truth": "Iterates all beans that are of given type.", "predict": "Iterates over all beans of the specified type and calls the consumer for each bean name.\n@param type The type of the beans to iterate over\n@param beanNameConsumer The consumer to call for each bean name\n@return void\n\n    "}, {"ID": 775, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Map<?, ?> mapOfEntries( Entry<?, ?>... entries ) { Map<Object, Object> looseTypedMap = new LinkedHashMap<>( entries.length ); for (Entry<?, ?> entry : entries) looseTypedMap.put(entry.getKey(), entry.getValue()); return looseTypedMap; }\n\n    ### Response: Relaxed implementation of the java 9 Map.ofEntries.\nLinkedHashMap ensures element order remains as supplied.\n@param entries array of Map.Entry elements\n@return a mutable, type relaxed LinkedHashMap.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void defineParameters(final Map<?, ?> properties) { for (Map.Entry<?, ?> entry : properties.entrySet()) { defineParameter(entry.getKey().toString(), entry.getValue()); } }\n\n    ### Response:", "ground_truth": "Defines many parameters at once.", "predict": "Defines parameters based on the properties map.\n@param properties map of properties\n@throws IllegalArgumentException if the properties map is null or empty"}, {"ID": 776, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object invoke(Object proxy, Method method, Object[] args) /* CSOFF: IllegalThrows */ throws Throwable /* CSON: IllegalThrows */ { final long startTime = System.currentTimeMillis(); Object result = null; try { result = method.invoke(target, args); if ((result != null) && !method.getReturnType().equals(Void.TYPE) && method.getReturnType().isInterface()) { result = wrapObject(method.getReturnType(), result, reporter); } } catch (InvocationTargetException t) { if (t.getCause() != null) { throw t.getCause(); } } finally { final long endTime = System.currentTimeMillis(); reporter.reportTimedOperation(targetClass, method, startTime, endTime); } return result; }\n\n    ### Response: Handles method invocations on the generated proxy. Measures the time needed\nto execute the given method on the wrapped object.\n\n@see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[]).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object intercept(final ActionRequest actionRequest) throws Exception { printBefore(actionRequest); long startTime = System.currentTimeMillis(); Object result = null; try { result = actionRequest.invoke(); } catch (Exception ex) { result = \"<exception>\"; throw ex; } catch (Throwable th) { result = \"<throwable>\"; throw new Exception(th); } finally { long executionTime = System.currentTimeMillis() - startTime; printAfter(actionRequest, executionTime, result); } return result; }\n\n    ### Response:", "ground_truth": "Measure action invocation time.", "predict": "Intercepts method invocations on the generated proxy. Prints a message before the method invocation, measures the time needed to execute the given method on the wrapped object, and prints a message after the method invocation.\n\n@see org.apache.struts2.interceptor.Interceptor#intercept(org.apache.struts2.interceptor.ActionRequest)."}, {"ID": 777, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String removeLeadingAndTrailingDelimiter(String str, String delimiter) { final int strLength = str.length(); final int delimiterLength = delimiter.length(); final boolean leadingDelimiter = str.startsWith(delimiter); final boolean trailingDelimiter = strLength > delimiterLength && str.endsWith(delimiter); if (!leadingDelimiter && !trailingDelimiter) { return str; } else { final int startingDelimiterIndex = leadingDelimiter ? delimiterLength : 0; final int endingDelimiterIndex = trailingDelimiter ? Math.max(strLength - delimiterLength, startingDelimiterIndex) : strLength; return str.substring(startingDelimiterIndex, endingDelimiterIndex); } }\n\n    ### Response: Removes the leading and trailing delimiter from a string.\n\n@param str String to process.\n@param delimiter Delimiter to remove.\n@return The string with the leading and trailing delimiter removed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int resolveJavaVersion(final int version) { final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber(); final int platformVersion = javaVersionNumber - 8 + 52; return version > platformVersion ? version : platformVersion; }\n\n    ### Response:", "ground_truth": "Resolves Java version from current version.", "predict": "Resolves the Java version based on the platform version.\n\n@param version The version to resolve.\n@return The resolved version.\n\n    "}, {"ID": 778, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void ifNotEqJmp(MethodVisitor mv, int param, int value, Label label) { mv.visitVarInsn(ILOAD, param); if (value == 0) { /* notest forvalue 0 */ mv.visitJumpInsn(IFNE, label); } else if (value == 1) { mv.visitInsn(ICONST_1); mv.visitJumpInsn(IF_ICMPNE, label); } else if (value == 2) { mv.visitInsn(ICONST_2); mv.visitJumpInsn(IF_ICMPNE, label); } else if (value == 3) { mv.visitInsn(ICONST_3); mv.visitJumpInsn(IF_ICMPNE, label); } else if (value == 4) { mv.visitInsn(ICONST_4); mv.visitJumpInsn(IF_ICMPNE, label); } else if (value == 5) { mv.visitInsn(ICONST_5); mv.visitJumpInsn(IF_ICMPNE, label); } else if (value >= 6) { mv.visitIntInsn(BIPUSH, value); mv.visitJumpInsn(IF_ICMPNE, label); } else { throw new RuntimeException(\"non supported negative values\"); } }\n\n    ### Response: dump a Jump if not EQ.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void pushInt(final MethodVisitor mv, final int value) { if (value <= 5) { mv.visitInsn(ICONST_0 + value); } else if (value <= Byte.MAX_VALUE) { mv.visitIntInsn(BIPUSH, value); } else { mv.visitIntInsn(SIPUSH, value); } }\n\n    ### Response:", "ground_truth": "Pushes int value in an optimal way.", "predict": " push an integer onto the operand stack.\n\n    "}, {"ID": 779, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void eliminateCallTargetArgAt(Node ref, int argIndex) { Node callArgNode = ReferenceMap.getArgumentForCallOrNewOrDotCall(ref, argIndex); if (callArgNode != null) { NodeUtil.deleteNode(callArgNode, compiler); } }\n\n    ### Response: Eliminates the parameter from a function call.\n@param definitionFinder The definition and use sites index.\n@param p\n@param call The function call node\n@param argIndex The index of the argument to remove..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) { if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) { throw new ProxettaException(\"Invalid argument index: \" + argIndex); } }\n\n    ### Response:", "ground_truth": "Validates argument index.", "predict": " Checks if the argument index is valid for the given method.\n@param methodInfo The method to check the argument index for.\n@param argIndex The index of the argument to check.\n@throws ProxettaException If the argument index is invalid."}, {"ID": 780, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String insertPattern(final String logFileName, final String rollPattern) { int index = logFileName.lastIndexOf('.'); if(index==-1) return logFileName + rollPattern; return logFileName.substring(0, index) + rollPattern + logFileName.substring(index); }\n\n    ### Response: Merges the roll pattern name into the file name\n@param logFileName The log file name\n@param rollPattern The rolling log file appender roll pattern\n@return the merged file pattern.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String adviceFieldName(final String name, final int index) { return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index; }\n\n    ### Response:", "ground_truth": "Builds advice field name.", "predict": " Generates a unique field name for a proxied class field\n@param name The original field name\n@param index The index of the field in the proxied class\n@return the unique field name for the proxied class field."}, {"ID": 781, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String insertPattern(final String logFileName, final String rollPattern) { int index = logFileName.lastIndexOf('.'); if(index==-1) return logFileName + rollPattern; return logFileName.substring(0, index) + rollPattern + logFileName.substring(index); }\n\n    ### Response: Merges the roll pattern name into the file name\n@param logFileName The log file name\n@param rollPattern The rolling log file appender roll pattern\n@return the merged file pattern.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String adviceMethodName(final String name, final int index) { return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index; }\n\n    ### Response:", "ground_truth": "Builds advice method name.", "predict": " Generates a unique method name for a proxied method\n@param name The original method name\n@param index The unique index for the method\n@return the unique method name for the proxied method."}, {"ID": 782, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cacheMetadata(ResultSetMetaData resultSetMetaData) throws SQLException { cachedColumnNames = new LinkedHashMap<String, Integer>(); for (int i = 1; i <= resultSetMetaData.getColumnCount(); i++) { final String fieldTypeName = resultSetMetaData.getColumnTypeName(i); if (!fieldTypeName.equalsIgnoreCase(\"geometry\") && isSupportedPropertyType(resultSetMetaData.getColumnType(i), fieldTypeName)) { cachedColumnNames.put(resultSetMetaData.getColumnName(i).toUpperCase(), i); columnCountProperties++; } } }\n\n    ### Response: Cache the column name and its index.\n\n@param resultSetMetaData\n@throws SQLException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { mv.visitVarInsn(ALOAD, 0); for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKESPECIAL call.", "predict": " Load the arguments of a method.\n\n@param mv\n@param methodInfo\n@throws IllegalArgumentException."}, {"ID": 783, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void writeConf() throws IOException { for (int i = 0; i < mNumMasters; i++) { File confDir = new File(mWorkDir, \"conf-master\" + i); writeConfToFile(confDir, mMasterProperties.getOrDefault(i, new HashMap<>())); } for (int i = 0; i < mNumWorkers; i++) { File confDir = new File(mWorkDir, \"conf-worker\" + i); writeConfToFile(confDir, mWorkerProperties.getOrDefault(i, new HashMap<>())); } }\n\n    ### Response: Writes the contents of properties to the configuration file..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 0; i < methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKESTATIC call.", "predict": " Loads the arguments of a static method onto the operand stack.\n\n    "}, {"ID": 784, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cacheMetadata(ResultSetMetaData resultSetMetaData) throws SQLException { cachedColumnNames = new LinkedHashMap<String, Integer>(); for (int i = 1; i <= resultSetMetaData.getColumnCount(); i++) { final String fieldTypeName = resultSetMetaData.getColumnTypeName(i); if (!fieldTypeName.equalsIgnoreCase(\"geometry\") && isSupportedPropertyType(resultSetMetaData.getColumnType(i), fieldTypeName)) { cachedColumnNames.put(resultSetMetaData.getColumnName(i).toUpperCase(), i); columnCountProperties++; } } }\n\n    ### Response: Cache the column name and its index.\n\n@param resultSetMetaData\n@throws SQLException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKEVIRTUAL call.", "predict": " Load the method arguments onto the stack.\n\n@param mv\n@param methodInfo"}, {"ID": 785, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void createLoadsBasedOnDescriptor(MethodVisitor mv, String descriptor, int startindex) { int slot = startindex; int descriptorpos = 1; // start after the '(' char ch; while ((ch = descriptor.charAt(descriptorpos)) != ')') { switch (ch) { case '[': mv.visitVarInsn(ALOAD, slot); slot++; // jump to end of array, could be [[[[I while (descriptor.charAt(++descriptorpos) == '[') { } if (descriptor.charAt(descriptorpos) == 'L') { descriptorpos = descriptor.indexOf(';', descriptorpos) + 1; } else { // Just a primitive array descriptorpos++; } break; case 'L': mv.visitVarInsn(ALOAD, slot); slot++; // jump to end of 'L' signature descriptorpos = descriptor.indexOf(';', descriptorpos) + 1; break; case 'J': mv.visitVarInsn(LLOAD, slot); slot += 2; // double slotter descriptorpos++; break; case 'D': mv.visitVarInsn(DLOAD, slot); slot += 2; // double slotter descriptorpos++; break; case 'F': mv.visitVarInsn(FLOAD, slot); descriptorpos++; slot++; break; case 'I': case 'Z': case 'B': case 'C': case 'S': mv.visitVarInsn(ILOAD, slot); descriptorpos++; slot++; break; default: throw new IllegalStateException(\"Unexpected type in descriptor: \" + ch); } } }\n\n    ### Response: Create the set of LOAD instructions to load the method parameters. Take into account the size and type.\n\n@param mv the method visitor to recieve the load instructions\n@param descriptor the complete method descriptor (eg. \"(ILjava/lang/String;)V\") - params and return type are\nskipped\n@param startindex the initial index in which to assume the first parameter is stored.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ILOAD, offset); break; case 'J': mv.visitVarInsn(LLOAD, offset); break; case 'F': mv.visitVarInsn(FLOAD, offset); break; case 'D': mv.visitVarInsn(DLOAD, offset); break; default: mv.visitVarInsn(ALOAD, offset); } }\n\n    ### Response:", "ground_truth": "Loads one argument. Index is 1-based. No conversion occurs.", "predict": " Load the value of a method argument onto the stack. The argument is identified by its index in the method signature. The type of the argument is determined by its signature character. The argument offset is calculated based on the size of the previous arguments. The appropriate load instruction is selected based on the argument type."}, {"ID": 786, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void pushClassType(CodeAttribute b, String classType) { if (classType.length() != 1) { if (classType.startsWith(\"L\") && classType.endsWith(\";\")) { classType = classType.substring(1, classType.length() - 1); } b.loadClass(classType); } else { char type = classType.charAt(0); switch (type) { case 'I': b.getstatic(Integer.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'J': b.getstatic(Long.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'S': b.getstatic(Short.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'F': b.getstatic(Float.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'D': b.getstatic(Double.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'B': b.getstatic(Byte.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'C': b.getstatic(Character.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'Z': b.getstatic(Boolean.class.getName(), TYPE, LJAVA_LANG_CLASS); break; default: throw new RuntimeException(\"Cannot handle primitive type: \" + type); } } }\n\n    ### Response: Pushes a class type onto the stack from the string representation This can\nalso handle primitives\n\n@param b         the bytecode\n@param classType the type descriptor for the class or primitive to push.\nThis will accept both the java.lang.Object form and the\nLjava/lang/Object; form.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ISTORE, offset); break; case 'J': mv.visitVarInsn(LSTORE, offset); break; case 'F': mv.visitVarInsn(FSTORE, offset); break; case 'D': mv.visitVarInsn(DSTORE, offset); break; default: mv.visitVarInsn(ASTORE, offset); } }\n\n    ### Response:", "ground_truth": "Stores one argument. Index is 1-based. No conversion occurs.", "predict": " Stores a method argument onto the stack.\n\n@param mv         the method visitor\n@param methodInfo the method info object\n@param index      the index of the argument to store\n\nThis method uses the method info object to determine the offset of the\nargument and the type of the argument. It then uses the appropriate\ninstruction to store the argument onto the stack."}, {"ID": 787, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void pushClassType(CodeAttribute b, String classType) { if (classType.length() != 1) { if (classType.startsWith(\"L\") && classType.endsWith(\";\")) { classType = classType.substring(1, classType.length() - 1); } b.loadClass(classType); } else { char type = classType.charAt(0); switch (type) { case 'I': b.getstatic(Integer.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'J': b.getstatic(Long.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'S': b.getstatic(Short.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'F': b.getstatic(Float.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'D': b.getstatic(Double.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'B': b.getstatic(Byte.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'C': b.getstatic(Character.class.getName(), TYPE, LJAVA_LANG_CLASS); break; case 'Z': b.getstatic(Boolean.class.getName(), TYPE, LJAVA_LANG_CLASS); break; default: throw new RuntimeException(\"Cannot handle primitive type: \" + type); } } }\n\n    ### Response: Pushes a class type onto the stack from the string representation This can\nalso handle primitives\n\n@param b         the bytecode\n@param classType the type descriptor for the class or primitive to push.\nThis will accept both the java.lang.Object form and the\nLjava/lang/Object; form.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) { varOffset += methodInfo.getAllArgumentsSize(); switch (methodInfo.getReturnType().getOpcode()) { case 'V': mv.visitInsn(ACONST_NULL); break; case 'B': AsmUtil.valueOfByte(mv); break; case 'C': AsmUtil.valueOfCharacter(mv); break; case 'S': AsmUtil.valueOfShort(mv); break; case 'I': AsmUtil.valueOfInteger(mv); break; case 'Z': AsmUtil.valueOfBoolean(mv); break; case 'J': AsmUtil.valueOfLong(mv); break; case 'F': AsmUtil.valueOfFloat(mv); break; case 'D': AsmUtil.valueOfDouble(mv); break; } }\n\n    ### Response:", "ground_truth": "Prepares return value.", "predict": " Prepares the return value for the method. This method will push the appropriate return value onto the stack based on the return type of the method.\n\n@param mv         the method visitor\n@param methodInfo the method info\n@param varOffset  the offset of the first local variable in the method. This is used to determine the index of the return value on the stack."}, {"ID": 788, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JobDefinition manuallyTriggerableJobDefinition(final String jobType, final String jobName, final String description, final int restarts, final Optional<Duration> maxAge) { return new DefaultJobDefinition(jobType, jobName, description, maxAge, Optional.empty(), Optional.empty(), restarts, 0, Optional.empty()); }\n\n    ### Response: Create a JobDefinition for a job that will not be triggered automatically by a job trigger.\n\n@param jobType     The type of the Job\n@param jobName     A human readable name of the Job\n@param description A short description of the job's purpose\n@param restarts    The number of restarts if the job failed because of errors or exceptions\n@param maxAge      Optional maximum age of a job. When the job is not run for longer than this duration,\na warning is displayed on the status page\n@return JobDefinition.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) { return new StringBand(7) .append(access) .append(COLON) .append(description) .append(StringPool.UNDERSCORE) .append(className) .append(StringPool.HASH) .append(methodName) .toString(); }\n\n    ### Response:", "ground_truth": "Creates unique key for method signatures map.", "predict": " Create a unique key for a method signature.\n\n@param access      The access level of the method (public, private, protected, default)\n@param methodName  The name of the method\n@param description A short description of the method's purpose\n@param className   The name of the class that contains the method\n@return A unique key for the method signature."}, {"ID": 789, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Serializable copy(Serializable obj) { final boolean isTraceOn = TraceComponent.isAnyTracingEnabled(); if (isTraceOn && tc.isDebugEnabled()) Tr.debug(tc, \"copy : \" + Util.identity(obj)); // ----------------------------------------------------------------------- // Optimize copyObject by special casing null, immutable objects, // and primitive arrays. All of these can be handled much more // efficiently than performing a 'deep' copy. d154342.7 // ----------------------------------------------------------------------- if (obj == null) { return obj; } Class<?> objType = obj.getClass(); // if the object is a primitive wrapper class, then return it. if ((objType == String.class) || (objType == Integer.class) || (objType == Long.class) || (objType == Boolean.class) || (objType == Byte.class) || (objType == Character.class) || (objType == Float.class) || (objType == Double.class) || (objType == Short.class)) { // Yes, so do nothing... return obj; } Class<?> componentType = objType.getComponentType(); // If this is an array of primitives take a clone instead of deep copy if (componentType != null && componentType.isPrimitive()) { if (componentType == boolean.class) return ((boolean[]) obj).clone(); if (componentType == byte.class) return ((byte[]) obj).clone(); if (componentType == char.class) return ((char[]) obj).clone(); if (componentType == short.class) return ((short[]) obj).clone(); if (componentType == int.class) return ((int[]) obj).clone(); if (componentType == long.class) return ((long[]) obj).clone(); if (componentType == float.class) return ((float[]) obj).clone(); if (componentType == double.class) return ((double[]) obj).clone(); } // End d154342.7 if (isTraceOn && tc.isDebugEnabled()) Tr.debug(tc, \"copy : making a deep copy\"); return copySerializable(obj); }\n\n    ### Response: Make a copy of an object by writing it out to stream and reading it\nback again. This will make a \"deep\" copy of the object.\n\nThis method is optimized to not copy immutable objects.\n\n@param obj the object to be copied, or null\n@return a copy of the object\n@throws RuntimeException if the object cannot be serialized.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void newArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitIntInsn(NEWARRAY, T_INT); return; } if (componentType == long.class) { mv.visitIntInsn(NEWARRAY, T_LONG); return; } if (componentType == float.class) { mv.visitIntInsn(NEWARRAY, T_FLOAT); return; } if (componentType == double.class) { mv.visitIntInsn(NEWARRAY, T_DOUBLE); return; } if (componentType == byte.class) { mv.visitIntInsn(NEWARRAY, T_BYTE); return; } if (componentType == short.class) { mv.visitIntInsn(NEWARRAY, T_SHORT); return; } if (componentType == boolean.class) { mv.visitIntInsn(NEWARRAY, T_BOOLEAN); return; } if (componentType == char.class) { mv.visitIntInsn(NEWARRAY, T_CHAR); return; } mv.visitTypeInsn(ANEWARRAY, AsmUtil.typeToSignature(componentType)); }\n\n    ### Response:", "ground_truth": "Creates new array.", "predict": " Generate a new array of the specified type.\n\n@param mv the method visitor\n@param componentType the type of the array elements\n@throws RuntimeException if the type is not supported."}, {"ID": 790, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Serializable copy(Serializable obj) { final boolean isTraceOn = TraceComponent.isAnyTracingEnabled(); if (isTraceOn && tc.isDebugEnabled()) Tr.debug(tc, \"copy : \" + Util.identity(obj)); // ----------------------------------------------------------------------- // Optimize copyObject by special casing null, immutable objects, // and primitive arrays. All of these can be handled much more // efficiently than performing a 'deep' copy. d154342.7 // ----------------------------------------------------------------------- if (obj == null) { return obj; } Class<?> objType = obj.getClass(); // if the object is a primitive wrapper class, then return it. if ((objType == String.class) || (objType == Integer.class) || (objType == Long.class) || (objType == Boolean.class) || (objType == Byte.class) || (objType == Character.class) || (objType == Float.class) || (objType == Double.class) || (objType == Short.class)) { // Yes, so do nothing... return obj; } Class<?> componentType = objType.getComponentType(); // If this is an array of primitives take a clone instead of deep copy if (componentType != null && componentType.isPrimitive()) { if (componentType == boolean.class) return ((boolean[]) obj).clone(); if (componentType == byte.class) return ((byte[]) obj).clone(); if (componentType == char.class) return ((char[]) obj).clone(); if (componentType == short.class) return ((short[]) obj).clone(); if (componentType == int.class) return ((int[]) obj).clone(); if (componentType == long.class) return ((long[]) obj).clone(); if (componentType == float.class) return ((float[]) obj).clone(); if (componentType == double.class) return ((double[]) obj).clone(); } // End d154342.7 if (isTraceOn && tc.isDebugEnabled()) Tr.debug(tc, \"copy : making a deep copy\"); return copySerializable(obj); }\n\n    ### Response: Make a copy of an object by writing it out to stream and reading it\nback again. This will make a \"deep\" copy of the object.\n\nThis method is optimized to not copy immutable objects.\n\n@param obj the object to be copied, or null\n@return a copy of the object\n@throws RuntimeException if the object cannot be serialized.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeIntoArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitInsn(IASTORE); return; } if (componentType == long.class) { mv.visitInsn(LASTORE); return; } if (componentType == float.class) { mv.visitInsn(FASTORE); return; } if (componentType == double.class) { mv.visitInsn(DASTORE); return; } if (componentType == byte.class) { mv.visitInsn(BASTORE); return; } if (componentType == short.class) { mv.visitInsn(SASTORE); return; } if (componentType == boolean.class) { mv.visitInsn(BASTORE); return; } if (componentType == char.class) { mv.visitInsn(CASTORE); return; } mv.visitInsn(AASTORE); }\n\n    ### Response:", "ground_truth": "Stores element on stack into an array.", "predict": " Store a value into an array. This method is used by the code generator to store values into arrays. The method takes a MethodVisitor and a Class representing the type of the array element. It uses the appropriate array store instruction based on the type of the array element.\n\n@param mv the MethodVisitor to use for generating code\n@param componentType the Class representing the type of the array element\n@throws IllegalArgumentException if the componentType is not a valid array element type."}, {"ID": 791, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getEncodingFromLocale(Locale locale) { init(); if (locale == cachedLocale) { return cachedEncoding; } String encoding = null; /*(String) _localeMap.get(locale.toString()); if (encoding == null) { encoding = (String) _localeMap.get(locale.getLanguage() + \"_\" + locale.getCountry()); if (encoding == null) { encoding = (String) _localeMap.get(locale.getLanguage()); } }*/ if (encoding == null) { //check the com.ibm.wsspi.http.EncodingUtils com.ibm.wsspi.http.EncodingUtils encodingUtils = com.ibm.ws.webcontainer.osgi.WebContainer.getEncodingUtils(); if (encodingUtils!=null) { encoding = encodingUtils.getEncodingFromLocale(locale); } } cachedEncoding = encoding; cachedLocale = locale; return encoding; }\n\n    ### Response: Get the encoding for a passed in locale.\n\n@param locale The locale.\n\n@return The encoding..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String extractEncoding(final String contentType, String defaultEncoding) { String encoding = extractEncoding(contentType); if (encoding == null) { if (defaultEncoding == null) { defaultEncoding = JoddCore.encoding; } encoding = defaultEncoding; } return encoding; }\n\n    ### Response:", "ground_truth": "Extracts encoding from a given content type.\n\n@param contentType     content type.\n@param defaultEncoding Default encoding to be used if extract returns {@code null}.\nIf defaultEncoding is {@code null}, {@link JoddCore#encoding} will be used.\n@return Encoding from the content type.\n@see #extractEncoding(String)", "predict": " Extract the encoding from the content type header.\n\n@param contentType The content type header.\n@param defaultEncoding The default encoding to use if none is found in the content type header.\n\n@return The encoding."}, {"ID": 792, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isValidFileExtension(String filename, String allowedFileExtensions, String deniedFileExtensions) { if (filename == null) { return false; } String ext = getExtension(filename).toLowerCase(); if (allowedFileExtensions != null && !allowedFileExtensions.isEmpty()) { if (ext.length() == 0) { return false; } StringTokenizer st = new StringTokenizer(allowedFileExtensions.toLowerCase(), EXTENSIONS_SEPARATORS); while (st.hasMoreTokens()) { String ext2 = st.nextToken(); if (ext.equals(ext2)) { return true; } } return false; } if (deniedFileExtensions != null && !deniedFileExtensions.isEmpty()) { if (ext.length() == 0) { return true; } StringTokenizer st = new StringTokenizer(deniedFileExtensions.toLowerCase(), EXTENSIONS_SEPARATORS); while (st.hasMoreTokens()) { String ext2 = st.nextToken(); if (ext.equals(ext2)) { return false; } } return true; } return true; }\n\n    ### Response: Checks whether the extension of the filename is valid.\nThe extension check is case-sensitive on all platforms.\n\n@param filename the filename to query, null returns false\n@param allowedFileExtensions the allowed file extensions\n@param deniedFileExtensions the denied file extensions\n@return true if is valid file extension; false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isEmptyFlags(Flags flags) { if (flags == null) return true; Flags.Flag[] systemFlags = flags.getSystemFlags(); if (systemFlags != null && systemFlags.length > 0) { return false; } String[] userFlags = flags.getUserFlags(); if (userFlags != null && userFlags.length > 0) { return false; } return true; }\n\n    ### Response:", "ground_truth": "Check whether flags is a empty flags\n@param flags a flags of message to check\n@return whether the flags is empty", "predict": " Checks whether the Flags object is empty.\n\n@param flags the Flags object to check\n@return true if the Flags object is empty; false otherwise."}, {"ID": 793, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveAuthBearerToken(final HttpServletRequest request) { String header = request.getHeader(HEADER_AUTHORIZATION); if (header == null) { return null; } int ndx = header.indexOf(\"Bearer \"); if (ndx == -1) { return null; } return header.substring(ndx + 7).trim(); }\n\n    ### Response:", "ground_truth": "Returns Bearer token.", "predict": " Get the bearer token from the HTTP request.\n\n@param request the HTTP request\n@return the bearer token, or null."}, {"ID": 794, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Action unauthorized(final String realm) { return new Action(r -> { r.addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"\" + realm + \"\\\"\"); r.setStatus(HttpStatus.UNAUTHORIZED_401); return r; }); }\n\n    ### Response: Returns unauthorized response.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException { resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"'); resp.sendError(HttpServletResponse.SC_UNAUTHORIZED); }\n\n    ### Response:", "ground_truth": "Sends correct headers to require basic authentication for the given realm.", "predict": " Sends an unauthorized response to the client."}, {"ID": 795, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkFileExists(final File file, final String name) { if (!file.exists()) { final String msg = \"missing file for \" + name + \" : \" + file.getAbsolutePath(); throw new IllegalStateException(msg); } }\n\n    ### Response: Check that a file exists and throw an exception if not.\n\n@param file to check existence of.\n@param name to associate for the exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); } prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length()); }\n\n    ### Response:", "ground_truth": "Prepares response for file download with provided mime type.", "predict": " Prepare the response for downloading a file.\n\n@param response to prepare.\n@param file to download.\n@param mimeType of the file.\n\n    "}, {"ID": 796, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeData(final long user, final List<Preference<Long, Long>> recommendations, final String path, final String fileName, final boolean append, final TemporalDataModelIF<Long, Long> model) { BufferedWriter out = null; try { File dir = null; if (path != null) { dir = new File(path); if (!dir.isDirectory()) { if (!dir.mkdir() && (fileName != null)) { System.out.println(\"Directory \" + path + \" could not be created\"); return; } } } if ((path != null) && (fileName != null)) { out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path + \"/\" + fileName, append), \"UTF-8\")); } for (Preference<Long, Long> recItem : recommendations) { if (out != null) { out.write(user + \"\\t\" + recItem.getItem()+ \"\\t\" + recItem.getScore() + \"\\n\"); } if (model != null) { model.addPreference(user, recItem.getItem(), recItem.getScore()); } } if (out != null) { out.flush(); out.close(); } } catch (IOException e) { System.out.println(e.getMessage()); // logger.error(e.getMessage()); } finally { if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } }\n\n    ### Response: Write recommendations to file.\n\n@param user the user\n@param recommendations the recommendations\n@param path directory where fileName will be written (if not null)\n@param fileName name of the file, if null recommendations will not be\nprinted\n@param append flag to decide if recommendations should be appended to\nfile\n@param model if not null, recommendations will be saved here.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) { if ((mimeType == null) && (fileName != null)) { String extension = FileNameUtil.getExtension(fileName); mimeType = MimeTypes.getMimeType(extension); } if (mimeType != null) { response.setContentType(mimeType); } if (fileSize >= 0) { response.setContentLength(fileSize); } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if (fileName != null) { String name = FileNameUtil.getName(fileName); String encodedFileName = URLCoder.encode(name); response.setHeader(CONTENT_DISPOSITION, \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName); } }\n\n    ### Response:", "ground_truth": "null\n@param fileSize if less then 0 it will be ignored", "predict": " Prepare the response for downloading a file.\n\n@param response the HTTP response\n@param fileName the name of the file to be downloaded\n@param mimeType the MIME type of the file (if null, it will be guessed from the file name)\n@param fileSize the size of the file in bytes (if negative, it will not be set)\n\n    "}, {"ID": 797, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookie findCookie(HttpServletRequest request, String name) { if (request != null) { Cookie[] cookies = request.getCookies(); if (cookies != null && cookies.length > 0) { for (Cookie cookie : cookies) { if (cookie.getName().equals(name)) { return cookie; } } } } return null; }\n\n    ### Response: find cookie from request\n@param request current request\n@param name cookie name\n@return cookie value or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) { Cookie[] cookies = request.getCookies(); if (cookies == null) { return null; } ArrayList<Cookie> list = new ArrayList<>(cookies.length); for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { list.add(cookie); } } if (list.isEmpty()) { return null; } return list.toArray(new Cookie[0]); }\n\n    ### Response:", "ground_truth": "", "predict": " get all cookies from request\n@param request current request\n@param cookieName cookie name\n@return array of cookies or null."}, {"ID": 798, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String copyToString(Reader in) throws IOException { StringWriter out = new StringWriter(); copy(in, out); return out.toString(); }\n\n    ### Response: Copy the contents of the given Reader into a String.\nCloses the reader when done.\n\n@param in the reader to copy from\n@return the String that has been copied to\n@throws IOException in case of I/O errors.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException { BufferedReader buff = request.getReader(); StringWriter out = new StringWriter(); StreamUtil.copy(buff, out); return out.toString(); }\n\n    ### Response:", "ground_truth": "Reads HTTP request body using the request reader. Once body is read,\nit cannot be read again!", "predict": " Reads the request body from the given request and returns it as a String.\n\n@param request the request to read the body from\n@return the String that has been read from the request body\n@throws IOException in case of I/O errors."}, {"ID": 799, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRequestBody(HttpServletRequest request) { if(request.getMethod().equals(\"GET\") || request.getMethod().equals(\"DELETE\")) { return null; } StringBuilder stringBuilder = new StringBuilder(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader( inputStream)); char[] charBuffer = new char[128]; int bytesRead = -1; while ((bytesRead = bufferedReader.read(charBuffer)) > 0) { stringBuilder.append(charBuffer, 0, bytesRead); } } else { stringBuilder.append(\"\"); } } catch (IOException ex) { // to nothing } finally { if (bufferedReader != null) { try { bufferedReader.close(); } catch (IOException ex) { } } } if (!StringUtils.isEmpty(stringBuilder)) { return stringBuilder.toString(); } if (request.getParameterMap().keySet().size() > 0) { return request.getParameterMap().keySet().toArray()[0].toString(); } return null; }\n\n    ### Response: not easily tested.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException { String charEncoding = request.getCharacterEncoding(); if (charEncoding == null) { charEncoding = JoddCore.encoding; } CharArrayWriter charArrayWriter = new CharArrayWriter(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding)); StreamUtil.copy(bufferedReader, charArrayWriter); } else { return StringPool.EMPTY; } } finally { StreamUtil.close(bufferedReader); } return charArrayWriter.toString(); }\n\n    ### Response:", "ground_truth": "Reads HTTP request body using the request stream. Once body is read,\nit cannot be read again!", "predict": "not easily tested."}, {"ID": 800, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static SharedFlowController getSharedFlow( String sharedFlowClassName, HttpServletRequest request, ServletContext servletContext ) { StorageHandler sh = Handlers.get( servletContext ).getStorageHandler(); HttpServletRequest unwrappedRequest = unwrapMultipart( request ); RequestContext rc = new RequestContext( unwrappedRequest, null ); String attrName = ScopedServletUtils.getScopedSessionAttrName(InternalConstants.SHARED_FLOW_ATTR_PREFIX + sharedFlowClassName, request); SharedFlowController sf = (SharedFlowController) sh.getAttribute(rc, attrName); if (sf != null) { sf.reinitializeIfNecessary(request, null, servletContext); } return sf; }\n\n    ### Response: Get the shared flow with the given class name.\n\n@param sharedFlowClassName the class name of the shared flow to retrieve.\n@param request the current HttpServletRequest.\n@return the {@link SharedFlowController} of the given class name which is stored in the user session..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) { String ctxPath = getContextPath(pageContext); HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); request.setAttribute(contextPathVariableName, ctxPath); ServletContext servletContext = pageContext.getServletContext(); servletContext.setAttribute(contextPathVariableName, ctxPath); }\n\n    ### Response:", "ground_truth": "Stores context path in server context and request scope.", "predict": " Store the context path in the request and servlet context attributes with the given name.\n\n@param pageContext the current PageContext.\n@param contextPathVariableName the name of the attribute to store the context path in."}, {"ID": 801, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getNamePrefix( ServletContext servletContext, ServletRequest request, String name ) { ArrayList/*< URLRewriter >*/ rewriters = getRewriters( request ); InternalStringBuilder prefix = new InternalStringBuilder(); if ( rewriters != null ) { for ( Iterator i = rewriters.iterator(); i.hasNext(); ) { URLRewriter rewriter = ( URLRewriter ) i.next(); String nextPrefix = rewriter.getNamePrefix( servletContext, request, name ); if ( nextPrefix != null ) { prefix.append( nextPrefix ); } } } return prefix.toString(); }\n\n    ### Response: Get the prefix to use when rewriting a query parameter name.\nLoops through the list of registered URLRewriters to build up a the prefix.\n\n@param servletContext the current ServletContext.\n@param request        the current ServletRequest.\n@param name           the name of the query parameter.\n@return a prefix to use to rewrite a query parameter name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) { String ctxPath = getContextPath(servletContext); servletContext.setAttribute(contextPathVariableName, ctxPath); }\n\n    ### Response:", "ground_truth": "Stores context path in page context and request scope.", "predict": " Store the context path in the specified attribute of the ServletContext.\n\n@param servletContext         the current ServletContext.\n@param contextPathVariableName the name of the attribute to store the context path in."}, {"ID": 802, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean checkSelector(SlingHttpServletRequest request, String key) { String[] selectors = request.getRequestPathInfo().getSelectors(); for (String selector : selectors) { if (selector.equals(key)) { return true; } } return false; }\n\n    ### Response: Retrieves a key in the selectors and returns 'true' is the key is present.\n\n@param request the request object with the selector info\n@param key     the selector key which is checked.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isGetParameter(final HttpServletRequest request, String name) { name = URLCoder.encodeQueryParam(name) + '='; String query = request.getQueryString(); String[] nameValuePairs = StringUtil.splitc(query, '&'); for (String nameValuePair : nameValuePairs) { if (nameValuePair.startsWith(name)) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Checks if some parameter is in GET parameters.", "predict": " Checks if the given parameter is present in the request as a GET parameter.\n\n@param request the request object with the GET parameter info\n@param name    the name of the GET parameter which is checked."}, {"ID": 803, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] splitString(final String str, final char splitChar) { final int length = str.length(); final StringBuilder bulder = new StringBuilder(Math.max(8, length)); int counter = 1; for (int i = 0; i < length; i++) { if (str.charAt(i) == splitChar) { counter++; } } final String[] result = new String[counter]; int position = 0; for (int i = 0; i < length; i++) { final char chr = str.charAt(i); if (chr == splitChar) { result[position++] = bulder.toString(); bulder.setLength(0); } else { bulder.append(chr); } } if (position < result.length) { result[position] = bulder.toString(); } return result; }\n\n    ### Response: Split a string for a char used as the delimeter.\n\n@param str       a string to be split\n@param splitChar a char to be used as delimeter\n@return array contains split string parts without delimeter chars.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] prepareParameters( final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) { int emptyCount = 0; int total = paramValues.length; for (int i = 0; i < paramValues.length; i++) { String paramValue = paramValues[i]; if (paramValue == null) { emptyCount++; continue; } if (paramValue.length() == 0) { emptyCount++; if (treatEmptyParamsAsNull) { paramValue = null; } } paramValues[i] = paramValue; } if ((ignoreEmptyRequestParams) && (emptyCount == total)) { return null; } } return paramValues; }\n\n    ### Response:", "ground_truth": "Prepares parameters for further processing.\n@param paramValues\tstring array of param values\n@param treatEmptyParamsAsNull\tempty parameters should be treated as null\n@param ignoreEmptyRequestParams\tif all parameters are empty, return null", "predict": " Prepare parameters for a request.\n\n@param paramValues              an array of parameter values\n@param treatEmptyParamsAsNull   a flag to indicate whether to treat empty parameters as null\n@param ignoreEmptyRequestParams a flag to indicate whether to ignore empty request parameters\n@return an array of parameter values after preparing them for a request. If all parameters are empty and ignoreEmptyRequestParams is true, returns null."}, {"ID": 804, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public void init(ServletConfig config) throws ServletException { super.init(config); // Move init params to my properties Enumeration<String> paramNames = this.getInitParameterNames(); while (paramNames.hasMoreElements()) { String paramName = paramNames.nextElement(); this.setProperty(paramName, this.getInitParameter(paramName)); } if (Boolean.TRUE.toString().equalsIgnoreCase(this.getInitParameter(LOG_PARAM))) logger = Logger.getLogger(PROPERTY_PREFIX); }\n\n    ### Response: web servlet init method.\n@exception ServletException From inherited class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyParamsToAttributes( final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { Enumeration paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues == null) { continue; } servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } // multipart if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } FileUpload[] paramValues = multipartRequest.getFiles(paramName); servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } }\n\n    ### Response:", "ground_truth": "Copies all request parameters to attributes.", "predict": " Copy parameters from request to attributes.\n@param servletRequest The request object.\n@param treatEmptyParamsAsNull If true, empty parameters will be treated as null.\n@param ignoreEmptyRequestParams If true, empty request parameters will be ignored.\n@exception ServletException If there is an error processing the request."}, {"ID": 805, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] serializeObject(Object obj) { if (obj == null) { return null; } ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(obj); out.flush(); } catch (IOException ioex) { throw new EJBException(\"Timer info object failed to serialize.\", ioex); } return baos.toByteArray(); }\n\n    ### Response: Internal convenience method for serializing the user info object to a byte array..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void invokeBody(final JspFragment body) throws JspException { if (body == null) { return; } try { body.invoke(null); } catch (IOException ioex) { throw new JspException(\"Tag body failed\", ioex); } }\n\n    ### Response:", "ground_truth": "Invokes tag body.", "predict": " Internal convenience method for invoking the tag body."}, {"ID": 806, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String serialize(Value value) throws JSONException { StringWriter writer = new StringWriter(); Serializer.serialize(value, writer); return writer.toString(); }\n\n    ### Response: Serializes a JSON value to a string.\n@param value the value to serialize\n@return the serialized value\n@throws JSONException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] renderBody(final JspFragment body) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter(); invokeBody(body, writer); return writer.toCharArray(); }\n\n    ### Response:", "ground_truth": "Renders tag body to char array.", "predict": " Renders the body of a JSP page and returns the result as a character array.\n@param body the JSP fragment to render\n@return the rendered body as a character array\n@throws JspException."}, {"ID": 807, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String fill(char symbol, int times) { char[] result = new char[times]; for (int i = 0; i < times; i++) { result[i] = symbol; } return new String(result); }\n\n    ### Response: Returns string of specified length filled with specified symbol\n\n@param symbol character with which String would be filled\n@param times  amount of times character would be copied\n@return filled String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String renderBodyToString(final JspFragment body) throws JspException { char[] result = renderBody(body); return new String(result); }\n\n    ### Response:", "ground_truth": "Renders tag body to string.\n@see #renderBody(javax.servlet.jsp.tagext.JspFragment)", "predict": " Renders the body of the JSP page and returns it as a string.\n\n@param body JspFragment object representing the body of the JSP page\n@return String representation of the rendered JSP page\n@throws JspException if an error occurs during rendering\n\n    "}, {"ID": 808, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized void setChannels(Collection<WonderPushChannel> channels) { if (channels == null) return; boolean save = false; try { Set<String> channelIdsToRemove = new HashSet<>(sChannels.keySet()); for (WonderPushChannel channel : channels) { if (channel == null) continue; channelIdsToRemove.remove(channel.getId()); if (_putChannel(channel)) save = true; } for (String channelId : channelIdsToRemove) { if (_removeChannel(channelId)) save = true; } } catch (Exception ex) { Log.e(WonderPush.TAG, \"Unexpected error while setting channels \" + channels, ex); } finally { try { if (save) { save(); } } catch (Exception ex) { Log.e(WonderPush.TAG, \"Unexpected error while setting channels \" + channels, ex); } } }\n\n    ### Response: Create, update and remove channels to match the given channels.\n\nCreates, updates and removes channels both in this class registry and in Android.\n\nAny non listed, previously existing channel will be removed.\n\n@param channels The channels to create or update.\nAny non listed, previously existing channel will be removed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) { for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) { if (invocationStrategy != initMethod.invocationStrategy) { continue; } try { initMethod.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid init method: \" + initMethod, ex); } } }\n\n    ### Response:", "ground_truth": "Invokes init methods.", "predict": "Invoke the initialization methods of the bean.\n\n@param invocationStrategy The strategy to use to invoke the initialization methods."}, {"ID": 809, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void delete(IPermission[] perms) throws AuthorizationException { if (perms.length > 0) { try { primDelete(perms); } catch (Exception ex) { log.error(\"Exception deleting permissions \" + Arrays.toString(perms), ex); throw new AuthorizationException( \"Exception deleting permissions \" + Arrays.toString(perms), ex); } } }\n\n    ### Response: Delete the IPermissions from the store.\n\n@param perms org.apereo.portal.security.IPermission[]\n@exception AuthorizationException - wraps an Exception specific to the store..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void callDestroyMethods() { for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) { try { destroyMethodPoint.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex); } } }\n\n    ### Response:", "ground_truth": "Calls destroy methods on given BeanData. Destroy methods are called\nwithout any order.", "predict": "Destroys the bean by calling any configured destroy methods.\n\n@exception PetiteException - wraps an Exception specific to the Petite container."}, {"ID": 810, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object doGetFieldValue(String fullField, String field, Object object, boolean useCache, Map<String, ReflectInfo> cachedFields) { // check cache Field f; if (useCache) { ReflectInfo info = cachedFields.get(fullField); if (info != null) { return getField(info.target, info.field); } } int index = field.indexOf('.'); if (index != -1) { String parent = field.substring(0, index); String sub = field.substring(index + 1); try { f = FieldUtils.findField(object.getClass(), parent); if (f == null) { throw new RuntimeException( \"No field '\" + parent + \"' found at class \" + object.getClass().getName()); } f.setAccessible(true); Object o = f.get(object); if (o == null) { return null; } return get(fullField, sub, o); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } } f = FieldUtils.findField(object.getClass(), field); if (f == null) { throw new RuntimeException(\"No field '\" + field + \"' found at class \" + object.getClass().getName()); } if (useCache && !cachedFields.containsKey(fullField)) { cachedFields.put(fullField, new ReflectInfo(f, object)); } return getField(object, f); }\n\n    ### Response: Do get field value.\n\n@param fullField the full field\n@param field the field\n@param object the object\n@param useCache the use cache\n@param cachedFields the cached fields\n@return the object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object newBeanInstance() { if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) { throw new PetiteException(\"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition.type.getName()); } int paramNo = beanDefinition.ctor.references.length; Object[] args = new Object[paramNo]; // wiring if (beanDefinition.wiringMode != WiringMode.NONE) { for (int i = 0; i < paramNo; i++) { args[i] = pc.getBean(beanDefinition.ctor.references[i]); if (args[i] == null) { if ((beanDefinition.wiringMode == WiringMode.STRICT)) { throw new PetiteException( \"Wiring constructor failed. References '\" + beanDefinition.ctor.references[i] + \"' not found for constructor: \" + beanDefinition.ctor.constructor); } } } } // create instance final Object bean; try { bean = beanDefinition.ctor.constructor.newInstance(args); } catch (Exception ex) { throw new PetiteException(\"Failed to create new bean instance '\" + beanDefinition.type.getName() + \"' using constructor: \" + beanDefinition.ctor.constructor, ex); } return bean; }\n\n    ### Response:", "ground_truth": "Creates a new instance.", "predict": " New bean instance.\n\n@return the new bean instance."}, {"ID": 811, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setPrivateField(final Object obj, final String name, final Object value) { try { final Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } catch (final Exception ex) { throw new RuntimeException(\"Couldn't set field '\" + name + \"' in class '\" + obj.getClass() + \"'\", ex); } }\n\n    ### Response: Sets a private field in an object by using reflection.\n\n@param obj\nObject with the attribute to set.\n@param name\nName of the attribute to set.\n@param value\nValue to set for the attribute..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) { if (beanDefinition.name == null) { return; } if (implicitParamInjection) { // implicit final int len = beanDefinition.name.length() + 1; for (final String param : beanDefinition.params) { final Object value = paramManager.get(param); final String destination = param.substring(len); try { BeanUtil.declared.setProperty(bean, destination, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition.name, ex); } } } // explicit for (final ValueInjectionPoint pip : beanDefinition.values) { final String value = paramManager.parseKeyTemplate(pip.valueTemplate); try { BeanUtil.declared.setProperty(bean, pip.property, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set value for: '\" + pip.valueTemplate + \"' to bean: \" + beanDefinition.name, ex); } } }\n\n    ### Response:", "ground_truth": "Injects all parameters.", "predict": " Injects parameters and values into a bean based on its definition.\n\n@param paramManager\nManager for resolving parameter values.\n@param implicitParamInjection\nWhether to inject parameters implicitly (i.e. by prefixing them with the bean name).\n@param beanDefinition\nDefinition of the bean to inject parameters and values into."}, {"ID": 812, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getEmbeddedId( final HttpServletRequest servletRequest, final Prefix prefix) { String requestPath = servletRequest.getPathInfo(); // http://stackoverflow.com/questions/18963562/grizzlys-request-getpathinfo-returns-always-null if (requestPath == null && servletRequest.getContextPath().isEmpty()) { requestPath = servletRequest.getRequestURI(); } String id = null; if (requestPath != null) { final String pathPrefix = prefix.getPrefix(); final String[] part = requestPath.split(\"/\"); if (part.length > 1 && part[1].startsWith(pathPrefix)) { id = part[1].substring(pathPrefix.length()); } } return id; }\n\n    ### Response: Extract the id embedded at the beginning of a request path\n\n@param servletRequest the servlet request\n@param prefix the prefix for the id\n@return the found id or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"UnusedDeclaration\"}) public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) { return actionPath; }\n\n    ### Response:", "ground_truth": "Rewrites action path.", "predict": " This method rewrites the action path based on the http method.\n\n@param servletRequest the servlet request\n@param actionPath the original action path\n@param httpMethod the http method\n@return the rewritten action path."}, {"ID": 813, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static List<String> resolveValues(final Iterable<? extends String> values) { final List<String> valuesList = new ArrayList<String>(); for(final String value : values) { Validate.notNull(value, \"One of the specified values was null\"); valuesList.add(value); } return valuesList; }\n\n    ### Response: Private helper method for setting the field values. nulls are not permitted. Instances are immutable so this\nmethod cannot be made public.\n\n@param values A non-null Iterable of field values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addHeader(final String name, final String value) { List<String> valuesList = super.getAll(name); if (valuesList.isEmpty()) { super.add(name, value); return; } super.remove(name); valuesList.add(value); super.addAll(name, valuesList); }\n\n    ### Response:", "ground_truth": "Adds new header value. If existing value exist, it will be removed\nso the store the new key value.", "predict": " Adds a header with the specified name and value to the HTTP message. If a header with the same name already exists, the value is added to the existing header. If the header does not exist, it is created with the specified value.\n\n@param name The name of the header to add.\n@param value The value of the header to add."}, {"ID": 814, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String checkPattern(final String value, final Pattern pattern, final boolean withBrace) { String res = value; final Matcher matcher = pattern.matcher(value); while (matcher.find()) { final String envName = matcher.group(2); if (!this.varenvMap.containsKey(envName)) { final String envValue = System.getenv(envName); this.varenvMap.put(envName, envValue); } // Check if the var env is ready if (this.varenvMap.get(envName) != null) { if (withBrace) { res = res.replace(\"${\" + envName + \"}\", this.varenvMap.get(envName)); } else { res = res.replace(\"$\" + envName, this.varenvMap.get(envName)); } } else { LOGGER.log(UNDEFINED_ENV_VAR, envName); } } return res; }\n\n    ### Response: Check if the given string contains an environment variable.\n\n@param value the string value to parse\n@param pattern the regex pattern to use\n@param withBrace true for ${varname}, false for $varname\n\n@return the given string updated with right environment variable content.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) { String realValue = value; if (append || appendDuplicateProps) { PropsEntry pv = map.get(key); if (pv != null) { realValue = pv.value + APPEND_SEPARATOR + realValue; } } PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); }\n\n    ### Response:", "ground_truth": "Puts key-value pair into the map, with respect of appending duplicate properties", "predict": " Add a new property to the map.\n\n@param profile the profile name\n@param map the map to add the property to\n@param key the property key\n@param value the property value\n@param append true to append the value to an existing property with the same key, false to overwrite it\n\n@return the updated map with the new property added."}, {"ID": 815, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void put(String section, String key, String value, boolean append) { // ignore lines without = if (key == null) { return; } if (section == null) { put(key, value, append); return; } put(key.isEmpty() ? section : section + '.' + key, value, append); }\n\n    ### Response: Adds accumulated value to key and current section..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void putBaseProperty(final String key, final String value, final boolean append) { put(null, baseProperties, key, value, append); }\n\n    ### Response:", "ground_truth": "Adds base property.", "predict": " Adds a property to the baseProperties section of the properties file."}, {"ID": 816, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void put(String section, String key, String value, boolean append) { // ignore lines without = if (key == null) { return; } if (section == null) { put(key, value, append); return; } put(key.isEmpty() ? section : section + '.' + key, value, append); }\n\n    ### Response: Adds accumulated value to key and current section..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void putProfileProperty(final String key, final String value, final String profile, final boolean append) { Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>()); put(profile, map, key, value, append); }\n\n    ### Response:", "ground_truth": "Adds profile property.", "predict": " Adds a property to a profile. If the profile does not exist, it will be created. If the property already exists, its value will be updated."}, {"ID": 817, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getValueFromServerConfiguration(final Server server, final String key) { if (server == null) { return null; } final Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration(); if (configuration == null) { return null; } final Xpp3Dom node = configuration.getChild(key); if (node == null) { return null; } return node.getValue(); }\n\n    ### Response: Get string value from server configuration section in settings.xml.\n\n@param server Server object.\n@param key    Key string.\n@return String value if key exists; otherwise, return null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropsEntry getProfileProperty(final String profile, final String key) { final Map<String, PropsEntry> profileMap = profileProperties.get(profile); if (profileMap == null) { return null; } return profileMap.get(key); }\n\n    ### Response:", "ground_truth": "Returns profile property.", "predict": " Get property entry from profile properties map.\n\n@param profile Profile name.\n@param key     Property key.\n@return Property entry if key exists in profile properties map; otherwise, return null."}, {"ID": 818, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int[] balancePair(String str, String left, String right) { int count = 0; int offset = 0; int firstLeft = -1; while (true) { int leftIndex = str.indexOf(left, offset); int rightIndex = str.indexOf(right, offset); if (leftIndex == rightIndex) { return new int[] { firstLeft, -1 }; } else if ((leftIndex < rightIndex && leftIndex != -1) || rightIndex == -1) { if (firstLeft == -1) { firstLeft = leftIndex; } count++; offset = leftIndex + 1; } else { count--; offset = rightIndex + 1; if (count < 0) { return new int[] { firstLeft, -1 }; } if (count == 0) { return new int[] { firstLeft, rightIndex }; } } } }\n\n    ### Response: Get the first balance pair substring index.\n\n@param str the string\n@param left left symbol\n@param right right symbol\n@return (leftIndex, rightIndex) If not found, rightIndex is -1..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveMacros(String value, final String... profiles) { // create string template parser that will be used internally StringTemplateParser stringTemplateParser = new StringTemplateParser(); stringTemplateParser.setResolveEscapes(false); if (!ignoreMissingMacros) { stringTemplateParser.setReplaceMissingKey(false); } else { stringTemplateParser.setReplaceMissingKey(true); stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY); } final Function<String, String> macroResolver = macroName -> { String[] lookupProfiles = profiles; int leftIndex = macroName.indexOf('<'); if (leftIndex != -1) { int rightIndex = macroName.indexOf('>'); String profiles1 = macroName.substring(leftIndex + 1, rightIndex); macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(profiles1, ','); StringUtil.trimAll(lookupProfiles); } return lookupValue(macroName, lookupProfiles); }; // start parsing int loopCount = 0; while (loopCount++ < MAX_INNER_MACROS) { final String newValue = stringTemplateParser.parse(value, macroResolver); if (newValue.equals(value)) { break; } if (skipEmptyProps) { if (newValue.length() == 0) { return null; } } value = newValue; } return value; }\n\n    ### Response:", "ground_truth": "Resolves all macros in this props set. Called on property lookup.", "predict": " Resolve macros in the given value using the given profiles.\n\n@param value the value to resolve macros in\n@param profiles the profiles to use for resolving macros\n@return the resolved value\n\n    "}, {"ID": 819, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPrefix(PackageElement packageElement) { if (packageElement == null) { return \"\"; } String packageName = packageElement.getQualifiedName().toString(); String prefix = getPrefix(packageName); if (prefix != null) { return prefix; } prefix = packageLookup.getObjectiveCName(packageName); if (prefix == null) { prefix = NameTable.camelCaseQualifiedName(packageName); } addPrefix(packageName, prefix); return prefix; }\n\n    ### Response: Return the prefix for a specified package. If a prefix was specified\nfor the package, then that prefix is returned. Otherwise, a camel-cased\nprefix is created from the package name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) { if (target == null) { target = new HashMap(); } // make sure prefix ends with a dot if (prefix != null) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } } if (profiles != null) { for (String profile : profiles) { while (true) { final Map<String, PropsEntry> map = this.profileProperties.get(profile); if (map != null) { extractMap(target, map, profiles, wildcardPatterns, prefix); } final int ndx = profile.lastIndexOf('.'); if (ndx == -1) { break; } profile = profile.substring(0, ndx); } } } extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix); return target; }\n\n    ### Response:", "ground_truth": "Extracts props to target map. This is all-in-one method, that does many things at once.", "predict": " Extract properties from a map of properties, using a set of profiles and wildcard patterns. If a prefix is specified, it is added to the beginning of each property name. If a property name matches any of the wildcard patterns, it is included in the result. If a property name is not found in any of the profiles, it is included in the result with a null value."}, {"ID": 820, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int streamToWord(byte[] data, int[] offp) { int i; int word = 0; int off = offp[0]; for (i = 0; i < 4; i++) { word = (word << 8) | (data[off] & 0xff); off = (off + 1) % data.length; } offp[0] = off; return word; }\n\n    ### Response: Cyclically extract a word of key material\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int streamtoword(byte[] data, int[] offp) { int i; int word = 0; int off = offp[0]; for (i = 0; i < 4; i++) { word = (word << 8) | (data[off] & 0xff); off = (off + 1) % data.length; } offp[0] = off; return word; }\n\n    ### Response:", "ground_truth": "Cycically extract a word of key material.\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data", "predict": " Cyclically extract a word of key material\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data."}, {"ID": 821, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setTarget(String target) throws IllegalArgumentException { int major, minor; if (target == null || \"1.0\".equals(target) || \"1.1\".equals(target)) { major = 45; minor = 3; if (target == null) { target = \"1.0\"; } } else if (\"1.2\".equals(target)) { major = 46; minor = 0; } else if (\"1.3\".equals(target)) { major = 47; minor = 0; } else if (\"1.4\".equals(target)) { major = 48; minor = 0; } else if (\"1.5\".equals(target)) { major = 49; minor = 0; } else if (\"1.6\".equals(target)) { major = 50; minor = 0; } else if (\"1.7\".equals(target)) { major = 51; minor = 0; } else { throw new IllegalArgumentException (\"Unsupported target version: \" + target); } mVersion = (minor << 16) | (major & 0xffff); mTarget = target.intern(); }\n\n    ### Response: Specify what target virtual machine version classfile should generate\nfor. Calling this method changes the major and minor version of the\nclassfile format.\n\n@param target VM version, 1.0, 1.1, etc.\n@throws IllegalArgumentException if target is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String hashpw(String password, String salt) { BCrypt B; String real_salt; byte[] passwordb, saltb, hashed; char minor = (char) 0; int rounds, off; StringBuffer rs = new StringBuffer(); if (salt.charAt(0) != '$' || salt.charAt(1) != '2') { throw new IllegalArgumentException(\"Invalid salt version\"); } if (salt.charAt(2) == '$') { off = 3; } else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') { throw new IllegalArgumentException(\"Invalid salt revision\"); } off = 4; } // Extract number of rounds if (salt.charAt(off + 2) > '$') { throw new IllegalArgumentException(\"Missing salt rounds\"); } rounds = Integer.parseInt(salt.substring(off, off + 2)); real_salt = salt.substring(off + 3, off + 25); try { passwordb = (password + (minor >= 'a' ? \"\\000\" : \"\")).getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { throw new AssertionError(\"UTF-8 is not supported\"); } saltb = decode_base64(real_salt, BCRYPT_SALT_LEN); B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, (int[]) bf_crypt_ciphertext.clone()); rs.append(\"$2\"); if (minor >= 'a') { rs.append(minor); } rs.append('$'); if (rounds < 10) { rs.append('0'); } if (rounds > 30) { throw new IllegalArgumentException( \"rounds exceeds maximum (30)\"); } rs.append(rounds) .append('$') .append(encode_base64(saltb, saltb.length)) .append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); }\n\n    ### Response:", "ground_truth": "Hash a password using the OpenBSD bcrypt scheme.\n\n@param password the password to hash\n@param salt the salt to hash with (perhaps generated\nusing BCrypt.gensalt)\n@return the hashed password", "predict": " Generate a method-level comment for the following Java code:\r\n\r\n```java\r\npublic static String hashpw(String password, String salt) {\r\n    BCrypt B;\r\n    String real_salt;\r\n    byte[] passwordb, saltb, hashed;\r\n    char minor = (char) 0;\r\n    int rounds, off;\r\n    StringBuffer rs = new StringBuffer();\r\n\r\n    if (salt.charAt(0) != '$' || salt.charAt(1) != '2') {\r\n        throw new IllegalArgumentException(\"Invalid salt version\");\r\n    }\r\n\r\n    if (salt.charAt(2) == '$') {\r\n        off = 3;\r\n    } else {\r\n        minor = salt.charAt(2);\r\n        if (minor != 'a' || salt.charAt(3) != '$') {\r\n            throw new IllegalArgumentException(\"Invalid salt revision\");\r\n        }\r\n        off = 4;\r\n    }\r\n\r\n    // Extract number of rounds\r\n    if (salt.charAt(off + 2) > '$') {\r\n        throw new IllegalArgumentException(\"Missing salt rounds\");\r\n    }\r\n\r\n    rounds"}, {"ID": 822, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean constantTimeEquals(byte[] a, byte[] b) { if (a.length != b.length) { return false; } int result = 0; for (int i = 0; i < a.length; i++) { result |= a[i] ^ b[i]; } return result == 0; }\n\n    ### Response: Checks if byte arrays a and be are equal in an algorithm that runs in\nconstant time provided that their lengths are equal.\n\n@param a the first byte array\n@param b the second byte array\n@return true if a and be are equal, else false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean checkpw(String plaintext, String hashed) { byte[] hashed_bytes; byte[] try_bytes; try { String try_pw = hashpw(plaintext, hashed); hashed_bytes = hashed.getBytes(\"UTF-8\"); try_bytes = try_pw.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { return false; } if (hashed_bytes.length != try_bytes.length) { return false; } byte ret = 0; for (int i = 0; i < try_bytes.length; i++) { ret |= hashed_bytes[i] ^ try_bytes[i]; } return ret == 0; }\n\n    ### Response:", "ground_truth": "Check that a plaintext password matches a previously hashed\none.\n\n@param plaintext the plaintext password to verify\n@param hashed the previously-hashed password\n@return true if the passwords match, false otherwise", "predict": " Checks if a plaintext password matches a hashed password in an algorithm that runs in constant time.\n\n@param plaintext the plaintext password to check\n@param hashed the hashed password to compare to\n@return true if the plaintext password matches the hashed password, else false."}, {"ID": 823, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int countLineBreaks(String s) { int pos = -1; int count = 0; while (true) { int nextPos = s.indexOf('\\n', pos + 1); if (nextPos == -1) { break; } pos = nextPos; count++; } return count; }\n\n    ### Response: non-private only for test case.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int copyAll(final OutputStream out) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; } return count; }\n\n    ### Response:", "ground_truth": "Copies bytes from this stream to some output until boundary is\nreached. Returns number of copied bytes. It will throw an exception\nfor any irregular behaviour.", "predict": " non-private only for test case."}, {"ID": 824, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final int readAll(ReadableByteChannel ch, ByteBuffer dst) throws IOException { int count = 0; while (dst.hasRemaining()) { int rc = ch.read(dst); if (rc == -1) { if (count > 0) { return count; } return -1; } count += rc; } return count; }\n\n    ### Response: Read channel until dst has remaining or eof.\n@param ch\n@param dst\n@return Returns number of bytes or -1 if no bytes were read and eof reached.\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; }\n\n    ### Response:", "ground_truth": "Copies max or less number of bytes to output stream. Useful for determining\nif uploaded file is larger then expected.", "predict": " Copy bytes from input stream to output stream until maxBytes or boundary is reached.\n@param out\n@param maxBytes\n@return Returns number of bytes copied.\n@throws IOException."}, {"ID": 825, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initBeforeList() { final List<ProcessAdvice> beforeRequestProcessAdvices = new ArrayList<>(); final Method invokeHolder = getInvokeHolder(); final Class<?> processorClass = invokeHolder.getDeclaringClass(); // 1. process class advice if (null != processorClass && processorClass.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = processorClass.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } // 2. process method advice if (invokeHolder.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = invokeHolder.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } this.beforeRequestProcessAdvices = beforeRequestProcessAdvices; }\n\n    ### Response: Initializes before process advices..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod); final ActionConfig actionConfig = resolveActionConfig(annotationValues); // interceptors ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig); // filters ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig); // build action definition when not provided if (actionDefinition == null) { actionDefinition = parseActionDefinition(actionClass, actionMethod); } detectAndRegisterAlias(annotationValues, actionDefinition); final boolean async = parseMethodAsyncFlag(actionMethod); final boolean auth = parseMethodAuthFlag(actionMethod); final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod); final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult(); return createActionRuntime( null, actionClass, actionMethod, actionResult, defaultActionResult, actionFilters, actionInterceptors, actionDefinition, async, auth); }\n\n    ### Response:", "ground_truth": "Parses java action method annotation and returns its action runtime.\n\n@param actionClass action class\n@param actionMethod action method\n@param actionDefinition optional action def, usually null so to be parsed", "predict": " Parses the action runtime for the given action class, method, and action definition.\n\n    "}, {"ID": 826, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> MapBinder<String, T> optionBinder(Binder binder, Key<T> interfaceKey) { final TypeLiteral<T> interfaceType = interfaceKey.getTypeLiteral(); if (interfaceKey.getAnnotation() != null) { return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType, interfaceKey.getAnnotation()); } else if (interfaceKey.getAnnotationType() != null) { Class<? extends Annotation> annotationType = interfaceKey.getAnnotationType(); return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType, annotationType); } else { return MapBinder.newMapBinder(binder, TypeLiteral.get(String.class), interfaceType); } }\n\n    ### Response: Binds an option for a specific choice.  The choice must already be registered on the injector for this to work.\n\n@param binder the binder for the injector that is being configured\n@param interfaceKey the interface that will have an option added to it.  This must equal the\nKey provided to createChoice\n@param  interface type\n@return A MapBinder that can be used to create the actual option bindings..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) { final Class<? extends Annotation> annotationType; if (annotationValues == null) { annotationType = Action.class; } else { annotationType = annotationValues.annotationType(); } return actionConfigManager.lookup(annotationType); }\n\n    ### Response:", "ground_truth": "Resolves action config.", "predict": " Resolves the action configuration for the given annotation type.\n\n@param annotationValues the annotation values to resolve the action configuration for\n@return the action configuration for the given annotation type.  If no action configuration is found, a default action configuration will be returned."}, {"ID": 827, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveTimeZoneId(String zoneId) { String alias = _CalendarUtils.getTimeZoneAlias(zoneId); if (alias != null) { zoneId = alias; } alias = TimeZoneAliases.getAlias(zoneId); if (alias != null) { zoneId = alias; } return zoneId; }\n\n    ### Response: Check if the zoneId has an alias in the CLDR data..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) { final String alias = parseMethodAlias(annotationValues); if (alias != null) { String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH); actionsManager.registerPathAlias(alias, aliasPath); } }\n\n    ### Response:", "ground_truth": "Detects if alias is defined in annotation and registers it if so.", "predict": " Parse the method alias from the annotation values and register it as an alias for the action path."}, {"ID": 828, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized Statistics getStatistics(String scheme, Class<? extends FileSystem> cls) { Statistics result = statisticsTable.get(cls); if (result == null) { result = new Statistics(scheme); statisticsTable.put(cls, result); } return result; }\n\n    ### Response: Get the statistics for a particular file system\n@param cls the class to lookup\n@return a statistics object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionInterceptor>[] result = null; InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class); if (interceptedBy != null) { result = interceptedBy.value(); if (result.length == 0) { result = null; } } return result; }\n\n    ### Response:", "ground_truth": "Reads class or method annotation for action interceptors.", "predict": " Read the action interceptors for a given action class or method\n@param actionClassOrMethod the action class or method to lookup\n@return an array of action interceptor classes. If no interceptors are specified, returns null."}, {"ID": 829, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized Statistics getStatistics(String scheme, Class<? extends FileSystem> cls) { Statistics result = statisticsTable.get(cls); if (result == null) { result = new Statistics(scheme); statisticsTable.put(cls, result); } return result; }\n\n    ### Response: Get the statistics for a particular file system\n@param cls the class to lookup\n@return a statistics object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionFilter>[] result = null; FilteredBy filteredBy = actionClassOrMethod.getAnnotation(FilteredBy.class); if (filteredBy != null) { result = filteredBy.value(); if (result.length == 0) { result = null; } } return result; }\n\n    ### Response:", "ground_truth": "Reads class or method annotation for action filters.", "predict": " Read the action filters for a particular action class or method\n@param actionClassOrMethod the action class or method to read\n@return an array of action filter classes or null if none are defined."}, {"ID": 830, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class findClassInternal(String name) throws ClassNotFoundException { if (!validate(name)) throw new ClassNotFoundException(name); String tempPath = name.replace('.', '/'); String classPath = tempPath + \".class\"; ResourceEntry entry = null; entry = findResourceInternal(name, classPath); if (entry == null) throw new ClassNotFoundException(name); Class clazz = entry.loadedClass; if (clazz != null) return clazz; synchronized (this) { if (entry.binaryContent == null && entry.loadedClass == null) throw new ClassNotFoundException(name); // Looking up the package String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); Package pkg = null; if (packageName != null) { pkg = getPackage(packageName); // Define the package (if null) if (pkg == null) { try { if (entry.manifest == null) { definePackage(packageName, null, null, null, null, null, null, null); } else { definePackage(packageName, entry.manifest, entry.codeBase); } } catch (IllegalArgumentException e) { // Ignore: normal error due to dual definition of package } pkg = getPackage(packageName); } } if (securityManager != null) { // Checking sealing if (pkg != null) { boolean sealCheck = true; if (pkg.isSealed()) { sealCheck = pkg.isSealed(entry.codeBase); } else { sealCheck = (entry.manifest == null) || !isPackageSealed(packageName, entry.manifest); } if (!sealCheck) throw new SecurityException (\"Sealing violation loading \" + name + \" : Package \" + packageName + \" is sealed.\"); } } if (entry.loadedClass == null) { clazz = defineClass(name, entry.binaryContent, 0, entry.binaryContent.length, new CodeSource(entry.codeBase, entry.certificates)); entry.loadedClass = clazz; entry.binaryContent = null; entry.source = null; entry.codeBase = null; entry.manifest = null; entry.certificates = null; } else { clazz = entry.loadedClass; } } return clazz; }\n\n    ### Response: Find specified class in local repositories.\n\n@return the loaded class, or null if the class isn't found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] readPackageActionPath(final Class actionClass) { Package actionPackage = actionClass.getPackage(); final String actionPackageName = actionPackage.getName(); // 1 - read annotations first String packageActionPathFromAnnotation; mainloop: while (true) { MadvocAction madvocActionAnnotation = actionPackage.getAnnotation(MadvocAction.class); packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null; if (StringUtil.isEmpty(packageActionPathFromAnnotation)) { packageActionPathFromAnnotation = null; } if (packageActionPathFromAnnotation == null) { // next package String newPackage = actionPackage.getName(); actionPackage = null; while (actionPackage == null) { final int ndx = newPackage.lastIndexOf('.'); if (ndx == -1) { // end of hierarchy, nothing found break mainloop; } newPackage = newPackage.substring(0, ndx); actionPackage = Packages.of(actionClass.getClassLoader(), newPackage); } } else { // annotation found, register root rootPackages.addRootPackage(actionPackage.getName(), packageActionPathFromAnnotation); break; } } // 2 - read root package String packagePath = rootPackages.findPackagePathForActionPackage(actionPackageName); if (packagePath == null) { return ArraysUtil.array(null, null); } return ArraysUtil.array( StringUtil.stripChar(packagePath, '/'), StringUtil.surround(packagePath, StringPool.SLASH) ); }\n\n    ### Response:", "ground_truth": "Reads action path for package.\nIf annotation is not set on package-level, class package will be used for\npackage action path part.", "predict": " Read the package path for the specified action class.\n\n@return an array of two strings: the package path and the package path with a trailing slash. The first string may be null if no package path was found. The second string may be null if the package path is empty."}, {"ID": 831, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static FieldInfo of(Field field) { if (field == null) { return null; } synchronized (CACHE) { FieldInfo fieldInfo = CACHE.get(field); boolean isEnumContant = field.isEnumConstant(); if (fieldInfo == null && (isEnumContant || !Modifier.isStatic(field.getModifiers()))) { String fieldName; if (isEnumContant) { // check for @Value annotation Value value = field.getAnnotation(Value.class); if (value != null) { fieldName = value.value(); } else { // check for @NullValue annotation NullValue nullValue = field.getAnnotation(NullValue.class); if (nullValue != null) { fieldName = null; } else { // else ignore return null; } } } else { // check for @Key annotation Key key = field.getAnnotation(Key.class); if (key == null) { // else ignore return null; } fieldName = key.value(); field.setAccessible(true); } if (\"##default\".equals(fieldName)) { fieldName = field.getName(); } fieldInfo = new FieldInfo(field, fieldName); CACHE.put(field, fieldInfo); } return fieldInfo; } }\n\n    ### Response: Returns the field information for the given field.\n\n@param field field or {@code null} for {@code null} result\n@return field information or {@code null} if the field has no {@link #name} or for {@code null}\ninput.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) { // read annotation String methodActionPath = annotationValues != null ? annotationValues.value() : null; if (methodActionPath == null) { methodActionPath = methodName; } else { if (methodActionPath.equals(Action.NONE)) { return ArraysUtil.array(null, null); } } // check for defaults for (String path : actionConfig.getActionMethodNames()) { if (methodActionPath.equals(path)) { methodActionPath = null; break; } } return ArraysUtil.array(methodName, methodActionPath); }\n\n    ### Response:", "ground_truth": "Reads action path from the action method.", "predict": " Reads the action path for the given method name and action annotation values.\n\n@param methodName the method name\n@param annotationValues the action annotation values or {@code null}\n@param actionConfig the action configuration\n@return the action path as an array with the method name as the first element and the action path as the second element or {@code null} if the action path is not defined or is equal to {@link Action#NONE}\ninput."}, {"ID": 832, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveTimeZoneId(String zoneId) { String alias = _CalendarUtils.getTimeZoneAlias(zoneId); if (alias != null) { zoneId = alias; } alias = TimeZoneAliases.getAlias(zoneId); if (alias != null) { zoneId = alias; } return zoneId; }\n\n    ### Response: Check if the zoneId has an alias in the CLDR data..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseMethodAlias(final ActionAnnotationValues annotationValues) { String alias = null; if (annotationValues != null) { alias = annotationValues.alias(); } return alias; }\n\n    ### Response:", "ground_truth": "Reads method's alias value.", "predict": " Parse the alias from the ActionAnnotationValues object."}, {"ID": 833, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Field> getFields(final Method method, final Object[] params) { final Annotation[][] parameterAnnotations = method.getParameterAnnotations(); final List<Field> fields = new ArrayList<Field>(); int i = 0; String paramName = null; for (final Annotation[] annotations : parameterAnnotations) { final Object object = params[i++]; boolean ignoreFlag = false; DeIdentify deidentify = null; for (final Annotation annotation : annotations) { if (annotation instanceof IgnoreAudit) { ignoreFlag = true; break; } if (annotation instanceof AuditField) { final AuditField field = (AuditField) annotation; paramName = field.field(); } if (annotation instanceof DeIdentify) { deidentify = (DeIdentify) annotation; } } if (ignoreFlag) { } else { if (null == paramName) { paramName = \"arg\" + i; } serializer.serialize(fields, object, paramName, deidentify); } paramName = null; } return fields; }\n\n    ### Response: Extract fields based on annotations.\n\n@param method\n: Class method with annotations.\n@param params\n: Method parameter values.\n\n@return list of fields extracted from method.\n\n@since 2.4.1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime createActionRuntime( final ActionHandler actionHandler, final Class actionClass, final Method actionClassMethod, final Class<? extends ActionResult> actionResult, final Class<? extends ActionResult> defaultActionResult, final ActionFilter[] filters, final ActionInterceptor[] interceptors, final ActionDefinition actionDefinition, final boolean async, final boolean auth) { if (actionHandler != null) { return new ActionRuntime( actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, NoneActionResult.class, NoneActionResult.class, async, auth, null, null); } final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass); // find ins and outs final Class[] paramTypes = actionClassMethod.getParameterTypes(); final MethodParam[] params = new MethodParam[paramTypes.length]; final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations(); String[] methodParamNames = null; // for all elements: action and method arguments... for (int ndx = 0; ndx < paramTypes.length; ndx++) { Class paramType = paramTypes[ndx]; // lazy init to postpone bytecode usage, when method has no arguments if (methodParamNames == null) { methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod); } final String paramName = methodParamNames[ndx]; final Annotation[] parameterAnnotations = paramAnns[ndx]; final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations); MapperFunction mapperFunction = null; for (final Annotation annotation : parameterAnnotations) { if (annotation instanceof Mapper) { mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value()); break; } } params[ndx] = new MethodParam( paramTypes[ndx], paramName, scopeDataInspector.detectAnnotationType(parameterAnnotations), paramsScopeData, mapperFunction ); } return new ActionRuntime( null, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params); }\n\n    ### Response:", "ground_truth": "Creates new instance of action runtime configuration.\nInitialize caches.", "predict": " Create an action runtime instance.\n\n@param actionHandler\n: Action handler instance.\n@param actionClass\n: Action class.\n@param actionClassMethod\n: Action class method.\n@param actionResult\n: Action result class.\n@param defaultActionResult\n: Default action result class.\n@param filters\n: Action filters.\n@param interceptors\n: Action interceptors.\n@param actionDefinition\n: Action definition.\n@param async\n: Async flag.\n@param auth\n: Auth flag.\n\n@return action runtime instance.\n\n@since 2.4.1."}, {"ID": 834, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean checkIfModifiedSince(final HttpServletRequest request, final HttpServletResponse response, final Attributes resourceAttributes) { try { final long headerValue = request.getDateHeader(\"If-Modified-Since\"); final long lastModified = resourceAttributes.getLastModified(); if (headerValue != -1) { // If an If-None-Match header has been specified, if modified // since // is ignored. if ((request.getHeader(\"If-None-Match\") == null) && (lastModified < headerValue + 1000)) { // The entity has not been modified since the date // specified by the client. This is not an error case. response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); response.setHeader(\"ETag\", resourceAttributes.getETag()); return false; } } } catch (final IllegalArgumentException illegalArgument) { return true; } return true; }\n\n    ### Response: Check if the if-modified-since condition is satisfied.\n\n@param request\nThe servlet request we are processing\n@param response\nThe servlet response we are creating\n@param resourceAttributes\nFile object\n@return boolean true if the resource meets the specified condition, and\nfalse if the condition is not satisfied, in which case request\nprocessing is stopped.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void preResponseCommit() { long lastModified = lastModifiedData.getLastModified(); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); if (lastModified > -1 && !response.containsHeader(\"Last-Modified\")) { if (ifModifiedSince < (lastModified / 1000 * 1000)) { response.setDateHeader(\"Last-Modified\", lastModified); } else { response.reset(); response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } }\n\n    ### Response:", "ground_truth": "todo move to BufferResponseWrapper ?", "predict": " This method is called before the response is committed. It checks if the Last-Modified header should be set based on the last modified date of the resource. If the If-Modified-Since header is present and is later than the last modified date, the response is reset and a 304 status code is set. Otherwise, the Last-Modified header is set to the last modified date."}, {"ID": 835, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> T invokeJavascriptReturnValue(String function, Class<T> returnType) { Object returnObject = invokeJavascript(function); if (returnObject instanceof JSObject) { try { Constructor<T> constructor = returnType.getConstructor(JSObject.class); return constructor.newInstance((JSObject) returnObject); } catch (Exception ex) { throw new IllegalStateException(ex); } } else { return (T) returnObject; } }\n\n    ### Response: Invokes a JavaScript function that takes no arguments.\n\n@param \n@param function The function to invoke\n@param returnType The type of object to return\n@return The result of the function..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T applyAdvice(final Class<T> targetClass) { Class adviceClass = cache.get(targetClass); if (adviceClass == null) { // advice not yet created adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define(); cache.put(targetClass, adviceClass); } // create new advice instance and injects target instance to it try { Object advice = ClassUtil.newInstance(adviceClass); Field field = adviceClass.getField(\"$___target$0\"); field.set(advice, targetClass); return (T) advice; } catch (Exception ex) { throw new ProxettaException(ex); } }\n\n    ### Response:", "ground_truth": "Applies advice on given target class and returns proxy instance.", "predict": " Applies a proxy to the specified class.\n\n@param targetClass The class to apply the proxy to\n@return A proxy instance of the specified class\n\n    "}, {"ID": 836, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setInvocationHandler(Object proxy, InvocationHandler handler) { Field field = getInvocationHandlerField(); try { field.set(proxy, handler); } catch (IllegalArgumentException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }\n\n    ### Response: Sets the invocation handler for a proxy created from this factory.\n\n@param proxy the proxy to modify\n@param handler the handler to use.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void injectTargetIntoProxy(final Object proxy, final Object target) { Class proxyClass = proxy.getClass(); try { Field field = proxyClass.getField(\"$___target$0\"); field.set(proxy, target); } catch (Exception ex) { throw new ProxettaException(ex); } }\n\n    ### Response:", "ground_truth": "Injects target into proxy.", "predict": " Injects the target object into a proxy object created by this factory.\n\n@param proxy the proxy object to modify\n@param target the target object to inject."}, {"ID": 837, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(String desc, boolean visible) { if (fv != null) { return fv.visitAnnotation(desc, visible); } return null; }\n\n    ### Response: Visits an annotation of the field.\n\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (fv != null) { return fv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of the field.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation of the field.\n\n@param descriptor\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation."}, {"ID": 838, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Table findUserTable(Session session, String name, String schemaName) { Schema schema = (Schema) schemaMap.get(schemaName); if (schema == null) { return null; } if (session != null) { Table table = session.getLocalTable(name); if (table != null) { return table; } } int i = schema.tableList.getIndex(name); if (i == -1) { return null; } return (Table) schema.tableList.get(i); }\n\n    ### Response: Returns the specified user-defined table or view visible within the\ncontext of the specified schema. It excludes system tables.\nReturns null if the table does not exist in the context..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveRealName(final String jsonName) { if (jsonNames == null) { return jsonName; } int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName); if (jsonIndex == -1) { return jsonName; } return realNames[jsonIndex]; }\n\n    ### Response:", "ground_truth": "Resolves real name from JSON name.", "predict": " Resolves the JSON name to its corresponding real name. If the JSON name is not found in the mapping, it returns the original JSON name.\n\n    "}, {"ID": 839, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { if (valueToAdd == 0) { return false; } int realIndex = iIndices[index]; if (realIndex == -1) { throw new UnsupportedOperationException(\"Field is not supported\"); } values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); return true; }\n\n    ### Response: Adds to the indexed field part of the period.\n\n@param period  the period to query\n@param index  the index to use\n@param values  the array to populate\n@param valueToAdd  the value to add\n@return true if the array is updated\n@throws UnsupportedOperationException if not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveJsonName(final String realName) { if (realNames == null) { return realName; } int realIndex = ArraysUtil.indexOf(realNames, realName); if (realIndex == -1) { return realName; } return jsonNames[realIndex]; }\n\n    ### Response:", "ground_truth": "Resolves JSON name from real name.", "predict": " Resolves the JSON name for the given real name.\n\n@param realName  the real name to resolve\n@return the JSON name, or the real name if not found\n@throws IllegalArgumentException if the real name is null"}, {"ID": 840, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function RendererLayer(game, type, settings) { this.game = game; this.type = type; var typeData = RendererLayer.Types[type]; RL.Util.merge(this, typeData); for(var key in settings){ if(this[key] !== void 0){ this[key] = settings[key]; } } }\n\n    ### Response: Represents a map tile layer to be rendered.\n@class RendererLayer\n@constructor\n@param {Game} game - Game instance this obj is attached to.\n@param {String} type - Type of `RendererLayer`. When created this object is merged with the value of `RendererLayer.Types[type]`..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public TypeData lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { if (serializationSubclassAware) { typeData = findSubclassTypeData(type); } if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } } return typeData; }\n\n    ### Response:", "ground_truth": "Returns all includes for given type. Returns an empty array\nwhen no includes are defined.", "predict": " Looks up the `TypeData` for the given class. If the `TypeData` is not found, it will scan the class for annotations and create a new `TypeData` object. If `serializationSubclassAware` is true, it will also look for a subclass of the given class and use its `TypeData` if found.\n@method lookupTypeData\n@param {Class} type - Class to lookup `TypeData` for.\n@return {TypeData} `TypeData` for the given class."}, {"ID": 841, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function RendererLayer(game, type, settings) { this.game = game; this.type = type; var typeData = RendererLayer.Types[type]; RL.Util.merge(this, typeData); for(var key in settings){ if(this[key] !== void 0){ this[key] = settings[key]; } } }\n\n    ### Response: Represents a map tile layer to be rendered.\n@class RendererLayer\n@constructor\n@param {Game} game - Game instance this obj is attached to.\n@param {String} type - Type of `RendererLayer`. When created this object is merged with the value of `RendererLayer.Types[type]`..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeData _lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } return typeData; }\n\n    ### Response:", "ground_truth": "Lookups type data and creates one if missing.", "predict": " Looks up the `TypeData` for the given class type. If it doesn't exist, it scans the class for annotations and creates a new `TypeData` object.\n@method _lookupTypeData\n@private\n@param {Class} type - Class type to lookup.\n@return {TypeData} - `TypeData` object for the given class type."}, {"ID": 842, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> TypeConverter findTypeConverter(Class<?> sourceType, Class<T> targetType, Class<? extends Annotation> formattingAnnotation) { TypeConverter typeConverter = null; List<Class> sourceHierarchy = ClassUtils.resolveHierarchy(sourceType); List<Class> targetHierarchy = ClassUtils.resolveHierarchy(targetType); boolean hasFormatting = formattingAnnotation != null; for (Class sourceSuperType : sourceHierarchy) { for (Class targetSuperType : targetHierarchy) { ConvertiblePair pair = new ConvertiblePair(sourceSuperType, targetSuperType, formattingAnnotation); typeConverter = typeConverters.get(pair); if (typeConverter != null) { converterCache.put(pair, typeConverter); return typeConverter; } } } if (hasFormatting) { for (Class sourceSuperType : sourceHierarchy) { for (Class targetSuperType : targetHierarchy) { ConvertiblePair pair = new ConvertiblePair(sourceSuperType, targetSuperType); typeConverter = typeConverters.get(pair); if (typeConverter != null) { converterCache.put(pair, typeConverter); return typeConverter; } } } } return typeConverter; }\n\n    ### Response: Find the type converter.\n@param sourceType sourceType\n@param targetType  targetType\n@param formattingAnnotation formattingAnnotation\n@param  Generic type\n@return type converter.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeData findSubclassTypeData(final Class type) { final Class<? extends Annotation> defaultAnnotation = jsonAnnotation; if (type.getAnnotation(defaultAnnotation) != null) { // current type has annotation, don't find anything, let type data be created return null; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); // lookup superclasses Class[] superClasses = cd.getAllSuperclasses(); for (Class superClass : superClasses) { if (superClass.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(superClass); } } Class[] interfaces = cd.getAllInterfaces(); for (Class interfaze : interfaces) { if (interfaze.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(interfaze); } } return null; }\n\n    ### Response:", "ground_truth": "Finds type data of first annotated superclass or interface.", "predict": " Find the subclass type data.\n@param type type\n@return subclass type data."}, {"ID": 843, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ImageIcon loadIcon(final Class clasz, final String name) { final URL url = Utils4J.getResource(clasz, name); return new ImageIcon(url); }\n\n    ### Response: Load an icon located in the same package as a given class.\n\n@param clasz\nClass with the same package where the icon is located.\n@param name\nFilename of the icon.\n\n@return New icon instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveJsonName(final Class type, final String name) { TypeData typeData = lookupTypeData(type); return typeData.resolveJsonName(name); }\n\n    ### Response:", "ground_truth": "Returns different name of a property if set by annotation.", "predict": " Resolves the JSON name for a given Java type and property name.\n\n@param type\nJava type for which to resolve the JSON name.\n@param name\nJava property name for which to resolve the JSON name.\n\n@return Resolved JSON name for the given Java type and property name."}, {"ID": 844, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Class findNearestMatchingRelationClass(final String sourceTypeName, final String relType, final String targetTypeName) { final Class sourceType = getNodeEntityClass(sourceTypeName); final Class targetType = getNodeEntityClass(targetTypeName); final Map<Integer, Class> candidates = new TreeMap<>(); for (final Class candidate : getRelationClassCandidatesForRelType(relType)) { final Relation rel = instantiate(candidate); final int distance = getDistance(rel.getSourceType(), sourceType, -1) + getDistance(rel.getTargetType(), targetType, -1); if (distance >= 2000) { candidates.put(distance - 2000, candidate); } } if (candidates.isEmpty()) { return null; } else { final Entry<Integer, Class> candidateEntry = candidates.entrySet().iterator().next(); final Class c = candidateEntry.getValue(); combinedTypeRelationClassCache.put(getCombinedType(sourceTypeName, relType, targetTypeName), c); return c; } }\n\n    ### Response: Find the most specialized relation class matching the given\nparameters.\n\nIf no direct match is found (source and target type are equal), we\ncount the levels of inheritance, including interfaces.\n\n@param sourceTypeName\n@param relType\n@param targetTypeName\n@param rel\n@param candidate\n@return class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveRealName(final Class type, final String jsonName) { TypeData typeData = lookupTypeData(type); return typeData.resolveRealName(jsonName); }\n\n    ### Response:", "ground_truth": "Returns real property name for given JSON property.", "predict": " Resolves the real name of a property based on the type and the\nname in the JSON payload.\n\n@param type\n@param jsonName\n@return real name."}, {"ID": 845, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object wrappedArray(CollectionNumber coll) { Object data = wrappedFloatArray(coll); if (data != null) { return data; } data = wrappedDoubleArray(coll); if (data != null) { return data; } data = wrappedByteArray(coll); if (data != null) { return data; } data = wrappedShortArray(coll); if (data != null) { return data; } data = wrappedIntArray(coll); if (data != null) { return data; } data = wrappedLongArray(coll); if (data != null) { return data; } return null; }\n\n    ### Response: If available, return the array wrapped by the collection - USE WITH\nCAUTION AS IT EXPOSES THE INTERNAL STATE OF THE COLLECTION. This\nis provided in case an external routine for computation\nrequires you to use array, and you want to avoid the copy\nfor performance reason.\n\n@param coll the collection\n@return the array or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public byte[] getFileContent() throws IOException { if (data != null) { return data; } if (tempFile != null) { return FileUtil.readBytes(tempFile); } return null; }\n\n    ### Response:", "ground_truth": "Returns the content of file upload item.", "predict": " Get the content of the file as a byte array. If the data is already available, return it. If there is a temporary file, read the content of the file and return it. Otherwise, return null."}, {"ID": 846, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getAttributes() { // skips the header int u = header + 8 + readUnsignedShort(header + 6) * 2; // skips fields and methods for (int i = readUnsignedShort(u); i > 0; --i) { for (int j = readUnsignedShort(u + 8); j > 0; --j) { u += 6 + readInt(u + 12); } u += 8; } u += 2; for (int i = readUnsignedShort(u); i > 0; --i) { for (int j = readUnsignedShort(u + 8); j > 0; --j) { u += 6 + readInt(u + 12); } u += 8; } // the attribute_info structure starts just after the methods return u + 2; }\n\n    ### Response: Returns the start index of the attribute_info structure of this class.\n\n@return the start index of the attribute_info structure of this class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) { // Find attributOffset of the 'bootstrap_methods' array. byte[] inputBytes = classReader.b; int currentAttributeOffset = classReader.getFirstAttributeOffset(); for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer); if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6); break; } currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2); } if (bootstrapMethodCount > 0) { // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array. int bootstrapMethodsOffset = currentAttributeOffset + 8; int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2; bootstrapMethods = new ByteVector(bootstrapMethodsLength); bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength); // Add each bootstrap method in the symbol table entries. int currentOffset = bootstrapMethodsOffset; for (int i = 0; i < bootstrapMethodCount; i++) { int offset = currentOffset - bootstrapMethodsOffset; int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int numBootstrapArguments = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode(); while (numBootstrapArguments-- > 0) { int bootstrapArgument = classReader.readUnsignedShort(currentOffset); currentOffset += 2; hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode(); } add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF)); } } }\n\n    ### Response:", "ground_truth": "Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\nthe SymbolTable.\n\n@param classReader the ClassReader whose bootstrap methods must be copied to initialize the\nSymbolTable.\n@param charBuffer a buffer used to read strings in the constant pool.", "predict": " Copies the bootstrap_methods attribute from the given ClassReader to the symbol table of this class.\n\n@param classReader the ClassReader from which to copy the bootstrap_methods attribute\n@param charBuffer a buffer to use for reading strings from the constant pool\n@throws IOException if an I/O error occurs while reading the attribute data"}, {"ID": 847, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String shortName(String className) { int startPos = className.lastIndexOf('.'); if (startPos == -1) { return className; } return className.substring(startPos + 1); }\n\n    ### Response: Trim off package to return the simple class name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int setMajorVersionAndClassName(final int majorVersion, final String className) { this.majorVersion = majorVersion; this.className = className; return addConstantClass(className).index; }\n\n    ### Response:", "ground_truth": "Sets the major version and the name of the class to which this symbol table belongs. Also adds\nthe class name to the constant pool.\n\n@param majorVersion a major ClassFile version number.\n@param className an internal class name.\n@return the constant pool index of a new or already existing Symbol with the given class name.", "predict": "Sets the major version and class name of the constant pool and returns the index of the new entry."}, {"ID": 848, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void put(final TypePath typePath, final ByteVector output) { if (typePath == null) { output.putByte(0); } else { int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1; output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length); } }\n\n    ### Response: Puts the type_path JVMS structure corresponding to the given TypePath into the given\nByteVector.\n\n@param typePath a TypePath instance, or null for empty paths.\n@param output where the type path must be put..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putConstantPool(final ByteVector output) { output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length); }\n\n    ### Response:", "ground_truth": "Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\nconstant_pool_count value.\n\n@param output where the JVMS ClassFile's constant_pool array must be put.", "predict": " Puts the constant pool of this class into the given ByteVector.\n\n@param output where the constant pool must be put."}, {"ID": 849, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void put(final TypePath typePath, final ByteVector output) { if (typePath == null) { output.putByte(0); } else { int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1; output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length); } }\n\n    ### Response: Puts the type_path JVMS structure corresponding to the given TypePath into the given\nByteVector.\n\n@param typePath a TypePath instance, or null for empty paths.\n@param output where the type path must be put..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putBootstrapMethods(final ByteVector output) { if (bootstrapMethods != null) { output .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)) .putInt(bootstrapMethods.length + 2) .putShort(bootstrapMethodCount) .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length); } }\n\n    ### Response:", "ground_truth": "Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n6 attribute header bytes and the num_bootstrap_methods value.\n\n@param output where the JVMS BootstrapMethods attribute must be put.", "predict": " Puts the bootstrap_methods JVMS structure corresponding to the given BootstrapMethods into the given\nByteVector.\n\n@param output where the bootstrap methods must be put."}, {"ID": 850, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onVisitFieldInsn(int opcode, String owner, String name, String descriptor) { super.visitFieldInsn(opcode, owner, name, descriptor); }\n\n    ### Response: Visits a field instruction.\n\n@param opcode     The visited opcode.\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantFieldref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a field name.\n@param descriptor a field descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a field reference constant to the constant pool.\n\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor.\n@return           The index of the added constant."}, {"ID": 851, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onVisitFieldInsn(int opcode, String owner, String name, String descriptor) { super.visitFieldInsn(opcode, owner, name, descriptor); }\n\n    ### Response: Visits a field instruction.\n\n@param opcode     The visited opcode.\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\nsymbol table. Does nothing if the constant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a method name.\n@param descriptor a method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a new method reference constant to the constant pool.\n\n@param owner      The class of the method's owner.\n@param name       The name of the method.\n@param descriptor The descriptor of the method.\n@param isInterface Whether the method is an interface method.\n@return The index of the new method reference constant in the constant pool."}, {"ID": 852, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Entry addConstantMemberReference( final int tag, final String owner, final String name, final String descriptor) { int hashCode = hash(tag, owner, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122( tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor)); return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\nthe constant pool of this symbol table. Does nothing if the constant pool already contains a\nsimilar item.\n\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a constant member reference in the constant pool of this symbol table. Does nothing if the constant pool already contains a similar constant member reference.\n\n@param tag the type of the constant pool entry.\n@param owner the internal name of the class that owns the field or method this entry represents.\n@param name the name of the field or method this entry represents.\n@param descriptor the descriptor of the field or method this entry represents.\n@return the index of a new or already existing constant member reference Symbol with the given tag, owner, name, and descriptor."}, {"ID": 853, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantMemberReference( final int index, final int tag, final String owner, final String name, final String descriptor) { add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\nto the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a new CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_Fieldref_info, or CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_METHODREF_TAG}, {@link Symbol#CONSTANT_INTERFACEMETHODREF_TAG}, {@link Symbol#CONSTANT_FIELDREF_TAG}, or {@link Symbol#CONSTANT_NAMEANDTYPE_TAG}.\n@param owner the internal name of the class that owns the field or method.\n@param name the field or method name.\n@param descriptor the field or method descriptor."}, {"ID": 854, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } constantPool.putByte(tag).putInt(value); return put(new Entry(constantPoolCount++, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.\n@return a constant pool constant with the given tag and primitive values.", "predict": " Adds a constant integer or float to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar constant.\n\n@param tag the tag of the constant, either {@link Symbol#CONSTANT_Integer} or {@link Symbol#CONSTANT_Float}.\n@param value the value of the constant.\n@return the Symbol object representing the constant."}, {"ID": 855, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.", "predict": " Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float."}, {"ID": 856, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantLongOrDouble(final int tag, final long value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } int index = constantPoolCount; constantPool.putByte(tag).putLong(value); constantPoolCount += 2; return put(new Entry(index, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.\n@return a constant pool constant with the given tag and primitive values.", "predict": " Adds a constant long or double to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar constant.\n\n@param tag the tag of the constant, either {@link Symbol#LONG_TAG} or {@link Symbol#DOUBLE_TAG}.\n@param value the value of the constant.\n@return the Symbol object representing the constant."}, {"ID": 857, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantLong(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Double_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.", "predict": " Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double."}, {"ID": 858, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addConstantNameAndType(final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; int hashCode = hash(tag, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry.index; } entry = entry.next; } constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor)); return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index; }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a constant name and type in the constant pool of this symbol table. Does nothing if the constant pool already contains a similar constant name and type.\n\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return the index of a new or already existing constant name and type Symbol with the given name and descriptor."}, {"ID": 859, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param name the name of the field or method described by this Symbol.\n@param descriptor the descriptor of the field or method described by this Symbol."}, {"ID": 860, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addConstantUtf8(final String value) { int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value); return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index; }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param value a string.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a UTF8 constant to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar UTF8 constant.\n\n@param value a string value.\n@return the index of a new or already existing UTF8 constant with the given value."}, {"ID": 861, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantUtf8(final int index, final String value) { add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param value a string.", "predict": " Adds a new CONSTANT_Utf8_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param value the string value of the new Symbol."}, {"ID": 862, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantMethodHandle( final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; // Note that we don't need to include isInterface in the hash computation, because it is // redundant with owner (we can't have the same owner with different isInterface values). int hashCode = hash(tag, owner, name, descriptor, referenceKind); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } if (referenceKind <= Opcodes.H_PUTSTATIC) { constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index); } else { constantPool.put112( tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index); } return put( new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\nthe constant pool already contains a similar item.\n\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_MethodHandle_info entry to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar entry.\n\n@param referenceKind the kind of reference, either REF_getField, REF_getStatic, REF_putField, REF_putStatic, REF_invokeVirtual, REF_invokeStatic, REF_invokeSpecial, or REF_newInvokeSpecial.\n@param owner the internal name of the class that owns the field or method.\n@param name the name of the field or method.\n@param descriptor the descriptor of the field or method.\n@param isInterface true if the owner class is an interface.\n@return the Symbol object representing the newly added CONSTANT_MethodHandle_info entry."}, {"ID": 863, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantMethodHandle( final int index, final int referenceKind, final String owner, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; int hashCode = hash(tag, owner, name, descriptor, referenceKind); add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param referenceKind one of {@link Symbol#REF_getField}, {@link Symbol#REF_getStatic}, {@link Symbol#REF_putField}, or {@link Symbol#REF_putStatic}.\n@param owner the internal name of the class that owns the field or method.\n@param name the name of the field or method.\n@param descriptor the descriptor of the field or method."}, {"ID": 864, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <V> String toJson(final DataTypeDescriptor<V> descriptor, final V arg) { String s = format.write(arg, descriptor, false); TypeEnum type = descriptor.getType(); if (type == TypeEnum.STRING || type == TypeEnum.ENUM || type == TypeEnum.DATETIME) { // Remove the quotes. s = s.substring(1, s.length() - 1); } return s; }\n\n    ### Response: Serializes an argument to JSON, strips the quotes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\nbootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\npool already contains a similar item.\n\n@param name a method name.\n@param descriptor a field descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a dynamic constant to the constant pool."}, {"ID": 865, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <V> String toJson(final DataTypeDescriptor<V> descriptor, final V arg) { String s = format.write(arg, descriptor, false); TypeEnum type = descriptor.getType(); if (type == TypeEnum.STRING || type == TypeEnum.ENUM || type == TypeEnum.DATETIME) { // Remove the quotes. s = s.substring(1, s.length() - 1); } return s; }\n\n    ### Response: Serializes an argument to JSON, strips the quotes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantInvokeDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\nrelated bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a method name.\n@param descriptor a method descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a dynamic constant to the constant pool with the given name, descriptor, bootstrap method handle, and bootstrap method arguments."}, {"ID": 866, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantDynamicOrInvokeDynamicReference( final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor)); return put( new Entry( constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\ntable. Does nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a new or existing CONSTANT_Dynamic or CONSTANT_InvokeDynamic reference to the constant pool.\n\n@param tag the tag of the constant pool entry, either CONSTANT_Dynamic or CONSTANT_InvokeDynamic.\n@param name the name of the method or field being referred to.\n@param descriptor the descriptor of the method or field being referred to.\n@param bootstrapMethodIndex the index of the bootstrap method in the bootstrapMethods array of the class.\n@return the Symbol representing the new or existing CONSTANT_Dynamic or CONSTANT_InvokeDynamic reference."}, {"ID": 867, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantDynamicOrInvokeDynamicReference( final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\nsymbol table.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param index the constant pool index of the new Symbol.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.", "predict": " Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param index the constant pool index of the new Symbol.\n@param name the name of the method or field being referred to.\n@param descriptor the descriptor of the method or field being referred to.\n@param bootstrapMethodIndex the index of the bootstrap method in the bootstrapMethods array of the class this symbol table belongs to."}, {"ID": 868, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantUtf8Reference(final int tag, final String value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) { return entry; } entry = entry.next; } constantPool.put12(tag, addConstantUtf8(value)); return put(new Entry(constantPoolCount++, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\nnothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a constant UTF-8 reference to the constant pool of this symbol table. Does nothing if the constant pool already contains a similar UTF-8 reference.\n\n@param tag the tag of the constant pool entry to be added.\n@param value the UTF-8 string value of the constant pool entry to be added.\n@return the Symbol object representing the added constant pool entry."}, {"ID": 869, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantInteger(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.", "predict": " Adds a new CONSTANT_Utf8_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag always {@link Symbol#CONSTANT_UTF8_TAG}.\n@param value the string value of the new Symbol."}, {"ID": 870, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (n *IpfsNode) Bootstrap(cfg BootstrapConfig) error { // TODO what should return value be when in offlineMode? if n.Routing == nil { return nil } if n.Bootstrapper != nil { n.Bootstrapper.Close() // stop previous bootstrap process. } // if the caller did not specify a bootstrap peer function, get the // freshest bootstrap peers from config. this responds to live changes. if cfg.BootstrapPeers == nil { cfg.BootstrapPeers = func() []pstore.PeerInfo { ps, err := n.loadBootstrapPeers() if err != nil { log.Warning(\"failed to parse bootstrap peers from config\") return nil } return ps } } var err error n.Bootstrapper, err = Bootstrap(n, cfg) return err }\n\n    ### Response: // Bootstrap will set and call the IpfsNodes bootstrap function..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addBootstrapMethod( final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { ByteVector bootstrapMethodsAttribute = bootstrapMethods; if (bootstrapMethodsAttribute == null) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector(); } // The bootstrap method arguments can be Constant_Dynamic values, which reference other // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified // while adding the given bootstrap method to it, in the rest of this method. for (Object bootstrapMethodArgument : bootstrapMethodArguments) { addConstant(bootstrapMethodArgument); } // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to // compare it with existing ones, and will be reverted below if there is already a similar // bootstrap method. int bootstrapMethodOffset = bootstrapMethodsAttribute.length; bootstrapMethodsAttribute.putShort( addConstantMethodHandle( bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()) .index); int numBootstrapArguments = bootstrapMethodArguments.length; bootstrapMethodsAttribute.putShort(numBootstrapArguments); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index); } // Compute the length and the hash code of the bootstrap method. int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset; int hashCode = bootstrapMethodHandle.hashCode(); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { hashCode ^= bootstrapMethodArgument.hashCode(); } hashCode &= 0x7FFFFFFF; // Add the bootstrap method to the symbol table or revert the above changes. return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode); }\n\n    ### Response:", "ground_truth": "Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\nthe BootstrapMethods already contains a similar bootstrap method.\n\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " // Adds a bootstrap method to the BootstrapMethods attribute of the class. The bootstrap method is represented by a method handle and its arguments. The method handle is added to the constant pool and the BootstrapMethods attribute is updated accordingly. If there is already a similar bootstrap method, it is not added again. The method returns a symbol that represents the bootstrap method."}, {"ID": 871, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addType(final String value) { int hashCode = hash(Symbol.TYPE_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode)); }\n\n    ### Response: Adds a type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar type.\n\n@param value an internal class name.\n@return the index of a new or already existing type Symbol with the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info; } entry = entry.next; } String type1 = typeTable[typeTableIndex1].value; String type2 = typeTable[typeTableIndex2].value; int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2)); put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex; return commonSuperTypeIndex; }\n\n    ### Response:", "ground_truth": "Adds a merged type in the type table of this symbol table. Does nothing if the type table\nalready contains a similar type.\n\n@param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\ncorresponding to the common super class of the given types.", "predict": " Adds a merged type in the type table of this symbol table. Does nothing if the type table already\ncontains a similar merged type.\n\n@param typeTableIndex1 the index of the first type to merge.\n@param typeTableIndex2 the index of the second type to merge.\n@return the index of a new or already existing merged type Symbol with the given type indices."}, {"ID": 872, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String quoteNameIfNecessary(String name) { int len = name.length(); for (int i = 0; i < len; i++) { char c = name.charAt(i); if (! ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ') || (c >= '0' && c <= '9'))) { return '\"' + quoteName(name) + '\"'; } } return name; }\n\n    ### Response: Returns the name, conservatively quoting it if there are any\ncharacters that are likely to cause trouble outside of a\nquoted string, or returning it literally if it seems safe..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int hash(final String name) { int h = 0; for (int i = name.length() - 1; i >= 0; i--) { char c = name.charAt(i); if (!caseSensitive) { if (c >= 'A' && c <= 'Z') { c += 32; } } h = 31 * h + c; } if (h > 0) { return h; } if (h == Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return -h; }\n\n    ### Response:", "ground_truth": "Calculates hash value of the input string.", "predict": " Computes a hash code for the given string, taking into account the case sensitivity of the hash table. If the hash code is positive, it is returned as is. If it is negative, the absolute value of the hash code is returned. If the hash code is zero, a special value is returned to avoid collisions with other values."}, {"ID": 873, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EntryBuffer clear() { for (int i = 0; i < buffer.length; i++) { buffer[i] = null; } return this; }\n\n    ### Response: Clears the buffer and resets the index to the given index.\n\n@return The entry buffer..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpMultiMap<V> clear() { for (int i = 0; i < entries.length; i++) { entries[i] = null; } head.before = head.after = head; return this; }\n\n    ### Response:", "ground_truth": "Clears the map.", "predict": "Clears the multi-map and resets the head and tail pointers to the same node.\n\n@return The multi-map."}, {"ID": 874, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getIndex(CharSequence name) { if (length() == 0 || name == null) { return -1; } int h = AsciiString.hashCode(name); int i = index(h); for (HeaderEntry e = headerFields[i]; e != null; e = e.next) { if (e.hash == h && equalsConstantTime(name, e.name) != 0) { return getIndex(e.index); } } return -1; }\n\n    ### Response: Returns the lowest index value for the header field name in the dynamic table. Returns -1 if\nthe header field name is not in the dynamic table..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<V> getAll(final String name) { LinkedList<V> values = new LinkedList<>(); int h = hash(name); int i = index(h); MapEntry<V> e = entries[i]; while (e != null) { if (e.hash == h && eq(name, e.key)) { values.addFirst(e.getValue()); } e = e.next; } return values; }\n\n    ### Response:", "ground_truth": "Returns all values associated with the name.", "predict": " Returns a list of all the values associated with the specified header field name in the dynamic table. The list is ordered in the order in which the values were added to the table. If the header field name is not in the dynamic table, an empty list is returned."}, {"ID": 875, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<Entry<K, V>> iterator() { return new Iterator<Entry<K, V>>() { private final Entry<K, V>[] tab = KeyMap.this.table; private Entry<K, V> nextEntry; private int nextPos = 0; @Override public boolean hasNext() { if (nextEntry != null) { return true; } else { while (nextPos < tab.length) { Entry<K, V> e = tab[nextPos++]; if (e != null) { nextEntry = e; return true; } } return false; } } @Override public Entry<K, V> next() { if (nextEntry != null || hasNext()) { Entry<K, V> e = nextEntry; nextEntry = nextEntry.next; return e; } else { throw new NoSuchElementException(); } } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response: Creates an iterator over the entries of this map.\n\n@return An iterator over the entries of this map..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<Map.Entry<String, V>> iterator() { final MapEntry[] e = {head.after}; return new Iterator<Map.Entry<String, V>>() { @Override public boolean hasNext() { return e[0] != head; } @Override @SuppressWarnings(\"unchecked\") public Map.Entry<String, V> next() { if (!hasNext()) { throw new NoSuchElementException(\"No next() entry in the iteration\"); } MapEntry<V> next = e[0]; e[0] = e[0].after; return next; } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response:", "ground_truth": "Returns iterator of all entries.", "predict": " Creates an iterator over the entries of this map.\n\n@return An iterator over the entries of this map."}, {"ID": 876, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized Collection<T> getAll() { List<T> all = new ArrayList<T>(size); for (T e = head; e != null; e = e.getNext()) { all.add(e); } return all; }\n\n    ### Response: Returns all the elements from this list.\n\n@return all the elements from this list..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Map.Entry<String, V>> entries() { List<Map.Entry<String, V>> all = new LinkedList<>(); MapEntry<V> e = head.after; while (e != head) { all.add(e); e = e.after; } return all; }\n\n    ### Response:", "ground_truth": "Returns all the entries of this map. Case sensitivity does not influence\nthe returned list, it always contains all of the values.", "predict": " Returns a list of all the entries in this map.\n\n@return a list of all the entries in this map."}, {"ID": 877, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = buf.length; int newCapacity = oldCapacity << 1; if (newCapacity - minCapacity < 0) newCapacity = minCapacity; if (newCapacity < 0) { if (minCapacity < 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } buf = copyOf(buf, newCapacity); }\n\n    ### Response: Increases the capacity to ensure that it can hold at least the\nnumber of elements specified by the minimum capacity argument.\n\n@param minCapacity the desired minimum capacity.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void grow(final int minCapacity) { final int oldCapacity = buffer.length; int newCapacity = oldCapacity << 1; if (newCapacity - minCapacity < 0) { // special case, min capacity is larger then a grow newCapacity = minCapacity + 512; } buffer = Arrays.copyOf(buffer, newCapacity); }\n\n    ### Response:", "ground_truth": "Grows the buffer.", "predict": " Increases the capacity to ensure that it can hold at least the\nnumber of elements specified by the minimum capacity argument.\n\n@param minCapacity the desired minimum capacity."}, {"ID": 878, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final static void appendCode(final StringBuilder out, final String in, final int start, final int end) { for (int i = start; i < end; i++) { final char c; switch (c = in.charAt(i)) { case '&': out.append(\"&amp;\"); break; case '<': out.append(\"&lt;\"); break; case '>': out.append(\"&gt;\"); break; default: out.append(c); break; } } }\n\n    ### Response: Appends the given string encoding special HTML characters.\n\n@param out\nThe StringBuilder to write to.\n@param in\nInput String.\n@param start\nInput String starting position.\n@param end\nInput String end position..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public FastCharBuffer append(final CharSequence csq, final int start, final int end) { for (int i = start; i < end; i++) { append(csq.charAt(i)); } return this; }\n\n    ### Response:", "ground_truth": "Appends character sequence to buffer.", "predict": "Appends the specified character sequence to this buffer.\n\n@param csq\nThe character sequence to be appended.\n@param start\nThe start index, inclusive.\n@param end\nThe end index, exclusive.\n@return This buffer."}, {"ID": 879, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(String desc, boolean visible) { AnnotationInfoVisitor av = visitAnnotation(getInfo(), desc, visible); annotationInfos.add(av.getAnnotationInfo()); return av; }\n\n    ### Response: See the class comment for details of annotation processing..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4] return new AnnotationVisitorAdapter(destAnn); }\n\n    ### Response:", "ground_truth": "Copies target method annotations.", "predict": "This method overrides the `visitAnnotation` method of the `ClassVisitor` interface. It creates a new `AnnotationVisitorAdapter` object and returns it. The `AnnotationVisitorAdapter` class is a helper class that implements the `AnnotationVisitor` interface and delegates all method calls to the specified `AnnotationVisitor` object. The `AnnotationVisitorAdapter` class is used to provide a default implementation of the `visitAnnotation` method that simply delegates to the specified `AnnotationVisitor` object. The `[A4]` comment indicates that the `AnnotationVisitorAdapter` class is defined elsewhere in the code."}, {"ID": 880, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void calculateGTPointQualities(){ for (int p = 0; p < numPoints; p++) { CMMPoint cmdp = cmmpoints.get(p); if(!cmdp.isNoise()){ cmdp.connectivity = getConnectionValue(cmdp, cmdp.workclass()); cmdp.p.setMeasureValue(\"Connectivity\", cmdp.connectivity); } } }\n\n    ### Response: calculate initial connectivities.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { createFirstChainDelegate_Continue(tmd); for (int p = 0; p < tmd.proxyData.length; p++) { tmd.selectCurrentProxy(p); createProxyMethod(tmd); } }\n\n    ### Response:", "ground_truth": "Finally, builds proxy methods if applied to current method.", "predict": " create the first chain of delegation and continue to create the proxy methods."}, {"ID": 881, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void renderTo(final ByteBuffer out) { final ByteBuffer code = this.code; out.putShort(access).putShort(name).putShort(desc); int attributeCount = 0; if (code.length > 0) { ++attributeCount; } int exceptionCount = exceptions.length; if (exceptionCount > 0) { ++attributeCount; } // if ((access & Constants.ACC_SYNTHETIC) != 0) { // ++attributeCount; // } // if ((access & Constants.ACC_DEPRECATED) != 0) { // ++attributeCount; // } out.putShort(attributeCount); if (code.length > 0) { int size = 12 + code.length + 8 * catchCount; if (localVar != null) { size += 8 + localVar.length; } out.putShort(cw.newUTF8(\"Code\")).putInt(size) .putShort(maxStack).putShort(maxLocals) .putInt(code.length).put(code) .putShort(catchCount); if (catchCount > 0) { out.put(catchTable); } attributeCount = 0; if (localVar != null) { ++attributeCount; } out.putShort(attributeCount); if (localVar != null) { out.putShort(cw.newUTF8(\"LocalVariableTable\")) .putInt(localVar.length + 2).putShort(localVarCount) .put(localVar); } } if (exceptionCount > 0) { out.putShort(cw.newUTF8(\"Exceptions\")).putInt(2 * exceptionCount + 2) .putShort(exceptionCount); for (int i = 0; i < exceptionCount; ++i) { out.putShort(exceptions[i]); } } // if ((access & Constants.ACC_SYNTHETIC) != 0) { // out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0); // } // if ((access & Constants.ACC_DEPRECATED) != 0) { // out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0); // } }\n\n    ### Response: Puts the bytecode of this method in the given byte vector.\n\n@param out the byte vector into which the bytecode of this method must be copied..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createFirstChainDelegate_Start() { // check invalid access flags int access = msign.getAccessFlags(); if (!wd.allowFinalMethods) { if ((access & AsmUtil.ACC_FINAL) != 0) { // detect final throw new ProxettaException( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\"); } } // create proxy methods tmd = new TargetMethodData(msign, aspectList); access &= ~ACC_NATIVE; access &= ~ACC_ABSTRACT; methodVisitor = wd.dest.visitMethod( access, tmd.msign.getMethodName(), tmd.msign.getDescription(), tmd.msign.getAsmMethodSignature(), null); }\n\n    ### Response:", "ground_truth": "Starts creation of first chain delegate.", "predict": " Creates a new method in the destination class, with the same access flags as the source method, and the same name and description as the source method. The method is not implemented, and the methodVisitor is set to the newly created method."}, {"ID": 882, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected function _setDefaults() { $this->setConfigParam('sTheme', 'azure'); if (is_null($this->getConfigParam('sDefaultLang'))) { $this->setConfigParam('sDefaultLang', 0); } if (is_null($this->getConfigParam('blLogChangesInAdmin'))) { $this->setConfigParam('blLogChangesInAdmin', false); } if (is_null($this->getConfigParam('blCheckTemplates'))) { $this->setConfigParam('blCheckTemplates', false); } if (is_null($this->getConfigParam('blAllowArticlesubclass'))) { $this->setConfigParam('blAllowArticlesubclass', false); } if (is_null($this->getConfigParam('iAdminListSize'))) { $this->setConfigParam('iAdminListSize', 9); } // #1173M for EE - not all pic are deleted if (is_null($this->getConfigParam('iPicCount'))) { $this->setConfigParam('iPicCount', 12); } if (is_null($this->getConfigParam('iZoomPicCount'))) { $this->setConfigParam('iZoomPicCount', 4); } if (is_null($this->getConfigParam('iDebug'))) { $this->setConfigParam('iDebug', $this->isProductiveMode() ? 0 : -1); } $this->setConfigParam('sCoreDir', __DIR__ . DIRECTORY_SEPARATOR); }\n\n    ### Response: Set important defaults..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) { methodVisitor.visitCode(); if (tmd.msign.isStatic) { loadStaticMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } else { loadSpecialMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } visitReturn(methodVisitor, tmd.msign, false); methodVisitor.visitMaxs(0, 0); methodVisitor.visitEnd(); }\n\n    ### Response:", "ground_truth": "Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.\nThis method mirrors the target method.", "predict": " Create the first chain delegate for the given method data."}, {"ID": 883, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Path getSkipOutputPath(Configuration conf) { String name = conf.get(OUT_PATH); if(name!=null) { if(\"none\".equals(name)) { return null; } return new Path(name); } Path outPath = FileOutputFormat.getOutputPath(new JobConf(conf)); return outPath==null ? null : new Path(outPath, \"_logs\"+Path.SEPARATOR+\"skip\"); }\n\n    ### Response: Get the directory to which skipped records are written. By default it is\nthe sub directory of the output _logs directory.\nUser can stop writing skipped records by setting the value null.\n\n@param conf the configuration.\n@return path skip output directory. Null is returned if this is not set\nand output directory is also not set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Path parse(final String path) { return path == null ? new Path() : new Path(StringUtil.splitc(path, '.')); }\n\n    ### Response:", "ground_truth": "Parses input dot-separated string that represents a path.", "predict": " Parse a string into a path.\n\n@param path the string to parse.\n@return the parsed path. If the input string is null, an empty path is returned."}, {"ID": 884, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CharSequence getCharsetAsSequence(HttpMessage message) { CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE); if (contentTypeValue != null) { return getCharsetAsSequence(contentTypeValue); } else { return null; } }\n\n    ### Response: Fetch charset from message's Content-Type header as a char sequence.\n\nA lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\nThis is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n\n@return the {@code CharSequence} with charset from message's Content-Type header\nor {@code null} if charset is not presented.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Path push(final CharSequence field) { _push(field); if (altPath != null) { altPath.push(field); } return this; }\n\n    ### Response:", "ground_truth": "Push element to the path.", "predict": " Push a field to the stack.\n\n@param field the field to push\n@return this object\n\nNote: This method is not thread-safe."}, {"ID": 885, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized PortletApplicationDefinition getPortletAppDD( ServletContext servletContext, String name, String contextPath) throws PortletContainerException { PortletApplicationDefinition portletApp = this.portletAppDefinitionCache.get(servletContext); if (portletApp == null) { portletApp = createDefinition(servletContext, name, contextPath); this.portletAppDefinitionCache.put(servletContext, portletApp); } return portletApp; }\n\n    ### Response: Retrieve the Portlet Application Deployment Descriptor for the given servlet context. Create\nit if it does not allready exist.\n\n@param servletContext the servlet context.\n@return The portlet application deployment descriptor.\n@throws PortletContainerException if the descriptor can not be found or parsed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void configureServletContext(final ServletContext servletContext) { servletContext.addListener(jodd.servlet.RequestContextListener.class); if (decoraEnabled) { final FilterRegistration filter = servletContext.addFilter(\"decora\", jodd.decora.DecoraServletFilter.class); filter.addMappingForUrlPatterns(null, true, contextPath); } final FilterRegistration filter = servletContext.addFilter(\"madvoc\", jodd.madvoc.MadvocServletFilter.class); filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath); }\n\n    ### Response:", "ground_truth": "Configures servlet context.", "predict": " Configure the servlet context by adding the required listeners and filters.\n\n@param servletContext the servlet context.\n@param decoraEnabled if decora is enabled.\n@param contextPath the context path.\n@param madvocDispatcherTypes the madvoc dispatcher types."}, {"ID": 886, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProperty(final Object object, final String property, final Class propertyType, final Object value) { Class[] paramTypes = new Class[]{propertyType}; Object[] params = new Object[]{value}; String methodName = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1); ReflectionUtil.invokeMethod(object, methodName, params, paramTypes); }\n\n    ### Response: This method sets a property on an object via reflection.\n\n@param object The object on which the property is to be set.\n@param property The name of the property to be set.\n@param propertyType The type of the property being set.\n@param value The value of the property being set..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object execute() { String methodName = targetMethodName(); Class returnType = returnType(); Object next = pathref.continueWith(this, methodName, returnType); return ProxyTarget.returnValue(next); }\n\n    ### Response:", "ground_truth": "Reads method name and appends it. Creates object for next call and\nreturns that value. If next object is unsupported, it will return null;", "predict": " This method executes the target method on the object referenced by the path reference.\n\n@return The return value of the target method.\n\n    "}, {"ID": 887, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private FieldDescriptor[] getExtentFieldDescriptors(TableAlias extAlias, FieldDescriptor[] fds) { FieldDescriptor[] result = new FieldDescriptor[fds.length]; for (int i = 0; i < fds.length; i++) { result[i] = extAlias.cld.getFieldDescriptorByName(fds[i].getAttributeName()); } return result; }\n\n    ### Response: Get the FieldDescriptors of the extent based on the FieldDescriptors of the parent..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldDescriptor[] getAllFieldDescriptors() { if (allFields == null) { FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()]; int index = 0; for (FieldDescriptor fieldDescriptor : fieldsMap.values()) { allFields[index] = fieldDescriptor; index++; } Arrays.sort(allFields, Comparator.comparing(fd -> fd.getField().getName())); this.allFields = allFields; } return allFields; }\n\n    ### Response:", "ground_truth": "Returns all fields of this collection. Returns empty array\nif no fields exist. Initialized lazy.", "predict": " Get all the FieldDescriptors of the table."}, {"ID": 888, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected PropertyMap getNotionProperties(final SecurityContext securityContext, final Class type, final String storageKey) { final Map<String, PropertyMap> notionPropertyMap = (Map<String, PropertyMap>)securityContext.getAttribute(\"notionProperties\"); if (notionPropertyMap != null) { final Set<PropertyKey> keySet = Services.getInstance().getConfigurationProvider().getPropertySet(type, PropertyView.Public); final PropertyMap notionProperties = notionPropertyMap.get(storageKey); if (notionProperties != null) { for (final Iterator<PropertyKey> it = notionProperties.keySet().iterator(); it.hasNext();) { final PropertyKey key = it.next(); if (!keySet.contains(key)) { it.remove(); } } return notionProperties; } } return null; }\n\n    ### Response: Loads a PropertyMap from the current security context that was previously stored\nthere by one of the Notions that was executed before this relationship creation.\n\n@param securityContext the security context\n@param type the entity type\n@param storageKey the key for which the PropertyMap was stored\n\n@return a PropertyMap or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") @Override protected <T> BeanDefinition<T> createBeanDefinitionForRegistration( final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) { if (proxetta != null) { final Class originalType = type; final ProxettaFactory builder = proxetta.proxy(); builder.setTarget(type); type = builder.define(); return new ProxettaBeanDefinition( name, type, scope, wiringMode, originalType, proxetta.getAspects(new ProxyAspect[0]), consumer); } return super.createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); }\n\n    ### Response:", "ground_truth": "Applies proxetta on bean class before bean registration.", "predict": " Creates a BeanDefinition for the given name, type, scope, wiring mode, and consumer. If Proxetta is enabled, it will create a proxy for the given type using the given aspects.\n\n@param name the name of the bean\n@param type the type of the bean\n@param scope the scope of the bean\n@param wiringMode the wiring mode of the bean\n@param consumer the consumer of the bean\n\n@return a BeanDefinition for the given parameters."}, {"ID": 889, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function setTransactionIsolationLevel($level = null) { $this->_connect(); $sql = null; // Default transaction level in sql server if ($level === null) { $level = SQLSRV_TXN_READ_COMMITTED; } switch ($level) { case SQLSRV_TXN_READ_UNCOMMITTED: $sql = \"READ UNCOMMITTED\"; break; case SQLSRV_TXN_READ_COMMITTED: $sql = \"READ COMMITTED\"; break; case SQLSRV_TXN_REPEATABLE_READ: $sql = \"REPEATABLE READ\"; break; case SQLSRV_TXN_SNAPSHOT: $sql = \"SNAPSHOT\"; break; case SQLSRV_TXN_SERIALIZABLE: $sql = \"SERIALIZABLE\"; break; default: // require_once 'Zend/Db/Adapter/Sqlsrv/Exception.php'; throw new Zend_Db_Adapter_Sqlsrv_Exception(\"Invalid transaction isolation level mode '$level' specified\"); } if (!sqlsrv_query($this->_connection, \"SET TRANSACTION ISOLATION LEVEL $sql;\")) { // require_once 'Zend/Db/Adapter/Sqlsrv/Exception.php'; throw new Zend_Db_Adapter_Sqlsrv_Exception(\"Transaction cannot be changed to '$level'\"); } return true; }\n\n    ### Response: Set the transaction isoltion level.\n\n@param integer|null $level A fetch mode from SQLSRV_TXN_*.\n@return true\n@throws Zend_Db_Adapter_Sqlsrv_Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) { final int isolation; switch (txMode.getIsolationLevel()) { case ISOLATION_DEFAULT: isolation = DbTransactionMode.ISOLATION_DEFAULT; break; case ISOLATION_NONE: isolation = DbTransactionMode.ISOLATION_NONE; break; case ISOLATION_READ_COMMITTED: isolation = DbTransactionMode.ISOLATION_READ_COMMITTED; break; case ISOLATION_READ_UNCOMMITTED: isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED; break; case ISOLATION_REPEATABLE_READ: isolation = DbTransactionMode.ISOLATION_REPEATABLE_READ; break; case ISOLATION_SERIALIZABLE: isolation = DbTransactionMode.ISOLATION_SERIALIZABLE; break; default: throw new IllegalArgumentException(); } return new DbTransactionMode(isolation, txMode.isReadOnly()); }\n\n    ### Response:", "ground_truth": "Converter JTX transaction mode to DB transaction mode.", "predict": " Convert a JTA transaction mode to a database transaction mode.\n\n@param JtxTransactionMode txMode The JTA transaction mode.\n@return DbTransactionMode The database transaction mode.\n@throws IllegalArgumentException If the JTA transaction mode is not recognized."}, {"ID": 890, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getId(final Object entity) { Object unwrapped = entity; if (unwrapped == null) { return null; } unwrapped = ProxyHelper.unwrap(unwrapped); try { final MappedClass mappedClass = getMappedClass(unwrapped.getClass()); if (mappedClass != null) { final Field idField = mappedClass.getIdField(); if (idField != null) { return idField.get(unwrapped); } } } catch (Exception e) { LOG.error(e.getMessage(), e); } return null; }\n\n    ### Response: Gets the ID value for an entity\n\n@param entity the entity to process\n@return the ID value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { try { return getter.invokeGetter(source); } catch (Exception ex) { throw new JsonException(ex); } } return null; }\n\n    ### Response:", "ground_truth": "Reads property using property descriptor.", "predict": " Reads the value of a property from an object\n\n@param source the object to read from\n@param propertyDescriptor the property to read\n@return the value of the property, or null if the property is not readable or does not exist."}, {"ID": 891, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProperties(Object object, Map map) { MetaClass mc = getMetaClass(object); for (Object o : map.entrySet()) { Map.Entry entry = (Map.Entry) o; String key = entry.getKey().toString(); Object value = entry.getValue(); setPropertySafe(object, mc, key, value); } }\n\n    ### Response: Sets the properties on the given object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void putAll(final Map t) { for (Object o : t.entrySet()) { Map.Entry e = (Map.Entry) o; put(e.getKey(), e.getValue()); } }\n\n    ### Response:", "ground_truth": "Copies all of the mappings from the specified map to this one.\nThese mappings replace any mappings that this map had for any of the\nkeys currently in the specified Map.\n\n@param t Mappings to be stored in this map.", "predict": " Adds all of the mappings from the specified map to this map.\n\n    "}, {"ID": 892, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Buffer consumeAlphaNum(final Buffer buffer) throws IOException { final int count = getAlphaNumCount(buffer); if (count == 0) { return null; } return buffer.readBytes(count); }\n\n    ### Response: Consumes a alphanum.\n\n@param buffer\n@return\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; }\n\n    ### Response:", "ground_truth": "Appends other buffer to this one.", "predict": " Appends a buffer to the current buffer.\n\n@param buffer\n@return The current buffer with the appended buffer."}, {"ID": 893, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updateSearchStyle(JTextComponent c, SeaGlassContext context, String prefix) { searchIconWidth = 0; Object o = style.get(context, prefix + \".searchIconWidth\"); if (o != null && o instanceof Integer) { searchIconWidth = (Integer) o; } popupIconWidth = 0; o = style.get(context, prefix + \".popupIconWidth\"); if (o != null && o instanceof Integer) { popupIconWidth = (Integer) o; } cancelIconWidth = 0; o = style.get(context, prefix + \".cancelIconWidth\"); if (o != null && o instanceof Integer) { cancelIconWidth = (Integer) o; } searchLeftInnerMargin = 0; o = style.get(context, prefix + \".searchLeftInnerMargin\"); if (o != null && o instanceof Integer) { searchLeftInnerMargin = (Integer) o; } searchRightInnerMargin = 0; o = style.get(context, prefix + \".searchRightInnerMargin\"); if (o != null && o instanceof Integer) { searchRightInnerMargin = (Integer) o; } placeholderColor = Color.GRAY; o = style.get(context, \"placeholderTextColor\"); if (o != null && o instanceof Color) { placeholderColor = (Color) o; } Border border = c.getBorder(); if (border == null || border instanceof UIResource && !(border instanceof TextFieldBorder)) { c.setBorder(createTextFieldBorder(context)); } if (isSearchField.isInState(c)) { o = c.getClientProperty(\"JTextField.Search.PlaceholderText\"); if (o != null && o instanceof String) { placeholderText = (String) o; } else if (placeholderText != null) { placeholderText = null; } o = c.getClientProperty(\"JTextField.Search.FindAction\"); if (o != null && o instanceof ActionListener) { if (findAction == null) { findAction = (ActionListener) o; } } o = c.getClientProperty(\"JTextField.Search.FindPopup\"); if (o != null && o instanceof JPopupMenu) { if (findPopup == null) { findPopup = (JPopupMenu) o; } } o = c.getClientProperty(\"JTextField.Search.CancelAction\"); if (o != null && o instanceof ActionListener) { if (cancelAction == null) { cancelAction = (ActionListener) o; } } installMouseListeners(); } else { placeholderText = null; if (findAction != null) { findAction = null; } if (findPopup != null) { findPopup = null; } if (cancelAction != null) { cancelAction = null; } uninstallMouseListeners(); } }\n\n    ### Response: Sea Glass code to support the search JTextField.variant.\n\n@param c       the JTextField component.\n@param context the SeaGlassContext.\n@param prefix  the control prefix, e.g. \"TextField\",\n\"FormattedTextField\", or \"PasswordField\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final Writer writer) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] array = fastByteBuffer.toArray(); writer.write(new String(array, StringPool.ISO_8859_1)); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1); } finally { StreamUtil.close(inputStream); } } } }\n\n    ### Response:", "ground_truth": "Writes content to the writer.", "predict": " Writes the contents of this list to the specified writer, using the ISO-8859-1 character encoding.\n\n@param writer the writer to write to.\n@throws IOException if an I/O error occurs."}, {"ID": 894, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updateSearchStyle(JTextComponent c, SeaGlassContext context, String prefix) { searchIconWidth = 0; Object o = style.get(context, prefix + \".searchIconWidth\"); if (o != null && o instanceof Integer) { searchIconWidth = (Integer) o; } popupIconWidth = 0; o = style.get(context, prefix + \".popupIconWidth\"); if (o != null && o instanceof Integer) { popupIconWidth = (Integer) o; } cancelIconWidth = 0; o = style.get(context, prefix + \".cancelIconWidth\"); if (o != null && o instanceof Integer) { cancelIconWidth = (Integer) o; } searchLeftInnerMargin = 0; o = style.get(context, prefix + \".searchLeftInnerMargin\"); if (o != null && o instanceof Integer) { searchLeftInnerMargin = (Integer) o; } searchRightInnerMargin = 0; o = style.get(context, prefix + \".searchRightInnerMargin\"); if (o != null && o instanceof Integer) { searchRightInnerMargin = (Integer) o; } placeholderColor = Color.GRAY; o = style.get(context, \"placeholderTextColor\"); if (o != null && o instanceof Color) { placeholderColor = (Color) o; } Border border = c.getBorder(); if (border == null || border instanceof UIResource && !(border instanceof TextFieldBorder)) { c.setBorder(createTextFieldBorder(context)); } if (isSearchField.isInState(c)) { o = c.getClientProperty(\"JTextField.Search.PlaceholderText\"); if (o != null && o instanceof String) { placeholderText = (String) o; } else if (placeholderText != null) { placeholderText = null; } o = c.getClientProperty(\"JTextField.Search.FindAction\"); if (o != null && o instanceof ActionListener) { if (findAction == null) { findAction = (ActionListener) o; } } o = c.getClientProperty(\"JTextField.Search.FindPopup\"); if (o != null && o instanceof JPopupMenu) { if (findPopup == null) { findPopup = (JPopupMenu) o; } } o = c.getClientProperty(\"JTextField.Search.CancelAction\"); if (o != null && o instanceof ActionListener) { if (cancelAction == null) { cancelAction = (ActionListener) o; } } installMouseListeners(); } else { placeholderText = null; if (findAction != null) { findAction = null; } if (findPopup != null) { findPopup = null; } if (cancelAction != null) { cancelAction = null; } uninstallMouseListeners(); } }\n\n    ### Response: Sea Glass code to support the search JTextField.variant.\n\n@param c       the JTextField component.\n@param context the SeaGlassContext.\n@param prefix  the control prefix, e.g. \"TextField\",\n\"FormattedTextField\", or \"PasswordField\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final OutputStream out) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; out.write(fastByteBuffer.toArray()); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, out); } finally { StreamUtil.close(inputStream); } } } }\n\n    ### Response:", "ground_truth": "Writes content to the output stream.", "predict": " Writes the contents of the list to the specified output stream.\n\n@param out the output stream to write to.\n@throws IOException if an I/O error occurs."}, {"ID": 895, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long copy(InputStream in, OutputStream out, long max) throws IOException { int chunk; long all; long remaining; remaining = max; all = 0; while (remaining > 0) { // cast is save because the buffer.length is an integer chunk = in.read(buffer, 0, (int) Math.min(remaining, buffer.length)); if (chunk < 0) { break; } out.write(buffer, 0, chunk); all += chunk; remaining -= chunk; } out.flush(); return all; }\n\n    ### Response: Copies up to max bytes.\n\n@return number of bytes actually copied.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException { // start final int size = size(); final int callbackSize = progressListener.callbackSize(size); int count = 0; // total count int step = 0; // step is offset in current chunk progressListener.transferred(count); // loop for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] bytes = fastByteBuffer.toArray(); int offset = 0; while (offset < bytes.length) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the bytes array if (offset + chunk > bytes.length) { chunk = bytes.length - offset; } // writes the chunk out.write(bytes, offset, chunk); offset += chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); int remaining = uploadable.getSize(); try { while (remaining > 0) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the remaining size if (chunk > remaining) { chunk = remaining; } // writes remaining chunk StreamUtil.copy(inputStream, out, chunk); remaining -= chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } finally { StreamUtil.close(inputStream); } } } // end if (step != 0) { progressListener.transferred(count); } }\n\n    ### Response:", "ground_truth": "Writes content to the output stream, using progress listener to track the sending progress.", "predict": " Writes the content of the list to the output stream.\n\n@param out the output stream to write to.\n@param progressListener the progress listener to notify of progress.\n\n    "}, {"ID": 896, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isBlank(Object o) { if (o instanceof CharSequence) { CharSequence cs = (CharSequence) o; return cs == null || new StringBuilder(cs.length()).append(cs).toString() .trim().isEmpty(); } if (o instanceof Iterable) { Iterable<?> iter = (Iterable<?>) o; return iter == null || !iter.iterator().hasNext(); } if (o instanceof Iterator) { Iterator<?> iter = (Iterator<?>) o; return iter == null || !iter.hasNext(); } if (o instanceof Map) { Map<?, ?> map = (Map<?, ?>) o; return map == null || map.isEmpty(); } if (o instanceof Boolean) { Boolean bool = (Boolean) o; return bool == null || bool.equals(Boolean.FALSE); } return o == null; }\n\n    ### Response: Checks if an Object is null, blank Iterable, blank Iterator, blank Map,\nblank CharSequence or Boolean.FALSE.\n\n@param o\nany Object\n@return true if given Object is blank, false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getString(final String key) { CharSequence cs = (CharSequence) map.get(key); return cs == null ? null : cs.toString(); }\n\n    ### Response:", "ground_truth": "Returns the string value with the specified key.", "predict": " Retrieves the value of the given key from the map and returns it as a String.\n\n@param key\nthe key to retrieve the value for\n@return the value of the given key as a String, or null if the key is not present or the value is null."}, {"ID": 897, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MetricValue fromNumberValue(Number number) { if (number == null) { return EMPTY; } else if (number instanceof Float || number instanceof Double) { return fromDblValue(number.doubleValue()); } else if (number instanceof Byte || number instanceof Short || number instanceof Integer || number instanceof Long) { return fromIntValue(number.longValue()); } else { throw new IllegalArgumentException(\"Unrecognized number type: \" + number.getClass()); } }\n\n    ### Response: Construct a metric value from a Number implementation.\n@param number A floating point or integral type.\n@return a MetricValue holding the specified number.\n@throws IllegalArgumentException if the derived type of Number is not recognized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Integer getInteger(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Integer) { return (Integer) number; } return number.intValue(); }\n\n    ### Response:", "ground_truth": "returns the integer value with the specified key.", "predict": " Get an integer value from a map.\n@param key The key to look up in the map.\n@return the integer value associated with the key, or null if the key is not present or the value is not an integer."}, {"ID": 898, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MetricValue fromNumberValue(Number number) { if (number == null) { return EMPTY; } else if (number instanceof Float || number instanceof Double) { return fromDblValue(number.doubleValue()); } else if (number instanceof Byte || number instanceof Short || number instanceof Integer || number instanceof Long) { return fromIntValue(number.longValue()); } else { throw new IllegalArgumentException(\"Unrecognized number type: \" + number.getClass()); } }\n\n    ### Response: Construct a metric value from a Number implementation.\n@param number A floating point or integral type.\n@return a MetricValue holding the specified number.\n@throws IllegalArgumentException if the derived type of Number is not recognized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Long getLong(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Long) { return (Long) number; } return number.longValue(); }\n\n    ### Response:", "ground_truth": "Returns the long value with the specified key.", "predict": " Get a long value from the map for the specified key.\n@param key The key to look up in the map.\n@return the long value associated with the key, or null if the key is not present or the value is not a Long."}, {"ID": 899, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MetricValue fromNumberValue(Number number) { if (number == null) { return EMPTY; } else if (number instanceof Float || number instanceof Double) { return fromDblValue(number.doubleValue()); } else if (number instanceof Byte || number instanceof Short || number instanceof Integer || number instanceof Long) { return fromIntValue(number.longValue()); } else { throw new IllegalArgumentException(\"Unrecognized number type: \" + number.getClass()); } }\n\n    ### Response: Construct a metric value from a Number implementation.\n@param number A floating point or integral type.\n@return a MetricValue holding the specified number.\n@throws IllegalArgumentException if the derived type of Number is not recognized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Double getDouble(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Double) { return (Double) number; } return number.doubleValue(); }\n\n    ### Response:", "ground_truth": "Returns the double value with the specified key.", "predict": " Get a Double value from the map for the specified key.\n@param key The key to look up in the map.\n@return the Double value associated with the key, or null if the key is not present or the value is not a Double."}, {"ID": 900, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MetricValue fromNumberValue(Number number) { if (number == null) { return EMPTY; } else if (number instanceof Float || number instanceof Double) { return fromDblValue(number.doubleValue()); } else if (number instanceof Byte || number instanceof Short || number instanceof Integer || number instanceof Long) { return fromIntValue(number.longValue()); } else { throw new IllegalArgumentException(\"Unrecognized number type: \" + number.getClass()); } }\n\n    ### Response: Construct a metric value from a Number implementation.\n@param number A floating point or integral type.\n@return a MetricValue holding the specified number.\n@throws IllegalArgumentException if the derived type of Number is not recognized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Float getFloat(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Float) { return (Float) number; } return number.floatValue(); }\n\n    ### Response:", "ground_truth": "Returns the float value with the specified key.", "predict": " Get a float value from the map for the specified key.\n@param key The key to look up in the map.\n@return the float value associated with the key, or null if the key is not present or the value is not a float."}, {"ID": 901, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T getRequiredValue(String key) { T value = (T) map.get(key); if (value == null) { throw new RequiredParameterException(); } return value; }\n\n    ### Response: Get a required value from a key out of the Job Context\n\n@param key\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T getValue(final String key) { T val = (T) map.get(key); if (val instanceof Map) { return (T) new JsonObject((Map) val); } if (val instanceof List) { return (T) new JsonArray((List) val); } return val; }\n\n    ### Response:", "ground_truth": "Returns the value with the specified key, as an object.", "predict": " Get a value from a key out of the Job Context\n\n@param key\n@return."}, {"ID": 902, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String put(final String key, final String value) { return propsMap.put(key, value); }\n\n    ### Response: Sets the property with the specified key.\n\n@param key\nThe key (may not be {@code null})\n@param value\nThe value (may not be {@code null})\n@return The previous value of the property, or {@code null} if it did not have one.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonObject put(final String key, final String value) { Objects.requireNonNull(key); map.put(key, value); return this; }\n\n    ### Response:", "ground_truth": "Puts a string into the JSON object with the specified key.", "predict": " Adds a property to this object.\n\n@param key\nThe key (may not be {@code null})\n@param value\nThe value (may not be {@code null})\n@return This object\n@throws NullPointerException\nIf the key or value is {@code null}"}, {"ID": 903, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeRemoteResources() { if (reader != null) { try { reader.close(); } catch (final IOException ignore) { } reader = null; } if (writer != null) { writer.close(); writer = null; } if (socketOutstream != null) { try { socketOutstream.close(); } catch (final IOException ignore) { } socketOutstream = null; } if (socketInstream != null) { try { socketInstream.close(); } catch (final IOException ignore) { } socketInstream = null; } if (socket != null) { try { socket.close(); } catch (final IOException ignore) { } socket = null; } }\n\n    ### Response: Safely close remote resources.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useFolder(final String folderName) { closeFolderIfOpened(folder); try { this.folderName = folderName; this.folder = getService().getFolder(folderName); try { folder.open(Folder.READ_WRITE); } catch (final MailException ignore) { folder.open(Folder.READ_ONLY); } } catch (final MessagingException msgexc) { throw new MailException(\"Failed to connect to folder: \" + folderName, msgexc); } }\n\n    ### Response:", "ground_truth": "Opens new folder and closes previously opened folder.\n\n@param folderName Folder to open", "predict": "Open a folder with the given name and store it in the instance variable. If the folder is already opened, close it first. If the folder cannot be opened, throw a MailException with an appropriate error message."}, {"ID": 904, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasBreakpointAtCurrentPosition(VdmThread thread) { try { thread.updateStack(); if (thread.hasStackFrames()) { final IStackFrame top = thread.getTopStackFrame(); if (top instanceof IVdmStackFrame && top.getLineNumber() > 0) { final IVdmStackFrame frame = (IVdmStackFrame) top; if (frame.getSourceURI() != null) { final String location = frame.getSourceURI().getPath(); final IDbgpBreakpoint[] breakpoints = thread.getDbgpSession().getCoreCommands().getBreakpoints(); for (int i = 0; i < breakpoints.length; ++i) { if (breakpoints[i] instanceof IDbgpLineBreakpoint) { final IDbgpLineBreakpoint bp = (IDbgpLineBreakpoint) breakpoints[i]; if (frame.getLineNumber() == bp.getLineNumber()) { try { if (new URI(bp.getFilename()).getPath().equals(location)) { return true; } } catch (URISyntaxException e) { if (VdmDebugPlugin.DEBUG) { e.printStackTrace(); } } } } } } } } } catch (DebugException e) { if (VdmDebugPlugin.DEBUG) { e.printStackTrace(); } } catch (DbgpException e) { if (VdmDebugPlugin.DEBUG) { e.printStackTrace(); } } return false; }\n\n    ### Response: Tests if the specified thread has breakpoint at the same line\n\n@param thread\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    ReceivedEmail[] receiveMessages( final EmailFilter filter, final Flags flagsToSet, final Flags flagsToUnset, final boolean envelope, final Consumer<Message[]> processedMessageConsumer) { useAndOpenFolderIfNotSet(); final Message[] messages; try { if (filter == null) { messages = folder.getMessages(); } else { messages = folder.search(filter.getSearchTerm()); } if (messages.length == 0) { return ReceivedEmail.EMPTY_ARRAY; } if (envelope) { final FetchProfile fetchProfile = new FetchProfile(); fetchProfile.add(FetchProfile.Item.ENVELOPE); fetchProfile.add(FetchProfile.Item.FLAGS); folder.fetch(messages, fetchProfile); } // process messages final ReceivedEmail[] emails = new ReceivedEmail[messages.length]; for (int i = 0; i < messages.length; i++) { final Message msg = messages[i]; // we need to parse message BEFORE flags are set! emails[i] = new ReceivedEmail(msg, envelope, attachmentStorage); if (!EmailUtil.isEmptyFlags(flagsToSet)) { emails[i].flags(flagsToSet); msg.setFlags(flagsToSet, true); } if (!EmailUtil.isEmptyFlags(flagsToUnset)) { emails[i].flags().remove(flagsToUnset); msg.setFlags(flagsToUnset, false); } if (EmailUtil.isEmptyFlags(flagsToSet) && !emails[i].isSeen()) { msg.setFlag(Flags.Flag.SEEN, false); } } if (processedMessageConsumer != null) { processedMessageConsumer.accept(messages); } // if messages were marked to be deleted, we need to expunge the folder if (!EmailUtil.isEmptyFlags(flagsToSet)) { if (flagsToSet.contains(Flags.Flag.DELETED)) { folder.expunge(); } } return emails; } catch (final MessagingException msgexc) { throw new MailException(\"Failed to fetch messages\", msgexc); } }\n\n    ### Response:", "ground_truth": "The main email receiving method.", "predict": " Retrieves messages from the current folder that match the specified filter and sets the specified flags on them.\n\n@param filter the filter to use to retrieve messages, or null to retrieve all messages\n@param flagsToSet the flags to set on the messages\n@param flagsToUnset the flags to unset on the messages\n@param envelope whether to fetch the message envelope\n@param processedMessageConsumer an optional consumer that will be called with the array of processed messages\n@return an array of received emails\n\n    "}, {"ID": 905, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void onFlushBatch(Map<String, BulkWriteOperation> bulkWriteOperationMap) { if (!bulkWriteOperationMap.isEmpty()) { for (BulkWriteOperation builder : bulkWriteOperationMap.values()) { try { builder.execute(getWriteConcern()); } catch (BulkWriteException bwex) { log.error(\"Batch insertion is not performed due to error in write command. Caused By: \", bwex); throw new KunderaException( \"Batch insertion is not performed due to error in write command. Caused By: \", bwex); } catch (MongoException mex) { log.error(\"Batch insertion is not performed. Caused By: \", mex); throw new KunderaException(\"Batch insertion is not performed. Caused By: \", mex); } } } }\n\n    ### Response: On flush batch.\n\n@param bulkWriteOperationMap\nthe bulk write operation map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateEmailFlags(final ReceivedEmail receivedEmail) { useAndOpenFolderIfNotSet(); try { folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true); } catch (MessagingException mex) { throw new MailException(\"Failed to fetch messages\", mex); } }\n\n    ### Response:", "ground_truth": "Updates the email flags on the server.", "predict": " Update email flags.\n\n@param receivedEmail\nthe received email."}, {"ID": 906, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void run() { Folder folder = this.getInboxFolder(); if (folder != null) this.processMail(folder); try { folder.close(true); } catch (MessagingException e) { e.printStackTrace(); } }\n\n    ### Response: Run the code in this process..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void closeFolderIfOpened(final Folder folder) { if (folder != null) { try { folder.close(true); } catch (final MessagingException ignore) { } } }\n\n    ### Response:", "ground_truth": "Closes folder if opened and expunge deleted messages.", "predict": " Close the folder if it is opened."}, {"ID": 907, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JScrollPane getScrollPane(JTextComponent editorPane) { Container p = editorPane.getParent(); while (p != null) { if (p instanceof JScrollPane) { return (JScrollPane) p; } p = p.getParent(); } return null; }\n\n    ### Response: Get the JscrollPane that contains an editor pane, or null if none.\n\n@param editorPane an editor pane\n@return the JscrollPane that contains the editor pane, or null if none.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    DbQueryNamedParameter lookupNamedParameter(final String name) { DbQueryNamedParameter p = rootNP; while (p != null) { if (p.equalsName(name)) { return p; } p = p.next; } return null; }\n\n    ### Response:", "ground_truth": "Lookup for named parameter.", "predict": " Lookup a named parameter in the query.\n\n@param name the name of the parameter to lookup\n@return the named parameter, or null if not found."}, {"ID": 908, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String findSourceFile(StackTraceElement[] target, String defaultValue) { for (StackTraceElement e : target) { if (CLEANER.isIn(e)) { return e.getFileName(); } } return defaultValue; }\n\n    ### Response: Finds the source file of the target stack trace.\nReturns the default value if source file cannot be found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String alias(final String target) { return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV); }\n\n    ### Response:", "ground_truth": "Creates alias.", "predict": " Creates an alias for the given target string.\n\nThe alias is created by concatenating the left chevron, target string, and right chevron."}, {"ID": 909, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void checkViolations(List<String> givenViolations, List<String> expectedValidationViolations) { /* * check if number of expected violations matches the given violations */ Assert.assertEquals( String.format( \"number of expected validation violations (%s) does not match the number of given violations (%s)\", StringUtils.join(expectedValidationViolations, LIST_DELIMITER), StringUtils.join( givenViolations, LIST_DELIMITER)), expectedValidationViolations.size(), givenViolations.size()); /* * check if the set of given violations matches the expected violations */ boolean listsAreCongruent = true; List<String> givenButNotExpected = new ArrayList<String>(); for (String givenViolation : givenViolations) { if (!expectedValidationViolations.contains(givenViolation)) { listsAreCongruent = false; givenButNotExpected.add(givenViolation); } } Assert.assertTrue( String.format( \"the violations (%s) where given but not expected: all given violations (%s), all expected violations (%s)\", StringUtils.join(givenButNotExpected, LIST_DELIMITER), StringUtils.join(givenViolations, LIST_DELIMITER), StringUtils.join(expectedValidationViolations, LIST_DELIMITER)), listsAreCongruent); }\n\n    ### Response: Helper method doing the checking work.\n\n@param givenViolations\n@param expectedValidationViolations.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean validateAction(final String... profiles) { prepareValidator(); vtor.useProfiles(profiles); vtor.validate(this); vtor.resetProfiles(); List<Violation> violations = vtor.getViolations(); return violations == null; }\n\n    ### Response:", "ground_truth": "Validates action. Profiles are reset after the invocation.\n@return true if validation is successful, otherwise returns false", "predict": " Helper method for validating an action with the given profiles.\n\n@param profiles\n@return true if the action is valid, false otherwise."}, {"ID": 910, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void doGroupStart(String group, String name, Object args, String parent) { checkOpen(); JsonObject message = createMessage(args) .putString(\"group\", group) .putString(\"name\", name) .putString(\"parent\", parent) .putString(\"action\", \"startGroup\"); if (open && !paused) { if (log.isDebugEnabled()) { if (parent != null) { log.debug(String.format(\"%s - Group start: Group[name=%s, group=%s, parent=%s, args=%s]\", this, name, group, parent, args)); } else { log.debug(String.format(\"%s - Group start: Group[name=%s, group=%s, args=%s]\", this, name, group, args)); } } eventBus.send(inAddress, message); } checkFull(); }\n\n    ### Response: Sends a group start message..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addViolation(final String name, final Object invalidValue) { prepareValidator(); vtor.addViolation(new Violation(name, this, invalidValue)); }\n\n    ### Response:", "ground_truth": "Adds action violation.", "predict": " Adds a violation to the validator."}, {"ID": 911, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setMimeType(com.google.api.ads.admanager.axis.v201805.MimeType mimeType) { this.mimeType = mimeType; }\n\n    ### Response: Sets the mimeType value for this VideoMetadata.\n\n@param mimeType   * The mime type of the asset. This attribute is required..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RawData as(final String mimeOrExtension) { if (mimeOrExtension.contains(StringPool.SLASH)) { this.mimeType = mimeOrExtension; } else { this.mimeType = MimeTypes.getMimeType(mimeOrExtension); } return this; }\n\n    ### Response:", "ground_truth": "Defines mime type by providing real mime type or just extension!", "predict": " Sets the mimeType value for this RawData object based on the given mimeOrExtension parameter.\n\n@param mimeOrExtension   * The mime type or extension of the asset. This attribute is required. If the parameter contains a slash (/) character, it is assumed to be a mime type, otherwise it is assumed to be an extension and the corresponding mime type is looked up using the MimeTypes class."}, {"ID": 912, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RawData escapeRegex(Object o) { if (null == o) return RawData.NULL; if (o instanceof RawData) return (RawData) o; String s = o.toString(); return new RawData(s.replaceAll(\"([\\\\/\\\\*\\\\{\\\\}\\\\<\\\\>\\\\-\\\\\\\\\\\\!])\", \"\\\\\\\\$1\")); }\n\n    ### Response: Escape for regular expression\n\n@param o\n@return Regex escaped data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RawData downloadableAs(final String downloadFileName) { this.downloadFileName = downloadFileName; this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName)); return this; }\n\n    ### Response:", "ground_truth": "Defines download file name and mime type from the name extension.", "predict": " Set downloadable file name and MIME type\n\n@param downloadFileName\n@return This object with downloadable file name and MIME type set."}, {"ID": 913, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public KdTree.Node findNeighbor(P target) { if( tree.root == null ) return null; this.target = target; this.closest = null; this.bestDistanceSq = maxDistanceSq; stepClosest(tree.root); return closest; }\n\n    ### Response: Finds the node which is closest to 'target'\n\n@param target A point\n@return Closest node or null if none is within the minimum distance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T setTarget(final InputStream target) { assertTargetIsNotDefined(); targetInputStream = target; targetClass = null; targetClassName = null; return _this(); }\n\n    ### Response:", "ground_truth": "Defines class input stream as a target.", "predict": " Sets the input stream to be used as the target for deserialization.\n\n@param target The input stream to be used as the target for deserialization.\n@return This object."}, {"ID": 914, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JavaClass lookupClass(String className) throws ClassNotFoundException { if (classesThatCantBeFound.contains(className)) { throw new ClassNotFoundException(\"Error while looking for class \" + className + \": class not found\"); } String resourceName = className.replace('.', '/') + \".class\"; InputStream in = null; boolean parsedClass = false; try { in = getInputStreamForResource(resourceName); if (in == null) { classesThatCantBeFound.add(className); throw new ClassNotFoundException(\"Error while looking for class \" + className + \": class not found\"); } ClassParser classParser = new ClassParser(in, resourceName); JavaClass javaClass = classParser.parse(); parsedClass = true; return javaClass; } catch (IOException e) { classesThatCantBeFound.add(className); throw new ClassNotFoundException(\"IOException while looking for class \" + className, e); } finally { if (in != null && !parsedClass) { try { in.close(); } catch (IOException ignore) { // Ignore } } } }\n\n    ### Response: Look up a class from the classpath.\n\n@param className\nname of class to look up\n@return the JavaClass object for the class\n@throws ClassNotFoundException\nif the class couldn't be found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T setTarget(final String targetName) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(targetName); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + targetName); } targetClassName = targetName; targetClass = null; } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to get stream class name: \" + targetName, ioex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines class name as a target.\nClass will not be loaded by classloader!", "predict": " Set the target class for the proxy.\n\n@param targetName\nname of the target class\n@return this proxy object\n@throws ProxettaException\nif the target class couldn't be loaded or if the target class is already defined."}, {"ID": 915, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected List getProjectClasspathElements() throws DependencyResolutionRequiredException { Set results = new LinkedHashSet(); Set includes = getClasspathIncludes(); if (includes.contains(CLASSPATH_INCLUDE_ALL) || includes.contains(CLASSPATH_INCLUDE_RUNTIME)) { for (Iterator i = project.getRuntimeClasspathElements().iterator(); i.hasNext();) { String fileName = (String) i.next(); try { results.add(new File(fileName).getCanonicalPath()); } catch (IOException e) { throw new RuntimeException(\"Classpath element not found: \" + fileName, e); } } } if (includes.contains(CLASSPATH_INCLUDE_ALL) || includes.contains(CLASSPATH_INCLUDE_ARTIFACTS)) { for (Iterator i = project.getArtifacts().iterator(); i.hasNext();) { Artifact artifact = (Artifact) i.next(); if (artifact.getType().equals(\"jar\") && artifact.getClassifier() == null) { try { results.add(artifact.getFile().getCanonicalPath()); } catch (IOException e) { throw new RuntimeException(\"Maven artifact file not found: \" + artifact, e); } } } } if (includes.contains(CLASSPATH_INCLUDE_ALL) || includes.contains(CLASSPATH_INCLUDE_PLUGINS)) { for (Iterator i = pluginArtifacts.iterator(); i.hasNext();) { Artifact artifact = (Artifact) i.next(); if (artifact.getType().equals(\"jar\") && artifact.getClassifier() == null) { try { results.add(artifact.getFile().getCanonicalPath()); } catch (IOException e) { throw new RuntimeException(\"Maven plugin-artifact file not found: \" + artifact, e); } } } } return new ArrayList(results); }\n\n    ### Response: Allow the script to work with every JAR dependency of both the project and plugin, including\noptional and provided dependencies. Runtime classpath elements are loaded first, so that\nlegacy behavior is not modified.  Additional elements are added first in the order of\nproject artifacts, then in the order of plugin artifacts..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T setTarget(final Class target) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(target); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + target.getName()); } targetClass = target; targetClassName = target.getName(); } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines class as a target.", "predict": " This method sets the target class for the proxy. It first checks if the target class has already been defined, and throws an exception if it has. It then attempts to load the target class using the classloader of the current thread. If the target class is not found, an exception is thrown. If the target class is found, the input stream for the class is opened and stored in the targetInputStream field. The target class and class name are also stored. Finally, the method returns the proxy object itself."}, {"ID": 916, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void scan() { if (ivScanned) { return; } ivScanned = true; final boolean isTraceOn = TraceComponent.isAnyTracingEnabled(); for (Class<?> klass = ivClass; klass != null && klass != Object.class; klass = klass.getSuperclass()) { if (isTraceOn && (tc.isDebugEnabled() || tcMetaData.isDebugEnabled())) Tr.debug(tc.isDebugEnabled() ? tc : tcMetaData, \"scanning \" + klass.getName()); ivCurrentClassName = klass.getName(); ivCurrentPrivateMethodMetaData = null; ClassLoader classLoader = klass.getClassLoader(); if (classLoader == null) { classLoader = getBootClassLoader(); // d742751 } String resourceName = klass.getName().replace('.', '/') + \".class\"; InputStream input = classLoader.getResourceAsStream(resourceName); if (input == null) // d728537 { if (isTraceOn && (tc.isDebugEnabled() || tcMetaData.isDebugEnabled())) Tr.debug(tc.isDebugEnabled() ? tc : tcMetaData, \"failed to find \" + resourceName + \" from \" + classLoader); ivScanException = new FileNotFoundException(resourceName); return; } try { ClassReader classReader = new ClassReader(input); classReader.accept(this, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES); } // If the class is malformed, ASM might throw any exception. d728537 catch (Throwable t) { FFDCFilter.processException(t, CLASS_NAME + \".scan\", \"168\", this, new Object[] { resourceName, klass, classLoader }); if (isTraceOn && (tc.isDebugEnabled() || tcMetaData.isDebugEnabled())) Tr.debug(tc.isDebugEnabled() ? tc : tcMetaData, \"scan exception\", t); ivScanException = t; return; } finally { try { input.close(); } catch (IOException ex) { if (isTraceOn && tc.isDebugEnabled()) Tr.debug(tc, \"error closing input stream\", ex); } } } }\n\n    ### Response: Scan the bytecode of all classes in the hierarchy unless already done..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void process() { if (targetInputStream == null) { throw new ProxettaException(\"Target missing: \" + targetClassName); } // create class reader final ClassReader classReader; try { classReader = new ClassReader(targetInputStream); } catch (IOException ioex) { throw new ProxettaException(\"Error reading class input stream\", ioex); } // reads information final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader()); classReader.accept(targetClassInfoReader, 0); this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES); // create proxy if (log.isDebugEnabled()) { log.debug(\"processing: \" + classReader.getClassName()); } WorkData wd = process(classReader, targetClassInfoReader); // store important data proxyApplied = wd.proxyApplied; proxyClassName = wd.thisReference.replace('/', '.'); }\n\n    ### Response:", "ground_truth": "Reads the target and creates destination class.", "predict": "Process the bytecode of the target class to create a proxy.\n\n    "}, {"ID": 917, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] readRecord() throws IOException { if (this.debug) { System.err.println(\"ReadRecord: recIdx = \" + this.currRecIdx + \" blkIdx = \" + this.currBlkIdx); } if (this.inStream == null) { throw new IOException(\"reading from an output buffer\"); } if (this.currRecIdx >= this.recsPerBlock) { if (!this.readBlock()) { return null; } } byte[] result = new byte[this.recordSize]; System.arraycopy(this.blockBuffer, (this.currRecIdx * this.recordSize), result, 0, this.recordSize); this.currRecIdx++; return result; }\n\n    ### Response: Read a record from the input stream and return the data.\n\n@return The record data..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] create() { process(); byte[] result = toByteArray(); dumpClassInDebugFolder(result); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } return null; } if (log.isDebugEnabled()) { log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName)); } return result; }\n\n    ### Response:", "ground_truth": "Returns byte array of created class.", "predict": " Create a proxy for the target class.\n\n@return The proxy byte array.\n\n    "}, {"ID": 918, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected Class<?> resolveProxyClass(String[] interfaceNames) throws ClassNotFoundException { ClassLoader proxyClassLoader = classLoader; Class<?>[] interfaces = new Class[interfaceNames.length]; Class<?> nonPublicInterface = null; for (int i = 0; i < interfaceNames.length; i++) { Class<?> intf = loadClass(interfaceNames[i]); if (!Modifier.isPublic(intf.getModifiers())) { ClassLoader classLoader = getClassLoader(intf); if (nonPublicInterface != null) { if (classLoader != proxyClassLoader) { throw new IllegalAccessError(nonPublicInterface + \" and \" + intf + \" both declared non-public in different class loaders\"); } } else { nonPublicInterface = intf; proxyClassLoader = classLoader; } } interfaces[i] = intf; } try { return Proxy.getProxyClass(proxyClassLoader, interfaces); } catch (IllegalArgumentException ex) { throw new ClassNotFoundException(null, ex); } }\n\n    ### Response: Delegates class loading to the specified class loader.\n\n{@inheritDoc}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class define() { process(); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } if (targetClass != null) { return targetClass; } if (targetClassName != null) { try { return ClassLoaderUtil.loadClass(targetClassName); } catch (ClassNotFoundException cnfex) { throw new ProxettaException(cnfex); } } } if (log.isDebugEnabled()) { log.debug(\"Proxy created: \" + StringUtil.toSafeString(targetClassName)); } try { ClassLoader classLoader = proxetta.getClassLoader(); if (classLoader == null) { classLoader = ClassLoaderUtil.getDefaultClassLoader(); if ((classLoader == null) && (targetClass != null)) { classLoader = targetClass.getClassLoader(); } } final byte[] bytes = toByteArray(); dumpClassInDebugFolder(bytes); return DefineClass.of(getProxyClassName(), bytes, classLoader); } catch (Exception ex) { throw new ProxettaException(\"Class definition failed\", ex); } }\n\n    ### Response:", "ground_truth": "Defines class.", "predict": " Defines a new class using the specified class loader.\n\n{@inheritDoc}."}, {"ID": 919, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public IEntityGroupStore newInstance() throws GroupsException { try { return new RDBMEntityGroupStore(); } catch (Exception ex) { log.error(\"ReferenceEntityGroupStoreFactory.newInstance(): \" + ex); throw new GroupsException(ex); } }\n\n    ### Response: Return an instance of the group store implementation.\n\n@return IEntityGroupStore\n@exception GroupsException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object newInstance() { Class type = define(); try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new ProxettaException(\"Invalid Proxetta class\", ex); } }\n\n    ### Response:", "ground_truth": "Creates new instance of created class.\nAssumes default no-arg constructor.", "predict": " Create a new instance of the specified class.\n\n@param type the class to create an instance of\n@return the new instance\n@exception ProxettaException if the class is not a valid Proxetta class or if an error occurs during instantiation."}, {"ID": 920, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init() { String fileName = null; try { fileName = System.getProperty(SYSTEM_PROPERTY); if (fileName == null) { LOG.info(\"User file configuration not provided, reading default file.\"); readConfiguration(getClass().getResourceAsStream(DEFAULT_FILE_NAME)); } else { try { FileInputStream stream = new FileInputStream(fileName); LOG.info(\"Reading configuration file: \" + fileName); readConfiguration(stream); } catch (FileNotFoundException fnfe) { LOG.info(\"Error using user provided configuration file, reading default file.\"); readConfiguration(getClass().getResourceAsStream(DEFAULT_FILE_NAME)); } } } catch (IOException ioe) { LOG.error(\"Error reading provided \" + fileName + \" file\"); } }\n\n    ### Response: Initializes configuration.\n\n@throws IOException\nthrown when initialization error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void dumpClassInDebugFolder(final byte[] bytes) { File debugFolder = proxetta.getDebugFolder(); if (debugFolder == null) { return; } if (!debugFolder.exists() || !debugFolder.isDirectory()) { log.warn(\"Invalid debug folder: \" + debugFolder); } String fileName = proxyClassName; if (fileName == null) { fileName = \"proxetta-\" + System.currentTimeMillis(); } fileName += \".class\"; File file = new File(debugFolder, fileName); try { FileUtil.writeBytes(file, bytes); } catch (IOException ioex) { log.warn(\"Error writing class as \" + file, ioex); } }\n\n    ### Response:", "ground_truth": "Writes created class content to output folder for debugging purposes.", "predict": " Dumps the class in the debug folder.\n\n@param bytes the class bytes to be dumped.\n@throws IOException\nthrown when an error occurs while writing the class bytes to the debug folder."}, {"ID": 921, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Programmatic public List<SessionLogEntry> findByUserAndStrictlyBefore( final String user, final Timestamp from) { return repositoryService.allMatches(new QueryDefault<>(SessionLogEntry.class, \"findByUserAndTimestampStrictlyBefore\", \"user\", user, \"from\", from)); }\n\n    ### Response: region > findByUserAndStrictlyBefore.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T from(final String personalName, final String from) { return from(new EmailAddress(personalName, from)); }\n\n    ### Response:", "ground_truth": "Sets the FROM address by providing personal name and address.\n\n@param personalName personal name.\n@param from         email address.\n@return this\n@see #from(EmailAddress)", "predict": " region > from."}, {"ID": 922, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Comparable<? super T>> Predicates<T> betweenInclusive(T from, T to) { Predicates.failIfDifferentTypes(from, to); return new BetweenInclusive<T>(from, to); }\n\n    ### Response: Creates a predicate which returns true if an object passed to accept method is within the range, inclusive\nof the from and to values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T to(final EmailAddress to) { this.to = ArraysUtil.append(this.to, to); return _this(); }\n\n    ### Response:", "ground_truth": "Appends TO address.\n\n@param to {@link EmailAddress} to add.\n@return this", "predict": " Adds the given email address to the list of recipients of the email.\n\n    "}, {"ID": 923, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SearchSmsResponse searchMessages(Date date, String to) throws IOException, NexmoClientException { return this.searchMessages(new SmsDateSearchRequest(date, to)); }\n\n    ### Response: Search for completed SMS transactions by date and recipient MSISDN.\n\n@param date the date of the SMS message to be looked up\n@param to   the MSISDN number of the SMS recipient\n\n@return SMS data matching the provided criteria.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T to(final String personalName, final String to) { return to(new EmailAddress(personalName, to)); }\n\n    ### Response:", "ground_truth": "Appends TO address by personal name and email address.\n\n@param personalName personal name.\n@param to           email address.\n@return this\n@see #to(EmailAddress)", "predict": " Set the email recipient's personal name and email address.\n\n@param personalName the personal name of the recipient\n@param to           the email address of the recipient\n\n@return the email recipient with the personal name and email address set."}, {"ID": 924, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setReplyTo(String replyTo) { try { this.replyTo = new EndpointReference(new URI(replyTo)); } catch (URISyntaxException e) { throw new CitrusRuntimeException(\"Invalid replyTo uri\", e); } }\n\n    ### Response: Sets the reply to endpoint reference by string.\n@param replyTo the replyTo to set.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T replyTo(final EmailAddress... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends REPLY-TO addresses.\n\n@param replyTo vararg of {@link EmailAddress}es to set.\n@return this", "predict": " Sets the reply to email addresses.\n@param replyTo the replyTo to set.\n\n    "}, {"ID": 925, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<T> sample(final Iterator<T> input) { if (fraction == 0) { return emptyIterable; } return new SampledIterator<T>() { T current = null; @Override public boolean hasNext() { if (current == null) { current = getNextSampledElement(); } return current != null; } @Override public T next() { if (current == null) { return getNextSampledElement(); } else { T result = current; current = null; return result; } } private T getNextSampledElement() { if (fraction <= THRESHOLD) { double rand = random.nextDouble(); double u = Math.max(rand, EPSILON); int gap = (int) (Math.log(u) / Math.log(1 - fraction)); int elementCount = 0; if (input.hasNext()) { T element = input.next(); while (input.hasNext() && elementCount < gap) { element = input.next(); elementCount++; } if (elementCount < gap) { return null; } else { return element; } } else { return null; } } else { while (input.hasNext()) { T element = input.next(); if (random.nextDouble() <= fraction) { return element; } } return null; } } }; }\n\n    ### Response: Sample the input elements, for each input element, take a Bernoulli trail for sampling.\n\n@param input Elements to be sampled.\n@return The sampled result which is lazy computed upon input elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T cc(final EmailAddress... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends CC addresses.\n\n@param ccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " Add the given email addresses to the CC list.\n\n@param ccs Email addresses to be added to the CC list.\n@return This object."}, {"ID": 926, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String encodeString(String string, String encoding) throws RuntimeException { return StringConverter.byteToHex(digestString(string, encoding)); }\n\n    ### Response: Retrieves a hexidecimal character sequence representing the MD5\ndigest of the specified character sequence, using the specified\nencoding to first convert the character sequence into a byte sequence.\nIf the specified encoding is null, then ISO-8859-1 is assumed\n\n@param string the string to encode.\n@param encoding the encoding used to convert the string into the\nbyte sequence to submit for MD5 digest\n@return a hexidecimal character sequence representing the MD5\ndigest of the specified string\n@throws RuntimeException if an MD5 digest\nalgorithm is not available through the\njava.security.MessageDigest spi or the requested\nencoding is not available.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T textMessage(final String text, final String encoding) { return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding)); }\n\n    ### Response:", "ground_truth": "Adds plain message text.\n\n@param text     The text to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Creates a new text message with the specified text and encoding.\n\n@param text the text of the message\n@param encoding the encoding of the message\n@return a new text message with the specified text and encoding\n@throws RuntimeException if the message cannot be created for any reason."}, {"ID": 927, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String encodeString(String string, String encoding) throws RuntimeException { return StringConverter.byteToHex(digestString(string, encoding)); }\n\n    ### Response: Retrieves a hexidecimal character sequence representing the MD5\ndigest of the specified character sequence, using the specified\nencoding to first convert the character sequence into a byte sequence.\nIf the specified encoding is null, then ISO-8859-1 is assumed\n\n@param string the string to encode.\n@param encoding the encoding used to convert the string into the\nbyte sequence to submit for MD5 digest\n@return a hexidecimal character sequence representing the MD5\ndigest of the specified string\n@throws RuntimeException if an MD5 digest\nalgorithm is not available through the\njava.security.MessageDigest spi or the requested\nencoding is not available.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); }\n\n    ### Response:", "ground_truth": "Adds HTML message.\n\n@param html     The HTML to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Creates a new email message with the specified HTML content and encoding, and sends it using the default SMTP settings.\n\n@param html the HTML content of the email message\n@param encoding the encoding of the HTML content\n@return the email message that was sent\n@throws MessagingException if an error occurs while sending the email message"}, {"ID": 928, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final String setHeader(String name, String value) { sortedHeaders = null; return headers.put(name, value); }\n\n    ### Response: Sets a header field value based on its name.\n\n@param name The header name to set\n@param value The header value to set\n@return the previous value or null if the field was previously unset..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T header(final String name, final String value) { headers.put(name, value); return _this(); }\n\n    ### Response:", "ground_truth": "Sets header value.\n\n@param name  The name of the header.\n@param value The value of the header.\n@return this", "predict": " Adds a header field to the request.\n\n@param name The header name to add\n@param value The header value to add\n@return this builder for chaining."}, {"ID": 929, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getSystemProperty(String name, String defaultValue) { String value; value = System.getProperty(name, null); if (value != null) { return value; } value = System.getenv(name); if (value != null) { return value; } return defaultValue; }\n\n    ### Response: Replies the value of the system property.\n\n@param name\n- name of the property.\n@param defaultValue\n- value to reply if the these is no property found\n@return the value, or defaultValue..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String get(final String name, final String defaultValue) { Objects.requireNonNull(name); String value = null; try { if (System.getSecurityManager() == null) { value = System.getProperty(name); } else { value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name)); } } catch (Exception ignore) { } if (value == null) { return defaultValue; } return value; }\n\n    ### Response:", "ground_truth": "Returns system property. If key is not available, returns the default value.", "predict": " Gets the system property value.\n\n@param name\n- name of the property.\n@param defaultValue\n- value to return if the property is not found.\n@return the value of the property, or defaultValue if the property is not found."}, {"ID": 930, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean getSystemProp(final String key, final boolean defaultValue) { String val = System.getProperty(key); if (val == null) val = System.getenv(key); if (val == null) { return defaultValue; } else if (val.isEmpty()) { return true; } else { switch (val.toLowerCase(Locale.ROOT)) { case \"t\": case \"true\": case \"1\": return true; case \"f\": case \"false\": case \"0\": return false; default: throw new IllegalArgumentException(\"Invalid value, expected true/false: \" + val); } } }\n\n    ### Response: an error rather than return false. The default can also be specified..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean getBoolean(final String name, final boolean defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); switch (value) { case \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true; case \"false\": case \"no\" : case \"0\" : case \"off\" : return false; default: return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as boolean.", "predict": "The method `getBoolean` retrieves the value of a system property or environment variable and converts it to a boolean value. If the value is null or empty, the default value is returned. If the value is not recognized as a boolean value, the default value is returned. The method is case-insensitive and supports the common boolean string values of \"true\", \"yes\", \"1\", and \"on\" for true, and \"false\", \"no\", \"0\", and \"off\" for false."}, {"ID": 931, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(CharSequence name, String defaultValue) { String value = get(name); if (value == null) { return defaultValue; } return value; }\n\n    ### Response: Returns the value of a header with the specified name.  If there are\nmore than one values for the specified name, the first value is returned.\n\n@param name The name of the header to search\n@return The first header value or {@code defaultValue} if there is no such header.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getInt(final String name, final int defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Integer.parseInt(value); } catch (NumberFormatException nfex) { return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as an int.", "predict": " Returns the value of a header with the specified name as an integer.  If there are\nmore than one values for the specified name, the first value is returned.\n\n@param name The name of the header to search\n@param defaultValue The default value to return if the header is not found or cannot be parsed as an integer\n@return The first header value as an integer or {@code defaultValue} if there is no such header or the value cannot be parsed as an integer."}, {"ID": 932, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long getLongHeader(String name, long defaultValue) { String firstHeader = getHeader(name); if (firstHeader == null) { return defaultValue; } try { return Long.parseLong(firstHeader.trim()); } catch (NumberFormatException e) { return defaultValue; } }\n\n    ### Response: Get header value as long. If not exists, return defaultValue.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getLong(final String name, final long defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Long.parseLong(value); } catch (NumberFormatException nfex) { return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as a long.", "predict": " Get value as long. If not exists, return defaultValue."}, {"ID": 933, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object get(String name) throws CertificateParsingException { X509AttributeName attr = new X509AttributeName(name); String id = attr.getPrefix(); if (!(id.equalsIgnoreCase(NAME))) { throw new CertificateParsingException(\"Invalid root of \" + \"attribute name, expected [\" + NAME + \"], received \" + \"[\" + id + \"]\"); } attr = new X509AttributeName(attr.getSuffix()); id = attr.getPrefix(); if (id.equalsIgnoreCase(INFO)) { if (info == null) { return null; } if (attr.getSuffix() != null) { try { return info.get(attr.getSuffix()); } catch (IOException e) { throw new CertificateParsingException(e.toString()); } catch (CertificateException e) { throw new CertificateParsingException(e.toString()); } } else { return info; } } else if (id.equalsIgnoreCase(ALG_ID)) { return(algId); } else if (id.equalsIgnoreCase(SIGNATURE)) { if (signature != null) return signature.clone(); else return null; } else if (id.equalsIgnoreCase(SIGNED_CERT)) { if (signedCert != null) return signedCert.clone(); else return null; } else { throw new CertificateParsingException(\"Attribute name not \" + \"recognized or get() not allowed for the same: \" + id); } }\n\n    ### Response: Return the requested attribute from the certificate.\n\nNote that the X509CertInfo is not cloned for performance reasons.\nCallers must ensure that they do not modify it. All other\nattributes are cloned.\n\n@param name the name of the attribute.\n@exception CertificateParsingException on invalid attribute identifier..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    MethodParameter[] getResolvedParameters() { if (paramExtractor == null) { return MethodParameter.EMPTY_ARRAY; } if (!paramExtractor.debugInfoPresent) { throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName); } return paramExtractor.getMethodParameters(); }\n\n    ### Response:", "ground_truth": "Returns method parameters once when method is parsed.\nIf method has no parameters, an empty array is returned.", "predict": "Return the resolved method parameters for the method.\n\n@return the resolved method parameters for the method.\n@exception ParamoException if parameter names are not available for the method."}, {"ID": 934, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int countCurrentDockerSlaves(final DockerSlaveTemplate template) throws Exception { int count = 0; List<Container> containers = getClient().listContainersCmd().exec(); for (Container container : containers) { final Map<String, String> labels = container.getLabels(); if (labels.containsKey(DOCKER_CLOUD_LABEL) && labels.get(DOCKER_CLOUD_LABEL).equals(getDisplayName())) { if (template == null) { // count only total cloud capacity count++; } else if (labels.containsKey(DOCKER_TEMPLATE_LABEL) && labels.get(DOCKER_TEMPLATE_LABEL).equals(template.getId())) { count++; } } } return count; }\n\n    ### Response: Counts the number of instances in Docker currently running that are using the specified template.\n\n@param template If null, then all instances are counted..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) { if ((value == null) && jsonContext.isExcludeNulls()) { return count; } if (key != null) { currentPath.push(key.toString()); } else { currentPath.push(StringPool.NULL); } // check if we should include the field boolean include = true; if (value != null) { // + all collections are not serialized by default include = jsonContext.matchIgnoredPropertyTypes(value.getClass(), false, include); // + path queries: excludes/includes include = jsonContext.matchPathToQueries(include); } // done if (!include) { currentPath.pop(); return count; } if (key == null) { jsonContext.pushName(null, count > 0); } else { jsonContext.pushName(key.toString(), count > 0); } jsonContext.serialize(value); if (jsonContext.isNamePopped()) { count++; } currentPath.pop(); return count; }\n\n    ### Response:", "ground_truth": "Serializes key and a value.", "predict": "Serializes a key-value pair to JSON.\n\n@param jsonContext The JSON context.\n@param currentPath The current path.\n@param key The key.\n@param value The value.\n@param count The count.\n@return The count.\n\n    "}, {"ID": 935, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getInternal( String defaultValue, boolean required) { String value = properties.getProperty(path, defaultValue); if (value != null) { return value; } if (defaultValue == null) { value = getDefaultValue(); if (value != null) { return value; } } if (required) { throw new RuntimeException(\"Property \" + path + \" must be set\"); } return value; }\n\n    ### Response: Retrieves the value of a property, using a given default value, and\noptionally failing if there is no value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String lookupAlias(final String alias) { String value = actionsManager.lookupPathAlias(alias); if (value == null) { ActionRuntime cfg = actionsManager.lookup(alias); if (cfg != null) { value = cfg.getActionPath(); } } return value; }\n\n    ### Response:", "ground_truth": "Lookups value as an alias and, if not found, as a default alias.", "predict": " Looks up the path of an action alias, first in the actions manager's\nconfigured aliases, and then in the actions.xml file. If the alias is not found,\nreturns null."}, {"ID": 936, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String unescapeHtml(final String input) { StringBuilder writer = null; int len = input.length(); int i = 1; int st = 0; while (true) { // look for '&' while (i < len && input.charAt(i-1) != '&') { i++; } if (i >= len) { break; } // found '&', look for ';' int j = i; while (j < len && j < i + MAX_ESCAPE + 1 && input.charAt(j) != ';') { j++; } if (j == len || j < i + MIN_ESCAPE || j == i + MAX_ESCAPE + 1) { i++; continue; } // found escape if (input.charAt(i) == '#') { // numeric escape int k = i + 1; int radix = 10; final char firstChar = input.charAt(k); if (firstChar == 'x' || firstChar == 'X') { k++; radix = 16; } try { int entityValue = Integer.parseInt(input.substring(k, j), radix); if (writer == null) { writer = new StringBuilder(input.length()); } writer.append(input.substring(st, i - 1)); if (entityValue > 0xFFFF) { final char[] chrs = Character.toChars(entityValue); writer.append(chrs[0]); writer.append(chrs[1]); } else if(entityValue == 39) { writer.append('\\''); } else { writer.append(entityValue); } } catch (NumberFormatException ex) { i++; continue; } } else { // named escape CharSequence value = LOOKUP_MAP.get(input.substring(i, j)); if (value == null) { i++; continue; } if (writer == null) { writer = new StringBuilder(input.length()); } writer.append(input.substring(st, i - 1)); writer.append(value); } // skip escape st = j + 1; i = st; } if (writer != null) { writer.append(input.substring(st, len)); return writer.toString(); } return input; }\n\n    ### Response: Unescapes HTML3 chars from a string.\n\nModified version of http://stackoverflow.com/questions/994331/java-how-to-decode-html-character-entities-in-java-like-httputility-htmldecode/24575417#24575417.\n\n@param input\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveAlias(final String value) { final StringBuilder result = new StringBuilder(value.length()); int i = 0; int len = value.length(); while (i < len) { int ndx = value.indexOf('<', i); if (ndx == -1) { // alias markers not found if (i == 0) { // try whole string as an alias String alias = lookupAlias(value); return (alias != null ? alias : value); } else { result.append(value.substring(i)); } break; } // alias marked found result.append(value.substring(i, ndx)); ndx++; int ndx2 = value.indexOf('>', ndx); String aliasName = (ndx2 == -1 ? value.substring(ndx) : value.substring(ndx, ndx2)); // process alias String alias = lookupAlias(aliasName); if (alias != null) { result.append(alias); } else { // alias not found if (log.isWarnEnabled()) { log.warn(\"Alias not found: \" + aliasName); } } i = ndx2 + 1; } // fix prefix '//' - may happened when aliases are used i = 0; len = result.length(); while (i < len) { if (result.charAt(i) != '/') { break; } i++; } if (i > 1) { return result.substring(i - 1, len); } return result.toString(); }\n\n    ### Response:", "ground_truth": "Returns resolved alias result value or passed on, if alias doesn't exist.", "predict": " Resolves alias markers in a string.\n\n@param value\n@return."}, {"ID": 937, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Segment> buildSegments(String str) { List<Segment> segments = new ArrayList<>(); String value = str; int i = value.indexOf(PREFIX); while (i > -1) { //the text before the prefix if (i > 0) { String rawSegment = value.substring(0, i); segments.add(new RawSegment(rawSegment)); } //everything after the prefix value = value.substring(i + PREFIX.length()); int suffixIdx = value.indexOf(SUFFIX); if (suffixIdx > -1) { String expr = value.substring(0, suffixIdx).trim(); segments.add(new PlaceholderSegment(expr)); if (value.length() > suffixIdx) { value = value.substring(suffixIdx + SUFFIX.length()); } } else { throw new ConfigurationException(\"Incomplete placeholder definitions detected: \" + str); } i = value.indexOf(PREFIX); } if (value.length() > 0) { segments.add(new RawSegment(value)); } return segments; }\n\n    ### Response: Split a placeholder value into logic segments.\n\n@param str The placeholder\n@return The list of segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResultPath resolveResultPath(String path, String value) { boolean absolutePath = false; if (value != null) { // [*] resolve alias in value value = resolveAlias(value); // [*] absolute paths if (StringUtil.startsWithChar(value, '/')) { absolutePath = true; int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path = value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { path = value; value = null; } } else { // [*] resolve # in value and path int i = 0; while (i < value.length()) { if (value.charAt(i) != '#') { break; } int dotNdx = MadvocUtil.lastIndexOfSlashDot(path); if (dotNdx != -1) { // dot found path = path.substring(0, dotNdx); } i++; } if (i > 0) { // remove # from value value = value.substring(i); // [*] update path and value if (StringUtil.startsWithChar(value, '.')) { value = value.substring(1); } else { int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path += '.' + value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { if (value.length() > 0) { if (StringUtil.endsWithChar(path, '/')) { path += value; } else { path += '.' + value; } } value = null; } } } } } if (!absolutePath) { if (resultPathPrefix != null) { path = resultPathPrefix + path; } } return new ResultPath(path, value); }\n\n    ### Response:", "ground_truth": "Resolves result path.", "predict": " Resolve a result path and value.\n\n@param path The result path\n@param value The result value\n@return The resolved result path and value.\n\n    "}, {"ID": 938, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static final String uppercaseDrive(String path) { String resultPath = null; if (path != null) { if (path.length() >= 2 && path.charAt(1) == ':') { resultPath = Character.toUpperCase(path.charAt(0)) + path.substring(1); } else { resultPath = path; } } return resultPath; }\n\n    ### Response: Cygwin prefers lowercase drive letters, but other parts of maven use\nuppercase\n\n@param path\n@return String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveResultPathString(final String path, final String value) { final ResultPath resultPath = resolveResultPath(path, value); final String result = resultPath.pathValue(); return resolveAlias(result); }\n\n    ### Response:", "ground_truth": "Resolves result path as a string, when parts are not important\nand when only full string matters. Additional alias resolving\non full path is done.", "predict": " @param path the path to resolve\n@param value the value to resolve\n@return the resolved path value with aliases resolved.\n\n    "}, {"ID": 939, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getMatchingPoint(String pattern, String itemName) { int index = pattern.indexOf('*'); if (index == -1) { return -1; } String firstPart = pattern.substring(0, index); int indexFirstPart = itemName.indexOf(firstPart, 0); if (indexFirstPart == -1) { return -1; } String secondPart = pattern.substring(index + 1); int indexSecondPart = itemName.indexOf(secondPart, index + 1); if (indexSecondPart == -1) { return -1; } return firstPart.length() + secondPart.length(); }\n\n    ### Response: This method returns higher values the better the matching is.\n\n@param pattern  configuration pattern to match with\n@param itemName item name to match\n@return -1 if name does not match at all, zero or positive otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int lastIndexOfSlashDot(final String str) { int slashNdx = str.lastIndexOf('/'); int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); if (dotNdx == -1) { if (slashNdx == -1) { return -1; } slashNdx++; if (slashNdx < str.length() - 1) { dotNdx = slashNdx; } else { dotNdx = -1; } } return dotNdx; }\n\n    ### Response:", "ground_truth": "Locates last dot after the last slash or just slash.", "predict": " This method returns the index of the last dot or slash in the given string.\n\n@param str the string to search for the last dot or slash\n@return the index of the last dot or slash in the string, or -1 if not found."}, {"ID": 940, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char idx( String str, int index ) { int i = calculateIndex( str.length(), index ); char c = str.charAt( i ); return c; }\n\n    ### Response: Gets character at index\n@param str string\n@param index index\n@return char at.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int lastIndexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); slashNdx++; return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); }\n\n    ### Response:", "ground_truth": "Locates last index of dot after the optional last slash.", "predict": " Finds the last index of a dot after a slash\n@param str string\n@return index of last dot after slash or -1 if none found.\n\n    "}, {"ID": 941, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parseIPv4(String name) throws IOException { // Parse name into byte-value address components int slashNdx = name.indexOf('/'); if (slashNdx == -1) { address = InetAddress.getByName(name).getAddress(); } else { address = new byte[8]; // parse mask byte[] mask = InetAddress.getByName (name.substring(slashNdx+1)).getAddress(); // parse base address byte[] host = InetAddress.getByName (name.substring(0, slashNdx)).getAddress(); System.arraycopy(host, 0, address, 0, 4); System.arraycopy(mask, 0, address, 4, 4); } }\n\n    ### Response: Parse an IPv4 address.\n\n@param name IPv4 address with optional mask values\n@throws IOException on error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); if (slashNdx == -1) { slashNdx = 0; } return str.indexOf('.', slashNdx); }\n\n    ### Response:", "ground_truth": "Locates first dot after the last slash.", "predict": " Find the index of the first dot after the last slash in a string.\n\n@param str the string to search\n@return the index of the first dot after the last slash, or -1 if not found."}, {"ID": 942, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripLastCamelWord(String name) { int ndx = name.length() - 1; while (ndx >= 0) { if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) { break; } ndx--; } if (ndx >= 0) { name = name.substring(0, ndx); } return name; }\n\n    ### Response:", "ground_truth": "Removes last CamelWord", "predict": " Strip the last camel-case word from a string.  For example, \"getFooBarBaz\" would return \"getFooBar\".\n\n@param name the string to strip the last camel-case word from\n@return the string with the last camel-case word removed, or the original string if it doesn't contain any camel-case words."}, {"ID": 943, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String defineFileName(SQLiteDatabaseSchema model) { int lastIndex = model.fileName.lastIndexOf(\".\"); String schemaName = model.fileName; if (lastIndex > -1) { schemaName = model.fileName.substring(0, lastIndex); } schemaName = schemaName.toLowerCase() + \"_schema_\" + model.version + \".sql\"; return schemaName; }\n\n    ### Response: Define file name.\n\n@param model\nthe model\n@return the string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) { String schemaName = null; final DbTable dbTable = type.getAnnotation(DbTable.class); if (dbTable != null) { schemaName = dbTable.schema().trim(); } if ((schemaName == null) || (schemaName.length() == 0)) { schemaName = defaultSchemaName; } return schemaName; }\n\n    ### Response:", "ground_truth": "Resolves schema name from a type. Uses default schema name if not specified.", "predict": " Resolve schema name.\n\n@param type\nthe type\n@param defaultSchemaName\nthe default schema name\n@return the string."}, {"ID": 944, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EndpointConfig resolveEndpointConfig() { final String endpointClassName = getEndpointClassName(); // 1) default values //String configName = org.jboss.wsf.spi.metadata.config.EndpointConfig.STANDARD_ENDPOINT_CONFIG; String configName = endpointClassName; String configFile = EndpointConfig.DEFAULT_ENDPOINT_CONFIG_FILE; boolean specifiedConfig = false; // 2) annotation contribution if (isEndpointClassAnnotated(org.jboss.ws.api.annotation.EndpointConfig.class)) { final String cfgName = getEndpointConfigNameFromAnnotation(); if (cfgName != null && !cfgName.isEmpty()) { configName = cfgName; } final String cfgFile = getEndpointConfigFileFromAnnotation(); if (cfgFile != null && !cfgFile.isEmpty()) { configFile = cfgFile; } specifiedConfig = true; } // 3) descriptor overrides (jboss-webservices.xml or web.xml) final String epCfgNameOverride = getEndpointConfigNameOverride(); if (epCfgNameOverride != null && !epCfgNameOverride.isEmpty()) { configName = epCfgNameOverride; specifiedConfig = true; } final String epCfgFileOverride = getEndpointConfigFileOverride(); if (epCfgFileOverride != null && !epCfgFileOverride.isEmpty()) { configFile = epCfgFileOverride; } // 4) setup of configuration if (configFile != EndpointConfig.DEFAULT_ENDPOINT_CONFIG_FILE) { //look for provided endpoint config file try { ConfigRoot configRoot = ConfigMetaDataParser.parse(getConfigFile(configFile)); EndpointConfig config = configRoot.getEndpointConfigByName(configName); if (config == null && !specifiedConfig) { config = configRoot.getEndpointConfigByName(EndpointConfig.STANDARD_ENDPOINT_CONFIG); } if (config != null) { return config; } } catch (IOException e) { throw Messages.MESSAGES.couldNotReadConfigFile(configFile); } } else { EndpointConfig config = null; URL url = getDefaultConfigFile(configFile); if (url != null) { //the default file exists try { ConfigRoot configRoot = ConfigMetaDataParser.parse(url); config = configRoot.getEndpointConfigByName(configName); if (config == null && !specifiedConfig) { config = configRoot.getEndpointConfigByName(EndpointConfig.STANDARD_ENDPOINT_CONFIG); } } catch (IOException e) { throw Messages.MESSAGES.couldNotReadConfigFile(configFile); } } if (config == null) { //use endpoint configs from AS domain ServerConfig sc = getServerConfig(); config = sc.getEndpointConfig(configName); if (config == null && !specifiedConfig) { config = sc.getEndpointConfig(EndpointConfig.STANDARD_ENDPOINT_CONFIG); } if (config == null && specifiedConfig) { throw Messages.MESSAGES.couldNotFindEndpointConfigName(configName); } } if (config != null) { return config; } } return null; }\n\n    ### Response: Returns the EndpointConfig resolved for the current endpoint\n\n@return the EndpointConfig resolved for the current endpoint.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbEntityColumnDescriptor resolveColumnDescriptors( final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) { String columnName = null; boolean isId = false; Class<? extends SqlType> sqlTypeClass = null; // read ID annotation DbId dbId = null; if (property.getFieldDescriptor() != null) { dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class); } if (dbId == null && property.getReadMethodDescriptor() != null) { dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId == null && property.getWriteMethodDescriptor() != null) { dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId != null) { columnName = dbId.value().trim(); sqlTypeClass = dbId.sqlType(); isId = true; } else { DbColumn dbColumn = null; if (property.getFieldDescriptor() != null) { dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getReadMethodDescriptor() != null) { dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getWriteMethodDescriptor() != null) { dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn != null) { columnName = dbColumn.value().trim(); sqlTypeClass = dbColumn.sqlType(); } else { if (isAnnotated) { return null; } } } if (StringUtil.isEmpty(columnName)) { // default annotation value columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName()); } else { if (!columnNamingStrategy.isStrictAnnotationNames()) { columnName = columnNamingStrategy.applyToColumnName(columnName); } } if (sqlTypeClass == SqlType.class) { sqlTypeClass = null; } return new DbEntityColumnDescriptor( dbEntityDescriptor, quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()), property.getName(), property.getType(), isId, sqlTypeClass); }\n\n    ### Response:", "ground_truth": "Resolves column descriptor from property. If property is annotated value will be read\nfrom annotation. If property is not annotated, then property will be ignored\nif entity is annotated. Otherwise, column name is generated from the property name.", "predict": " Resolves the column descriptor for the given property of the given entity.\n\n@param dbEntityDescriptor the entity descriptor\n@param property the property descriptor\n@param isAnnotated indicates if the property is annotated\n@param columnNamingStrategy the column naming strategy to use\n@return the column descriptor for the given property of the given entity, or null if the property is not annotated and not a database ID property."}, {"ID": 945, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Token[] lexx(final String format) { final ArrayList<Token> list = new ArrayList<>(format.length()); boolean inLiteral = false; // Although the buffer is stored in a Token, the Tokens are only // used internally, so cannot be accessed by other threads StringBuilder buffer = null; Token previous = null; for (int i = 0; i < format.length(); i++) { final char ch = format.charAt(i); if (inLiteral && ch != '\\'') { buffer.append(ch); // buffer can't be null if inLiteral is true continue; } Object value = null; switch (ch) { // TODO: Need to handle escaping of ' case '\\'': if (inLiteral) { buffer = null; inLiteral = false; } else { buffer = new StringBuilder(); list.add(new Token(buffer)); inLiteral = true; } break; case 'y': value = y; break; case 'M': value = M; break; case 'd': value = d; break; case 'H': value = H; break; case 'm': value = m; break; case 's': value = s; break; case 'S': value = S; break; default: if (buffer == null) { buffer = new StringBuilder(); list.add(new Token(buffer)); } buffer.append(ch); } if (value != null) { if (previous != null && previous.getValue().equals(value)) { previous.increment(); } else { final Token token = new Token(value); list.add(token); previous = token; } buffer = null; } } if (inLiteral) { // i.e. we have not found the end of the literal throw new IllegalArgumentException(\"Unmatched quote in format: \" + format); } return list.toArray(new Token[list.size()]); }\n\n    ### Response: Parses a classic date format string into Tokens\n\n@param format  the format to parse, not null\n@return array of Token[].\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(final long[] key, final long[] tweak) { final int newNw = key.length; // only create new arrays if the value of N{w} changes (different key size) if (nw != newNw) { nw = newNw; switch (nw) { case WORDS_4: pi = PI4; rpi = RPI4; r = R4; break; case WORDS_8: pi = PI8; rpi = RPI8; r = R8; break; case WORDS_16: pi = PI16; rpi = RPI16; r = R16; break; default: throw new RuntimeException(\"Invalid threefish key\"); } this.k = new long[nw + 1]; // instantiation of these fields here for performance reasons vd = new long[nw]; // v is the intermediate value v{d} at round d ed = new long[nw]; // ed is the value of e{d} at round d fd = new long[nw]; // fd is the value of f{d} at round d ksd = new long[nw]; // ksd is the value of k{s} at round d } System.arraycopy(key, 0, this.k, 0, key.length); long knw = EXTENDED_KEY_SCHEDULE_CONST; for (int i = 0; i < nw; i++) { knw ^= this.k[i]; } this.k[nw] = knw; // set tweak values t[0] = tweak[0]; t[1] = tweak[1]; t[2] = t[0] ^ t[1]; }\n\n    ### Response:", "ground_truth": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "predict": " Initializes the Threefish cipher with the given key and tweak values.\n\n@param key  the key to use, not null\n@param tweak  the tweak values to use, not null\n@throws RuntimeException  if the key length is not valid (4, 8, or 16 words)\n\n    "}, {"ID": 946, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long generate(long hash, final CharSequence value) { final long m = 0xc6a4a7935bd1e995L; final int r = 47; int strlen = value.length(); int length = 2 * strlen; hash ^= length * m; int len4 = strlen / 4; int offset = 0; for (int i = 0; i < len4; i++) { final int index = i * 4 + offset; long k = (value.charAt(index + 0) | ((long) value.charAt(index + 1) << 16) | ((long) value.charAt(index + 2) << 32) | ((long) value.charAt(index + 3) << 48)); k *= m; k ^= k >>> r; k *= m; hash ^= k; hash *= m; } final int off = offset + (strlen & ~0x3); switch (strlen % 4) { case 3: hash ^= (long) value.charAt(off + 2) << 48; case 2: hash ^= (long) value.charAt(off + 1) << 32; case 1: hash ^= (long) value.charAt(off + 0) << 16; hash *= m; } hash ^= hash >>> r; hash *= m; hash ^= hash >>> r; return hash; }\n\n    ### Response: Calculates hash from a String, using utf-16 encoding.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void mix(final int j, final int d) { y[0] = x[0] + x[1]; final long rotl = r[d % DEPTH_OF_D_IN_R][j]; // java left rotation for a long y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl)); y[1] ^= y[0]; }\n\n    ### Response:", "ground_truth": "Implementation of the MIX function.\n\n@param j the index in the rotation constants\n@param d the round", "predict": " Mixes the state of the hash function.\n\n    "}, {"ID": 947, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setNextValue(final long pValue, final int pLength, final int pMaxSize) { long value = pValue; // Set to max value if pValue cannot be stored on pLength bits. long bitMax = (long) Math.pow(2, Math.min(pLength, pMaxSize)); if (pValue > bitMax) { value = bitMax - 1; } // size to wrote int writeSize = pLength; while (writeSize > 0) { // modulo int mod = currentBitIndex % BYTE_SIZE; byte ret = 0; if (mod == 0 && writeSize <= BYTE_SIZE || pLength < BYTE_SIZE - mod) { // shift left value ret = (byte) (value << BYTE_SIZE - (writeSize + mod)); } else { // shift right long length = Long.toBinaryString(value).length(); ret = (byte) (value >> writeSize - length - (BYTE_SIZE - length - mod)); } byteTab[currentBitIndex / BYTE_SIZE] |= ret; long val = Math.min(writeSize, BYTE_SIZE - mod); writeSize -= val; currentBitIndex += val; } }\n\n    ### Response: Add Value to the current position with the specified size\n\n@param pValue\nvalue to add\n@param pLength\nlength of the value\n@param pMaxSize\nmax size in bits.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void demix(final int j, final int d) { y[1] ^= y[0]; final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack! // right shift x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr); x[0] = y[0] - x[1]; }\n\n    ### Response:", "ground_truth": "Implementation of the un-MIX function.", "predict": " Demixes the current state of the PRNG using the specified index and the depth of the demixing operation.\n\n@param j\nindex of the state to demix\n@param d\ndepth of the demixing operation"}, {"ID": 948, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void accumulateNormals(final RandomElementReader vertices, final Element face) throws IOException { int[] indices = face.getIntList(\"vertex_index\"); for (int i = 0; i < indices.length; i++) { int pre; int post; if (counterClockwise) { pre = (i + indices.length - 1) % indices.length; post = (i + 1) % indices.length; } else { pre = (i + 1) % indices.length; post = (i + indices.length - 1) % indices.length; } Element centerVertex; Element preVertex; Element postVertex; try { centerVertex = vertices.readElement(indices[i]); preVertex = vertices.readElement(indices[pre]); postVertex = vertices.readElement(indices[post]); accumulateNormal(centerVertex, preVertex, postVertex); } catch (IndexOutOfBoundsException e) { // we ignore defects in the normals. } } }\n\n    ### Response: Calculate the face normal, weight by angle and add them to\nthe vertices.\n@param vertices Vertices buffer.\n@param face  Face to process.\n@throws IOException if reading fails..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void keySchedule(final int s) { for (int i = 0; i < nw; i++) { // just put in the main key first ksd[i] = k[(s + i) % (nw + 1)]; // don't add anything for i = 0,...,Nw - 4 if (i == nw - 3) { // second to last ksd[i] += t[s % TWEAK_VALUES]; } else if (i == nw - 2) { // first to last ksd[i] += t[(s + 1) % TWEAK_VALUES]; } else if (i == nw - 1) { // last ksd[i] += s; } } }\n\n    ### Response:", "ground_truth": "Creates the subkeys.\n\n@param s the value of the round devided by 4", "predict": " Generate the key schedule for the given key.\n@param s The key to schedule.\n\n    "}, {"ID": 949, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static SecretKey generateKey(final byte[] key) { return new SecretKey() { private byte[] k; { if (key.length == 16) { k = key; } else { k = new byte[16]; System.arraycopy(key, 0, k, 0, key.length < 16 ? key.length : 16); } } @Override public String getAlgorithm() { return \"AES\"; } @Override public String getFormat() { return \"RAW\"; } @Override public byte[] getEncoded() { return k; } }; }\n\n    ### Response: 16 bytes max,  128-bit encription.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(final String keyMessage, final long tweak1, final long tweak2) { long[] tweak = new long[] {tweak1, tweak2}; byte[] key = new byte[blockSize / Byte.SIZE]; byte[] keyData = StringUtil.getBytes(keyMessage); System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length); init(bytesToLongs(key), tweak); }\n\n    ### Response:", "ground_truth": "Initializes cipher in a simple way.", "predict": " Initializes the cipher with the given key and tweak. The key is converted to a byte array using the StringUtil class, and then padded to the block size using the System.arraycopy method. The tweak is converted to a long array and passed to the init method."}, {"ID": 950, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long[] hash(final String in, final long seed, final long[] hashOut) { if ((in == null) || (in.length() == 0)) { return emptyOrNull(seed, hashOut); } final byte[] byteArr = in.getBytes(UTF_8); return hash(Memory.wrap(byteArr), 0L, byteArr.length, seed, hashOut); }\n\n    ### Response: Returns a 128-bit hash of the input.\n@param in a String\n@param seed A long valued seed.\n@param hashOut A long array of size 2\n@return the hash.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public byte[] encryptBlock(final byte[] content, final int offset) { long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes); long[] encryptedBlock = new long[blockSize / Long.SIZE]; blockEncrypt(contentBlock, encryptedBlock); return longsToBytes(encryptedBlock); }\n\n    ### Response:", "ground_truth": "Encrypts a block.", "predict": " Encrypts a block of data.\n@param content the data to encrypt\n@param offset the offset in the data to start encryption\n@return the encrypted data\n\n    "}, {"ID": 951, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long[] asLongTypeArray(List<Long> input) { long[] result = new long[input.size()]; for (int i = 0; i < result.length; i++) { result[i] = input.get(i); } return result; }\n\n    ### Response: As long type array.\n\n@param input the input\n@return the long[].\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) { long[] result = new long[size >> 3]; int i8 = offset; for (int i = 0; i < result.length; i++) { result[i] = Bits.getLong(ba, i8); i8 += 8; } return result; }\n\n    ### Response:", "ground_truth": "Converts segment of byte array into long array.", "predict": " Converts a byte array to a long array.\n\n@param ba the byte array\n@param offset the offset\n@param size the size\n@return the long[] array."}, {"ID": 952, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String dequote(String str) { char start = str.charAt(0); if ((start == '\\'') || (start == '\\\"')) { // possibly quoted char end = str.charAt(str.length() - 1); if (start == end) { // dequote return str.substring(1, str.length() - 1); } } return str; }\n\n    ### Response: Remove quotes from a string, only if the input string start with and end with the same quote character.\n\n@param str the string to remove surrounding quotes from\n@return the de-quoted string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String removeAnyBounding(final char s, final char e, final String str) { if (str == null || str.length() < 2) { return str; } if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) { return str.substring(1, str.length() - 1); } return str; }\n\n    ### Response:", "ground_truth": "If the string starts and ends with start and end char, remove them,\notherwise return the string as it was passed in.", "predict": " Remove any bounding characters from a string.\n\n@param s the starting character to remove\n@param e the ending character to remove\n@param str the string to remove the bounding characters from\n@return the string with the bounding characters removed."}, {"ID": 953, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getCallMethod(JoinPoint joinPoint) { if (joinPoint != null && joinPoint.getSignature() != null) { Class<?> declaringType = joinPoint.getSignature().getDeclaringType(); String className = (declaringType != null) ? declaringType.getSimpleName() : PRINT_QUESTION; String methodName = joinPoint.getSignature().getName(); return className + PRINT_SEMICOLON + methodName; } return PRINT_EMPTY_METHOD; }\n\n    ### Response: Gets method description string from join point.\n\n@param joinPoint aspect join point\n@return method description string from join point.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String path() { if (methref != null) { final String methodName = methref.ref(); return target.getName() + '#' + methodName; } return path; }\n\n    ### Response:", "ground_truth": "Returns path value.", "predict": " Gets the path of the method.\n\n@return the path of the method."}, {"ID": 954, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadProps(Properties props, File file) throws IOException { FileInputStream fis = null; try { fis = new FileInputStream(file); props.load(fis); } finally { if (null != fis) { fis.close(); } } }\n\n    ### Response: Loads in the properties file\n\n@param props Properties being loaded from the file\n@param file  File declartion that is being used\n@throws java.io.IOException IOException is thrown.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File zlib(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't zlib folder\"); } FileInputStream fis = new FileInputStream(file); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); String zlibFileName = file.getAbsolutePath() + ZLIB_EXT; DeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater); try { StreamUtil.copy(fis, dos); } finally { StreamUtil.close(dos); StreamUtil.close(fis); } return new File(zlibFileName); }\n\n    ### Response:", "ground_truth": "Compresses a file into zlib archive.", "predict": " Compresses the file using zlib algorithm\n\n@param file File to be compressed\n@return Compressed file\n@throws java.io.IOException IOException is thrown."}, {"ID": 955, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadProps(Properties props, File file) throws IOException { FileInputStream fis = null; try { fis = new FileInputStream(file); props.load(fis); } finally { if (null != fis) { fis.close(); } } }\n\n    ### Response: Loads in the properties file\n\n@param props Properties being loaded from the file\n@param file  File declartion that is being used\n@throws java.io.IOException IOException is thrown.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File gzip(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't gzip folder\"); } FileInputStream fis = new FileInputStream(file); String gzipName = file.getAbsolutePath() + GZIP_EXT; GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(gzipName)); try { StreamUtil.copy(fis, gzos); } finally { StreamUtil.close(gzos); StreamUtil.close(fis); } return new File(gzipName); }\n\n    ### Response:", "ground_truth": "Compresses a file into gzip archive.", "predict": " Compresses a file using GZIP compression\n\n@param file File to be compressed\n@return Compressed file\n@throws java.io.IOException IOException is thrown."}, {"ID": 956, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File createFile(String relativePath, InputStream sourceData) throws IOException { final File tempFile = getFile(relativePath); boolean ok = false; try { final FileOutputStream fos = new FileOutputStream(tempFile); try { VFSUtils.copyStream(sourceData, fos); fos.close(); sourceData.close(); ok = true; return tempFile; } finally { VFSUtils.safeClose(fos); } } finally { VFSUtils.safeClose(sourceData); if (!ok) { tempFile.delete(); } } }\n\n    ### Response: Create a file within this temporary directory, prepopulating the file from the given input stream.\n\n@param relativePath the relative path name\n@param sourceData   the source input stream to use\n@return the file\n@throws IOException if the directory was closed at the time of this invocation or an error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File ungzip(final File file) throws IOException { String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath()); File out = new File(outFileName); out.createNewFile(); FileOutputStream fos = new FileOutputStream(out); GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file)); try { StreamUtil.copy(gzis, fos); } finally { StreamUtil.close(fos); StreamUtil.close(gzis); } return out; }\n\n    ### Response:", "ground_truth": "Decompress gzip archive.", "predict": " Unzip the given file and return the resulting file.\n\n@param file the file to unzip\n@return the resulting file\n@throws IOException if an error occurs during the unzipping process."}, {"ID": 957, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> listZipContents(File zipFile, String path) throws IOException { List<String> names = new ArrayList<>(); if(zipFile.isFile()) { ZipFile zip = null; try { zip = new ZipFile(zipFile); Enumeration<? extends ZipEntry> entries = zip.entries(); while (entries.hasMoreElements()) { ZipEntry entry = entries.nextElement(); String name = entry.getName(); if (!entry.isDirectory() && name.startsWith(path)) { names.add(name); } } } finally { close(zip); } } return names; }\n\n    ### Response: Lists the contents of a zip file.\nOnly looks in the supplied path within the zip file.\n\n@since 1.0\n@param zipFile the zip file to use\n@param path the path inside the jar file\n@return the contents of the zip file\n@throws IOException if an I/O error has occurred.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> listZip(final File zipFile) throws IOException { List<String> entries = new ArrayList<>(); ZipFile zip = new ZipFile(zipFile); Enumeration zipEntries = zip.entries(); while (zipEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipEntries.nextElement(); String entryName = entry.getName(); entries.add(entryName); } return Collections.unmodifiableList(entries); }\n\n    ### Response:", "ground_truth": "Lists zip content.", "predict": " Lists the contents of a zip file.\n\n@since 1.0\n@param zipFile the zip file to use\n@return the contents of the zip file\n@throws IOException if an I/O error has occurred."}, {"ID": 958, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addFilePatternsToPackageResourceGuard(final Application application, final String... patterns) { final IPackageResourceGuard packageResourceGuard = application.getResourceSettings() .getPackageResourceGuard(); if (packageResourceGuard instanceof SecurePackageResourceGuard) { final SecurePackageResourceGuard guard = (SecurePackageResourceGuard)packageResourceGuard; for (final String pattern : patterns) { guard.addPattern(pattern); } } }\n\n    ### Response: Adds the given file patterns to package resource guard from the given application.\n\n@param application\nthe application\n@param patterns\nthe patterns.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException { unzip(new File(zipFile), new File(destDir), patterns); }\n\n    ### Response:", "ground_truth": "Extracts zip file content to the target directory.\n@see #unzip(java.io.File, java.io.File, String...)", "predict": " Unzips the given zip file to the given destination directory, only keeping the files that match the given patterns.\n\n@param zipFile\nthe zip file\n@param destDir\nthe destination directory\n@param patterns\nthe patterns.\n\n    "}, {"ID": 959, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException { String[] filenames = dir.list(); if (filenames == null) { if (!dir.exists()) { throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\"); } throw new IOException(\"Given file is not a directory '\" + dir + \"'\"); } if (mustHaveChildren && filenames.length == 0) { throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\"); } for (int i = 0; i < filenames.length; i++) { String filename = filenames[i]; File file = new File(dir, filename); boolean isDir = file.isDirectory(); String path = pathPrefix + file.getName(); // NOSONAR if (isDir) { path += PATH_SEPARATOR; // NOSONAR } // Create a ZIP entry String name = mapper.map(path); if (name != null) { ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file); out.putNextEntry(zipEntry); // Copy the file content if (!isDir) { FileUtils.copy(file, out); } out.closeEntry(); } // Traverse the directory if (isDir) { pack(file, out, mapper, path, false); } } }\n\n    ### Response: Compresses the given directory and all its sub-directories into a ZIP file.\n\n@param dir\nroot directory.\n@param out\nZIP output stream.\n@param mapper\ncall-back for renaming the entries.\n@param pathPrefix\nprefix to be used for the entries.\n@param mustHaveChildren\nif true, but directory to pack doesn't have any files, throw an exception..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException { if (!file.exists()) { throw new FileNotFoundException(file.toString()); } if (path == null) { path = file.getName(); } while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } boolean isDir = file.isDirectory(); if (isDir) { // add folder record if (!StringUtil.endsWithChar(path, '/')) { path += '/'; } } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(file.lastModified()); if (comment != null) { zipEntry.setComment(comment); } if (isDir) { zipEntry.setSize(0); zipEntry.setCrc(0); } zos.putNextEntry(zipEntry); if (!isDir) { InputStream is = new FileInputStream(file); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } } zos.closeEntry(); // continue adding if (recursive && file.isDirectory()) { boolean noRelativePath = StringUtil.isEmpty(path); final File[] children = file.listFiles(); if (children != null && children.length != 0) { for (File child : children) { String childRelativePath = (noRelativePath ? StringPool.EMPTY : path) + child.getName(); addToZip(zos, child, childRelativePath, comment, recursive); } } } }\n\n    ### Response:", "ground_truth": "Adds single entry to ZIP output stream.\n\n@param zos zip output stream\n@param file file or folder to add\n@param path relative path of file entry; if null files name will be used instead\n@param comment optional comment\n@param recursive when set to true content of added folders will be added, too", "predict": " Adds the specified file or directory to the specified ZIP output stream.\n\n@param zos\nthe ZIP output stream to which the file or directory should be added.\n@param file\nthe file or directory to add.\n@param path\nthe path to use for the file or directory in the ZIP archive.\n@param comment\nthe comment to add to the ZIP entry.\n@param recursive\nif true, and the file is a directory, add its children recursively.\n\n    "}, {"ID": 960, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:npathcomplexity\") public static void zipFile(File input, OutputStream output) throws IOException { try (ZipOutputStream zos = new ZipOutputStream(output)) { if (input == null) { return; } final LinkedList<File> candidates = new LinkedList<>(); candidates.add(input); final byte[] buffer = new byte[BUFFER_SIZE]; int len; File file; File relativeFile; String zipFilename; final File rootDirectory = (input.isDirectory()) ? input : input.getParentFile(); while (!candidates.isEmpty()) { file = candidates.removeFirst(); assert file != null; if (file.getAbsoluteFile().equals(rootDirectory.getAbsoluteFile())) { relativeFile = null; } else { relativeFile = makeRelative(file, rootDirectory, false); } if (file.isDirectory()) { if (relativeFile != null) { zipFilename = fromFileStandardToURLStandard(relativeFile) + URL_PATH_SEPARATOR; final ZipEntry zipEntry = new ZipEntry(zipFilename); zos.putNextEntry(zipEntry); zos.closeEntry(); } candidates.addAll(Arrays.asList(file.listFiles())); } else if (relativeFile != null) { try (FileInputStream fis = new FileInputStream(file)) { zipFilename = fromFileStandardToURLStandard(relativeFile); final ZipEntry zipEntry = new ZipEntry(zipFilename); zos.putNextEntry(zipEntry); while ((len = fis.read(buffer)) > 0) { zos.write(buffer, 0, len); } zos.closeEntry(); } } } } }\n\n    ### Response: Create a zip file from the given input file.\nIf the input file is a directory, the content of the directory is zipped.\nIf the input file is a standard file, it is zipped.\n\n@param input the name of the file to compress.\n@param output the name of the ZIP file to create.\n@throws IOException when ziiping is failing.\n@since 6.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException { while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } if (StringUtil.endsWithChar(path, '/')) { path = path.substring(0, path.length() - 1); } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(System.currentTimeMillis()); if (comment != null) { zipEntry.setComment(comment); } zos.putNextEntry(zipEntry); InputStream is = new ByteArrayInputStream(content); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } zos.closeEntry(); }\n\n    ### Response:", "ground_truth": "Adds byte content into the zip as a file.", "predict": " Add the given content to the given ZIP output stream with the given path and comment.\n\n@param zos the ZIP output stream to add the content to.\n@param content the content to add to the ZIP file.\n@param path the path of the content in the ZIP file.\n@param comment the comment to add to the ZIP entry.\n@throws IOException when adding the content to the ZIP file fails.\n@since 6.2."}, {"ID": 961, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasTimestamp(final MessageOrBuilder messageOrBuilder) { try { final FieldDescriptor fieldDescriptor = ProtoBufFieldProcessor.getFieldDescriptor(messageOrBuilder, TIMESTAMP_FIELD_NAME); return messageOrBuilder.hasField(fieldDescriptor); } catch (NotAvailableException ex) { return false; } }\n\n    ### Response: Method return true if the given message contains a timestamp field.\n@param messageOrBuilder the message to analyze\n@return true if the timestamp field is provided, otherwise false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) { final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name); if (fieldDescriptor != null) { if (!fieldDescriptor.matchDeclared(declared)) { return null; } } return fieldDescriptor; }\n\n    ### Response:", "ground_truth": "Returns field descriptor.", "predict": " Method returns the field descriptor for the given field name.\n@param name the name of the field to retrieve\n@param declared true if the field is declared in the current message, false otherwise\n@return the field descriptor for the given field name, or null if it does not exist."}, {"ID": 962, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(String propertyName) { final PropertyDescriptor propertyDescriptor = findPropertyDescriptor(propertyName); if (propertyDescriptor == null) { throw new PropertyNotFoundException(beanClass, propertyName); } return propertyDescriptor; }\n\n    ### Response: Get the property descriptor for the named property. Throws an exception if the property does not exist.\n\n@param propertyName property name\n@return the PropertyDescriptor for the named property\n@throws PropertyNotFoundException if the named property does not exist on the bean\n@see #findPropertyDescriptor(String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) { PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name); if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) { return propertyDescriptor; } return null; }\n\n    ### Response:", "ground_truth": "Returns property descriptor. Declared flag is matched on both read and write\nmethods.", "predict": " Get the property descriptor for the named property, optionally checking for declared properties only.\n\n@param name property name\n@param declared whether to check for declared properties only\n@return the PropertyDescriptor for the named property, or null if not found\n@see #getProperties()"}, {"ID": 963, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResourceBundle getBundle(final String bundleName) { LOG.info(\"Getting bundle: \" + bundleName); return bundles.get(bundleName); }\n\n    ### Response: Returns a single bundle from the bundles map.\n\n@param bundleName\nThe name of the bundle to be retrieved.\n@return returns the specified bundle from the cache.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setRequestBundleName(final ServletRequest request, final String bundleName) { if (log.isDebugEnabled()) { log.debug(\"Bundle name for this request: \" + bundleName); } request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName); }\n\n    ### Response:", "ground_truth": "Sets bundle name for provided servlet request.", "predict": " Sets the bundle name for the current request.\n\n@param request\nThe current request.\n@param bundleName\nThe name of the bundle to be used for this request."}, {"ID": 964, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setLocale(final HttpServletRequest request, final Locale locale) { final HttpSession session = request.getSession(false); if (null == session) { LOGGER.warn(\"Ignores set locale caused by no session\"); return; } session.setAttribute(Keys.LOCALE, locale); LOGGER.log(Level.DEBUG, \"Client[sessionId={0}] sets locale to [{1}]\", new Object[]{session.getId(), locale.toString()}); }\n\n    ### Response: Sets the specified locale into session of the specified request.\n\n\nIf no session of the specified request, do nothing.\n\n\n@param request the specified request\n@param locale  a new locale.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setSessionLocale(final HttpSession session, final String localeCode) { if (log.isDebugEnabled()) { log.debug(\"Locale stored to session: \" + localeCode); } Locale locale = Locale.forLanguageTag(localeCode); session.setAttribute(SESSION_LOCALE_ATTR, locale); }\n\n    ### Response:", "ground_truth": "Saves Locale to HTTP session.", "predict": " Stores the specified locale code into session attribute.\n\n\n@param session the specified session\n@param localeCode the locale code to be stored in session attribute."}, {"ID": 965, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Locale getLocale() { UI currentUI = UI.getCurrent(); Locale locale = currentUI == null ? null : currentUI.getLocale(); if (locale == null) { locale = Locale.getDefault(); } return locale; }\n\n    ### Response: Gets the locale of the current Vaadin UI. If the locale can not be determinted, the default locale\nis returned instead.\n\n@return the current locale, never {@code null}.\n@see com.vaadin.ui.UI#getLocale()\n@see java.util.Locale#getDefault().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Locale getSessionLocale(final HttpSession session) { Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR); return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale; }\n\n    ### Response:", "ground_truth": "Returns current locale from session.\ns", "predict": " Gets the locale stored in the session attribute with the name {@link #SESSION_LOCALE_ATTR}. If the locale is not found, the fallback locale is returned instead.\n\n@param session the HTTP session\n@return the locale stored in the session attribute, or the fallback locale if not found\n@see #SESSION_LOCALE_ATTR\n@see #MESSAGE_RESOLVER"}, {"ID": 966, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parseMultipartParameters(Map<String, List<FileItem>> fileItemListMap, RequestAdapter requestAdapter) { String encoding = requestAdapter.getEncoding(); MultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>(); MultiValueMap<String, FileParameter> fileParameterMap = new LinkedMultiValueMap<>(); for (Map.Entry<String, List<FileItem>> entry : fileItemListMap.entrySet()) { String fieldName = entry.getKey(); List<FileItem> fileItemList = entry.getValue(); if (fileItemList != null && !fileItemList.isEmpty()) { for (FileItem fileItem : fileItemList) { if (fileItem.isFormField()) { String value = getString(fileItem, encoding); parameterMap.add(fieldName, value); } else { String fileName = fileItem.getName(); // Skip file uploads that don't have a file name - meaning that // no file was selected. if (StringUtils.isEmpty(fileName)) { continue; } boolean valid = FilenameUtils.isValidFileExtension(fileName, allowedFileExtensions, deniedFileExtensions); if (!valid) { continue; } MemoryMultipartFileParameter fileParameter = new MemoryMultipartFileParameter(fileItem); fileParameterMap.add(fieldName, fileParameter); if (log.isDebugEnabled()) { log.debug(\"Found multipart file [\" + fileParameter.getFileName() + \"] of size \" + fileParameter.getFileSize() + \" bytes, stored \" + fileParameter.getStorageDescription()); } } } } } if (!parameterMap.isEmpty()) { for (Map.Entry<String, List<String>> entry : parameterMap.entrySet()) { String name = entry.getKey(); List<String> list = entry.getValue(); String[] values = list.toArray(new String[0]); requestAdapter.setParameter(name, values); } } if (!fileParameterMap.isEmpty()) { for (Map.Entry<String, List<FileParameter>> entry : fileParameterMap.entrySet()) { String name = entry.getKey(); List<FileParameter> list = entry.getValue(); FileParameter[] values = list.toArray(new FileParameter[0]); requestAdapter.setFileParameter(name, values); } } }\n\n    ### Response: Parse form fields and file items.\n\n@param fileItemListMap the file item list map\n@param requestAdapter the request adapter.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) { beanName = beanName + '.'; List<String> list = new ArrayList<>(); for (Map.Entry<String, Object> entry : params.entrySet()) { String key = entry.getKey(); if (!key.startsWith(beanName)) { continue; } list.add(key); if (!resolveReferenceParams) { continue; } // resolve all references String value = PropertiesUtil.resolveProperty(params, key); entry.setValue(value); } if (list.isEmpty()) { return StringPool.EMPTY_ARRAY; } else { return list.toArray(new String[0]); } }\n\n    ### Response:", "ground_truth": "Returns an array of param keys that belongs to provided bean.\nOptionally resolves the value of returned parameters.", "predict": " Filter parameters for a given bean name.\n\n@param beanName the bean name\n@param resolveReferenceParams whether to resolve reference parameters\n@return the filtered parameter names\n\n    "}, {"ID": 967, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Service setSupportedServiceProfiles(Iterable<ServiceProfile> profiles) { if (profiles == null) { this.supportedServiceProfiles = null; return this; } Set<ServiceProfile> set = new TreeSet<ServiceProfile>(); for (ServiceProfile profile : profiles) { if (profile != null) { set.add(profile); } } int size = set.size(); if (size == 0) { this.supportedServiceProfiles = null; return this; } ServiceProfile[] array = new ServiceProfile[size]; this.supportedServiceProfiles = set.toArray(array); return this; }\n\n    ### Response: Set the supported service profiles.\n\n@param profiles\nSupported service profiles.\n\n@return\n{@code this} object.\n\n@since 2.12.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropsEntries profile(final String... profiles) { if (profiles == null) { return this; } for (String profile : profiles) { addProfiles(profile); } return this; }\n\n    ### Response:", "ground_truth": "Enables profiles to iterate.", "predict": " Add profiles to the list of profiles.\n\n@param profiles\nProfiles to add.\n\n@return\n{@code this} object."}, {"ID": 968, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static long getLong(final byte[] arr, final long off) throws IOException { final int ioff = (int) off; if (ioff < 0 || ioff > arr.length - 8) { throw new IndexOutOfBoundsException(); } return ((arr[ioff + 7] & 0xffL) << 56) // | ((arr[ioff + 6] & 0xffL) << 48) // | ((arr[ioff + 5] & 0xffL) << 40) // | ((arr[ioff + 4] & 0xffL) << 32) // | ((arr[ioff + 3] & 0xffL) << 24) // | ((arr[ioff + 2] & 0xffL) << 16) // | ((arr[ioff + 1] & 0xffL) << 8) // | (arr[ioff] & 0xffL); }\n\n    ### Response: Get a long from a byte array.\n\n@param arr\nthe byte array\n@param off\nthe offset to start reading from\n@return the long\n@throws IOException\nif an I/O exception occurs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getLongLittleEndian(final byte[] buf, final int offset) { return ((long) buf[offset + 7] << 56) // no mask needed | ((buf[offset + 6] & 0xffL) << 48) | ((buf[offset + 5] & 0xffL) << 40) | ((buf[offset + 4] & 0xffL) << 32) | ((buf[offset + 3] & 0xffL) << 24) | ((buf[offset + 2] & 0xffL) << 16) | ((buf[offset + 1] & 0xffL) << 8) | ((buf[offset] & 0xffL)); // no shift needed }\n\n    ### Response:", "ground_truth": "Gets a long from a byte buffer in little endian byte order.", "predict": " Get a long from a byte array in little-endian order.\n\n@param buf\nthe byte array\n@param offset\nthe offset to start reading from\n@return the long\n\n    "}, {"ID": 969, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void streamToOutput(InputStream inputStream) throws IOException { try { byte[] buffer = new byte[4096]; int bytesRead = -1; while ((bytesRead = inputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, bytesRead); } outputStream.flush(); } finally { inputStream.close(); } }\n\n    ### Response: Utility method to read all the bytes from an InputStream into the outputStream.\n@param inputStream   Stream of bytes to read from.\n@throws IOException  Thrown on errors reading / writing..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException { if (inputStream == null) { throw new IOException(\"Class not found\"); } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE]; int bytesRead; while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) { outputStream.write(data, 0, bytesRead); } outputStream.flush(); return outputStream.toByteArray(); } finally { if (close) { inputStream.close(); } } }\n\n    ### Response:", "ground_truth": "Reads the given input stream and returns its content as a byte array.\n\n@param inputStream an input stream.\n@param close true to close the input stream after reading.\n@return the content of the given input stream.\n@throws IOException if a problem occurs during reading.", "predict": " Utility method to read all the bytes from an InputStream into a byte array.\n@param inputStream   Stream of bytes to read from.\n@param close         Whether to close the input stream after reading.\n@return              The byte array containing all the bytes from the input stream.\n@throws IOException  Thrown on errors reading / writing."}, {"ID": 970, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Label readLabel(int offset, Label[] labels) { // SPRING PATCH: leniently handle offset mismatch if (offset >= labels.length) { return new Label(); } // END OF PATCH if (labels[offset] == null) { labels[offset] = new Label(); } return labels[offset]; }\n\n    ### Response: Returns the label corresponding to the given offset. The default\nimplementation of this method creates a label for the given offset if it\nhas not been already created.\n\n@param offset a bytecode offset in a method.\n@param labels the already created labels, indexed by their offset. If a\nlabel already exists for offset this method must not create a\nnew one. Otherwise it must store the new label in this array.\n@return a non null Label, which must be equal to labels[offset]..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) { if (labels[bytecodeOffset] == null) { labels[bytecodeOffset] = new Label(); } return labels[bytecodeOffset]; }\n\n    ### Response:", "ground_truth": "Returns the label corresponding to the given bytecode offset. The default implementation of\nthis method creates a label for the given offset if it has not been already created.\n\n@param bytecodeOffset a bytecode offset in a method.\n@param labels the already created labels, indexed by their offset. If a label already exists\nfor bytecodeOffset this method must not create a new one. Otherwise it must store the new\nlabel in this array.\n@return a non null Label, which must be equal to labels[bytecodeOffset].", "predict": " Returns the label corresponding to the given bytecode offset. The default implementation of this method creates a label for the given bytecode offset if it has not been already created.\n\n@param bytecodeOffset a bytecode offset in a method.\n@param labels the already created labels, indexed by their bytecode offset. If a label already exists for bytecodeOffset this method must not create a new one. Otherwise it must store the new label in this array.\n@return a non null Label, which must be equal to labels[bytecodeOffset]."}, {"ID": 971, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getPressedPointerIndex(MotionEvent event, int i) { final int count = event.getPointerCount(); final int action = event.getActionMasked(); final int index = event.getActionIndex(); if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) { if (i >= index) { i++; } } return (i < count) ? i : -1; }\n\n    ### Response: Gets the index of the i-th pressed pointer.\nNormally, the index will be equal to i, except in the case when the pointer is released.\n@return index of the specified pointer or -1 if not found (i.e. not enough pointers are down).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getTypeAnnotationBytecodeOffset( final int[] typeAnnotationOffsets, final int typeAnnotationIndex) { if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) { return -1; } return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1); }\n\n    ### Response:", "ground_truth": "Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n-1 if there is no such type_annotation of if it does not have a bytecode offset.\n\n@param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\nRuntime[In]VisibleTypeAnnotations attribute, or null.\n@param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n@return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\nif there is no such type_annotation of if it does not have a bytecode offset.", "predict": " Gets the bytecode offset of the type annotation at the specified index.\n@param typeAnnotationOffsets the array of type annotation bytecode offsets\n@param typeAnnotationIndex the index of the type annotation to retrieve\n@return the bytecode offset of the type annotation or -1 if not found (e.g. invalid index or unexpected bytecode)\n\n    "}, {"ID": 972, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static IterableResult<Extension> search(ExtensionQuery query, Iterable<ExtensionRepository> repositories) throws SearchException { IterableResult<Extension> searchResult = null; int currentOffset = query.getOffset() > 0 ? query.getOffset() : 0; int currentNb = query.getLimit(); // A local index would avoid things like this... for (ExtensionRepository repository : repositories) { try { searchResult = search(repository, query, currentOffset, currentNb, searchResult); if (searchResult != null) { if (currentOffset > 0) { currentOffset = query.getOffset() - searchResult.getTotalHits(); if (currentOffset < 0) { currentOffset = 0; } } if (currentNb > 0) { currentNb = query.getLimit() - searchResult.getSize(); if (currentNb < 0) { currentNb = 0; } } } } catch (SearchException e) { LOGGER.error( \"Failed to search on repository [{}] with query [{}]. \" + \"Ignore and go to next repository.\", repository.getDescriptor().toString(), query, e); } } return searchResult != null ? searchResult : new CollectionIterableResult<>(0, query.getOffset(), Collections.<Extension>emptyList()); }\n\n    ### Response: Search passed repositories based of the provided query.\n\n@param query the query\n@param repositories the repositories\n@return the found extensions descriptors, empty list if nothing could be found\n@throws SearchException error when trying to search provided query\n@since 10.0RC1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int readElementValues( final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) { int currentOffset = annotationOffset; // Read the num_element_value_pairs field (or num_values field for an array_value). int numElementValuePairs = readUnsignedShort(currentOffset); currentOffset += 2; if (named) { // Parse the element_value_pairs array. while (numElementValuePairs-- > 0) { String elementName = readUTF8(currentOffset, charBuffer); currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer); } } else { // Parse the array_value array. while (numElementValuePairs-- > 0) { currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer); } } if (annotationVisitor != null) { annotationVisitor.visitEnd(); } return currentOffset; }\n\n    ### Response:", "ground_truth": "Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\nthem. This method can also be used to read the values of the JVMS 'array_value' field of an\nannotation's 'element_value'.\n\n@param annotationVisitor the visitor that must visit the values.\n@param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\nfield) or of an 'array_value' structure.\n@param named if the annotation values are named or not. This should be true to parse the values\nof a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\nannotation's element_value.\n@param charBuffer the buffer used to read strings in the constant pool.\n@return the end offset of the JVMS 'annotation' or 'array_value' structure.", "predict": " Reads the element values of an annotation or array value.\n\n@param annotationVisitor the visitor to visit the element values\n@param annotationOffset the offset of the annotation or array value\n@param named whether the annotation has named element values or not\n@param charBuffer the buffer to use for reading strings\n@return the offset of the end of the element values\n@since 10.0RC1."}, {"ID": 973, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int newLocal(final Type type) { Object t; switch (type.getSort()) { case Type.BOOLEAN: case Type.CHAR: case Type.BYTE: case Type.SHORT: case Type.INT: t = Opcodes.INTEGER; break; case Type.FLOAT: t = Opcodes.FLOAT; break; case Type.LONG: t = Opcodes.LONG; break; case Type.DOUBLE: t = Opcodes.DOUBLE; break; case Type.ARRAY: t = type.getDescriptor(); break; // case Type.OBJECT: default: t = type.getInternalName(); break; } int local = newLocalMapping(type); setLocalType(local, type); setFrameLocal(local, t); changed = true; return local; }\n\n    ### Response: Creates a new local variable of the given type.\n\n@param type\nthe type of the local variable to be created.\n@return the identifier of the newly created local variable..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int readVerificationTypeInfo( final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) { int currentOffset = verificationTypeInfoOffset; int tag = b[currentOffset++] & 0xFF; switch (tag) { case Frame.ITEM_TOP: frame[index] = Opcodes.TOP; break; case Frame.ITEM_INTEGER: frame[index] = Opcodes.INTEGER; break; case Frame.ITEM_FLOAT: frame[index] = Opcodes.FLOAT; break; case Frame.ITEM_DOUBLE: frame[index] = Opcodes.DOUBLE; break; case Frame.ITEM_LONG: frame[index] = Opcodes.LONG; break; case Frame.ITEM_NULL: frame[index] = Opcodes.NULL; break; case Frame.ITEM_UNINITIALIZED_THIS: frame[index] = Opcodes.UNINITIALIZED_THIS; break; case Frame.ITEM_OBJECT: frame[index] = readClass(currentOffset, charBuffer); currentOffset += 2; break; case Frame.ITEM_UNINITIALIZED: frame[index] = createLabel(readUnsignedShort(currentOffset), labels); currentOffset += 2; break; default: throw new IllegalArgumentException(); } return currentOffset; }\n\n    ### Response:", "ground_truth": "Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\narray.\n\n@param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\nread.\n@param frame the array where the parsed type must be stored.\n@param index the index in 'frame' where the parsed type must be stored.\n@param charBuffer the buffer used to read strings in the constant pool.\n@param labels the labels of the method currently being parsed, indexed by their offset. If the\nparsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\nstored in this array if it does not already exist.\n@return the end offset of the JVMS 'verification_type_info' structure.", "predict": " Reads verification type information from the given byte array and updates the given frame and label arrays accordingly.\n\n@param verificationTypeInfoOffset\nthe offset of the verification type information in the byte array.\n@param frame\nthe frame array to be updated.\n@param index\nthe index of the local variable to be updated in the frame array.\n@param charBuffer\nthe char buffer to be used to read class names.\n@param labels\nthe label array to be updated.\n@return the offset of the next verification type information item in the byte array.\n\n    "}, {"ID": 974, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getAttributes() { // skips the header int u = header + 8 + readUnsignedShort(header + 6) * 2; // skips fields and methods for (int i = readUnsignedShort(u); i > 0; --i) { for (int j = readUnsignedShort(u + 8); j > 0; --j) { u += 6 + readInt(u + 12); } u += 8; } u += 2; for (int i = readUnsignedShort(u); i > 0; --i) { for (int j = readUnsignedShort(u + 8); j > 0; --j) { u += 6 + readInt(u + 12); } u += 8; } // the attribute_info structure starts just after the methods return u + 2; }\n\n    ### Response: Returns the start index of the attribute_info structure of this class.\n\n@return the start index of the attribute_info structure of this class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) { char[] charBuffer = new char[maxStringLength]; int currentAttributeOffset = getFirstAttributeOffset(); int[] currentBootstrapMethodOffsets = null; for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { // Read the attribute_info's attribute_name and attribute_length fields. String attributeName = readUTF8(currentAttributeOffset, charBuffer); int attributeLength = readInt(currentAttributeOffset + 2); currentAttributeOffset += 6; if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { // Read the num_bootstrap_methods field and create an array of this size. currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)]; // Compute and store the offset of each 'bootstrap_methods' array field entry. int currentBootstrapMethodOffset = currentAttributeOffset + 2; for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) { currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset; // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each), // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2). currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2; } return currentBootstrapMethodOffsets; } currentAttributeOffset += attributeLength; } return null; }\n\n    ### Response:", "ground_truth": "Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n\n@param maxStringLength a conservative estimate of the maximum length of the strings contained\nin the constant pool of the class.\n@return the offsets of the bootstrap methods or null.", "predict": " Reads the 'BootstrapMethods' attribute of this class and returns an array of offsets of the 'bootstrap_methods' array field entries.\n\n@param maxStringLength the maximum length of the strings in the constant pool\n@return an array of offsets of the 'bootstrap_methods' array field entries, or null if the attribute is not found or has invalid format."}, {"ID": 975, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object[] getMethods() { Method[] methods = getClassUnderInspection().getMethods(); Constructor[] ctors = getClassUnderInspection().getConstructors(); Object[] result = new Object[methods.length + ctors.length]; int resultIndex = 0; for (; resultIndex < methods.length; resultIndex++) { Method method = methods[resultIndex]; result[resultIndex] = methodInfo(method); } for (int i = 0; i < ctors.length; i++, resultIndex++) { Constructor ctor = ctors[i]; result[resultIndex] = methodInfo(ctor); } return result; }\n\n    ### Response: Get info about usual Java instance and class Methods as well as Constructors.\n\n@return Array of StringArrays that can be indexed with the MEMBER_xxx_IDX constants.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CtorDescriptor[] inspectConstructors() { Class type = classDescriptor.getType(); Constructor[] ctors = type.getDeclaredConstructors(); CtorDescriptor[] allCtors = new CtorDescriptor[ctors.length]; for (int i = 0; i < ctors.length; i++) { Constructor ctor = ctors[i]; CtorDescriptor ctorDescriptor = createCtorDescriptor(ctor); allCtors[i] = ctorDescriptor; if (ctorDescriptor.isDefault()) { defaultCtor = ctorDescriptor; } } return allCtors; }\n\n    ### Response:", "ground_truth": "Inspects all declared constructors of a target type.", "predict": " Get info about all declared Constructors of the class.\n\n@return Array of CtorDescriptor objects representing all declared Constructors of the class."}, {"ID": 976, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Node select_parser(int partnum, String mime, Element instruction) { if (null == instruction) return null; NodeList instructions = instruction.getElementsByTagNameNS(PARSERS_NS, \"parse\"); Node parserNode = null; instructionsLoop: for (int i = 0; i < instructions.getLength(); i++) { Element parse = (Element) instructions.item(i); if (partnum != 0) { String part_i = parse.getAttribute(\"part\"); if (part_i.length() > 0) { int n = Integer.parseInt(part_i); if (n != partnum) { continue; } } } if (mime != null) { String mime_i = parse.getAttribute(\"mime\"); if (mime_i.length() > 0) { String[] mime_parts = mime_i.split(\";\\\\s*\"); if (!mime.startsWith(mime_parts[0])) { continue; } boolean ok = true; for (int j = 1; j < mime_parts.length; j++) { if (mime.indexOf(mime_parts[j]) < 0) { ok = false; break; } } if (!ok) { continue; } } } NodeList children = parse.getChildNodes(); for (int j = 0; j < children.getLength(); j++) { if (children.item(j).getNodeType() == Node.ELEMENT_NODE) { parserNode = children.item(j); break instructionsLoop; } } } return parserNode; }\n\n    ### Response: Selects a parser for a message part based on the part number and MIME\nformat type, if supplied in instructions.\n\n@param partnum\nAn integer indicating the message part number.\n@param mime\nA MIME media type.\n@param instruction\nAn Element representing parser instructions.\n@return A Node containing parser info, or {@code null} if no matching\nparser is found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CtorDescriptor getCtorDescriptor(final Class... args) { ctors: for (CtorDescriptor ctorDescriptor : allCtors) { Class[] arg = ctorDescriptor.getParameters(); if (arg.length != args.length) { continue; } for (int j = 0; j < arg.length; j++) { if (arg[j] != args[j]) { continue ctors; } } return ctorDescriptor; } return null; }\n\n    ### Response:", "ground_truth": "Finds constructor description that matches given argument types.", "predict": " Returns the constructor descriptor for the given argument types.\n\n@param args\nThe argument types for which to find a constructor descriptor.\n@return The constructor descriptor for the given argument types, or\n{@code null} if no matching constructor is found."}, {"ID": 977, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getCachedETag(HttpHost host, String file) { Map<String, Object> cachedETags = readCachedETags(); @SuppressWarnings(\"unchecked\") Map<String, Object> hostMap = (Map<String, Object>)cachedETags.get(host.toURI()); if (hostMap == null) { return null; } @SuppressWarnings(\"unchecked\") Map<String, String> etagMap = (Map<String, String>)hostMap.get(file); if (etagMap == null) { return null; } return etagMap.get(\"ETag\"); }\n\n    ### Response: Get the cached ETag for the given host and file\n@param host the host\n@param file the file\n@return the cached ETag or null if there is no ETag in the cache.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) { return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME); }\n\n    ### Response:", "ground_truth": "", "predict": " Get the request map from the given servlet request.\n@param servletRequest the servlet request\n@return the request map or null if there is no request map in the request."}, {"ID": 978, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, List<StringValue>> getPageParametersMap(final Request request) { final Map<String, List<StringValue>> map = new HashMap<>(); addToParameters(request.getRequestParameters(), map); addToParameters(request.getQueryParameters(), map); addToParameters(request.getPostParameters(), map); return map; }\n\n    ### Response: Gets a map with all parameters. Looks in the query, request and post parameters.\n\n@param request\nthe request\n@return a map with all parameters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) { Map<String, TransientBeanData> map = new HashMap<>(); servletRequest.setAttribute(ATTR_NAME, map); return map; }\n\n    ### Response:", "ground_truth": "Creates instance map and stores it in the request.", "predict": " Creates a map and sets it as an attribute of the request.\n\n@param servletRequest\nthe request\n@return the created map\n\n    "}, {"ID": 979, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long[] asLongTypeArray(List<Long> input) { long[] result = new long[input.size()]; for (int i = 0; i < result.length; i++) { result[i] = input.get(i); } return result; }\n\n    ### Response: As long type array.\n\n@param input the input\n@return the long[].\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected long[] convertArrayToArray(final Object value) { final Class valueComponentType = value.getClass().getComponentType(); final long[] result; if (valueComponentType.isPrimitive()) { result = convertPrimitiveArrayToArray(value, valueComponentType); } else { // convert object array to target array final Object[] array = (Object[]) value; result = new long[array.length]; for (int i = 0; i < array.length; i++) { result[i] = convertType(array[i]); } } return result; }\n\n    ### Response:", "ground_truth": "Converts array value to array.", "predict": " Converts an array to a long array.\n\n@param value the value to convert\n@return the long[] array.\n\n    "}, {"ID": 980, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public InputStream fetch(URL url) throws DownloadFailedException { if (\"file\".equalsIgnoreCase(url.getProtocol())) { final File file; try { file = new File(url.toURI()); } catch (URISyntaxException ex) { final String msg = format(\"Download failed, unable to locate '%s'\", url.toString()); throw new DownloadFailedException(msg); } if (file.exists()) { try { return new FileInputStream(file); } catch (IOException ex) { final String msg = format(\"Download failed, unable to rerieve '%s'\", url.toString()); throw new DownloadFailedException(msg, ex); } } else { final String msg = format(\"Download failed, file ('%s') does not exist\", url.toString()); throw new DownloadFailedException(msg); } } else { if (connection != null) { LOGGER.warn(\"HTTP URL Connection was not properly closed\"); connection.disconnect(); connection = null; } connection = obtainConnection(url); final String encoding = connection.getContentEncoding(); try { if (encoding != null && \"gzip\".equalsIgnoreCase(encoding)) { return new GZIPInputStream(connection.getInputStream()); } else if (encoding != null && \"deflate\".equalsIgnoreCase(encoding)) { return new InflaterInputStream(connection.getInputStream()); } else { return connection.getInputStream(); } } catch (IOException ex) { checkForCommonExceptionTypes(ex); final String msg = format(\"Error retrieving '%s'%nConnection Timeout: %d%nEncoding: %s%n\", url.toString(), connection.getConnectTimeout(), encoding); throw new DownloadFailedException(msg, ex); } catch (Exception ex) { final String msg = format(\"Unexpected exception retrieving '%s'%nConnection Timeout: %d%nEncoding: %s%n\", url.toString(), connection.getConnectTimeout(), encoding); throw new DownloadFailedException(msg, ex); } } }\n\n    ### Response: Retrieves the resource identified by the given URL and returns the\nInputStream.\n\n@param url the URL of the resource to download\n@return the stream to read the retrieved content from\n@throws org.owasp.dependencycheck.utils.DownloadFailedException is thrown\nif there is an error downloading the resource.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final FilterConfig filterConfig) throws ServletException { // final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER); if (decoraManagerClass != null) { try { final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass); decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType); } catch (Exception ex) { log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex); throw new ServletException(ex); } } else { decoraManager = createDecoraManager(); } // final String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER); if (decoraParserClass != null) { try { final Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass); decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType); } catch (Exception ex) { log.error(\"Unable to load Decora parser class: \" + decoraParserClass, ex); throw new ServletException(ex); } } else { decoraParser = createDecoraParser(); } // final String decoraCache = filterConfig.getInitParameter(PARAM_DECORA_CACHE); if (decoraCache != null) { cached = Converter.get().toBoolean(decoraCache, false); } }\n\n    ### Response:", "ground_truth": "Initializes Decora filter. Loads manager and parser from init parameters.", "predict": " Initializes the filter.\n\n@param filterConfig the filter configuration\n@throws ServletException thrown if there is an error initializing the filter\n\n    "}, {"ID": 981, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { // clean up collections if (consumers != null) { consumers.clear(); consumers = null; } if (providers != null) { providers.clear(); providers = null; } if (listeners != null) { listeners.clear(); listeners = null; } }\n\n    ### Response: Close the pipe.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile onFile(final Consumer<File> fileConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer); } else { consumers.add(fileConsumer); } return this; }\n\n    ### Response:", "ground_truth": "Registers file consumer", "predict": " Add a file consumer to the pipe."}, {"ID": 982, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static File platformIndependentUriToFile(final URI fileURI) { File file; try { file = new File(fileURI); } catch (IllegalArgumentException e) { if (fileURI.toString().startsWith(\"file://\")) { file = new File(fileURI.toString().substring(\"file://\".length())); } else { throw e; } } return file; }\n\n    ### Response: Convert a url to a file object.  No checks are made to see if file exists but there are some hacks that\nare needed to convert uris to files across platforms.\n\n@param fileURI the uri to convert.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile searchPath(final URI searchPath) { File file; try { file = new File(searchPath); } catch (Exception ex) { throw new FindFileException(\"URI error: \" + searchPath, ex); } addPath(file); return this; }\n\n    ### Response:", "ground_truth": "Specifies the search path. Throws an exception if URI is invalid.", "predict": " Search for a file in a search path.  The search path can be a directory or a jar file.  If the search path is a directory, the file is searched for in that directory.  If the search path is a jar file, the file is searched for in the jar file.  If the file is not found, a FindFileException is thrown.\n\n@param searchPath the uri of the search path."}, {"ID": 983, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ParsedPolicy parse(File file) throws Exception { if (file == null || !file.exists()) { if (debug) { if (file == null) { ProGradePolicyDebugger.log(\"Given File is null\"); } else { if (!file.exists()) { ProGradePolicyDebugger.log(\"Policy file \" + file.getCanonicalPath() + \" doesn't exists.\"); } } } throw new Exception(\"ER007: File with policy doesn't exists!\"); } if (debug) { ProGradePolicyDebugger.log(\"Parsing policy \" + file.getCanonicalPath()); } final InputStreamReader reader = new InputStreamReader(new FileInputStream(file), \"UTF-8\"); try { return parse(reader); } finally { reader.close(); } }\n\n    ### Response: Parse content of text policy file to ParsedPolicy object which represent this policy.\n\n@param file text file with policy file\n@return parsed policy file which is represented by ParsedPolicy\n@throws throw Exception when any problem occurred during parsing file (file doesn't exist, incompatible policy file etc.).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile searchPath(final URL searchPath) { File file = FileUtil.toContainerFile(searchPath); if (file == null) { throw new FindFileException(\"URL error: \" + searchPath); } addPath(file); return this; }\n\n    ### Response:", "ground_truth": "Specifies the search path. Throws an exception if URL is invalid.", "predict": " Add search path to the list of search paths.\n\n@param searchPath URL of the search path to be added\n@return this object to allow chaining of method calls\n@throws FindFileException if the URL is not a valid file URL or if the file cannot be accessed or if the file is not a directory\n\n    "}, {"ID": 984, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FulltextMatch setPatterns( final Collection<String> patterns ) { if (patterns == null || patterns.size() == 0) { clearPatterns(); return this; } synchronized (patterns) { for (String pattern : patterns) { if (pattern == null || pattern.length() == 0) { throw new IllegalArgumentException( \"null element\" ); } } clearPatterns(); for (String pattern : patterns) { addPattern( pattern ); } } return this; }\n\n    ### Response: Sets the matching patterns.\n\n@param   patterns\nthe matching patterns.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile include(final String... patterns) { for (String pattern : patterns) { rules.include(pattern); } return this; }\n\n    ### Response:", "ground_truth": "Defines include patterns.", "predict": " Adds the specified patterns to the list of include patterns.\n\n@param   patterns\nthe patterns to add to the include list.\n\n    "}, {"ID": 985, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FulltextMatch setPatterns( final Collection<String> patterns ) { if (patterns == null || patterns.size() == 0) { clearPatterns(); return this; } synchronized (patterns) { for (String pattern : patterns) { if (pattern == null || pattern.length() == 0) { throw new IllegalArgumentException( \"null element\" ); } } clearPatterns(); for (String pattern : patterns) { addPattern( pattern ); } } return this; }\n\n    ### Response: Sets the matching patterns.\n\n@param   patterns\nthe matching patterns.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile exclude(final String... patterns) { for (String pattern : patterns) { rules.exclude(pattern); } return this; }\n\n    ### Response:", "ground_truth": "Defines exclude patterns.", "predict": " Excludes the specified patterns from the search.\n\n@param   patterns\nthe patterns to exclude."}, {"ID": 986, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cleanUp(Context context) { File path = getScreenshotFolder(context); if (!path.exists()) { return; } delete(path); }\n\n    ### Response: Delete the screenshot folder for this app. Be careful not to call this before any intents have\nfinished using a screenshot reference..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addPath(final File path) { if (!path.exists()) { return; } if (pathList == null) { pathList = new LinkedList<>(); } pathList.add(path); }\n\n    ### Response:", "ground_truth": "Adds existing search path to the file list.\nNon existing files are ignored.\nIf path is a folder, it will be scanned for all files.", "predict": " Add a file path to the list of paths to be cleaned up. This method should only be called by the cleanup method."}, {"ID": 987, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<File> getKSChildDirectories(String ksName) { List<File> result = new ArrayList<>(); for (DataDirectory dataDirectory : dataDirectories) { File ksDir = new File(dataDirectory.location, ksName); File[] cfDirs = ksDir.listFiles(); if (cfDirs == null) continue; for (File cfDir : cfDirs) { if (cfDir.isDirectory()) result.add(cfDir); } } return result; }\n\n    ### Response: Recursively finds all the sub directories in the KS directory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<File> findAll() { List<File> allFiles = new ArrayList<>(); File file; while ((file = nextFile()) != null) { allFiles.add(file); } return allFiles; }\n\n    ### Response:", "ground_truth": "Finds all files and returns list of founded files.", "predict": " Finds all the files in the directory and its subdirectories."}, {"ID": 988, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public List<Message> getNextMessagesToDeliver() throws InterruptedException { LinkedList<Message> toDeliver = new LinkedList<>(); synchronized (deliverySet) { while (deliverySet.isEmpty() || !deliverySet.first().isReadyToDeliver()) { deliverySet.wait(); } Iterator<MessageInfo> iterator = deliverySet.iterator(); while (iterator.hasNext()) { MessageInfo messageInfo = iterator.next(); if (messageInfo.isReadyToDeliver()) { toDeliver.add(messageInfo.getMessage()); iterator.remove(); } else { break; } } } return toDeliver; }\n\n    ### Response: see the interface javadoc.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void init() { rules.detectMode(); todoFiles = new LinkedList<>(); todoFolders = new LinkedList<>(); if (pathList == null) { pathList = new LinkedList<>(); return; } if (pathListOriginal == null) { pathListOriginal = (LinkedList<File>) pathList.clone(); } String[] files = new String[pathList.size()]; int index = 0; Iterator<File> iterator = pathList.iterator(); while (iterator.hasNext()) { File file = iterator.next(); if (file.isFile()) { files[index++] = file.getAbsolutePath(); iterator.remove(); } } if (index != 0) { FilesIterator filesIterator = new FilesIterator(files); todoFiles.add(filesIterator); } }\n\n    ### Response:", "ground_truth": "Initializes file walking.\nSeparates input files and folders.", "predict": " see the interface javadoc."}, {"ID": 989, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<Tree> iterator() { return new Iterator<Tree>() { @Override public boolean hasNext() { return next != null; } @Override public Tree next() { Tree t = next.leaf; next = next.parent; return t; } @Override public void remove() { throw new UnsupportedOperationException(); } private TreePath next = TreePath.this; }; }\n\n    ### Response: Iterates from leaves to root..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<File> iterator() { return new Iterator<File>() { private File nextFile; @Override public boolean hasNext() { nextFile = nextFile(); return nextFile != null; } @Override public File next() { if (nextFile == null) { throw new NoSuchElementException(); } return nextFile; } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response:", "ground_truth": "Returns file walking iterator.", "predict": " Iterates over the files in the directory."}, {"ID": 990, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getTypeName(Type type) { String name; if (type instanceof Class) { name = ((Class<?>) type).getName(); } else if (type instanceof ParameterizedType) { name = ((Class<?>) ((ParameterizedType) type).getRawType()).getName(); } else { name = type.toString(); } return name; }\n\n    ### Response: Get class name without generics.\n\n@param type the type\n@return type name without generics.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WiringMode resolveBeanWiringMode(final Class type) { PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class); return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT; }\n\n    ### Response:", "ground_truth": "Resolves bean's auto-wire flag from the annotation. Returns default auto-wire if annotation doesn't exist.", "predict": " Get the wiring mode for a bean class.\n\n@param type the bean class\n@return the wiring mode for the bean class\n\n    "}, {"ID": 991, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getDisplayName(TimeZone tz, GenericNameType type, long date) { String name = null; String tzCanonicalID = null; switch (type) { case LOCATION: tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz); if (tzCanonicalID != null) { name = getGenericLocationName(tzCanonicalID); } break; case LONG: case SHORT: name = formatGenericNonLocationName(tz, type, date); if (name == null) { tzCanonicalID = ZoneMeta.getCanonicalCLDRID(tz); if (tzCanonicalID != null) { name = getGenericLocationName(tzCanonicalID); } } break; } return name; }\n\n    ### Response: Returns the display name of the time zone for the given name type\nat the given date, or null if the display name is not available.\n\n@param tz the time zone\n@param type the generic name type - see {@link GenericNameType}\n@param date the date\n@return the display name of the time zone for the given name type\nat the given date, or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveBeanName(final Class type, final boolean useLongTypeName) { PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class); String name = null; if (petiteBean != null) { name = petiteBean.value().trim(); } if ((name == null) || (name.length() == 0)) { if (useLongTypeName) { name = type.getName(); } else { name = StringUtil.uncapitalize(type.getSimpleName()); } } return name; }\n\n    ### Response:", "ground_truth": "Resolves bean's name from bean annotation or type name. May be used for resolving bean name\nof base type during registration of bean subclass.", "predict": " Resolves the bean name for the given type.\n\n@param type the type\n@param useLongTypeName whether to use the long type name as the bean name\n@return the resolved bean name\n\n    "}, {"ID": 992, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() throws IOException { if (outStream == null && outWriter == null) { throw new IllegalStateException(); } if (outStream != null) { outStream.close(); } if (outWriter != null) { outWriter.close(); } }\n\n    ### Response: Close output.\n\n@throws IOException if closing result output failed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PrintWriter getWriter() { if (outWriter == null) { if (outStream != null) { throw new IllegalStateException(\"Can't call getWriter() after getOutputStream()\"); } bufferedWriter = new FastCharArrayWriter(); outWriter = new PrintWriter(bufferedWriter) { @Override public void close() { // do not close the print writer after rendering // since it will remove reference to bufferedWriter } }; } return outWriter; }\n\n    ### Response:", "ground_truth": "Returns a writer.", "predict": " Get a PrintWriter for writing to the output.\n\n@throws IllegalStateException if getOutputStream() has already been called."}, {"ID": 993, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() throws IOException { if (outStream == null && outWriter == null) { throw new IllegalStateException(); } if (outStream != null) { outStream.close(); } if (outWriter != null) { outWriter.close(); } }\n\n    ### Response: Close output.\n\n@throws IOException if closing result output failed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServletOutputStream getOutputStream() { if (outStream == null) { if (outWriter != null) { throw new IllegalStateException(\"Can't call getOutputStream() after getWriter()\"); } bufferOutputStream = new FastByteArrayServletOutputStream(); outStream = bufferOutputStream; } return outStream; }\n\n    ### Response:", "ground_truth": "Returns a servlet output stream.", "predict": " Get the output stream for writing response data.\n\n@throws IllegalStateException if getWriter() has already been called."}, {"ID": 994, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder sb = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { sb.append(\"[]\"); } return sb.toString(); case OBJECT: return new String(buf, off, len).replace('/', '.').intern(); default: return null; } }\n\n    ### Response: Returns the binary name of the class corresponding to this type. This\nmethod must not be used on method types.\n\n@return the binary name of the class corresponding to this type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { stringBuilder.append(\"[]\"); } return stringBuilder.toString(); case OBJECT: case INTERNAL: return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.'); default: throw new AssertionError(); } }\n\n    ### Response:", "ground_truth": "Returns the binary name of the class corresponding to this type. This method must not be used\non method types.\n\n@return the binary name of the class corresponding to this type.", "predict": " Returns the binary name of the class corresponding to this type. This\nmethod must not be used on method types.\n\n@return the binary name of the class corresponding to this type."}, {"ID": 995, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getTimingStat() { final Stopwatch root = STOPWATCH.get(); if (null == root) { return \"No stopwatch\"; } final StringBuilder stringBuilder = new StringBuilder(); root.appendTimingStat(1, stringBuilder); return stringBuilder.toString(); }\n\n    ### Response: Gets the current timing statistics.\n\n\nIf a task is not ended, the outputs will be minus for percentage and elapsed, the absolute value of the elapsed\nfiled is the start time.\n\n\n@return the current timing statistics, returns {@code \"No stopwatch\"} if not stopwatch.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getConstructorDescriptor(final Constructor<?> constructor) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = constructor.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } return stringBuilder.append(\")V\").toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given constructor.\n\n@param constructor a {@link Constructor} object.\n@return the descriptor of the given constructor.", "predict": " Gets the descriptor of the constructor.\n\n\n@param constructor the constructor to get the descriptor for\n@return the descriptor of the constructor\n\n    "}, {"ID": 996, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getMessagesForDisplay() { if(messages.isEmpty()) { return \"\"; } StringBuilder stringBuilder = new StringBuilder(); for (String message : messages) { stringBuilder.append(message); stringBuilder.append(\"\\n\"); } String tempStr = stringBuilder.toString(); stringBuilder.deleteCharAt(tempStr.length() - 1); return stringBuilder.toString(); }\n\n    ### Response: Formats the messages in the result to a suitable form\nso that it can be used in user interface.\n\n@return a string containing the formatted message..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); for (Type argumentType : argumentTypes) { argumentType.appendDescriptor(stringBuilder); } stringBuilder.append(')'); returnType.appendDescriptor(stringBuilder); return stringBuilder.toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given argument and return types.\n\n@param returnType the return type of the method.\n@param argumentTypes the argument types of the method.\n@return the descriptor corresponding to the given argument and return types.", "predict": "Returns the method descriptor for the given return type and argument types.\n\n@param returnType the return type of the method\n@param argumentTypes the argument types of the method\n@return the method descriptor for the given return type and argument types."}, {"ID": 997, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getTimingStat() { final Stopwatch root = STOPWATCH.get(); if (null == root) { return \"No stopwatch\"; } final StringBuilder stringBuilder = new StringBuilder(); root.appendTimingStat(1, stringBuilder); return stringBuilder.toString(); }\n\n    ### Response: Gets the current timing statistics.\n\n\nIf a task is not ended, the outputs will be minus for percentage and elapsed, the absolute value of the elapsed\nfiled is the start time.\n\n\n@return the current timing statistics, returns {@code \"No stopwatch\"} if not stopwatch.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getMethodDescriptor(final Method method) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = method.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } stringBuilder.append(')'); appendDescriptor(method.getReturnType(), stringBuilder); return stringBuilder.toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given method.\n\n@param method a {@link Method} object.\n@return the descriptor of the given method.", "predict": " Gets the descriptor of the given method.\n\n\n@param method the method to get the descriptor for\n@return the descriptor of the given method\n\n    "}, {"ID": 998, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getDescriptor() { if (sort == OBJECT) { return valueBuffer.substring(valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('L'); stringBuilder.append(valueBuffer, valueBegin, valueEnd); stringBuilder.append(';'); return stringBuilder.toString(); } else { return valueBuffer.substring(valueBegin, valueEnd); } }\n\n    ### Response: Returns the descriptor corresponding to this type.\n\n@return the descriptor corresponding to this type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void appendDescriptor(final StringBuilder stringBuilder) { if (sort == OBJECT) { stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';'); } else { stringBuilder.append(valueBuffer, valueBegin, valueEnd); } }\n\n    ### Response:", "ground_truth": "Appends the descriptor corresponding to this type to the given string buffer.\n\n@param stringBuilder the string builder to which the descriptor must be appended.", "predict": " Appends the descriptor corresponding to this type to the given string builder.\n\n@param stringBuilder the string builder to which the descriptor should be appended."}, {"ID": 999, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getOpcode(final int opcode) { if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) { switch (sort) { case BOOLEAN: case BYTE: return opcode + 5; case CHAR: return opcode + 6; case SHORT: return opcode + 7; case INT: return opcode; case FLOAT: return opcode + 2; case LONG: return opcode + 1; case DOUBLE: return opcode + 3; // case ARRAY: // case OBJECT: default: return opcode + 4; } } else { switch (sort) { case VOID: return opcode + 5; case BOOLEAN: case CHAR: case BYTE: case SHORT: case INT: return opcode; case FLOAT: return opcode + 2; case LONG: return opcode + 1; case DOUBLE: return opcode + 3; // case ARRAY: // case OBJECT: default: return opcode + 4; } } }\n\n    ### Response: Returns a JVM instruction opcode adapted to this Java type.\n\n@param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\nISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\nISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n@return an opcode that is similar to the given opcode, but adapted to\nthis Java type. For example, if this type is float and\nopcode is IRETURN, this method returns FRETURN..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getSize() { switch (sort) { case VOID: return 0; case BOOLEAN: case CHAR: case BYTE: case SHORT: case INT: case FLOAT: case ARRAY: case OBJECT: case INTERNAL: return 1; case LONG: case DOUBLE: return 2; default: throw new AssertionError(); } }\n\n    ### Response:", "ground_truth": "Returns the size of values of this type. This method must not be used for method types.\n\n@return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n{@code void} and 1 otherwise.", "predict": " Returns the size of this Java type in words.\n\n@return the size of this Java type in words. For example, if this\ntype is boolean, byte, short, int or float, this method returns 1. If\nthis type is long or double, this method returns 2. If this type is\nvoid, this method returns 0. If this type is an array or an object,\nthis method returns the number of words required to store the reference\nor the array elements, respectively. If this type is INTERNAL, this\nmethod returns the size of the internal representation of the type."}, {"ID": 1000, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String replaceChars(String str) { StringBuffer buf = new StringBuffer(str); int length = buf.length(); for (int i = 0; i < length; i++) { char currentChar = buf.charAt(i); // Replace space with \"%20\" if (currentChar == ' ') { buf.setCharAt(i, '%'); buf.insert(i+1, \"20\"); length = length + 2; i = i + 2; } // Replace backslash with forward slash else if (currentChar == '\\\\') { buf.setCharAt(i, '/'); } } return buf.toString(); }\n\n    ### Response: Replace spaces with \"%20\" and backslashes with forward slashes in\nthe input string to generate a well-formed URI string.\n\n@param str The input string\n@return The string after conversion.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getArgumentsAndReturnSizes(final String methodDescriptor) { int argumentsSize = 1; // Skip the first character, which is always a '('. int currentOffset = 1; int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration. while (currentChar != ')') { if (currentChar == 'J' || currentChar == 'D') { currentOffset++; argumentsSize += 2; } else { while (methodDescriptor.charAt(currentOffset) == '[') { currentOffset++; } if (methodDescriptor.charAt(currentOffset++) == 'L') { // Skip the argument descriptor content. currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1; } argumentsSize += 1; } currentChar = methodDescriptor.charAt(currentOffset); } currentChar = methodDescriptor.charAt(currentOffset + 1); if (currentChar == 'V') { return argumentsSize << 2; } else { int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1; return argumentsSize << 2 | returnSize; } }\n\n    ### Response:", "ground_truth": "Computes the size of the arguments and of the return value of a method.\n\n@param methodDescriptor a method descriptor.\n@return the size of the arguments of the method (plus one for the implicit this argument),\nargumentsSize, and the size of its return value, returnSize, packed into a single int i =\n{@code (argumentsSize << 2) | returnSize} (argumentsSize is therefore equal to {@code\ni >> 2}, and returnSize to {@code i & 0x03}).", "predict": " Compute the size of the arguments and return value of a method based on its method descriptor.\n\n@param methodDescriptor The method descriptor of the method\n@return The size of the arguments and return value in bytes, packed into an integer. The first 16 bits represent the size of the arguments, and the last 16 bits represent the size of the return value. If the return value is void, the last 16 bits are set to 0."}, {"ID": 1001, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function parseEvent(cursor, runningStatus) { var delay, status, result; delay = parseVarInt(cursor); status = cursor.readUInt8(); // if the most significant bit is not set, // we use the last status if ((status & 0x80) === 0) { if (!runningStatus) { throw new error.MIDIParserError( 'undefined event status', cursor.tell() ); } status = runningStatus; cursor.seek(cursor.tell() - 1); } else { runningStatus = status; } if (status === 0xFF) { result = parseMetaEvent(delay, cursor); } else if (status === 0xF0 || status === 0xF7) { result = parseSysexEvent(delay, status & 0xF, cursor); } else if (status >= 0x80 && status < 0xF0) { result = parseChannelEvent(delay, status >> 4, status & 0xF, cursor); } else { throw new error.MIDIParserError( status, 'known status type', cursor.tell() ); } return { runningStatus: runningStatus, event: result }; }\n\n    ### Response: Parse any type of MIDI event\n\n@param {BufferCursor} cursor Buffer to parse\n@param {number} [runningStatus] Previous status if applicable\n@throws {module:midijs/lib/error~MIDIParserError}\nUnknown event status encountered or running status undefined\nwhile being requested by this event's data\n@return {Object} Parsed event and new running status.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = th; status = STATUS_MARKED_ROLLBACK; }\n\n    ### Response:", "ground_truth": "Modify the transaction associated with the target object such that the only possible outcome\nof the transaction is to roll back the transaction.", "predict": " Mark the current transaction as rollback-only.\n\n@param {Throwable} th The cause of the rollback\n@throws {module:jtx~JtxException} If there is no active transaction or if the current transaction is already marked as rollback-only."}, {"ID": 1002, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean checkDeploymentDir(File directory) { if (!directory.exists()) { if (deploymentDirAccessible) { deploymentDirAccessible = false; ROOT_LOGGER.directoryIsNonexistent(deploymentDir.getAbsolutePath()); } } else if (!directory.isDirectory()) { if (deploymentDirAccessible) { deploymentDirAccessible = false; ROOT_LOGGER.isNotADirectory(deploymentDir.getAbsolutePath()); } } else if (!directory.canRead()) { if (deploymentDirAccessible) { deploymentDirAccessible = false; ROOT_LOGGER.directoryIsNotReadable(deploymentDir.getAbsolutePath()); } } else if (!directory.canWrite()) { if (deploymentDirAccessible) { deploymentDirAccessible = false; ROOT_LOGGER.directoryIsNotWritable(deploymentDir.getAbsolutePath()); } } else { deploymentDirAccessible = true; } return deploymentDirAccessible; }\n\n    ### Response: Checks that given directory if readable & writable and prints a warning if the check fails. Warning is only\nprinted once and is not repeated until the condition is fixed and broken again.\n\n@param directory deployment directory\n@return does given directory exist and is readable and writable?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void commitOrRollback(boolean doCommit) { if (log.isDebugEnabled()) { if (doCommit) { log.debug(\"Commit JTX\"); } else { log.debug(\"Rollback JTX\"); } } boolean forcedRollback = false; if (!isNoTransaction()) { if (isRollbackOnly()) { if (doCommit) { doCommit = false; forcedRollback = true; } } else if (!isActive()) { if (isCompleted()) { throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\"); } throw new JtxException(\"No active TX to \" + (doCommit ? \"commit\" : \"rollback\")); } } if (doCommit) { commitAllResources(); } else { rollbackAllResources(forcedRollback); } }\n\n    ### Response:", "ground_truth": "Performs either commit or rollback on all transaction resources.", "predict": " Commits or rolls back the transaction. If the transaction is marked as rollback only, it will be rolled back. If the transaction is not active, it will throw an exception. If the transaction is already completed, it will throw an exception.\n\n@param doCommit true to commit, false to rollback\n@throws JtxException if the transaction is not active or already completed."}, {"ID": 1003, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <X> X implicitlyWaitFor(Callable<X> condition) { long end = System.currentTimeMillis() + OperaIntervals.IMPLICIT_WAIT.getMs(); Exception lastException = null; do { X toReturn = null; try { toReturn = condition.call(); } catch (Exception e) { lastException = e; } if (toReturn instanceof Boolean && !(Boolean) toReturn) { continue; } if (toReturn != null) { return toReturn; } sleep(OperaIntervals.POLL_INTERVAL.getMs()); } while (System.currentTimeMillis() < end); if (lastException != null) { if (lastException instanceof RuntimeException) { throw (RuntimeException) lastException; } throw new WebDriverException(lastException); } return null; }\n\n    ### Response: Implicitly wait for an element to become visible.\n\nEssentially it polls the client every {@link OperaIntervals#POLL_INTERVAL} until {@link\nOperaIntervals#IMPLICIT_WAIT} is reached for callable condition to be true.\n\n@param condition a callable implementation\n@param        computes a result, or throws an exception if unable to do so\n@return a non-null value if condition is met within implicit wait timeout, null otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void rollbackAllResources(final boolean wasForced) { status = STATUS_ROLLING_BACK; Exception lastException = null; Iterator<JtxResource> it = resources.iterator(); while (it.hasNext()) { JtxResource resource = it.next(); try { resource.rollbackTransaction(); } catch (Exception ex) { lastException = ex; } finally { it.remove(); } } txManager.removeTransaction(this); status = STATUS_ROLLEDBACK; if (lastException != null) { status = STATUS_UNKNOWN; throw new JtxException(\"Rollback failed: one or more TX resources couldn't rollback a TX\", lastException); } if (wasForced) { throw new JtxException(\"TX rolled back because it has been marked as rollback-only\", rollbackCause); } }\n\n    ### Response:", "ground_truth": "Rollbacks all attached resources. Resource will be closed. and detached from this transaction.\nIf exception occurs, it will be rethrown at the end.", "predict": " Rollback all resources associated with the transaction.\n\n@param wasForced true if the transaction was marked as rollback-only, false otherwise.\n@throws JtxException if any of the resources couldn't rollback the transaction.\n\n    "}, {"ID": 1004, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Resource getConsoleResource(BeanContext context) { SlingHttpServletRequest request = context.getRequest(); ResourceResolver resolver = request.getResourceResolver(); String path = null; // use the resource set by a probably executed 'defineObjects' tag (supports including components) Resource resource = context.getAttribute(\"resource\", Resource.class); if (resource == null) { resource = request.getResource(); } if (resource != null) { path = resource.getPath(); } // use the suffix as the resource path if the resource is not defined or references a servlet if (StringUtils.isBlank(path) || path.startsWith(\"/bin/\")) { RequestPathInfo requestPathInfo = request.getRequestPathInfo(); path = requestPathInfo.getSuffix(); resource = null; } if (resource == null && StringUtils.isNotBlank(path)) { resource = resolver.getResource(path); } if (resource == null) { // fallback to the root node if the servlet request has no suffix resource = resolver.getResource(\"/\"); } return resource; }\n\n    ### Response: determines the addressed resource by the suffix if the requests resource is the servlet itself.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E requestResource(final Class<E> resourceType) { if (isCompleted()) { throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\"); } if (isRollbackOnly()) { throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause); } if (!isNoTransaction() && !isActive()) { throw new JtxException(\"Resources are not available since TX is not active\"); } checkTimeout(); E resource = lookupResource(resourceType); if (resource == null) { int maxResources = txManager.getMaxResourcesPerTransaction(); if ((maxResources != -1) && (resources.size() >= maxResources)) { throw new JtxException(\"TX already has attached max. number of resources\"); } JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType); resource = resourceManager.beginTransaction(mode, isActive()); resources.add(new JtxResource<>(this, resourceManager, resource)); } return resource; }\n\n    ### Response:", "ground_truth": "Requests a resource. If resource is not found, it will be created and new transaction will be started on it.", "predict": " retrieves a resource of the specified type from the transaction. If the resource is not yet attached to the transaction, it will be attached and returned. If the transaction is already completed or marked as rollback only, an exception will be thrown. If the transaction is not active, an exception will be thrown. If the transaction has reached its timeout, an exception will be thrown. If the transaction already has attached the maximum number of resources, an exception will be thrown."}, {"ID": 1005, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void internalWriteNameValuePair(String name, String value) throws IOException { writeComma(); writeNewLineIndent(); writeName(name); if (m_pretty) { m_writer.write(' '); } m_writer.write(value); }\n\n    ### Response: Core write attribute implementation.\n\n@param name attribute name\n@param value attribute value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void popName() { if (isPushed) { if (pushedComma) { writeComma(); } String name = pushedName; pushedName = null; isPushed = false; writeName(name); } }\n\n    ### Response:", "ground_truth": "Writes stored name to JSON string. Cleans storage.", "predict": " Pops the last pushed name from the stack and writes it to the output.\n\n@throws IOException if an I/O error occurs."}, {"ID": 1006, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String escapeString(String value) { m_buffer.setLength(0); m_buffer.append('\"'); for (int index = 0; index < value.length(); index++) { char c = value.charAt(index); switch (c) { case '\"': { m_buffer.append(\"\\\\\\\"\"); break; } case '\\\\': { m_buffer.append(\"\\\\\\\\\"); break; } case '/': { m_buffer.append(\"\\\\/\"); break; } case '\\b': { m_buffer.append(\"\\\\b\"); break; } case '\\f': { m_buffer.append(\"\\\\f\"); break; } case '\\n': { m_buffer.append(\"\\\\n\"); break; } case '\\r': { m_buffer.append(\"\\\\r\"); break; } case '\\t': { m_buffer.append(\"\\\\t\"); break; } default: { // Append if it's not a control character (0x00 to 0x1f) if (c > 0x1f) { m_buffer.append(c); } break; } } } m_buffer.append('\"'); return m_buffer.toString(); }\n\n    ### Response: Escape text to ensure valid JSON.\n\n@param value value\n@return escaped value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeString(final String value) { popName(); write(StringPool.QUOTE); int len = value.length(); for (int i = 0; i < len; i++) { char c = value.charAt(i); switch (c) { case '\"': write(\"\\\\\\\"\"); break; case '\\\\': write(\"\\\\\\\\\"); break; case '/': if (strictStringEncoding) { write(\"\\\\/\"); } else { write(c); } break; case '\\b': write(\"\\\\b\"); break; case '\\f': write(\"\\\\f\"); break; case '\\n': write(\"\\\\n\"); break; case '\\r': write(\"\\\\r\"); break; case '\\t': write(\"\\\\t\"); break; default: if (Character.isISOControl(c)) { unicode(c); } else { write(c); } } } write(StringPool.QUOTE); }\n\n    ### Response:", "ground_truth": "Write a quoted and escaped value to the output.", "predict": " Write a string to the output stream, escaping any necessary characters.\n\n@param value the string to write\n@throws IOException if an I/O error occurs"}, {"ID": 1007, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] hexToByte(String s) throws IOException { int l = s.length() / 2; byte data[] = new byte[l]; int j = 0; if (s.length() % 2 != 0) { throw new IOException( \"hexadecimal string with odd number of characters\"); } for (int i = 0; i < l; i++) { char c = s.charAt(j++); int n, b; n = HEXINDEX.indexOf(c); if (n == -1) { throw new IOException( \"hexadecimal string contains non hex character\"); } b = (n & 0xf) << 4; c = s.charAt(j++); n = HEXINDEX.indexOf(c); b += (n & 0xf); data[i] = (byte) b; } return data; }\n\n    ### Response: Compacts a hexadecimal string into a byte array\n\n\n@param s hexadecimal string\n\n@return byte array for the hex string\n@throws IOException \u975e16\u8fdb\u5236\u5b57\u7b26\u6216\u8005\u8d85\u957f\u65f6\u629b\u51fa.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void unicode(final char c) { write(\"\\\\u\"); int n = c; for (int i = 0; i < 4; ++i) { int digit = (n & 0xf000) >> 12; char hex = CharUtil.int2hex(digit); write(hex); n <<= 4; } }\n\n    ### Response:", "ground_truth": "Writes unicode representation of a character.", "predict": " Writes a Unicode character to the output stream.\n\n@param c the Unicode character to write\n@throws IOException if an I/O error occurs"}, {"ID": 1008, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void print(CharSequence charSequence) { try { consoleReader.println(charSequence); consoleReader.flush(); } catch (IOException e) { throw new IllegalStateException(\"Can't write to console\", e); } }\n\n    ### Response: Print charSequence to console\n\n@param charSequence to print.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void write(final CharSequence charSequence) { popName(); try { out.append(charSequence); } catch (IOException ioex) { throw new JsonException(ioex); } }\n\n    ### Response:", "ground_truth": "Appends char sequence to the buffer. Used for numbers, nulls, booleans, etc.", "predict": " Write charSequence to output stream\n\n@param charSequence to write."}, {"ID": 1009, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func SetLevelString(levelstr string) LogLevel { logMux.Lock() defer logMux.Unlock() current := logLevel switch strings.ToLower(levelstr) { case \"debug\": logLevel = LevelDebug case \"info\": logLevel = LevelInfo case \"warning\": logLevel = LevelWarning case \"error\": logLevel = LevelError case \"critical\": logLevel = LevelCritical case \"fatal\": logLevel = LevelFatal } return current }\n\n    ### Response: // SetLevelString switches to a new log level passed as\n// string. Accepted are the values \"debug\", \"info\", \"warning\"\n// \"error\", \"critical\", and \"fatal\". The passed string will\n// be set to lower-case. The function is intended to be used\n// when then log level is read out of a configuration..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) { logLevel = logLevel.trim().toUpperCase(); parsingErrorLogLevel = Logger.Level.valueOf(logLevel); return this; }\n\n    ### Response:", "ground_truth": "Sets parsing error log level as a name.", "predict": " // setParsingErrorLogLevelName sets the log level for parsing errors.\n// The log level name is passed as a string and will be trimmed\n// and converted to upper-case. The resulting log level name is\n// used to set the parsingErrorLogLevel field. The method returns\n// the LagartoDomBuilderConfig object for chaining."}, {"ID": 1010, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public final void reset(int start, int count) throws IllegalArgumentException { int len = 0; if (text != null) { len = text.length; } if (start < 0 || count < 0 || start > len - count) { throw new IllegalArgumentException(); } textStart = start; textLimit = start + count; reset(); }\n\n    ### Response: Reset the iterator to iterate over the given range of the text. Throws\nIllegalArgumentException if the range is outside of the bounds of the\ncharacter array.\n\n@param start the index of the new first character over which to iterate\n@param count the new number of characters over which to iterate.\n@exception IllegalArgumentException If invalid arguments are passed.\n\n@deprecated This API is ICU internal only.\n@hide draft / provisional / internal are hidden on Android.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startRegion(final int start, final int tagLen, final int deepLevel) { this.regionStart = start + tagLen; this.regionLength = 0; this.regionTagStart = start; this.deepLevel = deepLevel; }\n\n    ### Response:", "ground_truth": "Starts defining region by setting the start index and reset region length to zero.", "predict": "Start a new region of text with the given start index, tag length, and deep level.\n\n@param start the start index of the region\n@param tagLen the length of the tag that starts the region\n@param deepLevel the deep level of the region\n\n@stable ICU 4.8"}, {"ID": 1011, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isValid(final String value) { if (value == null) { return true; } if (value.length() == 0) { return false; } final int space = value.indexOf(' '); if (space == -1) { return false; } // Try converting amount final String amount = value.substring(0, space); if (!(amount.matches(DECIMAL) || amount.matches(INTEGER))) { return false; } // Try to convert code into a currency final String currencyCode = value.substring(space + 1); try { Currency.getInstance(currencyCode); } catch (RuntimeException ex) { return false; } return true; }\n\n    ### Response: Check that a given string is a well-formed currency amount.\n\n@param value\nValue to check.\n\n@return Returns true if it's a valid currency amount else false is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isContaining(final String include) { if (value == null) { return false; } if (splits == null) { splits = StringUtil.splitc(value, ' '); } for (String s: splits) { if (s.equals(include)) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Returns true if attribute is containing some value.", "predict": " Check if a given string is present in the value.\n\n@param include\nString to check.\n\n@return Returns true if the string is present in the value else false is returned."}, {"ID": 1012, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void callAnnotated(Object o, Class<? extends Annotation> ann, boolean lazy) { try { getMethodOfInterest(o, ann).invoke(o); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { throw new RuntimeException(ex.getCause()); } catch (IllegalArgumentException ex) { if (!lazy) { throw new RuntimeException(ex.getMessage()); } } }\n\n    ### Response: Call an method by Annotation.\n\n@param o the object to call.\n@param ann the annotation\n@param lazy if true, the a missing annotation is OK. if false\nthe annotation has to be present or a Runtime exception is thrown..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pseudoFunctionType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction); }\n\n    ### Response:", "ground_truth": "Registers pseudo function.", "predict": " Register a pseudo function.\n\n@param pseudoFunctionType the pseudo function type to register.\n\n    "}, {"ID": 1013, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String getAttribute(Node node, String name, boolean required) { NamedNodeMap attributes = node.getAttributes(); Node idNode = attributes.getNamedItem(name); if (idNode == null) { if (required) { throw new IllegalArgumentException(toPath(node) + \" has no \" + name + \" attribute\"); } else { return \"\"; } } else { String value = idNode.getNodeValue(); if (value == null) { return \"\"; } return value; } }\n\n    ### Response: Get an Attribute from the given node and throwing an exception in the case it is required but\nnot present\n\n@param node\n@param name\n@param required\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName); if (pseudoFunction == null) { throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName); } return pseudoFunction; }\n\n    ### Response:", "ground_truth": "Lookups pseudo function for given pseudo function name.", "predict": " Lookup the PseudoFunction with the given name from the PSEUDO_FUNCTION_MAP and return it.\n\n@param pseudoFunctionName\n@return PseudoFunction."}, {"ID": 1014, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static ClassWriter generateClass(String className, String superName, String[] interfaces, String signature, int classModifiers, String apiName) { ClassWriter classWriter = new ClassWriter(0); if (interfaces != null){ for (int i = 0; i < interfaces.length; i++) { interfaces[i] = getFullClassTypeName(interfaces[i], apiName); } } classWriter.visit(V1_8, classModifiers, getFullClassTypeName(className, apiName), signature, superName, interfaces); return classWriter; }\n\n    ### Response: Generates an empty class.\n@param className The classes name.\n@param superName The super object, which the class extends from.\n@param interfaces The name of the interfaces which this class implements.\n@param classModifiers The modifiers to the class.\n@return A class writer that will be used to write the remaining information of the class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) { wd.init(name, superName, this.suffix, this.reqProxyClassName); // change access of destination access &= ~AsmUtil.ACC_ABSTRACT; // write destination class final int v = ProxettaAsmUtil.resolveJavaVersion(version); wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null); wd.proxyAspects = new ProxyAspectData[aspects.length]; for (int i = 0; i < aspects.length; i++) { wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i); } }\n\n    ### Response:", "ground_truth": "Creates destination subclass header from current target class. Destination name is created from targets by\nadding a suffix and, optionally, a number. Destination extends the target.", "predict": " Visits the header of a class.\n@param version The class version.\n@param access The class access flags.\n@param name The class name.\n@param signature The signature of the class.\n@param superName The name of the super class.\n@param interfaces The names of the interfaces implemented by the class."}, {"ID": 1015, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(String desc, boolean visible) { AnnotationInfoVisitor av = visitAnnotation(getInfo(), desc, visible); annotationInfos.add(av.getAnnotationInfo()); return av; }\n\n    ### Response: See the class comment for details of annotation processing..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3] return new AnnotationVisitorAdapter(destAnn); }\n\n    ### Response:", "ground_truth": "Copies all destination type annotations to the target.", "predict": "This method overrides the `visitAnnotation` method of the `ClassVisitor` interface. It takes two parameters, `desc` and `visible`, which are used to specify the annotation type and whether it is visible at runtime. The method returns an `AnnotationVisitor` object that can be used to visit the individual annotation elements.\r\n\r\nThe implementation of this method creates a new `AnnotationVisitorAdapter` object, passing in the destination `AnnotationVisitor` object returned by the `visitAnnotation` method of the destination `ClassVisitor` object. The `AnnotationVisitorAdapter` class is a simple adapter that simply delegates all method calls to the destination `AnnotationVisitor` object.\r\n\r\nThe `[A3]` comment indicates that the `destAnn` variable is created by the `visitAnnotation` method of the destination `ClassVisitor` object."}, {"ID": 1016, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { if (isInstrumentableClass()) { // Add a field to hold the trace state if needed if (isTraceObjectFieldDefinitionRequired()) { int access = (Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC); String name = getTraceObjectFieldName(); String desc = getTraceObjectFieldType().getDescriptor(); visitField(access, name, desc, null, null); } // Add a static initializer to setup trace if needed if (isStaticInitializerRequired() && !isStaticInitDefined()) { staticInitializerGenerated = true; MethodVisitor mv = visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null); Label lineNumberLabel = new Label(); mv.visitCode(); mv.visitLabel(lineNumberLabel); mv.visitLineNumber(65535, lineNumberLabel); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 0); mv.visitEnd(); } } super.visitEnd(); }\n\n    ### Response: Visit the end of the class. All of the methods and fieldInfos defined in\nthe class have been visited at this point. If we didn't encounter a\ntrace state field or static initializer, we'll add them now..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void makeStaticInitBlock() { if (wd.adviceClinits != null) { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null); mv.visitCode(); for (String name : wd.adviceClinits) { mv.visitMethodInsn( INVOKESTATIC, wd.thisReference, name, DESC_VOID, false); } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } }\n\n    ### Response:", "ground_truth": "Creates static initialization block that simply calls all\nadvice static init methods in correct order.", "predict": " Generate a static initializer block for the class. This block will contain\nany advice that needs to be executed at class load time."}, {"ID": 1017, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitCode() { mv = cv.visitMethod(ACC_PRIVATE, \"<init>\", \"(Z)V\", null, null); mv.visitCode(); Label l0 = new Label(); mv.visitLabel(l0); mv.visitLineNumber(1, l0); mv.visitVarInsn(ALOAD, 0); mv.visitVarInsn(ILOAD, 1); mv.visitMethodInsn(INVOKESPECIAL, TQ_ROOT_BEAN, \"<init>\", \"(Z)V\", false); Label l1 = new Label(); mv.visitLabel(l1); mv.visitLineNumber(2, l1); mv.visitVarInsn(ALOAD, 0); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKEVIRTUAL, classInfo.getClassName(), \"setRoot\", \"(Ljava/lang/Object;)V\", false); // init all the properties List<FieldInfo> fields = classInfo.getFields(); if (fields != null) { for (FieldInfo field : fields) { field.writeFieldInit(mv); } } Label l2 = new Label(); mv.visitLabel(l2); mv.visitLineNumber(3, l2); mv.visitInsn(RETURN); Label l12 = new Label(); mv.visitLabel(l12); mv.visitLocalVariable(\"this\", \"L\" + classInfo.getClassName() + \";\", null, l0, l12, 0); mv.visitLocalVariable(\"alias\", \"Z\", null, l0, l12, 1); mv.visitMaxs(5, 2); mv.visitEnd(); }\n\n    ### Response: Write the constructor initialising all the fields eagerly..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void makeProxyConstructor() { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null); mv.visitCode(); if (wd.adviceInits != null) { for (String name : wd.adviceInits) { mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn (INVOKESPECIAL, wd.thisReference, name, DESC_VOID, false); } } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Creates init method that simply calls all advice constructor methods in correct order.\nThis created init method is called from each destination's constructor.", "predict": " Generate the constructor for the proxy class that initializes all the fields of the target class eagerly."}, {"ID": 1018, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] getMethodParamNames(final Method m) { if (METHOD_NAMES_POOL.containsKey(m)) return METHOD_NAMES_POOL.get(m); final String[] paramNames = new String[m.getParameterTypes().length]; final String n = m.getDeclaringClass().getName(); ClassReader cr; try { cr = new ClassReader(n); } catch (IOException e) { return null; } cr.accept(new ClassVisitor(Opcodes.ASM5) { @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { final Type[] args = Type.getArgumentTypes(desc); // The method name is the same and the number of parameters is the same if (!name.equals(m.getName()) || !sameType(args, m.getParameterTypes())) { return super.visitMethod(access, name, desc, signature, exceptions); } MethodVisitor v = super.visitMethod(access, name, desc, signature, exceptions); return new MethodVisitor(Opcodes.ASM5, v) { @Override public void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) { int i = index - 1; // if it is a static method, the first is the parameter // if it's not a static method, the first one is \"this\" and then the parameter of the method if (Modifier.isStatic(m.getModifiers())) { i = index; } if (i >= 0 && i < paramNames.length) { paramNames[i] = name; } super.visitLocalVariable(name, desc, signature, start, end, index); } }; } }, 0); METHOD_NAMES_POOL.put(m, paramNames); return paramNames; }\n\n    ### Response: get method param names\n\n@param m method\n@return return method param names.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void processSuperMethods() { for (ClassReader cr : targetClassInfo.superClassReaders) { cr.accept(new EmptyClassVisitor() { String declaredClassName; @Override public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) { declaredClassName = name; } @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { if (name.equals(INIT) || name.equals(CLINIT)) { return null; } MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName); if (msign == null) { return null; } return applyProxy(msign); } }, 0); } }\n\n    ### Response:", "ground_truth": "Checks for all public super methods that are not overridden.", "predict": " process super methods\n\n@param targetClassInfo class info\n@return process super methods."}, {"ID": 1019, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int binaryEmptySlotSearch() { int low = 0; int high = count; int mid = 0; int compare = 0; while (low < high) { mid = (low + high) / 2; compare = compare(mid); if (compare < 0) { high = mid; } else if (compare > 0) { low = mid + 1; } else { return -1; } } return low; }\n\n    ### Response: Returns the index of the lowest element > the given search target\nor count or -1 if target is found\n@return the index.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int findLast(int low, int high) { int ndx = -1; while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(mid); if (delta > 0) { high = mid - 1; } else { if (delta == 0) { ndx = mid; } low = mid + 1; } } if (ndx == -1) { return -(low + 1); } return ndx; }\n\n    ### Response:", "ground_truth": "Finds very last index of given element in inclusive index range. Returns negative\nvalue if element is not found.", "predict": " Returns the index of the last element in the range [low, high] that is less than or equal to the given search target, or -1 if no such element exists.\n@param low the lower bound of the range\n@param high the upper bound of the range\n@return the index of the last element that is less than or equal to the search target, or -1 if no such element exists."}, {"ID": 1020, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String fill( final String prefix, final String charSequence, final int times) { if (times < 1) { return \"\"; } StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix); } for (int i = 0; i < times; i++) { sb.append(charSequence); } return sb.toString(); }\n\n    ### Response: Create a string representation repeating a character\nsequence the requested number of times.\n@param prefix an optional prefix to prepend\n@param charSequence the character sequence to repeat\n@param times how many times the character sequence should be repeated\n@return a string filled with character sequence or empty string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String on(final String string) { if (!enabled) { return string; } final StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix).append(\"m\"); } sb.append(string); if (suffix != null) { sb.append(suffix).append(\"m\"); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns chalked string.", "predict": " Create a string representation with optional prefix and suffix.\n@param string the string to modify\n@return the modified string or the original string if disabled.\n\n    "}, {"ID": 1021, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) { Attribute[] attributes = getAttributePrototypes(); firstField = null; lastField = null; firstMethod = null; lastMethod = null; firstAttribute = null; compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING; return toByteArray(); }\n\n    ### Response: Returns the equivalent of the given class file, with the ASM specific instructions replaced\nwith standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) { final Attribute[] attributes = getAttributePrototypes(); firstField = null; lastField = null; firstMethod = null; lastMethod = null; lastRuntimeVisibleAnnotation = null; lastRuntimeInvisibleAnnotation = null; lastRuntimeVisibleTypeAnnotation = null; lastRuntimeInvisibleTypeAnnotation = null; moduleWriter = null; nestHostClassIndex = 0; numberOfNestMemberClasses = 0; nestMemberClasses = null; firstAttribute = null; compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING; new ClassReader(classFile, 0, /* checkClassVersion = */ false) .accept( this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS); return toByteArray(); }\n\n    ### Response:", "ground_truth": "Returns the equivalent of the given class file, with the ASM specific instructions replaced\nwith standard ones. This is done with a ClassReader -> ClassWriter round trip.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones.", "predict": " Replaces the ASM specific instructions in the given class file with standard ones.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones."}, {"ID": 1022, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getNamingContextName() { if (namingContextName == null) { Container parent = getParent(); if (parent == null) { namingContextName = getName(); } else { Stack<String> stk = new Stack<String>(); StringBuffer buff = new StringBuffer(); while (parent != null) { stk.push(parent.getName()); parent = parent.getParent(); } while (!stk.empty()) { buff.append(\"/\" + stk.pop()); } buff.append(getName()); namingContextName = buff.toString(); } } return namingContextName; }\n\n    ### Response: Get naming context full name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Attribute[] getAttributePrototypes() { Attribute.Set attributePrototypes = new Attribute.Set(); attributePrototypes.addAttributes(firstAttribute); FieldWriter fieldWriter = firstField; while (fieldWriter != null) { fieldWriter.collectAttributePrototypes(attributePrototypes); fieldWriter = (FieldWriter) fieldWriter.fv; } MethodWriter methodWriter = firstMethod; while (methodWriter != null) { methodWriter.collectAttributePrototypes(attributePrototypes); methodWriter = (MethodWriter) methodWriter.mv; } return attributePrototypes.toArray(); }\n\n    ### Response:", "ground_truth": "Returns the prototypes of the attributes used by this class, its fields and its methods.\n\n@return the prototypes of the attributes used by this class, its fields and its methods.", "predict": " Get attribute prototypes of the class."}, {"ID": 1023, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerDefaults() { register(Long.class, new LongConverter()); register(Integer.class, new IntegerConverter()); register(Short.class, new ShortConverter()); register(Byte.class, new ByteConverter()); register(Double.class, new DoubleConverter()); register(Float.class, new FloatConverter()); register(Character.class, new CharacterConverter()); register(Boolean.class, new BooleanConverter()); register(String.class, new StringConverter()); register(URL.class, new UrlConverter()); register(URI.class, new UriConverter()); register(Charset.class, new CharsetConverter()); register(File.class, new FileConverter()); register(Path.class, new PathConverter()); register(Locale.class, new LocaleConverter()); register(Pattern.class, new PatternConverter()); register(Long.TYPE, new LongConverter()); register(Integer.TYPE, new IntegerConverter()); register(Short.TYPE, new ShortConverter()); register(Byte.TYPE, new ByteConverter()); register(Character.TYPE, new CharacterConverter()); register(Double.TYPE, new DoubleConverter()); register(Float.TYPE, new FloatConverter()); register(Boolean.TYPE, new BooleanConverter()); }\n\n    ### Response: Register converters supported by default..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerDefaults() { register(Integer.class, IntegerSqlType.class); register(int.class, IntegerSqlType.class); register(MutableInteger.class, IntegerSqlType.class); register(Float.class, FloatSqlType.class); register(float.class, FloatSqlType.class); register(MutableFloat.class, FloatSqlType.class); register(Double.class, DoubleSqlType.class); register(double.class, DoubleSqlType.class); register(MutableDouble.class, DoubleSqlType.class); register(Byte.class, ByteSqlType.class); register(byte.class, ByteSqlType.class); register(MutableByte.class, ByteSqlType.class); register(Boolean.class, BooleanSqlType.class); register(boolean.class, BooleanSqlType.class); register(MutableBoolean.class, BooleanSqlType.class); register(Long.class, LongSqlType.class); register(long.class, LongSqlType.class); register(MutableLong.class, LongSqlType.class); register(Short.class, ShortSqlType.class); register(short.class, ShortSqlType.class); register(MutableShort.class, ShortSqlType.class); register(Character.class, CharacterSqlType.class); register(char.class, CharacterSqlType.class); register(BigDecimal.class, BigDecimalSqlType.class); register(BigInteger.class, BigIntegerSqlType.class); register(String.class, StringSqlType.class); register(LocalDateTime.class, LocalDateTimeSqlType.class); register(LocalDate.class, LocalDateSqlType.class); register(LocalTime.class, LocalTimeSqlType.class); register(Date.class, SqlDateSqlType.class); register(Timestamp.class, TimestampSqlType.class); register(Time.class, TimeSqlType.class); register(java.util.Date.class, DateSqlType.class); register(JulianDate.class, JulianDateSqlType.class); register(byte[].class, ByteArraySqlType.class); register(URL.class, URLSqlType.class); register(Blob.class, BlobSqlType.class); register(Clob.class, ClobSqlType.class); register(Array.class, SqlArraySqlType.class); register(Ref.class, SqlRefSqlType.class); }\n\n    ### Response:", "ground_truth": "Registers default set of SQL types.", "predict": " Register default SQL types for common Java types."}, {"ID": 1024, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:hiddenfield\") public <T, U extends T> void register(final Class<T> type, final Set<EventHandler<U>> handlers) { this.handlers.put(type, new ExceptionHandlingEventHandler<>( new BroadCastEventHandler<>(handlers), this.errorHandler)); }\n\n    ### Response: Register a new event handler.\n\n@param type     Message type to process with this handler.\n@param handlers A set of handlers that process that type of message.\n@param       Message type.\n@param       Type of message that event handler supports. Must be a subclass of T..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) { types.put(type, lookupSqlType(sqlTypeClass)); }\n\n    ### Response:", "ground_truth": "Registers sql type for provided type.", "predict": " Register a new SQL type.\n\n@param type            The class of the object that needs to be mapped to a SQL type.\n@param sqlTypeClass    The class of the SQL type to map to. Must be a subclass of SqlType."}, {"ID": 1025, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private CompiledStatement assignStatementArguments(CompiledStatement stmt) throws SQLException { boolean ok = false; try { if (limit != null) { // we use this if SQL statement LIMITs are not supported by this database type stmt.setMaxRows(limit.intValue()); } // set any arguments if we are logging our object Object[] argValues = null; if (logger.isLevelEnabled(Level.TRACE) && argHolders.length > 0) { argValues = new Object[argHolders.length]; } for (int i = 0; i < argHolders.length; i++) { Object argValue = argHolders[i].getSqlArgValue(); FieldType fieldType = argFieldTypes[i]; SqlType sqlType; if (fieldType == null) { sqlType = argHolders[i].getSqlType(); } else { sqlType = fieldType.getSqlType(); } stmt.setObject(i, argValue, sqlType); if (argValues != null) { argValues[i] = argValue; } } logger.debug(\"prepared statement '{}' with {} args\", statement, argHolders.length); if (argValues != null) { // need to do the (Object) cast to force args to be a single object logger.trace(\"prepared statement arguments: {}\", (Object) argValues); } ok = true; return stmt; } finally { if (!ok) { IOUtils.closeThrowSqlException(stmt, \"statement\"); } } }\n\n    ### Response: Assign arguments to the statement.\n\n@return The statement passed in or null if it had to be closed on error..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SqlType lookup(final Class clazz) { SqlType sqlType; for (Class x = clazz; x != null; x = x.getSuperclass()) { sqlType = types.get(clazz); if (sqlType != null) { return sqlType; } Class[] interfaces = x.getInterfaces(); for (Class i : interfaces) { sqlType = types.get(i); if (sqlType != null) { return sqlType; } } } return null; }\n\n    ### Response:", "ground_truth": "Retrieves SQL type for provided type. All subclasses and interfaces are examined\nfor matching sql type.", "predict": " Lookup the SQL type for a given class.\n\n@param clazz The class to lookup.\n@return The SQL type for the class or null if not found."}, {"ID": 1026, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private CompiledStatement assignStatementArguments(CompiledStatement stmt) throws SQLException { boolean ok = false; try { if (limit != null) { // we use this if SQL statement LIMITs are not supported by this database type stmt.setMaxRows(limit.intValue()); } // set any arguments if we are logging our object Object[] argValues = null; if (logger.isLevelEnabled(Level.TRACE) && argHolders.length > 0) { argValues = new Object[argHolders.length]; } for (int i = 0; i < argHolders.length; i++) { Object argValue = argHolders[i].getSqlArgValue(); FieldType fieldType = argFieldTypes[i]; SqlType sqlType; if (fieldType == null) { sqlType = argHolders[i].getSqlType(); } else { sqlType = fieldType.getSqlType(); } stmt.setObject(i, argValue, sqlType); if (argValues != null) { argValues[i] = argValue; } } logger.debug(\"prepared statement '{}' with {} args\", statement, argHolders.length); if (argValues != null) { // need to do the (Object) cast to force args to be a single object logger.trace(\"prepared statement arguments: {}\", (Object) argValues); } ok = true; return stmt; } finally { if (!ok) { IOUtils.closeThrowSqlException(stmt, \"statement\"); } } }\n\n    ### Response: Assign arguments to the statement.\n\n@return The statement passed in or null if it had to be closed on error..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) { SqlType sqlType = sqlTypes.get(sqlTypeClass); if (sqlType == null) { try { sqlType = ClassUtil.newInstance(sqlTypeClass); } catch (Exception ex) { throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex); } sqlTypes.put(sqlTypeClass, sqlType); } return sqlType; }\n\n    ### Response:", "ground_truth": "Returns sql type instance. Instances are stored for better performances.", "predict": " Looks up the SQL type for the given class.\n\n@param sqlTypeClass The SQL type class to lookup.\n@return The SQL type for the given class."}, {"ID": 1027, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProxyAuthenticator(final String proxyHost, final String proxyPort, final String proxyUser, final String decodedPwd) { if (proxyUser == null || proxyUser.isEmpty() || decodedPwd == null || decodedPwd.isEmpty()) { return; } //Authenticate proxy credentials Authenticator.setDefault(new Authenticator() { @Override public PasswordAuthentication getPasswordAuthentication() { if (getRequestorType() == RequestorType.PROXY) { if (getRequestingHost().equals(proxyHost) && getRequestingPort() == Integer.valueOf(proxyPort)) { return new PasswordAuthentication(proxyUser, decodedPwd.toCharArray()); } } return null; } }); }\n\n    ### Response: Set Proxy Authenticator Default\n\n@param proxyHost The proxy host\n@param proxyPort The proxy port\n@param proxyUser the proxy username\n@param decodedPwd the proxy password decoded.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null); }\n\n    ### Response:", "ground_truth": "Creates SOCKS4 proxy.", "predict": " Create a SOCKS4 Proxy Info\n\n@param proxyAddress The proxy address\n@param proxyPort The proxy port\n@param proxyUser The proxy username\n\n    "}, {"ID": 1028, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProxyAuthenticator(final String proxyHost, final String proxyPort, final String proxyUser, final String decodedPwd) { if (proxyUser == null || proxyUser.isEmpty() || decodedPwd == null || decodedPwd.isEmpty()) { return; } //Authenticate proxy credentials Authenticator.setDefault(new Authenticator() { @Override public PasswordAuthentication getPasswordAuthentication() { if (getRequestorType() == RequestorType.PROXY) { if (getRequestingHost().equals(proxyHost) && getRequestingPort() == Integer.valueOf(proxyPort)) { return new PasswordAuthentication(proxyUser, decodedPwd.toCharArray()); } } return null; } }); }\n\n    ### Response: Set Proxy Authenticator Default\n\n@param proxyHost The proxy host\n@param proxyPort The proxy port\n@param proxyUser the proxy username\n@param decodedPwd the proxy password decoded.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); }\n\n    ### Response:", "ground_truth": "Creates SOCKS5 proxy.", "predict": " Create a Socks5 Proxy Info\n\n@param proxyAddress The proxy address\n@param proxyPort The proxy port\n@param proxyUser The proxy username\n@param proxyPassword The proxy password\n\n    "}, {"ID": 1029, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setProxyAuthenticator(final String proxyHost, final String proxyPort, final String proxyUser, final String decodedPwd) { if (proxyUser == null || proxyUser.isEmpty() || decodedPwd == null || decodedPwd.isEmpty()) { return; } //Authenticate proxy credentials Authenticator.setDefault(new Authenticator() { @Override public PasswordAuthentication getPasswordAuthentication() { if (getRequestorType() == RequestorType.PROXY) { if (getRequestingHost().equals(proxyHost) && getRequestingPort() == Integer.valueOf(proxyPort)) { return new PasswordAuthentication(proxyUser, decodedPwd.toCharArray()); } } return null; } }); }\n\n    ### Response: Set Proxy Authenticator Default\n\n@param proxyHost The proxy host\n@param proxyPort The proxy port\n@param proxyUser the proxy username\n@param decodedPwd the proxy password decoded.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword); }\n\n    ### Response:", "ground_truth": "Creates HTTP proxy.", "predict": " Get HTTP Proxy Info\n\n@param proxyAddress The proxy address\n@param proxyPort The proxy port\n@param proxyUser The proxy username\n@param proxyPassword The proxy password\n\n    "}, {"ID": 1030, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int inconsistentCompare(MimeType o1, MimeType o2) { if ((o1 == null) && (o2 == null)) { return 0; } if (o1 == null) { return 1; } if (o2 == null) { return -1; } int wilchCharComparison = compareByWildCardCount(o1, o2); if (wilchCharComparison == 0) { float q1 = getQ(o1); float q2 = getQ(o2); if (q1 == q2) { return fallBackCompare(o1, o2); } if (q1 > q2) { return -1; } else { return 1; } } else { return wilchCharComparison; } }\n\n    ### Response: this is not consistent with equals\n\n@param o1\n@param o2\n@return a negative value if the quality of o1 is higher, a positive when it is lower, 0 otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int totalThreadTransactions() { ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { return 0; } return txList.size(); }\n\n    ### Response:", "ground_truth": "Returns total number of transactions associated with current thread.", "predict": " this method returns the total number of transactions in the current thread.\n\n@return the total number of transactions in the current thread."}, {"ID": 1031, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getThreadCount(ThreadGroup group, Status... s) { Thread[] threads = getThreads(group); int count = 0; for (Thread t : threads) { if (t instanceof MonitoredThread) { Status status = getStatus((MonitoredThread) t); if (status != null) { for (Status x : s) { if (x == status) { count++; } } } } } return count; }\n\n    ### Response: Return the count of threads that are in any of the statuses.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int totalThreadTransactionsWithStatus(final JtxStatus status) { ArrayList<JtxTransaction> txlist = txStack.get(); if (txlist == null) { return 0; } int count = 0; for (JtxTransaction tx : txlist) { if (tx.getStatus() == status) { count++; } } return count; }\n\n    ### Response:", "ground_truth": "Returns total number of transactions of the specified status associated with current thread.", "predict": " Return the total number of transactions in the current thread with the specified status."}, {"ID": 1032, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void addToCommittedQueue(Session session, Object[] list) { synchronized (committedTransactionTimestamps) { // add the txList according to commit timestamp committedTransactions.addLast(list); // get session commit timestamp committedTransactionTimestamps.addLast(session.actionTimestamp); /* debug 190 if (committedTransactions.size() > 64) { System.out.println(\"******* excessive transaction queue\"); } // debug 190 */ } }\n\n    ### Response: add a list of actions to the end of queue.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void associateTransaction(final JtxTransaction tx) { totalTransactions++; ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { txList = new ArrayList<>(); txStack.set(txList); } txList.add(tx); // add last }\n\n    ### Response:", "ground_truth": "Associate transaction to current thread.", "predict": " associate a transaction with the current thread.\n\n    "}, {"ID": 1033, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void check(Class clazz) { final Constructor<?>[] constructors = clazz.getDeclaredConstructors(); if (constructors.length > 1) { throw new AssertionError(clazz + \" has more than one constructor\"); } final Constructor<?> constructor = constructors[0]; constructor.setAccessible(true); if (!Modifier.isPrivate(constructor.getModifiers())) { throw new AssertionError(\"Constructor of \" + clazz + \" must be private\"); } final Class<?>[] parameterTypes = constructor.getParameterTypes(); if (parameterTypes.length > 0) { if (expectedParameters == null) { throw new AssertionError(clazz + \" has non-default constructor with some parameters\"); } else { if (!Arrays.equals(parameterTypes, expectedParameters)) { throw new AssertionError(\"Expected constructor with parameters \" + getReadableClassesOutput(expectedParameters) + \" but found constructor with parameters \" + getReadableClassesOutput(parameterTypes)); } else { return; } } } try { constructor.newInstance(); } catch (InstantiationException e) { throw new RuntimeException(\"Can not instantiate instance of \" + clazz, e); } catch (IllegalAccessException e) { // Fixed by setAccessible(true) throw new RuntimeException(e); } catch (InvocationTargetException e) { final Throwable cause = e.getCause(); // It's okay case if we expect some exception from this constructor if (expectedTypeOfException != null || expectedExceptionMessage != null) { if (expectedTypeOfException != null && !expectedTypeOfException.equals(cause.getClass())) { throw new IllegalStateException(\"For \" + clazz + \" expected exception of type = \" + expectedTypeOfException + \", but was exception of type = \" + e.getCause().getClass()); } if (expectedExceptionMessage != null && !expectedExceptionMessage.equals(cause.getMessage())) { throw new IllegalStateException(\"For \" + clazz + \" expected exception message = '\" + expectedExceptionMessage + \"', but was = '\" + cause.getMessage() + \"'\", e.getCause()); } // Everything is okay } else { throw new IllegalStateException(\"For \" + clazz + \" no exception was expected\", e); } } catch (IllegalArgumentException e) { throw new RuntimeException(\"Looks like constructor of \" + clazz + \" is not default\", e); } }\n\n    ### Response: Runs the check which will assert that particular class has one private constructor\nwhich throws or not throws exception.\n\n@param clazz class that needs to be checked..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) { if (!validateExistingTransaction) { return; } JtxTransactionMode sourceMode = sourceTx.getTransactionMode(); JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel(); if (destIsolationLevel != ISOLATION_DEFAULT) { JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel(); if (currentIsolationLevel != destIsolationLevel) { throw new JtxException(\"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel); } } if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) { throw new JtxException(\"Participating TX is not marked as read-only, but existing TX is\"); } }\n\n    ### Response:", "ground_truth": "Check if propagation of a transaction is possible, due to source and destination transaction modes.\n@see #setValidateExistingTransaction(boolean)", "predict": "This method is used to continue a transaction in a new mode. It checks if the existing transaction is valid and if the new mode is compatible with the existing mode. If the new mode is read-write and the existing mode is read-only, it throws an exception.\n\n@param sourceTx the transaction to be continued\n@param destMode the new transaction mode\n\n    "}, {"ID": 1034, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> Converter<T> find(Class<T> type) throws ConversionException { //noinspection unchecked Converter<T> converter = (Converter<T>) storage.get(type); if (converter == null) { if (type.isEnum()) { //noinspection unchecked return new EnumConverter((Class<? extends Enum>) type); } if (type.isArray()) { Class<?> componentType = type.getComponentType(); Converter childConverter = find(componentType); //noinspection unchecked return new ArrayConverter(childConverter, componentType, stringSplitter); } throw new ConversionException(String.format(\"Could not find converter for type <%s>\", type)); } return converter; }\n\n    ### Response: Find converter for given type. Returns null if converter doesn't exists..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; }\n\n    ### Response:", "ground_truth": "Lookups resource manager for provided type. Throws an exception if provider doesn't exists.", "predict": " Lookup resource manager for given resource type. Returns null if resource manager doesn't exists."}, {"ID": 1035, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T extends RemoteProxy> T getNewInstance( RegistrationRequest request, GridRegistry registry) { try { String proxyClass = request.getConfiguration().proxy; if (proxyClass == null) { log.fine(\"No proxy class. Using default\"); proxyClass = BaseRemoteProxy.class.getCanonicalName(); } Class<?> clazz = Class.forName(proxyClass); log.fine(\"Using class \" + clazz.getName()); Object[] args = new Object[]{request, registry}; Class<?>[] argsClass = new Class[]{RegistrationRequest.class, GridRegistry.class}; Constructor<?> c = clazz.getConstructor(argsClass); Object proxy = c.newInstance(args); if (proxy instanceof RemoteProxy) { ((RemoteProxy) proxy).setupTimeoutListener(); return (T) proxy; } throw new InvalidParameterException(\"Error: \" + proxy.getClass() + \" isn't a remote proxy\"); } catch (InvocationTargetException e) { throw new InvalidParameterException(\"Error: \" + e.getTargetException().getMessage()); } catch (Exception e) { throw new InvalidParameterException(\"Error: \" + e.getMessage()); } }\n\n    ### Response: Takes a registration request and return the RemoteProxy associated to it. It can be any class\nextending RemoteProxy.\n\n@param request  The request\n@param registry The registry to use\n@param  RemoteProxy subclass\n@return a new instance built from the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected C createProxyObject(Class<C> target) { target = ProxettaUtil.resolveTargetClass(target); Class proxyClass = cache.get(target); if (proxyClass == null) { proxyClass = proxetta.defineProxy(target); cache.put(target, proxyClass); } C proxy; try { proxy = (C) ClassUtil.newInstance(proxyClass); } catch (Exception ex) { throw new PathrefException(ex); } return proxy; }\n\n    ### Response:", "ground_truth": "Creates proxy object.", "predict": " Creates a proxy object for the given target class.\n\n@param target The target class\n@return a proxy object for the given target class.\n\n    "}, {"ID": 1036, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String path(String repoPath, boolean withIndex) { String path = repoPath.substring(workspaceName(repoPath).length()); if (path.length() > 0) { if (!withIndex) { return TextUtil.removeIndexFromPath(path); } return path; } return \"/\"; }\n\n    ### Response: Extracts path from repository path.\n\n@param repoPath repository path\n@param withIndex indicates whether the index must be removed or not\n@return path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void append(final String methodName) { if (path.length() != 0) { path += StringPool.DOT; } if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) { path = StringUtil.substring(path, 0, -1); } path += methodName; }\n\n    ### Response:", "ground_truth": "Appends method name to existing path.", "predict": " Appends method name to the path.\n\n@param methodName method name to append\n@return void."}, {"ID": 1037, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String randomString(final int size) { final StringBuilder builder = new StringBuilder(); while (builder.length() < size) { final String suffix = java.util.UUID.randomUUID().toString().replace(\"-\", \"\"); builder.append(suffix); } return builder.substring(0, size); }\n\n    ### Response: Return a random string of a certain size.\n\n@param size the size\n@return the random size.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String alignLeftAndPad(final String text, final int size) { int textLength = text.length(); if (textLength > size) { return text.substring(0, size); } final StringBuilder sb = new StringBuilder(size); sb.append(text); while (textLength++ < size) { sb.append(' '); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Puts the text to the left and pads with spaces until the size is reached.", "predict": " Aligns the left side of the text with the left side of the size and pads the remaining space with spaces.\n\n@param text the text to be aligned and padded\n@param size the size of the resulting string\n@return the aligned and padded string."}, {"ID": 1038, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String enumToString(final Enum<?> value) { if (value == null) { return null; } final String underscored = value.name(); final StringBuilder sb = new StringBuilder(); for (int i = 0; i < underscored.length(); i++) { final char c = underscored.charAt(i); if (c == '_') { sb.append(Character.toUpperCase(underscored.charAt(++i))); } else { sb.append(Character.toLowerCase(c)); } } return sb.toString(); }\n\n    ### Response: Convert an enumeration to a String representation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toPrettyString(final Object value) { if (value == null) { return StringPool.NULL; } final Class<?> type = value.getClass(); if (type.isArray()) { final Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { final StringBuilder sb = new StringBuilder(); sb.append('['); if (componentType == int.class) { sb.append(ArraysUtil.toString((int[]) value)); } else if (componentType == long.class) { sb.append(ArraysUtil.toString((long[]) value)); } else if (componentType == double.class) { sb.append(ArraysUtil.toString((double[]) value)); } else if (componentType == float.class) { sb.append(ArraysUtil.toString((float[]) value)); } else if (componentType == boolean.class) { sb.append(ArraysUtil.toString((boolean[]) value)); } else if (componentType == short.class) { sb.append(ArraysUtil.toString((short[]) value)); } else if (componentType == byte.class) { sb.append(ArraysUtil.toString((byte[]) value)); } else { throw new IllegalArgumentException(); } sb.append(']'); return sb.toString(); } else { final StringBuilder sb = new StringBuilder(); sb.append('['); final Object[] array = (Object[]) value; for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(array[i])); } sb.append(']'); return sb.toString(); } } else if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final StringBuilder sb = new StringBuilder(); sb.append('{'); int i = 0; for (final Object o : iterable) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(o)); i++; } sb.append('}'); return sb.toString(); } return value.toString(); }\n\n    ### Response:", "ground_truth": "Converts object into pretty string. All arrays are iterated.", "predict": " Convert an object to a pretty string representation."}, {"ID": 1039, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceCrLfTab(final String str) { if (str == null) { return null; } final int len = str.length(); final StringBuilder sb = new StringBuilder(); int i = 0; while (i < len) { final char ch = str.charAt(i++); if (ch == '\\\\') { if (i < len) { final char next = str.charAt(i); final Character replacement = SPECIAL_CHAR_REPLACEMENT_MAP.get(next); if (replacement != null) { sb.append(replacement); i++; } else { sb.append(ch); } } else { sb.append(ch); } } else { sb.append(ch); } } return sb.toString(); }\n\n    ### Response: Replaces the strings \"\\r\", \"\\n\" and \"\\t\" with \"carriage return\", \"new line\" and \"tab\" character.\n\n@param str\nString to replace or null.\n\n@return Replaced string or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) { final int length = input.length(); final StringBuilder sb = new StringBuilder(length); boolean upperCase = firstCharUppercase; for (int i = 0; i < length; i++) { final char ch = input.charAt(i); if (ch == separator) { upperCase = true; } else if (upperCase) { sb.append(Character.toUpperCase(ch)); upperCase = false; } else { sb.append(ch); } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Converts separated string value to CamelCase.", "predict": " Converts a string to camel case.\n\n@param input\nString to convert.\n\n@param firstCharUppercase\nIf true, the first character of the resulting string will be uppercase.\n\n@param separator\nSeparator character.\n\n@return Camel case string."}, {"ID": 1040, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parse() { template = text; if (StringUtils.isEmptyTrimmed(template)) return; int index = 0; while (template.indexOf(\"${\") != -1) { int from = template.lastIndexOf(\"${\"); int to = template.indexOf(\"}\", from + 2); if (to == -1) { template = text; complex = false; entities.clear(); return; } int dv = template.indexOf(\":\", from + 2); if (dv != -1 && dv > to) { dv = -1; } String systemProperty = null; String defaultValue = null; String s = template.substring(from + 2, to); if (\"/\".equals(s)) { systemProperty = File.separator; } else if (\":\".equals(s)) { systemProperty = File.pathSeparator; dv = -1; } else { systemProperty = SecurityActions.getSystemProperty(s); } if (dv != -1) { s = template.substring(from + 2, dv); systemProperty = SecurityActions.getSystemProperty(s); defaultValue = template.substring(dv + 1, to); } String prefix = \"\"; String postfix = \"\"; String key = StringUtils.createKey(index++); updateComplex(defaultValue); entities.put(key, new Expression(s, defaultValue, systemProperty)); if (from != 0) { prefix = template.substring(0, from); } if (to + 1 < template.length()) { postfix = template.substring(to + 1); } template = prefix + key + postfix; } updateComplex(template); }\n\n    ### Response: Parse a text and get a template and expression entities.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) { StringBuilder str = new StringBuilder(); int total = src.length(); int from = 0; while (from < total) { int to = from + len; if (to >= total) { to = total; } else if (breakOnWhitespace) { int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from); if (ndx != -1) { to = ndx + 1; } } int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to); if (cutFrom != -1) { int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1; str.append(src, cutFrom, cutTo); } str.append('\\n'); from = to; } return str.toString(); }\n\n    ### Response:", "ground_truth": "Formats provided string as paragraph.", "predict": " Format a paragraph of text into lines of a given length.\n\n    "}, {"ID": 1041, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String interpolate() { getValues(); if (definition == null) { return \"\"; } int variableStart = definition.indexOf(\"{\"); if (variableStart < 0) { return definition; } int index = 0; int variableEnd = 0; StringBuilder sb = new StringBuilder(); while (variableStart >= 0) { sb.append(definition.substring(variableEnd, variableStart)); variableEnd = getIndexForEndOfVariable(definition, variableStart) + 1; variableStart = definition.indexOf(\"{\", variableEnd); sb.append(values.get(index++).getValue()); } if (variableEnd < definition.length()) { sb.append(definition.substring(variableEnd)); } return sb.toString(); }\n\n    ### Response: This will strip off any \"{\" stuff, substituting values accordingly.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String convertTabsToSpaces(final String line, final int tabWidth) { int tab_index, tab_size; int last_tab_index = 0; int added_chars = 0; if (tabWidth == 0) { return StringUtil.remove(line, '\\t'); } StringBuilder result = new StringBuilder(); while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) { tab_size = tabWidth - ((tab_index + added_chars) % tabWidth); if (tab_size == 0) { tab_size = tabWidth; } added_chars += tab_size - 1; result.append(line, last_tab_index, tab_index); result.append(StringUtil.repeat(' ', tab_size)); last_tab_index = tab_index+1; } if (last_tab_index == 0) { return line; } result.append(line.substring(last_tab_index)); return result.toString(); }\n\n    ### Response:", "ground_truth": "Converts all tabs on a line to spaces according to the provided tab width.\nThis is not a simple tab to spaces replacement, since the resulting\nindentation remains the same.", "predict": " This method takes a line of text and replaces any instances of the tab character with the appropriate number of spaces to maintain the desired tab width."}, {"ID": 1042, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String escapeJavaScriptChars(String s) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); switch (ch) { case '\\b': sb.append(\"\\\\b\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\f': sb.append(\"\\\\f\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\"': sb.append(\"\\\\\\\"\"); break; case '\\'': sb.append(\"\\\\\\'\"); break; case '\\\\': sb.append(\"\\\\\\\\\"); break; default: if (ch < 32 || ch >= 127) { sb.append(String.format(\"\\\\u%04X\", (int)ch)); } else { sb.append(ch); } break; } } return sb.toString(); }\n\n    ### Response: Returns a String with escaped special JavaScript characters.\n\n@param s String that needs to be escaped\n@return a valid escaped JavaScript string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String escapeJava(final String string) { int strLen = string.length(); StringBuilder sb = new StringBuilder(strLen); for (int i = 0; i < strLen; i++) { char c = string.charAt(i); switch (c) { case '\\b' : sb.append(\"\\\\b\"); break; case '\\t' : sb.append(\"\\\\t\"); break; case '\\n' : sb.append(\"\\\\n\"); break; case '\\f' : sb.append(\"\\\\f\"); break; case '\\r' : sb.append(\"\\\\r\"); break; case '\\\"' : sb.append(\"\\\\\\\"\"); break; case '\\\\' : sb.append(\"\\\\\\\\\"); break; default: if ((c < 32) || (c > 127)) { String hex = Integer.toHexString(c); sb.append(\"\\\\u\"); for (int k = hex.length(); k < 4; k++) { sb.append('0'); } sb.append(hex); } else { sb.append(c); } } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Escapes a string using java rules.", "predict": " Escapes special Java characters in a given string.\n\n@param string String that needs to be escaped\n@return a valid escaped Java string."}, {"ID": 1043, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String nextString() { nextClean('\"'); StringBuilder sb = new StringBuilder(); for (;;) { char c = next(); switch (c) { case 0: case '\\n': case '\\r': throw syntaxError(\"Unterminated string\"); case '\\\\': c = next(); switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case 'u': sb.append((char)Integer.parseInt(next(4), 16)); break; default: sb.append(c); } break; case '\"': return sb.toString(); default: if (c < ' ') { throw syntaxError(\"Unescaped control character (ascii \" + ((int) c) + \") in string\"); } sb.append(c); break; } } }\n\n    ### Response: Return the characters up to the next close quote character.\nBackslash processing is done. The formal JSON format does not\nallow strings in single quotes, but an implementation is allowed to\naccept them.\n@return      A String..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String unescapeJava(final String str) { char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(str.length()); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c != '\\\\') { sb.append(c); continue; } i++; c = chars[i]; switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\\\"'); break; case '\\\\': sb.append('\\\\'); break; case 'u' : char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16); sb.append(hex); i += 4; break; default: throw new IllegalArgumentException(\"Invalid escaping character: \" + c); } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Unescapes a string using java rules.", "predict": " Unescape a Java string literal.\n@param str  The string to unescape.\n@return     The unescaped string.\n\n    "}, {"ID": 1044, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(final Class<T> type) { T bean = (T) components.get(type); if (bean != null) { return bean; } return (T) get(type.getName()); }\n\n    ### Response: Get component or bean by type.\n\n@param \n@param type\n@return Component.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final Class<T> type) { String name = resolveBeanName(type); return (T) getBean(name); }\n\n    ### Response:", "ground_truth": "Returns Petite bean instance. Bean name will be resolved from provided type.", "predict": " Get component or bean by type.\n\n@param \n@param type\n@return Component."}, {"ID": 1045, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(final Class<T> type) { T bean = (T) components.get(type); if (bean != null) { return bean; } return (T) get(type.getName()); }\n\n    ### Response: Get component or bean by type.\n\n@param \n@param type\n@return Component.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getBean(final String name) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name); if (def == null) { // try provider ProviderDefinition providerDefinition = providers.get(name); if (providerDefinition != null) { return (T) invokeProvider(providerDefinition); } return null; } // Find the bean in its scope Object bean = def.scopeLookup(); if (bean == null) { // Create new bean in the scope initBeanDefinition(def); final BeanData beanData = new BeanData(this, def); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData); bean = beanData.bean(); } return (T) bean; }\n\n    ### Response:", "ground_truth": "Returns Petite bean instance.\nPetite container will find the bean in corresponding scope and all its dependencies,\neither by constructor or property injection. When using constructor injection, cyclic dependencies\ncan not be prevented, but at least they are detected.\n\n@see PetiteContainer#createBean(Class)", "predict": " Get a bean by name.\n\n@param \n@param name\n@return Bean."}, {"ID": 1046, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:npathcomplexity\") public void setFrom(SARLConfiguration config) { if (this.input == null) { this.input = config.getInput(); } if (this.output == null) { this.output = config.getOutput(); } if (this.binOutput == null) { this.binOutput = config.getBinOutput(); } if (this.testInput == null) { this.testInput = config.getTestInput(); } if (this.testOutput == null) { this.testOutput = config.getTestOutput(); } if (this.testBinOutput == null) { this.testBinOutput = config.getTestBinOutput(); } if (this.inputCompliance == null) { this.inputCompliance = config.getInputCompliance(); } if (this.outputCompliance == null) { this.outputCompliance = config.getOutputCompliance(); } if (this.encoding == null) { this.encoding = config.getEncoding(); } }\n\n    ### Response: Set the uninitialized field with given configuration.\n\n@param config the configured values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initBeanDefinition(final BeanDefinition def) { // init methods if (def.initMethods == null) { def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type); } // destroy methods if (def.destroyMethods == null) { def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type); } // properties if (def.properties == null) { def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // methods if (def.methods == null) { def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type); } // ctors if (def.ctor == null) { def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type); } // values if (def.values == null) { def.values = paramManager.resolveParamInjectionPoints(def.type); } // sets if (def.sets == null) { def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // params if (def.params == null) { def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters()); } }\n\n    ### Response:", "ground_truth": "Resolves and initializes bean definition. May be called multiple times.", "predict": " Initialize the bean definition with the given petite configuration.\n\n@param def the bean definition to initialize."}, {"ID": 1047, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getBeanPropertyValue(final String property, final Object bean) { if (bean == null) { return null; } if (\".\".equals(property)) { return bean; } try { Object data = PropertyUtils.getProperty(bean, property); return data; } catch (Exception e) { LOG.error(\"Failed to get bean property \" + property + \" on \" + bean, e); return null; } }\n\n    ### Response: Get the bean property value.\n\n@param property the bean property\n@param bean the bean\n@return the bean property value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeProvider(final ProviderDefinition provider) { if (provider.method != null) { final Object bean; if (provider.beanName != null) { // instance factory method bean = getBean(provider.beanName); } else { // static factory method bean = null; } try { return provider.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid provider method: \" + provider.method.getName(), ex); } } throw new PetiteException(\"Invalid provider\"); }\n\n    ### Response:", "ground_truth": "Invokes provider to get a bean.", "predict": " Invoke the provider.\n\n@param provider the provider definition\n@return the provider result\n\n    "}, {"ID": 1048, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void dequeueIfNotDoneYet(Element elem, String name, Object object) { @SuppressWarnings(\"rawtypes\") Queue queue = queue(elem, name, null); if (queue != null && object.equals(queue.peek())) { dequeueCurrentAndRunNext(elem, name); } }\n\n    ### Response: Dequeue the object and run the next if it is the first\nin the queue..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addBean(final String name, final Object bean, WiringMode wiringMode) { wiringMode = petiteConfig.resolveWiringMode(wiringMode); registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null); BeanDefinition def = lookupExistingBeanDefinition(name); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean)); }\n\n    ### Response:", "ground_truth": "Adds object instance to the container as singleton bean.", "predict": " Add a bean to the container with the given name and bean instance. The wiring mode will be resolved using the Petite configuration. If the bean already exists, it will be replaced. The bean will be registered as a singleton. If the bean has constructor parameters or field injection points, they will be resolved and injected. Finally, any initialization methods will be invoked."}, {"ID": 1049, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void doUpdateBeanValue(final Object value) { String beanProperty = getBeanProperty(); if (beanProperty != null && beanProperty.length() > 0 && !\".\".equals(beanProperty)) { Object bean = getBean(); if (bean != null) { try { Object beanValue = getBeanValue(); if (!Util.equals(beanValue, value)) { PropertyUtils.setProperty(bean, beanProperty, value); } } catch (Exception e) { LOG.error(\"Failed to set bean property \" + beanProperty + \" on \" + bean); } } } }\n\n    ### Response: Updates the bean value with the new value.\n\n@param value the new value with which to update the bean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setBeanProperty(final String name, final Object value) { Object bean = null; int ndx = name.length(); while (true) { ndx = name.lastIndexOf('.', ndx); if (ndx == -1) { break; } String beanName = name.substring(0, ndx); bean = getBean(beanName); if (bean != null) { break; } ndx--; } if (bean == null) { throw new PetiteException(\"Invalid bean property: \" + name); } try { BeanUtil.declared.setProperty(bean, name.substring(ndx + 1), value); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } }\n\n    ### Response:", "ground_truth": "Sets petite bean property.", "predict": " Sets the value of a property on a bean.\n\n@param name the name of the property to set.\n@param value the new value to set on the property."}, {"ID": 1050, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object put(String name, Object value) { if (bean != null) { Object oldValue = get(name); Method method = getWriteMethod(name); if (method == null) { throw new IllegalArgumentException(\"The bean of type: \" + bean.getClass().getName() + \" has no property called: \" + name); } try { Object[] arguments = createWriteMethodArguments(method, value); method.invoke(bean, arguments); Object newValue = get(name); firePropertyChange(name, oldValue, newValue); } catch (InvocationTargetException e) { throw new IllegalArgumentException(e.getMessage()); } catch (IllegalAccessException e) { throw new IllegalArgumentException(e.getMessage()); } return oldValue; } return null; }\n\n    ### Response: Sets the bean property with the given name to the given value.\n\n@param name  the name of the property to set\n@param value the value to set that property to\n@return the previous value of that property.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getBeanProperty(final String name) { int ndx = name.indexOf('.'); if (ndx == -1) { throw new PetiteException(\"Only bean name is specified, missing property name: \" + name); } String beanName = name.substring(0, ndx); Object bean = getBean(beanName); if (bean == null) { throw new PetiteException(\"Bean doesn't exist: \" + name); } try { return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1)); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } }\n\n    ### Response:", "ground_truth": "Returns petite bean property value.", "predict": " Gets the bean property with the given name.\n\n@param name  the name of the property to get\n@return the value of that property.\n\n    "}, {"ID": 1051, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clear() { for (Bean bean : beans.values()) { if (null != bean.destructionCallback) { bean.destructionCallback.run(); } } beans.clear(); }\n\n    ### Response: Clear all beans and call the destruction callback..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void shutdown() { scopes.forEachValue(Scope::shutdown); externalsCache.clear(); beans.clear(); beansAlt.clear(); scopes.clear(); providers.clear(); beanCollections.clear(); }\n\n    ### Response:", "ground_truth": "Shutdowns container. After container is down, it can't be used anymore.", "predict": " Shutdown all beans, scopes, and caches."}, {"ID": 1052, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static List<BitextRule> getAllBuiltinBitextRules(Language language, ResourceBundle messages) { List<BitextRule> rules = new ArrayList<>(); try { List<Class<? extends BitextRule>> classes = BitextRule.getRelevantRules(); for (Class class1 : classes) { Constructor[] constructors = class1.getConstructors(); boolean foundConstructor = false; for (Constructor constructor : constructors) { Class[] paramTypes = constructor.getParameterTypes(); if (paramTypes.length == 0) { rules.add((BitextRule) constructor.newInstance()); foundConstructor = true; break; } if (paramTypes.length == 1 && paramTypes[0].equals(ResourceBundle.class)) { rules.add((BitextRule) constructor.newInstance(messages)); foundConstructor = true; break; } if (paramTypes.length == 2 && paramTypes[0].equals(ResourceBundle.class) && paramTypes[1].equals(Language.class)) { rules.add((BitextRule) constructor.newInstance(messages, language)); foundConstructor = true; break; } } if (!foundConstructor) { throw new RuntimeException(\"Unknown constructor type for rule class \" + class1.getName() + \", it supports only these constructors: \" + Arrays.toString(constructors)); } } } catch (Exception e) { throw new RuntimeException(\"Failed to load bitext rules\", e); } return rules; }\n\n    ### Response: Use reflection to add bitext rules..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) { Class[] paramTypes; Class declaringClass; String name; if (methodOrCtor instanceof Method) { Method method = (Method) methodOrCtor; paramTypes = method.getParameterTypes(); name = method.getName(); declaringClass = method.getDeclaringClass(); } else { Constructor constructor = (Constructor) methodOrCtor; paramTypes = constructor.getParameterTypes(); declaringClass = constructor.getDeclaringClass(); name = CTOR_METHOD; } if (paramTypes.length == 0) { return MethodParameter.EMPTY_ARRAY; } InputStream stream; try { stream = ClassLoaderUtil.getClassAsStream(declaringClass); } catch (IOException ioex) { throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex); } if (stream == null) { throw new ParamoException(\"Class not found: \" + declaringClass); } try { ClassReader reader = new ClassReader(stream); MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes); reader.accept(visitor, 0); return visitor.getResolvedParameters(); } catch (IOException ioex) { throw new ParamoException(ioex); } finally { StreamUtil.close(stream); } }\n\n    ### Response:", "ground_truth": "Resolves method parameters from a method or constructor.\nReturns an empty array when target does not contain any parameter.\nNo caching is involved in this process, i.e. class bytecode\nis examined every time this method is called.", "predict": " This method uses reflection to resolve the parameters of a method or constructor. It first determines the parameter types and the declaring class of the method or constructor. It then attempts to load the class bytes from the classloader and create a ClassReader to read the class file. The MethodFinder class is a custom class that extends ClassVisitor and visits each method and constructor in the class file. When it finds the method or constructor with the same name and parameter types as the input method or constructor, it resolves the parameters and returns them as a MethodParameter array. If the method or constructor has no parameters, it returns an empty MethodParameter array."}, {"ID": 1053, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final int doAfterBody() throws JspException { // Use the body of the tag as input for the date BodyContent body = getBodyContent(); String s = body.getString().trim(); // Clear the body since we will output only the formatted date body.clearBody(); if (output_date == null) { long time; try { time = Long.valueOf(s).longValue(); output_date = new Date(time); } catch (NumberFormatException nfe) {} } return SKIP_BODY; }\n\n    ### Response: Method called at end of format tag body.\n\n@return SKIP_BODY.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int doAfterBody() throws JspException { BodyContent body = getBodyContent(); JspWriter out = body.getEnclosingWriter(); String bodytext = populateForm(body.getString(), name -> value(name, pageContext)); try { out.print(bodytext); } catch (IOException ioex) { throw new JspException(ioex); } return SKIP_BODY; }\n\n    ### Response:", "ground_truth": "Performs smart form population.", "predict": " Method called at end of format tag body.\n\n@return SKIP_BODY."}, {"ID": 1054, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Collection<QProfileDto> selectDescendants(DbSession dbSession, Collection<QProfileDto> profiles) { if (profiles.isEmpty()) { return emptyList(); } Collection<QProfileDto> children = selectChildren(dbSession, profiles); List<QProfileDto> descendants = new ArrayList<>(children); descendants.addAll(selectDescendants(dbSession, children)); return descendants; }\n\n    ### Response: All descendants, in any order. The specified profiles are not included into results..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getValue(final String... profiles) { if (hasMacro) { return propsData.resolveMacros(value, profiles); } return value; }\n\n    ### Response:", "ground_truth": "Returns the property value, with replaced macros.", "predict": " Returns the value of the property. If the property has a macro, it will be resolved using the specified profiles."}, {"ID": 1055, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void clearReferences() { // Unregister any JDBC drivers loaded by this classloader Enumeration drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { Driver driver = (Driver) drivers.nextElement(); if (driver.getClass().getClassLoader() == this) { try { DriverManager.deregisterDriver(driver); } catch (SQLException e) { log.warn(\"SQL driver deregistration failed\", e); } } } // Null out any static or final fields from loaded classes, // as a workaround for apparent garbage collection bugs if (ENABLE_CLEAR_REFERENCES) { Iterator loadedClasses = ((HashMap)((HashMap) resourceEntries).clone()).values().iterator(); while (loadedClasses.hasNext()) { ResourceEntry entry = (ResourceEntry) loadedClasses.next(); if (entry.loadedClass != null) { Class clazz = entry.loadedClass; try { Field[] fields = clazz.getDeclaredFields(); for (int i = 0; i < fields.length; i++) { Field field = fields[i]; int mods = field.getModifiers(); if (field.getType().isPrimitive() || (field.getName().indexOf(\"$\") != -1)) { continue; } if (Modifier.isStatic(mods)) { try { field.setAccessible(true); if (Modifier.isFinal(mods)) { if (!((field.getType().getName().startsWith(\"java.\")) || (field.getType().getName().startsWith(\"javax.\")))) { nullInstance(field.get(null)); } } else { field.set(null, null); if (log.isDebugEnabled()) { log.debug(\"Set field \" + field.getName() + \" to null in class \" + clazz.getName()); } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(\"Could not set field \" + field.getName() + \" to null in class \" + clazz.getName(), t); } } } } } catch (Throwable t) { if (log.isDebugEnabled()) { log.debug(\"Could not clean fields for class \" + clazz.getName(), t); } } } } } // Clear the IntrospectionUtils cache. IntrospectionUtils.clear(); // Clear the classloader reference in common-logging org.apache.juli.logging.LogFactory.release(this); // Clear the classloader reference in the VM's bean introspector java.beans.Introspector.flushCaches(); }\n\n    ### Response: Clear references..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void end() { if (parentNode != rootNode) { Node thisNode = parentNode; while (thisNode != rootNode) { if (domBuilder.config.isImpliedEndTags()) { if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) { thisNode = thisNode.getParentNode(); continue; } } error(\"Unclosed tag closed: <\" + thisNode.getNodeName() + \">\"); thisNode = thisNode.getParentNode(); } } // remove whitespaces if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } // foster if (domBuilder.config.isUseFosterRules()) { HtmlFosterRules fosterRules = new HtmlFosterRules(); fosterRules.fixFosterElements(rootNode); } // elapsed rootNode.end(); if (log.isDebugEnabled()) { log.debug(\"LagartoDom tree created in \" + rootNode.getElapsedTime() + \" ms\"); } }\n\n    ### Response:", "ground_truth": "Finishes the tree building. Closes unclosed tags.", "predict": " Ends the parsing process."}, {"ID": 1056, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasSisterTagAfter(Tag tag, String nameToFind) { Body body = (Body) tag.getParent(); List<Statement> stats = body.getStatements(); Iterator<Statement> it = stats.iterator(); Statement other; boolean isAfter = false; while (it.hasNext()) { other = it.next(); if (other instanceof Tag) { if (isAfter) { if (((Tag) other).getTagLibTag().getName().equals(nameToFind)) return true; } else if (other == tag) isAfter = true; } } return false; }\n\n    ### Response: Prueft ob das das angegebene Tag in der gleichen Ebene nach dem angegebenen Tag vorkommt.\n\n@param tag Ausgangspunkt, nach diesem tag darf das angegebene nicht vorkommen.\n@param nameToFind Tag Name der nicht vorkommen darf\n@return kommt das Tag vor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Element createElementNode(final Tag tag) { boolean hasVoidTags = htmlVoidRules != null; boolean isVoid = false; boolean selfClosed = false; if (hasVoidTags) { isVoid = htmlVoidRules.isVoidTag(tag.getName()); // HTML and XHTML if (isVoid) { // it's void tag, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } } else { // XML, no voids, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } return new Element(rootNode, tag, isVoid, selfClosed); }\n\n    ### Response:", "ground_truth": "Creates new element with correct configuration.", "predict": " Erstellt einen neuen Elementknoten f\u00fcr das angegebene Tag.\n\n@param tag Das Tag f\u00fcr den neuen Elementknoten.\n@return Den neuen Elementknoten."}, {"ID": 1057, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Node getNextParentNodeWithAttr(final Node parent, final String attrName) { Node parentNode = parent; Element parendElement = (Element) parentNode; Node valueNode = parendElement.getAttributes().getNamedItem(attrName); while (valueNode == null) { parentNode = parentNode.getParentNode(); if (parentNode != null) { if (parentNode.getNodeType() == Node.ELEMENT_NODE) { parendElement = (Element) parentNode; valueNode = parendElement.getAttributes().getNamedItem(attrName); } } else { break; } } return parendElement; }\n\n    ### Response: Returns the next parent node which has the specific attribute name defined.\n\n@param parent\nthe w3c node from which the search will start.\n@param attrName\nthe attribute name which is searched for.\n@return a parent node, if the attribute is found, otherwise null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void tag(final Tag tag) { if (!enabled) { return; } TagType tagType = tag.getType(); Element node; switch (tagType) { case START: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); if (domBuilder.config.isImpliedEndTags()) { while (true) { String parentNodeName = parentNode.getNodeName(); if (!implRules.implicitlyCloseParentTagOnNewTag(parentNodeName, node.getNodeName())) { break; } parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + node.getNodeName() + \"> \"); } } } parentNode.addChild(node); if (!node.isVoidElement()) { parentNode = node; } break; case END: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } String tagName = tag.getName().toString(); Node matchingParent = findMatchingParentOpenTag(tagName); if (matchingParent == parentNode) { // regular situation parentNode = parentNode.getParentNode(); break; } if (matchingParent == null) { // matching open tag not found, remove it error(\"Orphan closed tag ignored: </\" + tagName + \"> \" + tag.getTagPosition()); break; } // try to close it implicitly if (domBuilder.config.isImpliedEndTags()) { boolean fixed = false; while (implRules.implicitlyCloseParentTagOnTagEnd(parentNode.getNodeName(), tagName)) { parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + tagName + \">\"); } if (parentNode == matchingParent) { parentNode = matchingParent.parentNode; fixed = true; break; } } if (fixed) { break; } } // matching tag found, but it is not a regular situation // therefore close all unclosed tags in between fixUnclosedTagsUpToMatchingParent(tag, matchingParent); break; case SELF_CLOSING: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); parentNode.addChild(node); break; } }\n\n    ### Response:", "ground_truth": "Visits tags.", "predict": " This method is responsible for processing the incoming tag. It is called by the DOMBuilder when a new tag is encountered. The tag is processed based on its type and the current state of the DOM tree. The method uses a switch statement to determine the type of the tag and then processes it accordingly.\n\n@param tag\nthe tag to be processed.\n\n    "}, {"ID": 1058, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node previousNode() { if (currentNode == null) return null; // get sibling Node result = getPreviousSibling(currentNode); if (result == null) { result = getParentNode(currentNode); if (result != null) { currentNode = result; return result; } return null; } // get the lastChild of result. Node lastChild = getLastChild(result); Node prev = lastChild; while (lastChild != null) { prev = lastChild; lastChild = getLastChild(prev); } lastChild = prev; // if there is a lastChild which passes filters return it. if (lastChild != null) { currentNode = lastChild; return lastChild; } // otherwise return the previous sibling. currentNode = result; return result; }\n\n    ### Response: Return the previous Node from the current node, after applying filter,\nwhatToshow. If result is not null, set the current Node..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) { if (parentNode == null) { return; } Node lastChild = parentNode.getLastChild(); if (lastChild == null) { return; } if (lastChild.getNodeType() != Node.NodeType.TEXT) { return; } if (closedTag) { if (parentNode.getChildNodesCount() == 1) { return; } } Text text = (Text) lastChild; if (text.isBlank()) { lastChild.detachFromParent(); } }\n\n    ### Response:", "ground_truth": "Removes last child node if contains just empty text.", "predict": " Remove the last child node of the parent node if it is a text node and it is empty or if the parent node is a closed tag and it has only one child node."}, {"ID": 1059, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final boolean complies(final String value, final String constValue, final String separators) { if (value == null) { return false; } else { final StringTokenizer tok = new StringTokenizer(value, separators); while (tok.hasMoreTokens()) { final String t = tok.nextToken(); if (t.equals(constValue)) { return true; } } return false; } }\n\n    ### Response: Helper method for subclasses to do the comparation.\n\n@param value\nObject that contains the property.\n@param constValue\nValue to compare with.\n@param separators\nSeparators\n\n@return If object property contains the value as one of the tokens TRUE else FALSE..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getQueryString() { if (sqlTemplate == null) { return toString(); } if (parameterValues == null) { return sqlTemplate; } final StringBuilder sb = new StringBuilder(); int qMarkCount = 0; final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', \"?\"); while (tok.hasMoreTokens()) { final String oneChunk = tok.nextToken(); sb.append(oneChunk); try { Object value = null; if (parameterValues.size() > 1 + qMarkCount) { value = parameterValues.get(1 + qMarkCount); qMarkCount++; } else { if (!tok.hasMoreTokens()) { value = \"\"; } } if (value == null) { value = \"?\"; } sb.append(value); } catch (Throwable th) { sb.append(\"--- Building query failed: \").append(th.toString()); } } return sb.toString().trim(); }\n\n    ### Response:", "ground_truth": "Returns the query string.", "predict": " Returns the query string with the parameter values replaced with actual values.\n\n@return The query string with parameter values replaced with actual values."}, {"ID": 1060, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getType(final WComponent component) { for (Class<?> clazz = component.getClass(); clazz != null && WComponent.class. isAssignableFrom(clazz); clazz = clazz.getSuperclass()) { if (\"com.github.bordertech.wcomponents\".equals(clazz.getPackage().getName())) { return clazz.getName(); } } return null; }\n\n    ### Response: Tries to return the type of component.\n\n@param component the component to determine the type of.\n@return the component type, or null if the given component is not a core component..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getActionClassName(final Object action) { Class clazz = action.getClass(); clazz = ProxettaUtil.resolveTargetClass(clazz); return clazz.getName(); }\n\n    ### Response:", "ground_truth": "Returns correct action class name. Detects Proxetta classes.", "predict": " Tries to return the class name of the given action.\n\n@param action the action to determine the class name of.\n@return the class name of the action, or null if the given action is null."}, {"ID": 1061, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean setGroupCountSize(int count, int size) { if (count <= 0 || size <= 0) { return false; } m_groupcount_ = count; m_groupsize_ = size; return true; }\n\n    ### Response: Sets the number of group and size of each group in number of char\n@param count number of groups\n@param size size of group in char\n@return true if group size is set correctly.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int calculateTo(final int from, final int count, final int size) { int to = size; if (count != -1) { to = from + count; if (to > size) { to = size; } } return to; }\n\n    ### Response:", "ground_truth": "Calculates 'TO'.", "predict": " Calculates the end index of the range based on the start index, count and size of each group.\n@param from start index of the range\n@param count number of groups\n@param size size of group in char\n@return end index of the range."}, {"ID": 1062, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceCrLfTab(final String str) { if (str == null) { return null; } final int len = str.length(); final StringBuilder sb = new StringBuilder(); int i = 0; while (i < len) { final char ch = str.charAt(i++); if (ch == '\\\\') { if (i < len) { final char next = str.charAt(i); final Character replacement = SPECIAL_CHAR_REPLACEMENT_MAP.get(next); if (replacement != null) { sb.append(replacement); i++; } else { sb.append(ch); } } else { sb.append(ch); } } else { sb.append(ch); } } return sb.toString(); }\n\n    ### Response: Replaces the strings \"\\r\", \"\\n\" and \"\\t\" with \"carriage return\", \"new line\" and \"tab\" character.\n\n@param str\nString to replace or null.\n\n@return Replaced string or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); Iterator iter = collection.iterator(); int i = 0; int to = calculateTo(from, count, collection.size()); while (i < to) { Object item = iter.next(); if (i >= from) { if (status != null) { iteratorStatus.next(!iter.hasNext()); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } i++; } }\n\n    ### Response:", "ground_truth": "Iterates collection.", "predict": "Iterates over a collection and executes the body of the tag for each item in the specified range.\n\n@param collection\nCollection to iterate over.\n\n@param from\nIndex of the first item to process.\n\n@param count\nNumber of items to process.\n\n@param pageContext\nCurrent page context.\n\n@throws JspException\nIf an error occurs during processing.\n\n    "}, {"ID": 1063, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String createSpan(final List<String> lemmas, final int from, final int to) { String lemmaSpan = \"\"; for (int i = from; i < to; i++) { lemmaSpan += lemmas.get(i) + \"_\"; } lemmaSpan += lemmas.get(to); return lemmaSpan; }\n\n    ### Response: Create lemma span for search of multiwords in MFS dictionary.\n\n@param lemmas\nthe lemmas of the sentence\n@param from\nthe starting index\n@param to\nthe end index\n@return the string representing a perhaps multi word entry.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); int len = array.length; int to = calculateTo(from, count, len); int last = to - 1; for (int i = from; i < to; i++) { Object item = array[i]; if (status != null) { iteratorStatus.next(i == last); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } }\n\n    ### Response:", "ground_truth": "Iterates arrays.", "predict": " Iterates over an array of objects and executes the body of the tag for each object.\n\n@param array\nthe array of objects to iterate over\n@param from\nthe starting index\n@param count\nthe number of objects to iterate over\n@param pageContext\nthe page context\n@throws JspException\nif an error occurs during iteration\n\n    "}, {"ID": 1064, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String normalize(final CharSequence self) { final String s = self.toString(); int nx = s.indexOf('\\r'); if (nx < 0) { return s; } final int len = s.length(); final StringBuilder sb = new StringBuilder(len); int i = 0; do { sb.append(s, i, nx); sb.append('\\n'); if ((i = nx + 1) >= len) break; if (s.charAt(i) == '\\n') { // skip the LF in CR LF if (++i >= len) break; } nx = s.indexOf('\\r', i); } while (nx > 0); sb.append(s, i, len); return sb.toString(); }\n\n    ### Response: Return a String with linefeeds and carriage returns normalized to linefeeds.\n\n@param self a CharSequence object\n@return the normalized toString() for the CharSequence\n@see #normalize(String)\n@since 1.8.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replace(final String s, final String sub, final String with) { if (sub.isEmpty()) { return s; } int c = 0; int i = s.indexOf(sub, c); if (i == -1) { return s; } int length = s.length(); StringBuilder sb = new StringBuilder(length + with.length()); do { sb.append(s, c, i); sb.append(with); c = i + sub.length(); } while ((i = s.indexOf(sub, c)) != -1); if (c < length) { sb.append(s, c, length); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a certain pattern in a string with a\nreplacement string. This is the fastest replace function known to author.\n\n@param s      string to be inspected\n@param sub    string pattern to be replaced\n@param with   string that should go where the pattern was", "predict": " Replace all occurrences of a substring with another substring in a string.\n\n@param s the string to search in\n@param sub the substring to search for\n@param with the replacement substring\n@return the resulting string with all occurrences of sub replaced with with\n@since 1.8.2."}, {"ID": 1065, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int indexOf(final char ch, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (startIndex >= size) { return -1; } final char[] thisBuf = buffer; for (int i = startIndex; i < size; i++) { if (thisBuf[i] == ch) { return i; } } return -1; }\n\n    ### Response: Searches the string builder to find the first reference to the specified char.\n\n@param ch  the character to find\n@param startIndex  the index to start at, invalid index rounded to edge\n@return the first index of the character, or -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceChar(final String s, final char sub, final char with) { int startIndex = s.indexOf(sub); if (startIndex == -1) { return s; } char[] str = s.toCharArray(); for (int i = startIndex; i < str.length; i++) { if (str[i] == sub) { str[i] = with; } } return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a character in a string.\n\n@param s      input string\n@param sub    character to replace\n@param with   character to replace with", "predict": "Replaces all occurrences of a character in a string with another character.\n\n@param s  the string to modify\n@param sub  the character to replace\n@param with  the character to replace with\n@return the modified string\n\n    "}, {"ID": 1066, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String characterPad(final String s, final int fieldLength, final char padChar, final boolean postpend) { final char[] chArr = s.toCharArray(); final int sLen = chArr.length; if (sLen < fieldLength) { final char[] out = new char[fieldLength]; final int blanks = fieldLength - sLen; if (postpend) { for (int i = 0; i < sLen; i++) { out[i] = chArr[i]; } for (int i = sLen; i < fieldLength; i++) { out[i] = padChar; } } else { //prepend for (int i = 0; i < blanks; i++) { out[i] = padChar; } for (int i = blanks; i < fieldLength; i++) { out[i] = chArr[i - blanks]; } } return String.valueOf(out); } return s; }\n\n    ### Response: Prepend or postpend the given string with the given character to fill the given field length.\nIf the given string is equal or greater than the given field length, it will be returned\nwithout modification.\n@param s the given string\n@param fieldLength the desired field length\n@param padChar the desired pad character\n@param postpend if true append the pacCharacters to the end of the string.\n@return prepended or postpended given string with the given character to fill the given field\nlength..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceChars(final String s, final char[] sub, final char[] with) { char[] str = s.toCharArray(); for (int i = 0; i < str.length; i++) { char c = str[i]; for (int j = 0; j < sub.length; j++) { if (c == sub[j]) { str[i] = with[j]; break; } } } return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a characters in a string.\n\n@param s      input string\n@param sub    characters to replace\n@param with   characters to replace with", "predict": " Replace all occurrences of the characters in the sub array with the characters in the with array in the given string.\n@param s the given string\n@param sub the characters to be replaced\n@param with the characters to replace with\n@return the modified string with replaced characters."}, {"ID": 1067, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replace(String s, String sub, String with) { int c=0; int i=s.indexOf(sub,c); if (i == -1) return s; StringBuffer buf = new StringBuffer(s.length()+with.length()); synchronized(buf) { do { buf.append(s.substring(c,i)); buf.append(with); c=i+sub.length(); } while ((i=s.indexOf(sub,c))!=-1); if (c<s.length()) buf.append(s.substring(c,s.length())); return buf.toString(); } }\n\n    ### Response: replace substrings within string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceFirst(final String s, final String sub, final String with) { int i = s.indexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); }\n\n    ### Response:", "ground_truth": "Replaces the very first occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": " replace the first occurrence of substring within string."}, {"ID": 1068, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static final String trimFirstWord(String s) { s = s.trim(); char[] chars = s.toCharArray(); int firstSpace = -1; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (Character.isWhitespace(c)) { firstSpace = i; break; } } if (firstSpace == -1) { return s; } s = s.substring(firstSpace).trim(); s = capitalize(s); return s; }\n\n    ### Response: Trims off the first word of the specified string and capitalizes the\nnew first word.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceFirst(final String s, final char sub, final char with) { int index = s.indexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces the very first occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": " Replaces the first occurrence of the specified character in the specified string with the specified replacement character.\n\n    "}, {"ID": 1069, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replace(String s, String sub, String with) { int c=0; int i=s.indexOf(sub,c); if (i == -1) return s; StringBuffer buf = new StringBuffer(s.length()+with.length()); synchronized(buf) { do { buf.append(s.substring(c,i)); buf.append(with); c=i+sub.length(); } while ((i=s.indexOf(sub,c))!=-1); if (c<s.length()) buf.append(s.substring(c,s.length())); return buf.toString(); } }\n\n    ### Response: replace substrings within string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceLast(final String s, final String sub, final String with) { int i = s.lastIndexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); }\n\n    ### Response:", "ground_truth": "Replaces the very last occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": " replaces the last occurrence of a substring within a string."}, {"ID": 1070, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static final String trimFirstWord(String s) { s = s.trim(); char[] chars = s.toCharArray(); int firstSpace = -1; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (Character.isWhitespace(c)) { firstSpace = i; break; } } if (firstSpace == -1) { return s; } s = s.substring(firstSpace).trim(); s = capitalize(s); return s; }\n\n    ### Response: Trims off the first word of the specified string and capitalizes the\nnew first word.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceLast(final String s, final char sub, final char with) { int index = s.lastIndexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces the very last occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": " Replaces the last occurrence of the specified character in the specified string with the specified replacement character.\n\n    "}, {"ID": 1071, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String normalize(final CharSequence self) { final String s = self.toString(); int nx = s.indexOf('\\r'); if (nx < 0) { return s; } final int len = s.length(); final StringBuilder sb = new StringBuilder(len); int i = 0; do { sb.append(s, i, nx); sb.append('\\n'); if ((i = nx + 1) >= len) break; if (s.charAt(i) == '\\n') { // skip the LF in CR LF if (++i >= len) break; } nx = s.indexOf('\\r', i); } while (nx > 0); sb.append(s, i, len); return sb.toString(); }\n\n    ### Response: Return a String with linefeeds and carriage returns normalized to linefeeds.\n\n@param self a CharSequence object\n@return the normalized toString() for the CharSequence\n@see #normalize(String)\n@since 1.8.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String remove(final String s, final String sub) { int c = 0; int sublen = sub.length(); if (sublen == 0) { return s; } int i = s.indexOf(sub, c); if (i == -1) { return s; } StringBuilder sb = new StringBuilder(s.length()); do { sb.append(s, c, i); c = i + sublen; } while ((i = s.indexOf(sub, c)) != -1); if (c < s.length()) { sb.append(s, c, s.length()); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Removes all substring occurrences from the string.\n\n@param s      source string\n@param sub    substring to remove", "predict": " Remove all occurrences of the specified substring from the specified string.\n\n@param s the string to be modified\n@param sub the substring to be removed\n@return the resulting string\n@since 1.8.2."}, {"ID": 1072, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String trimLeadingWhitespace(String string) { if (string.isEmpty()) { return string; } int start = 0; char c; for (int i = 0; i < string.length(); i++) { c = string.charAt(i); if (!Character.isWhitespace(c)) { start = i; break; } } if (start == 0) { return string; } return string.substring(start); }\n\n    ### Response: Returns a string that contains a copy of a specified string\nwithout leading whitespaces.\n\n@param string the string to trim leading whitespaces\n@return a string with leading whitespaces trimmed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String remove(final String string, final char ch) { int stringLen = string.length(); char[] result = new char[stringLen]; int offset = 0; for (int i = 0; i < stringLen; i++) { char c = string.charAt(i); if (c == ch) { continue; } result[offset] = c; offset++; } if (offset == stringLen) { return string; // no changes } return new String(result, 0, offset); }\n\n    ### Response:", "ground_truth": "Removes a single character from string.\n\n@param string    source string\n@param ch  character to remove", "predict": " Removes all occurrences of a specified character from a string.\n\n@param string the string to remove characters from\n@param ch the character to remove\n@return a string with all occurrences of the specified character removed."}, {"ID": 1073, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean allEquals(final String value, final String... strings) { if (strings != null) { for (final String s : strings) { if (s == null && value != null || s != null && !s.equals(value)) { return false; } } } else { return value == null; } return true; }\n\n    ### Response: Return true if all strings are the same..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAllEmpty(final String... strings) { for (String string : strings) { if (!isEmpty(string)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Determines if string array contains empty strings.\n@see #isEmpty(CharSequence)", "predict": " Return true if all strings are empty."}, {"ID": 1074, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean allEquals(final String value, final String... strings) { if (strings != null) { for (final String s : strings) { if (s == null && value != null || s != null && !s.equals(value)) { return false; } } } else { return value == null; } return true; }\n\n    ### Response: Return true if all strings are the same..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAllBlank(final String... strings) { for (String string : strings) { if (!isBlank(string)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Determines if string array contains just blank strings.", "predict": " Return true if all strings are blank."}, {"ID": 1075, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static TypedConstant getConstant(Object value) { if (value == null) { return CstKnownNull.THE_ONE; } else if (value instanceof Boolean) { return CstBoolean.make((Boolean) value); } else if (value instanceof Byte) { return CstByte.make((Byte) value); } else if (value instanceof Character) { return CstChar.make((Character) value); } else if (value instanceof Double) { return CstDouble.make(Double.doubleToLongBits((Double) value)); } else if (value instanceof Float) { return CstFloat.make(Float.floatToIntBits((Float) value)); } else if (value instanceof Integer) { return CstInteger.make((Integer) value); } else if (value instanceof Long) { return CstLong.make((Long) value); } else if (value instanceof Short) { return CstShort.make((Short) value); } else if (value instanceof String) { return new CstString((String) value); } else if (value instanceof Class) { return new CstType(TypeId.get((Class<?>) value).ropType); } else if (value instanceof TypeId) { return new CstType(((TypeId) value).ropType); } else { throw new UnsupportedOperationException(\"Not a constant: \" + value); } }\n\n    ### Response: Returns a rop constant for the specified value.\n\n@param value null, a boxed primitive, String, Class, or TypeId..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toStringArray(final Object value) { if (value == null) { return new String[0]; } Class<?> type = value.getClass(); if (!type.isArray()) { return new String[] {value.toString()}; } Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { if (componentType == int.class) { return ArraysUtil.toStringArray((int[]) value); } else if (componentType == long.class) { return ArraysUtil.toStringArray((long[]) value); } else if (componentType == double.class) { return ArraysUtil.toStringArray((double[]) value); } else if (componentType == float.class) { return ArraysUtil.toStringArray((float[]) value); } else if (componentType == boolean.class) { return ArraysUtil.toStringArray((boolean[]) value); } else if (componentType == short.class) { return ArraysUtil.toStringArray((short[]) value); } else if (componentType == byte.class) { return ArraysUtil.toStringArray((byte[]) value); } else { throw new IllegalArgumentException(); } } else { return ArraysUtil.toStringArray((Object[]) value); } }\n\n    ### Response:", "ground_truth": "Converts an array object to array of strings, where every element\nof input array is converted to a string. If input is not an array,\nthe result will still be an array with one element.", "predict": " Converts the specified value to a String array.\n\n@param value null, a boxed primitive array, or an Object array."}, {"ID": 1076, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String trimLeadingWhitespace(String string) { if (string.isEmpty()) { return string; } int start = 0; char c; for (int i = 0; i < string.length(); i++) { c = string.charAt(i); if (!Character.isWhitespace(c)) { start = i; break; } } if (start == 0) { return string; } return string.substring(start); }\n\n    ### Response: Returns a string that contains a copy of a specified string\nwithout leading whitespaces.\n\n@param string the string to trim leading whitespaces\n@return a string with leading whitespaces trimmed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String changeFirstCharacterCase(final boolean capitalize, final String string) { int strLen = string.length(); if (strLen == 0) { return string; } char ch = string.charAt(0); char modifiedCh; if (capitalize) { modifiedCh = Character.toUpperCase(ch); } else { modifiedCh = Character.toLowerCase(ch); } if (modifiedCh == ch) { // no change, return unchanged string return string; } char[] chars = string.toCharArray(); chars[0] = modifiedCh; return new String(chars); }\n\n    ### Response:", "ground_truth": "Internal method for changing the first character case.", "predict": " Returns a string that contains a copy of a specified string\nwith the first character capitalized or lowercase, depending on the value of the\ncapitalize parameter.\n\n@param capitalize true to capitalize the first character, false to lowercase\n@param string the string to modify the first character case\n@return a string with the first character modified according to the capitalize parameter."}, {"ID": 1077, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String removeEnclosedCurlyBraces( String str ) { final char curlyReplacement = 6; char[] chars = str.toCharArray(); int open = 0; for ( int i = 0; i < chars.length; i++ ) { if ( chars[i] == '{' ) { if ( open != 0 ) chars[i] = curlyReplacement; open++; } else if ( chars[i] == '}' ) { open--; if ( open != 0 ) { chars[i] = curlyReplacement; } } } char[] res = new char[chars.length]; int j = 0; for( int i = 0; i < chars.length; i++ ) { if( chars[i] != curlyReplacement ) { res[j++] = chars[i]; } } return new String( Arrays.copyOf( res, j ) ); }\n\n    ### Response: Enclosed curly braces cannot be matched with a regex. Thus we remove them before applying the replaceAll method.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUtil.isWhitespace(c)) { wasWhitespace = true; } else { if (wasWhitespace) { chars[i] = Character.toUpperCase(c); } else { chars[i] = Character.toLowerCase(c); } wasWhitespace = false; } } return new String(chars); }\n\n    ### Response:", "ground_truth": "Makes a title-cased string from given input.", "predict": " This method takes a string as input and returns the string with the first letter of each word capitalized and the rest of the letters in lowercase. It uses the CharUtil class to check if a character is whitespace or not."}, {"ID": 1078, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String normalize(String s) { StringBuilder sb = new StringBuilder(); boolean changed = false; boolean lastCharWasWS = false; final int len = s.length(); for (int i = 0; i < len; i++) { char c = s.charAt(i); if (Character.isWhitespace(c)) { if (!lastCharWasWS) { sb.append(SPACE); changed |= c != SPACE; } else { changed = true; } lastCharWasWS = true; } else { sb.append(c); lastCharWasWS = false; } } return changed ? sb.toString() : s; }\n\n    ### Response: Normalize a string.\n\n\"normalized\" in this context means all whitespace characters\nare replaced by space characters and consecutive whitespace\ncharacaters are collapsed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String compressChars(final String s, final char c) { int len = s.length(); StringBuilder sb = new StringBuilder(len); boolean wasChar = false; for (int i = 0; i < len; i++) { char c1 = s.charAt(i); if (c1 == c) { if (wasChar) { continue; } wasChar = true; } else { wasChar = false; } sb.append(c1); } if (sb.length() == len) { return s; } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Compress multiple occurrences of given char into one appearance.", "predict": " Compress a string by replacing all occurrences of a character with a single occurrence.\n\n\"compressed\" in this context means all occurrences of a character\nare replaced by a single occurrence."}, {"ID": 1079, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOfIgnoreCase(final String str, final String searchStr) {// NOSONAR if (searchStr.isEmpty() || str.isEmpty()) { return str.indexOf(searchStr); } for (int i = 0; i < str.length(); ++i) { if (i + searchStr.length() > str.length()) { return -1; } int j = 0; int ii = i; while (ii < str.length() && j < searchStr.length()) { char c = Character.toLowerCase(str.charAt(ii)); char c2 = Character.toLowerCase(searchStr.charAt(j)); if (c != c2) { break; } j++; ii++; } if (j == searchStr.length()) { return i; } } return -1; }\n\n    ### Response: Return first postion ignore case, return -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) { String sub = subS.toLowerCase(); int sublen = sub.length(); if (startIndex + sublen > src.length()) { return false; } int j = 0; int i = startIndex; while (j < sublen) { char source = Character.toLowerCase(src.charAt(i)); if (sub.charAt(j) != source) { return false; } j++; i++; } return true; }\n\n    ### Response:", "ground_truth": "Tests if this string starts with the specified prefix with ignored case\nand with the specified prefix beginning a specified index.\n\n@param src        source string to test\n@param subS       starting substring\n@param startIndex index from where to test\n\n@return true if the character sequence represented by the argument is\na prefix of the character sequence represented by this string;\nfalse otherwise.", "predict": " Check if the source string starts with the substring ignoring case.\n\n    "}, {"ID": 1080, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean isArgument(final String fragment) { String s = fragment.trim(); if (s.length() > 0) { return s.charAt(s.length() - 1) != COBOL_DELIMITER; } return false; }\n\n    ### Response: Examine characters before an assumed level. If these characters are not\nterminated by a COBOL delimiter then the level is actually an argument to\na previous keyword, not an actual level.\n\n@param fragment a fragment of code preceding an assumed level\n@return true if the assumed level is an argument.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean endsWithChar(final String s, final char c) { if (s.length() == 0) { return false; } return s.charAt(s.length() - 1) == c; }\n\n    ### Response:", "ground_truth": "Returns if string ends with provided character.", "predict": " Determines if a string ends with a specified character.\n\n@param s the string to check\n@param c the character to look for\n@return true if the string ends with the specified character, false otherwise."}, {"ID": 1081, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int countOccurrencesOf(String str, String sub) { if (str == null || sub == null || str.length() == 0 || sub.length() == 0) { return 0; } int count = 0; int pos = 0; int idx; while ((idx = str.indexOf(sub, pos)) != -1) { ++count; pos = idx + sub.length(); } return count; }\n\n    ### Response: Count the occurrences of the substring in string s.\n\n@param str string to search in. Return 0 if this is null.\n@param sub string to search for. Return 0 if this is null.\n@return The number of occurrences.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int countIgnoreCase(final String source, final String sub) { int count = 0; int j = 0; int sublen = sub.length(); if (sublen == 0) { return 0; } while (true) { int i = indexOfIgnoreCase(source, sub, j); if (i == -1) { break; } count++; j = i + sublen; } return count; }\n\n    ### Response:", "ground_truth": "Count substring occurrences in a source string, ignoring case.\n\n@param source\tsource string\n@param sub\t\tsubstring to count\n@return\t\t\tnumber of substring occurrences", "predict": " Count the occurrences of the substring in string s, ignoring case.\n\n@param source string to search in. Return 0 if this is null.\n@param sub string to search for. Return 0 if this is null.\n@return The number of occurrences.\n\n    "}, {"ID": 1082, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean containsContentType(String contentType, String[] allowedContentTypes) { if (allowedContentTypes == null) { return false; } for (int i = 0; i < allowedContentTypes.length; i++) { if (allowedContentTypes[i].indexOf(contentType) != -1) { return true; } } return false; }\n\n    ### Response: Indicate if the passes content type match one of the options passed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsIgnoreCase(final String[] as, final String[] as1) { if (as.length != as1.length) { return false; } for (int i = 0; i < as.length; i++) { if (!as[i].equalsIgnoreCase(as1[i])) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Compares two string arrays.\n\n@param as     first string array\n@param as1    second string array\n\n@return true if all array elements matches", "predict": " Compares two arrays of strings, ignoring case differences."}, {"ID": 1083, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int indexOf(final String s, final char searchChar, final int beginIndex, final int endIndex) { for (int i = beginIndex; i < endIndex; i++) { if (s.charAt(i) == searchChar) { return i; } } return -1; }\n\n    ### Response: Returns the index within the specified string of the first occurrence of the specified search\ncharacter.\n\n@param s the string to search\n@param searchChar the character to search for\n@param beginIndex the index at which to start the search\n@param endIndex the index at which to stop the search\n@return the index of the first occurrence of the character in the string or -1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOfWhitespace(final String string, final int startindex, final int endindex) { for (int i = startindex; i < endindex; i++) { if (CharUtil.isWhitespace(string.charAt(i))) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Returns first index of a whitespace character, starting from specified index offset.", "predict": " Returns the index within the specified string of the first occurrence of a whitespace character.\n\n@param string the string to search\n@param startindex the index at which to start the search\n@param endindex the index at which to stop the search\n@return the index of the first occurrence of a whitespace character in the string or -1."}, {"ID": 1084, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Transformer public static String lowerFirst(Object o) { if (null == o) return \"\"; String string = o.toString(); if (string.length() == 0) { return string; } return (\"\" + string.charAt(0)).toLowerCase() + string.substring(1); }\n\n    ### Response: Make the first character be lowercase of the given object's string representation\n\n@param o\n@return the string result.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripLeadingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(0) == c) { return string.substring(1); } } return string; }\n\n    ### Response:", "ground_truth": "Strips leading char if string starts with one.", "predict": " Remove the leading character c from the given string if it exists.\n\n@param string\n@param c\n@return the string result."}, {"ID": 1085, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String removeTrailing(String string, char c) { if(string == null) { return null; } final int lastCharIndex = string.length() - 1; return string.charAt(lastCharIndex) == c ? string.substring(0, lastCharIndex) : string; }\n\n    ### Response: Remove trailing character, if exists.\n\n@param string source string,\n@param c trailing character to eliminate.\n@return source string guaranteed to not end in requested character..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripTrailingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(string.length() - 1) == c) { return string.substring(0, string.length() - 1); } } return string; }\n\n    ### Response:", "ground_truth": "Strips trailing char if string ends with one.", "predict": " Remove trailing character, if exists.\n\n@param string source string,\n@param c trailing character to eliminate.\n@return source string guaranteed to not end in requested character."}, {"ID": 1086, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int scopeString2Int(boolean ignoreScope, String type) { type = StringUtil.toLowerCase(type); char c = type.charAt(0); // ignore scope only handles only reconize local,arguments as scope, the rest is ignored if (ignoreScope) { if ('a' == c) { if (\"arguments\".equals(type)) return Scope.SCOPE_ARGUMENTS; } else if ('l' == c) { if (\"local\".equals(type)) return Scope.SCOPE_LOCAL;// LLL } else if ('r' == c) { if (\"request\".equals(type)) return Scope.SCOPE_REQUEST; } else if ('v' == c) { if (\"variables\".equals(type)) return Scope.SCOPE_VARIABLES; } else if ('s' == c) { if (\"server\".equals(type)) return Scope.SCOPE_SERVER; } return Scope.SCOPE_UNDEFINED; } if ('a' == c) { if (\"application\".equals(type)) return Scope.SCOPE_APPLICATION; else if (\"arguments\".equals(type)) return Scope.SCOPE_ARGUMENTS; } else if ('c' == c) { if (\"cgi\".equals(type)) return Scope.SCOPE_CGI; if (\"cookie\".equals(type)) return Scope.SCOPE_COOKIE; if (\"client\".equals(type)) return Scope.SCOPE_CLIENT; if (\"cluster\".equals(type)) return Scope.SCOPE_CLUSTER; } else if ('f' == c) { if (\"form\".equals(type)) return Scope.SCOPE_FORM; } else if ('l' == c) { if (\"local\".equals(type)) return Scope.SCOPE_LOCAL;// LLL } else if ('r' == c) { if (\"request\".equals(type)) return Scope.SCOPE_REQUEST; } else if ('s' == c) { if (\"session\".equals(type)) return Scope.SCOPE_SESSION; if (\"server\".equals(type)) return Scope.SCOPE_SERVER; } else if ('u' == c) { if (\"url\".equals(type)) return Scope.SCOPE_URL; } else if ('v' == c) { if (\"variables\".equals(type)) return Scope.SCOPE_VARIABLES; } return Scope.SCOPE_UNDEFINED; }\n\n    ### Response: translate a string type definition to its int representation\n\n@param type type to translate\n@return int representation matching to given string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripChar(final String string, final char c) { if (string.length() == 0) { return string; } if (string.length() == 1) { if (string.charAt(0) == c) { return StringPool.EMPTY; } return string; } int left = 0; int right = string.length(); if (string.charAt(left) == c) { left++; } if (string.charAt(right - 1) == c) { right--; } return string.substring(left, right); }\n\n    ### Response:", "ground_truth": "Strips leading and trailing char from given string.", "predict": " remove all occurrences of a given character from a string\n\n@param string string to remove character from\n@param c character to remove\n@return string with all occurrences of c removed."}, {"ID": 1087, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripToChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(ndx); }\n\n    ### Response:", "ground_truth": "Strips everything up to the first appearance of given char.\nCharacter IS included in the returned string.", "predict": " Strip the string to the first occurrence of the specified character.\n\n@param string the string to be stripped\n@param c the character to be stripped\n@return the stripped string\n\n    "}, {"ID": 1088, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripFromChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(0, ndx); }\n\n    ### Response:", "ground_truth": "Strips everything from the first appearance of given char.\nCharacter IS NOT included in the returned string.", "predict": " Strip the specified character from the beginning of the string.\n\n@param string the string to strip from\n@param c the character to strip\n@return the stripped string\n\n    "}, {"ID": 1089, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] trimArray(String[] strings) { for (int i = 0; i < strings.length; i++) { strings[i] = strings[i].trim(); } return strings; }\n\n    ### Response: Trims all elements inside the array, modifying the original array.\n\n@param strings The string array\n@return The passed string array, trimmed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cropAll(final String... strings) { for (int i = 0; i < strings.length; i++) { String string = strings[i]; if (string != null) { string = crop(strings[i]); } strings[i] = string; } }\n\n    ### Response:", "ground_truth": "Crops all elements of string array.", "predict": " Crops all elements inside the array, modifying the original array.\n\n@param strings The string array\n@return The passed string array, cropped."}, {"ID": 1090, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String ltrim(String str, String defaultValue) { if (str == null) return defaultValue; int len = str.length(); int st = 0; while ((st < len) && (str.charAt(st) <= ' ')) { st++; } return ((st > 0)) ? str.substring(st) : str; }\n\n    ### Response: This function returns a string with whitespace stripped from the beginning of str\n\n@param str String to clean\n@return cleaned String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String trimLeft(final String src) { int len = src.length(); int st = 0; while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) { st++; } return st > 0 ? src.substring(st) : src; }\n\n    ### Response:", "ground_truth": "Trim whitespaces from the left.", "predict": " This function returns a string with whitespace stripped from the beginning of src\n\n@param src String to clean\n@return cleaned String."}, {"ID": 1091, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String rtrim(String str, String defaultValue) { if (str == null) return defaultValue; int len = str.length(); while ((0 < len) && (str.charAt(len - 1) <= ' ')) { len--; } return (len < str.length()) ? str.substring(0, len) : str; }\n\n    ### Response: This function returns a string with whitespace stripped from the end of str\n\n@param str String to clean\n@return cleaned String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String trimRight(final String src) { int len = src.length(); int count = len; while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) { len--; } return (len < count) ? src.substring(0, len) : src; }\n\n    ### Response:", "ground_truth": "Trim whitespaces from the right.", "predict": " This function returns a string with whitespace stripped from the end of src\n\n@param src String to clean\n@return cleaned String."}, {"ID": 1092, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) { int ndx = offset; int[] res = new int[4]; ndx = string.indexOf(leftBoundary, ndx); if (ndx == -1) { return null; } res[0] = ndx; ndx += leftBoundary.length(); res[1] = ndx; ndx = string.indexOf(rightBoundary, ndx); if (ndx == -1) { return null; } res[2] = ndx; res[3] = ndx + rightBoundary.length(); return res; }\n\n    ### Response:", "ground_truth": "Returns indexes of the first region without escaping character.\n@see #indexOfRegion(String, String, String, char, int)", "predict": " Find the index of the left and right boundaries in the string starting from the given offset.  Return an array of four integers representing the start and end indices of the left and right boundaries, respectively.  If either boundary is not found, return null.\n\n@param string the string to search in\n@param leftBoundary the left boundary to search for\n@param rightBoundary the right boundary to search for\n@param offset the starting offset in the string\n@return an array of four integers representing the start and end indices of the left and right boundaries, respectively, or null if either boundary is not found."}, {"ID": 1093, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String uppercaseToUnderscore(final String str) { if (str == null) { return null; } final StringBuffer sb = new StringBuffer(); for (int i = 0; i < str.length(); i++) { final char ch = str.charAt(i); if (Character.isUpperCase(ch)) { if (i > 0) { sb.append(\"_\"); } sb.append(Character.toLowerCase(ch)); } else { sb.append(ch); } } return sb.toString(); }\n\n    ### Response: Inserts an underscore before every upper case character and returns an\nall lower case string. If the first character is upper case an underscore\nwill not be inserted.\n\n@param str\nString to convert.\n\n@return Lower case + underscored text..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String join(final Collection collection, final char separator) { if (collection == null) { return null; } if (collection.size() == 0) { return StringPool.EMPTY; } final StringBuilder sb = new StringBuilder(collection.size() * 16); final Iterator it = collection.iterator(); for (int i = 0; i < collection.size(); i++) { if (i > 0) { sb.append(separator); } sb.append(it.next()); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Joins an collection of objects into one string with separator.", "predict": " Joins the elements of the collection into a single string, separated by the specified separator.\n\n@param collection\nCollection to join.\n\n@param separator\nSeparator character.\n\n@return Joined string."}, {"ID": 1094, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String arrayToList(String[] array, String delimiter) { if (ArrayUtil.isEmpty(array)) return \"\"; StringBuilder sb = new StringBuilder(array[0]); if (delimiter.length() == 1) { char c = delimiter.charAt(0); for (int i = 1; i < array.length; i++) { sb.append(c); sb.append(array[i]); } } else { for (int i = 1; i < array.length; i++) { sb.append(delimiter); sb.append(array[i]); } } return sb.toString(); }\n\n    ### Response: convert a string array to string list\n\n@param array array to convert\n@param delimiter delimiter for the new list\n@return list generated from string array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String join(final Object[] array, final String separator) { if (array == null) { return null; } if (array.length == 0) { return StringPool.EMPTY; } if (array.length == 1) { return String.valueOf(array[0]); } final StringBuilder sb = new StringBuilder(array.length * 16); for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(separator); } sb.append(array[i]); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Joins an array of objects into one string with separator.", "predict": " join an array of objects into a string with a separator\n\n@param array array of objects to join\n@param separator separator to use between each object\n@return string with all objects joined with the separator"}, {"ID": 1095, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static IExtraLanguageConversionInitializer getTypeConverterInitializer() { return it -> { final List<Pair<String, String>> properties = loadPropertyFile(TYPE_CONVERSION_FILENAME); if (!properties.isEmpty()) { for (final Pair<String, String> entry : properties) { final String source = Objects.toString(entry.getKey()); final String target = Objects.toString(entry.getValue()); final String baseName; final Matcher matcher = TYPE_NAME_PAT.matcher(source); if (matcher.find()) { baseName = matcher.group(1); } else { baseName = source; } it.apply(baseName, source, target); } } }; }\n\n    ### Response: Replies the initializer for the type converter.\n\n@return the initializer..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) { if (srcCharsetName.equals(newCharsetName)) { return source; } return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName); }\n\n    ### Response:", "ground_truth": "Converts string charset. If charset names are the same, the same string is returned.", "predict": "Converts the character set of the given source string to the new character set.\n\n@param source the source string to be converted\n@param srcCharsetName the character set name of the source string\n@param newCharsetName the character set name to which the source string should be converted\n@return the converted string\n\n    "}, {"ID": 1096, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final M get(final int index) { if ((index >= 0) && (index < size())) { return m_jso.get(index); } return null; }\n\n    ### Response: Return the primitive found at the specified index.\n@param index\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) { if ((index < 0) || (index >= string.length())) { return false; } return string.charAt(index) == charToCompare; }\n\n    ### Response:", "ground_truth": "Safely compares provided char with char on given location.", "predict": " Check if the character at the specified index in the string is equal to the specified character.\n@param string\n@param index\n@param charToCompare\n@return true if the character at the specified index is equal to the specified character, false otherwise."}, {"ID": 1097, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String toPojoName(String name, String prefix, String suffix) { LinkedList<String> parts = new LinkedList<>(Arrays.asList(name.split(SPLITTER_REGEX))); if (parts.isEmpty()) { return prefix + name + suffix; } if (parts.getFirst().equals(\"I\")) { parts.removeFirst(); } if (parts.getFirst().equals(\"Abstract\")) { parts.removeFirst(); } if (parts.getLast().equals(\"Interface\")) { parts.removeLast(); } String candidate = join(parts, \"\"); if (name.equals(candidate)) { return prefix + name + suffix; } return candidate; }\n\n    ### Response: Converts a name of an interface or abstract class to Pojo name.\nRemove leading \"I\" and \"Abstract\" or trailing \"Interface\".\n@param name      The name to convert.\n@param prefix    The prefix to use if needed.\n@param suffix    The suffix to user if needed.\n@return          The converted name, if a conversion actually happened or the original name prefixed and suffixed otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String surround(String string, final String prefix, final String suffix) { if (!string.startsWith(prefix)) { string = prefix + string; } if (!string.endsWith(suffix)) { string += suffix; } return string; }\n\n    ### Response:", "ground_truth": "Surrounds the string with provided prefix and suffix if such missing from string.", "predict": " Surrounds a string with a prefix and suffix.\n@param string    The string to surround.\n@param prefix    The prefix to add.\n@param suffix    The suffix to add.\n@return          The surrounded string."}, {"ID": 1098, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String grep(String selector, String text) { if (text == null || text.isEmpty()) { return null; } final StringBuilder line = new StringBuilder(); final int textLength = text.length(); char c; String string; for (int i = 0; i < textLength; ++i) { c = text.charAt(i); if (c == '\\n' || c == '\\r') { string = line.toString(); if (string.contains(selector)) { return string; } line.setLength(0); } else { line.append(c); } } if (line.length() > 0) { string = line.toString(); if (string.contains(selector)) { return string; } } return null; }\n\n    ### Response: Replies the first line that contains the given selector.\n\n@param selector is the string to search for.\n@param text is the text to search in.\n@return the found line or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String prefix(String string, final String prefix) { if (!string.startsWith(prefix)) { string = prefix + string; } return string; }\n\n    ### Response:", "ground_truth": "Inserts prefix if doesn't exist.", "predict": " Adds the given prefix to the beginning of the string if it doesn't already have it.\n\n@param string is the string to add the prefix to.\n@param prefix is the prefix to add to the string.\n@return the modified string with the prefix added."}, {"ID": 1099, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String toPojoName(String name, String prefix, String suffix) { LinkedList<String> parts = new LinkedList<>(Arrays.asList(name.split(SPLITTER_REGEX))); if (parts.isEmpty()) { return prefix + name + suffix; } if (parts.getFirst().equals(\"I\")) { parts.removeFirst(); } if (parts.getFirst().equals(\"Abstract\")) { parts.removeFirst(); } if (parts.getLast().equals(\"Interface\")) { parts.removeLast(); } String candidate = join(parts, \"\"); if (name.equals(candidate)) { return prefix + name + suffix; } return candidate; }\n\n    ### Response: Converts a name of an interface or abstract class to Pojo name.\nRemove leading \"I\" and \"Abstract\" or trailing \"Interface\".\n@param name      The name to convert.\n@param prefix    The prefix to use if needed.\n@param suffix    The suffix to user if needed.\n@return          The converted name, if a conversion actually happened or the original name prefixed and suffixed otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String suffix(String string, final String suffix) { if (!string.endsWith(suffix)) { string += suffix; } return string; }\n\n    ### Response:", "ground_truth": "Appends suffix if doesn't exist.", "predict": " Adds a suffix to a string if it doesn't already have it.\n@param string    The string to add the suffix to.\n@param suffix    The suffix to add.\n@return          The string with the suffix added if it didn't already have it."}, {"ID": 1100, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static String stripFragment(final String path) { final int i = path.indexOf(SHARP); if (i != -1) { return path.substring(0, i); } else { return path; } }\n\n    ### Response: Strip fragment part from path.\n\n@param path path\n@return path without path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutToIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(0, i); } return string; }\n\n    ### Response:", "ground_truth": "Cuts the string from beginning to the first index of provided substring.", "predict": " Cuts the string to the index of the substring.\n\n@param string the string to be cut\n@param substring the substring to find the index of\n@return the cut string"}, {"ID": 1101, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int substr_count(final String string, final String substring) { if(substring.length()==1) { return substr_count(string, substring.charAt(0)); } int count = 0; int idx = 0; while ((idx = string.indexOf(substring, idx)) != -1) { ++idx; ++count; } return count; }\n\n    ### Response: Count the number of substring occurrences.\n\n@param string\n@param substring\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutFromIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(i); } return string; }\n\n    ### Response:", "ground_truth": "Cuts the string from the first index of provided substring to the end.", "predict": " Remove the substring from the beginning of the string.\n\n@param string\n@param substring\n@return."}, {"ID": 1102, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String grep(String selector, String text) { if (text == null || text.isEmpty()) { return null; } final StringBuilder line = new StringBuilder(); final int textLength = text.length(); char c; String string; for (int i = 0; i < textLength; ++i) { c = text.charAt(i); if (c == '\\n' || c == '\\r') { string = line.toString(); if (string.contains(selector)) { return string; } line.setLength(0); } else { line.append(c); } } if (line.length() > 0) { string = line.toString(); if (string.contains(selector)) { return string; } } return null; }\n\n    ### Response: Replies the first line that contains the given selector.\n\n@param selector is the string to search for.\n@param text is the text to search in.\n@return the found line or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutPrefix(String string, final String prefix) { if (string.startsWith(prefix)) { string = string.substring(prefix.length()); } return string; }\n\n    ### Response:", "ground_truth": "Cuts prefix if exists.", "predict": " Removes the prefix from the given string.\n\n@param string is the string to remove the prefix from.\n@param prefix is the prefix to remove.\n@return the string without the prefix."}, {"ID": 1103, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String read(final File aFile) throws IOException { String string = new String(readBytes(aFile), StandardCharsets.UTF_8.name()); if (string.endsWith(EOL)) { string = string.substring(0, string.length() - 1); } return string; }\n\n    ### Response: Reads the contents of a file into a string using the UTF-8 character set encoding.\n\n@param aFile The file from which to read\n@return The information read from the file\n@throws IOException If the supplied file could not be read.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutSuffix(String string, final String suffix) { if (string.endsWith(suffix)) { string = string.substring(0, string.length() - suffix.length()); } return string; }\n\n    ### Response:", "ground_truth": "Cuts sufix if exists.", "predict": " Removes a suffix from a string if it exists.\n\n@param string The string from which to remove the suffix\n@param suffix The suffix to remove\n@return The string with the suffix removed, or the original string if it did not end with the suffix."}, {"ID": 1104, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getDeepestNestedElementName(String configDisplayId) { int start = configDisplayId.lastIndexOf(\"]/\"); if (start > 1) { int end = configDisplayId.indexOf('[', start += 2); if (end > start) return configDisplayId.substring(start, end); } return null; }\n\n    ### Response: Returns the most deeply nested element name.\n\n@param configDisplayId config.displayId\n@return the most deeply nested element name. Null if there are not any nested elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutSurrounding(final String string, final String prefix, final String suffix) { int start = 0; int end = string.length(); if (string.startsWith(prefix)) { start = prefix.length(); } if (string.endsWith(suffix)) { end -= suffix.length(); } if (end <= start) { return StringPool.EMPTY; } return string.substring(start, end); }\n\n    ### Response:", "ground_truth": "Removes surrounding prefix and suffixes.", "predict": " Cuts the surrounding prefix and suffix from the given string.\n\n@param string the string to cut from\n@param prefix the prefix to cut\n@param suffix the suffix to cut\n@return the cut string. If the prefix and suffix are not found, an empty string is returned."}, {"ID": 1105, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String lTrim(final String value) { if (value == null) { return null; } String trimmed = value; int offset = 0; final int maxLength = value.length(); while (offset < maxLength && (value.charAt(offset) == ' ' || value.charAt(offset) == '\\t')) { offset++; } if (offset > 0) { trimmed = value.substring(offset); } return trimmed; }\n\n    ### Response: Removes empty space from the beginning of a string\n\n@param value -\nto be trimmed\n@return String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String insert(final String src, final String insert, int offset) { if (offset < 0) { offset = 0; } if (offset > src.length()) { offset = src.length(); } StringBuilder sb = new StringBuilder(src); sb.insert(offset, insert); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Inserts a string on provided offset.", "predict": " Inserts a string into a source string at a specified offset\n\n@param src -\nthe source string\n@param insert -\nthe string to be inserted\n@param offset -\nthe position at which to insert the string\n@return String."}, {"ID": 1106, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String leftPad(String text, String padding, int linesToIgnore) { StringBuilder result = new StringBuilder(); Matcher matcher = LINE_START_PATTERN.matcher(text); while (matcher.find()) { if (linesToIgnore > 0) { linesToIgnore--; } else { result.append(padding); } result.append(matcher.group()).append(\"\\n\"); } return result.toString(); }\n\n    ### Response: Inserts the specified string at the beginning of each newline of the specified text.\n\n@param text          the text to pad.\n@param padding       the padding.\n@param linesToIgnore the number of lines to ignore before starting the padding.\n@return the padded text..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String repeat(final String source, int count) { StringBand result = new StringBand(count); while (count > 0) { result.append(source); count--; } return result.toString(); }\n\n    ### Response:", "ground_truth": "Creates a new string that contains the provided string a number of times.", "predict": " Repeats the specified string the specified number of times.\n\n@param source the string to repeat.\n@param count  the number of times to repeat the string.\n@return the repeated string."}, {"ID": 1107, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toStringUnsignedInt(byte[] key) { StringBuilder result = new StringBuilder(); for (int i = 0; i < key.length; i++) { result.append(key[i] & 0xFF); result.append(' '); } return result.toString(); }\n\n    ### Response: Generates a string representation of the given key\n\n@param key\n@return the String representation of the given key.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String reverse(final String s) { StringBuilder result = new StringBuilder(s.length()); for (int i = s.length() -1; i >= 0; i--) { result.append(s.charAt(i)); } return result.toString(); }\n\n    ### Response:", "ground_truth": "Reverse a string.", "predict": " Reverses the given string\n\n@param s\n@return the reversed string."}, {"ID": 1108, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String fill( final String prefix, final String charSequence, final int times) { if (times < 1) { return \"\"; } StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix); } for (int i = 0; i < times; i++) { sb.append(charSequence); } return sb.toString(); }\n\n    ### Response: Create a string representation repeating a character\nsequence the requested number of times.\n@param prefix an optional prefix to prepend\n@param charSequence the character sequence to repeat\n@param times how many times the character sequence should be repeated\n@return a string filled with character sequence or empty string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String maxCommonPrefix(final String one, final String two) { final int minLength = Math.min(one.length(), two.length()); final StringBuilder sb = new StringBuilder(minLength); for (int pos = 0; pos < minLength; pos++) { final char currentChar = one.charAt(pos); if (currentChar != two.charAt(pos)) { break; } sb.append(currentChar); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns max common prefix of two strings.", "predict": " Find the maximum common prefix between two strings.\n@param one the first string\n@param two the second string\n@return the maximum common prefix between the two strings."}, {"ID": 1109, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toJavaDateTimeFormat(String strftime) { if (!StringUtils.contains(strftime, '%')) { return replaceL(strftime); } StringBuilder result = new StringBuilder(); for (int i = 0; i < strftime.length(); i++) { char c = strftime.charAt(i); if (c == '%') { c = strftime.charAt(++i); boolean stripLeadingZero = false; if (c == '-') { stripLeadingZero = true; c = strftime.charAt(++i); } if (stripLeadingZero) { result.append(CONVERSIONS[c].substring(1)); } else { result.append(CONVERSIONS[c]); } } else if (Character.isLetter(c)) { result.append(\"'\"); while (Character.isLetter(c)) { result.append(c); if (++i < strftime.length()) { c = strftime.charAt(i); } else { c = 0; } } result.append(\"'\"); --i; // re-consume last char } else { result.append(c); } } return replaceL(result.toString()); }\n\n    ### Response: Parses a string in python strftime format, returning the equivalent string in java date time format.\n\n@param strftime\n@return date formatted as string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String findCommonPrefix(final String... strings) { StringBuilder prefix = new StringBuilder(); int index = 0; char c = 0; loop: while (true) { for (int i = 0; i < strings.length; i++) { String s = strings[i]; if (index == s.length()) { break loop; } if (i == 0) { c = s.charAt(index); } else { if (s.charAt(index) != c) { break loop; } } } index++; prefix.append(c); } return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString(); }\n\n    ### Response:", "ground_truth": "Finds common prefix for several strings. Returns an empty string if\narguments do not have a common prefix.", "predict": " Finds the common prefix among a list of strings.\n\n@param strings\n@return common prefix as string."}, {"ID": 1110, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String ljust(String s, Integer length) { if (s.length() >= length) { return s; } length -= s.length(); StringBuffer sb = new StringBuffer(); for (Integer i = 0; i < length; i++) { sb.append(\" \"); } return s + sb.toString(); }\n\n    ### Response: Left justify a string by forcing it to be the specified length. This is\ndone by concatonating space characters to the end of the string until the\nstring is of the specified length. If, however, the string is initially\nlonger than the specified length then the original string is returned.\n\n@param s\nA string.\n@param length\nThe target length for the string.\n@return A left-justified string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String shorten(String s, int length, final String suffix) { length -= suffix.length(); if (s.length() > length) { for (int j = length; j >= 0; j--) { if (CharUtil.isWhitespace(s.charAt(j))) { length = j; break; } } String temp = s.substring(0, length); s = temp.concat(suffix); } return s; }\n\n    ### Response:", "ground_truth": "Shorten string to given length.", "predict": " Shorten a string by removing characters from the end of the string until the string is of the specified length or a whitespace character is encountered. If a whitespace character is encountered, the string is truncated at that point. If the string is already shorter than the specified length, it is returned unchanged.\n\n@param s\nA string.\n@param length\nThe target length for the string.\n@param suffix\nA string to append to the end of the shortened string.\n@return A shortened string with the specified suffix appended."}, {"ID": 1111, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String wordShapeDigits(final String s) { char[] outChars = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (Character.isDigit(c)) { if (outChars == null) { outChars = s.toCharArray(); } outChars[i] = '9'; } } if (outChars == null) { // no digit found return s; } else { return new String(outChars); } }\n\n    ### Response: Just collapses digits to 9 characters.\nDoes lazy copying of String.\n\n@param s String to find word shape of\n@return The same string except digits are equivalence classed to 9..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toUpperCase(final String s, Locale locale) { if (s == null) { return null; } StringBuilder sb = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127) { // found non-ascii char, fallback to the slow unicode detection if (locale == null) { locale = Locale.getDefault(); } return s.toUpperCase(locale); } if ((c >= 'a') && (c <= 'z')) { if (sb == null) { sb = new StringBuilder(s); } sb.setCharAt(i, (char)(c - 32)); } } if (sb == null) { return s; } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Converts all of the characters in the string to upper case, based on the\nlocale.\n\n@param  s the string to convert\n@param  locale apply this locale's rules\n@return the string, converted to upper case, or null if the\nstring is null", "predict": "Converts the given string to uppercase using the specified locale. If the string contains non-ASCII characters, the method falls back to the slow unicode detection.\n\n@param s The string to convert to uppercase\n@param locale The locale to use for case conversion\n@return The uppercase version of the string"}, {"ID": 1112, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function getString($value) { if ($this->startsWith($value, '\\'') && $this->endsWith($value, '\\'')) { return ltrim(rtrim($value, '\\''), '\\''); } if ($this->startsWith($value, '\"') && $this->endsWith($value, '\"')) { return ltrim(rtrim($value, '\"'), '\"'); } return $value; }\n\n    ### Response: Removes ' or \" from string\n\n@param string $value\n@return string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String removeQuotes(final String string) { if ( (startsWithChar(string, '\\'') && endsWithChar(string, '\\'')) || (startsWithChar(string, '\"') && endsWithChar(string, '\"')) || (startsWithChar(string, '`') && endsWithChar(string, '`')) ) { return substring(string, 1, -1); } return string; }\n\n    ### Response:", "ground_truth": "Removes starting and ending single or double quotes.", "predict": " Removes ' or \" or ` from string\n\n@param string $string\n@return string."}, {"ID": 1113, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toHex(byte[] bytes) { final char[] string = new char[2 * bytes.length]; int i = 0; for (byte b : bytes) { string[i++] = hexDigits[(b >> 4) & 0x0f]; string[i++] = hexDigits[b & 0x0f]; } return new String(string); }\n\n    ### Response: Converts the specified array of bytes to a hex string.\n@param bytes The array of bytes to convert to a string.\n@return The hexadecimal representation of bytes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toHexString(final byte[] bytes) { char[] chars = new char[bytes.length * 2]; int i = 0; for (byte b : bytes) { chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4); chars[i++] = CharUtil.int2hex(b & 0x0F); } return new String(chars); }\n\n    ### Response:", "ground_truth": "Converts bytes to hex string.", "predict": " Converts the specified array of bytes to a hex string.\n@param bytes The array of bytes to convert to a string.\n@return The hexadecimal representation of bytes."}, {"ID": 1114, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] bytes(String s) { try { return s.getBytes(ENCODING); } catch (UnsupportedEncodingException e) { log.error(\"UnsupportedEncodingException \", e); throw new RuntimeException(e); } }\n\n    ### Response: Gets UTF-8 bytes from the string.\n\n@param s\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] getBytes(final String string) { try { return string.getBytes(JoddCore.encoding); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Returns String bytes using Jodds default encoding.", "predict": " Gets bytes from the string using the default encoding.\n\n@param string\n@return."}, {"ID": 1115, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String nextToken() throws JSONException { char c; char q; StringBuilder sb = new StringBuilder(); do { c = next(); } while (Character.isWhitespace(c)); if (c == '\"' || c == '\\'') { q = c; for (;;) { c = next(); if (c < ' ') { throw syntaxError(\"Unterminated string.\"); } if (c == q) { return sb.toString(); } sb.append(c); } } for (;;) { if (c == 0 || Character.isWhitespace(c)) { return sb.toString(); } sb.append(c); c = next(); } }\n\n    ### Response: Get the next token or string. This is used in parsing HTTP headers.\n@throws JSONException\n@return A String..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char detectQuoteChar(final String str) { if (str.length() < 2) { return 0; } final char c = str.charAt(0); if (c != str.charAt(str.length() - 1)) { return 0; } if (c == '\\'' || c == '\"' || c == '`') { return c; } return 0; }\n\n    ### Response:", "ground_truth": "Detects quote character or return 0.", "predict": " Detect the quote character used in a string. This is used in parsing JSON strings.\n@param str The string to detect the quote character for.\n@return The quote character used in the string, or 0 if none was found."}, {"ID": 1116, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void accept(final AnnotationVisitor av, final String name, final Object value) { if (av != null) { if (value instanceof String[]) { String[] typeconst = (String[]) value; av.visitEnum(name, typeconst[0], typeconst[1]); } else if (value instanceof AnnotationNode) { AnnotationNode an = (AnnotationNode) value; an.accept(av.visitAnnotation(name, an.desc)); } else if (value instanceof List) { AnnotationVisitor v = av.visitArray(name); List<?> array = (List<?>) value; for (int j = 0; j < array.size(); ++j) { accept(v, null, array.get(j)); } v.visitEnd(); } else { av.visit(name, value); } } }\n\n    ### Response: Makes the given visitor visit a given annotation value.\n\n@param av\nan annotation visitor. Maybe null.\n@param name\nthe value name.\n@param value\nthe actual value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit(final String name, final Object value) { if (av != null) { av.visit(name, value); } }\n\n    ### Response:", "ground_truth": "Visits a primitive value of the annotation.\n\n@param name the value name.\n@param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\nCharacter}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\n{@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\nvalue can also be an array of byte, boolean, short, char, int, long, float or double values\n(this is equivalent to using {@link #visitArray} and visiting each array element in turn,\nbut is more convenient).", "predict": " Visits a given annotation value.\n\n@param name\nthe value name.\n@param value\nthe actual value."}, {"ID": 1117, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void accept(final AnnotationVisitor av, final String name, final Object value) { if (av != null) { if (value instanceof String[]) { String[] typeconst = (String[]) value; av.visitEnum(name, typeconst[0], typeconst[1]); } else if (value instanceof AnnotationNode) { AnnotationNode an = (AnnotationNode) value; an.accept(av.visitAnnotation(name, an.desc)); } else if (value instanceof List) { AnnotationVisitor v = av.visitArray(name); List<?> array = (List<?>) value; for (int j = 0; j < array.size(); ++j) { accept(v, null, array.get(j)); } v.visitEnd(); } else { av.visit(name, value); } } }\n\n    ### Response: Makes the given visitor visit a given annotation value.\n\n@param av\nan annotation visitor. Maybe null.\n@param name\nthe value name.\n@param value\nthe actual value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitEnum(final String name, final String descriptor, final String value) { if (av != null) { av.visitEnum(name, descriptor, value); } }\n\n    ### Response:", "ground_truth": "Visits an enumeration value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the enumeration class.\n@param value the actual enumeration value.", "predict": " Visits an enum value.\n\n@param name\nthe value name.\n@param descriptor\nthe enum type descriptor.\n@param value\nthe enum value."}, {"ID": 1118, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodMember getCurrentMethod(String name, String descriptor) { if (liveVersion == null) { return getMethod(name, descriptor); } else { return liveVersion.getReloadableMethod(name, descriptor); } }\n\n    ### Response: Gets the method corresponding to given name and descriptor, taking into consideration changes that have happened\nby reloading.\n\n@param name the member name\n@param descriptor the member descriptor (e.g. (Ljava/lang/String;)I)\n@return the MethodMember for that name and descriptor. Null if not found on a live version, or an exception if\nthere is no live version and it cannot be found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String name, final String descriptor) { if (av != null) { return av.visitAnnotation(name, descriptor); } return null; }\n\n    ### Response:", "ground_truth": "Visits a nested annotation value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the nested annotation class.\n@return a visitor to visit the actual nested annotation value, or {@literal null} if this\nvisitor is not interested in visiting this nested annotation. The nested annotation\nvalue must be fully visited before calling other methods on this annotation visitor.", "predict": " Visits an annotation of the specified type.\n\n@param name the annotation name\n@param descriptor the annotation descriptor (e.g. Ljavax/annotation/Nullable;)\n@return a visitor to visit the individual annotation values, or null if this visitor is not interested in\nvisiting this annotation."}, {"ID": 1119, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ViewDispatcher getViewDispatcher(Activity activity) throws ViewDispatcherException { if (dispatchRule.getViewDispatcher() != null) { return dispatchRule.getViewDispatcher(); } try { String dispatcherName; if (dispatchRule.getDispatcherName() != null) { dispatcherName = dispatchRule.getDispatcherName(); } else { dispatcherName = activity.getSetting(ViewDispatcher.VIEW_DISPATCHER_SETTING_NAME); if (dispatcherName == null) { throw new IllegalArgumentException(\"The settings name '\" + ViewDispatcher.VIEW_DISPATCHER_SETTING_NAME + \"' has not been specified in the default response rule\"); } } ViewDispatcher viewDispatcher = cache.get(dispatcherName); if (viewDispatcher == null) { if (dispatcherName.startsWith(BeanRule.CLASS_DIRECTIVE_PREFIX)) { String dispatcherClassName = dispatcherName.substring(BeanRule.CLASS_DIRECTIVE_PREFIX.length()); Class<?> dispatcherClass = activity.getEnvironment().getClassLoader().loadClass(dispatcherClassName); viewDispatcher = (ViewDispatcher)activity.getBean(dispatcherClass); } else { viewDispatcher = activity.getBean(dispatcherName); } if (viewDispatcher == null) { throw new IllegalArgumentException(\"No bean named '\" + dispatcherName + \"' is defined\"); } if (viewDispatcher.isSingleton()) { ViewDispatcher existing = cache.putIfAbsent(dispatcherName, viewDispatcher); if (existing != null) { viewDispatcher = existing; } else { if (log.isDebugEnabled()) { log.debug(\"Caching \" + viewDispatcher); } } } } return viewDispatcher; } catch(Exception e) { throw new ViewDispatcherException(\"Unable to determine ViewDispatcher\", e); } }\n\n    ### Response: Determine the view dispatcher.\n\n@param activity the current Activity\n@throws ViewDispatcherException if ViewDispatcher can not be determined.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> registerType(final Class<E> type) { DbEntityDescriptor<E> ded = createDbEntityDescriptor(type); DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded); if (log.isDebugEnabled()) { log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName()); } if (existing != null) { if (ded.getType() == type) { return ded; } throw new DbOomException(\"Type already registered: \" + existing.getType()); } existing = entityNamesMap.put(ded.getEntityName(), ded); if (existing != null) { throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType()); } return ded; }\n\n    ### Response:", "ground_truth": "Registers just type and entity names. Enough for most usages.", "predict": " Register a type with the database.\n\n@param type the type to register\n@return the descriptor for the registered type\n@throws DbOomException if the type is already registered or the name is already mapped to an entity."}, {"ID": 1120, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <E> boolean onCheckCollectionAttribute(PluralAttribute<? super X, ?, ?> pluralAttribute, Class<E> paramClass) { if (pluralAttribute != null) { if (isCollectionAttribute(pluralAttribute) && isBindable(pluralAttribute, paramClass)) { return true; } } return false; }\n\n    ### Response: On check collection attribute.\n\n@param \nthe element type\n@param pluralAttribute\nthe plural attribute\n@param paramClass\nthe param class\n@return true, if successful.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) { if (force) { removeEntity(type); } return registerEntity(type); }\n\n    ### Response:", "ground_truth": "Registers entity. Existing entity will be removed if exist, so no exception will be thrown.", "predict": " Register entity.\n\n@param type\nthe type\n@param force\nthe force\n@return the db entity descriptor"}, {"ID": 1121, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <E> E getJson(PortletPreferences prefs, String key, Class<E> type) throws IOException { final String prefValue = StringUtils.trimToNull(prefs.getValue(key, null)); if (prefValue == null) { return null; } return mapper.readValue(prefValue, type); }\n\n    ### Response: Read the specified portlet preference and parse it as a JSON string into the specified type.\nIf the preference is null returns null.\n\n@param prefs Preferences to read from\n@param key Preference key to read from\n@param type The class type parse the JSON into.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) { DbEntityDescriptor<E> ded = descriptorsMap.remove(type); if (ded == null) { ded = createDbEntityDescriptor(type); } entityNamesMap.remove(ded.getEntityName()); tableNamesMap.remove(ded.getTableName()); return ded; }\n\n    ### Response:", "ground_truth": "Removes entity and returns removed descriptor.", "predict": " Removes the specified entity descriptor from the cache. If the descriptor is not found, a new one is created and returned.\n\n@param type The entity type to remove the descriptor for.\n\n    "}, {"ID": 1122, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final <E> E merge(E e) { checkClosed(); checkTransactionNeeded(); try { return getPersistenceDelegator().merge(e); } catch (Exception ex) { // on Rollback doRollback(); throw new KunderaException(ex); } }\n\n    ### Response: Merge the state of the given entity into the current persistence context.\n\n@param entity\n@return the managed instance that the state was merged to\n@throws IllegalArgumentException\nif instance is not an entity or is a removed entity\n@throws TransactionRequiredException\nif invoked on a container-managed entity manager of type\nPersistenceContextType.TRANSACTION and there is no\ntransaction\n@see javax.persistence.EntityManager#merge(java.lang.Object).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E createEntityInstance(final Class<E> type) { try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new DbOomException(ex); } }\n\n    ### Response:", "ground_truth": "Creates new entity instances.", "predict": " Create a new instance of the given entity class.\n\n@param type\n@return a new instance of the given entity class\n@throws DbOomException\nif an error occurs while creating the instance\n\n    "}, {"ID": 1123, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private T createEmpty(Class<?> clazz) { T emptyInstance = null; if (clazz.isInterface()) { throw new IllegalArgumentException(\"Specified class is an interface: \" + clazz.getName()); } try { emptyInstance = (T) clazz.newInstance(); } catch (InstantiationException ex) { throw new IllegalArgumentException(clazz.getName() + \". Is it an abstract class?\", ex); } catch (IllegalAccessException ex) { throw new IllegalArgumentException(clazz.getName() + \"Is the constructor accessible?\", ex); } return emptyInstance; }\n\n    ### Response: Creates new empty Bean instance\n\n@param clazz Class description which would be instantiated\n@return empty Bean instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WrapperProxettaFactory setTargetInterface(final Class targetInterface) { if (!targetInterface.isInterface()) { throw new ProxettaException(\"Not an interface: \" + targetInterface.getName()); } this.targetInterface = targetInterface; return this; }\n\n    ### Response:", "ground_truth": "Defines the interface of the resulting class.", "predict": " Sets the target interface for the factory.\n\n@param targetInterface Interface to be set as target interface for the factory.\n@return the factory itself."}, {"ID": 1124, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final Object getProperty(Map context, Object target, Object oname) throws OgnlException { return super.getProperty(context, target, oname); }\n\n    ### Response: to override them..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectTargetIntoWrapper(final Object target, final Object wrapper) { ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName); }\n\n    ### Response:", "ground_truth": "Injects target into wrapper.", "predict": " injects the target object into the wrapper object."}, {"ID": 1125, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<AnnotationData> getAnnotationSet(final Collection<TagAndLength> pTags) { Collection<AnnotationData> ret = null; if (pTags != null) { Map<ITag, AnnotationData> data = AnnotationUtils.getInstance().getMap().get(getClass().getName()); ret = new ArrayList<AnnotationData>(data.size()); for (TagAndLength tal : pTags) { AnnotationData ann = data.get(tal.getTag()); if (ann != null) { ann.setSize(tal.getLength() * BitUtils.BYTE_SIZE); } else { ann = new AnnotationData(); ann.setSkip(true); ann.setSize(tal.getLength() * BitUtils.BYTE_SIZE); } ret.add(ann); } } else { ret = AnnotationUtils.getInstance().getMapSet().get(getClass().getName()); } return ret; }\n\n    ### Response: Method to get the annotation set from the current class\n\n@return An annotation set which contain all annotation data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) { PropertyDescriptor[] properties = annotatedProperties.get(type); if (properties != null) { return properties; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); List<PropertyDescriptor> list = new ArrayList<>(); for (PropertyDescriptor propertyDescriptor : allProperties) { Annotation ann = null; if (propertyDescriptor.getFieldDescriptor() != null) { ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) { ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) { ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann != null) { list.add(propertyDescriptor); } } if (list.isEmpty()) { properties = EMPTY; } else { properties = list.toArray(new PropertyDescriptor[0]); } annotatedProperties.put(type, properties); return properties; }\n\n    ### Response:", "ground_truth": "Lookups for annotated properties. Caches all annotated properties on the first\naction class scan.", "predict": " Method to lookup all annotated properties of a given class\n\n@param type The class to lookup the annotated properties for\n@return An array of property descriptors for all annotated properties of the given class. If no annotated properties are found, an empty array is returned."}, {"ID": 1126, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public InetAddress getRemoteAddress() { final Channel channel; try { channel = strategy.getChannel(); } catch (IOException e) { return null; } final Connection connection = channel.getConnection(); final InetSocketAddress peerAddress = connection.getPeerAddress(InetSocketAddress.class); return peerAddress == null ? null : peerAddress.getAddress(); }\n\n    ### Response: Get the remote address.\n\n@return the remote address, {@code null} if not available.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) { cp.init(); final Connection connection = cp.getConnection(); final DbServer dbServer = detectDatabase(connection); cp.closeConnection(connection); dbServer.accept(dbOomConfig); return dbServer; }\n\n    ### Response:", "ground_truth": "Detects database and configure DbOom engine.", "predict": " Detect the database and configure DbOom.\n\n@param cp the connection provider\n@param dbOomConfig the DbOom configuration\n@return the detected database server and configured DbOom"}, {"ID": 1127, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void close() { synchronized (lock) { if (closed) { return; } closed = true; tokenSource.unregister(this); tokenSource = null; action = null; } }\n\n    ### Response: Unregisters the callback runnable from the cancellation token..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void close() throws IOException { if (closed) { return; } if (gzipstream != null) { flushToGZip(); gzipstream.close(); gzipstream = null; } else { if (bufferCount > 0) { output.write(buffer, 0, bufferCount); bufferCount = 0; } } output.close(); closed = true; }\n\n    ### Response:", "ground_truth": "Closes this output stream, causing any buffered data to be flushed and any\nfurther output data to throw an IOException.", "predict": " Closes the output stream and flushes any remaining data to the GZIP output stream if applicable."}, {"ID": 1128, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void write (final int b) throws IOException { if (m_nCount >= m_aBuf.length) _flushBuffer (); m_aBuf[m_nCount++] = (byte) b; }\n\n    ### Response: Writes the specified byte to this buffered output stream.\n\n@param b\nthe byte to be written.\n@exception IOException\nif an I/O error occurs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void write(final int b) throws IOException { if (closed) { throw new IOException(\"Cannot write to a closed output stream\"); } if (bufferCount >= buffer.length) { flushToGZip(); } buffer[bufferCount++] = (byte) b; }\n\n    ### Response:", "ground_truth": "Writes the specified byte to our output stream.", "predict": " Writes the specified byte to this output stream. The general contract for write is that one byte is written to the output stream. The byte to be written is the eight low-order bits of the argument b. The 24 high-order bits of b are ignored.\n\n@param b\nthe byte to be written.\n@exception IOException\nif an I/O error occurs."}, {"ID": 1129, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { final HttpServletRequest req = (HttpServletRequest) request; final HttpServletResponse res = (HttpServletResponse) response; final String requestUri = req.getRequestURI(); if (requestUri != null) { for (final String url: denyUrls) { if (requestUri.startsWith(url.trim())) { res.setStatus(HttpServletResponse.SC_FORBIDDEN); return; } } for (final String url: ignoreUrls) { if (requestUri.startsWith(url.trim())) { res.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } } } chain.doFilter(request, response); }\n\n    ### Response: Check for denied or ignored URLs being requested.\n\n@param request The request object.\n@param response The response object.\n@param chain Refers to the {@code FilterChain} object to pass control to the next {@code Filter}.\n@throws IOException a IOException\n@throws ServletException a ServletException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; if (isRequestedSessionIdFromURL(httpRequest)) { HttpSession session = httpRequest.getSession(false); if (session != null) { session.invalidate(); // clear session if session id in URL } } // wrap response to remove URL encoding HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) { @Override public String encodeRedirectUrl(final String url) { return url; } @Override public String encodeRedirectURL(final String url) { return url; } @Override public String encodeUrl(final String url) { return url; } @Override public String encodeURL(final String url) { return url; } }; chain.doFilter(request, wrappedResponse); }\n\n    ### Response:", "ground_truth": "Filters requests to remove URL-based session identifiers.", "predict": " Check if the requested session ID is in the URL and invalidate the session if it is.\n\n@param request The request object.\n@param response The response object.\n@param chain Refers to the {@code FilterChain} object to pass control to the next {@code Filter}.\n@throws IOException a IOException\n@throws ServletException a ServletException."}, {"ID": 1130, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable public static String encodeText(@Nullable final String name) { if (name == null) { return null; } try { return MimeUtility.encodeText(name); } catch (final UnsupportedEncodingException e) { throw new IllegalArgumentException(e.getMessage(), e); } }\n\n    ### Response: To make sure email clients can interpret text properly, we need to encode some values according to RFC-2047..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getEncodedName() { if (name == null) { return null; } try { return MimeUtility.encodeText(name); } catch (final UnsupportedEncodingException ueex) { throw new MailException(ueex); } }\n\n    ### Response:", "ground_truth": "Returns encoded attachment name.\n\n@return encoded attachment name. Value may be {@code null}.", "predict": " This method is used to encode the name of the recipient in the email message. It uses the MimeUtility class to encode the name according to RFC-2047. If there is an error during encoding, it throws a MailException."}, {"ID": 1131, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] toByteArray() throws IOException { DerOutputStream out = new DerOutputStream(); encode(out); data.reset(); return out.toByteArray(); }\n\n    ### Response: Returns a DER-encoded value, such that if it's passed to the\nDerValue constructor, a value equivalent to \"this\" is returned.\n\n@return DER-encoded value, including tag and length..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] toByteArray() { final FastByteArrayOutputStream out; if (size != -1) { out = new FastByteArrayOutputStream(size); } else { out = new FastByteArrayOutputStream(); } writeToStream(out); return out.toByteArray(); }\n\n    ### Response:", "ground_truth": "Returns byte content of the attachment.\n\n@return byte array with content of the attachment.", "predict": " Returns a DER-encoded value, such that if it's passed to the\nDerValue constructor, a value equivalent to \"this\" is returned.\n\n@return DER-encoded value, including tag and length."}, {"ID": 1132, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(InputStream source, File destination) throws IOException { OutputStream output = null; try { output = new FileOutputStream(destination); copy(source, output); } finally { closeQuietly(output); } }\n\n    ### Response: Copies the content of an InputStream into a destination File.\n\n@param source the InputStream to copy\n@param destination the target File\n@throws IOException if an error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeToFile(final File destination) { InputStream input = null; final OutputStream output; try { input = getDataSource().getInputStream(); output = new FileOutputStream(destination); StreamUtil.copy(input, output); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } }\n\n    ### Response:", "ground_truth": "Saves attachment to a file.\n\n@param destination The destination file to be written.", "predict": " Writes the content of the data source to a file.\n\n@param destination the target File\n@throws MailException if an error occurs."}, {"ID": 1133, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(File file, OutputStream out) throws IOException { FileInputStream in = new FileInputStream(file); try { IOUtils.copy(new BufferedInputStream(in), out); } finally { IOUtils.closeQuietly(in); } }\n\n    ### Response: Copies the given file into an output stream.\n\n@param file input file (must exist).\n@param out output stream.\n\n@throws java.io.IOException if file is not found or copying fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeToStream(final OutputStream out) { InputStream input = null; try { input = getDataSource().getInputStream(); StreamUtil.copy(input, out); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } }\n\n    ### Response:", "ground_truth": "Saves attachment to the output stream.\n\n@param out OutputStream where attachment should be copied to.", "predict": " Writes the data source content to the given output stream.\n\n@param out output stream.\n\n@throws java.io.IOException if writing fails.\n\n    "}, {"ID": 1134, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<E> list(int first, int max, String sortProperty, boolean ascending) { Criteria c = createCriteria() .setMaxResults(max) .setFirstResult(first); final int ndx = sortProperty.lastIndexOf('.'); if (ndx != -1) { final String associationPath = sortProperty.substring(0, ndx); final String propertyName = sortProperty.substring(ndx + 1); c = c.createAlias(associationPath, ASSOCIATION_ALIAS) .addOrder(ascending ? Order.asc(ASSOCIATION_ALIAS + \".\" + propertyName) : Order.desc(ASSOCIATION_ALIAS + \".\" + propertyName)); } else { c = c.addOrder(ascending ? Order.asc(sortProperty) : Order.desc(sortProperty)); } return list(c); }\n\n    ### Response: Returns one page of data from this repository.\n\n@param first        the first entity to return\n@param max          the maximum number of entities to return\n@param sortProperty the property to sort by\n@param ascending    whether or not the sorting is asceding\n@return one page of data from this repository.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String appendArgument(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx) + type + desc.substring(ndx); }\n\n    ### Response:", "ground_truth": "Appends argument to the existing description.", "predict": " Appends the given type to the end of the given method description.\n\n@param desc the method description\n@param type the type to append\n@return the updated method description with the type appended\n\n    "}, {"ID": 1135, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<E> list(int first, int max, String sortProperty, boolean ascending) { Criteria c = createCriteria() .setMaxResults(max) .setFirstResult(first); final int ndx = sortProperty.lastIndexOf('.'); if (ndx != -1) { final String associationPath = sortProperty.substring(0, ndx); final String propertyName = sortProperty.substring(ndx + 1); c = c.createAlias(associationPath, ASSOCIATION_ALIAS) .addOrder(ascending ? Order.asc(ASSOCIATION_ALIAS + \".\" + propertyName) : Order.desc(ASSOCIATION_ALIAS + \".\" + propertyName)); } else { c = c.addOrder(ascending ? Order.asc(sortProperty) : Order.desc(sortProperty)); } return list(c); }\n\n    ### Response: Returns one page of data from this repository.\n\n@param first        the first entity to return\n@param max          the maximum number of entities to return\n@param sortProperty the property to sort by\n@param ascending    whether or not the sorting is asceding\n@return one page of data from this repository.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); }\n\n    ### Response:", "ground_truth": "Prepends argument to the existing description.", "predict": " Prepends the given type to the argument list of the given method description.\n\n@param desc the method description\n@param type the type to prepend\n@return the updated method description with the type prepended to the argument list\n\n    "}, {"ID": 1136, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function getPrevKeyWith( keys, fullSid, ndx ) { ndx = ndx >= 0 ? ndx : ndx + keys.length; for ( ; ndx >= 0; ndx -- ) { var key = keys[ ndx ]; if ( key.hasTarget( fullSid ) ) { return key; } } return null; }\n\n    ### Response: Get previous key with given sid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; }\n\n    ### Response:", "ground_truth": "Changes return type.", "predict": " Change return type of a method.\n\n    "}, {"ID": 1137, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String grep(String selector, String text) { if (text == null || text.isEmpty()) { return null; } final StringBuilder line = new StringBuilder(); final int textLength = text.length(); char c; String string; for (int i = 0; i < textLength; ++i) { c = text.charAt(i); if (c == '\\n' || c == '\\r') { string = line.toString(); if (string.contains(selector)) { return string; } line.setLength(0); } else { line.append(c); } } if (line.length() > 0) { string = line.toString(); if (string.contains(selector)) { return string; } } return null; }\n\n    ### Response: Replies the first line that contains the given selector.\n\n@param selector is the string to search for.\n@param text is the text to search in.\n@return the found line or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void text(final CharSequence text) { if (!strip) { super.text(text); return; } int textLength = text.length(); char[] dest = new char[textLength]; int ndx = 0; boolean regularChar = true; for (int i = 0; i < textLength; i++) { char c = text.charAt(i); if (CharUtil.isWhitespace(c)) { if (regularChar) { regularChar = false; c = ' '; } else { continue; } } else { regularChar = true; } dest[ndx] = c; ndx++; } if (regularChar || (ndx != 1)) { super.text(CharBuffer.wrap(dest, 0, ndx)); strippedCharsCount += textLength - ndx; } else { strippedCharsCount += textLength; } }\n\n    ### Response:", "ground_truth": "Cleans unnecessary whitespaces.", "predict": " Strips the whitespace characters from the beginning and end of the text and replaces them with a single space character.\n\n@param text is the text to be stripped.\n@return the stripped text.\n\n    "}, {"ID": 1138, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:hiddenfield\") public <T, U extends T> void register(final Class<T> type, final Set<EventHandler<U>> handlers) { this.handlers.put(type, new ExceptionHandlingEventHandler<>( new BroadCastEventHandler<>(handlers), this.errorHandler)); }\n\n    ### Response: Register a new event handler.\n\n@param type     Message type to process with this handler.\n@param handlers A set of handlers that process that type of message.\n@param       Message type.\n@param       Type of message that event handler supports. Must be a subclass of T..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) { converters.put(type, typeConverter); }\n\n    ### Response:", "ground_truth": "Registers a converter for specified type.\nUser must register converter for all super-classes as well.\n\n@param type\t\tclass that converter is for\n@param typeConverter\tconverter for provided class", "predict": " Register a new type converter.\n\n@param type            Type to convert.\n@param typeConverter   Converter to use for the given type."}, {"ID": 1139, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PriorityConverter getConverter(Type type) { PriorityConverter converter = converters.get(type); return converter; }\n\n    ### Response: Get a converter for the given type\n\n@param \n\n@param type the type to find a converter for\n@return the converter for the given type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); }\n\n    ### Response:", "ground_truth": "Retrieves converter for provided type. Only registered types are matched,\ntherefore subclasses must be also registered.\n\n@return founded converter or null", "predict": "Lookup a converter for the given type\n\n@param \n\n@param type the type to find a converter for\n@return the converter for the given type."}, {"ID": 1140, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String select(final int index) { checkIsInMultiOrPipeline(); client.select(index); String statusCodeReply = client.getStatusCodeReply(); client.setDb(index); return statusCodeReply; }\n\n    ### Response: Select the DB with having the specified zero-based numeric index. For default every new client\nconnection is automatically selected to DB 0.\n@param index\n@return Status code reply.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Node> select(final String query) { Collection<List<CssSelector>> selectorsCollection = CSSelly.parse(query); return select(selectorsCollection); }\n\n    ### Response:", "ground_truth": "Selects nodes using CSS3 selector query.", "predict": " Selects nodes based on the given CSS selectors.\n@param query CSS selectors\n@return List of selected nodes."}, {"ID": 1141, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Node> getConnectedNodes() { List<Node> nodes = new ArrayList<>(); for (Link l : links) { if (l.getElement() instanceof Node) { nodes.add((Node) l.getElement()); } } return nodes; }\n\n    ### Response: Get the full list of nodes that have been connected into the network\n\n@return the list of nodes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { List<Node> results = new ArrayList<>(); for (List<CssSelector> selectors : selectorsCollection) { processSelectors(results, selectors); } return results; }\n\n    ### Response:", "ground_truth": "Selected nodes using pre-parsed CSS selectors. Take in consideration\ncollection type for results grouping order.", "predict": " Select nodes based on a collection of CSS selectors.\n\n@param selectorsCollection the collection of CSS selectors to use for selection.\n@return the list of selected nodes."}, {"ID": 1142, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setDirectTextContent(final Node elementToChange, final String asString) { assert elementToChange.getNodeType() != Node.DOCUMENT_NODE; if (Node.ATTRIBUTE_NODE == elementToChange.getNodeType()) { elementToChange.setTextContent(asString); return; } List<Node> nodes = new LinkedList<Node>(); List<Node> nodes2 = new LinkedList<Node>(); for (Node n : nodeListToIterator(elementToChange.getChildNodes())) { if (Node.TEXT_NODE == n.getNodeType()) { continue; } nodes.add(n); } if ((asString != null) && (!asString.isEmpty())) { elementToChange.setTextContent(asString); for (Node n : nodeListToIterator(elementToChange.getChildNodes())) { if (Node.TEXT_NODE != n.getNodeType()) { continue; } nodes.add(n); } } removeAllChildren(elementToChange); for (Node n : nodes) { elementToChange.appendChild(n); } for (Node n : nodes2) { elementToChange.appendChild(n); } }\n\n    ### Response: Set text content of given element without removing existing child nodes. Text nodes are added\nafter child element nodes always.\n\n@param elementToChange\n@param asString.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) { List<Node> selectedNodes = select(rootNode, selectors); for (Node selectedNode : selectedNodes) { if (!results.contains(selectedNode)) { results.add(selectedNode); } } }\n\n    ### Response:", "ground_truth": "Process selectors and keep adding results.", "predict": " Process CSS selectors on the root node and add matching nodes to the results list.\n\n@param results\n@param selectors."}, {"ID": 1143, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validateTableRow(final Node row, final int numColumns) { assert row != null; assert row.getNodeName().equals(\"row\") || row.getNodeName().equals(\"tr\"); if (row.getNodeName().equals(\"row\")) { final List<Node> entries = XMLUtilities.getDirectChildNodes(row, \"entry\"); final List<Node> entryTbls = XMLUtilities.getDirectChildNodes(row, \"entrytbl\"); if ((entries.size() + entryTbls.size()) <= numColumns) { for (final Node entryTbl : entryTbls) { if (!validateEntryTbl((Element) entryTbl)) return false; } return true; } else { return false; } } else { final List<Node> nodes = XMLUtilities.getDirectChildNodes(row, \"td\", \"th\"); return nodes.size() <= numColumns; } }\n\n    ### Response: Check to ensure that a docbook row has the required number of columns for a table.\n\n@param row        The DOM row element to be checked.\n@param numColumns The number of entry elements that should exist in the row.\n@return True if the row has the required number of entries, otherwise false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node selectFirst(final String query) { List<Node> selectedNodes = select(query); if (selectedNodes.isEmpty()) { return null; } return selectedNodes.get(0); }\n\n    ### Response:", "ground_truth": "Selects nodes using CSS3 selector query and returns the very first one.", "predict": " Selects the first node that matches the given query.\n\n@param query The XPath query to match nodes.\n@return The first node that matches the query, or null if no nodes match."}, {"ID": 1144, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void assignClickListenerRecursively(View parent) { if (parent == null) { return; } if (parent instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) parent; int childCount = viewGroup.getChildCount(); for (int i = childCount - 1; i >= 0; i--) { View child = viewGroup.getChildAt(i); assignClickListenerRecursively(child); } } setClickListener(parent); }\n\n    ### Response: Loop among the views in the hierarchy and assign listener to them.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void walkDescendantsIteratively(final LinkedList<Node> nodes, final CssSelector cssSelector, final List<Node> result) { while (!nodes.isEmpty()) { Node node = nodes.removeFirst(); selectAndAdd(node, cssSelector, result); // append children in walking order to be processed right after this node int childCount = node.getChildNodesCount(); for (int i = childCount - 1; i >= 0; i--) { nodes.addFirst(node.getChild(i)); } } }\n\n    ### Response:", "ground_truth": "Walks over the child notes, maintaining the tree order and not using recursion.", "predict": " Traverse the DOM tree in a depth-first order and select nodes that match the given CSS selector. The selected nodes are added to the result list."}, {"ID": 1145, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void readProcessingInstructions(final Document doc) { final NodeList docNodes = doc.getChildNodes(); for (int i = 0; i < docNodes.getLength(); i++) { final Node node = docNodes.item(i); if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { final ProcessingInstruction pi = (ProcessingInstruction) node; switch (pi.getNodeName()) { case PI_WORKDIR_TARGET: workdir = pi; break; case PI_WORKDIR_TARGET_URI: workdirUrl = pi; break; case PI_PATH2PROJ_TARGET: path2proj = pi; break; case PI_PATH2PROJ_TARGET_URI: path2projUrl = pi; break; case PI_PATH2ROOTMAP_TARGET_URI: path2rootmapUrl = pi; break; } } } }\n\n    ### Response: Read processing metadata from processing instructions..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void walk(final Node rootNode, final CssSelector cssSelector, final List<Node> result) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector.getPrevCssSelector(); Combinator combinator = previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT; switch (combinator) { case DESCENDANT: LinkedList<Node> nodes = new LinkedList<>(); int childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { nodes.add(rootNode.getChild(i)); // recursive // selectAndAdd(node, cssSelector, result); // walk(node, cssSelector, result); } walkDescendantsIteratively(nodes, cssSelector, result); break; case CHILD: childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node node = rootNode.getChild(i); selectAndAdd(node, cssSelector, result); } break; case ADJACENT_SIBLING: Node node = rootNode.getNextSiblingElement(); if (node != null) { selectAndAdd(node, cssSelector, result); } break; case GENERAL_SIBLING: node = rootNode; while (true) { node = node.getNextSiblingElement(); if (node == null) { break; } selectAndAdd(node, cssSelector, result); } break; } }\n\n    ### Response:", "ground_truth": "Finds nodes in the tree that matches single selector.", "predict": " Walks the DOM tree and selects nodes that match the given CSS selector.\n\n    "}, {"ID": 1146, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visit(final NodeTraversal t, final Node n, final Node p) { final JSDocInfo info = n.getJSDocInfo(); if (info == null) { return; } final JSTypeRegistry registry = compiler.getTypeRegistry(); final List<Node> thrownTypes = transform( info.getThrownTypes(), new Function<JSTypeExpression, Node>() { @Override public Node apply(JSTypeExpression expr) { return expr.getRoot(); } }); final Scope scope = t.getScope(); for (Node typeRoot : info.getTypeNodes()) { NodeUtil.visitPreOrder( typeRoot, new NodeUtil.Visitor() { @Override public void visit(Node node) { if (!node.isString()) { return; } if (thrownTypes.contains(node)) { return; } Node parent = node.getParent(); if (parent != null) { switch (parent.getToken()) { case BANG: case QMARK: case THIS: // The names inside function(this:Foo) and case NEW: // function(new:Bar) are already non-null. case TYPEOF: // Names after 'typeof' don't have nullability. return; case PIPE: { // Inside a union Node gp = parent.getParent(); if (gp != null && gp.getToken() == Token.QMARK) { return; // Inside an explicitly nullable union } for (Node child : parent.children()) { if ((child.isString() && child.getString().equals(\"null\")) || child.getToken() == Token.QMARK) { return; // Inside a union that contains null or nullable type } } break; } default: break; } } String typeName = node.getString(); if (typeName.equals(\"null\") || registry.getType(scope, typeName) == null) { return; } JSType type = registry.createTypeFromCommentNode(node); if (type.isNullable()) { compiler.report(JSError.make(node, IMPLICITLY_NULLABLE_JSDOC, typeName)); } } }, Predicates.alwaysTrue()); } }\n\n    ### Response: Crawls the JSDoc of the given node to find any names in JSDoc\nthat are implicitly null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void selectAndAdd(final Node node, final CssSelector cssSelector, final List<Node> result) { // ignore all nodes that are not elements if (node.getNodeType() != Node.NodeType.ELEMENT) { return; } boolean matched = cssSelector.accept(node); if (matched) { // check for duplicates if (result.contains(node)) { return; } // no duplicate found, add it to the results result.add(node); } }\n\n    ### Response:", "ground_truth": "Selects single node for single selector and appends it to the results.", "predict": "Selects and adds the given node to the result list if it matches the given CSS selector.\n\n    "}, {"ID": 1147, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int renderNodes(final StringBuilder stringBuilder, final List<Node> nodes, final int index, final List<String> mustacheKeys, final Map<Integer, Node> cachedNodes) { int newIndex = index; final Iterator<Node> iterator = nodes.iterator(); while (iterator.hasNext()) { final Node node = iterator.next(); newIndex = this.renderNode(stringBuilder, mustacheKeys, cachedNodes, newIndex, node, true); if (iterator.hasNext()) { stringBuilder.append(\",\"); } } return newIndex; }\n\n    ### Response: Renders a list of entities required by trivial components tree.\n\n@param nodes         a list of nodes that should be rendered\n@param index         index of corresponding node (should match cachedNodes\n@param mustacheKeys  optional mustache keys\n@param cachedNodes   a map of node number to node\n@param stringBuilder the builder\n@return the last rendered index + 1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean filter(final List<Node> currentResults, final Node node, final CssSelector cssSelector, final int index) { return cssSelector.accept(currentResults, node, index); }\n\n    ### Response:", "ground_truth": "Filter nodes.", "predict": "Checks if a node matches a CSS selector.\n\n@param currentResults the current list of matching nodes\n@param node           the node to check\n@param cssSelector    the CSS selector to match against\n@param index          the index of the node in the list\n@return true if the node matches the selector, false otherwise."}, {"ID": 1148, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static private int indexOfNthOccurrenceOfCharIn(String str, char ch, int n) { boolean inMiddleOfQuote = false; int index = -1, previousIndex = 0; for (int i=0; i < n; i++) { do { index = str.indexOf(ch, index+1); if (index < 0) { return -1; } if (hasOddNumberOfSingleQuotes(str.substring(previousIndex, index))) { inMiddleOfQuote = !inMiddleOfQuote; } previousIndex = index; } while (inMiddleOfQuote); } return index; }\n\n    ### Response: Returns the Nth occurrence of the specified character in the specified\nString, but ignoring those contained in single quotes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static char [] zzUnpackCMap(final String packed) { char [] map = new char[0x110000]; int i = 0; /* index in packed string */ int j = 0; /* index in unpacked array */ while (i < 128) { int count = packed.charAt(i++); char value = packed.charAt(i++); do map[j++] = value; while (--count > 0); } return map; }\n\n    ### Response:", "ground_truth": "Unpacks the compressed character translation table.\n\n@param packed   the packed character translation table\n@return         the unpacked character translation table", "predict": " Unpacks the compressed character mapping table packed into the specified string into a new character array."}, {"ID": 1149, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean wellKnownTypeArgument(NewClassTree tree, VisitorState state) { Type type = getType(tree); if (type == null) { return false; } type = state.getTypes().asSuper(type, state.getSymbolFromString(\"java.lang.ThreadLocal\")); if (type == null) { return false; } if (type.getTypeArguments().isEmpty()) { return false; } Type argType = getOnlyElement(type.getTypeArguments()); if (WELL_KNOWN_TYPES.contains(argType.asElement().getQualifiedName().toString())) { return true; } if (isSubtype(argType, state.getTypeFromString(\"java.text.DateFormat\"), state)) { return true; } return false; }\n\n    ### Response: Ignore some common ThreadLocal type arguments that are fine to have per-instance copies of..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean zzRefill() { if (zzBuffer == null) { zzBuffer = zzChars; zzEndRead += zzChars.length; return false; } return true; }\n\n    ### Response:", "ground_truth": "Refills the input buffer.\n\n@return      false, iff there was new input.", "predict": "This method refills the buffer if it is null, which means it hasn't been filled yet. It returns false if the buffer was not refilled, indicating that the caller should continue to use the existing buffer."}, {"ID": 1150, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<String, Object> buildSQLCount(final int currentPageNum, final int pageSize, final int pageCount, final Query query, final StringBuilder sqlBuilder, final List<Object> paramList) throws RepositoryException { final Map<String, Object> ret = new HashMap<>(); int pageCnt = pageCount; int recordCnt = 0; final StringBuilder selectBuilder = new StringBuilder(); final StringBuilder whereBuilder = new StringBuilder(); final StringBuilder orderByBuilder = new StringBuilder(); buildSelect(selectBuilder, query.getProjections()); buildWhere(whereBuilder, paramList, query.getFilter()); buildOrderBy(orderByBuilder, query.getSorts()); if (-1 == pageCount) { final StringBuilder countBuilder = new StringBuilder(\"SELECT COUNT(\" + JdbcRepositories.getDefaultKeyName() + \") FROM \").append(getName()); if (StringUtils.isNotBlank(whereBuilder.toString())) { countBuilder.append(\" WHERE \").append(whereBuilder); } recordCnt = (int) count(countBuilder, paramList); if (0 == recordCnt) { ret.put(Pagination.PAGINATION_PAGE_COUNT, 0); ret.put(Pagination.PAGINATION_RECORD_COUNT, 0); return ret; } pageCnt = (int) Math.ceil((double) recordCnt / (double) pageSize); } ret.put(Pagination.PAGINATION_PAGE_COUNT, pageCnt); ret.put(Pagination.PAGINATION_RECORD_COUNT, recordCnt); final int start = (currentPageNum - 1) * pageSize; final int end = start + pageSize; sqlBuilder.append(JdbcFactory.getInstance(). queryPage(start, end, selectBuilder.toString(), whereBuilder.toString(), orderByBuilder.toString(), getName())); return ret; }\n\n    ### Response: Builds query SQL and count result.\n\n@param currentPageNum currentPageNum\n@param pageSize       pageSize\n@param pageCount      if the pageCount specified with {@code -1}, the returned (pageCnt, recordCnt) value will be\ncalculated, otherwise, the returned pageCnt will be this pageCount, and recordCnt will be {@code 0}, means these\nvalues will not be calculated\n@param query          query\n@param sqlBuilder     the specified SQL builder\n@param paramList      paramList\n@return &lt;pageCnt, Integer&gt;,\n&lt;recordCnt, Integer&gt;\n@throws RepositoryException RepositoryException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) { if (sortColumnName != null) { sql = buildOrderSql(sql, sortColumnName, ascending); } int from = (page - 1) * pageSize; String pageSql = buildPageSql(sql, from, pageSize); DbSqlBuilder dbsql = sql(pageSql); DbOomQuery query = query(dbsql); query.setMaxRows(pageSize); query.setFetchSize(pageSize); query.setMap(params); List<T> list = query.list(pageSize, target); query.close(); String countSql = buildCountSql(sql); dbsql = sql(countSql); query = query(dbsql); query.setMap(params); long count = query.executeCount(); query.close(); return new PageData<>(page, (int) count, pageSize, list); }\n\n    ### Response:", "ground_truth": "Pages given page.\n\n@param sql sql query that lists all items\n@param params map of SQL parameters\n@param page current page to show\n@param pageSize number of items to show\n@param sortColumnName name of sorting column, null for no sorting\n@param ascending true for ascending order\n@param target db entities for mapping (sa usual in DbOom)", "predict": " Executes the given SQL query with the given parameters and returns a page of results.\n\n@param sql the SQL query to execute\n@param params the parameters to bind to the query\n@param page the page number (1-based)\n@param pageSize the page size\n@param sortColumnName the name of the column to sort by, or null to sort by the primary key\n@param ascending true to sort in ascending order, false to sort in descending order\n@param target the target class for the result set\n@return the page of results\n@throws RepositoryException if an error occurs executing the query\n\n    "}, {"ID": 1151, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeSelect(String sql) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"select\"); if (ndx != -1) { sql = sql.substring(ndx + 6); // select.length() } return sql; }\n\n    ### Response:", "ground_truth": "Removes the first 'select' from the sql query.", "predict": " Remove the \"select\" keyword from the beginning of the SQL statement.\n\n@param sql the SQL statement to remove the \"select\" keyword from\n@return the SQL statement with the \"select\" keyword removed\n\n    "}, {"ID": 1152, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeToFrom(String sql) { int from = 0; int fromCount = 1; int selectCount = 0; int lastNdx = 0; while (true) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from); if (ndx == -1) { break; } // count selects in left part String left = sql.substring(lastNdx, ndx); selectCount += StringUtil.countIgnoreCase(left, \"select\"); if (fromCount >= selectCount) { sql = sql.substring(ndx); break; } // find next 'from' lastNdx = ndx; from = ndx + 4; fromCount++; } return sql; }\n\n    ### Response:", "ground_truth": "Removes the first part of the sql up to the relevant 'from'.\nTries to detect sub-queries in the 'select' part.", "predict": " Remove the \"to\" keyword from the SQL statement.  This is useful when generating SQL statements for Oracle databases, which do not support the \"to\" keyword.\n\n@param sql the SQL statement\n@return the modified SQL statement\n\n    "}, {"ID": 1153, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeLastOrderBy(String sql) { int ndx = StringUtil.lastIndexOfIgnoreCase(sql, \"order by\"); if (ndx != -1) { int ndx2 = sql.lastIndexOf(sql, ')'); if (ndx > ndx2) { sql = sql.substring(0, ndx); } } return sql; }\n\n    ### Response:", "ground_truth": "Removes everything from last \"order by\".", "predict": " Remove the last \"ORDER BY\" clause from the SQL statement.\n\n@param sql the SQL statement\n@return the SQL statement with the last \"ORDER BY\" clause removed, or the original SQL statement if no \"ORDER BY\" clause was found."}, {"ID": 1154, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getServletPackageName() { if (isTagFile()) { String className = tagInfo.getTagClassName(); int lastIndex = className.lastIndexOf('.'); String pkgName = \"\"; if (lastIndex != -1) { pkgName = className.substring(0, lastIndex); } return pkgName; } else { String dPackageName = getDerivedPackageName(); if (dPackageName.length() == 0) { return basePackageName; } return basePackageName + '.' + getDerivedPackageName(); } }\n\n    ### Response: Package name for the generated class is make up of the base package\nname, which is user settable, and the derived package name.  The\nderived package name directly mirrors the file hierarchy of the JSP page.\n@return the package name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(final String html) { int ndx = html.indexOf('&'); if (ndx == -1) { return html; } StringBuilder result = new StringBuilder(html.length()); int lastIndex = 0; int len = html.length(); mainloop: while (ndx != -1) { result.append(html.substring(lastIndex, ndx)); lastIndex = ndx; while (html.charAt(lastIndex) != ';') { lastIndex++; if (lastIndex == len) { lastIndex = ndx; break mainloop; } } if (html.charAt(ndx + 1) == '#') { // decimal/hex char c = html.charAt(ndx + 2); int radix; if ((c == 'x') || (c == 'X')) { radix = 16; ndx += 3; } else { radix = 10; ndx += 2; } String number = html.substring(ndx, lastIndex); int i = Integer.parseInt(number, radix); result.append((char) i); lastIndex++; } else { // token String encodeToken = html.substring(ndx + 1, lastIndex); char[] replacement = ENTITY_MAP.get(encodeToken); if (replacement == null) { result.append('&'); lastIndex = ndx + 1; } else { result.append(replacement); lastIndex++; } } ndx = html.indexOf('&', lastIndex); } result.append(html.substring(lastIndex)); return result.toString(); }\n\n    ### Response:", "ground_truth": "Decodes HTML text. Assumes that all character references are properly closed with semi-colon.", "predict": " Decodes HTML entities in the given string.\n@param html the string to decode\n@return the decoded string\n\n    "}, {"ID": 1155, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public UserDetails loadUserDetails(OpenIDAuthenticationToken token) { if (token == null) { return null; } User user = new User(); user.setIdentifier(token.getIdentityUrl()); user = loadUser(user); if (user == null) { // create new OpenID user String email = \"email@domain.com\"; String firstName = null, lastName = null, fullName = null; List<OpenIDAttribute> attributes = token.getAttributes(); for (OpenIDAttribute attribute : attributes) { if (attribute.getName().equals(\"email\")) { email = attribute.getValues().get(0); } if (attribute.getName().equals(\"firstname\")) { firstName = attribute.getValues().get(0); } if (attribute.getName().equals(\"lastname\")) { lastName = attribute.getValues().get(0); } if (attribute.getName().equals(\"fullname\")) { fullName = attribute.getValues().get(0); } } if (fullName == null) { if (firstName == null) { firstName = \"No\"; } if (lastName == null) { lastName = \"Name\"; } fullName = firstName.concat(\" \").concat(lastName); } user = new User(); user.setActive(true); user.setEmail(email); user.setName(fullName); user.setPassword(Utils.generateSecurityToken()); user.setIdentifier(token.getIdentityUrl()); String id = user.create(); if (id == null) { throw new BadCredentialsException(\"Authentication failed: cannot create new user.\"); } } return new AuthenticatedUserDetails(user); }\n\n    ### Response: Loads a user from the data store or creates a new user from an OpenID profile.\n@param token the OpenID authentication token holding the user profile\n@return a user object or null if user is not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String detectName(final char[] input, int ndx) { final Ptr ptr = new Ptr(); int firstIndex = 0; int lastIndex = ENTITY_NAMES.length - 1; int len = input.length; char[] lastName = null; final BinarySearchBase binarySearch = new BinarySearchBase() { @Override protected int compare(final int index) { char[] name = ENTITY_NAMES[index]; if (ptr.offset >= name.length) { return -1; } return name[ptr.offset] - ptr.c; } }; while (true) { ptr.c = input[ndx]; if (!CharUtil.isAlphaOrDigit(ptr.c)) { return lastName != null ? new String(lastName) : null; } firstIndex = binarySearch.findFirst(firstIndex, lastIndex); if (firstIndex < 0) { return lastName != null ? new String(lastName) : null; } char[] element = ENTITY_NAMES[firstIndex]; if (element.length == ptr.offset + 1) { // total match, remember position, continue for finding the longer name lastName = ENTITY_NAMES[firstIndex]; } lastIndex = binarySearch.findLast(firstIndex, lastIndex); if (firstIndex == lastIndex) { // only one element found, check the rest for (int i = ptr.offset; i < element.length; i++) { if (element[i] != input[ndx]) { return lastName != null ? new String(lastName) : null; } ndx++; } return new String(element); } ptr.offset++; ndx++; if (ndx == len) { return lastName != null ? new String(lastName) : null; } } }\n\n    ### Response:", "ground_truth": "Detects the longest character reference name on given position in char array.", "predict": " Detects the name of an entity in a text based on the input character array and starting index.\n@param input the character array to search for the entity name\n@param ndx the starting index in the input array\n@return the detected entity name or null if no entity name is found.\n\n    "}, {"ID": 1156, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Message> getFilteredList( EMessageType messageType, Long fromTsMillis, Long toTsMillis, long limit ) throws Exception { String tableName = TABLE_MESSAGES; String sql = \"select \" + getQueryFieldsString() + \" from \" + tableName; List<String> wheresList = new ArrayList<>(); if (messageType != null && messageType != EMessageType.ALL) { String where = type_NAME + \"=\" + messageType.getCode(); wheresList.add(where); } if (fromTsMillis != null) { String where = TimeStamp_NAME + \">\" + fromTsMillis; wheresList.add(where); } if (toTsMillis != null) { String where = TimeStamp_NAME + \"<\" + toTsMillis; wheresList.add(where); } if (wheresList.size() > 0) { sql += \" WHERE \"; for( int i = 0; i < wheresList.size(); i++ ) { if (i > 0) { sql += \" AND \"; } sql += wheresList.get(i); } } sql += \" order by \" + ID_NAME + \" desc\"; if (limit > 0) { sql += \" limit \" + limit; } String _sql = sql; List<Message> messages = new ArrayList<Message>(); logDb.execOnConnection(connection -> { try (IHMStatement stmt = connection.createStatement(); IHMResultSet rs = stmt.executeQuery(_sql);) { while( rs.next() ) { Message event = resultSetToItem(rs); messages.add(event); } } return null; }); return messages; }\n\n    ### Response: Get the list of messages, filtered.\n\n@param messageType the type to filter.\n@param fromTsMillis the start time in millis.\n@param toTsMillis the end time in millis.\n@param limit the max number of messages.\n@return the list of messages.\n@throws Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String buildOrderSql(String sql, final String column, final boolean ascending) { sql += \" order by \" + column; if (!ascending) { sql += \" desc\"; } return sql; }\n\n    ### Response:", "ground_truth": "Appends ORDER BY keyword.", "predict": " Build the order sql for the given column and order.\n\n@param sql the original sql.\n@param column the column to order by.\n@param ascending true for ascending order, false for descending order.\n@return the order sql."}, {"ID": 1157, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected long createTaskInternal(final String name, final String channel, final String data, final String key1, final String key2, final Long batchId, int postponeSec, TedStatus status) { final String sqlLogId = \"create_task\"; if (status == null) status = TedStatus.NEW; String nextts = (status == TedStatus.NEW ? dbType.sql.now() + \" + \" + dbType.sql.intervalSeconds(postponeSec) : \"null\"); String sql = \" insert into tedtask (taskId, `system`, name, channel, bno, status, createTs, nextTs, retries, data, key1, key2, batchId)\" + \" values(null, '$sys', ?, ?, null, '$status', $now, $nextts, 0, ?, ?, ?, ?)\" + \" \"; sql = sql.replace(\"$nextTaskId\", dbType.sql.sequenceSql(\"SEQ_TEDTASK_ID\")); sql = sql.replace(\"$now\", dbType.sql.now()); sql = sql.replace(\"$sys\", thisSystem); sql = sql.replace(\"$nextts\", nextts); sql = sql.replace(\"$status\", status.toString()); final String finalSql = sql; Long taskId = JdbcSelectTed.runInConn(dataSource, new ExecInConn<Long>() { @Override public Long execute(Connection connection) throws SQLException { int res = JdbcSelectTedImpl.executeUpdate(connection, finalSql, asList( sqlParam(name, JetJdbcParamType.STRING), sqlParam(channel, JetJdbcParamType.STRING), sqlParam(data, JetJdbcParamType.STRING), sqlParam(key1, JetJdbcParamType.STRING), sqlParam(key2, JetJdbcParamType.STRING), sqlParam(batchId, JetJdbcParamType.LONG) )); if (res != 1) throw new IllegalStateException(\"expected 1 insert\"); String sql = \"select last_insert_id()\"; return JdbcSelectTedImpl.selectSingleLong(connection, sql, Collections.<SqlParam>emptyList()); } }); logger.trace(\"Task {} {} created successfully. \", name, taskId); return taskId; }\n\n    ### Response: taskid is autonumber in MySql.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String buildPageSql(String sql, final int from, final int pageSize) { sql = removeSelect(sql); return \"select LIMIT \" + from + ' ' + pageSize + sql; }\n\n    ### Response:", "ground_truth": "Builds page sql using LIMIT keyword after the SELECT.", "predict": "This method is used to build the SQL query for pagination. It removes the SELECT keyword from the SQL query and adds the LIMIT keyword with the given from and pageSize parameters."}, {"ID": 1158, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void updateRequiredDeclarations(Constraint constraint) { Declaration[] decs = constraint.getRequiredDeclarations(); if ( decs != null && decs.length > 0 ) { for (Declaration dec1 : decs) { Declaration dec = dec1; // check for duplications for (Declaration requiredDeclaration : this.requiredDeclarations) { if (dec.equals(requiredDeclaration)) { dec = null; break; } } if (dec != null) { Declaration[] tmp = this.requiredDeclarations; this.requiredDeclarations = new Declaration[tmp.length + 1]; System.arraycopy(tmp, 0, this.requiredDeclarations, 0, tmp.length); this.requiredDeclarations[this.requiredDeclarations.length - 1] = dec; } } } }\n\n    ### Response: Updades the cached required declaration array\n\n@param constraint.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void resolveColumnsAndProperties(final Class type) { PropertyDescriptor[] allProperties = ClassIntrospector.get().lookup(type).getAllPropertyDescriptors(); List<DbEntityColumnDescriptor> decList = new ArrayList<>(allProperties.length); int idcount = 0; HashSet<String> names = new HashSet<>(allProperties.length); for (PropertyDescriptor propertyDescriptor : allProperties) { DbEntityColumnDescriptor dec = DbMetaUtil.resolveColumnDescriptors(this, propertyDescriptor, isAnnotated, columnNamingStrategy); if (dec != null) { if (!names.add(dec.getColumnName())) { throw new DbOomException(\"Duplicate column name: \" + dec.getColumnName()); } decList.add(dec); if (dec.isId) { idcount++; } } } if (decList.isEmpty()) { throw new DbOomException(\"No column mappings in entity: \" + type); } columnDescriptors = decList.toArray(new DbEntityColumnDescriptor[0]); Arrays.sort(columnDescriptors); // extract ids from sorted list if (idcount > 0) { idColumnDescriptors = new DbEntityColumnDescriptor[idcount]; idcount = 0; for (DbEntityColumnDescriptor dec : columnDescriptors) { if (dec.isId) { idColumnDescriptors[idcount++] = dec; } } } }\n\n    ### Response:", "ground_truth": "Resolves list of all columns and properties.", "predict": "Resolves the column and property mappings for the given entity type.\n\n@param type the entity type."}, {"ID": 1159, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Column getColumn(String columnName) { if (columnName == null) { return null; } for (Column column : columns) { if (columnName.equals(column.getData())) { return column; } } return null; }\n\n    ### Response: Find a column by its name\n\n@param columnName the name of the column\n@return the given Column, or null if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityColumnDescriptor findByColumnName(final String columnName) { if (columnName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.columnName.equalsIgnoreCase(columnName)) { return columnDescriptor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds column descriptor by column name. Case is ignored.", "predict": " Find a DbEntityColumnDescriptor by its column name\n\n@param columnName the name of the column\n@return the given DbEntityColumnDescriptor, or null if not found."}, {"ID": 1160, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object get(Object propertyName) { if (propertyName instanceof CharSequence) { propertyName = propertyName.toString(); } if (propertyName instanceof List) { Map submap = new HashMap(); List propertyNames = (List)propertyName; for (Object currentName : propertyNames) { if (currentName != null) { currentName = currentName.toString(); if (containsKey(currentName)) { submap.put(currentName, get(currentName)); } } } return submap; } if (NameUtils.isConfigurational(propertyName.toString())) { return null; } Object val = null; MetaProperty mp = metaClass.getMetaProperty(propertyName.toString()); if (mp != null) { val = mp.getProperty(instance); } return val; }\n\n    ### Response: Obtains the value of an object's properties on demand using Groovy's MOP.\n\n@param propertyName The name of the property\n@return The property value or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityColumnDescriptor findByPropertyName(final String propertyName) { if (propertyName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.propertyName.equals(propertyName)) { return columnDescriptor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds column descriptor by property name.", "predict": " Finds a column descriptor by its property name.\n\n@param propertyName The name of the property\n@return The column descriptor or null."}, {"ID": 1161, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DateTime getDateTime(final ResultSet rs, final String columnName) throws SQLException { final Timestamp ts = rs.getTimestamp(columnName); return (ts == null) ? null : new DateTime(ts); }\n\n    ### Response: Returns a DateTime object representing the date or null if the input is null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPropertyName(final String columnName) { DbEntityColumnDescriptor dec = findByColumnName(columnName); return dec == null ? null : dec.propertyName; }\n\n    ### Response:", "ground_truth": "Returns property name for specified column name.", "predict": " Returns the property name for the given column name. If the column name is not found, returns null."}, {"ID": 1162, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String toAlias(String propertyName) { String result = propertyAliasType.get(propertyName); return result == null ? propertyName : result; }\n\n    ### Response: Returns alias for name if it exists, or the original name if not.\n\n@param propertyName Property name.\n@return Alias if exists, original name if not..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getColumnName(final String propertyName) { DbEntityColumnDescriptor dec = findByPropertyName(propertyName); return dec == null ? null : dec.columnName; }\n\n    ### Response:", "ground_truth": "Returns column name for specified property name..", "predict": " Returns the column name for the given property name.\n\n@param propertyName Property name.\n@return Column name for the given property name."}, {"ID": 1163, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getAsText() { Object value = getValue(); if (value == null) { return \"\"; } String propertyName = null; // used in error handling below try { StringBuffer label = new StringBuffer(); for (int i = 0; i < properties.length; i++) { propertyName = properties[i]; Class<?> propertyType = PropertyUtils.getPropertyType(value, propertyName); Object propertyValue = PropertyUtils.getNestedProperty(value, propertyName); PropertyEditor editor = registry.findCustomEditor(propertyType, registryPropertyNamePrefix + propertyName); if (editor == null) { label.append(propertyValue); } else { editor.setValue(propertyValue); label.append(editor.getAsText()); editor.setValue(null); } if (i < (properties.length - 1)) { label.append(separator); } } return label.toString(); } catch (Exception e) { throw new IllegalArgumentException(\"Couldn't access \" + propertyName + \" of \" + value.getClass().getName() + \" : \" + e.getMessage(), e); } }\n\n    ### Response: Format the Object as String of concatenated properties..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getIdValue(final E object) { final String propertyName = getIdPropertyName(); return BeanUtil.declared.getProperty(object, propertyName); }\n\n    ### Response:", "ground_truth": "Returns ID value for given entity instance.", "predict": " Get the value of the id property of the given object."}, {"ID": 1164, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int copyProperty( final Object dst, final Object src, final String propertyName ) { int count = 0; if (isPropertyGettable( src, propertyName ) && isPropertySettable( dst, propertyName )) { Object value = getProperty( src, propertyName ); setProperty( dst, propertyName, value ); count++; } return count; }\n\n    ### Response: Copies the property from the object to the other object.\n\n@param   dst\nthe destination object to which the property value is set.\n@param   src\nthe source object from which the property value is got.\n@param   propertyName\nthe property name.\n@return\nthe number of properties copied; zero or one..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setIdValue(final E object, final Object value) { final String propertyName = getIdPropertyName(); BeanUtil.declared.setProperty(object, propertyName, value); }\n\n    ### Response:", "ground_truth": "Sets ID value for given entity.", "predict": " Sets the value of the id property of the given object.\n\n@param   object\nthe object whose id property value is to be set.\n@param   value\nthe new value of the id property."}, {"ID": 1165, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setId(String name, Object value) { if (name == null) { idPropertyName = null; idValue = null; } else { idPropertyName= name; idValue = value; } }\n\n    ### Response: Sets the id property of the feature. This method also allows wiping the current id\nby setting the name of the id to null. The value will in that case be ignored.\n@param name the name of the id property, or null if the geometry property is to be wiped\n@param value the value of the id property of this feature.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getKeyValue(final E object) { Object idValue = getIdValue(object); String idValueString = idValue == null ? StringPool.NULL : idValue.toString(); return type.getName().concat(StringPool.COLON).concat(idValueString); }\n\n    ### Response:", "ground_truth": "Returns unique key for this entity. Returned key\nis built from entity class and id value.", "predict": " Returns the key value for the given object. The key value is a string that consists of the class name of the object and the value of its id property. If the id property is null, the key value will be \"null\".\n@param object the object for which to generate the key value\n@return the key value for the given object\n\n    "}, {"ID": 1166, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String capitalizeFirstWordAsciiOnly(String s) { if (s == null || s.isEmpty()) { return s; } int secondWordStart = s.length(); for (int i = 1; i < s.length(); i++) { if (!isLowerCaseAsciiOnly(s.charAt(i))) { secondWordStart = i; break; } } return toUpperCaseAsciiOnly(s.substring(0, secondWordStart)) + s.substring(secondWordStart); }\n\n    ### Response: \"fooBar\" -> \"FOOBar\"\n\"FooBar\" -> \"FOOBar\"\n\"foo\" -> \"FOO\".\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; }\n\n    ### Response:", "ground_truth": "Appends a string.", "predict": " \"fooBar\" -> \"fooBar\"\n\"FooBar\" -> \"FooBar\"\n\"foo\" -> \"foo\".\n\n    "}, {"ID": 1167, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private double getRandomNeighbor(T[] data, T[] medoids, int[] y, double[] d) { int n = data.length; int index = Math.randomInt(k); T medoid = null; boolean dup; do { dup = false; medoid = data[Math.randomInt(n)]; for (int i = 0; i < k; i++) { if (medoid == medoids[i]) { dup = true; break; } } } while (dup); medoids[index] = medoid; for (int i = 0; i < n; i++) { double dist = distance.d(data[i], medoid); if (d[i] > dist) { y[i] = index; d[i] = dist; } else if (y[i] == index) { d[i] = dist; y[i] = index; for (int j = 0; j < k; j++) { if (j != index) { dist = distance.d(data[i], medoids[j]); if (d[i] > dist) { y[i] = j; d[i] = dist; } } } } } return Math.sum(d); }\n\n    ### Response: Generate a random neighbor which differs in only one medoid with current clusters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setIndex(final int newIndex) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { String[] newArray = new String[newIndex]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } if (newIndex > index) { for (int i = index; i < newIndex; i++) { array[i] = StringPool.EMPTY; } } else if (newIndex < index) { for (int i = newIndex; i < index; i++) { array[i] = null; } } index = newIndex; length = calculateLength(); }\n\n    ### Response:", "ground_truth": "Specifies the new index.", "predict": " Sets the index of the array to the specified value. If the new index is less than zero, throws an ArrayIndexOutOfBoundsException. If the new index is greater than the length of the array, creates a new array with the specified length and copies the contents of the current array to the new array. If the new index is greater than the current index, sets the values of the new elements to StringPool.EMPTY, and if the new index is less than the current index, sets the values of the elements to null. Finally, sets the index and length of the array."}, {"ID": 1168, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] insert(T[] array, int currentSize, int index, T element) { assert currentSize <= array.length; if (currentSize + 1 <= array.length) { System.arraycopy(array, index, array, index + 1, currentSize - index); array[index] = element; return array; } @SuppressWarnings(\"unchecked\") T[] newArray = (T[]) new Object[growSize(currentSize)]; System.arraycopy(array, 0, newArray, 0, index); newArray[index] = element; System.arraycopy(array, index, newArray, index + 1, array.length - index); return newArray; }\n\n    ### Response: Inserts an element into the array at the specified index, growing the array if there is no\nmore room.\n\n@param array       The array to which to append the element. Must NOT be null.\n@param currentSize The number of elements in the array. Must be less than or equal to\narray.length.\n@param element     The element to insert.\n@return the array to which the element was appended. This may be different than the given\narray..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void expandCapacity() { String[] newArray = new String[array.length << 1]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; }\n\n    ### Response:", "ground_truth": "Expands internal string array by multiplying its size by 2.", "predict": " Expands the capacity of the array by doubling its size.\n\n@param array The array to expand."}, {"ID": 1169, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int findStartTrimWhitespace(CharSequence s) { final int len = s.length(); for (int i = 0; i < len; i++) { if (!Character.isWhitespace(s.charAt(i))) { return i; } } return len; }\n\n    ### Response: Finds and returns the start of the given sequence after trimming\nwhitespace characters from the left.\n\n@param s\nthe character sequence\n@return the index containing the first non-whitespace character, or the\nlength of the character sequence if all characters are blank.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int calculateLength() { int len = 0; for (int i = 0; i < index; i++) { len += array[i].length(); } return len; }\n\n    ### Response:", "ground_truth": "Calculates string length.", "predict": " Calculates and returns the length of the array of strings.\n\n@return the length of the array of strings."}, {"ID": 1170, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String checkHeap() { for(int i = 1; i < size; i++) { final int parent = (i - 1) >>> 1; if(comparator.compare(queue[parent], queue[i]) > 0) { return \"@\" + parent + \": \" + queue[parent] + \" < @\" + i + \": \" + queue[i]; } } return null; }\n\n    ### Response: Test whether the heap is still valid.\n\nDebug method.\n\n@return {@code null} when the heap is correct.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createMixingMessage(final BeanDefinition targetBeanDefinition, final BeanDefinition refBeanDefinition) { return \"Scopes mixing detected: \" + refBeanDefinition.name + \"@\" + refBeanDefinition.scope.getClass().getSimpleName() + \" -> \" + targetBeanDefinition.name + \"@\" + targetBeanDefinition.scope.getClass().getSimpleName(); }\n\n    ### Response:", "ground_truth": "Creates mixed scope message.", "predict": " Create a message for a detected scope mixing.\n\n@param targetBeanDefinition the bean definition that declares the target scope\n@param refBeanDefinition the bean definition that declares the reference scope\n@return a message that describes the detected scope mixing"}, {"ID": 1171, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T extends RemoteProxy> T getNewInstance( RegistrationRequest request, GridRegistry registry) { try { String proxyClass = request.getConfiguration().proxy; if (proxyClass == null) { log.fine(\"No proxy class. Using default\"); proxyClass = BaseRemoteProxy.class.getCanonicalName(); } Class<?> clazz = Class.forName(proxyClass); log.fine(\"Using class \" + clazz.getName()); Object[] args = new Object[]{request, registry}; Class<?>[] argsClass = new Class[]{RegistrationRequest.class, GridRegistry.class}; Constructor<?> c = clazz.getConstructor(argsClass); Object proxy = c.newInstance(args); if (proxy instanceof RemoteProxy) { ((RemoteProxy) proxy).setupTimeoutListener(); return (T) proxy; } throw new InvalidParameterException(\"Error: \" + proxy.getClass() + \" isn't a remote proxy\"); } catch (InvocationTargetException e) { throw new InvalidParameterException(\"Error: \" + e.getTargetException().getMessage()); } catch (Exception e) { throw new InvalidParameterException(\"Error: \" + e.getMessage()); } }\n\n    ### Response: Takes a registration request and return the RemoteProxy associated to it. It can be any class\nextending RemoteProxy.\n\n@param request  The request\n@param registry The registry to use\n@param  RemoteProxy subclass\n@return a new instance built from the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object createScopedProxyBean(final PetiteContainer petiteContainer, final BeanDefinition refBeanDefinition) { Class beanType = refBeanDefinition.type; Class proxyClass = proxyClasses.get(beanType); if (proxyClass == null) { // create proxy class only once if (refBeanDefinition instanceof ProxettaBeanDefinition) { // special case, double proxy! ProxettaBeanDefinition pbd = (ProxettaBeanDefinition) refBeanDefinition; ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspects(ArraysUtil.insert(pbd.proxyAspects, aspect, 0)); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(pbd.originalTarget); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } else { ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspect(aspect); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(beanType); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } } Object proxy; try { proxy = ClassUtil.newInstance(proxyClass); Field field = proxyClass.getField(\"$__petiteContainer$0\"); field.set(proxy, petiteContainer); field = proxyClass.getField(\"$__name$0\"); field.set(proxy, refBeanDefinition.name); } catch (Exception ex) { throw new PetiteException(ex); } return proxy; }\n\n    ### Response:", "ground_truth": "Creates scoped proxy bean for given bean definition.", "predict": " Creates a new instance of a scoped proxy bean.\n\n@param petiteContainer the Petite container\n@param refBeanDefinition the bean definition\n@return a new instance of a scoped proxy bean\n\n    "}, {"ID": 1172, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final synchronized void setPriority(byte priority) { if (this.priority == priority) return; if (status == STATUS_STARTED_READY) { if (manager.remove(this)) { this.priority = priority; while (manager.getTransferTarget() != null) manager = manager.getTransferTarget(); manager.addReady(this); return; } } this.priority = priority; }\n\n    ### Response: Change the priority of this task..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void loopBody() throws JspException { JspFragment body = getJspBody(); if (body == null) { return; } LoopIterator loopIterator = new LoopIterator(start, end, step, modulus); if (status != null) { getJspContext().setAttribute(status, loopIterator); } while (loopIterator.next()) { TagUtil.invokeBody(body); } if (status != null) { getJspContext().removeAttribute(status); } }\n\n    ### Response:", "ground_truth": "Loops body.", "predict": " This method is called by the JSP container to execute the body of the loop. It is called repeatedly until the loopIterator has reached the end value. The loopIterator is used to determine the current value of the loop variable and to determine whether to execute the loop body. The loop body is executed by calling the invokeBody method of the TagUtil class. If a status variable is specified, it is set to the current value of the loopIterator before the loop body is executed and removed after the loop body has been executed."}, {"ID": 1173, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static private List<LaunchManifest.RequiredBundle> findExtensionBundles(List<File> dirs) throws IOException { List<LaunchManifest.RequiredBundle> list = new ArrayList<LaunchManifest.RequiredBundle>(); for (File dir : dirs) { if (dir.exists()) { File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (!file.isDirectory() && file.getName().toLowerCase().endsWith(\".jar\")) { String bundles = getRequiredBundles(file); if (bundles != null) { list.addAll(LaunchManifest.parseRequireBundle(bundles)); } } } } } } return list; }\n\n    ### Response: Find Required bundles from the manifest file underneath specified directory recursively.\nthis method does not expect that the parameters are null.\nreturns list of RequredBundle object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void init() { File[] filesArray = dir.listFiles(); filesCount = 0; if (filesArray != null) { filesCount = filesArray.length; for (File file : filesArray) { if (!acceptFile(file)) { continue; } map.put(file, new MutableLong(file.lastModified())); } } }\n\n    ### Response:", "ground_truth": "Initializes dir watcher by reading all files\nfrom watched folder.", "predict": " Initializes the map of files and their last modified times.\nThis method is called by the constructor and expects that the directory is not null.\nThe method accepts a file and adds it to the map only if it is accepted by the acceptFile method.\nThe method returns nothing."}, {"ID": 1174, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean matchesPatternList(final String str, final List<Pattern> patterns) { if (patterns != null) { for (final Pattern pattern : patterns) { if (pattern.matcher(str).matches()) { return true; } } } return false; }\n\n    ### Response: Check if a string matches one of the patterns in the provided list.\n\n@param str\nthe string to test\n@param patterns\nthe patterns\n@return true, if successful.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean acceptFile(final File file) { if (!file.isFile()) { return false; // ignore non-files } String fileName = file.getName(); if (ignoreDotFiles) { if (fileName.startsWith(StringPool.DOT)) { return false; // ignore hidden files } } if (patterns == null) { return true; } return Wildcard.matchOne(fileName, patterns) != -1; }\n\n    ### Response:", "ground_truth": "Accepts if a file is going to be watched.", "predict": " Check if a file should be accepted based on the provided patterns.\n\n@param file\nthe file to check\n@return true, if the file should be accepted.\n\n    "}, {"ID": 1175, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] serializeObject(Object obj) { if (obj == null) { return null; } ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(obj); out.flush(); } catch (IOException ioex) { throw new EJBException(\"Timer info object failed to serialize.\", ioex); } return baos.toByteArray(); }\n\n    ### Response: Internal convenience method for serializing the user info object to a byte array..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirWatcher useWatchFile(final String name) { watchFile = new File(dir, name); if (!watchFile.isFile() || !watchFile.exists()) { try { FileUtil.touch(watchFile); } catch (IOException ioex) { throw new DirWatcherException(\"Invalid watch file: \" + name, ioex); } } watchFileLastAccessTime = watchFile.lastModified(); return this; }\n\n    ### Response:", "ground_truth": "Enables usage of provided watch file.", "predict": " Sets the watch file for this DirWatcher instance. If the file does not exist or is not a file, an exception is thrown. The last access time of the file is also updated.\n\n    "}, {"ID": 1176, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void simulate(LocationSource locationSource, long period, boolean isDaemon) throws IOException { this.locationSource = locationSource; dis = new DataInputStream(new BufferedInputStream(url.openStream())); if (timer == null) { timer = new Timer(\"AnchorageSimulator\", isDaemon); } timer.scheduleAtFixedRate(this, 0, period); }\n\n    ### Response: Starts simulating anchorige.\n@param locationSource\n@param period Update rate in millis.\n@param isDaemon Sets timer thread. In single thread this should be false.\nThis parament is used only if external Timer was not provided!\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final long pollingInterval) { if (timer == null) { if (!startBlank) { init(); } timer = new Timer(true); timer.schedule(new WatchTask(), 0, pollingInterval); } }\n\n    ### Response:", "ground_truth": "Starts the watcher.", "predict": " Starts the timer to poll the location source for updates.\n@param pollingInterval The interval between location updates in milliseconds.\n@throws IllegalStateException If the timer has already been started.\n\n    "}, {"ID": 1177, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void queueUpload(String key, File file) { if (mUploadQueue == null) mUploadQueue = new ArrayDeque<>(); mUploadQueue.add(new Pair<>(key, file)); }\n\n    ### Response: Queue an upload for later submission to S3\n\n@param key  destination key\n@param file local file.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onChange(final DirWatcherEvent.Type type, final File file) { listeners.accept(new DirWatcherEvent(type, file)); }\n\n    ### Response:", "ground_truth": "Triggers listeners on file change.", "predict": " Notify listeners of a change in the directory watcher.\n\n@param type  type of change\n@param file  file that was changed"}, {"ID": 1178, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final String metricsName, final MetricsBase theMetricsObj) { if (metricsList.putIfAbsent(metricsName, theMetricsObj) != null) { throw new IllegalArgumentException(\"Duplicate metricsName:\" + metricsName); } }\n\n    ### Response: Add a new metrics to the registry\n@param metricsName - the name\n@param theMetricsObj - the metrics\n@throws IllegalArgumentException if a name is already registered.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Enumeration<T> enumeration) { if (allEnumerations.contains(enumeration)) { throw new IllegalArgumentException(\"Duplicate enumeration\"); } allEnumerations.add(enumeration); }\n\n    ### Response:", "ground_truth": "Adds an enumeration to this composite.", "predict": " Add an enumeration to the registry\n@param enumeration - the enumeration to add\n@throws IllegalArgumentException if the enumeration is already registered."}, {"ID": 1179, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeFieldInfoSize() { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { // ConstantValue attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE); size += 8; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) { // Synthetic attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { // Signature attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { // Deprecated attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; }\n\n    ### Response: Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeFieldInfoSize() { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { // ConstantValue attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE); size += 8; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) { // Synthetic attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { // Signature attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { // Deprecated attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (lastRuntimeVisibleAnnotation != null) { size += lastRuntimeVisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_ANNOTATIONS); } if (lastRuntimeInvisibleAnnotation != null) { size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_ANNOTATIONS); } if (lastRuntimeVisibleTypeAnnotation != null) { size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS); } if (lastRuntimeInvisibleTypeAnnotation != null) { size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS); } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; }\n\n    ### Response:", "ground_truth": "Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure.", "predict": " Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure.."}, {"ID": 1180, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putFieldInfo(final ByteVector output) { boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0; output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex); // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0; if (constantValueIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { ++attributesCount; } if (signatureIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { ++attributesCount; } if (firstAttribute != null) { attributesCount += firstAttribute.getAttributeCount(); } output.putShort(attributesCount); // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)) .putInt(2) .putShort(constantValueIndex); } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0); } if (signatureIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)) .putInt(2) .putShort(signatureIndex); } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0); } if (firstAttribute != null) { firstAttribute.putAttributes(symbolTable, output); } }\n\n    ### Response: Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putFieldInfo(final ByteVector output) { boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0; output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex); // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0; if (constantValueIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { ++attributesCount; } if (signatureIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { ++attributesCount; } if (lastRuntimeVisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeVisibleTypeAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleTypeAnnotation != null) { ++attributesCount; } if (firstAttribute != null) { attributesCount += firstAttribute.getAttributeCount(); } output.putShort(attributesCount); // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)) .putInt(2) .putShort(constantValueIndex); } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0); } if (signatureIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)) .putInt(2) .putShort(signatureIndex); } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0); } if (lastRuntimeVisibleAnnotation != null) { lastRuntimeVisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output); } if (lastRuntimeInvisibleAnnotation != null) { lastRuntimeInvisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output); } if (lastRuntimeVisibleTypeAnnotation != null) { lastRuntimeVisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output); } if (lastRuntimeInvisibleTypeAnnotation != null) { lastRuntimeInvisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output); } if (firstAttribute != null) { firstAttribute.putAttributes(symbolTable, output); } }\n\n    ### Response:", "ground_truth": "Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put.", "predict": " Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put.."}, {"ID": 1181, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CellProcessor[] getCellProcessors(){ return new CellProcessor[] { new ParseInt(){ @Override public Object execute(Object value, CsvContext context) { String content = value.toString(); String[] split = content.split(\"\\\\$\"); return super.execute(split[1], context); } }, new ParseLong(), null, null, new ParseLong(), new ParseLong(), new ParseLong(), null, new ParseInt(), new ParseInt() }; }\n\n    ### Response: Provide this array to parse the columns of the csv into the right type using the Super CSV framework.\n\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Target ofValue(final Object value, final ScopeData scopeData) { return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); }\n\n    ### Response:", "ground_truth": "Creates a common target over a value, with known scope data.", "predict": " This method creates a new Target object with the given value, null scope data, and the value instance creator.\n\n@param value. The value to be assigned to the Target object.\n@param scopeData. The scope data to be assigned to the Target object.\n@return. A new Target object with the given value, null scope data, and the value instance creator."}, {"ID": 1182, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JavascriptVarBuilder appendRowColProperty(final int row, final int col, final String propertyValue, final boolean quoted) { return appendProperty(\"r\" + row + \"_c\" + col, propertyValue, quoted); }\n\n    ### Response: appends a property with the name \"rYY_cXX\" where YY is the row and XX is he column.\n\n@param row\n@param col\n@param propertyValue\n@param quoted\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeValue(final InjectionPoint injectionPoint, final Object propertyValue, final boolean silent) { writeValue(injectionPoint.targetName(), propertyValue, silent); }\n\n    ### Response:", "ground_truth": "Writes value to this target. Depending on a flag, writing the value can be\ncompletely silent, when no exception is thrown and with top performances.\nOtherwise, an exception is thrown on a failure.", "predict": " writes the property value to the target name of the injection point.\n\n@param injectionPoint\n@param propertyValue\n@param silent\n@return."}, {"ID": 1183, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void transformChar(Reader self, Writer writer, @ClosureParams(value=SimpleType.class, options=\"java.lang.String\") Closure closure) throws IOException { int c; try { char[] chars = new char[1]; while ((c = self.read()) != -1) { chars[0] = (char) c; writer.write((String) closure.call(new String(chars))); } writer.flush(); Writer temp2 = writer; writer = null; temp2.close(); Reader temp1 = self; self = null; temp1.close(); } finally { closeWithWarning(self); closeWithWarning(writer); } }\n\n    ### Response: Transforms each character from this reader by passing it to the given\nclosure.  The Closure should return each transformed character, which\nwill be passed to the Writer.  The reader and writer will be both be\nclosed before this method returns.\n\n@param self    a Reader object\n@param writer  a Writer to receive the transformed characters\n@param closure a closure that performs the required transformation\n@throws IOException if an IOException occurs.\n@since 1.5.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void decorate(final Writer writer, final char[] pageContent, final char[] decoraContent) throws IOException { DecoraTag[] decoraTags = parseDecorator(decoraContent); parsePage(pageContent, decoraTags); writeDecoratedPage(writer, decoraContent, pageContent, decoraTags); }\n\n    ### Response:", "ground_truth": "Decorates page content with decorator template and outputs the result.", "predict": "This method decorates a given page with the given decorator content.\n\n@param writer         a Writer object to write the decorated page\n@param pageContent    the content of the page to be decorated\n@param decoraContent  the content of the decorator to be applied\n@throws IOException    if an IOException occurs.\n@since 1.0.0."}, {"ID": 1184, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void valuateNoteChars() { short noteDuration = note.getStrictDuration(); if (note.isRest()){ noteChars = new char[] { getMusicalFont().getRestChar(noteDuration) }; //System.out.println(\"duration of the rest is \" + noteDuration); } else { if (isStemUp()) noteChars = new char[] { getMusicalFont().getNoteStemUpChar(noteDuration) }; else noteChars = new char[] { getMusicalFont().getNoteStemDownChar(noteDuration) }; } }\n\n    ### Response: Sets the Unicode value of the note as a char array.\n@see #noteChars.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void parsePage(final char[] pageContent, final DecoraTag[] decoraTags) { LagartoParser lagartoParser = new LagartoParser(pageContent); PageRegionExtractor writer = new PageRegionExtractor(decoraTags); lagartoParser.parse(writer); }\n\n    ### Response:", "ground_truth": "Parses target page and extracts Decora regions for replacements.", "predict": " Parses the page content and extracts the regions based on the decora tags.\n@see #parsePage(char[], DecoraTag[])."}, {"ID": 1185, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceVariables( final VariableResolver pResolver, final String pExpression, final String pOpen, final String pClose ) { final char[] open = pOpen.toCharArray(); final char[] close = pClose.toCharArray(); final StringBuilder out = new StringBuilder(); StringBuilder sb = new StringBuilder(); char[] last = null; int wo = 0; int wc = 0; int level = 0; for (char c : pExpression.toCharArray()) { if (c == open[wo]) { if (wc > 0) { sb.append(close, 0, wc); } wc = 0; wo++; if (open.length == wo) { // found open if (last == open) { out.append(open); } level++; out.append(sb); sb = new StringBuilder(); wo = 0; last = open; } } else if (c == close[wc]) { if (wo > 0) { sb.append(open, 0, wo); } wo = 0; wc++; if (close.length == wc) { // found close if (last == open) { final String variable = pResolver.get(sb.toString()); if (variable != null) { out.append(variable); } else { out.append(open); out.append(sb); out.append(close); } } else { out.append(sb); out.append(close); } sb = new StringBuilder(); level--; wc = 0; last = close; } } else { if (wo > 0) { sb.append(open, 0, wo); } if (wc > 0) { sb.append(close, 0, wc); } sb.append(c); wo = wc = 0; } } if (wo > 0) { sb.append(open, 0, wo); } if (wc > 0) { sb.append(close, 0, wc); } if (level > 0) { out.append(open); } out.append(sb); return out.toString(); }\n\n    ### Response: Substitute the variables in the given expression with the\nvalues from the resolver\n\n@param pResolver\n@param pExpression.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException { int ndx = 0; for (DecoraTag decoraTag : decoraTags) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag.getStartIndex() - ndx; if (decoratorLen <= 0) { continue; } out.write(decoratorContent, ndx, decoratorLen); ndx = decoraTag.getEndIndex(); // [2] now write region at the place of Decora tag int regionLen = decoraTag.getRegionLength(); if (regionLen == 0) { if (decoraTag.hasDefaultValue()) { out.write(decoratorContent, decoraTag.getDefaultValueStart(), decoraTag.getDefaultValueLength()); } } else { writeRegion(out, pageContent, decoraTag, decoraTags); } } // write remaining content out.write(decoratorContent, ndx, decoratorContent.length - ndx); }\n\n    ### Response:", "ground_truth": "Writes decorated content.", "predict": " This method is responsible for writing the decorated page to the output stream. It takes three parameters: the output stream, the decorator content, and the page content. It also takes an array of DecoraTag objects, which represent the regions in the decorator content that need to be replaced with the corresponding regions in the page content.\n\nThe method uses a loop to iterate over the DecoraTag objects and copy the content before the Decora tag to the output stream. It then calls the writeRegion() method to write the region at the place of the Decora tag.\n\nThe writeRegion() method takes the DecoraTag object, the page content, and the array of DecoraTag objects as parameters. It uses the start and end indices of the Decora tag to extract the corresponding region from the page content. If the Decora tag has a default value, it writes that value instead of the region.\n\nThe method-level comment for the writeDecoratedPage() method is as follows:\n\n/**\n * Writes the decorated page to the"}, {"ID": 1186, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void garbageCollection() { // number of tiles to remove from cache int toBeRemoved = Integer.MAX_VALUE; // MAX_VALUE for stressed memory case final int size = mCachedTiles.size(); if (!mStressedMemory) { toBeRemoved = size - mCapacity; if (toBeRemoved <= 0) { return; } } refreshAdditionalLists(); if (mAutoEnsureCapacity) { final int target = mMapTileArea.size() + mAdditionalMapTileList.size(); if (ensureCapacity(target)) { if (!mStressedMemory) { toBeRemoved = size - mCapacity; if (toBeRemoved <= 0) { return; } } } } populateSyncCachedTiles(mGC); for (int i = 0; i < mGC.getSize() ; i ++) { final long index = mGC.get(i); if (shouldKeepTile(index)) { continue; } remove(index); if (-- toBeRemoved == 0) { break; }; } }\n\n    ### Response: Removes from the memory cache all the tiles that should no longer be there\n@since 6.0.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void writeRegion(final Writer out, final char[] pageContent, final DecoraTag decoraTag, final DecoraTag[] decoraTags) throws IOException { int regionStart = decoraTag.getRegionStart(); int regionLen = decoraTag.getRegionLength(); int regionEnd = regionStart + regionLen; for (DecoraTag innerDecoraTag : decoraTags) { if (decoraTag == innerDecoraTag) { continue; } if (decoraTag.isRegionUndefined()) { continue; } if (innerDecoraTag.isInsideOtherTagRegion(decoraTag)) { // write everything from region start to the inner Decora tag out.write(pageContent, regionStart, innerDecoraTag.getRegionTagStart() - regionStart); regionStart = innerDecoraTag.getRegionTagEnd(); } } // write remaining content of the region out.write(pageContent, regionStart, regionEnd - regionStart); }\n\n    ### Response:", "ground_truth": "Writes region to output, but extracts all inner regions.", "predict": " Writes the content of a region of a page to a writer, taking into account the presence of other decora tags.\n@since 6.0.0."}, {"ID": 1187, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void run() { ExecutorService executorService = Executors.newFixedThreadPool(maxClients); try { serverSocket = new ServerSocket(port, maxClients); while (!shuttingDown) { try { Socket socket = serverSocket.accept(); debugConnection = new DebugConnection(socket); executorService.submit(debugConnection); } catch (SocketException e) { // closed debugConnection = null; } } } catch (IOException e) { e.printStackTrace(); } finally { try { debugConnection = null; serverSocket.close(); } catch (Exception e) { } executorService.shutdownNow(); } }\n\n    ### Response: Runs the server..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() throws IOException { serverSocket = new ServerSocket(listenPort, socketBacklog); serverSocket.setReuseAddress(true); executorService = Executors.newFixedThreadPool(threadPoolSize); running = true; while (running) { Socket socket = serverSocket.accept(); socket.setKeepAlive(false); executorService.execute(onSocketConnection(socket)); } executorService.shutdown(); }\n\n    ### Response:", "ground_truth": "Starts HTTP tunnel. Method ends when the tunnel is stopped.", "predict": "Starts the server.\n\n    "}, {"ID": 1188, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] toByteArray(InputStream source, int bufferSize) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); copy(source, baos, bufferSize); source.close(); return baos.toByteArray(); }\n\n    ### Response: Reads the given input stream into a byte array and closes the input stream\n\n@param source     The source of the bytes\n@param bufferSize The size of the byte buffer to use when copying streams\n@return Returns a byte array\n@throws IOException If there is an error reading from the stream.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProcessResult run(final Process process) throws InterruptedException { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX); final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX); outputGobbler.start(); errorGobbler.start(); final int result = process.waitFor(); outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessResult(result, baos.toString()); }\n\n    ### Response:", "ground_truth": "Executes a process and returns the process output and exit code.", "predict": " Runs the given process and waits for it to complete.\n\n@param process The process to run\n@return Returns the result of the process\n@throws InterruptedException If the thread is interrupted while waiting for the process to complete\n\n    "}, {"ID": 1189, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException { if (params == null) { throw new IllegalArgumentException(\"Parameters may not be null\"); } int timeout = params.getConnectionTimeout(); if (timeout == 0) { InetAddress hostAddress = getCachedMisconfiguredHost(host, port); if (hostAddress != null) { return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } try { SSLSocket sslSocket = (SSLSocket) clientSSLSockFactory.createSocket(host, port, localAddress, localPort); sslSocket.startHandshake(); return sslSocket; } catch (SSLException e) { if (!e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)) { throw e; } hostAddress = InetAddress.getByName(host); cacheMisconfiguredHost(host, port, hostAddress); return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } } Socket socket = clientSSLSockFactory.createSocket(); SocketAddress localAddr = new InetSocketAddress(localAddress, localPort); socket.bind(localAddr); SocketAddress remoteAddr = new InetSocketAddress(host, port); socket.connect(remoteAddr, timeout); return socket; }\n\n    ### Response: Attempts to get a new socket connection to the given host within the\ngiven time limit.\n\n@param host\nthe host name/IP\n@param port\nthe port on the host\n@param localAddress\nthe local host name/IP to bind the socket to\n@param localPort\nthe port on the local machine\n@param params\n{@link HttpConnectionParams Http connection parameters}\n\n@return Socket a new socket\n\n@throws IOException\nif an I/O error occurs while creating the socket\n@throws UnknownHostException\nif the IP address of the host cannot be determined\n@throws \tConnectTimeoutException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected IMAPSSLStore getStore(final Session session) { SimpleAuthenticator simpleAuthenticator = (SimpleAuthenticator) authenticator; final URLName url; if (simpleAuthenticator == null) { url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, null, null); } else { final PasswordAuthentication pa = simpleAuthenticator.getPasswordAuthentication(); url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, pa.getUserName(), pa.getPassword()); } return new IMAPSSLStore(session, url); }\n\n    ### Response:", "ground_truth": "Returns email store.\n\n@param session {@link Session}\n@return {@link com.sun.mail.imap.IMAPSSLStore}", "predict": " Gets an IMAP SSL store for the given session.\n\n@param session\nthe session\n\n@return IMAPSSLStore an IMAP SSL store for the given session\n\n    "}, {"ID": 1190, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected OutputStream createOutputStream() throws IOException { if (asFile().isPresent()) { return new FileOutputStream(asFile().orElse(null)); } return null; }\n\n    ### Response: Create output stream output stream.\n\n@return the output stream\n@throws IOException the io exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServletOutputStream createOutputStream() throws IOException { GzipResponseStream gzstream = new GzipResponseStream(origResponse); gzstream.setBuffer(threshold); return gzstream; }\n\n    ### Response:", "ground_truth": "Creates and returns a ServletOutputStream to write the content associated\nwith this Response.", "predict": " Create output stream output stream.\n\n@return the output stream\n@throws IOException the io exception."}, {"ID": 1191, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(final LynxConfig lynxConfig) { ShakeDetector shakeDetector = new ShakeDetector(new ShakeDetector.Listener() { @Override public void hearShake() { if (isEnabled) { openLynxActivity(lynxConfig); } } }); SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); shakeDetector.start(sensorManager); }\n\n    ### Response: Starts listening shakes to open LynxActivity if a shake is detected and if the ShakeDetector is\nenabled..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final TemplateData templateData) { super.init(templateData); if (hint != null) { templateData.incrementHintsCount(); } }\n\n    ### Response:", "ground_truth": "Counts actual real hints.", "predict": " Initializes the TemplateData object with the given hint and increments the hints count."}, {"ID": 1192, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getHatboxTableName() { final String tableName; if (!StringUtils.hasUpperCase(getTableName())) { tableName = getTableName() + \"_hatbox\"; } else { tableName = getTableName() + \"_HATBOX\"; } return tableName; }\n\n    ### Response: Generates the table name containing the Hatbox index.\n\n@return the Hatbox table name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendAlias(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { final ColumnAliasType columnAliasType = templateData.getColumnAliasType(); if (columnAliasType == null || columnAliasType == ColumnAliasType.TABLE_REFERENCE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnNameForQuery(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(columnName); } else if (columnAliasType == ColumnAliasType.COLUMN_CODE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnName(); final String code = templateData.registerColumnDataForColumnCode(tableName, columnName); query.append(code); } else if (columnAliasType == ColumnAliasType.TABLE_NAME) { final String tableName = ded.getTableNameForQuery(); final String columnName = dec.getColumnNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(columnName); } }\n\n    ### Response:", "ground_truth": "Appends alias.", "predict": " Appends the column alias to the query string based on the column alias type.\n\n@param query the query string to which the alias is to be appended.\n@param ded the descriptor for the entity containing the column.\n@param dec the descriptor for the column."}, {"ID": 1193, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getResultUrl( HttpServletRequest httpServletRequest, SearchResult result, IPortletWindowId portletWindowId) { final String externalUrl = result.getExternalUrl(); if (externalUrl != null) { return externalUrl; } UrlType urlType = UrlType.RENDER; final PortletUrl portletUrl = result.getPortletUrl(); if (portletUrl != null) { final PortletUrlType type = portletUrl.getType(); if (type != null) { switch (type) { case ACTION: { urlType = UrlType.ACTION; break; } default: case RENDER: { urlType = UrlType.RENDER; break; } case RESOURCE: { urlType = UrlType.RESOURCE; break; } } } } final IPortalUrlBuilder portalUrlBuilder = this.portalUrlProvider.getPortalUrlBuilderByPortletWindow( httpServletRequest, portletWindowId, urlType); final IPortletUrlBuilder portletUrlBuilder = portalUrlBuilder.getTargetedPortletUrlBuilder(); if (portletUrl != null) { final String portletMode = portletUrl.getPortletMode(); if (portletMode != null) { portletUrlBuilder.setPortletMode(PortletUtils.getPortletMode(portletMode)); } final String windowState = portletUrl.getWindowState(); if (windowState != null) { portletUrlBuilder.setWindowState(PortletUtils.getWindowState(windowState)); } for (final PortletUrlParameter param : portletUrl.getParam()) { final String name = param.getName(); final List<String> values = param.getValue(); portletUrlBuilder.addParameter(name, values.toArray(new String[values.size()])); } } return portalUrlBuilder.getUrlString(); }\n\n    ### Response: Determine the url for the search result.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendColumnName(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName()); if (templateData.getColumnAliasType() != null) { // create column aliases query.append(AS); switch (templateData.getColumnAliasType()) { case TABLE_NAME: { final String tableName = ded.getTableNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case TABLE_REFERENCE: { final String tableName = ded.getTableName(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case COLUMN_CODE: { final String tableName = ded.getTableName(); final String code = templateData.registerColumnDataForColumnCode(tableName, dec.getColumnName()); query.append(code); break; } } } }\n\n    ### Response:", "ground_truth": "Simply appends column name with optional table reference and alias.", "predict": " Append the column name to the query string."}, {"ID": 1194, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addRule(final TreeRule rule) { if (rule == null) { throw new IllegalArgumentException(\"Null rules are not accepted\"); } if (rules == null) { rules = new TreeMap<Integer, TreeMap<Integer, TreeRule>>(); } TreeMap<Integer, TreeRule> level = rules.get(rule.getLevel()); if (level == null) { level = new TreeMap<Integer, TreeRule>(); level.put(rule.getOrder(), rule); rules.put(rule.getLevel(), level); } else { level.put(rule.getOrder(), rule); } changed.put(\"rules\", true); }\n\n    ### Response: Adds the given rule to the tree, replacing anything in the designated spot\n@param rule The rule to add\n@throws IllegalArgumentException if the incoming rule was invalid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addRule(final D ruleDefinition, final boolean include) { if (rules == null) { rules = new ArrayList<>(); } if (include) { includesCount++; } else { excludesCount++; } Rule<R> newRule = new Rule<>(makeRule(ruleDefinition), include); if (rules.contains(newRule)) { return; } rules.add(newRule); }\n\n    ### Response:", "ground_truth": "Adds a rule. Duplicates are not allowed and will be ignored.", "predict": " Adds a new rule to the list of rules for this decision tree.\n@param ruleDefinition The definition of the rule to add\n@param include Whether to include or exclude the rule from the decision tree\n@throws IllegalArgumentException if the incoming rule definition was invalid."}, {"ID": 1195, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean insertIntoNextEmptySlot() { boolean found = searchFor(EMPTY); if (found) { Constant flag = INUSE_CONST; setVal(currentPos(), flag); } return found; }\n\n    ### Response: Inserts a new, blank record somewhere in the page. Return false if there\nwere no available slots.\n\n@return false if the insertion was not possible.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean apply(final V value, final boolean blacklist, boolean flag) { if (rules == null) { return flag; } if (blacklist) { flag = processExcludes(value, flag); flag = processIncludes(value, flag); } else { flag = processIncludes(value, flag); flag = processExcludes(value, flag); } return flag; }\n\n    ### Response:", "ground_truth": "Applies rules on given flag. Flag is only changed if at least one rule\nmatched. Otherwise, the same value is returned. This way you can\nchain several rules and have the rule engine change the flag\nonly when a rule is matched.", "predict": " Applies the rules to the given value, either adding it to the blacklist or the whitelist.\n\n@param value the value to apply the rules to\n@param blacklist whether to apply the rules to the blacklist or the whitelist\n@param flag the current flag state\n@return the updated flag state\n\nThe rules are defined in the constructor of the class."}, {"ID": 1196, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean accepts(final String ct) { for (final Object element : accepts) { final String accept = (String) element; if (accept != null && accept.trim().equals(\"*/*\")) { return true; } final String entryType = \"application/atom+xml\"; final boolean entry = entryType.equals(ct); if (entry && null == accept) { return true; } else if (entry && \"entry\".equals(accept)) { return true; } else if (entry && entryType.equals(accept)) { return true; } else { final String[] rules = accepts.toArray(new String[accepts.size()]); for (final String rule2 : rules) { String rule = rule2.trim(); if (rule.equals(ct)) { return true; } final int slashstar = rule.indexOf(\"/*\"); if (slashstar > 0) { rule = rule.substring(0, slashstar + 1); if (ct.startsWith(rule)) { return true; } } } } } return false; }\n\n    ### Response: Returns true if contentType is accepted by collection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean processIncludes(final V value, boolean include) { if (includesCount > 0) { if (!include) { for (Rule<R> rule : rules) { if (!rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, true)) { include = true; break; } } } } return include; }\n\n    ### Response:", "ground_truth": "Process includes rules.", "predict": " Processes includes for the given value.\n\n    "}, {"ID": 1197, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isExplicitlyRequested(String candidate, String... indices) { boolean result = false; for (String indexOrAlias : indices) { boolean include = true; if (indexOrAlias.charAt(0) == '+' || indexOrAlias.charAt(0) == '-') { include = indexOrAlias.charAt(0) == '+'; indexOrAlias = indexOrAlias.substring(1); } if (indexOrAlias.equals(\"*\") || indexOrAlias.equals(\"_all\")) { return false; } if (Regex.isSimpleMatchPattern(indexOrAlias)) { if (Regex.simpleMatch(indexOrAlias, candidate)) { if (include) { result = true; } else { return false; } } } else { if (candidate.equals(indexOrAlias)) { if (include) { result = true; } else { return false; } } } } return result; }\n\n    ### Response: Checks if the provided candidate is explicitly contained in the provided indices..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean processExcludes(final V value, boolean include) { if (excludesCount > 0) { if (include) { for (Rule<R> rule : rules) { if (rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, false)) { include = false; break; } } } } return include; }\n\n    ### Response:", "ground_truth": "Process excludes rules.", "predict": " Processes the exclude rules for the provided value and include flag."}, {"ID": 1198, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resourceName(final String className) { String name = className; if (!name.startsWith(\"/\")) { name = \"/\" + name; } if (!name.endsWith(DOT_GROOVY)) { name = name.replace('.', '/'); name += DOT_GROOVY; } return name; }\n\n    ### Response: Translate class-name into resource-name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPseudoClassName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; }\n\n    ### Response:", "ground_truth": "Returns pseudo-class name from simple class name.", "predict": " Get the simple class name and convert it to pseudo-class name by replacing underscores with hyphens."}, {"ID": 1199, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean addAll(Collection<? extends Character> c) { boolean retVal = false; final Iterator<? extends Character> i = c.iterator(); int n = c.size(); while (n-- != 0) if (add(i.next())) retVal = true; return retVal; }\n\n    ### Response: Adds all elements of the given collection to this collection.\n\n@param c a collection.\n@return true if this collection changed as a result of the call..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean addAll(final Collection<? extends E> c) { Iterator<? extends E> i = c.iterator(); boolean changed = false; while (i.hasNext()) { boolean ret = add(i.next()); if (!changed) { changed = ret; } } return changed; }\n\n    ### Response:", "ground_truth": "Add all of the elements in the given collection to this list.", "predict": " Adds all elements of the specified collection to this collection.\n\n@param c collection containing elements to be added to this collection.\n@return true if this collection changed as a result of the call."}, {"ID": 1200, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int findInsertion(float depth) { int low = 0, high = children.size()-1; while (low <= high) { int mid = (low + high) >>> 1; float midDepth = children.get(mid).depth(); if (depth > midDepth) { low = mid + 1; } else if (depth < midDepth) { high = mid - 1; } else { return mid; } } return low; }\n\n    ### Response: who says you never have to write binary search?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int findInsertionPoint(final E o, int low, int high) { while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(get(mid), o); if (delta > 0) { high = mid - 1; } else { low = mid + 1; } } return low; }\n\n    ### Response:", "ground_truth": "Conducts a binary search to find the index where Object\nshould be inserted.", "predict": " This method is a binary search implementation for finding the insertion point of an element in a sorted list. It takes in the element to be inserted, the low and high indices of the search range, and returns the index where the element should be inserted to maintain the sorted order. The compare method is used to compare the elements at the midpoint of the search range with the element to be inserted. If the element to be inserted is greater than the element at the midpoint, the search range is narrowed to the lower half of the list. If the element to be inserted is less than the element at the midpoint, the search range is narrowed to the upper half of the list. If the element to be inserted is equal to the element at the midpoint, the midpoint index is returned."}, {"ID": 1201, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<MappedField> getFieldsAnnotatedWith(final Class<? extends Annotation> clazz) { final List<MappedField> results = new ArrayList<MappedField>(); for (final MappedField mf : persistenceFields) { if (mf.hasAnnotation(clazz)) { results.add(mf); } } return results; }\n\n    ### Response: Returns fields annotated with the clazz\n\n@param clazz The Annotation to find.\n@return the list of fields.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void bindAnnotationConfig(final Class<? extends Annotation> annotationType, final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass); actionConfigs.put(annotationType, actionConfig); for (final AnnotationParser annotationParser : annotationParsers) { if (annotationType.equals(annotationParser.getAnnotationType())) { // parser already exists return; } } annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class)); }\n\n    ### Response:", "ground_truth": "Binds action annotation and the action config. This can overwrite the default annotation\nconfiguration of an annotation.", "predict": " Binds the annotation config to the action config.\n\n@param annotationType The annotation type to bind.\n@param actionConfigClass The action config class to bind to."}, {"ID": 1202, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ActionConfig imports(Configurer configurer) { Check.notNull(configurer); return imports(configurer.getRoot()); }\n\n    ### Response: Import the action data from setup.\n\n@param configurer The configurer reference (must not be null).\n@return The action data.\n@throws LionEngineException If unable to read node..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionConfig registerNewActionConfiguration(final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig newActionConfig = createActionConfig(actionConfigClass); actionConfigs.put(actionConfigClass, newActionConfig); return newActionConfig; }\n\n    ### Response:", "ground_truth": "Registers action configuration for given type.", "predict": " Register a new action configuration.\n\n@param actionConfigClass The action configuration class to register.\n@return The registered action configuration.\n@throws LionEngineException If unable to register action configuration."}, {"ID": 1203, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void initDelegatingConfigs(ModuleConfig moduleConfig, ServletContext servletContext) { ActionConfig[] actionConfigs = moduleConfig.findActionConfigs(); // Initialize action configs. for (int i = 0; i < actionConfigs.length; i++) { ActionConfig actionConfig = actionConfigs[i]; if (actionConfig instanceof DelegatingActionMapping) { ((DelegatingActionMapping) actionConfig).init(servletContext); } else { // Initialize action-level exception configs. ExceptionConfig[] exceptionConfigs = actionConfig.findExceptionConfigs(); for (int j = 0; j < exceptionConfigs.length; j++) { ExceptionConfig exceptionConfig = exceptionConfigs[j]; if (exceptionConfig instanceof DelegatingExceptionConfig) { ((DelegatingExceptionConfig) exceptionConfig).init(servletContext); } } } } // Initialize module-level exception configs. ExceptionConfig[] exceptionConfigs = moduleConfig.findExceptionConfigs(); for (int i = 0; i < exceptionConfigs.length; i++) { ExceptionConfig exceptionConfig = exceptionConfigs[i]; if (exceptionConfig instanceof DelegatingExceptionConfig) { ((DelegatingExceptionConfig) exceptionConfig).init(servletContext); } } }\n\n    ### Response: Initialize delegating action configs and exception configs for a Struts module that should delegate\nto one generated from a superclass..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionConfig lookup(final Class actionTypeOrAnnotationType) { final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType); if (actionConfig == null) { throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName()); } return actionConfig; }\n\n    ### Response:", "ground_truth": "Lookup for the action configuration. Typically, the input argument is either the action type or annotation type.", "predict": " Looks up an action configuration by action type or annotation type.\n\n    "}, {"ID": 1204, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T extends RequestBuilder> T with(final String jsonParam, final Object obj) { this.parameters.put(jsonParam, obj); return (T) this; }\n\n    ### Response: Adds the given parameter to the map and returns this same object.\n@param jsonParam JSON name of the parameter to add\n@param obj Object to add to the map\n@return This same object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) { final T actionConfig = (T) lookup(actionConfigType); actionConfigConsumer.accept(actionConfig); }\n\n    ### Response:", "ground_truth": "Fetch some action config and consumes it.", "predict": " Looks up the given action configuration type and applies the given consumer to it.\n@param actionConfigType Type of the action configuration to lookup\n@param actionConfigConsumer Consumer to apply to the action configuration\n@return This method does not return anything."}, {"ID": 1205, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Publisher<T> onComplete(Publisher<T> publisher, Supplier<CompletableFuture<Void>> future) { return actual -> publisher.subscribe(new CompletionAwareSubscriber<T>() { @Override protected void doOnSubscribe(Subscription subscription) { actual.onSubscribe(subscription); } @Override protected void doOnNext(T message) { try { actual.onNext(message); } catch (Throwable e) { onError(e); } } @Override protected void doOnError(Throwable t) { actual.onError(t); } @Override protected void doOnComplete() { future.get().whenComplete((aVoid, throwable) -> { if (throwable != null) { actual.onError(throwable); } else { actual.onComplete(); } }); } }); }\n\n    ### Response: Allow executing logic on completion of a Publisher.\n\n@param publisher The publisher\n@param future    The runnable\n@param        The generic type\n@return The mapped publisher.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static void setupSystemMailProperties() { System.setProperty(\"mail.mime.encodefilename\", Boolean.valueOf(Defaults.mailMimeEncodefilename).toString()); System.setProperty(\"mail.mime.decodefilename\", Boolean.valueOf(Defaults.mailMimeDecodefilename).toString()); }\n\n    ### Response:", "ground_truth": "Setups the system email properties.", "predict": " Sets up system properties for handling email attachments.\n\n@param None.\n\n    "}, {"ID": 1206, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Command> putToMap(final UUID mapId, final Object key, final Object value) { final State state = createCommandList(new WithCommandType() { @Override public void invoke(final State state) { putToMap(mapId, key, value, state); } }, true); return state.commands; }\n\n    ### Response: Creates the list with commands necessary to put a mapping into a map.\n\n@param mapId\nthe id of the map where the mapping should be added.\n@param key\nthe key of the new mapping.\n@param value\nthe value of the new mapping.\n@return the list with the commands..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void validateWithin(final ValidationContext vctx, final Object value) { vtor.validate(vctx, value, name); }\n\n    ### Response:", "ground_truth": "Validates provided context and value withing this constraint content.", "predict": " Validates the given value within the given validation context.\n\n@param vctx\nthe validation context to use for validation.\n@param value\nthe value to validate.\n@param name\nthe name of the value to validate."}, {"ID": 1207, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Node getNextParentNodeWithAttr(final Node parent, final String attrName) { Node parentNode = parent; Element parendElement = (Element) parentNode; Node valueNode = parendElement.getAttributes().getNamedItem(attrName); while (valueNode == null) { parentNode = parentNode.getParentNode(); if (parentNode != null) { if (parentNode.getNodeType() == Node.ELEMENT_NODE) { parendElement = (Element) parentNode; valueNode = parendElement.getAttributes().getNamedItem(attrName); } } else { break; } } return parendElement; }\n\n    ### Response: Returns the next parent node which has the specific attribute name defined.\n\n@param parent\nthe w3c node from which the search will start.\n@param attrName\nthe attribute name which is searched for.\n@return a parent node, if the attribute is found, otherwise null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Element findLastTable(final Node node) { Node tableNode = node; while (tableNode != null) { if (tableNode.getNodeType() == Node.NodeType.ELEMENT) { String tableNodeName = tableNode.getNodeName().toLowerCase(); if (tableNodeName.equals(\"table\")) { break; } } tableNode = tableNode.getParentNode(); } return (Element) tableNode; }\n\n    ### Response:", "ground_truth": "Finds the last table in stack of open elements.", "predict": " Finds the last table element in the DOM tree starting from the given node.\n\n@param node\nthe w3c node from which the search will start.\n@return the last table element found, or null if no table element is found."}, {"ID": 1208, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (p *parser) fosterParent(n *Node) { var table, parent, prev *Node var i int for i = len(p.oe) - 1; i >= 0; i-- { if p.oe[i].DataAtom == a.Table { table = p.oe[i] break } } if table == nil { // The foster parent is the html element. parent = p.oe[0] } else { parent = table.Parent } if parent == nil { parent = p.oe[i-1] } if table != nil { prev = table.PrevSibling } else { prev = parent.LastChild } if prev != nil && prev.Type == TextNode && n.Type == TextNode { prev.Data += n.Data return } parent.InsertBefore(n, table) }\n\n    ### Response: // fosterParent adds a child node according to the foster parenting rules.\n// Section 12.2.5.3, \"foster parenting\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void fixElements() { for (Element fosterElement : fosterElements) { // find parent table Element lastTable = findLastTable(fosterElement); Node fosterElementParent = fosterElement.getParentNode(); // filter our foster element Node[] fosterChilds = fosterElement.getChildNodes(); for (Node fosterChild : fosterChilds) { if (fosterChild.getNodeType() == Node.NodeType.ELEMENT) { if (isOneOfTableElements((Element) fosterChild)) { // move all child table elements outside // the foster element fosterChild.detachFromParent(); fosterElementParent.insertBefore(fosterChild, fosterElement); } } } // finally, move foster element above the table fosterElement.detachFromParent(); lastTable.getParentNode().insertBefore(fosterElement, lastTable); } }\n\n    ### Response:", "ground_truth": "Performs the fix for elements.", "predict": " // fixElements fixes the foster parenting of table elements.\n// Section 12.2.5.3, \"foster parenting\".."}, {"ID": 1209, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, Object> createSessionMap(HttpServletRequest request) { Map<String, Object> sessionMap = new HashMap<>(); HttpSession session = request.getSession(false); if (session != null) { for (Enumeration attributeNameEnum = session.getAttributeNames(); attributeNameEnum.hasMoreElements(); ) { String attributeName = (String)attributeNameEnum.nextElement(); sessionMap.put(attributeName, session.getAttribute(attributeName)); } } return sessionMap; }\n\n    ### Response: Creates a map from the session attributes in the specified request.\n\n@param request the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, BeanData> registerSessionBeans(final HttpSession httpSession) { SessionBeans sessionBeans = new SessionBeans(); httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans); return sessionBeans.getBeanMap(); }\n\n    ### Response:", "ground_truth": "Registers new session destroy callback if not already registered.", "predict": " Registers the session beans in the specified HTTP session.\n\n@param httpSession the HTTP session.\n\n    "}, {"ID": 1210, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getCachedETag(HttpHost host, String file) { Map<String, Object> cachedETags = readCachedETags(); @SuppressWarnings(\"unchecked\") Map<String, Object> hostMap = (Map<String, Object>)cachedETags.get(host.toURI()); if (hostMap == null) { return null; } @SuppressWarnings(\"unchecked\") Map<String, String> etagMap = (Map<String, String>)hostMap.get(file); if (etagMap == null) { return null; } return etagMap.get(\"ETag\"); }\n\n    ### Response: Get the cached ETag for the given host and file\n@param host the host\n@param file the file\n@return the cached ETag or null if there is no ETag in the cache.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Map<String, BeanData> getSessionMap(final HttpSession session) { SessionBeans sessionBeans = (SessionBeans) session.getAttribute(SESSION_BEANS_NAME); if (sessionBeans == null) { return null; } return sessionBeans.getBeanMap(); }\n\n    ### Response:", "ground_truth": "", "predict": " Get the session map for the given session\n@param session the session\n@return the session map or null if there is no session map in the session."}, {"ID": 1211, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getName(URI uri) { if (uri == null) { throw MESSAGES.nullArgument(\"uri\"); } String name = uri.getPath(); if (name != null) { // TODO: Not correct for certain uris like jar:...!/ int lastSlash = name.lastIndexOf('/'); if (lastSlash > 0) { name = name.substring(lastSlash + 1); } } return name; }\n\n    ### Response: Get the name.\n\n@param uri the uri\n@return name from uri's path.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(String name, final String superName, final String suffix, final String reqProxyClassName) { int lastSlash = name.lastIndexOf('/'); this.targetPackage = lastSlash == -1 ? StringPool.EMPTY : name.substring(0, lastSlash).replace('/', '.'); this.targetClassname = name.substring(lastSlash + 1); this.nextSupername = superName; this.superName = name; // create proxy name if (reqProxyClassName != null) { if (reqProxyClassName.startsWith(DOT)) { name = name.substring(0, lastSlash) + '/' + reqProxyClassName.substring(1); } else if (reqProxyClassName.endsWith(DOT)) { name = reqProxyClassName.replace('.', '/') + this.targetClassname; } else { name = reqProxyClassName.replace('.', '/'); } } // add optional suffix if (suffix != null) { name += suffix; } this.thisReference = name; this.superReference = this.superName; }\n\n    ### Response:", "ground_truth": "Work data initialization.", "predict": " Initialize the class.\n\n@param name the name of the class\n@param superName the name of the super class\n@param suffix the optional suffix for the class name\n@param reqProxyClassName the optional requested proxy class name"}, {"ID": 1212, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addModifier(Modifier modifier) { if (modifier != null) { final String ruleName = modifier.getType(); if (!Strings.isEmpty(ruleName)) { List<String> modifiers = this.modifiers.get(ruleName); if (modifiers == null) { modifiers = new ArrayList<>(); this.modifiers.put(ruleName, modifiers); } modifiers.addAll(modifier.getModifiers()); } } }\n\n    ### Response: Add a modifier for a rule.\n\nThe first modifier is the default modifier.\n\n@param modifier the modifier..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void addAdviceInitMethod(final String name) { if (adviceInits == null) { adviceInits = new ArrayList<>(); } adviceInits.add(name); }\n\n    ### Response:", "ground_truth": "Saves used constructors of advices.", "predict": " Add an advice init method.\n\n@param name the name of the advice init method."}, {"ID": 1213, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void end() { if (endCallback != null) { endCallback.accept(this, context); } if (currentPrompt != null) { currentPrompt.conversationEnded(context); currentPrompt = null; } Extensions.get(context.getBot(), ConversationRegistry.class).removeConversation(this); virgin = false; }\n\n    ### Response: Calls the conversation end method of the current prompt, and removes conversation\nfrom registry.\n\n@see ConversationPrompt#conversationEnded(ConversationContext).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void end() { if (newAction) { bundleId = bundlesManager.registerBundle(contextPath, actionPath, bundleId, bundleContentType, sources); } }\n\n    ### Response:", "ground_truth": "Called on end of parsing.", "predict": " Registers a new bundle in the bundles manager.\n\n@see BundlesManager#registerBundle(String, String, String, String, List<String>)."}, {"ID": 1214, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void put(String section, String key, String value, boolean append) { // ignore lines without = if (key == null) { return; } if (section == null) { put(key, value, append); return; } put(key.isEmpty() ? section : section + '.' + key, value, append); }\n\n    ### Response: Adds accumulated value to key and current section..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void add( final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) { // ignore lines without : or = if (key == null) { return; } String fullKey = key; if (section != null) { if (fullKey.length() != 0) { fullKey = section + '.' + fullKey; } else { fullKey = section; } } String v = value.toString(); if (trim) { if (valueTrimLeft && valueTrimRight) { v = v.trim(); } else if (valueTrimLeft) { v = StringUtil.trimLeft(v); } else { v = StringUtil.trimRight(v); } } if (v.length() == 0 && skipEmptyProps) { return; } extractProfilesAndAdd(fullKey, v, operator); }\n\n    ### Response:", "ground_truth": "Adds accumulated value to key and current section.", "predict": " Adds a key-value pair to the configuration. If the key is null, the method returns without adding anything. If the section is not null, it is added to the key before adding the key-value pair. If the value is trimmed, it is trimmed according to the trimLeft and trimRight flags. If the value is empty and skipEmptyProps is true, the method returns without adding anything. The method extracts any profiles from the key and adds the key-value pair to the corresponding profile."}, {"ID": 1215, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<E> list(int first, int max, String sortProperty, boolean ascending) { Criteria c = createCriteria() .setMaxResults(max) .setFirstResult(first); final int ndx = sortProperty.lastIndexOf('.'); if (ndx != -1) { final String associationPath = sortProperty.substring(0, ndx); final String propertyName = sortProperty.substring(ndx + 1); c = c.createAlias(associationPath, ASSOCIATION_ALIAS) .addOrder(ascending ? Order.asc(ASSOCIATION_ALIAS + \".\" + propertyName) : Order.desc(ASSOCIATION_ALIAS + \".\" + propertyName)); } else { c = c.addOrder(ascending ? Order.asc(sortProperty) : Order.desc(sortProperty)); } return list(c); }\n\n    ### Response: Returns one page of data from this repository.\n\n@param first        the first entity to return\n@param max          the maximum number of entities to return\n@param sortProperty the property to sort by\n@param ascending    whether or not the sorting is asceding\n@return one page of data from this repository.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void extractProfilesAndAdd(final String key, final String value, final Operator operator) { String fullKey = key; int ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { justAdd(fullKey, value, null, operator); return; } // extract profiles ArrayList<String> keyProfiles = new ArrayList<>(); while (true) { ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { break; } final int len = fullKey.length(); int ndx2 = fullKey.indexOf(PROFILE_RIGHT, ndx + 1); if (ndx2 == -1) { ndx2 = len; } // remember profile final String profile = fullKey.substring(ndx + 1, ndx2); keyProfiles.add(profile); // extract profile from key ndx2++; final String right = (ndx2 == len) ? StringPool.EMPTY : fullKey.substring(ndx2); fullKey = fullKey.substring(0, ndx) + right; } if (fullKey.startsWith(StringPool.DOT)) { // check for special case when only profile is defined in section fullKey = fullKey.substring(1); } // add value to extracted profiles justAdd(fullKey, value, keyProfiles, operator); }\n\n    ### Response:", "ground_truth": "Extracts profiles from the key name and adds key-value to them.", "predict": " Extracts profiles from the given key and adds the value to the corresponding profiles.\n\n@param key      the key to extract profiles from\n@param value    the value to add to the corresponding profiles\n@param operator the operator to use for adding the value to the profiles\n\n    "}, {"ID": 1216, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] getArgs(final String patternString, final String sourceString, final String[] keywordPrecedence) { log.debug(\"Util getArgs String[] with pattern: \" + patternString + \" and sourceStr: \" + sourceString); String[] rtn = null; ArrayList<String> argsList = null; String patternCopy = new String(patternString); if (keywordPrecedence != null && StringUtils.startsWithAny(patternString, keywordPrecedence)){ // for (String s : keywordPrecedence){ patternCopy = StringUtils.removeStart(patternCopy, s); } patternCopy = \"(?:\" + StringUtils.join(keywordPrecedence, \"|\") + \")\" + patternCopy; } final Pattern pattern = Pattern.compile(patternCopy); final Matcher matcher = pattern.matcher(sourceString); final int groupCount = matcher.groupCount(); // TODO - this doesn't work if we're not doing strict matching if (matcher.find()) { for (int i = 1; i <= groupCount; i++) { final String arg = matcher.group(i); if (arg != null) { if (argsList == null) { argsList = new ArrayList<String>(); } argsList.add(arg); } } } if (argsList != null) { rtn = argsList.toArray(new String[argsList.size()]); if (log.isDebugEnabled()) { final StringBuilder buf = new StringBuilder(); buf.append(\"returning args: \"); for (final String s : argsList) { buf.append(\"[\").append(s).append(\"] \"); } log.debug(buf.toString()); } } return rtn; }\n\n    ### Response: - could they be combined ??.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void justAdd(final String key, final String value, final ArrayList<String> keyProfiles, final Operator operator) { if (operator == Operator.COPY) { HashMap<String,Object> target = new HashMap<>(); String[] profiles = null; if (keyProfiles != null) { profiles = keyProfiles.toArray(new String[0]); } String[] sources = StringUtil.splitc(value, ','); for (String source : sources) { source = source.trim(); // try to extract profile for parsing String[] lookupProfiles = profiles; String lookupProfilesString = null; int leftIndex = source.indexOf('<'); if (leftIndex != -1) { int rightIndex = source.indexOf('>'); lookupProfilesString = source.substring(leftIndex + 1, rightIndex); source = source.substring(0, leftIndex).concat(source.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(lookupProfilesString, ','); StringUtil.trimAll(lookupProfiles); } String[] wildcards = new String[] {source + \".*\"}; propsData.extract(target, lookupProfiles, wildcards, null); for (Map.Entry<String, Object> entry : target.entrySet()) { String entryKey = entry.getKey(); String suffix = entryKey.substring(source.length()); String newKey = key + suffix; String newValue = \"${\" + entryKey; if (lookupProfilesString != null) { newValue += \"<\" + lookupProfilesString + \">\"; } newValue += \"}\"; if (profiles == null) { propsData.putBaseProperty(newKey, newValue, false); } else { for (final String p : profiles) { propsData.putProfileProperty(newKey, newValue, p, false); } } } } return; } boolean append = operator == Operator.QUICK_APPEND; if (keyProfiles == null) { propsData.putBaseProperty(key, value, append); return; } for (final String p : keyProfiles) { propsData.putProfileProperty(key, value, p, append); } }\n\n    ### Response:", "ground_truth": "Core key-value addition.", "predict": " - could they be combined ??."}, {"ID": 1217, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String descriptorToInternalName(String descriptor) { switch (descriptor.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': case '[': return descriptor; case 'L': return classDescriptorToInternalName(descriptor); default: throw new IllegalArgumentException(\"bad descriptor:\" + descriptor); } }\n\n    ### Response: Convert a non-method type descriptor into an internal type.\n\n@param descriptor the simple type descriptor to convert.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typedesc2ClassName(final String desc) { String className = desc; switch (desc.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': if (desc.length() != 1) { throw new IllegalArgumentException(INVALID_BASE_TYPE + desc); } break; case 'L': className = className.substring(1, className.length() - 1); break; case '[': // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. className = className.replace('/', '.'); break; default: throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } return className; }\n\n    ### Response:", "ground_truth": "Converts bytecode-like description to java class name that can be loaded\nwith a classloader. Uses less-known feature of class loaders for loading\narray classes.\n\n@see #typedescToSignature(String, jodd.mutable.MutableInteger)", "predict": " Convert a type descriptor into a class name.\n\n@param desc the type descriptor to convert.\n@return the class name corresponding to the type descriptor."}, {"ID": 1218, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void checkMethodDesc(final String desc) { if (desc == null || desc.length() == 0) { throw new IllegalArgumentException( \"Invalid method descriptor (must not be null or empty)\"); } if (desc.charAt(0) != '(' || desc.length() < 3) { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } int start = 1; if (desc.charAt(start) != ')') { do { if (desc.charAt(start) == 'V') { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } start = checkDesc(desc, start, false); } while (start < desc.length() && desc.charAt(start) != ')'); } start = checkDesc(desc, start + 1, true); if (start != desc.length()) { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } }\n\n    ### Response: Checks that the given string is a valid method descriptor.\n\n@param desc\nthe string to be checked..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typeref2Name(final String desc) { if (desc.charAt(0) != TYPE_REFERENCE) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } String name = desc.substring(1, desc.length() - 1); return name.replace('/', '.'); }\n\n    ### Response:", "ground_truth": "Converts type reference to java-name.", "predict": " Converts a type reference descriptor to a fully qualified class name.\n\n@param desc\nthe type reference descriptor to be converted.\n@return the fully qualified class name."}, {"ID": 1219, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int checkDesc(final String desc, final int start, final boolean canBeVoid) { if (desc == null || start >= desc.length()) { throw new IllegalArgumentException( \"Invalid type descriptor (must not be null or empty)\"); } int index; switch (desc.charAt(start)) { case 'V': if (canBeVoid) { return start + 1; } else { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } case 'Z': case 'C': case 'B': case 'S': case 'I': case 'F': case 'J': case 'D': return start + 1; case '[': index = start + 1; while (index < desc.length() && desc.charAt(index) == '[') { ++index; } if (index < desc.length()) { return checkDesc(desc, index, false); } else { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } case 'L': index = desc.indexOf(';', start); if (index == -1 || index - start < 2) { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } try { checkInternalName(desc, start + 1, index, null); } catch (IllegalArgumentException unused) { throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } return index + 1; default: throw new IllegalArgumentException(\"Invalid descriptor: \" + desc); } }\n\n    ### Response: Checks that a the given substring is a valid type descriptor.\n\n@param desc\nthe string to be checked.\n@param start\nindex of the first character of the identifier (inclusive).\n@param canBeVoid\ntrue if V can be considered valid.\n@return the index of the last character of the type decriptor, plus one..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typedescToSignature(final String desc, final MutableInteger from) { int fromIndex = from.get(); from.value++; // default usage for most cases switch (desc.charAt(fromIndex)) { case 'B': return \"byte\"; case 'C': return \"char\"; case 'D': return \"double\"; case 'F': return \"float\"; case 'I': return \"int\"; case 'J': return \"long\"; case 'S': return \"short\"; case 'Z': return \"boolean\"; case 'V': return \"void\"; case 'L': int index = desc.indexOf(';', fromIndex); if (index < 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } from.set(index + 1); String str = desc.substring(fromIndex + 1, index); return str.replace('/', '.'); case 'T': return desc.substring(from.value); case '[': StringBuilder brackets = new StringBuilder(); int n = fromIndex; while (desc.charAt(n) == '[') { // count opening brackets brackets.append(\"[]\"); n++; } from.value = n; String type = typedescToSignature(desc, from); // the rest of the string denotes a `<field_type>' return type + brackets; default: if (from.value == 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } // generics! return desc.substring(from.value); } }\n\n    ### Response:", "ground_truth": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n{@code\n ::= \n      ::= ||\n       ::= B|C|D|F|I|J|S|Z\n     ::= L;\n      ::= [\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL; ... an object of the given class\nS short signed short\nZ boolean true or false\n[ ... array\n}\n\nThis method converts this string into a Java type declaration such as\nString[].", "predict": " Converts a type descriptor to a JVM signature.\n\n@param desc\nthe type descriptor to be converted.\n@param from\nthe index of the first character of the type descriptor to be converted.\n@return the JVM signature corresponding to the type descriptor.\n\n    "}, {"ID": 1220, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Class<?> convertToObject(Class<?> type) { if (type == int.class) { return Integer.class; } else if (type == boolean.class) { return Boolean.class; } else if (type == byte.class) { return Byte.class; } else if (type == char.class) { return Character.class; } else if (type == short.class) { return Short.class; } else if (type == long.class) { return Long.class; } else if (type == float.class) { return Float.class; } else if (type == double.class) { return Double.class; } else if (type == void.class) { return Void.class; } else { return type; } }\n\n    ### Response: If class passed in represents a primitive type, its object peer is\nreturned. Otherwise, it is returned unchanged..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typeToTyperef(final Class type) { if (!type.isArray()) { if (!type.isPrimitive()) { return 'L' + typeToSignature(type) + ';'; } if (type == int.class) { return \"I\"; } if (type == long.class) { return \"J\"; } if (type == boolean.class) { return \"Z\"; } if (type == double.class) { return \"D\"; } if (type == float.class) { return \"F\"; } if (type == short.class) { return \"S\"; } if (type == void.class) { return \"V\"; } if (type == byte.class) { return \"B\"; } if (type == char.class) { return \"C\"; } } return type.getName(); }\n\n    ### Response:", "ground_truth": "Converts type to byteccode type ref.", "predict": " This method takes a class as input and returns a string representing the type in the JVM format. If the class is not an array, it is checked if it is a primitive type. If it is, the corresponding JVM primitive type code is returned. If it is not a primitive type, the method returns a string in the format of a class reference, preceded by the letter 'L' and followed by a semicolon. If the class is an array, the method returns the name of the class."}, {"ID": 1221, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long addAll(final String... members) { return doWithJedis(new JedisCallable<Long>() { @Override public Long call(Jedis jedis) { return jedis.sadd(getKey(), members); } }); }\n\n    ### Response: Adds to this set all of the elements in the specified members array\n@param members the members to add\n@return the number of members actually added.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Consumers<T> addAll(final Consumer<T>... consumers) { Collections.addAll(consumerList, consumers); return this; }\n\n    ### Response:", "ground_truth": "Registers additional consumers.", "predict": " Adds the specified consumers to the list of consumers to be executed when the message is received.\n@param consumers the consumers to add\n@return this object to allow for method chaining\n@throws NullPointerException if consumers is null or contains a null element"}, {"ID": 1222, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected <T> Collection<T> castCollectionToType(Class collectionType, Collection<T> converted) throws ConversionException { if (!Collection.class.isAssignableFrom(collectionType)) { throw new ConversionException(\"Collection type should extends collection\" + collectionType); } if (collectionType.isInterface()) { if (collectionType.isAssignableFrom(Set.class)) { return Collections.unmodifiableSet(new HashSet<>(converted)); } if (collectionType.isAssignableFrom(List.class)) { return Collections.unmodifiableList(new LinkedList<>(converted)); } if (collectionType.isAssignableFrom(Collection.class)) { return Collections.unmodifiableCollection(converted); } throw new ConversionException(\"Unsupported collection type \" + collectionType); } try { Constructor constructor = collectionType.getConstructor(Collection.class); return (Collection<T>) constructor.newInstance(converted); } catch (Exception e) { throw new ConversionException(\"Could not create an instance of \" + collectionType, e); } }\n\n    ### Response: Create an instance of specified collection with given element type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Collection<T> createCollection(final int length) { if (collectionType.isInterface()) { if (collectionType == List.class) { if (length > 0) { return new ArrayList<>(length); } else { return new ArrayList<>(); } } if (collectionType == Set.class) { if (length > 0) { return new HashSet<>(length); } else { return new HashSet<>(); } } throw new TypeConversionException(\"Unknown collection: \" + collectionType.getName()); } if (length > 0) { try { Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class); return ctor.newInstance(Integer.valueOf(length)); } catch (Exception ex) { // ignore exception } } try { return collectionType.getDeclaredConstructor().newInstance(); } catch (Exception ex) { throw new TypeConversionException(ex); } }\n\n    ### Response:", "ground_truth": "Creates new collection of target component type.\nDefault implementation uses reflection to create\nan collection of target type. Override it for better performances.", "predict": " Create an instance of specified collection with given length."}, {"ID": 1223, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> Collection<T> getCollection(String prefix, Function<String, T> factory) { Collection<T> collection = new ArrayList<>(); for (String property : properties.stringPropertyNames()) { if (property.startsWith(prefix + \".\")) { collection.add(factory.apply(property)); } } return collection; }\n\n    ### Response: Reads a collection of properties based on a prefix.\n\n@param prefix The prefix for which to read properties.\n@param factory The factory to call for each property name in the collection.\n@param  The collection value type.\n@return The collection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertToSingleElementCollection(final Object value) { Collection<T> collection = createCollection(0); //noinspection unchecked collection.add((T) value); return collection; }\n\n    ### Response:", "ground_truth": "Creates a collection with single element.", "predict": "Converts a single value to a collection.\n\n@param value The value to convert to a collection.\n@return The collection containing the value.\n\n    "}, {"ID": 1224, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Object toSafeJsonValue(Object value) { if (value == null) { return null; } else { if (value instanceof Boolean || value instanceof String || value instanceof Number) { return value; } if (value instanceof Iterable) { Iterable iterable = (Iterable) value; List answer = new ArrayList<>(); for (Object item : iterable) { Object itemJson = toSafeJsonValue(item); if (itemJson != null) { answer.add(itemJson); } } return answer; } if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } value = Proxies.unwrap(value); if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } if (isJsonObject(value)) { return value; } return value.toString(); } }\n\n    ### Response: Lets return a safe JSON value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertValueToCollection(Object value) { if (value instanceof Iterable) { Iterable iterable = (Iterable) value; Collection<T> collection = createCollection(0); for (Object element : iterable) { collection.add(convertType(element)); } return collection; } if (value instanceof CharSequence) { value = CsvUtil.toStringArray(value.toString()); } Class type = value.getClass(); if (type.isArray()) { // convert arrays Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { return convertPrimitiveArrayToCollection(value, componentType); } else { Object[] array = (Object[]) value; Collection<T> result = createCollection(array.length); for (Object a : array) { result.add(convertType(a)); } return result; } } // everything else: return convertToSingleElementCollection(value); }\n\n    ### Response:", "ground_truth": "Converts non-collection value to collection.", "predict": " Converts the given value to a collection.\n\n    "}, {"ID": 1225, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> Collection<T> getCollection(String prefix, Function<String, T> factory) { Collection<T> collection = new ArrayList<>(); for (String property : properties.stringPropertyNames()) { if (property.startsWith(prefix + \".\")) { collection.add(factory.apply(property)); } } return collection; }\n\n    ### Response: Reads a collection of properties based on a prefix.\n\n@param prefix The prefix for which to read properties.\n@param factory The factory to call for each property name in the collection.\n@param  The collection value type.\n@return The collection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertCollectionToCollection(final Collection value) { Collection<T> collection = createCollection(value.size()); for (Object v : value) { collection.add(convertType(v)); } return collection; }\n\n    ### Response:", "ground_truth": "Converts collection value to target collection.\nEach element is converted to target component type.", "predict": " Converts a collection to another collection of the same type.\n\n@param value The collection to convert.\n@return The converted collection.\n\n    "}, {"ID": 1226, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static List<Object> arrayAsList(Object value) { if (value instanceof List) { return (List<Object>) value; } List list = null; if (value instanceof int[]) { list = new ArrayList(); int[] array = (int[]) value; for (int i : array) { list.add(i); } } else if (value instanceof short[]) { list = new ArrayList(); short[] array = (short[]) value; for (short i : array) { list.add(i); } } else if (value instanceof char[]) { list = new ArrayList(); char[] array = (char[]) value; for (char i : array) { list.add(i); } } else if (value instanceof byte[]) { list = new ArrayList(); byte[] array = (byte[]) value; for (byte i : array) { list.add(i); } } else if (value instanceof long[]) { list = new ArrayList(); long[] array = (long[]) value; for (long i : array) { list.add(i); } } else if (value instanceof double[]) { list = new ArrayList(); double[] array = (double[]) value; for (double i : array) { list.add(i); } } else if (value instanceof float[]) { list = new ArrayList(); float[] array = (float[]) value; for (float i : array) { list.add(i); } } else if (value instanceof boolean[]) { list = new ArrayList(); boolean[] array = (boolean[]) value; for (boolean i : array) { list.add(i); } } else if (value.getClass().isArray()) { Object[] array = (Object[]) value; list = Arrays.asList(array); } return list; }\n\n    ### Response: Transforms any array to a matching list\n\n@param value\nsomething that might be an array\n@return List representation if passed in value was an array,\nnull otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"AutoBoxing\") protected Collection<T> convertPrimitiveArrayToCollection(final Object value, final Class primitiveComponentType) { Collection<T> result = null; if (primitiveComponentType == int.class) { int[] array = (int[]) value; result = createCollection(array.length); for (int a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == long.class) { long[] array = (long[]) value; result = createCollection(array.length); for (long a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == float.class) { float[] array = (float[]) value; result = createCollection(array.length); for (float a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == double.class) { double[] array = (double[]) value; result = createCollection(array.length); for (double a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == short.class) { short[] array = (short[]) value; result = createCollection(array.length); for (short a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == byte.class) { byte[] array = (byte[]) value; result = createCollection(array.length); for (byte a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == char.class) { char[] array = (char[]) value; result = createCollection(array.length); for (char a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == boolean.class) { boolean[] array = (boolean[]) value; result = createCollection(array.length); for (boolean a : array) { result.add(convertType(a)); } } return result; }\n\n    ### Response:", "ground_truth": "Converts primitive array to target collection.", "predict": " Converts a primitive array to a collection of the corresponding wrapper type.\n\n@param value\nthe primitive array to convert\n@param primitiveComponentType\nthe primitive component type of the array\n@return a collection of the corresponding wrapper type containing the elements of the primitive array\n\n    "}, {"ID": 1227, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void initLineNumber(int lineNumber) { if (lineNumber <= 0) throw new IllegalArgumentException(String.valueOf(lineNumber)); if (this.lineNumber > 0) throw new IllegalStateException(); this.lineNumber = lineNumber; }\n\n    ### Response: Initialize the line number of the script statement causing the error.\n\n@param lineNumber the line number in the script source.\nIt should be positive number.\n\n@throws IllegalStateException if the method is called more then once..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void addLineNumber(final int lineNumber) { if (this.lineNumber == 0) { this.lineNumber = (short) lineNumber; } else { if (otherLineNumbers == null) { otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]; } int otherLineNumberIndex = ++otherLineNumbers[0]; if (otherLineNumberIndex >= otherLineNumbers.length) { int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]; System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length); otherLineNumbers = newLineNumbers; } otherLineNumbers[otherLineNumberIndex] = lineNumber; } }\n\n    ### Response:", "ground_truth": "Adds a source line number corresponding to this label.\n\n@param lineNumber a source line number (which should be strictly positive).", "predict": " Add a line number to the list of line numbers associated with the script statement causing the error.\n\n@param lineNumber the line number in the script source.\n\n@throws IllegalStateException if the method is called more then once."}, {"ID": 1228, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void registerTopScript(DebuggableScript topScript, String source) { if (!topScript.isTopLevel()) { throw new IllegalArgumentException(); } String url = getNormalizedUrl(topScript); DebuggableScript[] functions = getAllFunctions(topScript); if (sourceProvider != null) { final String providedSource = sourceProvider.getSource(topScript); if(providedSource != null) { source = providedSource; } } final SourceInfo sourceInfo = new SourceInfo(source, functions, url); synchronized (urlToSourceInfo) { SourceInfo old = urlToSourceInfo.get(url); if (old != null) { sourceInfo.copyBreakpointsFrom(old); } urlToSourceInfo.put(url, sourceInfo); for (int i = 0; i != sourceInfo.functionSourcesTop(); ++i) { FunctionSource fsource = sourceInfo.functionSource(i); String name = fsource.name(); if (name.length() != 0) { functionNames.put(name, fsource); } } } synchronized (functionToSource) { for (int i = 0; i != functions.length; ++i) { FunctionSource fsource = sourceInfo.functionSource(i); functionToSource.put(functions[i], fsource); } } callback.updateSourceText(sourceInfo); }\n\n    ### Response: Registers the given script as a top-level script in the debugger..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) { methodVisitor.visitLabel(this); if (visitLineNumbers && lineNumber != 0) { methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this); if (otherLineNumbers != null) { for (int i = 1; i <= otherLineNumbers[0]; ++i) { methodVisitor.visitLineNumber(otherLineNumbers[i], this); } } } }\n\n    ### Response:", "ground_truth": "Makes the given visitor visit this label and its source line numbers, if applicable.\n\n@param methodVisitor a method visitor.\n@param visitLineNumbers whether to visit of the label's source line numbers, if any.", "predict": " Visits the label and its line number(s) if the visitLineNumbers parameter is true."}, {"ID": 1229, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Number parseNumber() throws ParseException { final int startIdx = getPosition(); if (peekMatches(\"Infinity\")) { advance(8); return Double.POSITIVE_INFINITY; } else if (peekMatches(\"-Infinity\")) { advance(9); return Double.NEGATIVE_INFINITY; } else if (peekMatches(\"NaN\")) { advance(3); return Double.NaN; } if (peek() == '-') { next(); } final int integralStartIdx = getPosition(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } final int integralEndIdx = getPosition(); final int numIntegralDigits = integralEndIdx - integralStartIdx; if (numIntegralDigits == 0) { throw new ParseException(this, \"Expected a number\"); } final boolean hasFractionalPart = peek() == '.'; if (hasFractionalPart) { next(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } if (getPosition() - (integralEndIdx + 1) == 0) { throw new ParseException(this, \"Expected digits after decimal point\"); } } final boolean hasExponentPart = peek() == '.'; if (hasExponentPart) { next(); final char sign = peek(); if (sign == '-' || sign == '+') { next(); } final int exponentStart = getPosition(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } if (getPosition() - exponentStart == 0) { throw new ParseException(this, \"Expected an exponent\"); } } final int endIdx = getPosition(); final String numberStr = getSubstring(startIdx, endIdx); if (hasFractionalPart || hasExponentPart) { return Double.valueOf(numberStr); } else if (numIntegralDigits < 9) { return Integer.valueOf(numberStr); } else if (numIntegralDigits == 9) { // For 9-digit numbers, could be int or long final long longVal = Long.parseLong(numberStr); if (longVal >= Integer.MIN_VALUE && longVal <= Integer.MAX_VALUE) { return (int) longVal; } else { return longVal; } } else { return Long.valueOf(numberStr); } }\n\n    ### Response: Parses and returns Integer, Long or Double type.\n\n\n\nNumber \u2190 Minus? IntegralPart FractionalPart? ExponentPart?\n\nMinus \u2190 \"-\"\n\nIntegralPart \u2190 \"0\" / [1-9] [0-9]*\n\nFractionalPart \u2190 \".\" [0-9]+\n\nExponentPart \u2190 ( \"e\" / \"E\" ) ( \"+\" / \"-\" )? [0-9]+\n\n\n\n@return the number\n@throws ParseException\nif parsing fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void put( final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) { if ((flags & FLAG_RESOLVED) == 0) { if (wideReference) { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length); code.putInt(-1); } else { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length); code.putShort(-1); } } else { if (wideReference) { code.putInt(bytecodeOffset - sourceInsnBytecodeOffset); } else { code.putShort(bytecodeOffset - sourceInsnBytecodeOffset); } } }\n\n    ### Response:", "ground_truth": "Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\nis known, the relative bytecode offset between the label and the instruction referencing it is\ncomputed and written directly. Otherwise, a null relative offset is written and a new forward\nreference is declared for this label.\n\n@param code the bytecode of the method. This is where the reference is appended.\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference to be appended.\n@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).", "predict": " Adds a reference to the bytecode offset of the instruction that is being referenced. If the reference is too far away, it will be stored as a forward reference.\n\n    @param code the bytecode of the class being modified\n    @param sourceInsnBytecodeOffset the bytecode offset of the instruction that is referencing the target instruction\n    @param wideReference true if the reference is a wide reference (i.e., a reference to a 32-bit instruction)\n    @throws IllegalStateException if the reference is too far away and the forward reference table is full\n\n    "}, {"ID": 1230, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addReference( final int sourcePosition, final int referencePosition) { if (srcAndRefPositions == null) { srcAndRefPositions = new int[6]; } if (referenceCount >= srcAndRefPositions.length) { int[] a = new int[srcAndRefPositions.length + 6]; System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length); srcAndRefPositions = a; } srcAndRefPositions[referenceCount++] = sourcePosition; srcAndRefPositions[referenceCount++] = referencePosition; }\n\n    ### Response: Adds a forward reference to this label. This method must be called only\nfor a true forward reference, i.e. only if this label is not resolved\nyet. For backward references, the offset of the reference can be, and\nmust be, computed and stored directly.\n\n@param sourcePosition the position of the referencing instruction. This\nposition will be used to compute the offset of this forward\nreference.\n@param referencePosition the position where the offset for this forward\nreference must be stored..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addForwardReference( final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) { if (forwardReferences == null) { forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]; } int lastElementIndex = forwardReferences[0]; if (lastElementIndex + 2 >= forwardReferences.length) { int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]; System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length); forwardReferences = newValues; } forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset; forwardReferences[++lastElementIndex] = referenceType | referenceHandle; forwardReferences[0] = lastElementIndex; }\n\n    ### Response:", "ground_truth": "Adds a forward reference to this label. This method must be called only for a true forward\nreference, i.e. only if this label is not resolved yet. For backward references, the relative\nbytecode offset of the reference can be, and must be, computed and stored directly.\n\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference stored at referenceHandle.\n@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n#FORWARD_REFERENCE_TYPE_WIDE}.\n@param referenceHandle the offset in the bytecode where the forward reference value must be\nstored.", "predict": " Adds a forward reference to this label. This method must be called only\nfor a true forward reference, i.e. only if this label is not resolved\nyet. For backward references, the offset of the reference can be, and\nmust be, computed and stored directly.\n\n@param sourceInsnBytecodeOffset the bytecode offset of the referencing instruction. This\noffset will be used to compute the offset of this forward\nreference.\n@param referenceType the type of the reference, as defined in the\n{@link ReferenceType} enum.\n@param referenceHandle the handle of the reference, as defined in the\n{@link ConstantPool} of the class."}, {"ID": 1231, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int packInt(final byte[] array, final JBBPIntCounter position, final int value) { if ((value & 0xFFFFFF80) == 0) { array[position.getAndIncrement()] = (byte) value; return 1; } else if ((value & 0xFFFF0000) == 0) { array[position.getAndIncrement()] = (byte) 0x80; array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 3; } array[position.getAndIncrement()] = (byte) 0x81; array[position.getAndIncrement()] = (byte) (value >>> 24); array[position.getAndIncrement()] = (byte) (value >>> 16); array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 5; }\n\n    ### Response: Pack an integer value and save that into a byte array since defined\nposition.\n\n@param array    a byte array where to write the packed data, it must not be\nnull\n@param position the position of the first byte of the packed value, it must\nnot be null\n@param value    the value to be packed\n@return number of bytes written into the array, the position will be\nincreased.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final boolean resolve(final byte[] code, final int bytecodeOffset) { this.flags |= FLAG_RESOLVED; this.bytecodeOffset = bytecodeOffset; if (forwardReferences == null) { return false; } boolean hasAsmInstructions = false; for (int i = forwardReferences[0]; i > 0; i -= 2) { final int sourceInsnBytecodeOffset = forwardReferences[i - 1]; final int reference = forwardReferences[i]; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK; if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) { if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to // 65535, which is sufficient since the size of a method is limited to 65535 bytes). int opcode = code[sourceInsnBytecodeOffset] & 0xFF; if (opcode < Opcodes.IFNULL) { // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA); } else { // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA); } hasAsmInstructions = true; } code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } else { code[handle++] = (byte) (relativeOffset >>> 24); code[handle++] = (byte) (relativeOffset >>> 16); code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } } return hasAsmInstructions; }\n\n    ### Response:", "ground_truth": "Sets the bytecode offset of this label to the given value and resolves the forward references\nto this label, if any. This method must be called when this label is added to the bytecode of\nthe method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\nwhere left in the bytecode by each forward reference previously added to this label.\n\n@param code the bytecode of the method.\n@param bytecodeOffset the bytecode offset of this label.\n@return {@literal true} if a blank that was left for this label was too small to store the\noffset. In such a case the corresponding jump instruction is replaced with an equivalent\nASM specific instruction using an unsigned two bytes offset. These ASM specific\ninstructions are later replaced with standard bytecode instructions with wider offsets (4\nbytes instead of 2), in ClassReader.", "predict": " Resolve forward references in the bytecode of a method.\n\n@param code           the bytecode of the method, it must not be null\n@param bytecodeOffset the offset of the first byte of the method in the\nbytecode array\n@return true if some jump instruction has been modified to be able to\nresolve the forward reference, false otherwise.\n\n    "}, {"ID": 1232, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) { // user managed stack of labels, to avoid using a recursive method // (recursivity can lead to stack overflow with very large methods) Label stack = this; while (stack != null) { // removes a label l from the stack Label l = stack; stack = l.next; l.next = null; if (JSR != null) { if ((l.status & VISITED2) != 0) { continue; } l.status |= VISITED2; // adds JSR to the successors of l, if it is a RET block if ((l.status & RET) != 0) { if (!l.inSameSubroutine(JSR)) { Edge e = new Edge(); e.info = l.inputStackTop; e.successor = JSR.successors.successor; e.next = l.successors; l.successors = e; } } } else { // if the l block already belongs to subroutine 'id', continue if (l.inSubroutine(id)) { continue; } // marks the l block as belonging to subroutine 'id' l.addToSubroutine(id, nbSubroutines); } // pushes each successor of l on the stack, except JSR targets Edge e = l.successors; while (e != null) { // if the l block is a JSR block, then 'l.successors.next' leads // to the JSR target (see {@link #visitJumpInsn}) and must // therefore not be followed if ((l.status & Label.JSR) == 0 || e != l.successors.next) { // pushes e.successor on the stack if it not already added if (e.successor.next == null) { e.successor.next = stack; stack = e.successor; } } e = e.next; } } }\n\n    ### Response: Finds the basic blocks that belong to a given subroutine, and marks these\nblocks as belonging to this subroutine. This method follows the control\nflow graph to find all the blocks that are reachable from the current\nblock WITHOUT following any JSR target.\n\n@param JSR\na JSR block that jumps to this subroutine. If this JSR is not\nnull it is added to the successor of the RET blocks found in\nthe subroutine.\n@param id\nthe id of this subroutine.\n@param nbSubroutines\nthe total number of subroutines in the method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void markSubroutine(final short subroutineId) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = listOfBlocksToProcess.nextListElement; basicBlock.nextListElement = null; // If it is not already marked as belonging to a subroutine, mark it as belonging to // subroutineId and add its successors to the list of blocks to process (unless already done). if (basicBlock.subroutineId == 0) { basicBlock.subroutineId = subroutineId; listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } } }\n\n    ### Response:", "ground_truth": "Finds the basic blocks that belong to the subroutine starting with the basic block\ncorresponding to this label, and marks these blocks as belonging to this subroutine. This\nmethod follows the control flow graph to find all the blocks that are reachable from the\ncurrent basic block WITHOUT following any jsr target.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineId the id of the subroutine starting with the basic block corresponding to\nthis label.", "predict": " Marks all the basic blocks that belong to a given subroutine with a given id. This method follows the control flow graph to find all the blocks that are reachable from the current block and marks them as belonging to the given subroutine.\n\n@param subroutineId\nthe id of the subroutine to which the basic blocks belong."}, {"ID": 1233, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void visitSubroutine(final Label JSR, final long id, final int nbSubroutines) { // user managed stack of labels, to avoid using a recursive method // (recursivity can lead to stack overflow with very large methods) Label stack = this; while (stack != null) { // removes a label l from the stack Label l = stack; stack = l.next; l.next = null; if (JSR != null) { if ((l.status & VISITED2) != 0) { continue; } l.status |= VISITED2; // adds JSR to the successors of l, if it is a RET block if ((l.status & RET) != 0) { if (!l.inSameSubroutine(JSR)) { Edge e = new Edge(); e.info = l.inputStackTop; e.successor = JSR.successors.successor; e.next = l.successors; l.successors = e; } } } else { // if the l block already belongs to subroutine 'id', continue if (l.inSubroutine(id)) { continue; } // marks the l block as belonging to subroutine 'id' l.addToSubroutine(id, nbSubroutines); } // pushes each successor of l on the stack, except JSR targets Edge e = l.successors; while (e != null) { // if the l block is a JSR block, then 'l.successors.next' leads // to the JSR target (see {@link #visitJumpInsn}) and must // therefore not be followed if ((l.status & Label.JSR) == 0 || e != l.successors.next) { // pushes e.successor on the stack if it not already added if (e.successor.next == null) { e.successor.next = stack; stack = e.successor; } } e = e.next; } } }\n\n    ### Response: Finds the basic blocks that belong to a given subroutine, and marks these\nblocks as belonging to this subroutine. This method follows the control\nflow graph to find all the blocks that are reachable from the current\nblock WITHOUT following any JSR target.\n\n@param JSR\na JSR block that jumps to this subroutine. If this JSR is not\nnull it is added to the successor of the RET blocks found in\nthe subroutine.\n@param id\nthe id of this subroutine.\n@param nbSubroutines\nthe total number of subroutines in the method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void addSubroutineRetSuccessors(final Label subroutineCaller) { // Data flow algorithm: put this basic block in a list blocks to process (which are blocks // belonging to a subroutine starting with this label) and, while there are blocks to process, // remove one from the list, put it in a list of blocks that have been processed, add a return // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks // in the control flow graph to the list of blocks to process (if not already done). Label listOfProcessedBlocks = EMPTY_LIST; Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Move a basic block from the list of blocks to process to the list of processed blocks. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = basicBlock.nextListElement; basicBlock.nextListElement = listOfProcessedBlocks; listOfProcessedBlocks = basicBlock; // Add an edge from this block to the successor of the caller basic block, if this block is // the end of a subroutine and if this block and subroutineCaller do not belong to the same // subroutine. if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) { basicBlock.outgoingEdges = new Edge( basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr // instruction leads to the jsr continuation block, i.e. where execution continues // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}). subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges); } // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does // not push basic blocks which are already in a list. Here this means either in the list of // blocks to process, or in the list of already processed blocks. This second list is // important to make sure we don't reprocess an already processed block. listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null, // so that this method can be called again with a different subroutine or subroutine caller. while (listOfProcessedBlocks != EMPTY_LIST) { Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement; listOfProcessedBlocks.nextListElement = null; listOfProcessedBlocks = newListOfProcessedBlocks; } }\n\n    ### Response:", "ground_truth": "Finds the basic blocks that end a subroutine starting with the basic block corresponding to\nthis label and, for each one of them, adds an outgoing edge to the basic block following the\ngiven subroutine call. In other words, completes the control flow graph by adding the edges\ncorresponding to the return from this subroutine, when called from the given caller basic\nblock.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\nthis label. This label is supposed to correspond to the start of a subroutine.", "predict": " Adds a return edge to the successor of the subroutine caller if applicable, and adds its successor basic blocks to the control flow graph to the list of blocks to process. This method follows the control flow graph to find all the blocks that are reachable from the current block WITHOUT following any JSR target.\n\n@param subroutineCaller\nthe label of the basic block that is the caller of the subroutine.\n\n    "}, {"ID": 1234, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int[] unwrappingGetItems(final PairTable table, final int numPairs) { if (numPairs < 1) { return null; } final int[] slotsArr = table.slotsArr; final int tableSize = 1 << table.lgSizeInts; final int[] result = new int[numPairs]; int i = 0; int l = 0; int r = numPairs - 1; // Special rules for the region before the first empty slot. final int hiBit = 1 << (table.validBits - 1); while ((i < tableSize) && (slotsArr[i] != -1)) { final int item = slotsArr[i++]; if ((item & hiBit) != 0) { result[r--] = item; } // This item was probably wrapped, so move to end. else { result[l++] = item; } } // The rest of the table is processed normally. while (i < tableSize) { final int look = slotsArr[i++]; if (look != -1) { result[l++] = look; } } assert l == (r + 1); return result; }\n\n    ### Response: While extracting the items from a linear probing hashtable,\nthis will usually undo the wrap-around provided that the table\nisn't too full. Experiments suggest that for sufficiently large tables\nthe load factor would have to be over 90 percent before this would fail frequently,\nand even then the subsequent sort would fix things up.\n@param table the given table to unwrap\n@param numPairs the number of valid pairs in the table\n@return the unwrapped table.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int[] compareDigits(final String str1, int ndx1, final String str2, int ndx2) { // iterate all digits in the first string int zeroCount1 = 0; while (charAt(str1, ndx1) == '0') { zeroCount1++; ndx1++; } int len1 = 0; while (true) { final char char1 = charAt(str1, ndx1); final boolean isDigitChar1 = CharUtil.isDigit(char1); if (!isDigitChar1) { break; } len1++; ndx1++; } // iterate all digits in the second string and compare with the first int zeroCount2 = 0; while (charAt(str2, ndx2) == '0') { zeroCount2++; ndx2++; } int len2 = 0; int ndx1_new = ndx1 - len1; int equalNumbers = 0; while (true) { final char char2 = charAt(str2, ndx2); final boolean isDigitChar2 = CharUtil.isDigit(char2); if (!isDigitChar2) { break; } if (equalNumbers == 0 && (ndx1_new < ndx1)) { equalNumbers = charAt(str1, ndx1_new++) - char2; } len2++; ndx2++; } // compare if (len1 != len2) { // numbers are not equals size return new int[] {len1 - len2}; } if (equalNumbers != 0) { return new int[] {equalNumbers}; } // numbers are equal, but number of zeros is different return new int[] {0, zeroCount1 - zeroCount2, ndx1, ndx2}; }\n\n    ### Response:", "ground_truth": "Compare digits at certain position in two strings.\nThe longest run of digits wins. That aside, the greatest\nvalue wins.\n@return if numbers are different, only 1 element is returned.", "predict": " This method compares two strings of digits and returns an array of integers. The first integer in the array is the difference in length between the two strings. If the strings are equal, the second integer in the array is the difference in the number of leading zeros between the two strings. If the strings are equal and have the same number of leading zeros, the third and fourth integers in the array are the indices of the first and last non-zero digits in the strings, respectively.\n@param str1 the first string of digits\n@param ndx1 the starting index of the first string\n@param str2 the second string of digits\n@param ndx2 the starting index of the second string\n@return an array of integers representing the comparison of the two strings of digits"}, {"ID": 1235, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static char initMaxDelimiter(char[] pDelimiters) { if (pDelimiters == null) { return 0; } char max = 0; for (char c : pDelimiters) { if (max < c) { max = c; } } return max; }\n\n    ### Response: Returns the highest char in the delimiter set.\n@param pDelimiters the delimiter set\n@return the highest char.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private char fixAccent(final char c) { for (int i = 0; i < ACCENT_CHARS.length; i+=2) { final char accentChar = ACCENT_CHARS[i]; if (accentChar == c) { return ACCENT_CHARS[i + 1]; } } return c; }\n\n    ### Response:", "ground_truth": "Fixes accent char.", "predict": " Fixes the accent character in the given char.\n@param c the char to fix\n@return the fixed char.\n\n    "}, {"ID": 1236, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] create(byte[][] rowDatas, ColumnType[] columnTypes) { int totalLength = 0; for (byte[] rowData : rowDatas) { if (rowData == null) { totalLength++; } else { int length = rowData.length; if (length < 251) { totalLength += length + 1; } else if (length < 65536) { totalLength += length + 3; } else if (length < 16777216) { totalLength += length + 4; } else { totalLength += length + 9; } } } byte[] buf = new byte[totalLength]; int pos = 0; for (byte[] arr : rowDatas) { if (arr == null) { buf[pos++] = (byte) 251; } else { int length = arr.length; if (length < 251) { buf[pos++] = (byte) length; } else if (length < 65536) { buf[pos++] = (byte) 0xfc; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[pos++] = (byte) 0xfd; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); } else { buf[pos++] = (byte) 0xfe; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); buf[pos++] = (byte) (length >>> 24); //byte[] cannot have more than 4 byte length size, so buf[pos+5] -> buf[pos+8] = 0x00; pos += 4; } System.arraycopy(arr, 0, buf, pos, length); pos += length; } } return buf; }\n\n    ### Response: Create Buffer with Text protocol values.\n\n@param rowDatas    datas\n@param columnTypes column types\n@return Buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putByte(final int byteValue) { int currentLength = length; if (currentLength + 1 > data.length) { enlarge(1); } data[currentLength++] = (byte) byteValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue a byte.\n@return this byte vector.", "predict": " Add a byte value to the end of the vector.\n\n@param byteValue the byte value to add\n@return the updated vector\n\n    "}, {"ID": 1237, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] create(byte[][] rowDatas, ColumnType[] columnTypes) { int totalLength = 0; for (byte[] rowData : rowDatas) { if (rowData == null) { totalLength++; } else { int length = rowData.length; if (length < 251) { totalLength += length + 1; } else if (length < 65536) { totalLength += length + 3; } else if (length < 16777216) { totalLength += length + 4; } else { totalLength += length + 9; } } } byte[] buf = new byte[totalLength]; int pos = 0; for (byte[] arr : rowDatas) { if (arr == null) { buf[pos++] = (byte) 251; } else { int length = arr.length; if (length < 251) { buf[pos++] = (byte) length; } else if (length < 65536) { buf[pos++] = (byte) 0xfc; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[pos++] = (byte) 0xfd; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); } else { buf[pos++] = (byte) 0xfe; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); buf[pos++] = (byte) (length >>> 24); //byte[] cannot have more than 4 byte length size, so buf[pos+5] -> buf[pos+8] = 0x00; pos += 4; } System.arraycopy(arr, 0, buf, pos, length); pos += length; } } return buf; }\n\n    ### Response: Create Buffer with Text protocol values.\n\n@param rowDatas    datas\n@param columnTypes column types\n@return Buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put11(final int byteValue1, final int byteValue2) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@return this byte vector.", "predict": " Add two bytes to the end of the buffer.\n\n@param byteValue1 first byte value\n@param byteValue2 second byte value\n@return this buffer."}, {"ID": 1238, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] create(byte[][] rowDatas, ColumnType[] columnTypes) { int totalLength = 0; for (byte[] rowData : rowDatas) { if (rowData == null) { totalLength++; } else { int length = rowData.length; if (length < 251) { totalLength += length + 1; } else if (length < 65536) { totalLength += length + 3; } else if (length < 16777216) { totalLength += length + 4; } else { totalLength += length + 9; } } } byte[] buf = new byte[totalLength]; int pos = 0; for (byte[] arr : rowDatas) { if (arr == null) { buf[pos++] = (byte) 251; } else { int length = arr.length; if (length < 251) { buf[pos++] = (byte) length; } else if (length < 65536) { buf[pos++] = (byte) 0xfc; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[pos++] = (byte) 0xfd; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); } else { buf[pos++] = (byte) 0xfe; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); buf[pos++] = (byte) (length >>> 24); //byte[] cannot have more than 4 byte length size, so buf[pos+5] -> buf[pos+8] = 0x00; pos += 4; } System.arraycopy(arr, 0, buf, pos, length); pos += length; } } return buf; }\n\n    ### Response: Create Buffer with Text protocol values.\n\n@param rowDatas    datas\n@param columnTypes column types\n@return Buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putShort(final int shortValue) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param shortValue a short.\n@return this byte vector.", "predict": " Add a short value to the end of the buffer.\n\n@param shortValue the short value to add\n@return this buffer\n\n    "}, {"ID": 1239, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] create(byte[][] rowDatas, ColumnType[] columnTypes) { int totalLength = 0; for (byte[] rowData : rowDatas) { if (rowData == null) { totalLength++; } else { int length = rowData.length; if (length < 251) { totalLength += length + 1; } else if (length < 65536) { totalLength += length + 3; } else if (length < 16777216) { totalLength += length + 4; } else { totalLength += length + 9; } } } byte[] buf = new byte[totalLength]; int pos = 0; for (byte[] arr : rowDatas) { if (arr == null) { buf[pos++] = (byte) 251; } else { int length = arr.length; if (length < 251) { buf[pos++] = (byte) length; } else if (length < 65536) { buf[pos++] = (byte) 0xfc; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[pos++] = (byte) 0xfd; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); } else { buf[pos++] = (byte) 0xfe; buf[pos++] = (byte) length; buf[pos++] = (byte) (length >>> 8); buf[pos++] = (byte) (length >>> 16); buf[pos++] = (byte) (length >>> 24); //byte[] cannot have more than 4 byte length size, so buf[pos+5] -> buf[pos+8] = 0x00; pos += 4; } System.arraycopy(arr, 0, buf, pos, length); pos += length; } } return buf; }\n\n    ### Response: Create Buffer with Text protocol values.\n\n@param rowDatas    datas\n@param columnTypes column types\n@return Buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put12(final int byteValue, final int shortValue) { int currentLength = length; if (currentLength + 3 > data.length) { enlarge(3); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue a byte.\n@param shortValue a short.\n@return this byte vector.", "predict": " Puts two bytes into the buffer.\n\n@param byteValue  first byte value\n@param shortValue second byte value\n@return this buffer."}, {"ID": 1240, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int packInt(final byte[] array, final JBBPIntCounter position, final int value) { if ((value & 0xFFFFFF80) == 0) { array[position.getAndIncrement()] = (byte) value; return 1; } else if ((value & 0xFFFF0000) == 0) { array[position.getAndIncrement()] = (byte) 0x80; array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 3; } array[position.getAndIncrement()] = (byte) 0x81; array[position.getAndIncrement()] = (byte) (value >>> 24); array[position.getAndIncrement()] = (byte) (value >>> 16); array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 5; }\n\n    ### Response: Pack an integer value and save that into a byte array since defined\nposition.\n\n@param array    a byte array where to write the packed data, it must not be\nnull\n@param position the position of the first byte of the packed value, it must\nnot be null\n@param value    the value to be packed\n@return number of bytes written into the array, the position will be\nincreased.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@param shortValue a short.\n@return this byte vector.", "predict": " Put a 112-bit value into the byte vector.\n\n@param byteValue1 the first byte value\n@param byteValue2 the second byte value\n@param shortValue the short value\n@return the updated byte vector\n\n    "}, {"ID": 1241, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeLength(long length) { if (length < 251) { buf[position++] = (byte) length; } else if (length < 65536) { buf[position++] = (byte) 0xfc; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[position++] = (byte) 0xfd; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); buf[position++] = (byte) (length >>> 16); } else { buf[position++] = (byte) 0xfe; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); buf[position++] = (byte) (length >>> 16); buf[position++] = (byte) (length >>> 24); buf[position++] = (byte) (length >>> 32); buf[position++] = (byte) (length >>> 40); buf[position++] = (byte) (length >>> 48); buf[position++] = (byte) (length >>> 54); } }\n\n    ### Response: Write length.\n\n@param length length.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putInt(final int intValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param intValue an int.\n@return this byte vector.", "predict": " Put int.\n\n@param intValue int value.\n@return this."}, {"ID": 1242, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int packInt(final byte[] array, final JBBPIntCounter position, final int value) { if ((value & 0xFFFFFF80) == 0) { array[position.getAndIncrement()] = (byte) value; return 1; } else if ((value & 0xFFFF0000) == 0) { array[position.getAndIncrement()] = (byte) 0x80; array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 3; } array[position.getAndIncrement()] = (byte) 0x81; array[position.getAndIncrement()] = (byte) (value >>> 24); array[position.getAndIncrement()] = (byte) (value >>> 16); array[position.getAndIncrement()] = (byte) (value >>> 8); array[position.getAndIncrement()] = (byte) value; return 5; }\n\n    ### Response: Pack an integer value and save that into a byte array since defined\nposition.\n\n@param array    a byte array where to write the packed data, it must not be\nnull\n@param position the position of the first byte of the packed value, it must\nnot be null\n@param value    the value to be packed\n@return number of bytes written into the array, the position will be\nincreased.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) { int currentLength = length; if (currentLength + 5 > data.length) { enlarge(5); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue1 >>> 8); currentData[currentLength++] = (byte) shortValue1; currentData[currentLength++] = (byte) (shortValue2 >>> 8); currentData[currentLength++] = (byte) shortValue2; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\nif necessary.\n\n@param byteValue a byte.\n@param shortValue1 a short.\n@param shortValue2 another short.\n@return this byte vector.", "predict": " Put a 1-byte value, 2-byte short value, and 2-byte short value into a ByteVector.\n\n@param byteValue    a 1-byte value to be put\n@param shortValue1  a 2-byte short value to be put\n@param shortValue2  a 2-byte short value to be put\n@return the ByteVector itself\n\n    "}, {"ID": 1243, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeLength(long length) { if (length < 251) { buf[position++] = (byte) length; } else if (length < 65536) { buf[position++] = (byte) 0xfc; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); } else if (length < 16777216) { buf[position++] = (byte) 0xfd; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); buf[position++] = (byte) (length >>> 16); } else { buf[position++] = (byte) 0xfe; buf[position++] = (byte) length; buf[position++] = (byte) (length >>> 8); buf[position++] = (byte) (length >>> 16); buf[position++] = (byte) (length >>> 24); buf[position++] = (byte) (length >>> 32); buf[position++] = (byte) (length >>> 40); buf[position++] = (byte) (length >>> 48); buf[position++] = (byte) (length >>> 54); } }\n\n    ### Response: Write length.\n\n@param length length.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putLong(final long longValue) { int currentLength = length; if (currentLength + 8 > data.length) { enlarge(8); } byte[] currentData = data; int intValue = (int) (longValue >>> 32); currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; intValue = (int) longValue; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param longValue a long.\n@return this byte vector.", "predict": " Put a long value.\n\n@param longValue the long value to be put.\n@return this ByteVector."}, {"ID": 1244, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int rawRead(Object array, int byteOffset, int byteLength) throws IOException { int writtenBytes = 0; for (; writtenBytes < byteLength; ) { if (uncompressedCursor >= uncompressedLimit) { if (hasNextChunk()) { continue; } else { return writtenBytes == 0 ? -1 : writtenBytes; } } int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes); Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes); writtenBytes += bytesToWrite; uncompressedCursor += bytesToWrite; } return writtenBytes; }\n\n    ### Response: Read uncompressed data into the specified array\n\n@param array\n@param byteOffset\n@param byteLength\n@return written bytes\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; }\n\n    ### Response:", "ground_truth": "Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\nbytes into this byte vector.\n@param byteOffset index of the first byte of byteArrayValue that must be copied.\n@param byteLength number of bytes of byteArrayValue that must be copied.\n@return this byte vector.", "predict": " Add a byte array to the end of this vector.\n\n@param byteArrayValue the byte array to add\n@param byteOffset the offset in the byte array to start copying from\n@param byteLength the number of bytes to copy\n@return this vector\n@throws NullPointerException if the byte array is null"}, {"ID": 1245, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static byte[] getDataCopy(byte[] data, int size) { if (data == null) { return NO_DATA; } byte[] newData = new byte[size]; System.arraycopy(data, 0, newData, 0, size); return newData; }\n\n    ### Response: Returns a copy of the data array..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void enlarge(final int size) { int doubleCapacity = 2 * data.length; int minimalCapacity = length + size; byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity]; System.arraycopy(data, 0, newData, 0, length); data = newData; }\n\n    ### Response:", "ground_truth": "Enlarges this byte vector so that it can receive 'size' more bytes.\n\n@param size number of additional bytes that this byte vector should be able to receive.", "predict": " Enlarges the data array by the specified size. If the new size is greater than the current capacity, the capacity is doubled. If the new size is less than or equal to the current capacity, the capacity is increased by the specified size."}, {"ID": 1246, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public T overlap(final T otherInterval) { if (otherInterval == null) { return null; } if (otherInterval.isInfinite()) { return (T)this; } if (this.isInfinite()) { return otherInterval; } final Interval thisAsInterval = asInterval(); final Interval otherAsInterval = otherInterval.asInterval(); Interval overlap = thisAsInterval.overlap(otherAsInterval); if (overlap == null) { return null; } return newInterval(overlap); }\n\n    ### Response: Gets the overlap between this interval and another interval.\n\n@param otherInterval\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaHttpSession(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final UserSession<T> userSession = UserSession.get(servletRequest); if (userSession == null) { return null; } final T authToken = userSession.getAuthToken(); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); if (newAuthToken != authToken) { final UserSession<T> newUserSesion = new UserSession<>(newAuthToken, userAuth().tokenValue(newAuthToken)); newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse()); } return newAuthToken; }\n\n    ### Response:", "ground_truth": "Tries to authenticate user via HTTP session. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": " Authenticates the user via the HTTP session.\n\n@param actionRequest\n@return the authenticated user's auth token."}, {"ID": 1247, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T remove(final T value) { expungeStaleEntries(); // final Entry<T> entry = removeEntry(value); if (entry == null) { return null; } final T ret = entry.get(); return ret; }\n\n    ### Response: Removes the specified value from this set.\n\n@param value the value to remove.\n@return the value removed or {@code null} if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaToken(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); // then try the auth token final String token = ServletUtil.resolveAuthBearerToken(servletRequest); if (token == null) { return null; } final T authToken = userAuth().validateToken(token); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken)); return newAuthToken; }\n\n    ### Response:", "ground_truth": "Tries to authenticate user via token. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": " Authenticates the user via a token.\n\n@param actionRequest the action request.\n@return the authenticated user or {@code null} if not authenticated.\n\n    "}, {"ID": 1248, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable private BasicCredentials getCredentials(String header) { if (header == null) { return null; } final int space = header.indexOf(' '); if (space <= 0) { return null; } final String method = header.substring(0, space); if (!prefix.equalsIgnoreCase(method)) { return null; } final String decoded; try { decoded = new String(Base64.getDecoder().decode(header.substring(space + 1)), StandardCharsets.UTF_8); } catch (IllegalArgumentException e) { logger.warn(\"Error decoding credentials\", e); return null; } // Decoded credentials is 'username:password' final int i = decoded.indexOf(':'); if (i <= 0) { return null; } final String username = decoded.substring(0, i); final String password = decoded.substring(i + 1); return new BasicCredentials(username, password); }\n\n    ### Response: Parses a Base64-encoded value of the `Authorization` header\nin the form of `Basic dXNlcm5hbWU6cGFzc3dvcmQ=`.\n\n@param header the value of the `Authorization` header\n@return a username and a password as {@link BasicCredentials}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaBasicAuth(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); final T authToken = userAuth().login(username, password); if (authToken == null) { return null; } return authToken; }\n\n    ### Response:", "ground_truth": "Tires to authenticate user via the basic authentication. Returns the token if user is authenticated.", "predict": " Authenticates the user via basic authentication.\n\n@param actionRequest the current action request\n@return an authenticated user token or null if authentication fails\n\n    "}, {"ID": 1249, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ResourceDescriptionResolver getResourceDescriptionResolver(final String... keyPrefix) { StringBuilder prefix = new StringBuilder(SUBSYSTEM_NAME); for (String kp : keyPrefix) { prefix.append('.').append(kp); } return new StandardResourceDescriptionResolver(prefix.toString(), RESOURCE_NAME, LoggingExtension.class.getClassLoader(), true, false) { @Override public String getOperationParameterDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDescription(paramName, locale, bundle); } return super.getOperationParameterDescription(operationName, paramName, locale, bundle); } @Override public String getOperationParameterValueTypeDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle, final String... suffixes) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDescription(paramName, locale, bundle); } return super.getOperationParameterValueTypeDescription(operationName, paramName, locale, bundle, suffixes); } @Override public String getOperationParameterDeprecatedDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDeprecatedDescription(paramName, locale, bundle); } return super.getOperationParameterDeprecatedDescription(operationName, paramName, locale, bundle); } }; }\n\n    ### Response: Returns a resource description resolver that uses common descriptions for some attributes.\n\n@param keyPrefix the prefix to be appended to the {@link LoggingExtension#SUBSYSTEM_NAME}\n\n@return the resolver.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String findDefaultMessage(final Locale locale, final String key) { String indexedKey = calcIndexKey(key); String msg = getMessage(fallbackBundlename, locale, key, indexedKey); if (msg != null) { return msg; } for (String bname : defaultBundles) { msg = getMessage(bname, locale, key, indexedKey); if (msg != null) { return msg; } } return null; }\n\n    ### Response:", "ground_truth": "Finds message in default bundles only, starting from fallback bundlename.", "predict": " Finds the default message for the given key in the specified locale.\n\n@param locale the locale\n@param key the message key\n\n@return the default message or null if not found.\n\n    "}, {"ID": 1250, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ResourceDescriptionResolver getResourceDescriptionResolver(final String... keyPrefix) { StringBuilder prefix = new StringBuilder(SUBSYSTEM_NAME); for (String kp : keyPrefix) { prefix.append('.').append(kp); } return new StandardResourceDescriptionResolver(prefix.toString(), RESOURCE_NAME, LoggingExtension.class.getClassLoader(), true, false) { @Override public String getOperationParameterDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDescription(paramName, locale, bundle); } return super.getOperationParameterDescription(operationName, paramName, locale, bundle); } @Override public String getOperationParameterValueTypeDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle, final String... suffixes) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDescription(paramName, locale, bundle); } return super.getOperationParameterValueTypeDescription(operationName, paramName, locale, bundle, suffixes); } @Override public String getOperationParameterDeprecatedDescription(final String operationName, final String paramName, final Locale locale, final ResourceBundle bundle) { if (DELEGATE_DESC_OPTS.contains(operationName)) { return getResourceAttributeDeprecatedDescription(paramName, locale, bundle); } return super.getOperationParameterDeprecatedDescription(operationName, paramName, locale, bundle); } }; }\n\n    ### Response: Returns a resource description resolver that uses common descriptions for some attributes.\n\n@param keyPrefix the prefix to be appended to the {@link LoggingExtension#SUBSYSTEM_NAME}\n\n@return the resolver.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ResourceBundle getBundle(final String bundleName, final Locale locale, final ClassLoader classLoader) { return ResourceBundle.getBundle(bundleName, locale, classLoader); }\n\n    ### Response:", "ground_truth": "Returns specified bundle. Invoked every time if cache is disabled.\nInput arguments are always valid.", "predict": " Returns a resource bundle for the given bundle name, locale, and class loader.\n\n@param bundleName the name of the bundle\n@param locale the locale of the bundle\n@param classLoader the class loader to use to load the bundle\n\n@return the resource bundle\n\n    "}, {"ID": 1251, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object getElementFromArrary(Object array, int index) { try { return Array.get(array, index); } catch (ArrayIndexOutOfBoundsException e) { return null; } }\n\n    ### Response: Gets the element from an array with given index.\n\n@param array the array\n@param index the index\n@return null if the array doesn't have the element at index, otherwise, return the element.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected K get(final K[] array, final int index) { return (K) Array.get(array, index); }\n\n    ### Response:", "ground_truth": "Returns array's element at given index.", "predict": " Gets the element from an array with given index.\n\n@param array the array\n@param index the index\n@return the element at the given index."}, {"ID": 1252, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void unlink(E e) { final E prev = e.getPrevious(); final E next = e.getNext(); if (prev == null) { first = next; } else { prev.setNext(next); e.setPrevious(null); } if (next == null) { last = prev; } else { next.setPrevious(prev); e.setNext(null); } }\n\n    ### Response: Unlinks the non-null element..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <E, ID> void setEntityId(final DbEntityDescriptor<E> ded, final E entity, final ID newIdValue) { ded.setIdValue(entity, newIdValue); }\n\n    ### Response:", "ground_truth": "Sets new ID value for entity.", "predict": " Sets the entity id value for the given entity."}, {"ID": 1253, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void write(EntityMetadata metadata, Object entity) { if (indexer != null) { MetamodelImpl metamodel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel( metadata.getPersistenceUnit()); ((com.impetus.kundera.index.lucene.Indexer) indexer).index(metadata, metamodel, entity); } }\n\n    ### Response: Indexes an object.\n\n@param metadata\nthe metadata\n@param entity\nthe entity.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void save(final Object entity) { final DbQuery q = query(dbOom.entities().insert(entity)); q.autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Simply inserts object into the database.", "predict": " Saves an object.\n\n@param entity\nthe entity to be saved."}, {"ID": 1254, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addCurrentEntity(Object entity) { Object identifier = identifier(entity); Object o = memento.get(identifier); if (o == null) { inserted.add(entity); } else { potentiallyChanged.put(identifier, entity); } }\n\n    ### Response: Use this entity as the new\n\n@param entity\nthe entity to be used as the new.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void update(final Object entity) { query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Updates single entity.", "predict": " Updates the entity in the database.\n\n@param entity\nthe entity to be updated in the database."}, {"ID": 1255, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final <E> E find(Class<E> entityClass, Object primaryKey) { checkClosed(); checkTransactionNeeded(); return getPersistenceDelegator().findById(entityClass, primaryKey); }\n\n    ### Response: Find by primary key. Search for an entity of the specified class and\nprimary key. If the entity instance is contained in the persistence\ncontext it is returned from there.\n\n@param entityClass\n@param primaryKey\n@return the found entity instance or null if the entity does not exist\n@throws IllegalArgumentException\nif the first argument does not denote an entity type or the\nsecond argument is is not a valid type for that entity\u2019s\nprimary key or is null\n@see javax.persistence.EntityManager#find(java.lang.Class,\njava.lang.Object).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E updateProperty(final E entity, final String name, final Object newValue) { query(dbOom.entities().updateColumn(entity, name, newValue)).autoClose().executeUpdate(); BeanUtil.declared.setProperty(entity, name, newValue); return entity; }\n\n    ### Response:", "ground_truth": "Updates single property in database and in the bean.", "predict": " Update a property of an entity instance. The entity instance is updated in the database and the entity instance is returned.\n\n@param entity\nthe entity instance to update\n@param name\nthe name of the property to update\n@param newValue\nthe new value for the property\n@return the updated entity instance\n@throws IllegalArgumentException\nif the entity argument is null or if the name argument is null or empty\n@throws IllegalStateException\nif the entity instance is not in the persistence context or if the entity instance is detached\n@see javax.persistence.EntityManager#merge(java.lang.Object)"}, {"ID": 1256, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <E> E fetch(Class<E> entityClass, Key nativeKey) { try { Entity nativeEntity = nativeReader.get(nativeKey); E entity = Unmarshaller.unmarshal(nativeEntity, entityClass); entityManager.executeEntityListeners(CallbackType.POST_LOAD, entity); return entity; } catch (DatastoreException exp) { throw new EntityManagerException(exp); } }\n\n    ### Response: Fetches the entity given the native key.\n\n@param entityClass\nthe expected result type\n@param nativeKey\nthe native key\n@return the entity with the given key, or null, if no entity exists with the given\nkey..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E updateProperty(final E entity, final String name) { Object value = BeanUtil.declared.getProperty(entity, name); query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate(); return entity; }\n\n    ### Response:", "ground_truth": "Updates property in the database by storing the current property value.", "predict": " Updates the property of the given entity with the given name.\n\n@param entity\nthe entity to update\n@param name\nthe name of the property to update\n@return the updated entity\n\n    "}, {"ID": 1257, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E findById(final Class<E> entityClass, final Object primaryKey) { E e = find(entityClass, primaryKey); if (e == null) { return null; } // Return a copy of this entity return (E) (e); }\n\n    ### Response: Find object based on primary key either form persistence cache or from\ndatabase\n\n@param entityClass\n@param primaryKey\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E, ID> E findById(final Class<E> entityType, final ID id) { return query(dbOom.entities().findById(entityType, id)).autoClose().find(entityType); }\n\n    ### Response:", "ground_truth": "Finds single entity by its id.", "predict": " Find object based on primary key either form persistence cache or from\ndatabase\n\n@param entityType\n@param id\n@return."}, {"ID": 1258, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <E> E wrapObject(final Class<E> clazz, final Object target, final TimingReporter timingReporter) { return (E) Proxy.newProxyInstance(GenericMonitoringWrapper.class.getClassLoader(), new Class[] { clazz }, new GenericMonitoringWrapper<E>(clazz, target, timingReporter)); }\n\n    ### Response: Wraps the given object and returns the reporting proxy. Uses the given\ntiming reporter to report timings.\n\n@param \nthe type of the public interface of the wrapped object\n@param clazz\nthe class object to the interface\n@param target\nthe object to wrap\n@param timingReporter\nthe reporter to report timing information to\n@return the monitoring wrapper.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) { return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType); }\n\n    ### Response:", "ground_truth": "Finds single entity by matching property.", "predict": " Finds a single entity of the given type with the given property name and value.\n\n@param entityType\nthe type of the entity to find\n@param name\nthe name of the property to match\n@param value\nthe value of the property to match\n@return the entity found, or null if none found\n\n    "}, {"ID": 1259, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> E checkInstanceOf(Class<E> type, Object object, String errorMessage) { isNotNull(type, \"type\"); if (!type.isInstance(object)) { throw new IllegalArgumentException(errorMessage); } return (E) object; }\n\n    ### Response: Tests whether the supplied object is an instance of the supplied class type.\n\n@param type         the expected type.\n@param object       the object tested against the expected type.\n@param errorMessage the errorMessage\n@return the object argument.\n@throws java.lang.IllegalArgumentException if the object is not an instance of the expected type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public <E> E findOne(final Object criteria) { return (E) query(dbOom.entities().find(criteria)).autoClose().find(criteria.getClass()); }\n\n    ### Response:", "ground_truth": "Finds one entity for given criteria.", "predict": " Finds a single entity of the specified type based on the given criteria.\n\n@param criteria the criteria to use to find the entity.\n@return the entity found.\n@throws java.lang.IllegalArgumentException if the criteria is null or if the criteria does not match any entity."}, {"ID": 1260, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"PMD.LooseCoupling\") public static Object convertToArray(final Object result, final Class entityType, final boolean projection) { final Collection res = result instanceof Collection // no projection because its applied later ? (Collection) result : convertToCollectionImpl(result, ArrayList.class, entityType, false); final Object array = Array.newInstance(entityType, res.size()); int i = 0; for (Object obj : res) { Array.set(array, i++, projection ? applyProjection(obj, entityType) : obj); } return array; }\n\n    ### Response: Convert result object to array.\n\n@param result     result object\n@param entityType target entity type\n@param projection true to apply projection, false otherwise\n@return converted result.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void deleteById(final Class entityType, final ID id) { query(dbOom.entities().deleteById(entityType, id)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Deleted single entity by its id.", "predict": " Delete entity by id.\n\n@param entityType entity type\n@param id         entity id"}, {"ID": 1261, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object toScriptEngineValueMap(Entity entity, int depth) { if (entity != null) { Object idValue = toScriptEngineValue(entity, entity.getEntityType().getIdAttribute(), 0); if (depth == 0) { return idValue; } else { Map<String, Object> map = Maps.newHashMap(); entity .getEntityType() .getAtomicAttributes() .forEach(attr -> map.put(attr.getName(), toScriptEngineValue(entity, attr, depth))); map.put(KEY_ID_VALUE, idValue); return map; } } else { return null; } }\n\n    ### Response: Convert entity to a JavaScript object. Adds \"_idValue\" as a special key to every level for\nquick access to the id value of an entity.\n\n@param entity The entity to be flattened, should start with non null entity\n@param depth Represents the number of reference levels being added to the JavaScript object\n@return A JavaScript object in Tree form, containing entities and there references.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void deleteById(final Object entity) { if (entity != null) { int result = query(dbOom.entities().deleteById(entity)).autoClose().executeUpdate(); if (result != 0) { // now reset the ID value Class type = entity.getClass(); DbEntityDescriptor ded = dbOom.entityManager().lookupType(type); setEntityId(ded, entity, 0); } } }\n\n    ### Response:", "ground_truth": "Delete single object by its id. Resets ID value.", "predict": " Deletes an entity from the database by its ID.\n\n@param entity The entity to be deleted, should start with non null entity\n@return The number of rows affected by the delete operation.\n\n    "}, {"ID": 1262, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int count(final long[] srcArr, final long thetaLong) { int cnt = 0; final int len = srcArr.length; for (int i = len; i-- > 0;) { final long hash = srcArr[i]; if (continueCondition(thetaLong, hash) ) { continue; } cnt++ ; } return cnt; }\n\n    ### Response: Counts the cardinality of the given source array.\n@param srcArr the given source array\n@param thetaLong See Theta Long\n@return the cardinality.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long count(final Class entityType) { return query(dbOom.entities().count(entityType)).autoClose().executeCount(); }\n\n    ### Response:", "ground_truth": "Counts number of all entities.", "predict": "Counts the number of entities of the given type in the database.\n@param entityType the type of entity to count\n@return the number of entities of the given type in the database."}, {"ID": 1263, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Schema create(SchemaId id, final String classType, final String name, final String description) { return new Schema(id, classType, name, description); }\n\n    ### Response: Creates a new schema. Not to be used by users, schemas are created when a configurable class are\nregistered in the system.\n\n@param id that identify this schema.\n@param classType classname that fully qualifies the configurable class that this schema originates from.\n@param name of this schema as specified in meta data, names must be unique.\n@param description purpose and useful information needed in order to manage this schema.\n\n@return A Schema..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void increaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, true)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Increases a property.", "predict": " Increases the value of a property in the database.\n\n@param entityType the type of entity that contains the property to be increased.\n@param id the identifier of the entity that contains the property to be increased.\n@param name the name of the property to be increased.\n@param delta the amount by which the property should be increased.\n\n@return void."}, {"ID": 1264, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Schema create(SchemaId id, final String classType, final String name, final String description) { return new Schema(id, classType, name, description); }\n\n    ### Response: Creates a new schema. Not to be used by users, schemas are created when a configurable class are\nregistered in the system.\n\n@param id that identify this schema.\n@param classType classname that fully qualifies the configurable class that this schema originates from.\n@param name of this schema as specified in meta data, names must be unique.\n@param description purpose and useful information needed in order to manage this schema.\n\n@return A Schema..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void decreaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, false)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Decreases a property.", "predict": " Decreases a property value for a given entity.\n\n@param entityType the type of the entity to decrease the property for.\n@param id the id of the entity to decrease the property for.\n@param name the name of the property to decrease.\n@param delta the amount to decrease the property by.\n\n@return void."}, {"ID": 1265, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> List<E> listify(ObjectMapper mapper, Object source, Class<E> targetElementType) { return (List<E>) collectify(mapper, source, List.class, targetElementType); }\n\n    ### Response: Convert an object to a list.\n\n@param mapper            the object mapper\n@param source            the source object\n@param targetElementType the target list element type\n@return list.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> List<E> findRelated(final Class<E> target, final Object source) { return query(dbOom.entities().findForeign(target, source)).autoClose().list(target); }\n\n    ### Response:", "ground_truth": "Finds related entity.", "predict": " Find related objects of a given type to a source object.\n\n@param target the target type\n@param source the source object\n@return list of related objects."}, {"ID": 1266, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E> List<E> listify(ObjectMapper mapper, Object source, Class<E> targetElementType) { return (List<E>) collectify(mapper, source, List.class, targetElementType); }\n\n    ### Response: Convert an object to a list.\n\n@param mapper            the object mapper\n@param source            the source object\n@param targetElementType the target list element type\n@return list.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> List<E> listAll(final Class<E> target) { return query(dbOom.entities().from(target)).autoClose().list(target); }\n\n    ### Response:", "ground_truth": "List all entities.", "predict": " Retrieve all instances of a given entity type from the database.\n\n@param target the entity type\n@return list of all instances of the given entity type."}, {"ID": 1267, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cancelSignals() { Iterator<String> keys = this.signals.keySet().iterator(); while (keys.hasNext()) { cancelSignal(keys.next()); } }\n\n    ### Response: Cancels any ongoing signal..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void clear() { entries = null; Iterator<String> keys = getAttributeNames(); while (keys.hasNext()) { removeAttribute(keys.next()); } }\n\n    ### Response:", "ground_truth": "Removes all attributes from the request as well as clears entries in this map.", "predict": " Removes all attributes from this session and invalidates it."}, {"ID": 1268, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Set entrySet() { if (entrySet != null) { return entrySet; } entrySet = new AbstractSet() { @Override public int size() { return ReferenceMap.this.size(); } @Override public void clear() { ReferenceMap.this.clear(); } @Override public boolean contains(final Object o) { if (o == null) { return false; } if (!(o instanceof Map.Entry)) { return false; } final Map.Entry e = (Map.Entry) o; final Entry e2 = getEntry(e.getKey()); return (e2 != null) && e.equals(e2); } @Override public boolean remove(final Object o) { final boolean r = contains(o); if (r) { final Map.Entry e = (Map.Entry) o; ReferenceMap.this.remove(e.getKey()); } return r; } @Override public Iterator iterator() { return new EntryIterator(); } @Override public Object[] toArray() { return toArray(new Object[0]); } @Override @SuppressWarnings(\"unchecked\") public Object[] toArray(final Object[] arr) { final List list = new ArrayList(); final Iterator iterator = iterator(); while (iterator.hasNext()) { final Entry e = (Entry) iterator.next(); list.add(new DefaultMapEntry(e.getKey(), e.getValue())); } return list.toArray(arr); } }; return entrySet; }\n\n    ### Response: Returns a set view of this map's entries.\n\n@return a set view of this map's entries.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Set<Entry<String, Object>> entrySet() { if (entries == null) { entries = new HashSet<>(); Iterator<String> iterator = getAttributeNames(); while (iterator.hasNext()) { final String key = iterator.next(); final Object value = getAttribute(key); entries.add(new Entry<String, Object>() { @Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (this.getClass() != obj.getClass()) { return false; } Entry entry = (Entry) obj; return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue())); } @Override public int hashCode() { return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode()); } @Override public String getKey() { return key; } @Override public Object getValue() { return value; } @Override public Object setValue(final Object obj) { setAttribute(key, obj); return value; } }); } } return entries; }\n\n    ### Response:", "ground_truth": "", "predict": " Returns a set view of this map's entries.\n\n@return a set view of this map's entries."}, {"ID": 1269, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object put(String key, Object value) { DeserializationState deserializationState = _deserState.get(); if (deserializationState.isDeserialized()) { return deserializationState.deserialized.put(key, value); } return deserializationState.overrides.put(key, value); }\n\n    ### Response: For efficiency this method breaks the contract that the old value is returned.  Otherwise common operations such\nas adding intrinsics and template attributes would require deserializing the object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object put(final String key, final Object value) { entries = null; Object previous = get(key); setAttribute(key, value); return previous; }\n\n    ### Response:", "ground_truth": "Saves an attribute in the request.", "predict": " This method violates the contract of the `Map` interface by modifying the map while iterating over it.  This can lead to unexpected behavior and is not recommended.  Instead, consider using a `ConcurrentHashMap` or a `CopyOnWriteArrayList` to avoid this issue."}, {"ID": 1270, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object get(String key, Object defaultValue) { Object value = get(key); return value == null ? defaultValue : value; }\n\n    ### Response: Get the variable value.\n\n@param key          - variable key\n@param defaultValue - default value\n@return variable value\n@see #getContext().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object remove(final Object key) { entries = null; Object value = get(key); removeAttribute(key.toString()); return value; }\n\n    ### Response:", "ground_truth": "Removes the specified request attribute.", "predict": " Remove the specified key from this map.\n\n@param key - the key to be removed\n@return the value to which the key had been mapped, or null if the key was not present\n@throws UnsupportedOperationException if the remove operation is not supported by this map\n@see #containsKey(Object)\n@see #put(Object, Object)"}, {"ID": 1271, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getCallerFromTheCurrentStack() { StackTraceElement[] stes = new Throwable().getStackTrace(); for (StackTraceElement ste : stes) { String stackLine = ste.toString(); if (!stackLine.contains(LOG.class.getName())) { return stackLine; } } return stes[stes.length - 1].toString(); }\n\n    ### Response: getCallerFromTheCurrentStack containing full class name, method name and line number of the java file name.\n\n@deprecated this may reduce the performance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"ThrowCaughtLocally\"}) public static StackTraceElement[] getCurrentStackTrace() { StackTraceElement[] ste = new Exception().getStackTrace(); if (ste.length > 1) { StackTraceElement[] result = new StackTraceElement[ste.length - 1]; System.arraycopy(ste, 1, result, 0, ste.length - 1); return result; } else { return ste; } }\n\n    ### Response:", "ground_truth": "Returns current stack trace in form of array of stack trace elements.\nFirst stack trace element is removed.\nSince an exception is thrown internally, this method is slow.", "predict": " getCurrentStackTrace returns the current stack trace of the thread. It returns an array of StackTraceElement objects, each representing a stack frame. The first element of the array represents the top of the stack, which is the method calling getCurrentStackTrace. The last element of the array represents the bottom of the stack, which is the most recent method invocation on the stack. The second element of the array represents the caller of the method calling getCurrentStackTrace."}, {"ID": 1272, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getStackTrace(final Throwable exception) { if (exception != null) { StringBuilder sb = new StringBuilder(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement element : stackTrace) { sb.append(element.toString()); sb.append('\\n'); } if (exception.getCause() != null) { StackTraceElement[] stackTraceCause = exception.getCause().getStackTrace(); for (StackTraceElement element : stackTraceCause) { sb.append(element.toString()); sb.append('\\n'); } } return sb.toString(); } return null; }\n\n    ### Response: Gets stacktrace as a String.\n\n@param exception Exception for which the stacktrace should be returned.\n@return Stacktrace as a String..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) { StackTraceElement[] st = t.getStackTrace(); ArrayList<StackTraceElement> result = new ArrayList<>(st.length); elementLoop: for (StackTraceElement element : st) { String className = element.getClassName(); if (allow != null) { boolean validElemenet = false; for (String filter : allow) { if (className.contains(filter)) { validElemenet = true; break; } } if (!validElemenet) { continue; } } if (deny != null) { for (String filter : deny) { if (className.contains(filter)) { continue elementLoop; } } } result.add(element); } st = new StackTraceElement[result.size()]; return result.toArray(st); }\n\n    ### Response:", "ground_truth": "Returns stack trace filtered by class names.", "predict": " Gets a filtered stacktrace as an array of StackTraceElement objects.\n\n@param t Exception for which the stacktrace should be filtered.\n@param allow Array of strings that should be included in the stacktrace.\n@param deny Array of strings that should be excluded from the stacktrace.\n@return Filtered stacktrace as an array of StackTraceElement objects."}, {"ID": 1273, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toStringArray(final Object array) { final int length = Array.getLength(array); final String[] result = new String[length]; for (int i = 0; i < length; i++) { result[i] = Array.get(array, i).toString(); } return result; }\n\n    ### Response: Convert an array of any type to an array of strings\n\n@param array\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) { ArrayList<StackTraceElement[]> result = new ArrayList<>(); while (t != null) { StackTraceElement[] stack = getStackTrace(t, allow, deny); result.add(stack); t = t.getCause(); } StackTraceElement[][] allStacks = new StackTraceElement[result.size()][]; for (int i = 0; i < allStacks.length; i++) { allStacks[i] = result.get(i); } return allStacks; }\n\n    ### Response:", "ground_truth": "Returns stack trace chain filtered by class names.", "predict": " Get the stack trace chain of a Throwable object, filtering out any stack trace elements that match the allow and deny lists.\n\n@param t The Throwable object to get the stack trace chain for.\n@param allow An array of strings representing stack trace elements to allow.\n@param deny An array of strings representing stack trace elements to deny.\n@return An array of arrays of StackTraceElement objects representing the stack trace chain, with any elements that match the deny list removed.\n\n    "}, {"ID": 1274, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?>[] getAllSuperClasses(Class<?> clz) { List<Class<?>> list = new ArrayList<>(); while ((clz = clz.getSuperclass()) != null) { list.add(clz); } return list.toArray(new Class<?>[list.size()]); }\n\n    ### Response: Get all super classes\n\n@param clz\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Throwable[] getExceptionChain(Throwable throwable) { ArrayList<Throwable> list = new ArrayList<>(); list.add(throwable); while ((throwable = throwable.getCause()) != null) { list.add(throwable); } Throwable[] result = new Throwable[list.size()]; return list.toArray(result); }\n\n    ### Response:", "ground_truth": "Returns exception chain starting from top up to root cause.", "predict": " Get the exception chain\n\n@param throwable\n@return an array of Throwables representing the exception chain."}, {"ID": 1275, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getStackTrace(final Throwable ex) { final StringWriter sw = new StringWriter(); final PrintWriter pw = new PrintWriter(sw, true); ex.printStackTrace(pw); pw.flush(); sw.flush(); return sw.toString(); }\n\n    ### Response: A standard function to get the stack trace from a\nthrown Exception\n\n@param ex The thrown exception\n@return The stack trace from the exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String exceptionStackTraceToString(final Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); }\n\n    ### Response:", "ground_truth": "Prints stack trace into a String.", "predict": " A standard function to convert a thrown exception to a string\n\n@param t The thrown exception\n@return The stack trace from the exception as a string."}, {"ID": 1276, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getExceptionStackTrace() { Throwable t = getException(); if (t == null) { return null; } StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); t.printStackTrace(pw); return sw.toString(); }\n\n    ### Response: Returns null if there is no exception logged..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String exceptionChainToString(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); while (t != null) { t.printStackTrace(pw); t = t.getCause(); } StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); }\n\n    ### Response:", "ground_truth": "Prints full exception stack trace, from top to root cause, into a String.", "predict": " Returns a string representation of the exception chain, including the stack trace of each exception. The string is formatted as a stack trace, with each exception separated by a newline. The string is closed after it is generated."}, {"ID": 1277, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String constructMessage(String message, Throwable cause) { if (cause != null) { StringBuilder strBuilder = new StringBuilder(); if (message != null) { strBuilder.append(message).append(\": \"); } strBuilder.append(\"Wrapped exception is {\").append(cause); strBuilder.append(\"}\"); return strBuilder.toString(); } else { return message; } }\n\n    ### Response: Constructs an exception String with the given message and incorporating the\ncausing exception\n@param message The message\n@param cause The causing exception\n@return The exception String.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String buildMessage(final String message, Throwable cause) { if (cause != null) { cause = getRootCause(cause); StringBuilder buf = new StringBuilder(); if (message != null) { buf.append(message).append(\"; \"); } buf.append(\"<--- \").append(cause); return buf.toString(); } else { return message; } }\n\n    ### Response:", "ground_truth": "Build a message for the given base message and its cause.", "predict": " Builds an exception message with the given message and incorporating the\ncausing exception\n@param message The message\n@param cause The causing exception\n@return The exception message."}, {"ID": 1278, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Throwable unwrapException(Throwable wrapped, StringBuilder outAction) { Throwable unwrapped = wrapped; while ((unwrapped instanceof ExecutionException) || (unwrapped instanceof CompletionException) || (unwrapped instanceof ExceptionWithAction)) { if ((unwrapped instanceof ExceptionWithAction) && (outAction != null)) { // Save the action string from an ExceptionWithAction, if desired. outAction.append(((ExceptionWithAction) unwrapped).getAction()); } if ((unwrapped.getCause() != null) && (unwrapped.getCause() instanceof Exception)) { unwrapped = unwrapped.getCause(); } else { break; } } return unwrapped; }\n\n    ### Response: outAction can be null if you don't care about any action string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Throwable unwrapThrowable(final Throwable wrappedThrowable) { Throwable unwrapped = wrappedThrowable; while (true) { if (unwrapped instanceof InvocationTargetException) { unwrapped = ((InvocationTargetException) unwrapped).getTargetException(); } else if (unwrapped instanceof UndeclaredThrowableException) { unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable(); } else { return unwrapped; } } }\n\n    ### Response:", "ground_truth": "Unwraps invocation and undeclared exceptions to real cause.", "predict": " This method unwraps a Throwable object and returns the root cause of the exception. It handles the cases where the exception is wrapped in InvocationTargetException or UndeclaredThrowableException."}, {"ID": 1279, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void connectAll() { for (int i = 0; i < size(); i++) { if (i == 0) { players[i].connect(true); } else if (i >= 1) { try { players[i].connect(false); } catch (Exception ex) { players[i].handleError(ex.getMessage()); } } pause(500); } if (hasCoach) { try { coach.connect(); } catch (Exception ex) { coach.handleError(ex.getMessage()); } pause(500); } }\n\n    ### Response: Connect all the players to the server.\nActionsPlayer with index 0 is always the goalie.\nConnects a coach if there is one..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerAsConsumer(final ClassScanner classScanner) { classScanner.registerEntryConsumer(classPathEntry -> { final String entryName = classPathEntry.name(); if (entryName.endsWith(actionClassSuffix)) { try { acceptActionClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc action, ignoring: \" + entryName); } } else if (classPathEntry.isTypeSignatureInUse(MADVOC_COMPONENT_ANNOTATION)) { try { acceptMadvocComponentClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc component ignoring: {}\" + entryName); } } }); }\n\n    ### Response:", "ground_truth": "Parses class name that matches madvoc-related names.", "predict": "Registers a consumer for the given class scanner.\nThe consumer will accept all classes that end with the given suffix and have the Madvoc action or component annotations.\nThe consumer will call the appropriate accept method for each class."}, {"ID": 1280, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<WarningsGroup> getByComponent(Class<? extends ICalComponent> componentClass) { List<WarningsGroup> warnings = new ArrayList<WarningsGroup>(); for (WarningsGroup group : this.warnings) { ICalComponent component = group.getComponent(); if (component == null) { continue; } if (componentClass == component.getClass()) { warnings.add(group); } } return warnings; }\n\n    ### Response: Gets all validation warnings of a given component.\n@param componentClass the component (e.g. {@code VEvent.class})\n@return the validation warnings.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void acceptMadvocComponentClass(final Class componentClass) { if (componentClass == null) { return; } if (!checkClass(componentClass)) { return; } madvocComponents.add(() -> madvocContainer.registerComponent(componentClass)); }\n\n    ### Response:", "ground_truth": "Registers new Madvoc component.", "predict": " Registers a component class for Madvoc.\n@param componentClass the component class to register.\n\n    "}, {"ID": 1281, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class<?> loadSystemClass(final String name) throws ClassNotFoundException { if (System.getSecurityManager() == null) { ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); return (systemClassLoader != null) ? systemClassLoader.loadClass(name) : bootClassLoader.loadClass(name); } try { return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() { @Override public Class<?> run() throws Exception { ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); return (systemClassLoader != null) ? systemClassLoader.loadClass(name) : bootClassLoader.loadClass(name); } }, controlContext); } catch (PrivilegedActionException e) { if (e.getException() instanceof ClassNotFoundException) throw (ClassNotFoundException) e.getException(); throw (RuntimeException) e.getException(); } }\n\n    ### Response: Returns a Class.\nTries to load a class from the System ClassLoader or if that doesn't exist tries the boot ClassLoader\n\n@param name the name of the class.\n@return a Class\n@throws ClassNotFoundException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassLoader getSystemClassLoader() { if (System.getSecurityManager() == null) { return ClassLoader.getSystemClassLoader(); } else { return AccessController.doPrivileged( (PrivilegedAction<ClassLoader>) ClassLoader::getSystemClassLoader); } }\n\n    ### Response:", "ground_truth": "Returns system class loader.", "predict": " Returns the system class loader.\n\n@return the system class loader."}, {"ID": 1282, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL getResource(String resourceName, Class<?> callingClass) { URL url = Thread.currentThread().getContextClassLoader().getResource(resourceName); if (url == null) { url = ClassLoaderUtil.class.getClassLoader().getResource(resourceName); } if (url == null) { ClassLoader cl = callingClass.getClassLoader(); if (cl != null) { url = cl.getResource(resourceName); } } if ((url == null) && (resourceName != null) && ((resourceName.length() == 0) || (resourceName.charAt(0) != '/'))) { return getResource('/' + resourceName, callingClass); } return url; }\n\n    ### Response: Load a given resource.\n\nThis method will try to load the resource using the following methods (in\norder):\n\nFrom Thread.currentThread().getContextClassLoader()\nFrom ClassLoaderUtil.class.getClassLoader()\ncallingClass.getClassLoader()\n\n\n@param resourceName\nThe name IllegalStateException(\"Unable to call \")of the\nresource to load\n@param callingClass\nThe Class object of the calling object\n@return Matching resouce or null if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { return url.openStream(); } return null; }\n\n    ### Response:", "ground_truth": "Opens a resource of the specified name for reading.\n@see #getResourceUrl(String, ClassLoader)", "predict": " Load a given resource as an InputStream.\n\nThis method will try to load the resource using the getResourceUrl() method,\nwhich will try to load the resource using the following methods (in order):\n\nFrom Thread.currentThread().getContextClassLoader()\nFrom ClassLoaderUtil.class.getClassLoader()\ncallingClass.getClassLoader()\n\nIf the resource is found, it will be opened as an InputStream and returned.\n\n@param resourceName\nThe name of the resource to load\n@param callingClass\nThe Class object of the calling object\n@return InputStream for the matching resource or null if not found.\n@throws IOException\nIf an error occurs while opening the InputStream."}, {"ID": 1283, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getContentStream(String stringUrl) throws MalformedURLException, IOException { URL url = new URL(stringUrl); URLConnection urlConnection = url.openConnection(); InputStream is = urlConnection.getInputStream(); if (\"gzip\".equals(urlConnection.getContentEncoding())) { is = new GZIPInputStream(is); } return is; }\n\n    ### Response: Get stream for URL only\n\n@param stringUrl URL to get content\n@return the input stream\n@throws IOException I/O error happened.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { URLConnection urlConnection = url.openConnection(); urlConnection.setUseCaches(useCache); return urlConnection.getInputStream(); } return null; }\n\n    ### Response:", "ground_truth": "Opens a resource of the specified name for reading. Controls caching,\nthat is important when the same jar is reloaded using custom classloader.", "predict": " Get input stream for a resource\n\n@param resourceName name of the resource to get input stream for\n@param callingClass class loader to use to load the resource\n@param useCache whether to use cache or not\n@return the input stream or null if resource not found\n@throws IOException I/O error happened."}, {"ID": 1284, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getHTMLInputStream(Class<?> clazz) throws IOException { return HTMLInputStreamPage.class.getResourceAsStream('/'+clazz.getName().replace('.', '/')+\".html\"); }\n\n    ### Response: Gets the HTML file with the same name as the provided Class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getClassAsStream(final Class clazz) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(clazz), clazz.getClassLoader()); }\n\n    ### Response:", "ground_truth": "Opens a class of the specified name for reading using class classloader.\n@see #getResourceAsStream(String, ClassLoader)", "predict": " Gets the input stream of the class file for the provided class."}, {"ID": 1285, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ObjectInputStream newObjectInputStream(Path self, final ClassLoader classLoader) throws IOException { return IOGroovyMethods.newObjectInputStream(Files.newInputStream(self), classLoader); }\n\n    ### Response: Create an object input stream for this path using the given class loader.\n\n@param self        a {@code Path} object\n@param classLoader the class loader to use when loading the class\n@return an object input stream\n@throws java.io.IOException if an IOException occurs.\n@since 2.3.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getClassAsStream(final String className, final ClassLoader classLoader) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader); }\n\n    ### Response:", "ground_truth": "Opens a class of the specified name for reading using provided class loader.", "predict": " Get an input stream for the class with the given name using the given class loader.\n\n@param className   the name of the class to load\n@param classLoader the class loader to use when loading the class\n@return an input stream for the class\n@throws java.io.IOException if an IOException occurs.\n@since 2.3.0."}, {"ID": 1286, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Set<Radio> getRadioChildren(final Widget widget, final Set<Radio> c) { Set<Radio> children = c; if (children == null) { children = new HashSet<Radio>(); } if (widget instanceof Radio) { children.add((Radio) widget); } else if (widget instanceof HasOneWidget) { children = getRadioChildren(((HasOneWidget) widget).getWidget(), children); } else if (widget instanceof HasWidgets) { for (Widget w : (HasWidgets) widget) { if (w instanceof Radio) { children.add((Radio) w); } else { children = getRadioChildren(w, children); } } } return children; }\n\n    ### Response: Gets the radio children.\n\n@param widget the widget\n@param c the current children\n@return the radio children.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; }\n\n    ### Response:", "ground_truth": "Adds a new child to the tree.", "predict": " Adds a new route chunk.\n\n@param newValue the new value\n@return the new route chunk."}, {"ID": 1287, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable private ScopeBlock findScopeBlock(ScopeBlock sb, int pc) { if ((pc <= sb.getStart()) || (pc >= sb.getFinish())) { return null; } List<ScopeBlock> children = sb.getChildren(); if (children != null) { for (ScopeBlock child : children) { ScopeBlock foundSb = findScopeBlock(child, pc); if (foundSb != null) { return foundSb; } } } return sb; }\n\n    ### Response: returns the scope block in which this register was assigned, by traversing the scope block tree\n\n@param sb\nthe scope block to start searching in\n@param pc\nthe current program counter\n@return the scope block or null if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RouteChunk findOrCreateChild(final String value) { if (children != null) { for (RouteChunk child : children) { if (child.get().equals(value)) { return child; } } } return add(value); }\n\n    ### Response:", "ground_truth": "Finds existing chunk or creates a new one if does not exist.", "predict": " finds or creates a child RouteChunk with the given value.\n\n@param value\nthe value of the RouteChunk to find or create\n@return the RouteChunk with the given value, or a new RouteChunk if not found."}, {"ID": 1288, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, String> getParameters(HttpServletRequest request) { Map<String, String> parameters = new HashMap<>(); Enumeration<?> names = request.getParameterNames(); while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = request.getParameter(key); if (StringUtils.isNotEmpty(value)) { parameters.put(key, value); } } return parameters; }\n\n    ### Response: Helps retrieve the parameters and its values as a Map\n\n@param request\nA {@link HttpServletRequest} that represents the request from which the parameters and their\ncorresponding values are to be extracted.\n@return A {@link Map} that represents the parameters and their values.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parseRequest() throws IOException { if (ServletUtil.isMultipartRequest(request)) { parseRequestStream(request.getInputStream(), characterEncoding); } else { Enumeration names = request.getParameterNames(); while (names.hasMoreElements()) { String paramName = (String) names.nextElement(); String[] values = request.getParameterValues(paramName); putParameters(paramName, values); } } }\n\n    ### Response:", "ground_truth": "Checks if request if multi-part and parse it. If request is not multi-part it\ncopies all parameters, to make usage the same in both cases.\n\n@see MultipartRequestWrapper", "predict": " Parses the request and extracts the parameters and their values.\n\n@throws IOException\nIf an I/O error occurs while parsing the request.\n@param request\nA {@link HttpServletRequest} that represents the request from which the parameters and their\ncorresponding values are to be extracted.\n@param characterEncoding\nThe character encoding to be used while parsing the request.\n\n    "}, {"ID": 1289, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static Object convertToCollection(final Object result, final Class collectionType, final Class targetEntity, final boolean projection) { final Object converted; if (collectionType.equals(Iterator.class)) { converted = toIterator(result, targetEntity, projection); } else if (collectionType.isAssignableFrom(List.class)) { converted = Lists.newArrayList(toIterator(result, targetEntity, projection)); } else if (collectionType.isAssignableFrom(Set.class)) { converted = Sets.newHashSet(toIterator(result, targetEntity, projection)); } else if (!collectionType.isInterface()) { converted = convertToCollectionImpl(result, collectionType, targetEntity, projection); } else { throw new ResultConversionException(String.format( \"Incompatible result type requested %s for conversion from actual result %s\", collectionType, result.getClass())); } return converted; }\n\n    ### Response: Convert result object to collection. In some cases, this could be do nothing case, because orient already\nreturns collection. If projection is required or when collection type is different from requested type,\nresult will be re-packaged into the new collection.\n\n@param result         result instance\n@param collectionType target collection type\n@param targetEntity   target entity type\n@param projection     true to apply projection, false otherwise\n@return converted result.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Object convertToCollection(final Object value, final Class destinationType, final Class componentType) { return typeConverterManager.convertToCollection(value, destinationType, componentType); }\n\n    ### Response:", "ground_truth": "Converter to collection.", "predict": " Convert value to collection.\n\n@param value          value to convert\n@param destinationType destination collection type\n@param componentType   component type of the collection\n@return converted value."}, {"ID": 1290, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object wrapValue(MetaProperty<?> metaProp, Class<?> beanType, Object value) { Object[] helpers = OPTIONALS.get(metaProp.propertyType()); if (helpers != null) { try { if (value != null) { value = ((Method) helpers[0]).invoke(null, value); } else { value = helpers[1]; } } catch (Exception ex) { throw new RuntimeException(ex); } } return value; }\n\n    ### Response: Wraps the value of a property if it is an optional.\n\n@param metaProp  the property to query, not null\n@param beanType  the type of the bean, not null\n@param value  the value to wrap, may be null\n@return the value of the property, with any optional wrapper added.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeSetter(final Setter setter, final BeanProperty bp, Object value) { try { final MapperFunction setterMapperFunction = setter.getMapperFunction(); if (setterMapperFunction != null) { value = setterMapperFunction.apply(value); } final Class type = setter.getSetterRawType(); if (ClassUtil.isTypeOf(type, Collection.class)) { Class componentType = setter.getSetterRawComponentType(); value = convertToCollection(value, type, componentType); } else { // no collections value = convertType(value, type); } setter.invokeSetter(bp.bean, value); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Setter failed: \" + setter, ex); } return value; }\n\n    ### Response:", "ground_truth": "Invokes setter, but first converts type to match the setter type.", "predict": " Invokes the setter on the bean with the given value.\n\n@param setter  the setter to invoke, not null\n@param bp  the bean property to set, not null\n@param value  the value to set, may be null\n@return the value that was set, after any conversion or mapping has been applied.\n\n    "}, {"ID": 1291, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T[] insert(T element, T[] array, int index) { Assert.notNull(array, \"Array is required\"); assertThat(index).throwing(new ArrayIndexOutOfBoundsException( String.format(\"[%1$d] is not a valid index [0, %2$d] in the array\", index, array.length))) .isGreaterThanEqualToAndLessThanEqualTo(0, array.length); Class<?> componentType = array.getClass().getComponentType(); componentType = defaultIfNull(componentType, ObjectUtils.getClass(element)); componentType = defaultIfNull(componentType, Object.class); T[] newArray = (T[]) Array.newInstance(componentType, array.length + 1); if (index > 0) { System.arraycopy(array, 0, newArray, 0, index); } newArray[index] = element; if (index < array.length) { System.arraycopy(array, index, newArray, index + 1, array.length - index); } return newArray; }\n\n    ### Response: Inserts element into the array at index.\n\n@param  Class type of the elements in the array.\n@param element element to insert into the array.\n@param array array in which the element is inserted.\n@param index an integer indicating the index into the array at which the element will be inserted.\n@return a new array with element inserted at index.\n@throws IllegalArgumentException if array is null.\n@throws ArrayIndexOutOfBoundsException if given index is not a valid index in the array.\n@see #prepend(Object, Object[])\n@see #append(Object, Object[]).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void arrayForcedSet(final BeanProperty bp, Object array, final int index, Object value) { Class componentType = array.getClass().getComponentType(); array = ensureArraySize(bp, array, componentType, index); value = convertType(value, componentType); Array.set(array, index, value); }\n\n    ### Response:", "ground_truth": "Sets the array element forced. If index is greater then arrays length, array will be expanded to the index.\nIf speed is critical, it is better to allocate an array with proper size before using this method.", "predict": "Sets the value at the specified index in the array, regardless of the current value.\n\n@param bp the BeanProperty for the array being set.\n@param array the array to set the value in.\n@param index the index of the value to set.\n@param value the value to set.\n@throws IllegalArgumentException if array is null.\n@throws ArrayIndexOutOfBoundsException if the index is out of bounds for the array.\n@throws ClassCastException if the value cannot be cast to the array's component type."}, {"ID": 1292, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JoseFactory instance() { if (instance == null) { synchronized (JoseFactory.class) { if (instance != null) { return instance; } ClassLoader cl = AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> Thread.currentThread().getContextClassLoader()); if (cl == null) { cl = JoseFactory.class.getClassLoader(); } JoseFactory newInstance = loadSpi(cl); if (newInstance == null && cl != JoseFactory.class.getClassLoader()) { cl = JoseFactory.class.getClassLoader(); newInstance = loadSpi(cl); } if (newInstance == null) { newInstance = new DefaultJoseFactory(); } instance = newInstance; } } return instance; }\n\n    ### Response: Obtain the JoseFactory using the ServiceLoader pattern.\n\n@return the factory instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object createBeanProperty(final BeanProperty bp) { Setter setter = bp.getSetter(true); if (setter == null) { return null; } Class type = setter.getSetterRawType(); Object newInstance; try { newInstance = ClassUtil.newInstance(type); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Invalid property: \" + bp.name, bp, ex); } newInstance = invokeSetter(setter, bp, newInstance); return newInstance; }\n\n    ### Response:", "ground_truth": "Creates new instance for current property name through its setter.\nIt uses default constructor!", "predict": " Create a new instance of the property type and invoke the setter method on it.\n\n@param bp the property to create\n@return the new instance or null if the property is read-only or an error occurred."}, {"ID": 1293, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> findClass(String classname) { Class<?> type = null; final ClassLoader loader = ClassLoaderFinder.findClassLoader(); if (loader != null) { try { type = loader.loadClass(classname); } catch (ClassNotFoundException e) { // } } if (type == null) { try { type = ClassFinder.class.getClassLoader().loadClass(classname); } catch (ClassNotFoundException e) { // } } if (type == null) { try { type = Class.forName(classname); } catch (ClassNotFoundException e) { // } } if (type != null && !LogService.class.isAssignableFrom(type)) { return type; } return null; }\n\n    ### Response: Find the class with a search policy.\n\n@param classname the name of the class.\n@return the class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class extractType(final BeanProperty bp) { Getter getter = bp.getGetter(isDeclared); if (getter != null) { if (bp.index != null) { Class type = getter.getGetterRawComponentType(); return type == null ? Object.class : type; } return getter.getGetterRawType(); } return null; // this should not happens }\n\n    ### Response:", "ground_truth": "Extracts type of current property.", "predict": " Extract the type of a property.\n\n@param bp the property to extract the type from.\n@return the type of the property."}, {"ID": 1294, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getSuccessMessageFromCookie(final HttpServletRequest request) { final Cookie cookie = getCookieByName(request, AZKABAN_SUCCESS_MESSAGE); if (cookie == null) { return null; } return cookie.getValue(); }\n\n    ### Response: Retrieves a success message from a cookie. azkaban.success.message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void stop(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { final HttpSession httpSession = servletRequest.getSession(false); if (httpSession != null) { httpSession.removeAttribute(AUTH_SESSION_NAME); } final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME); if (cookie == null) { return; } cookie.setMaxAge(0); cookie.setPath(\"/\"); servletResponse.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "", "predict": " Removes the authentication session and sets the authentication cookie to expire."}, {"ID": 1295, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setErrorMessageInCookie(final HttpServletResponse response, final String errorMsg) { final Cookie cookie = new Cookie(AZKABAN_FAILURE_MESSAGE, errorMsg); cookie.setPath(\"/\"); response.addCookie(cookie); }\n\n    ### Response: Sets an error message in azkaban.failure.message in the cookie. This will be used by the web\nclient javascript to somehow display the message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) { final HttpSession httpSession = httpServletRequest.getSession(true); httpSession.setAttribute(AUTH_SESSION_NAME, this); final Cookie cookie = new Cookie(AUTH_COOKIE_NAME, authTokenValue); //cookie.setDomain(SSORealm.SSO_DOMAIN); cookie.setMaxAge(cookieMaxAge); cookie.setPath(\"/\"); httpServletResponse.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "Starts new user session.", "predict": " Initializes the session and sets the authentication token in a cookie. The cookie is set to expire after a certain amount of time (cookieMaxAge) and is accessible to the entire web application. The domain is set to the SSO domain, which is used to authenticate the user."}, {"ID": 1296, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Date localDateToDate(LocalDate localDate) { Objects.requireNonNull(localDate, Required.LOCAL_DATE.toString()); Instant instant = localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant(); return Date.from(instant); }\n\n    ### Response: Converts a localDate to Date\n\n@param localDate The LocalDate to convert\n@return The converted Date.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Date toDate(final LocalDate localDate) { return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant()); }\n\n    ### Response:", "ground_truth": "Converts local date to Date.", "predict": " Converts a localDate to Date\n\n@param localDate The LocalDate to convert\n@return The converted Date."}, {"ID": 1297, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Calendar toCalendar(final long millis) { final Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(millis); return calendar; }\n\n    ### Response: Converts the given long value to a calendar object.\n\n@param millis\nthe millis\n@return the calendar.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Calendar toCalendar(final LocalDateTime localDateTime) { return GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault())); }\n\n    ### Response:", "ground_truth": "Converts local date time to Calendar.", "predict": " Converts the given LocalDateTime value to a calendar object.\n\n@param localDateTime\nthe localDateTime\n@return the calendar."}, {"ID": 1298, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Class getDynamicProxyClass(Class baseClass) { Class[] m_dynamicProxyClassInterfaces; if (foundInterfaces.containsKey(baseClass)) { m_dynamicProxyClassInterfaces = (Class[])foundInterfaces.get(baseClass); } else { m_dynamicProxyClassInterfaces = getInterfaces(baseClass); foundInterfaces.put(baseClass, m_dynamicProxyClassInterfaces); } // return dynymic Proxy Class implementing all interfaces Class proxyClazz = Proxy.getProxyClass(baseClass.getClassLoader(), m_dynamicProxyClassInterfaces); return proxyClazz; }\n\n    ### Response: returns a dynamic Proxy that implements all interfaces of the\nclass described by this ClassDescriptor.\n\n@return Class the dynamically created proxy class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class defineProxy(final Class target) { ProxyProxettaFactory builder = proxetta.proxy(); builder.setTarget(target); return builder.define(); }\n\n    ### Response:", "ground_truth": "Generates new class.", "predict": " defines a dynamic proxy class for the given target class.\n\n@param target the target class to be proxied.\n@return the dynamically created proxy class."}, {"ID": 1299, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<HyperlinkPart, List<String>> extractHyperlinks(String html) { Map<HyperlinkPart, List<String>> hyperlinksMap = new HashMap<>(); hyperlinksMap.put(HyperlinkPart.HTMLTAG, new ArrayList<>()); hyperlinksMap.put(HyperlinkPart.URL, new ArrayList<>()); hyperlinksMap.put(HyperlinkPart.ANCHORTEXT, new ArrayList<>()); Matcher m = HYPERLINK_PATTERN.matcher(html); while (m.find()) { if(m.groupCount()==2) { String tag = m.group(0); String url = m.group(1); String anchortext = m.group(2); hyperlinksMap.get(HyperlinkPart.HTMLTAG).add(tag); hyperlinksMap.get(HyperlinkPart.URL).add(url); hyperlinksMap.get(HyperlinkPart.ANCHORTEXT).add(anchortext); } } return hyperlinksMap; }\n\n    ### Response: Extracts the hyperlinks from an html string and returns their components\nin a map.\n\n@param html\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Check check) { String name = check.getName(); List<Check> list = map.computeIfAbsent(name, k -> new ArrayList<>()); list.add(check); }\n\n    ### Response:", "ground_truth": "Adds validation checks.", "predict": " Adds a check to the map of checks.\n\n@param check The check to add to the map."}, {"ID": 1300, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private VersionControl getAssetVersionControl() throws IOException, DataAccessException { VersionControl vc = getVersionControl(); if (vc == null) vc = DataAccess.getAssetVersionControl(assetRoot); return vc; }\n\n    ### Response: Falls back to DataAccess version control for asset versioning..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ValidationContext resolveFor(final Class<?> target) { ValidationContext vc = new ValidationContext(); vc.addClassChecks(target); return vc; }\n\n    ### Response:", "ground_truth": "Resolve validation context for provided target class.\n@see #addClassChecks(Class)", "predict": "Resolves validation context for the given target class."}, {"ID": 1301, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<LightweightTypeReference> cloneTypeReferences(List<JvmTypeReference> types, Map<String, JvmTypeReference> typeParameterMap) { final List<LightweightTypeReference> newList = new ArrayList<>(types.size()); for (final JvmTypeReference type : types) { newList.add(cloneTypeReference(type, typeParameterMap)); } return newList; }\n\n    ### Response: Clone the given types by applying the type parameter mapping when necessary.\n\n@param types the types to clone.\n@param typeParameterMap the type parameter mapping.\n@return the clones..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addClassChecks(final Class target) { final List<Check> list = cache.get(target, () -> { final List<Check> newList = new ArrayList<>(); final ClassDescriptor cd = ClassIntrospector.get().lookup(target); final PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { collectPropertyAnnotationChecks(newList, propertyDescriptor); } return newList; }); addAll(list); }\n\n    ### Response:", "ground_truth": "Parses class annotations and adds all checks.\n@see #resolveFor(Class)", "predict": " Add checks for the given class to the cache.\n\n@param target the class to add checks for.\n\n    "}, {"ID": 1302, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void sawOpcode(int seen) { try { stack.precomputation(this); if (seen == Const.INVOKEINTERFACE) { KeyType type = isKeyAccessMethod(seen); if (type != null) { int numParms = SignatureUtils.getNumParameters(getSigConstantOperand()); if (stack.getStackDepth() >= numParms) { OpcodeStack.Item item = stack.getStackItem(numParms - 1); String parmName = (String) item.getConstant(); if (parmName != null) { String upperParmName = parmName.toUpperCase(Locale.getDefault()); Map<String, Map<String, List<SourceInfo>>> typeMap = parmInfo.get(KeyType.PARAMETER); Map<String, List<SourceInfo>> parmCaseInfo = typeMap.get(upperParmName); if (parmCaseInfo == null) { parmCaseInfo = new HashMap<>(); typeMap.put(upperParmName, parmCaseInfo); } List<SourceInfo> annotations = parmCaseInfo.get(parmName); if (annotations == null) { annotations = new ArrayList<>(); parmCaseInfo.put(parmName, annotations); } annotations.add(new SourceInfo(getClassName(), getMethodName(), getMethodSig(), getMethod().isStatic(), SourceLineAnnotation.fromVisitedInstruction(getClassContext(), this, getPC()))); } } } } } finally { stack.sawOpcode(this, seen); } }\n\n    ### Response: implements the visitor to look for calls to HttpServletRequest.getParameter and collect what the name of the key is.\n\n@param seen\nthe opcode of the currently parsed instruction.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectPropertyAnnotationChecks(final List<Check> annChecks, final PropertyDescriptor propertyDescriptor) { FieldDescriptor fd = propertyDescriptor.getFieldDescriptor(); if (fd != null) { Annotation[] annotations = fd.getField().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } MethodDescriptor md = propertyDescriptor.getReadMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } md = propertyDescriptor.getWriteMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } }\n\n    ### Response:", "ground_truth": "Process all annotations of provided properties.", "predict": "collects the annotation checks for a given property descriptor.\n\n@param annChecks\nthe list of annotation checks to be collected.\n\n@param propertyDescriptor\nthe property descriptor to collect the annotation checks for."}, {"ID": 1303, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"TryWithIdenticalCatches\") private static Map<View, FormValidator.FieldInfo> findFieldsToValidate(Object target) { final Field[] fields = target.getClass().getDeclaredFields(); if (fields == null || fields.length == 0) { return Collections.emptyMap(); } final WeakHashMap<View, FormValidator.FieldInfo> infoMap = new WeakHashMap<>(fields.length); for (Field field : fields) { final List<FormValidator.ValidationInfo> infos = new ArrayList<>(); final Annotation[] annotations = field.getDeclaredAnnotations(); if (annotations.length > 0) { if (! View.class.isAssignableFrom(field.getType())) { // next field continue; } final View view; try { field.setAccessible(true); view = (View) field.get(target); } catch (IllegalAccessException e) { throw new FormsValidationException(e); } if (view == null) { continue; } for (Annotation annotation : annotations) { final IValidator validator; try { validator = ValidatorFactory.getValidator(annotation); } catch (IllegalAccessException e) { throw new FormsValidationException(e); } catch (InstantiationException e) { throw new FormsValidationException(e); } if (validator != null) { FormValidator.ValidationInfo info = new FormValidator.ValidationInfo(annotation, validator); infos.add(info); } } final Condition conditionAnnotation = field.getAnnotation(Condition.class); if (infos.size() > 0) { Collections.sort(infos, new Comparator<FormValidator.ValidationInfo>() { @Override public int compare(FormValidator.ValidationInfo lhs, FormValidator.ValidationInfo rhs) { return lhs.order < rhs.order ? -1 : (lhs.order == rhs.order ? 0 : 1); } }); } final FormValidator.FieldInfo fieldInfo = new FormValidator.FieldInfo(conditionAnnotation, infos); infoMap.put(view, fieldInfo); } } return infoMap; }\n\n    ### Response: find fields on target to validate and prepare for their validation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected void collectAnnotationChecks(final List<Check> annChecks, final Class targetType, final String targetName, final Annotation[] annotations) { for (Annotation annotation : annotations) { Constraint c = annotation.annotationType().getAnnotation(Constraint.class); Class<? extends ValidationConstraint> constraintClass; if (c == null) { // if constraint is not available, try lookup String constraintClassName = annotation.annotationType().getName() + \"Constraint\"; try { constraintClass = ClassLoaderUtil.loadClass(constraintClassName, this.getClass().getClassLoader()); } catch (ClassNotFoundException ingore) { continue; } } else { constraintClass = c.value(); } ValidationConstraint vc; try { vc = newConstraint(constraintClass, targetType); } catch (Exception ex) { throw new VtorException(\"Invalid constraint: \" + constraintClass.getClass().getName(), ex); } vc.configure(annotation); Check check = new Check(targetName, vc); copyDefaultCheckProperties(check, annotation); annChecks.add(check); } }\n\n    ### Response:", "ground_truth": "Collect annotations for some target.", "predict": " collect annotation checks for the given target type, target name and annotations.\n\n    "}, {"ID": 1304, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Activate protected void activate(Map<String, Object> properties) throws Exception { this.host = (String) properties.get(\"host\"); Integer iiopPort = (Integer) properties.get(\"iiopPort\"); this.iiopPort = iiopPort == null ? -1 : iiopPort; iiopsOptions = Nester.nest(\"iiopsOptions\", properties); }\n\n    ### Response: Start the ORB associated with this bean instance.\n\n@exception Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void copyDefaultCheckProperties(final Check destCheck, final Annotation annotation) { Integer severity = (Integer) ClassUtil.readAnnotationValue(annotation, ANN_SEVERITY); destCheck.setSeverity(severity.intValue()); String[] profiles = (String[]) ClassUtil.readAnnotationValue(annotation, ANN_PROFILES); destCheck.setProfiles(profiles); String message = (String) ClassUtil.readAnnotationValue(annotation, ANN_MESSAGE); destCheck.setMessage(message); }\n\n    ### Response:", "ground_truth": "Copies default properties from annotation to the check.", "predict": " Copy the default check properties from the given annotation to the given check instance.\n\n@param destCheck The check instance to copy the properties to.\n@param annotation The annotation to read the properties from.\n@exception Exception."}, {"ID": 1305, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String toAsciiString(byte[] bytes) { for(int i = 0; i < bytes.length; i++) { if(bytes[i] < 0) return null; } char[] chars = new char[bytes.length]; for(int i = 0; i < bytes.length; i++) { chars[i] = (char)bytes[i]; } return new String(chars); }\n\n    ### Response: return string if bytes have only ascii symbols, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String encodeUriComponent(final String source, final String encoding, final URIPart uriPart) { if (source == null) { return null; } byte[] bytes = encodeBytes(StringUtil.getBytes(source, encoding), uriPart); char[] chars = new char[bytes.length]; for (int i = 0; i < bytes.length; i++) { chars[i] = (char) bytes[i]; } return new String(chars); }\n\n    ### Response:", "ground_truth": "Encodes single URI component.", "predict": " Encodes the given string as a URI component using the specified encoding scheme. The resulting URI component will only contain characters that are valid for the specified URI part."}, {"ID": 1306, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(String scheme, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(scheme, encoding, HierarchicalUriComponents.Type.SCHEME); }\n\n    ### Response: Encodes the given URI scheme with the given encoding.\n@param scheme the scheme to be encoded\n@param encoding the character encoding to encode to\n@return the encoded scheme\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode(final String string, final String encoding) { return encodeUriComponent(string, encoding, URIPart.UNRESERVED); }\n\n    ### Response:", "ground_truth": "Encodes string using default RFCP rules.", "predict": " Encodes the given string with the given encoding.\n@param string the string to be encoded\n@param encoding the character encoding to encode to\n@return the encoded string\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    "}, {"ID": 1307, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(String scheme, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(scheme, encoding, HierarchicalUriComponents.Type.SCHEME); }\n\n    ### Response: Encodes the given URI scheme with the given encoding.\n@param scheme the scheme to be encoded\n@param encoding the character encoding to encode to\n@return the encoded scheme\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(final String scheme, final String encoding) { return encodeUriComponent(scheme, encoding, URIPart.SCHEME); }\n\n    ### Response:", "ground_truth": "Encodes the given URI scheme with the given encoding.", "predict": " Encodes the given URI scheme with the given encoding.\n@param scheme the scheme to be encoded\n@param encoding the character encoding to encode to\n@return the encoded scheme\n\n    "}, {"ID": 1308, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeHost(String host, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4); }\n\n    ### Response: Encodes the given URI host with the given encoding.\n@param host the host to be encoded\n@param encoding the character encoding to encode to\n@return the encoded host\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeHost(final String host, final String encoding) { return encodeUriComponent(host, encoding, URIPart.HOST); }\n\n    ### Response:", "ground_truth": "Encodes the given URI host with the given encoding.", "predict": " Encodes the given URI host with the given encoding.\n@param host the host to be encoded\n@param encoding the character encoding to encode to\n@return the encoded host\n\n    "}, {"ID": 1309, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePort(String port, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(port, encoding, HierarchicalUriComponents.Type.PORT); }\n\n    ### Response: Encodes the given URI port with the given encoding.\n@param port the port to be encoded\n@param encoding the character encoding to encode to\n@return the encoded port\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePort(final String port, final String encoding) { return encodeUriComponent(port, encoding, URIPart.PORT); }\n\n    ### Response:", "ground_truth": "Encodes the given URI port with the given encoding.", "predict": " Encodes the given URI port with the given encoding.\n@param port the port to be encoded\n@param encoding the character encoding to encode to\n@return the encoded port\n\n    "}, {"ID": 1310, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePath(String path, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(path, encoding, HierarchicalUriComponents.Type.PATH); }\n\n    ### Response: Encodes the given URI path with the given encoding.\n@param path the path to be encoded\n@param encoding the character encoding to encode to\n@return the encoded path\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePath(final String path, final String encoding) { return encodeUriComponent(path, encoding, URIPart.PATH); }\n\n    ### Response:", "ground_truth": "Encodes the given URI path with the given encoding.", "predict": " Encodes the given URI path with the given encoding.\n@param path the path to be encoded\n@param encoding the character encoding to encode to\n@return the encoded path\n\n    "}, {"ID": 1311, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQuery(String query, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(query, encoding, HierarchicalUriComponents.Type.QUERY); }\n\n    ### Response: Encodes the given URI query with the given encoding.\n@param query the query to be encoded\n@param encoding the character encoding to encode to\n@return the encoded query\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQuery(final String query, final String encoding) { return encodeUriComponent(query, encoding, URIPart.QUERY); }\n\n    ### Response:", "ground_truth": "Encodes the given URI query with the given encoding.", "predict": " Encodes the given URI query with the given encoding.\n@param query the query to be encoded\n@param encoding the character encoding to encode to\n@return the encoded query\n\n    "}, {"ID": 1312, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQueryParam(String queryParam, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(queryParam, encoding, HierarchicalUriComponents.Type.QUERY_PARAM); }\n\n    ### Response: Encodes the given URI query parameter with the given encoding.\n@param queryParam the query parameter to be encoded\n@param encoding the character encoding to encode to\n@return the encoded query parameter\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQueryParam(final String queryParam, final String encoding) { return encodeUriComponent(queryParam, encoding, URIPart.QUERY_PARAM); }\n\n    ### Response:", "ground_truth": "Encodes the given URI query parameter with the given encoding.", "predict": " Encodes the given URI query parameter with the given encoding.\n@param queryParam the query parameter to be encoded\n@param encoding the character encoding to encode to\n@return the encoded query parameter\n\n    "}, {"ID": 1313, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeFragment(String fragment, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(fragment, encoding, HierarchicalUriComponents.Type.FRAGMENT); }\n\n    ### Response: Encodes the given URI fragment with the given encoding.\n@param fragment the fragment to be encoded\n@param encoding the character encoding to encode to\n@return the encoded fragment\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeFragment(final String fragment, final String encoding) { return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT); }\n\n    ### Response:", "ground_truth": "Encodes the given URI fragment with the given encoding.", "predict": " Encodes the given URI fragment with the given encoding.\n@param fragment the fragment to be encoded\n@param encoding the character encoding to encode to\n@return the encoded fragment\n\n    "}, {"ID": 1314, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Method> getMethodsFromGroupId(int groupId, String[] filters) throws Exception { ArrayList<Method> methods = new ArrayList<Method>(); PreparedStatement statement = null; ResultSet results = null; try (Connection sqlConnection = sqlService.getConnection()) { statement = sqlConnection.prepareStatement( \"SELECT * FROM \" + Constants.DB_TABLE_OVERRIDE + \" WHERE \" + Constants.OVERRIDE_GROUP_ID + \" = ?\" ); statement.setInt(1, groupId); results = statement.executeQuery(); while (results.next()) { Method method = PathOverrideService.getInstance().getMethodForOverrideId(results.getInt(\"id\")); if (method == null) { continue; } // decide whether or not to add this method based on the filters boolean add = true; if (filters != null) { add = false; for (String filter : filters) { if (method.getMethodType().endsWith(filter)) { add = true; break; } } } if (add && !methods.contains(method)) { methods.add(method); } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (results != null) { results.close(); } } catch (Exception e) { } try { if (statement != null) { statement.close(); } } catch (Exception e) { } } return methods; }\n\n    ### Response: Returns all methods for a specific group\n\n@param groupId group ID to remove methods from\n@param filters array of method types to filter by, null means no filter\n@return Collection of methods found\n@throws Exception exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected HashMap<String, PropertyDescriptor> inspectProperties() { boolean scanAccessible = classDescriptor.isScanAccessible(); Class type = classDescriptor.getType(); HashMap<String, PropertyDescriptor> map = new HashMap<>(); Method[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type); for (int iteration = 0; iteration < 2; iteration++) { // first find the getters, and then the setters! for (Method method : methods) { if (Modifier.isStatic(method.getModifiers())) { continue; // ignore static methods } boolean add = false; boolean issetter = false; String propertyName; if (iteration == 0) { propertyName = ClassUtil.getBeanPropertyGetterName(method); if (propertyName != null) { add = true; issetter = false; } } else { propertyName = ClassUtil.getBeanPropertySetterName(method); if (propertyName != null) { add = true; issetter = true; } } if (add) { MethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true); addProperty(map, propertyName, methodDescriptor, issetter); } } } if (classDescriptor.isIncludeFieldsAsProperties()) { FieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors(); String[] prefix = classDescriptor.getPropertyFieldPrefix(); for (FieldDescriptor fieldDescriptor : fieldDescriptors) { Field field = fieldDescriptor.getField(); if (Modifier.isStatic(field.getModifiers())) { continue; // ignore static fields } String name = field.getName(); if (prefix != null) { for (String p : prefix) { if (!name.startsWith(p)) { continue; } name = name.substring(p.length()); break; } } if (!map.containsKey(name)) { // add missing field as a potential property map.put(name, createPropertyDescriptor(name, fieldDescriptor)); } } } return map; }\n\n    ### Response:", "ground_truth": "Inspects all properties of target type.", "predict": " Inspects the class for properties and returns a map of property names to property descriptors.\n\n@return Map of property names to property descriptors\n@throws Exception exception."}, {"ID": 1315, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(String propertyName) { final PropertyDescriptor propertyDescriptor = findPropertyDescriptor(propertyName); if (propertyDescriptor == null) { throw new PropertyNotFoundException(beanClass, propertyName); } return propertyDescriptor; }\n\n    ### Response: Get the property descriptor for the named property. Throws an exception if the property does not exist.\n\n@param propertyName property name\n@return the PropertyDescriptor for the named property\n@throws PropertyNotFoundException if the named property does not exist on the bean\n@see #findPropertyDescriptor(String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor[] getAllPropertyDescriptors() { if (allProperties == null) { PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()]; int index = 0; for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) { allProperties[index] = propertyDescriptor; index++; } Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() { @Override public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) { return pd1.getName().compareTo(pd2.getName()); } }); this.allProperties = allProperties; } return allProperties; }\n\n    ### Response:", "ground_truth": "Returns all property descriptors.\nProperties are sorted by name.", "predict": " Get all property descriptors for the bean.\n\n@return an array of PropertyDescriptor objects describing all properties supported by the bean\n@see #getPropertyDescriptor(String)"}, {"ID": 1316, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Cookie[] convertCookies(HttpEntity<?> httpEntity) { final List<Cookie> cookies = new LinkedList<>(); List<String> inboundCookies = httpEntity.getHeaders().get(HttpHeaders.SET_COOKIE); if (inboundCookies != null) { for (String cookieString : inboundCookies) { Cookie cookie = convertCookieString(cookieString); cookies.add(cookie); } } return cookies.toArray(new Cookie[0]); }\n\n    ### Response: Converts cookies from a HttpEntity into Cookie objects\n@param httpEntity The message to convert\n@return A array of converted cookies.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Cookie[] cookies() { List<String> newCookies = headers(\"set-cookie\"); if (newCookies == null) { return new Cookie[0]; } List<Cookie> cookieList = new ArrayList<>(newCookies.size()); for (String cookieValue : newCookies) { try { Cookie cookie = new Cookie(cookieValue); cookieList.add(cookie); } catch (Exception ex) { // ignore } } return cookieList.toArray(new Cookie[0]); }\n\n    ### Response:", "ground_truth": "Returns list of valid cookies sent from server.\nIf no cookie found, returns an empty array. Invalid cookies are ignored.", "predict": " Extracts cookies from the headers of a response\n@return An array of cookies extracted from the headers of the response.\n\n    "}, {"ID": 1317, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getByteArrayDataAsString(String contentEncoding, byte[] bytes) { ByteArrayOutputStream byteout = null; if (contentEncoding != null && contentEncoding.equals(\"gzip\")) { // GZIP ByteArrayInputStream bytein = null; GZIPInputStream zis = null; try { bytein = new ByteArrayInputStream(bytes); zis = new GZIPInputStream(bytein); byteout = new ByteArrayOutputStream(); int res = 0; byte buf[] = new byte[1024]; while (res >= 0) { res = zis.read(buf, 0, buf.length); if (res > 0) { byteout.write(buf, 0, res); } } zis.close(); bytein.close(); byteout.close(); return byteout.toString(); } catch (Exception e) { // No action to take } } else if (contentEncoding != null && contentEncoding.equals(\"deflate\")) { try { // DEFLATE byte[] buffer = new byte[1024]; Inflater decompresser = new Inflater(); byteout = new ByteArrayOutputStream(); decompresser.setInput(bytes); while (!decompresser.finished()) { int count = decompresser.inflate(buffer); byteout.write(buffer, 0, count); } byteout.close(); decompresser.end(); return byteout.toString(); } catch (Exception e) { // No action to take } } return new String(bytes); }\n\n    ### Response: Decodes stream data based on content encoding\n@param contentEncoding\n@param bytes\n@return String representing the stream data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse unzip() { String contentEncoding = contentEncoding(); if (contentEncoding != null && contentEncoding().equals(\"gzip\")) { if (body != null) { headerRemove(HEADER_CONTENT_ENCODING); try { ByteArrayInputStream in = new ByteArrayInputStream(body.getBytes(StringPool.ISO_8859_1)); GZIPInputStream gzipInputStream = new GZIPInputStream(in); ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamUtil.copy(gzipInputStream, out); body(out.toString(StringPool.ISO_8859_1)); } catch (IOException ioex) { throw new HttpException(ioex); } } } return this; }\n\n    ### Response:", "ground_truth": "Unzips GZip-ed body content, removes the content-encoding header\nand sets the new content-length value.", "predict": " Unzips the response body based on content encoding\n@return The response object with unzipped body."}, {"ID": 1318, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Connection createHttpConnection(Dsn dsn) { URL sentryApiUrl = HttpConnection.getSentryApiUrl(dsn.getUri(), dsn.getProjectId()); String proxyHost = getProxyHost(dsn); String proxyUser = getProxyUser(dsn); String proxyPass = getProxyPass(dsn); int proxyPort = getProxyPort(dsn); Proxy proxy = null; if (proxyHost != null) { InetSocketAddress proxyAddr = new InetSocketAddress(proxyHost, proxyPort); proxy = new Proxy(Proxy.Type.HTTP, proxyAddr); if (proxyUser != null && proxyPass != null) { Authenticator.setDefault(new ProxyAuthenticator(proxyUser, proxyPass)); } } Double sampleRate = getSampleRate(dsn); EventSampler eventSampler = null; if (sampleRate != null) { eventSampler = new RandomEventSampler(sampleRate); } HttpConnection httpConnection = new HttpConnection(sentryApiUrl, dsn.getPublicKey(), dsn.getSecretKey(), proxy, eventSampler); Marshaller marshaller = createMarshaller(dsn); httpConnection.setMarshaller(marshaller); int timeout = getTimeout(dsn); httpConnection.setConnectionTimeout(timeout); boolean bypassSecurityEnabled = getBypassSecurityEnabled(dsn); httpConnection.setBypassSecurity(bypassSecurityEnabled); return httpConnection; }\n\n    ### Response: Creates an HTTP connection to the Sentry server.\n\n@param dsn Data Source Name of the Sentry server.\n@return an {@link HttpConnection} to the server..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse close() { HttpConnection httpConnection = httpRequest.httpConnection; if (httpConnection != null) { httpConnection.close(); httpRequest.httpConnection = null; } return this; }\n\n    ### Response:", "ground_truth": "Closes requests connection if it was open.\nShould be called when using keep-alive connections.\nOtherwise, connection will be already closed.", "predict": " Closes the HTTP connection associated with the request.\n\n@return the response object."}, {"ID": 1319, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final File file) { if (file != null) { if (file.isDirectory()) { return true; } final String extension = getExtension(file); if (extension != null && filters.containsKey(extension)) { return true; } } return false; }\n\n    ### Response: Return true if this file should be shown in the directory pane, false if it shouldn't.\n\nFiles that begin with \".\" are ignored.\n\n@return boolean\n@param file\nFile\n@see #getExtension\n@see javax.swing.filechooser.FileFilter#accept.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final Scope referenceScope) { Class<? extends Scope> refScopeType = referenceScope.getClass(); if (refScopeType == ProtoScope.class) { return true; } if (refScopeType == SingletonScope.class) { return true; } if (refScopeType == ThreadLocalScope.class) { return true; } return false; }\n\n    ### Response:", "ground_truth": "Defines allowed referenced scopes that can be injected into the\nthread-local scoped bean.", "predict": " Return true if this scope should be shown in the scope pane, false if it shouldn't.\n\n@return boolean\n@param referenceScope\nScope\n@see com.google.inject.Scope#getClass"}, {"ID": 1320, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void scan(final String targetPath, final String basePackageName, final String relativePackageName, final WildcardMatcher matcher, final SaveHandler saveHandler) { final File target = new File(targetPath); if (!target.exists()) { return; } target.listFiles(file -> { String fileName = file.getName(); if (file.isDirectory()) { String relativePackageName2; if (relativePackageName == null) { relativePackageName2 = fileName + ResourceUtils.REGULAR_FILE_SEPARATOR; } else { relativePackageName2 = relativePackageName + fileName + ResourceUtils.REGULAR_FILE_SEPARATOR; } String basePath2 = targetPath + fileName + ResourceUtils.REGULAR_FILE_SEPARATOR; scan(basePath2, basePackageName, relativePackageName2, matcher, saveHandler); } else if (fileName.endsWith(ClassUtils.CLASS_FILE_SUFFIX)) { String className; if (relativePackageName != null) { className = basePackageName + relativePackageName + fileName.substring(0, fileName.length() - ClassUtils.CLASS_FILE_SUFFIX.length()); } else { className = basePackageName + fileName.substring(0, fileName.length() - ClassUtils.CLASS_FILE_SUFFIX.length()); } String relativePath = className.substring(basePackageName.length()); if (matcher.matches(relativePath)) { String resourceName = targetPath + fileName; Class<?> targetClass = loadClass(className); saveHandler.save(resourceName, targetClass); } } return false; }); }\n\n    ### Response: Recursive method used to find all classes in a given directory and sub dirs.\n\n@param targetPath the target path\n@param basePackageName the base package name\n@param relativePackageName the relative package name\n@param matcher the matcher\n@param saveHandler the save handler.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void printRoutes(final int width) { final ActionsManager actionsManager = webApp.madvocContainer().lookupComponent(ActionsManager.class); final List<ActionRuntime> actions = actionsManager.getAllActionRuntimes(); final Map<String, String> aliases = actionsManager.getAllAliases(); if (actions.isEmpty()) { return; } final Print print = new Print(); print.line(\"Routes\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionMethod = ar.getActionMethod(); print.out(Chalk256.chalk().yellow(), actionMethod == null ? \"*\" : actionMethod, 7); print.space(); final String signature = ClassUtil.getShortClassName( ProxettaUtil.resolveTargetClass(ar.getActionClass()), 2) + '#' + ar.getActionClassMethod().getName(); print.outLeftRightNewLine( Chalk256.chalk().green(), ar.getActionPath(), Chalk256.chalk().blue(), signature, width - 7 - 1 ); }); if (!aliases.isEmpty()) { print.line(\"Aliases\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionPath = ar.getActionPath(); for (final Map.Entry<String, String> entry : aliases.entrySet()) { if (entry.getValue().equals(actionPath)) { print.space(8); print.outLeftRightNewLine( Chalk256.chalk().green(), entry.getValue(), Chalk256.chalk().blue(), entry.getKey(), width - 8 ); } } }); } print.line(width); }\n\n    ### Response:", "ground_truth": "Prints routes to console.", "predict": "Prints the routes and aliases of the application.\n\n@param width the width of the output."}, {"ID": 1321, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static byte[] numberToBytes(String number, int length, boolean bigEndian) { BigInteger bi = new BigInteger(number); byte[] bytes = bi.toByteArray(); int remaining = length - bytes.length; if (remaining < 0) { bytes = Arrays.copyOfRange(bytes, -remaining, bytes.length); } else { byte[] fill = new byte[remaining]; bytes = addAll(fill, bytes); } if (!bigEndian) { reverse(bytes); } return bytes; }\n\n    ### Response: Converts the given number to a binary representation of the specified\nlength and \"endian-ness\".\n\n@param number String with number to convert\n@param length How long the resulting binary array should be\n@param bigEndian true if big endian (5=0005), or\nfalse if little endian (5=5000)\n@return byte array containing the binary result in the given order.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] encrypt(final byte[] content) { FastByteBuffer fbb = new FastByteBuffer(); int length = content.length + 1; int blockCount = length / blockSizeInBytes; int remaining = length; int offset = 0; for (int i = 0; i < blockCount; i++) { if (remaining == blockSizeInBytes) { break; } byte[] encrypted = encryptBlock(content, offset); fbb.append(encrypted); offset += blockSizeInBytes; remaining -= blockSizeInBytes; } if (remaining != 0) { // process remaining bytes byte[] block = new byte[blockSizeInBytes]; System.arraycopy(content, offset, block, 0, remaining - 1); block[remaining - 1] = TERMINATOR; byte[] encrypted = encryptBlock(block, 0); fbb.append(encrypted); } return fbb.toArray(); }\n\n    ### Response:", "ground_truth": "Encrypts complete content, block by block.", "predict": " Encrypts the given content using the specified block size and encryption algorithm.\n\n@param content byte array containing the content to encrypt\n@return byte array containing the encrypted content\n\n    "}, {"ID": 1322, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static public byte[] readValue(ObjectInput in, int len) throws IOException { int bytesRead = 0; byte[] data = new byte[len]; for (int offset = 0; offset < len; offset += bytesRead) { bytesRead = in.read(data, offset, len - offset); if (bytesRead == -1) { throw new IOException(\"Could not retrieve \"); } } return data; }\n\n    ### Response: Encapsulate the logic to read an entire byte array from the input stream.\n\n@param in\n@param len\n@return new array read from stream\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] decrypt(final byte[] encryptedContent) { FastByteBuffer fbb = new FastByteBuffer(); int length = encryptedContent.length; int blockCount = length / blockSizeInBytes; int offset = 0; for (int i = 0; i < blockCount - 1; i++) { byte[] decrypted = decryptBlock(encryptedContent, offset); fbb.append(decrypted); offset += blockSizeInBytes; } // process last block byte[] decrypted = decryptBlock(encryptedContent, offset); // find terminator int ndx = blockSizeInBytes - 1; while (ndx >= 0) { if (decrypted[ndx] == TERMINATOR) { break; } ndx--; } fbb.append(decrypted, 0, ndx); return fbb.toArray(); }\n\n    ### Response:", "ground_truth": "Decrypts the whole content, block by block.", "predict": " Decrypt the encrypted content using the specified block size.\n\n@param encryptedContent\n@return decrypted content as byte array.\n\n    "}, {"ID": 1323, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getBean(Token token) { Object value; if (token.getAlternativeValue() != null) { if (token.getDirectiveType() == TokenDirectiveType.FIELD) { Field field = (Field)token.getAlternativeValue(); if (Modifier.isStatic(field.getModifiers())) { value = ReflectionUtils.getField(field, null); } else { Class<?> cls = field.getDeclaringClass(); Object target = activity.getBean(cls); value = ReflectionUtils.getField(field, target); } } else if (token.getDirectiveType() == TokenDirectiveType.METHOD) { Method method = (Method)token.getAlternativeValue(); if (Modifier.isStatic(method.getModifiers())) { value = ReflectionUtils.invokeMethod(method, null); } else { Class<?> cls = method.getDeclaringClass(); Object target = activity.getBean(cls); value = ReflectionUtils.invokeMethod(method, target); } } else { Class<?> cls = (Class<?>)token.getAlternativeValue(); try { value = activity.getBean(cls); } catch (RequiredTypeBeanNotFoundException | NoUniqueBeanException e) { if (token.getGetterName() != null) { try { value = BeanUtils.getProperty(cls, token.getGetterName()); if (value == null) { value = token.getDefaultValue(); } return value; } catch (InvocationTargetException e2) { // ignore } } throw e; } if (value != null && token.getGetterName() != null) { value = getBeanProperty(value, token.getGetterName()); } } } else { value = activity.getBean(token.getName()); if (value != null && token.getGetterName() != null) { value = getBeanProperty(value, token.getGetterName()); } } if (value == null) { value = token.getDefaultValue(); } return value; }\n\n    ### Response: Returns the bean instance that matches the given token.\n\n@param token the token\n@return an instance of the bean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object map2bean(final Map map, Class targetType) { Object target = null; // create targets type String className = (String) map.get(classMetadataName); if (className == null) { if (targetType == null) { // nothing to do, no information about target type found target = map; } } else { checkClassName(jsonParser.classnameWhitelist, className); try { targetType = ClassLoaderUtil.loadClass(className); } catch (ClassNotFoundException cnfex) { throw new JsonException(cnfex); } } if (target == null) { target = jsonParser.newObjectInstance(targetType); } ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); boolean targetIsMap = target instanceof Map; for (Object key : map.keySet()) { String keyName = key.toString(); if (classMetadataName != null) { if (keyName.equals(classMetadataName)) { continue; } } PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared); if (!targetIsMap && pd == null) { // target property does not exist, continue continue; } // value is one of JSON basic types, like Number, Map, List... Object value = map.get(key); Class propertyType = pd == null ? null : pd.getType(); Class componentType = pd == null ? null : pd.resolveComponentType(true); if (value != null) { if (value instanceof List) { if (componentType != null && componentType != String.class) { value = generifyList((List) value, componentType); } } else if (value instanceof Map) { // if the value we want to inject is a Map... if (!ClassUtil.isTypeOf(propertyType, Map.class)) { // ... and if target is NOT a map value = map2bean((Map) value, propertyType); } else { // target is also a Map, but we might need to generify it Class keyType = pd == null ? null : pd.resolveKeyType(true); if (keyType != String.class || componentType != String.class) { // generify value = generifyMap((Map) value, keyType, componentType); } } } } if (targetIsMap) { ((Map)target).put(keyName, value); } else { try { setValue(target, pd, value); } catch (Exception ignore) { ignore.printStackTrace(); } } } return target; }\n\n    ### Response:", "ground_truth": "Converts map to target type.", "predict": " Maps the given map to a new instance of the given target type.\n\n@param map the map to map\n@param targetType the target type to map to\n@return a new instance of the target type with the values from the map mapped to its properties."}, {"ID": 1324, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object setAssemblageValue(Class assemblageType, Object assemblage, Object index, Object value) { if (assemblageType.isArray()) { int i = ((Integer) index).intValue(); if (Array.getLength(assemblage) <= i) { Object newAssemblage = Array.newInstance(assemblageType.getComponentType(), i + 1); System.arraycopy(assemblage, 0, newAssemblage, 0, Array.getLength(assemblage)); assemblage = newAssemblage; } Array.set(assemblage, i, value); } else if (List.class.isAssignableFrom(assemblageType)) { int i = ((Integer) index).intValue(); List list = (List) assemblage; if (list.size() > i) { list.set(i, value); } else { while (list.size() < i) { list.add(null); } list.add(value); } } else if (Map.class.isAssignableFrom(assemblageType)) { ((Map) assemblage).put(index, value); } else if (assemblage instanceof Collection) { ((Collection) assemblage).add(value); } else { throw new IllegalArgumentException(\"assemblage must be of type array, collection or map.\"); } return assemblage; }\n\n    ### Response: Helper method for subclasses to set values of indexed properties, like\nmap-values, collection-values or array-values.\n\n@param assemblageType either map or collection or array\n@param assemblage the assemblage to set the value on\n@param index the index to set the value at\n@param value the value to set\n@return the assemblage.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object generifyList(final List list, final Class componentType) { for (int i = 0; i < list.size(); i++) { Object element = list.get(i); if (element != null) { if (element instanceof Map) { Object bean = map2bean((Map) element, componentType); list.set(i, bean); } else { Object value = convert(element, componentType); list.set(i, value); } } } return list; }\n\n    ### Response:", "ground_truth": "Converts type of all list elements to match the component type.", "predict": " Helper method for subclasses to generify a list of objects.\n\n@param list the list to generify\n@param componentType the type of the elements in the list\n@return the generified list.\n\n    "}, {"ID": 1325, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void typeCheckFieldSet(Field field, Object value) throws IllegalAccessException { Class<?> fieldType = field.getType(); if (value == null) { if (fieldType.isPrimitive()) { throw Exceptions.illegalSetFieldTypeException(field, null, value); } } else { if (fieldType.isPrimitive()) { fieldType = boxTypeFor(fieldType); } Class<?> valueType = value.getClass(); if (!Utils.isConvertableFrom(fieldType, valueType)) { throw Exceptions.illegalSetFieldTypeException(field, valueType, value); } } }\n\n    ### Response: Perform a dynamic type check needed when setting a field value onto a field. Raises the appropriate exception\nwhen the check fails and returns normally otherwise. This method should only be called for object types. For\nprimitive types call the three parameter variant instead.\n\n@throws IllegalAccessException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException { Class propertyType; Setter setter = pd.getSetter(true); if (setter != null) { if (value != null) { propertyType = setter.getSetterRawType(); value = jsonParser.convertType(value, propertyType); } setter.invokeSetter(target, value); } }\n\n    ### Response:", "ground_truth": "Sets the property value.", "predict": " Sets the value of a property on the target object using the provided property descriptor. The value is first\nconverted to the appropriate type using the JSON parser. If the property has a setter method, it is invoked with the\nconverted value. If the setter method is not found, an exception is thrown.\n\n@param target The object on which to set the property value.\n@param pd The property descriptor for the property to set.\n@param value The value to set on the property.\n@throws InvocationTargetException If the setter method throws an exception.\n@throws IllegalAccessException If the setter method is not accessible."}, {"ID": 1326, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <K, V> Map<K, V> copy(final Map<K, V> map) { if (map == null) { return null; } TypeEnum keyType = null; TypeEnum valueType = null; Map<K, V> copy = new HashMap<K, V>(); for (Map.Entry<K, V> entry : map.entrySet()) { K key = entry.getKey(); V value = entry.getValue(); K keyCopy = null; if (key != null) { if (keyType == null) { keyType = TypeEnum.dataTypeOf(key.getClass()); } keyCopy = copy(key, keyType); } V valueCopy = null; if (value != null) { if (valueType == null) { valueType = TypeEnum.dataTypeOf(value.getClass()); } valueCopy = copy(value, valueType); } copy.put(keyCopy, valueCopy); } return copy; }\n\n    ### Response: Returns a deep copy of a pdef map..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) { if (keyType == String.class) { // only value type is changed, we can make value replacements for (Map.Entry<Object, Object> entry : map.entrySet()) { Object value = entry.getValue(); Object newValue = convert(value, valueType); if (value != newValue) { entry.setValue(newValue); } } return (Map<K, V>) map; } // key is changed too, we need a new map Map<K, V> newMap = new HashMap<>(map.size()); for (Map.Entry<Object, Object> entry : map.entrySet()) { Object key = entry.getKey(); Object newKey = convert(key, keyType); Object value = entry.getValue(); Object newValue = convert(value, valueType); newMap.put((K)newKey, (V)newValue); } return newMap; }\n\n    ### Response:", "ground_truth": "Change map elements to match key and value types.", "predict": " Converts a map to a generic map with the specified key and value types.\n\n    "}, {"ID": 1327, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compareTo(final FastZipEntry o) { final int diff0 = o.version - this.version; if (diff0 != 0) { return diff0; } final int diff1 = entryNameUnversioned.compareTo(o.entryNameUnversioned); if (diff1 != 0) { return diff1; } final int diff2 = entryName.compareTo(o.entryName); if (diff2 != 0) { return diff2; } // In case of multiple entries with the same entry name, return them in consecutive order of location, // so that the earliest entry overrides later entries (this is an arbitrary decision for consistency) final long diff3 = locHeaderPos - o.locHeaderPos; return diff3 < 0L ? -1 : diff3 > 0L ? 1 : 0; }\n\n    ### Response: Sort in decreasing order of version number, then lexicographically increasing order of unversioned entry\npath.\n\n@param o\nthe object to compare to\n@return the result of comparison.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compareTo(final Object o) { DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o; if (this.isId != that.isId) { return this.isId ? -1 : 1; // IDs should be the first in the array } return this.columnName.compareTo(that.columnName); }\n\n    ### Response:", "ground_truth": "Compares two column descriptors. Identity columns should be the first on the list.\nEach group then will be sorted by column name.", "predict": " Compare two DbEntityColumnDescriptor objects based on their column name and whether they are IDs or not.\n\n@param o\nthe object to compare to\n@return the result of comparison."}, {"ID": 1328, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Processor setProperty(final String name, final String value) { args.put(name, value); return this; }\n\n    ### Response: Set property. Existing property mapping will be overridden.\n\n@param name property name\n@param value property value\n@return this Process object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; }\n\n    ### Response:", "ground_truth": "Adds default header to all requests.", "predict": " Set default header. Existing header mapping will be overridden.\n\n@param name header name\n@param value header value\n@return this HttpBrowser object."}, {"ID": 1329, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String executeScriptExecuteRequest(String rScript) throws IOException { URI uri = getScriptExecutionUri(); HttpPost httpPost = new HttpPost(uri); NameValuePair nameValuePair = new BasicNameValuePair(\"x\", rScript); httpPost.setEntity(new UrlEncodedFormEntity(singletonList(nameValuePair))); String openCpuSessionKey; try (CloseableHttpResponse response = httpClient.execute(httpPost)) { int statusCode = response.getStatusLine().getStatusCode(); if (statusCode >= 200 && statusCode < 300) { Header openCpuSessionKeyHeader = response.getFirstHeader(\"X-ocpu-session\"); if (openCpuSessionKeyHeader == null) { throw new IOException(\"Missing 'X-ocpu-session' header\"); } openCpuSessionKey = openCpuSessionKeyHeader.getValue(); EntityUtils.consume(response.getEntity()); } else if (statusCode == 400) { HttpEntity entity = response.getEntity(); String rErrorMessage = EntityUtils.toString(entity); EntityUtils.consume(entity); throw new ScriptException(rErrorMessage); } else { throw new ClientProtocolException(format(FORMAT_UNEXPECTED_RESPONSE_STATUS, statusCode)); } } return openCpuSessionKey; }\n\n    ### Response: Execute R script using OpenCPU\n\n@param rScript R script\n@return OpenCPU session key\n@throws IOException if error occured during script execution request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse sendRequest(HttpRequest httpRequest) { elapsedTime = System.currentTimeMillis(); // send request httpRequest.followRedirects(false); while (true) { this.httpRequest = httpRequest; HttpResponse previousResponse = this.httpResponse; this.httpResponse = null; addDefaultHeaders(httpRequest); addCookies(httpRequest); // send request if (catchTransportExceptions) { try { this.httpResponse = _sendRequest(httpRequest, previousResponse); } catch (HttpException httpException) { httpResponse = new HttpResponse(); httpResponse.assignHttpRequest(httpRequest); httpResponse.statusCode(503); httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException)); } } else { this.httpResponse =_sendRequest(httpRequest, previousResponse); } readCookies(httpResponse); int statusCode = httpResponse.statusCode(); // 301: moved permanently if (statusCode == 301) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 302: redirect, 303: see other if (statusCode == 302 || statusCode == 303) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 307: temporary redirect, 308: permanent redirect if (statusCode == 307 || statusCode == 308) { String newPath = httpResponse.location(); if (newPath == null) { break; } String originalMethod = httpRequest.method(); httpRequest = new HttpRequest() .method(originalMethod) .set(newPath); continue; } break; } elapsedTime = System.currentTimeMillis() - elapsedTime; return this.httpResponse; }\n\n    ### Response:", "ground_truth": "Sends new request as a browser. Before sending,\nall browser cookies are added to the request.\nAfter sending, the cookies are read from the response.\nMoreover, status codes 301 and 302 are automatically\nhandled. Returns very last response.", "predict": " Send an HTTP request and receive an HTTP response.\n\n@param httpRequest HTTP request\n@return HTTP response\n@throws IOException if error occured during request/response processing."}, {"ID": 1330, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final HttpResponse executeUnparsed() throws IOException { // must set clientAuthentication as last execute interceptor in case it needs to sign request HttpRequestFactory requestFactory = transport.createRequestFactory(new HttpRequestInitializer() { public void initialize(HttpRequest request) throws IOException { if (requestInitializer != null) { requestInitializer.initialize(request); } final HttpExecuteInterceptor interceptor = request.getInterceptor(); request.setInterceptor(new HttpExecuteInterceptor() { public void intercept(HttpRequest request) throws IOException { if (interceptor != null) { interceptor.intercept(request); } if (clientAuthentication != null) { clientAuthentication.intercept(request); } } }); } }); // make request HttpRequest request = requestFactory.buildPostRequest(tokenServerUrl, new UrlEncodedContent(this)); request.setParser(new JsonObjectParser(jsonFactory)); request.setThrowExceptionOnExecuteError(false); HttpResponse response = request.execute(); if (response.isSuccessStatusCode()) { return response; } throw TokenResponseException.from(jsonFactory, response); }\n\n    ### Response: Executes request for an access token, and returns the HTTP response.\n\n\nTo execute and parse the response to {@link TokenResponse}, instead use {@link #execute()}.\n\n\n\nCallers should call {@link HttpResponse#disconnect} when the returned HTTP response object is\nno longer needed. However, {@link HttpResponse#disconnect} does not have to be called if the\nresponse stream is properly closed. Example usage:\n\n\n\nHttpResponse response = tokenRequest.executeUnparsed();\ntry {\nprocess the HTTP response object\n} finally {\nresponse.disconnect();\n}\n\n\n@return successful access token response, which can then be parsed directly using\n{@link HttpResponse#parseAs(Class)} or some other parsing method\n@throws TokenResponseException for an error response.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) { if (!keepAlive) { httpRequest.open(httpConnectionProvider); } else { // keeping alive if (previouseResponse == null) { httpRequest.open(httpConnectionProvider).connectionKeepAlive(true); } else { httpRequest.keepAlive(previouseResponse, true); } } return httpRequest.send(); }\n\n    ### Response:", "ground_truth": "Opens connection and sends a response.", "predict": "Sends the given HTTP request and returns the HTTP response.\n\n\nIf the HTTP connection is not kept alive, the request will be sent over a new HTTP connection.\nIf the HTTP connection is kept alive, the request will be sent over the same HTTP connection as the previous response.\n\n\n@param httpRequest the HTTP request to send\n@param previouseResponse the previous HTTP response, or null if this is the first request\n@return the HTTP response\n@throws IOException if an I/O error occurs while sending the request or receiving the response"}, {"ID": 1331, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<String, String> getMetatags() { Map<String, String> result = new HashMap<>(); for (Map.Entry<String, String> entry : _metatags.entrySet()) { String key = entry.getKey(); if (!ReservedField.isReservedField(key)) { result.put(key, entry.getValue()); } } return Collections.unmodifiableMap(result); }\n\n    ### Response: Returns an unmodifiable collection of metatags associated with the metric.\n\n@return  The metatags for a metric. Will never be null but may be empty..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addDefaultHeaders(final HttpRequest httpRequest) { for (Map.Entry<String, String> entry : defaultHeaders.entries()) { String name = entry.getKey(); if (!httpRequest.headers.contains(name)) { httpRequest.headers.add(name, entry.getValue()); } } }\n\n    ### Response:", "ground_truth": "Add default headers to the request. If request already has a header set,\ndefault header will be ignored.", "predict": " Adds the default headers to the given HTTP request.\n\n@param httpRequest  The HTTP request to add the default headers to."}, {"ID": 1332, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String cookie(String name) { Cookie[] cookies = servletRequest.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equals(name)) { return cookie.getValue(); } } } return null; }\n\n    ### Response: Gets cookie by name.\n\n@param name name of the cookie\n@return cookie value or null if the cookie was not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void readCookies(final HttpResponse httpResponse) { Cookie[] newCookies = httpResponse.cookies(); for (Cookie cookie : newCookies) { cookies.add(cookie.getName(), cookie); } }\n\n    ### Response:", "ground_truth": "Reads cookies from response and adds to cookies list.", "predict": " Reads cookies from the HTTP response and adds them to the cookies map.\n\n@param httpResponse HTTP response containing cookies to be added to the cookies map."}, {"ID": 1333, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static List<Cookie> parseCookieHeader(String host, String cookieHeaderValue) { if (StringUtils.isEmpty(cookieHeaderValue)){ return Collections.emptyList(); } String[] cookies = cookieHeaderValue.split(\";\"); List<Cookie> cookiesList = new ArrayList<Cookie>(); for (String cookie : cookies){ String[] parts = cookie.split(\"=\"); //manage empty value if (parts.length==1) { cookiesList.add(new Cookie(host,parts[0].trim(),\"\")); }else{ cookiesList.add(new Cookie(host,parts[0].trim(),parts[1].trim())); } } return cookiesList; }\n\n    ### Response: Parse a cookie header to return a list of cookies.\n\nUnfortunatly the method Header.getElements() is not working properly.\nOn a line like Cookie: has-js=1; drupal-toolbar=off it only returns the\nfirst element has-js=1. So we rework this one.\n\nThis is a \"won't fix\" known issue as the project ended.\nhttps://issues.apache.org/jira/browse/HTTPCLIENT-1356\n\n@param host the host used to build the query, functionally not useful as we are on the client side of the proxy but the host is required by the constructor of the Cookie object\n@param cookieHeaderValue the string value of the cookie header, the part of the string after \"Cookie: \"\n@return a list of cookies corresponding to the list of name/value found in cookieHeaderValue.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addCookies(final HttpRequest httpRequest) { // prepare all cookies List<Cookie> cookiesList = new ArrayList<>(); if (!cookies.isEmpty()) { for (Map.Entry<String, Cookie> cookieEntry : cookies) { cookiesList.add(cookieEntry.getValue()); } httpRequest.cookies(cookiesList.toArray(new Cookie[0])); } }\n\n    ### Response:", "ground_truth": "Add cookies to the request.", "predict": " Add all cookies to the request.\n\n@param httpRequest the request to add the cookies to."}, {"ID": 1334, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MimeMessage createMimeMessage(Session session) throws MessagingException { if (isEmpty(htmlPart) && isEmpty(textPart)) { throw new IllegalArgumentException(\"Missing email content\"); } final MimeMessage msg = new MimeMessage(session); msg.setSubject(subject); msg.setFrom(new InternetAddress(from)); msg.setContent(createMultiPart()); msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients, false)); return msg; }\n\n    ### Response: Creates a MimeMessage containing given Multipart.\nSubject, sender and content and session will be set.\n@param session current mail session\n@return MimeMessage without recipients\n@throws MessagingException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String sendMail(final Email email) { try { final MimeMessage msg = createMessage(email); getService().sendMessage(msg, msg.getAllRecipients()); return msg.getMessageID(); } catch (final MessagingException msgexc) { throw new MailException(\"Failed to send email: \" + email, msgexc); } }\n\n    ### Response:", "ground_truth": "Prepares message and sends it. Returns Message ID of sent email.\n\n@param email {@link Email} to send.\n@return String representing message ID.", "predict": " Sends an email using the given Email object.\n@param email Email object containing all necessary information for sending an email\n@return Message ID of the sent email\n@throws MailException if there is an error sending the email\n\n    "}, {"ID": 1335, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MimeMessage createMimeMessage(Session session) throws MessagingException { if (isEmpty(htmlPart) && isEmpty(textPart)) { throw new IllegalArgumentException(\"Missing email content\"); } final MimeMessage msg = new MimeMessage(session); msg.setSubject(subject); msg.setFrom(new InternetAddress(from)); msg.setContent(createMultiPart()); msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients, false)); return msg; }\n\n    ### Response: Creates a MimeMessage containing given Multipart.\nSubject, sender and content and session will be set.\n@param session current mail session\n@return MimeMessage without recipients\n@throws MessagingException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setSubject(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { if (emailWithData.subjectEncoding() != null) { msgToSet.setSubject(emailWithData.subject(), emailWithData.subjectEncoding()); } else { msgToSet.setSubject(emailWithData.subject()); } }\n\n    ### Response:", "ground_truth": "Sets subject in msgToSet from subject in emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Sets the subject of the given MimeMessage with the given Email object.\n@param emailWithData Email object containing subject and subject encoding\n@param msgToSet MimeMessage to set subject\n@throws MessagingException."}, {"ID": 1336, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Date determineStartDate(VAlarm valarm, ICalComponent parent) { Trigger trigger = valarm.getTrigger(); if (trigger == null) { return null; } Date triggerStart = trigger.getDate(); if (triggerStart != null) { return triggerStart; } Duration triggerDuration = trigger.getDuration(); if (triggerDuration == null) { return null; } if (parent == null) { return null; } Related related = trigger.getRelated(); Date date = null; if (related == Related.START) { date = ValuedProperty.getValue(parent.getProperty(DateStart.class)); } else if (related == Related.END) { date = ValuedProperty.getValue(parent.getProperty(DateEnd.class)); if (date == null) { Date dateStart = ValuedProperty.getValue(parent.getProperty(DateStart.class)); Duration duration = ValuedProperty.getValue(parent.getProperty(DurationProperty.class)); if (duration != null && dateStart != null) { date = duration.add(dateStart); } } } return (date == null) ? null : triggerDuration.add(date); }\n\n    ### Response: Determines what the alarm property's start date should be.\n@param valarm the component that is being converted to a vCal alarm\nproperty\n@param parent the component's parent\n@return the start date or null if it cannot be determined.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setSentDate(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { Date date = emailWithData.sentDate(); if (date == null) { date = new Date(); } msgToSet.setSentDate(date); }\n\n    ### Response:", "ground_truth": "Sets sent date in msgToSet with sent date from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Sets the sent date of the given email message to the given date.\n@param emailWithData the email message to set the sent date for\n@param msgToSet the message to set the sent date on\n@throws MessagingException if there is an error setting the sent date on the message\n\n    "}, {"ID": 1337, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, String> performMapping(final Map<String, String> input, final Map<String, String> mapping, final boolean skip) { final Map<String, String> props = new HashMap<String, String>(); for (final Map.Entry<String, String> entry : input.entrySet()) { if (null != mapping.get(entry.getKey())) { props.put(mapping.get(entry.getKey()), entry.getValue()); } else if(!skip) { props.put(entry.getKey(), entry.getValue()); } } return props; }\n\n    ### Response: Convert input keys via the supplied mapping.\n@param input data\n@param mapping map to convert key names\n@param skip if true, ignore input entries when the key is not present in the mapping.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setHeaders(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final Map<String, String> headers = emailWithData.headers(); if (headers != null) { for (final Map.Entry<String, String> entry : headers.entrySet()) { msgToSet.setHeader(entry.getKey(), entry.getValue()); } } }\n\n    ### Response:", "ground_truth": "Sets headers in msgToSet with headers from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Set the headers of the email message.\n@param emailWithData email with headers to set\n@param msgToSet message to set headers on"}, {"ID": 1338, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MimeMessage createMimeMessage(Session session) throws MessagingException { if (isEmpty(htmlPart) && isEmpty(textPart)) { throw new IllegalArgumentException(\"Missing email content\"); } final MimeMessage msg = new MimeMessage(session); msg.setSubject(subject); msg.setFrom(new InternetAddress(from)); msg.setContent(createMultiPart()); msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients, false)); return msg; }\n\n    ### Response: Creates a MimeMessage containing given Multipart.\nSubject, sender and content and session will be set.\n@param session current mail session\n@return MimeMessage without recipients\n@throws MessagingException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { msgToSet.setFrom(emailWithData.from().toInternetAddress()); msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo())); setRecipients(emailWithData, msgToSet); }\n\n    ### Response:", "ground_truth": "Sets FROM, REPLY-TO and recipients.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Sets the From, ReplyTo and Recipients of the given MimeMessage based on the given Email object.\n@param emailWithData Email object containing From, ReplyTo and Recipients\n@param msgToSet MimeMessage object to set the From, ReplyTo and Recipients\n@throws MessagingException."}, {"ID": 1339, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static InternetAddress[] add(InternetAddress[] oldArr, InternetAddress newValue) { if (oldArr == null) return new InternetAddress[] { newValue }; // else { InternetAddress[] tmp = new InternetAddress[oldArr.length + 1]; for (int i = 0; i < oldArr.length; i++) { tmp[i] = oldArr[i]; } tmp[oldArr.length] = newValue; return tmp; // } }\n\n    ### Response: creates a new expanded array and return it;\n\n@param oldArr\n@param newValue\n@return new expanded array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setRecipients(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { // TO final InternetAddress[] to = EmailAddress.convert(emailWithData.to()); if (to.length > 0) { msgToSet.setRecipients(RecipientType.TO, to); } // CC final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc()); if (cc.length > 0) { msgToSet.setRecipients(RecipientType.CC, cc); } // BCC final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc()); if (bcc.length > 0) { msgToSet.setRecipients(RecipientType.BCC, bcc); } }\n\n    ### Response:", "ground_truth": "Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": " sets the recipients of the email message based on the given email object.\n\n@param emailWithData\n@param msgToSet\n@throws MessagingException\n\n    "}, {"ID": 1340, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setMimeContent(Email email, MimeMessage mimeMsg) throws MessagingException, ContentHandlerException, AttachmentResourceHandlerException { LOG.debug(\"Add message content for email {}\", email); // create the root as mixed MimeMultipart rootContainer = new MimeMultipart(\"mixed\"); // create the container in case of attachments MimeMultipart relatedContainer = new MimeMultipart(\"related\"); MimeBodyPart relatedPart = new MimeBodyPart(); relatedPart.setContent(relatedContainer); // delegate content management to specialized classes contentHandler.setContent(mimeMsg, relatedContainer, email, email.getContent()); // add attachments to the root or the related container according to the // disposition (inline or attached) for (Attachment attachment : email.getAttachments()) { Multipart container = ContentDisposition.ATTACHMENT.equals(attachment.getDisposition()) ? rootContainer : relatedContainer; addAttachment(container, attachment); } // if no attachments (only text) then root is changed to point on // related container if (email.getAttachments().isEmpty()) { // if no attachments and several parts => set part type to // alternative instead of related // if no attachments and one part => set part type to mixed instead // of related rootContainer = relatedContainer; if (relatedContainer.getCount() == 1) { rootContainer.setSubType(\"mixed\"); } else { rootContainer.setSubType(\"alternative\"); } } else { // there are attachments so add the related part to the root rootContainer.addBodyPart(relatedPart); } mimeMsg.setContent(rootContainer); }\n\n    ### Response: Set the content on the mime message.\n\n\nIf the source email has several contents (for example text and html) and\nattachments (with attachment content disposition), the mime message looks\nlike:\n\n\nmixed\nrelated\nalternative\n[text/plain] text message\n[text/html] html message\nattachment 1\nattachment 2\n\n\n\nIf the source email has several contents (for example text and html) but\nno attachments, the mime message looks like:\n\n\nalternative\n[text/plain] text message\n[text/html] html message\n\n\n\nIf the source email has only one content (for example html) and\nattachments (with attachment content disposition), the mime message looks\nlike:\n\n\nmixed\nrelated\n[text/html] html message\nattachment 1\nattachment 2\n\n\n\nIf the source email has only one content (for example html) and no\nattachment, the mime message looks like:\n\n\nmixed\n[text/html] html message\n\n\n@param email\nthe source email\n@param mimeMsg\nthe mime message to fill\n@throws MessagingException\nwhen the email address is not valid\n@throws ContentHandlerException\nwhen the email address is not valid\n@throws AttachmentResourceHandlerException\nwhen the email address is not valid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addBodyData(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final List<EmailMessage> messages = emailWithData.messages(); final int totalMessages = messages.size(); // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List final List<EmailAttachment<? extends DataSource>> attachments = new ArrayList<>(emailWithData.attachments()); if (attachments.isEmpty() && totalMessages == 1) { // special case: no attachments and just one content setContent(messages.get(0), msgToSet); } else { final MimeMultipart multipart = new MimeMultipart(); final MimeMultipart msgMultipart = new MimeMultipart(ALTERNATIVE); multipart.addBodyPart(getBaseBodyPart(msgMultipart)); for (final EmailMessage emailMessage : messages) { msgMultipart.addBodyPart(getBodyPart(emailMessage, attachments)); } addAnyAttachments(attachments, multipart); msgToSet.setContent(multipart); } }\n\n    ### Response:", "ground_truth": "Adds message data and attachments.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": " Add the email data to the mime message.\n\n\nIf the email has several contents (for example text and html) and\nattachments (with attachment content disposition), the mime message looks\nlike:\n\n\nmultipart/mixed\nalternative\n[text/plain] text message\n[text/html] html message\nattachment 1\nattachment 2\n\n\n\nIf the email has several contents (for example text and html) but no\nattachments, the mime message looks like:\n\n\nmultipart/alternative\n[text/plain] text message\n[text/html] html message\n\n\n\nIf the email has only one content (for example html) and attachments\n(with attachment content disposition), the mime message looks like:\n\n\nmultipart/mixed\nrelated\n[text/html] html message\nattachment 1\nattachment 2\n\n\n\nIf the email has only one content (for example html) and no\nattachment, the mime message looks like:\n\n\nmultipart/mixed\n[text/html] html message\n\n\n\n@param emailWithData"}, {"ID": 1341, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void setContent(final Object content, final String type) throws MessagingException { charset = EmailExtensions.getCharsetFromContentType(type); super.setContent(content, type); }\n\n    ### Response: Sets the content.\n\n@param content\nthe content\n@param type\nthe type\n@throws MessagingException\nis thrown if the underlying implementation does not support modification of\nexisting values\n\n@see javax.mail.Part#setContent(java.lang.Object, java.lang.String).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setContent(final EmailMessage emailWithData, final Part partToSet) throws MessagingException { partToSet.setContent(emailWithData.getContent(), emailWithData.getMimeType() + CHARSET + emailWithData.getEncoding()); }\n\n    ### Response:", "ground_truth": "Sets emailWithData content into msgToSet.\n\n@param emailWithData {@link EmailMessage} with data.\n@param partToSet     {@link Part} to set data into.\n@throws MessagingException if there is a failure.", "predict": " Sets the content of the given part.\n\n@param emailWithData\nthe email with data to set\n@param partToSet\nthe part to set\n@throws MessagingException\nis thrown if the underlying implementation does not support modification of\nexisting values\n\n@see javax.mail.Part#setContent(java.lang.Object, java.lang.String)."}, {"ID": 1342, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MimeBodyPart newHtmlAttachmentBodyPart( URL contentUrl, String contentId ) throws MessagingException { MimeBodyPart mimeBodyPart = new MimeBodyPart(); mimeBodyPart.setDataHandler(new DataHandler(contentUrl)); if( contentId != null ) { mimeBodyPart.setHeader(\"Content-ID\", contentId); } return mimeBodyPart; }\n\n    ### Response: Creates a body part for an attachment that is used by an html body part..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MimeBodyPart createAttachmentBodyPart(final EmailAttachment<? extends DataSource> attachment) throws MessagingException { final MimeBodyPart part = new MimeBodyPart(); final String attachmentName = attachment.getEncodedName(); if (attachmentName != null) { part.setFileName(attachmentName); } part.setDataHandler(new DataHandler(attachment.getDataSource())); if (attachment.getContentId() != null) { part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV); } if (attachment.isInline()) { part.setDisposition(INLINE); } return part; }\n\n    ### Response:", "ground_truth": "Creates attachment body part. Handles regular and inline attachments.\n\n@param attachment Body part {@link EmailAttachment}.\n@return {@link MimeBodyPart} which represents body part attachment.\n@throws MessagingException if there is a failure.", "predict": " Creates a MimeBodyPart for an attachment.\n\n    "}, {"ID": 1343, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getDeepestNestedElementName(String configDisplayId) { int start = configDisplayId.lastIndexOf(\"]/\"); if (start > 1) { int end = configDisplayId.indexOf('[', start += 2); if (end > start) return configDisplayId.substring(start, end); } return null; }\n\n    ### Response: Returns the most deeply nested element name.\n\n@param configDisplayId config.displayId\n@return the most deeply nested element name. Null if there are not any nested elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getContentType(final String dataHeader) { String token = \"Content-Type:\"; int start = dataHeader.indexOf(token); if (start == -1) { return StringPool.EMPTY; } start += token.length(); return dataHeader.substring(start).trim(); }\n\n    ### Response:", "ground_truth": "Strips content type information from requests data header.\n@param dataHeader data header string\n@return content type or an empty string if no content type defined", "predict": " Returns the content type of the given data header.\n\n@param dataHeader the data header to extract the content type from.\n@return the content type of the given data header. Empty string if the content type is not found."}, {"ID": 1344, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeResultSet(final ResultSet rs) { if (rs == null) { return; } try { rs.close(); } catch (Exception e) { if (LOG.isWarnEnabled()) LOG.warn(\"Error closing ResultSet: \" + rs, e); } }\n\n    ### Response: Close a ResultSet\n\n@param rs a database ResultSet object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void saveResultSet(final ResultSet rs) { if (resultSets == null) { resultSets = new HashSet<>(); } resultSets.add(rs); }\n\n    ### Response:", "ground_truth": "Stores result set.", "predict": " Save a ResultSet\n\n@param rs a database ResultSet object."}, {"ID": 1345, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func addPeopleContext(db *sqlx.DB, in *dt.Msg) error { var addContext, singular bool var sex dt.Sex for _, stem := range in.Stems { switch stem { case \"us\": addContext = true case \"him\", \"he\": addContext, singular = true, true if sex == dt.SexFemale { sex = dt.SexEither } else if sex != dt.SexEither { sex = dt.SexMale } case \"her\", \"she\": addContext, singular = true, true if sex == dt.SexMale { sex = dt.SexEither } else if sex != dt.SexEither { sex = dt.SexFemale } case \"them\": addContext = true sex = dt.SexEither } } if !addContext { return nil } var byt []byte var err error if in.User.ID > 0 { q := `SELECT value FROM states WHERE userid=$1 AND key=$2` err = db.Get(&byt, q, in.User.ID, keyContextPeople) } else { q := `SELECT value FROM states WHERE flexid=$1 AND flexidtype=$2 AND key=$3` err = db.Get(&byt, q, in.User.FlexID, in.User.FlexIDType, keyContextPeople) } if err == sql.ErrNoRows { return nil } if err != nil { return err } var people []dt.Person if err = json.Unmarshal(byt, &people); err != nil { return err } // Filter our people in context by criteria, like sex. if !singular { in.StructuredInput.People = people return nil } if sex == dt.SexEither { // To reach this point, we have at least one person in context. in.StructuredInput.People = []dt.Person{people[0]} return nil } for _, person := range people { if person.Sex == sex { in.StructuredInput.People = []dt.Person{person} break } } return nil }\n\n    ### Response: // addPeopleContext adds people based on context to the sentence when\n// appropriate pronouns are found, like \"us\", \"him\", \"her\", or \"them\"..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q closeAllResultSets() { final SQLException sex = closeQueryResultSets(); if (sex != null) { throw new DbSqlException(\"Close associated ResultSets error\", sex); } return _this(); }\n\n    ### Response:", "ground_truth": "Closes all result sets created by this query. Query remains active.", "predict": " // closeAllResultSets closes all associated ResultSets and returns the Q object.\n\n    "}, {"ID": 1346, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T next() { SQLException sqlException = null; try { T result = nextThrow(); if (result != null) { return result; } } catch (SQLException e) { sqlException = e; } // we have to throw if there is no next or on a SQLException last = null; closeQuietly(); throw new IllegalStateException(\"Could not get next result for \" + dataClass, sqlException); }\n\n    ### Response: Returns the next object in the table.\n\n@throws IllegalStateException\nIf there was a problem extracting the object from SQL..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SQLException closeQuery() { SQLException sqlException = closeQueryResultSets(); if (statement != null) { try { statement.close(); } catch (SQLException sex) { if (sqlException == null) { sqlException = sex; } else { sqlException.setNextException(sex); } } statement = null; } query = null; queryState = CLOSED; return sqlException; }\n\n    ### Response:", "ground_truth": "Closes all assigned result sets and then closes the query. Query becomes closed.", "predict": " Closes the query and releases any resources associated with it.\n\n@return The first SQLException that was encountered during closing, or null if no exceptions were encountered."}, {"ID": 1347, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T next() { SQLException sqlException = null; try { T result = nextThrow(); if (result != null) { return result; } } catch (SQLException e) { sqlException = e; } // we have to throw if there is no next or on a SQLException last = null; closeQuietly(); throw new IllegalStateException(\"Could not get next result for \" + dataClass, sqlException); }\n\n    ### Response: Returns the next object in the table.\n\n@throws IllegalStateException\nIf there was a problem extracting the object from SQL..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings({\"ClassReferencesSubclass\"}) public void close() { final SQLException sqlException = closeQuery(); connection = null; if (this.session != null) { this.session.detachQuery(this); } if (sqlException != null) { throw new DbSqlException(\"Close query error\", sqlException); } }\n\n    ### Response:", "ground_truth": "Closes the query and all created results sets and detaches itself from the session.", "predict": " Closes the query and detaches it from the session.\n\n@throws DbSqlException\nIf there was a problem closing the query."}, {"ID": 1348, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ResultSet executeAdaptiveQuery(Session session, Statement statement, int fetchSize) { int remainingAdaptations = MAX_ADAPTATIONS; while (true) { try { statement.setFetchSize(fetchSize); ResultSet resultSet = session.execute(statement); return new AdaptiveResultSet(session, resultSet, remainingAdaptations); } catch (Throwable t) { if (isAdaptiveException(t) && --remainingAdaptations != 0 && fetchSize > MIN_FETCH_SIZE) { // Try again with half the fetch size fetchSize = Math.max(fetchSize / 2, MIN_FETCH_SIZE); _log.debug(\"Repeating previous query with fetch size {} due to {}\", fetchSize, t.getMessage()); } else { throw Throwables.propagate(t); } } } }\n\n    ### Response: Executes a query sychronously, dynamically adjusting the fetch size down if necessary..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setFetchSize(final int rows) { checkNotClosed(); this.fetchSize = rows; if (statement != null) { try { statement.setFetchSize(fetchSize); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex); } } return _this(); }\n\n    ### Response:", "ground_truth": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when\nmore rows are needed. The number of rows specified affects only result sets created using this statement.\nIf the value specified is zero, then the hint is ignored. The default value is zero.\n@see Statement#setFetchSize(int)", "predict": " Sets the fetch size for the query.\n\n    "}, {"ID": 1349, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int addServerGroup(String groupName, int profileId) throws Exception { int groupId = -1; PreparedStatement statement = null; ResultSet results = null; try (Connection sqlConnection = sqlService.getConnection()) { statement = sqlConnection.prepareStatement(\"INSERT INTO \" + Constants.DB_TABLE_SERVER_GROUPS + \"(\" + Constants.GENERIC_NAME + \",\" + Constants.GENERIC_PROFILE_ID + \")\" + \" VALUES (?, ?);\", PreparedStatement.RETURN_GENERATED_KEYS); statement.setString(1, groupName); statement.setInt(2, profileId); statement.executeUpdate(); results = statement.getGeneratedKeys(); if (results.next()) { groupId = results.getInt(1); } else { // something went wrong throw new Exception(\"Could not add group\"); } } catch (SQLException e) { e.printStackTrace(); } finally { try { if (results != null) { results.close(); } } catch (Exception e) { } try { if (statement != null) { statement.close(); } } catch (Exception e) { } } return groupId; }\n\n    ### Response: Add a new server group\n\n@param groupName name of the group\n@param profileId ID of associated profile\n@return id of server group\n@throws Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setMaxRows(final int maxRows) { checkNotClosed(); this.maxRows = maxRows; if (statement != null) { try { statement.setMaxRows(maxRows); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex); } } return _this(); }\n\n    ### Response:", "ground_truth": "Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.\nIf the limit is exceeded, the excess rows are silently dropped. Zero means there is no limit.\n@see Statement#setMaxRows(int)", "predict": " Set the maximum number of rows to be returned by the query.\n\n@param maxRows the maximum number of rows to be returned by the query.\n@return this query instance.\n@throws DbSqlException if an error occurs while setting the maximum number of rows."}, {"ID": 1350, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, Class<T> targetType, boolean required) throws WebApplicationException { String value = get(key); if (value == null) { if (required) { throw new BadRequestException(\"Missing parameter: \" + key); } Object result = null; if (targetType.isPrimitive()) { if (targetType == boolean.class) { result = Boolean.FALSE; } else if (targetType == int.class) { result = Integer.valueOf(0); } else if (targetType == long.class) { result = Long.valueOf(0); } else if (targetType == double.class) { result = Double.valueOf(0); } else if (targetType == float.class) { result = Float.valueOf(0); } else if (targetType == byte.class) { result = Byte.valueOf((byte) 0); } else if (targetType == short.class) { result = Short.valueOf((short) 0); } else if (targetType == char.class) { result = '\\0'; } } return (T) result; } try { return convertValue(value, targetType); } catch (WebApplicationException e) { throw e; } catch (Exception e) { throw new BadRequestException(\"Failed to convert '\" + value + \"' to type \" + targetType); } }\n\n    ### Response: Gets the single parameter in a generic and flexible way.\n\n@param  is the generic type of targetType.\n@param key is the {@link java.util.Map#get(Object) key} of the parameter to get.\n@param targetType is the {@link Class} reflecting the type to convert the value to. Supports common Java standard\ntypes such as {@link String}, {@link Long}, {@link Double}, {@link BigDecimal}, etc.\n@param required - {@code true} if the value is required and a {@link BadRequestException} is thrown if it is not\npresent, {@code false} otherwise (if optional).\n@return the value for the given key converted to the given targetType. May be\n{@code null} if required is {@code false} .\n@throws WebApplicationException if an error occurred. E.g. {@link BadRequestException} if a required parameter is\nmissing or {@link InternalServerErrorException} if the given targetType is not supported..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int executeUpdate(final boolean closeQuery) { start = System.currentTimeMillis(); init(); final int result; if (log.isDebugEnabled()) { log.debug(\"Executing update: \" + getQueryString()); } try { if (preparedStatement == null) { if (generatedColumns != null) { if (generatedColumns.length == 0) { result = statement.executeUpdate(query.sql, Statement.RETURN_GENERATED_KEYS); } else { result = statement.executeUpdate(query.sql, generatedColumns); } } else { result = statement.executeUpdate(query.sql); } } else { result = preparedStatement.executeUpdate(); } } catch (SQLException sex) { throw new DbSqlException(this, \"Query execution failed\", sex); } if (closeQuery) { close(); } elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return result; }\n\n    ### Response:", "ground_truth": "Executes UPDATE, INSERT or DELETE queries and optionally closes the query.\n@see Statement#executeUpdate(String)", "predict": " Executes an update query and returns the number of affected rows.\n\n@param closeQuery - {@code true} if the query should be closed after execution, {@code false} otherwise.\n@return the number of affected rows.\n@throws DbSqlException if an error occurred during query execution."}, {"ID": 1351, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private PortalUser getPortalUser(final String userName) { return jdbcOperations.execute( (ConnectionCallback<PortalUser>) con -> { PortalUser portalUser = null; PreparedStatement pstmt = null; try { String query = \"SELECT USER_ID FROM UP_USER WHERE USER_NAME=?\"; pstmt = con.prepareStatement(query); pstmt.setString(1, userName); ResultSet rs = null; try { if (log.isDebugEnabled()) log.debug( \"RDBMUserIdentityStore::getPortalUID(userName=\" + userName + \"): \" + query); rs = pstmt.executeQuery(); if (rs.next()) { portalUser = new PortalUser(); portalUser.setUserId(rs.getInt(\"USER_ID\")); portalUser.setUserName(userName); } } finally { try { if (rs != null) { rs.close(); } } catch (Exception e) { } } } finally { try { if (pstmt != null) { pstmt.close(); } } catch (Exception e) { } } return portalUser; }); }\n\n    ### Response: Gets the PortalUser data store object for the specified user name.\n\n@param userName The user's name\n@return A PortalUser object or null if the user doesn't exist..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected long executeCount(final boolean close) { start = System.currentTimeMillis(); init(); ResultSet rs = null; if (log.isDebugEnabled()) { log.debug(\"Executing prepared count: \" + getQueryString()); } try { if (preparedStatement == null) { rs = statement.executeQuery(query.sql); } else { rs = preparedStatement.executeQuery(); } final long firstLong = DbUtil.getFirstLong(rs); elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return firstLong; } catch (SQLException sex) { throw new DbSqlException(this, \"Count query failed\", sex); } finally { DbUtil.close(rs); if (close) { close(); } } }\n\n    ### Response:", "ground_truth": "Executes count queries and optionally closes query afterwards.", "predict": " Executes a count query and returns the first long value returned by the result set.\n\n@param close Whether to close the statement and result set after execution\n@return The first long value returned by the result set\n@throws DbSqlException If the count query fails\n\n    "}, {"ID": 1352, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final ResultSet executePreparedQuery(String sql, List<Object> params) throws SQLException { AbstractQueryCommand command = createPreparedQueryCommand(sql, params); ResultSet rs = null; try { rs = command.execute(); } finally { command.closeResources(); } return rs; }\n\n    ### Response: Useful helper method which handles resource management when executing a\nprepared query which returns a result set.\nDerived classes of Sql can override \"createPreparedQueryCommand\" and then\ncall this method to access the ResultSet returned from the provided query.\n\n@param sql    query to execute\n@param params parameters matching question mark placeholders in the query\n@return the resulting ResultSet\n@throws SQLException if a database error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResultSet getGeneratedColumns() { checkInitialized(); if (generatedColumns == null) { throw new DbSqlException(this, \"No column is specified as auto-generated\"); } final ResultSet rs; try { rs = statement.getGeneratedKeys(); } catch (SQLException sex) { throw new DbSqlException(this, \"No generated keys\", sex); } saveResultSet(rs); totalOpenResultSetCount++; return rs; }\n\n    ### Response:", "ground_truth": "Returns generated columns.", "predict": " Retrieves the auto-generated keys for the last executed statement.\n\n@return the ResultSet containing the auto-generated keys\n@throws DbSqlException if a database error occurs."}, {"ID": 1353, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected FbBotMillEventType eventKind(MessageEnvelope envelope) { IncomingMessage message = envelope.getMessage(); if (message != null) { if (message instanceof ReceivedMessage) { if (getLocationMessage(envelope) != null) { return FbBotMillEventType.LOCATION; } if(getImageMessage(envelope) != null) { return FbBotMillEventType.IMAGE; } if(getVideoMessage(envelope) != null) { return FbBotMillEventType.VIDEO; } if(getAudioMessage(envelope) != null) { return FbBotMillEventType.AUDIO; } if(getFileMessage(envelope) != null) { return FbBotMillEventType.FILE; } return FbBotMillEventType.MESSAGE; } if (message instanceof EchoMessage) { return FbBotMillEventType.ECHO; } } if (envelope.getPostback() != null) { return FbBotMillEventType.POSTBACK; } if (envelope.getDelivery() != null) { return FbBotMillEventType.DELIVERY; } if (envelope.getRead() != null) { return FbBotMillEventType.READ; } if (envelope.getAccountLinking() != null) { return FbBotMillEventType.ACCOUNT_LINKING; } if (envelope.getOptin() != null) { return FbBotMillEventType.AUTHENTICATION; } if (envelope.getCheckoutUpdate() != null) { return FbBotMillEventType.CHECKOUT_UPDATE; } if (envelope.getReferral() != null) { return FbBotMillEventType.REFERRAL; } if (envelope.getPayment() != null) { return FbBotMillEventType.PAYMENT; } if (envelope.getPreCheckout() != null) { return FbBotMillEventType.PRE_CHECKOUT; } return FbBotMillEventType.ANY; }\n\n    ### Response: Returns the kind of callback received for the current envelope.\n\n@param envelope\nthe envelope to inspect.\n@return a {@link FbBotMillEventType} representing the current callback\ntype..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getQueryString() { if (debug) { if ((callableStatement != null)) { if (preparedStatement instanceof LoggableCallableStatement) { return ((LoggableCallableStatement) callableStatement).getQueryString(); } } if (preparedStatement != null) { if (preparedStatement instanceof LoggablePreparedStatement) { return ((LoggablePreparedStatement) preparedStatement).getQueryString(); } } } if (query != null) { return query.sql; } return sqlString; }\n\n    ### Response:", "ground_truth": "Returns query SQL string. For prepared statements, returned sql string with quick-and-dirty replaced values.", "predict": " Returns the query string for the current statement.\n\n@return the query string for the current statement."}, {"ID": 1354, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T invoke(Object target, Method method, Object... parameters) { try { @SuppressWarnings(\"unchecked\") T returnValue = (T) method.invoke(target, parameters); return returnValue; } catch (InvocationTargetException e) { throw handleException(method.getName(), e); } catch (IllegalAccessException e) { throw handleException(method.getName(), e); } }\n\n    ### Response: Invoke target method\n\n@param target     Object target\n@param method     method to invoke\n@param parameters method parameters\n@param  Object generic type\n@return return value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T proxyOf(final T target, final Class<? extends Aspect> aspectClass) { final Aspect aspect; try { aspect = ClassUtil.newInstance(aspectClass, target); } catch (Exception e) { throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e); } return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces()); }\n\n    ### Response:", "ground_truth": "Creates a proxy of given target and the aspect.", "predict": " Create a proxy instance for the target object\n\n@param target         target object\n@param aspectClass    aspect class\n@param T              generic type\n@return proxy instance\n\n    "}, {"ID": 1355, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> collect(Iterator<T> iterator) { List<T> list = new ArrayList<T>(); while (iterator.hasNext()) { list.add(iterator.next()); } return list; }\n\n    ### Response: Collect an iterator's elements into a List.\n\n@param iterator the iterator\n@param       the element type\n@return a List containing the elements\n@since 1.9.3.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Collection<T> collectionOf(final Iterator<? extends T> iterator) { final List<T> list = new ArrayList<>(); while (iterator.hasNext()) { list.add(iterator.next()); } return list; }\n\n    ### Response:", "ground_truth": "Returns a collection containing all elements of the iterator.", "predict": " Create a Collection from an Iterator.\n\n@param iterator the iterator\n@param       the element type\n@return a Collection containing the elements\n@since 1.9.3."}, {"ID": 1356, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Stream<T> toStream( Iterator<T> iterator) { Iterable<T> iterable = () -> iterator; return toStream( iterable); }\n\n    ### Response: Returns a stream that produces the sequence defined by the given Iterator..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Stream<T> streamOf(final Iterator<T> iterator) { return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false); }\n\n    ### Response:", "ground_truth": "Converts iterator to a stream.", "predict": " Returns a stream that produces the sequence defined by the given Iterator."}, {"ID": 1357, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compare(final T o1, final T o2) { int result = 0; if (o1 == null) { if (o2 != null) { result = -1; } } else if (o2 == null) { result = 1; } else { result = compareType(o1, o2); } return result; }\n\n    ### Response: Compares two objects null safe to each other.\n\n@param o1\nthe first reference\n@param o2\nthe second reference\n@return a negative value if o1  o2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compare(final T o1, final T o2) { for (Comparator<T> comparator : comparators) { int result = comparator.compare(o1, o2); if (result != 0) { return result; } } return 0; }\n\n    ### Response:", "ground_truth": "Compares two objects starting with first comparator; if they are equals\nproceeds to the next comparator and so on.", "predict": " Compares two objects null safe to each other using a list of comparators.\n\n@param o1\nthe first reference\n@param o2\nthe second reference\n@return a negative value if o1 is less than o2, zero if they are equal, and a positive value if o1 is greater than o2."}, {"ID": 1358, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CommandOption<T> defaultsTo(Object aDefault) { if (aDefault == null) { defaultValue = null; return this; } boolean isCorrectType; if (type instanceof ParameterizedType) { isCorrectType = ((Class) ((ParameterizedType) type).getRawType()).isInstance(aDefault); } else { isCorrectType = ((Class) type).isInstance(aDefault); } if (!isCorrectType) { throw new IllegalArgumentException(\"Expected default setting of type: \" + type.getTypeName() + \", but was provided: \" + aDefault.getClass().getName()); } defaultValue = (T) aDefault; return this; }\n\n    ### Response: Sets command option default value\n\n@param aDefault value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PetiteConfig setDefaultWiringMode(final WiringMode defaultWiringMode) { if ((defaultWiringMode == null) || (defaultWiringMode == WiringMode.DEFAULT)) { throw new PetiteException(\"Invalid default wiring mode: \" + defaultWiringMode); } this.defaultWiringMode = defaultWiringMode; return this; }\n\n    ### Response:", "ground_truth": "Specifies default wiring mode.", "predict": " Sets the default wiring mode for the container.\n\n@param defaultWiringMode the default wiring mode to set."}, {"ID": 1359, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void log(Logger logger, Level level, String message, Throwable throwable, Object parameter) { if (logger.isLoggable(level)) { final String formattedMessage = MessageFormat.format(localize(logger, message), parameter); doLog(logger, level, formattedMessage, throwable); } }\n\n    ### Response: Allows both parameter substitution and a typed Throwable to be logged.\n\n@param logger the Logger the log to\n@param level the severity level\n@param message the log message\n@param throwable the Throwable to log\n@param parameter the parameter to substitute into message.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void print(final Level level, final String message, final Throwable throwable) { if (!isEnabled(level)) { return; } StringBuilder msg = new StringBuilder() .append(slf.getElapsedTime()).append(' ').append('[') .append(level).append(']').append(' ') .append(getCallerClass()).append(' ').append('-') .append(' ').append(message); System.out.println(msg.toString()); if (throwable != null) { throwable.printStackTrace(System.out); } }\n\n    ### Response:", "ground_truth": "Prints error message if level is enabled.", "predict": " Prints the given message and Throwable to the console, with the elapsed time, log level, and calling class prepended to the message.\n\n@param level the severity level\n@param message the log message\n@param throwable the Throwable to log\n\n    "}, {"ID": 1360, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getStackTrace(final Throwable exception) { if (exception != null) { StringBuilder sb = new StringBuilder(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement element : stackTrace) { sb.append(element.toString()); sb.append('\\n'); } if (exception.getCause() != null) { StackTraceElement[] stackTraceCause = exception.getCause().getStackTrace(); for (StackTraceElement element : stackTraceCause) { sb.append(element.toString()); sb.append('\\n'); } } return sb.toString(); } return null; }\n\n    ### Response: Gets stacktrace as a String.\n\n@param exception Exception for which the stacktrace should be returned.\n@return Stacktrace as a String..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getCallerClass() { Exception exception = new Exception(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { String className = stackTraceElement.getClassName(); if (className.equals(SimpleLoggerProvider.class.getName())) { continue; } if (className.equals(SimpleLogger.class.getName())) { continue; } if (className.equals(Logger.class.getName())) { continue; } return shortenClassName(className) + '.' + stackTraceElement.getMethodName() + ':' + stackTraceElement.getLineNumber(); } return \"N/A\"; }\n\n    ### Response:", "ground_truth": "Returns called class.", "predict": " Gets the class name and method name of the calling method.\n\n@return Class name and method name of the calling method.\n\n    "}, {"ID": 1361, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Map<String, String> splitQueryParameters(Uri rawUri) { String query = rawUri.getEncodedQuery(); if (query == null) { return Collections.emptyMap(); } Map<String, String> paramMap = new LinkedHashMap<>(); int start = 0; do { int next = query.indexOf('&', start); int end = (next == -1) ? query.length() : next; int separator = query.indexOf('=', start); if (separator > end || separator == -1) { separator = end; } String name = query.substring(start, separator); if (!android.text.TextUtils.isEmpty(name)) { String value = (separator == end ? \"\" : query.substring(separator + 1, end)); paramMap.put(Uri.decode(name), Uri.decode(value)); } // Move start to end of name. start = end + 1; } while (start < query.length()); return Collections.unmodifiableMap(paramMap); }\n\n    ### Response: Split query parameters\n@param rawUri raw uri\n@return map with params.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String shortenClassName(final String className) { int lastDotIndex = className.lastIndexOf('.'); if (lastDotIndex == -1) { return className; } StringBuilder shortClassName = new StringBuilder(className.length()); int start = 0; while(true) { shortClassName.append(className.charAt(start)); int next = className.indexOf('.', start); if (next == lastDotIndex) { break; } start = next + 1; shortClassName.append('.'); } shortClassName.append(className.substring(lastDotIndex)); return shortClassName.toString(); }\n\n    ### Response:", "ground_truth": "Returns shorten class name.", "predict": " Shorten class name\n@param className class name\n@return shortened class name."}, {"ID": 1362, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function Observer(object, observer, types) { return { observe(_types) { types = _types || types; if (isObject(object)) observe(object, observer, types); return this; }, unobserve() { if (isObject(object)) unobserve(object, observer); return this; }, reobserve(_object) { this.unobserve(); object = _object; return this.observe(); } }; }\n\n    ### Response: Make an Observer object, which allows easy unobserving and resobserving..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonSerializer excludeTypes(final Class... types) { if (excludedTypes == null) { excludedTypes = types; } else { excludedTypes = ArraysUtil.join(excludedTypes, types); } return this; }\n\n    ### Response:", "ground_truth": "Excludes types. Supports interfaces and subclasses as well.", "predict": " Excludes the specified types from serialization.\n\n    "}, {"ID": 1363, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void serialize(final Object obj, final ByteBuffer buffer) { ByteBufferOutput out = new ByteBufferOutput(buffer); Kryo kryo = borrow(); try { kryo.writeClassAndObject(out, obj); out.flush(); } finally { release(kryo); } }\n\n    ### Response: Serializes given object to byte buffer using Kryo instance in pool.\n\n@param obj    Object to serialize\n@param buffer to write to.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void serialize(final Object source, final Appendable target) { JsonContext jsonContext = createJsonContext(target); jsonContext.serialize(source); }\n\n    ### Response:", "ground_truth": "Serializes object into provided appendable.", "predict": " Serializes given object to Appendable using JsonContext instance.\n\n@param source Object to serialize\n@param target to write to."}, {"ID": 1364, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String serialize(final Object obj) throws IOException { final ObjectMapper mapper = new ObjectMapper(); mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS); return mapper.writeValueAsString(obj); }\n\n    ### Response: Serialize an object with Json\n@param obj Object\n@return String\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String serialize(final Object source) { FastCharBuffer fastCharBuffer = new FastCharBuffer(); serialize(source, fastCharBuffer); return fastCharBuffer.toString(); }\n\n    ### Response:", "ground_truth": "Serializes object into source.", "predict": " Serialize an object to a string\n@param source Object\n@return String\n\n    "}, {"ID": 1365, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object serializeAndDeserialize(Object o) throws IOException, ClassNotFoundException { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bytes); try { out.writeObject(o); } finally { out.close(); } ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream( bytes.toByteArray())); try { Object result = in.readObject(); return result; } finally { in.close(); } }\n\n    ### Response: Serializes and deserializes the given object.\n\n@param o\nan Object.\n@return an Object.\n@throws IOException\n@throws ClassNotFoundException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream out = null; ObjectInputStream in = null; Object objCopy = null; try { out = new ObjectOutputStream(bos); out.writeObject(obj); out.flush(); byte[] bytes = bos.toByteArray(); in = new ObjectInputStream(new ByteArrayInputStream(bytes)); objCopy = in.readObject(); } finally { StreamUtil.close(out); StreamUtil.close(in); } return (T) objCopy; }\n\n    ### Response:", "ground_truth": "Create object copy using serialization mechanism.", "predict": " Clones the given object using serialization.\n\n@param obj\nan Object.\n@return an Object.\n@throws IOException\n@throws ClassNotFoundException."}, {"ID": 1366, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void saveBytesToFile(byte[] data, File file) { if (data == null) { return; } FileOutputStream fos = null; BufferedOutputStream bos = null; try { fos = new FileOutputStream(file); bos = new BufferedOutputStream(fos); bos.write(data); bos.flush(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } }\n\n    ### Response: save to file\n\n@param data\n@param file.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeObject(final File dest, final Object object) throws IOException { FileOutputStream fos = null; BufferedOutputStream bos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(dest); bos = new BufferedOutputStream(fos); oos = new ObjectOutputStream(bos); oos.writeObject(object); } finally { StreamUtil.close(oos); StreamUtil.close(bos); StreamUtil.close(fos); } }\n\n    ### Response:", "ground_truth": "Writes serializable object to a file. Existing file will be overwritten.", "predict": " write object to file\n\n@param dest\n@param object."}, {"ID": 1367, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private SecretKey loadSecretKey() throws IOException, ClassNotFoundException { final File file = getKeyPath(KeyType.SECRET); SecretKey key; try (InputStream fis = Files.newInputStream(file.toPath()); ObjectInputStream ois = new ObjectInputStream(fis)) { key = (SecretKey) ois.readObject(); } return this.secretKey = key; }\n\n    ### Response: Loads the secret key.\n@return a SecretKey\n@throws IOException if the file cannot be read\n@throws ClassNotFoundException if deserialization of the SecretKey fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object readObject(final File source) throws IOException, ClassNotFoundException { Object result = null; FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; try { fis = new FileInputStream(source); bis = new BufferedInputStream(fis); ois = new ObjectInputStream(bis); result = ois.readObject(); } finally { StreamUtil.close(ois); StreamUtil.close(bis); StreamUtil.close(fis); } return result; }\n\n    ### Response:", "ground_truth": "Reads serialized object from the file.", "predict": " Reads an object from a file.\n@param source the file to read from\n@return the object read from the file\n@throws IOException if the file cannot be read\n@throws ClassNotFoundException if deserialization of the object fails.\n\n    "}, {"ID": 1368, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Serializable> byte[] serializeIntoBytes(T obj) throws IOException { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos)) { oos.writeObject(obj); oos.flush(); return bos.toByteArray(); } }\n\n    ### Response: Serialize an object into a byte array.\n\n@param obj A {@link Serializable} object\n@return Byte serialization of input object\n@throws IOException if it fails to serialize the object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] objectToByteArray(final Object obj) throws IOException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(bos); oos.writeObject(obj); } finally { StreamUtil.close(oos); } return bos.toByteArray(); }\n\n    ### Response:", "ground_truth": "Serialize an object to byte array.", "predict": " Serialize an object into a byte array.\n\n@param obj A {@link Serializable} object\n@return Byte serialization of input object\n@throws IOException if it fails to serialize the object."}, {"ID": 1369, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Pure public static Object parseObject(String xmlSerializedObject) throws IOException, ClassNotFoundException { assert xmlSerializedObject != null : AssertMessages.notNullParameter(0); try (ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(xmlSerializedObject))) { final ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); } }\n\n    ### Response: Deserialize an object from the given XML string.\n\n@param xmlSerializedObject is the string which is containing the serialized object.\n@return the serialized object extracted from the XML string.\n@throws IOException if something wrong append during deserialization.\n@throws ClassNotFoundException is thrown when the class for the deserialized object is not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException { Object retObj = null; ByteArrayInputStream bais = new ByteArrayInputStream(data); ObjectInputStream ois = null; try { ois = new ObjectInputStream(bais); retObj = ois.readObject(); } finally { StreamUtil.close(ois); } return retObj; }\n\n    ### Response:", "ground_truth": "De-serialize an object from byte array.", "predict": " Deserialize an object from the given byte array.\n\n@param data is the byte array which is containing the serialized object.\n@return the serialized object extracted from the byte array.\n@throws IOException if something wrong append during deserialization.\n@throws ClassNotFoundException is thrown when the class for the deserialized object is not found.."}, {"ID": 1370, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getUniqueName(String dn, String entityType, Attributes attrs) throws WIMException { final String METHODNAME = \"getUniqueName\"; String uniqueName = null; dn = iLdapConfigMgr.switchToNode(dn); if (iLdapConfigMgr.needTranslateRDN() && iLdapConfigMgr.needTranslateRDN(entityType)) { try { if (entityType != null) { LdapEntity ldapEntity = iLdapConfigMgr.getLdapEntity(entityType); if (ldapEntity != null) { String[] rdnName = LdapHelper.getRDNAttributes(dn); String[][] rdnWIMProps = ldapEntity.getWIMRDNProperties(); String[][] rdnWIMAttrs = ldapEntity.getWIMRDNAttributes(); String[][] rdnAttrs = ldapEntity.getRDNAttributes(); Attribute[] rdnAttributes = new Attribute[rdnWIMProps.length]; String[] rdnAttrValues = new String[rdnWIMProps.length]; for (int i = 0; i < rdnAttrs.length; i++) { String[] rdnAttr = rdnAttrs[i]; boolean isRDN = true; for (int j = 0; j < rdnAttr.length; j++) { if (!rdnAttr[j].equalsIgnoreCase(rdnName[j])) { isRDN = false; } } if (isRDN) { String[] rdnWIMProp = rdnWIMProps[i]; String[] rdnWIMAttr = rdnWIMAttrs[i]; boolean retrieveRDNs = false; if (attrs == null) { retrieveRDNs = true; } else { for (int k = 0; k < rdnWIMAttr.length; k++) { if (attrs.get(rdnWIMAttr[k]) == null) { retrieveRDNs = true; break; } } } if (retrieveRDNs) { attrs = getAttributes(dn, rdnWIMAttr); } for (int k = 0; k < rdnWIMAttr.length; k++) { rdnAttributes[k] = attrs.get(rdnWIMAttr[k]); if (rdnAttributes[k] != null) { rdnAttrValues[k] = (String) rdnAttributes[k].get(); } } uniqueName = LdapHelper.replaceRDN(dn, rdnWIMProp, rdnAttrValues); } } } } } catch (NamingException e) { String msg = Tr.formatMessage(tc, WIMMessageKey.NAMING_EXCEPTION, WIMMessageHelper.generateMsgParms(e.toString(true))); throw new WIMSystemException(WIMMessageKey.NAMING_EXCEPTION, msg, e); } } if (uniqueName == null) { uniqueName = dn; } else { if (tc.isDebugEnabled()) { Tr.debug(tc, METHODNAME + \" Translated uniqueName: \" + uniqueName); } } return uniqueName; }\n\n    ### Response: Get the unique name for the specified distinguished name.\n\n@param dn The distinguished name.\n@param entityType The entity type for the distinguished name.\n@param attrs The attributes for the entity.\n@return The unique name.\n@throws WIMException If there was an error retrieving portions of the unique name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[][] resolveMappedTypesTableNames(final Class[] types) { if (cachedMappedNames == null) { String[][] names = new String[types.length][]; for (int i = 0; i < types.length; i++) { Class type = types[i]; if (type != null) { DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded != null) { Class[] mappedTypes = ded.getMappedTypes(); if (mappedTypes != null) { names[i] = createTypesTableNames(mappedTypes); } } } } cachedMappedNames = names; } return cachedMappedNames; }\n\n    ### Response:", "ground_truth": "Resolved mapped type names for each type.", "predict": " Resolve the mapped types table names for the specified types.\n\n@param types The types to resolve.\n@return The table names for the mapped types.\n\n    "}, {"ID": 1371, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] getNames(Object object) { if (object == null) { return null; } Class<? extends Object> klass = object.getClass(); Field[] fields = klass.getFields(); int length = fields.length; if (length == 0) { return null; } String[] names = new String[length]; for (int i = 0; i < length; i += 1) { names[i] = fields[i].getName(); } return names; }\n\n    ### Response: Get an array of field names from an Object.\n\n@return An array of field names, or null if there are no names..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] createTypesTableNames(final Class[] types) { String[] names = new String[types.length]; for (int i = 0; i < types.length; i++) { if (types[i] == null) { names[i] = null; continue; } DbEntityDescriptor ded = dbEntityManager.lookupType(types[i]); if (ded != null) { String tableName = ded.getTableName(); tableName = tableName.toUpperCase(); names[i] = tableName; } } return names; }\n\n    ### Response:", "ground_truth": "Creates table names for given types.", "predict": " Create an array of table names for the given types.\n\n@param types The types for which to create table names.\n@return An array of table names, or null if there are no names."}, {"ID": 1372, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public <T> void set(PreparedStatement stmt, Path<?> path, int i, T value) throws SQLException { if (value == null || value instanceof Null) { Integer sqlType = null; if (path != null) { ColumnMetadata columnMetadata = ColumnMetadata.getColumnMetadata(path); if (columnMetadata.hasJdbcType()) { sqlType = columnMetadata.getJdbcType(); } } if (sqlType != null) { stmt.setNull(i, sqlType); } else { stmt.setNull(i, Types.NULL); } } else { getType(path, (Class) value.getClass()).setValue(stmt, i, value); } }\n\n    ### Response: Set the value at the given index in the statement\n\n@param \n@param stmt statement\n@param path path\n@param i one based index in statement\n@param value value to bind\n@throws SQLException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected Object readColumnValue(final int colNdx, final Class destinationType, final Class<? extends SqlType> sqlTypeClass, final int columnDbSqlType) { if (colNdx != cachedColumnNdx) { try { SqlType sqlType; if (sqlTypeClass != null) { sqlType = SqlTypeManager.get().lookupSqlType(sqlTypeClass); } else { sqlType = SqlTypeManager.get().lookup(destinationType); } if (sqlType != null) { cachedColumnValue = sqlType.readValue(resultSet, colNdx + 1, destinationType, columnDbSqlType); } else { cachedColumnValue = resultSet.getObject(colNdx + 1); cachedColumnValue = TypeConverterManager.get().convertType(cachedColumnValue, destinationType); } } catch (SQLException sex) { throw new DbOomException(dbOomQuery, \"Invalid value for column #\" + (colNdx + 1), sex); } cachedColumnNdx = colNdx; } return cachedColumnValue; }\n\n    ### Response:", "ground_truth": "Reads column value from result set. Since this method may be called more then once for\nthe same column, it caches column values.", "predict": " Read the value of the specified column from the current row of the result set and convert it to the specified type.\n\n@param colNdx one based index of the column to read\n@param destinationType type to convert the column value to\n@param sqlTypeClass class of the SqlType to use for conversion, or null to use the default SqlType for the destination type\n@param columnDbSqlType the database-specific SQL type of the column, or 0 if unknown\n@return the converted value of the column\n@throws SQLException if an error occurs while reading the value from the result set\n@throws DbOomException if the value cannot be converted to the specified type"}, {"ID": 1373, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unregister( ActiveObject object ) { synchronized (watchList) { for (int i = 0; i < watchList.size(); i++) { WeakReference<ActiveObject> weakRef = watchList.get(i); ActiveObject obj = weakRef.get(); if (obj == null) { // Object was garbage collected, remove and continue watchList.remove(i--); continue; } if (obj == object) { // Found it ! watchList.remove(i); break; } } } }\n\n    ### Response: Unregister a monitored active object\n@param object the object to unregister.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void cacheResultSetEntities(final Object[] result) { if (entitiesCache == null) { entitiesCache = new HashMap<>(); } for (int i = 0; i < result.length; i++) { Object object = result[i]; if (object == null) { continue; } DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded == null) { // not a type, continue continue; } // calculate key Object key; if (ded.hasIdColumn()) { //noinspection unchecked key = ded.getKeyValue(object); } else { key = object; } Object cachedObject = entitiesCache.get(key); if (cachedObject == null) { // object is not in the cache, add it entitiesCache.put(key, object); } else { // object is in the cache, replace it result[i] = cachedObject; } } }\n\n    ### Response:", "ground_truth": "Caches returned entities. Replaces new instances with existing ones.", "predict": " Cache the entities of a result set\n@param result the result set to cache.\n\n    "}, {"ID": 1374, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function getProvidersForPath(filePath) { var language = LanguageManager.getLanguageForPath(filePath).getId(), context = PreferencesManager._buildContext(filePath, language), installedProviders = getProvidersForLanguageId(language), preferredProviders, prefPreferredProviderNames = prefs.get(PREF_PREFER_PROVIDERS, context), prefPreferredOnly = prefs.get(PREF_PREFERRED_ONLY, context), providers; if (prefPreferredProviderNames && prefPreferredProviderNames.length) { if (typeof prefPreferredProviderNames === \"string\") { prefPreferredProviderNames = [prefPreferredProviderNames]; } preferredProviders = prefPreferredProviderNames.reduce(function (result, key) { var provider = _.find(installedProviders, {name: key}); if (provider) { result.push(provider); } return result; }, []); if (prefPreferredOnly) { providers = preferredProviders; } else { providers = _.union(preferredProviders, installedProviders); } } else { providers = installedProviders; } return providers; }\n\n    ### Response: Returns a list of provider for given file path, if available.\nDecision is made depending on the file extension.\n\n@param {!string} filePath\n@return {Array.}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProviderDefinition[] resolve(final Class type, final String name) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor[] methods = cd.getAllMethodDescriptors(); List<ProviderDefinition> list = new ArrayList<>(); for (MethodDescriptor methodDescriptor : methods) { Method method = methodDescriptor.getMethod(); PetiteProvider petiteProvider = method.getAnnotation(PetiteProvider.class); if (petiteProvider == null) { continue; } String providerName = petiteProvider.value(); if (StringUtil.isBlank(providerName)) { // default provider name providerName = method.getName(); if (providerName.endsWith(\"Provider\")) { providerName = StringUtil.substring(providerName, 0, -8); } } ProviderDefinition providerDefinition; if (Modifier.isStatic(method.getModifiers())) { providerDefinition = new ProviderDefinition(providerName, method); } else { providerDefinition = new ProviderDefinition(providerName, name, method); } list.add(providerDefinition); } ProviderDefinition[] providers; if (list.isEmpty()) { providers = ProviderDefinition.EMPTY; } else { providers = list.toArray(new ProviderDefinition[0]); } return providers; }\n\n    ### Response:", "ground_truth": "Resolves all providers in the class", "predict": " Resolves provider definitions for the given type and name.\n\n@param {!Class} type\n@param {!string} name\n@return {Array.<ProviderDefinition>}."}, {"ID": 1375, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String generateEntityName(SQLiteDaoDefinition dao, SQLiteEntity entity) { String entityName; if (entity == null) { M2MEntity m2mEntity = M2MEntity.extractEntityManagedByDAO(dao.getElement()); entityName = m2mEntity.getSimpleName(); } else { entityName = entity.getSimpleName(); } return entityName; }\n\n    ### Response: dao or entity can be null.\n\n@param dao\nthe dao\n@param entity\nthe entity\n@return the string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String applyToTableName(final String tableName) { String entityName = convertTableNameToEntityName(tableName); return convertEntityNameToTableName(entityName); }\n\n    ### Response:", "ground_truth": "Applies table naming strategy to given table name hint.\nReturns full table name.", "predict": " tableName can be null.\n\n@param tableName\nthe table name\n@return the string."}, {"ID": 1376, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public SQLException attempt() { try { Connection con = this.connectionSpec.getOrCreate(); con.setReadOnly(true); try { Statement stmt = con.createStatement( ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); stmt.setFetchSize(AbstractSQLGenerator.FETCH_SIZE); if (this.queryTimeout != null) { stmt.setQueryTimeout(this.queryTimeout); } try { SQLExecutor.executeSQL(con, stmt, this.query, this.resultProcessor); stmt.close(); stmt = null; } finally { if (stmt != null) { try { stmt.close(); } catch (SQLException e) { } } } con.close(); con = null; } finally { if (con != null) { try { con.close(); } catch (SQLException e) { } } } return null; } catch (SQLException ex) { return ex; } }\n\n    ### Response: Attempts executing the query specified in the constructor.\n\n@return a {@link SQLException} if execution failed, or null\nif execution was successful..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isConnectionValid(final ConnectionData connectionData, final long now) { if (!validateConnection) { return true; } if (now < connectionData.lastUsed + validationTimeout) { return true; } Connection conn = connectionData.connection; if (validationQuery == null) { try { return !conn.isClosed(); } catch (SQLException sex) { return false; } } boolean valid = true; Statement st = null; try { st = conn.createStatement(); st.execute(validationQuery); } catch (SQLException sex) { valid = false; } finally { if (st != null) { try { st.close(); } catch (SQLException ignore) { } } } return valid; }\n\n    ### Response:", "ground_truth": "Checks if existing connection is valid and available. It may happens\nthat if connection is not used for a while it becomes inactive,\nalthough not technically closed.", "predict": " Checks if the connection is valid.\n\n@param connectionData the connection data to check\n@param now the current time in milliseconds\n@return true if the connection is valid, false otherwise."}, {"ID": 1377, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forward(HttpServletRequest request, HttpServletResponse response, final String target) throws ServletException, IOException { if (target.startsWith(\"/WEB-INF/classes\") || target.startsWith(\"/WEB-INF/lib\") || target.matches(\"^/WEB-INF/.+\\\\.xml\")) { throw new IOException(\"Not allowed\"); } this.contentJsp = target; this.originalRequestURL = request.getRequestURL().toString(); request.setAttribute(FERRET_NAME, this); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if(dispatcher == null) { throw new IOException(\"No dispatcher for \" + target); } dispatcher.forward(request, response); }\n\n    ### Response: Store this UIResults object in the given HttpServletRequest, then\nforward the request to target, in this case, an image, html file, .jsp,\nany file which can return a complete document. Specifically, this means\nthat if target is a .jsp, it must render it's own header and footer.\n@param request the HttpServletRequest\n@param response the HttpServletResponse\n@param target the String path to the .jsp to handle drawing the data,\nrelative to the contextRoot (ex. \"/WEB-INF/query/foo.jsp\")\n@throws ServletException for usual reasons...\n@throws IOException for usual reasons....\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void renderView(final ActionRequest actionRequest, final String target) throws Exception { HttpServletRequest request = actionRequest.getHttpServletRequest(); HttpServletResponse response = actionRequest.getHttpServletResponse(); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if (dispatcher == null) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + target); // should never happened return; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if (DispatcherUtil.isPageIncluded(request, response)) { dispatcher.include(request, response); } else { dispatcher.forward(request, response); } }\n\n    ### Response:", "ground_truth": "Renders the view by dispatching to the target JSP.", "predict": "This method is called by the Struts action to render the view. It takes an ActionRequest object and a target string, which is the path to the JSP to render. The method first gets the underlying HTTP request and response objects from the ActionRequest object. It then gets a RequestDispatcher object for the target JSP using the request object. If the RequestDispatcher object is null, it means that the JSP file was not found, so the method sends an HTTP error response with a 404 status code and an error message. If the RequestDispatcher object is not null, the method checks whether the request is for an included page or a forwarded page. If it's an included page, the method calls the include method of the RequestDispatcher object, which includes the JSP file in the current page. If it's a forwarded page, the method calls the forward method of the RequestDispatcher object, which forwards the request to the JSP file."}, {"ID": 1378, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"PMD.DataflowAnomalyAnalysis\") protected static String derivePattern(String path) { String pattern; if (\"/\".equals(path)) { pattern = \"/**\"; } else { String patternBase = path; if (patternBase.endsWith(\"/\")) { patternBase = path.substring(0, path.length() - 1); } pattern = path + \",\" + path + \"/**\"; } return pattern; }\n\n    ### Response: Derives the resource pattern from the path.\n\n@param path the path\n@return the pattern.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String locateTarget(final ActionRequest actionRequest, String path) { String target; if (path.endsWith(StringPool.SLASH)) { path = path + defaultViewPageName; } for (final String ext : defaultViewExtensions) { target = path + ext; if (targetExists(actionRequest, target)) { return target; } } return null; }\n\n    ### Response:", "ground_truth": "Locates target using path with various extensions appended.", "predict": " Locates the target view for the given action request and path.\n\n@param actionRequest the action request\n@param path the path\n@return the target view or null if not found.\n\n    "}, {"ID": 1379, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String remainingStrings() throws IOException { StringBuffer buffer = null; while (true) { Tokenizer.Token t = get(); if (!t.isString()) break; if (buffer == null) buffer = new StringBuffer(); buffer.append(t.value); } unget(); if (buffer == null) return null; return buffer.toString(); }\n\n    ### Response: Returns a concatenation of the remaining strings from a Tokenizer..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); }\n\n    ### Response:", "ground_truth": "Returns buffered writer if buffering is enabled,\notherwise returns the original writer.", "predict": " Returns a PrintWriter to write the response output to. If the response output has been buffered, the PrintWriter will be to the buffer. Otherwise, the PrintWriter will be to the response output."}, {"ID": 1380, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public OutputStream getOutputStream() throws IOException { if (!_file.isWriteable()) { throw new IOException(\"Cannot write\"); } return IOUtil.toBufferedOutputStream(_file.getOutputStream()); }\n\n    ### Response: Get output stream.\n\n@returns Output stream\n@throws IOException IO exception occurred.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ServletOutputStream getOutputStream() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getOutputStream(); } return buffer.getOutputStream(); }\n\n    ### Response:", "ground_truth": "Returns buffered output stream if buffering is enabled,\notherwise returns the original stream.", "predict": " Get output stream.\n\n@returns Output stream\n@throws IOException IO exception occurred."}, {"ID": 1381, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Properties loadProperties(Resource resource, String filename) throws IOException { InputStream is = resource.getInputStream(); Properties props = new Properties(); try { if (resource.getFilename().endsWith(XML_SUFFIX)) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.loadFromXml(props, is); } else { String encoding = null; if (this.fileEncodings != null) { encoding = this.fileEncodings.getProperty(filename); } if (encoding == null) { encoding = this.defaultEncoding; } if (encoding != null) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\"); } this.propertiesPersister.load(props, new InputStreamReader(is, encoding)); } else { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.load(props, is); } } return props; } finally { is.close(); } }\n\n    ### Response: Load the properties from the given resource.\n@param resource the resource to load from\n@param filename the original bundle filename (basename + Locale)\n@return the populated Properties instance\n@throws IOException if properties loading failed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeContentToResponse(final char[] content) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUtil.toByteArray(content)); } else { outputStream.write(CharUtil.toByteArray(content, encoding)); } outputStream.flush(); } else { Writer out = getResponse().getWriter(); out.write(content); out.flush(); } }\n\n    ### Response:", "ground_truth": "Writes content to original output stream, using either output stream or writer, depending\non how the content was buffered. It is assumed that provided content is a modified\nwrapped content.", "predict": " Write the given content to the response.\n@param content the content to write to the response\n@throws IOException if an I/O error occurs."}, {"ID": 1382, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String extractSQLForJavaDoc(final SQLiteModelMethod method) { final One<Boolean> usedInWhere = new One<>(false); String sqlForJavaDoc = JQLChecker.getInstance().replace(method, method.jql, new JQLReplacerListenerImpl(method) { @Override public String onColumnNameToUpdate(String columnName) { return currentEntity.findPropertyByName(columnName).columnName; } @Override public String onColumnName(String columnName) { return currentEntity.findPropertyByName(columnName).columnName; } @Override public String onBindParameter(String bindParameterName, boolean inStatement) { if (!usedInWhere.value0) { if (bindParameterName.contains(\".\")) { String[] a = bindParameterName.split(\"\\\\.\"); if (a.length == 2) { bindParameterName = a[1]; } } return \":\" + bindParameterName; } else { return null; } } @Override public void onWhereStatementBegin(Where_stmtContext ctx) { usedInWhere.value0 = true; } @Override public void onWhereStatementEnd(Where_stmtContext ctx) { usedInWhere.value0 = false; }; }); return sqlForJavaDoc; }\n\n    ### Response: Extract SQL for java doc.\n\n@param method\nthe method\n@return the string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void setContentType(final String type) { super.setContentType(type); contentTypeResolver = new ContentTypeHeaderResolver(type); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } }\n\n    ### Response:", "ground_truth": "Sets the content type and enables or disables buffering.", "predict": " Set content type.\n\n@param type\nthe content type."}, {"ID": 1383, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] writeImageToBytes(BufferedImage image, String formatName, Float quality) throws IOException { byte[] bytes = null; if (quality != null) { bytes = compressAndWriteImageToBytes(image, formatName, quality); } else { bytes = writeImageToBytes(image, formatName); } return bytes; }\n\n    ### Response: Write the image to bytes in the provided format and optional quality\n\n@param image\nbuffered image\n@param formatName\nimage format name\n@param quality\nnull or quality between 0.0 and 1.0\n@return image bytes\n@throws IOException\nupon failure\n@since 1.1.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void print(final String string) throws IOException { if (isBufferStreamBased()) { String encoding = getContentTypeEncoding(); byte[] bytes; if (encoding == null) { bytes = string.getBytes(); } else { bytes = string.getBytes(encoding); } buffer.getOutputStream().write(bytes); return; } // make sure at least writer is initialized buffer.getWriter().write(string); }\n\n    ### Response:", "ground_truth": "Appends string to the buffer.", "predict": " Print the string to the output stream.\n\n@param string\nthe string to print\n@throws IOException\nif an I/O error occurs\n@since 1.1.2."}, {"ID": 1384, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getAuthTokenFromRequest(HttpServletRequest httpRequest) { String authToken = httpRequest.getHeader(AUTH_TOKEN_HEADER_KEY); if (authToken == null) { // token can also exist as request parameter authToken = httpRequest.getParameter(AUTH_TOKEN_PARAMETER_KEY); } return authToken; }\n\n    ### Response: Gets the authorization token from the request. First tries the header, if that's empty the parameter is checked.\n\n@param httpRequest request.\n@return authorization token if it exists in the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult login() { T authToken; authToken = loginViaBasicAuth(servletRequest); if (authToken == null) { authToken = loginViaRequestParams(servletRequest); } if (authToken == null) { log.warn(\"Login failed.\"); return JsonResult.of(HttpStatus.error401().unauthorized(\"Login failed.\")); } log.info(\"login OK!\"); final UserSession<T> userSession = new UserSession<>(authToken, userAuth.tokenValue(authToken)); userSession.start(servletRequest, servletResponse); // return token return tokenAsJson(authToken); }\n\n    ### Response:", "ground_truth": "Authenticate user and start user session.", "predict": " Logs in the user and returns a token if successful.\n\n@return token if successful, otherwise an error message.\n\n    "}, {"ID": 1385, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private JsonObject getPendingJSONObject() { for (Map.Entry<String, BoxJSONObject> entry : this.children.entrySet()) { BoxJSONObject child = entry.getValue(); JsonObject jsonObject = child.getPendingJSONObject(); if (jsonObject != null) { if (this.pendingChanges == null) { this.pendingChanges = new JsonObject(); } this.pendingChanges.set(entry.getKey(), jsonObject); } } return this.pendingChanges; }\n\n    ### Response: Gets a JsonObject containing any pending changes to this object that can be sent back to the Box API.\n@return a JsonObject containing the pending changes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult tokenAsJson(final T authToken) { final JsonObject jsonObject = new JsonObject(); jsonObject.put(\"token\", userAuth.tokenValue(authToken)); return JsonResult.of(jsonObject); }\n\n    ### Response:", "ground_truth": "Prepares the JSON payload that carries on the token value.", "predict": " Converts the given authentication token into a JSON object with a \"token\" field containing the token value.\n@param authToken the authentication token to convert\n@return a JSON object with a \"token\" field containing the token value."}, {"ID": 1386, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Credentials getCredentials() { String username = getUsername(); char[] password = getPassword(); if (username != null) { return new SimpleCredentials(username, password); } return null; }\n\n    ### Response: Return the credentials based on the user name and password.\n\n@return Credentials.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T loginViaBasicAuth(final HttpServletRequest servletRequest) { final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); return userAuth.login(username, password); }\n\n    ### Response:", "ground_truth": "Tries to login user with basic authentication.", "predict": " Login the user using basic authentication.\n\n@param servletRequest The HTTP request object.\n@return The authenticated user object."}, {"ID": 1387, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function logout() { if (is_null($userId = $this->getUserId())) { return null; } return $this->leave(static::USER_PREFIX . $userId); }\n\n    ### Response: Logout with current sender's fd.\n\n@return mixed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult logout() { log.debug(\"logout user\"); UserSession.stop(servletRequest, servletResponse); return JsonResult.of(HttpStatus.ok()); }\n\n    ### Response:", "ground_truth": "Logout hook.", "predict": " Logout user and clear session.\n\n@return JsonResult."}, {"ID": 1388, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] getBytes(URL url) throws IOException { final String path = url.getPath(); final File file = new File(path); if (file.exists()) { return getFileBytes(file); } return null; }\n\n    ### Response: Common code for getting the bytes of a url.\n\n@param url the url to read.\n@return bytes of the file pointed to by URL.\n@throws IOException if an IOException occurs while reading the file..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File toContainerFile(final URL url) { String protocol = url.getProtocol(); if (protocol.equals(FILE_PROTOCOL)) { return toFile(url); } String path = url.getPath(); return new File(URI.create( path.substring(ZERO, path.lastIndexOf(\"!/\")))); }\n\n    ### Response:", "ground_truth": "Returns a file of either a folder or a containing archive.", "predict": " Converts a URL to a container file.\n\n@param url the URL to convert.\n@return the container file."}, {"ID": 1389, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<File> ensureWriteableDirectory(List<File> dirs) throws IOException { for (Iterator<File> i = dirs.iterator(); i.hasNext();) { FileUtils.ensureWriteableDirectory(i.next()); } return dirs; }\n\n    ### Response: Ensure writeable directories.\n\nIf doesn't exist, we attempt creation.\n\n@param dirs List of Files to test.\n\n@return The passed dirs.\n\n@exception IOException If passed directory does not exist and is not\ncreateable, or directory is not writeable or is not a directory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File mkdirs(final File dirs) throws IOException { if (dirs.exists()) { checkIsDirectory(dirs); return dirs; } return checkCreateDirectory(dirs); }\n\n    ### Response:", "ground_truth": "Creates all directories at once.\n\n@param dirs Directories to make.\n@throws IOException if cannot create directory.", "predict": " Create directory if it doesn't exist.\n\n@param dirs The directory to create.\n\n@return The passed directory.\n\n@exception IOException If passed directory is not a directory or is not\ncreateable.\n\n    "}, {"ID": 1390, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String createIfNeeded(String dir) { File f = new File(dir); if (f.exists()) { return dir; } else { boolean success = f.mkdirs(); if (success) return dir; else return null; } }\n\n    ### Response: Create input directory if it does not exist\n\n@return directory name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File mkdir(final File dir) throws IOException { if (dir.exists()) { checkIsDirectory(dir); return dir; } return checkCreateDirectory(dir); }\n\n    ### Response:", "ground_truth": "Creates single directory.\n\n@throws IOException if cannot create directory.", "predict": " Create directory if it does not exist\n\n@param dir directory to create\n@return created directory\n@throws IOException if directory cannot be created\n\n    "}, {"ID": 1391, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyFile(File src, File dest) throws IOException { if (src == null) throw new NullPointerException(\"Source must not be null\"); if (dest == null) throw new NullPointerException(\"Destination must not be null\"); if (!src.exists()) throw new FileNotFoundException(\"Source '\" + src + \"' does not exist\"); if (!src.isFile()) throw new IOException(\"Source '\" + src + \"' is not a file\"); if (dest.exists()) throw new IOException(\"Destination '\" + dest + \"' is already exists\"); FileChannel in = null, out = null; try { in = new FileInputStream(src).getChannel(); out = new FileOutputStream(dest).getChannel(); in.transferTo(0, in.size(), out); } finally { try { in.close(); out.close(); } catch (IOException e) { // Ignore. } } if (src.length() != dest.length()) { throw new IOException(\"Failed to copy full contents from '\" + src + \"' to '\" + dest + \"'\"); } dest.setLastModified(src.lastModified()); }\n\n    ### Response: Copies a file to a new location preserving the file date.\n\n@param src\nAn existing file to copy, must not be null.\n@param dest\nThe new file, must not be null and exist.\n\n@throws IOException\nIf copying is failed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void _copyFile(final File srcFile, final File destFile) throws IOException { if (destFile.exists()) { if (destFile.isDirectory()) { throw new IOException(\"Destination '\" + destFile + \"' is a directory\"); } } // do copy file FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(srcFile); output = new FileOutputStream(destFile, false); StreamUtil.copy(input, output); } finally { StreamUtil.close(output); StreamUtil.close(input); } // done if (srcFile.length() != destFile.length()) { throw new IOException(\"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\"); } destFile.setLastModified(srcFile.lastModified()); }\n\n    ### Response:", "ground_truth": "Internal file copy when most of the pre-checking has passed.\n\n@param srcFile  Source {@link File}.\n@param destFile Destination {@link File}.\n@throws IOException if cannot copy", "predict": " Copies a file to a new location preserving the file date.\n\n@param srcFile\nAn existing file to copy, must not be null.\n@param destFile\nThe new file, must not be null and exist.\n\n@throws IOException\nIf copying is failed.."}, {"ID": 1392, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unjarDir(File jarFile, File destDir) throws IOException { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(jarFile); unjar(fis, destDir); }\n\n    ### Response: Unjars a given jar file into a given directory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyDir(final File srcDir, final File destDir) throws IOException { checkDirCopy(srcDir, destDir); _copyDirectory(srcDir, destDir); }\n\n    ### Response:", "ground_truth": "Copies directory with specified copy params.\n\n@see #_copyDirectory(File, File)", "predict": " Copies a directory from one location to another.\n\n    "}, {"ID": 1393, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean moveFile(final File srcFile, final File destDir) throws IOException, FileIsADirectoryException { return RenameFileExtensions.renameFile(srcFile, destDir, true); }\n\n    ### Response: Moves the given source file to the destination Directory.\n\n@param srcFile\nThe source file.\n@param destDir\nThe destination directory.\n@return true if the file was moved otherwise false.\n@throws IOException\nSignals that an I/O exception has occurred.\n@throws FileIsADirectoryException\nthe file is A directory exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File moveFileToDir(final File srcFile, final File destDir) throws IOException { checkExistsAndDirectory(destDir); return moveFile(srcFile, file(destDir, srcFile.getName())); }\n\n    ### Response:", "ground_truth": "Moves a file to a directory.\n\n@param srcFile Source {@link File}.\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": " Moves the given source file to the destination Directory.\n\n@param srcFile\nThe source file.\n@param destDir\nThe destination directory.\n@return the moved file.\n@throws IOException\nSignals that an I/O exception has occurred.\n\n    "}, {"ID": 1394, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unjarDir(File jarFile, File destDir) throws IOException { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(jarFile); unjar(fis, destDir); }\n\n    ### Response: Unjars a given jar file into a given directory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void _moveDirectory(final File srcDest, File destDir) throws IOException { if (destDir.exists()) { checkIsDirectory(destDir); destDir = file(destDir, destDir.getName()); destDir.mkdir(); } final boolean rename = srcDest.renameTo(destDir); if (!rename) { _copyDirectory(srcDest, destDir); deleteDir(srcDest); } }\n\n    ### Response:", "ground_truth": "Moves a directory.\n\n@param srcDest Source directory\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": " Moves a directory from one location to another. If the destination directory already exists, it will be overwritten. If the source directory contains subdirectories, they will also be moved.\n\n    "}, {"ID": 1395, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void delete(File file) { if (file.isDirectory()) { File[] files = file.listFiles(); if (files != null) { for (File child : files) { delete(child); } } } file.delete(); }\n\n    ### Response: Recursive delete of a file or directory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cleanDir(final File destDir) throws IOException { checkExists(destDir); checkIsDirectory(destDir); File[] files = destDir.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of: \" + destDir); } IOException exception = null; for (File file : files) { try { if (file.isDirectory()) { deleteDir(file); } else { file.delete(); } } catch (IOException ioex) { exception = ioex; continue; } } if (exception != null) { throw exception; } }\n\n    ### Response:", "ground_truth": "Cleans a directory without deleting it.\n\n@param destDir destination to clean.\n@throws IOException if something went wrong.", "predict": " Deletes all files and directories in the specified directory. If any errors occur during the deletion process, they are caught and the method continues to delete the remaining files and directories. If any errors occur during the deletion process, they are re-thrown after all files and directories have been deleted."}, {"ID": 1396, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeProperties(Properties p, File file) throws IOException { FileOutputStream fos = new FileOutputStream(file); try { p.store(fos,\"\"); } finally { ArchiveUtils.closeQuietly(fos); } }\n\n    ### Response: Store Properties instance to a File\n@param p\n@param file destination File\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] readUTFChars(final File file) throws IOException { checkExists(file); checkIsFile(file); UnicodeInputStream in = unicodeInputStreamOf(file); try { return StreamUtil.readChars(in, detectEncoding(in)); } finally { StreamUtil.close(in); } }\n\n    ### Response:", "ground_truth": "Reads UTF file content as char array.\n\n@param file {@link File} to read.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " Read UTF-8 characters from a file\n@param file\n@return UTF-8 characters\n@throws IOException if an I/O error occurs.\n\n    "}, {"ID": 1397, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> appendLines(List<String> result, String file, String encoding) throws IOException { InputStream is = new FileInputStream(file); try { return appendLines(result, is, encoding); } finally { is.close(); } }\n\n    ### Response: Utility for loading lines from a file.\n@param result The result of the appended lines.\n@param file The file to have an input stream.\n@param encoding if null, then UTF-8\n@return filled list\n@throws IOException If there were problems opening the file for input stream..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] readChars(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file, encoding); try { return StreamUtil.readChars(in, encoding); } finally { StreamUtil.close(in); } }\n\n    ### Response:", "ground_truth": "Reads file content as char array.\n\n@param file     {@link File} to read.\n@param encoding Encoding to use.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " Utility for reading the contents of a file as a char array.\n@param file The file to read.\n@param encoding The encoding of the file.\n@return The contents of the file as a char array.\n@throws IOException If there were problems reading the file.\n\n    "}, {"ID": 1398, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void saveFile(final File file, final String contents, final String encoding) throws IOException { saveFile(file, contents.getBytes(encoding)); }\n\n    ### Response: Save the data, represented as a String to a file\n\n@param file     The location/name of the file to be saved.\n@param contents The data that is to be written to the file.\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeChars(final File dest, final char[] data, final String encoding) throws IOException { outChars(dest, data, encoding, false); }\n\n    ### Response:", "ground_truth": "Write characters. append = false\n\n@see #outChars(File, char[], String, boolean)", "predict": " Write the character array to a file\n\n@param dest     The location/name of the file to be written to.\n@param data     The character array to be written to the file.\n@param encoding The encoding to be used for writing the data to the file.\n@throws IOException."}, {"ID": 1399, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void saveFile(final File file, final String contents, final String encoding) throws IOException { saveFile(file, contents.getBytes(encoding)); }\n\n    ### Response: Save the data, represented as a String to a file\n\n@param file     The location/name of the file to be saved.\n@param contents The data that is to be written to the file.\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, false); }\n\n    ### Response:", "ground_truth": "Writes String. append = false\n\n@see #outString(File, String, String, boolean)", "predict": " Write a string to a file\n\n@param dest     The location/name of the file to be written to.\n@param data     The string data to be written to the file.\n@param encoding The encoding to be used for the file.\n@throws IOException."}, {"ID": 1400, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void saveFile(final File file, final String contents, final String encoding) throws IOException { saveFile(file, contents.getBytes(encoding)); }\n\n    ### Response: Save the data, represented as a String to a file\n\n@param file     The location/name of the file to be saved.\n@param contents The data that is to be written to the file.\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void appendString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, true); }\n\n    ### Response:", "ground_truth": "Appends String. append = true\n\n@see #outString(File, String, String, boolean)", "predict": " Append the data, represented as a String to a file\n\n@param dest     The location/name of the file to which the data is to be appended.\n@param data     The data that is to be appended to the file.\n@param encoding The encoding format of the data.\n@throws IOException."}, {"ID": 1401, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (this.entryOffset >= this.entrySize) { return -1; } if ((numToRead + this.entryOffset) > this.entrySize) { numToRead = (int) (this.entrySize - this.entryOffset); } if (this.readBuf != null) { int sz = (numToRead > this.readBuf.length) ? this.readBuf.length : numToRead; System.arraycopy(this.readBuf, 0, buf, offset, sz); if (sz >= this.readBuf.length) { this.readBuf = null; } else { int newLen = this.readBuf.length - sz; byte[] newBuf = new byte[newLen]; System.arraycopy(this.readBuf, sz, newBuf, 0, newLen); this.readBuf = newBuf; } totalRead += sz; numToRead -= sz; offset += sz; } while (numToRead > 0) { byte[] rec = this.buffer.readRecord(); if (rec == null) { // Unexpected EOF! throw new IOException(\"unexpected EOF with \" + numToRead + \" bytes unread\"); } int sz = numToRead; int recLen = rec.length; if (recLen > sz) { System.arraycopy(rec, 0, buf, offset, sz); this.readBuf = new byte[recLen - sz]; System.arraycopy(rec, sz, this.readBuf, 0, recLen - sz); } else { sz = recLen; System.arraycopy(rec, 0, buf, offset, recLen); } totalRead += sz; numToRead -= sz; offset += sz; } this.entryOffset += totalRead; return totalRead; }\n\n    ### Response: Reads bytes from the current tar archive entry.\n\nThis method is aware of the boundaries of the current\nentry in the archive and will deal with them as if they\nwere this stream's start and EOF.\n\n@param buf The buffer into which to place bytes read.\n@param offset The offset at which to place bytes read.\n@param numToRead The number of bytes to read.\n@return The number of bytes read, or -1 at EOF.\n@throws IOException on error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] readBytes(final File file, final int count) throws IOException { checkExists(file); checkIsFile(file); long numToRead = file.length(); if (numToRead >= Integer.MAX_VALUE) { throw new IOException(\"File is larger then max array size\"); } if (count > NEGATIVE_ONE && count < numToRead) { numToRead = count; } byte[] bytes = new byte[(int) numToRead]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; }\n\n    ### Response:", "ground_truth": "Read file and returns byte array with contents.\n\n@param file  {@link File} to read\n@param count number of bytes to read\n@return byte array from {@link File} contents.\n@throws IOException if not a {@link File} or {@link File} does not exist or file size is\nlarger than {@link Integer#MAX_VALUE}.", "predict": "Reads the specified number of bytes from the specified file.\n\n@param file The file to read from.\n@param count The number of bytes to read.\n@return The bytes read from the file.\n@throws IOException If an I/O error occurs.\n\n    "}, {"ID": 1402, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CodedInput newInstance(final byte[] buf, final int off, final int len) { return new CodedInput(buf, off, len, false); }\n\n    ### Response: Create a new CodedInput wrapping the given byte array slice..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, false); }\n\n    ### Response:", "ground_truth": "Write bytes. append = false\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Write the given byte array slice to the specified file.\n\n    "}, {"ID": 1403, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CodedInput newInstance(final byte[] buf, final int off, final int len) { return new CodedInput(buf, off, len, false); }\n\n    ### Response: Create a new CodedInput wrapping the given byte array slice..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void appendBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, true); }\n\n    ### Response:", "ground_truth": "Appends bytes. append = true\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Append the given byte array slice to the end of the specified file.\n\n    "}, {"ID": 1404, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void moveFile(File src, File dest) throws IOException { copyFile(src, dest); if (!delete(src)) { throw new IOException(\"Failed to delete the src file '\" + src + \"' after copying.\"); } }\n\n    ### Response: Moves a file from src to dest.\nThis method is equals to \"copy -> delete.\"\n\n@param src\nAn existing file to move, must not be null.\n@param dest\nThe destination file, must not be null and exist.\n\n@throws IOException\nIf moving is failed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(final File src, final File dest) throws IOException { if (src.isDirectory()) { copyDir(src, dest); return; } if (dest.isDirectory()) { copyFileToDir(src, dest); return; } copyFile(src, dest); }\n\n    ### Response:", "ground_truth": "Smart copy. If source is a directory, copy it to destination.\nOtherwise, if destination is directory, copy source file to it.\nOtherwise, try to copy source file to destination file.\n\n@param src  source {@link File}\n@param dest destination {@link File}\n@throws IOException if there is an error copying.\n@see #copyDir(File, File)\n@see #copyFileToDir(File, File)\n@see #copyFile(File, File)", "predict": " Copies a file or directory from src to dest.\n\n@param src\nAn existing file or directory to copy, must not be null.\n@param dest\nThe destination file or directory, must not be null and exist.\n\n@throws IOException\nIf copying is failed."}, {"ID": 1405, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(File source, File dest) throws IOException { if (dest.isDirectory()) { dest = new File(dest + File.separator + source.getName()); } FileChannel in = null, out = null; try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(dest).getChannel(); long size = in.size(); MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); out.write(buf); } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } }\n\n    ### Response: Fast and simple file copy.\n\n@param source source file\n@param dest destination file or directory.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void delete(final File dest) throws IOException { if (dest.isDirectory()) { deleteDir(dest); return; } deleteFile(dest); }\n\n    ### Response:", "ground_truth": "Smart delete of destination file or directory.\n\n@throws IOException if there is an issue deleting the file/directory.\n@see #deleteFile(File)\n@see #deleteDir(File)", "predict": " Deletes a file or directory.\n\n@param dest file or directory to delete.\n\n    "}, {"ID": 1406, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String uniqueEnvironment(String prefix, String suffix, File directory) throws IOException { File tmpDir = UNIQUE_DIRECTORY_CREATOR.create(prefix, suffix, directory); String randomFilename = UUID.randomUUID().toString(); File envNameAsFile = new File(tmpDir, randomFilename); return envNameAsFile.getAbsolutePath(); }\n\n    ### Response: Creates a unique directory for housing a BDB environment, and returns\nits name.\n\n@param prefix a prefix for the temporary directory's name. Cannot be\nnull.\n@param suffix a suffix for the temporary directory's name.\n@return the environment name to use.\n@param directory the parent directory to use.\n\n@throws IOException if an error occurred in creating the temporary\ndirectory..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File createTempDirectory(final String prefix, final String suffix, final File tempDir) throws IOException { File file = createTempFile(prefix, suffix, tempDir); file.delete(); file.mkdir(); return file; }\n\n    ### Response:", "ground_truth": "Creates temporary directory.\n\n@see #createTempFile(String, String, File)", "predict": " Creates a temporary directory with a unique name.\n\n@param prefix a prefix for the temporary directory's name. Cannot be\nnull.\n@param suffix a suffix for the temporary directory's name.\n@param tempDir the parent directory to use.\n@return the temporary directory.\n\n@throws IOException if an error occurred in creating the temporary\ndirectory."}, {"ID": 1407, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isPureAscii(byte[] data) { if (data == null) { return false; } for (byte b : data) { if (b < 0x20) { return false; } } return true; }\n\n    ### Response: Test if the data in the array is pure ASCII\n@param data data to check\n@return true if there are only ASCII characters.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isBinary(final File file) throws IOException { byte[] bytes = readBytes(file, 128); for (byte b : bytes) { if (b < 32 && b != 9 && b != 10 && b != 13) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Checks the start of the file for ASCII control characters\n\n@param file {@link File}\n@return true if the the start of the {@link File} is ASCII control characters.", "predict": " Test if the file is binary\n@param file file to check\n@return true if the file is binary.\n\n    "}, {"ID": 1408, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyFile(File src, File dest) throws IOException { if (src == null) throw new NullPointerException(\"Source must not be null\"); if (dest == null) throw new NullPointerException(\"Destination must not be null\"); if (!src.exists()) throw new FileNotFoundException(\"Source '\" + src + \"' does not exist\"); if (!src.isFile()) throw new IOException(\"Source '\" + src + \"' is not a file\"); if (dest.exists()) throw new IOException(\"Destination '\" + dest + \"' is already exists\"); FileChannel in = null, out = null; try { in = new FileInputStream(src).getChannel(); out = new FileOutputStream(dest).getChannel(); in.transferTo(0, in.size(), out); } finally { try { in.close(); out.close(); } catch (IOException e) { // Ignore. } } if (src.length() != dest.length()) { throw new IOException(\"Failed to copy full contents from '\" + src + \"' to '\" + dest + \"'\"); } dest.setLastModified(src.lastModified()); }\n\n    ### Response: Copies a file to a new location preserving the file date.\n\n@param src\nAn existing file to copy, must not be null.\n@param dest\nThe new file, must not be null and exist.\n\n@throws IOException\nIf copying is failed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void checkDirCopy(final File srcDir, final File destDir) throws IOException { checkExists(srcDir); checkIsDirectory(srcDir); if (equals(srcDir, destDir)) { throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\"); } }\n\n    ### Response:", "ground_truth": "Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.\n\n@param srcDir  Source directory\n@param destDir Destination directory\n@throws IOException if any of the above conditions are not true.", "predict": " Checks if a directory can be copied to a new location.\n\n@param srcDir\nThe source directory, must not be null and exist.\n@param destDir\nThe destination directory, must not be null and exist.\n\n@throws IOException\nIf the directory cannot be copied."}, {"ID": 1409, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File parseParametersForWritableDirectory(Map<String, String> parameters, String parameterName) throws JournalException { String directoryString = parameters.get(parameterName); if (directoryString == null) { throw new JournalException(\"'\" + parameterName + \"' is required.\"); } File directory = new File(directoryString); if (!directory.exists()) { throw new JournalException(\"Directory '\" + directory + \"' does not exist.\"); } if (!directory.isDirectory()) { throw new JournalException(\"Directory '\" + directory + \"' is not a directory.\"); } if (!directory.canWrite()) { throw new JournalException(\"Directory '\" + directory + \"' is not writable.\"); } return directory; }\n\n    ### Response: Look in the parameters for the path to a writable directory. The\nparameter is required..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void checkFileCopy(final File srcFile, final File destFile) throws IOException { checkExists(srcFile); checkIsFile(srcFile); if (equals(srcFile, destFile)) { throw new IOException(\"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\"); } File destParent = destFile.getParentFile(); if (destParent != null && !destParent.exists()) { checkCreateDirectory(destParent); } }\n\n    ### Response:", "ground_truth": "Checks that file copy can occur.\n\n@param srcFile  Source {@link File}\n@param destFile Destination {@link File}\n@throws IOException if srcFile does not exist or is not a file or\nsrcFile and destFile are equal or cannot create ancestor directories.", "predict": " Check if the source file exists, is a file, and is not equal to the destination file. If the destination file's parent directory does not exist, create it.\n\n    "}, {"ID": 1410, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void printUsageInfo() { StringBuilder usage = new StringBuilder(); usage.append(\" System Properties: \\n\"); usage.append(\" -DselionHome=<folderPath>: \\n\"); usage.append(\" Path of SeLion home directory. Defaults to <user.home>/.selion2/ \\n\"); usage.append(\" -D[property]=[value]: \\n\"); usage.append(\" Any other System Property you wish to pass to the JVM \\n\"); System.out.print(usage.toString()); }\n\n    ### Response: Print the usage of SeLion Grid jar.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void printUsage(final String commandName) { final StringBuilder usage = new StringBuilder(commandName); for (final Option option : options) { if (option.shortName != null) { usage.append(\" [-\").append(option.shortName).append(\"]\"); } else if (option.longName != null) { usage.append(\" [--\").append(option.longName).append(\"]\"); } } for (final Param param : params) { usage.append(\" \").append(param.label); } System.out.println(usage); }\n\n    ### Response:", "ground_truth": "Prints the usage line.", "predict": " Print the usage of the command line tool."}, {"ID": 1411, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    MethodDescriptor getMethodDescriptor(TypeCache.CachedType<?> cachedType, String signature) { MethodDescriptor methodDescriptor = cachedType.getMethod(signature); if (methodDescriptor == null) { if (signature.startsWith(CONSTRUCTOR_METHOD)) { methodDescriptor = scannerContext.getStore().create(ConstructorDescriptor.class); } else { methodDescriptor = scannerContext.getStore().create(MethodDescriptor.class); } methodDescriptor.setSignature(signature); cachedType.addMember(signature, methodDescriptor); } return methodDescriptor; }\n\n    ### Response: Return the method descriptor for the given type and method signature.\n\n@param cachedType\nThe containing type.\n@param signature\nThe method signature.\n@return The method descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Method resolveActionMethod(final Class<?> actionClass, final String methodName) { MethodDescriptor methodDescriptor = ClassIntrospector.get().lookup(actionClass).getMethodDescriptor(methodName, false); if (methodDescriptor == null) { throw new MadvocException(\"Public method not found: \" + actionClass.getSimpleName() + \"#\" + methodName); } return methodDescriptor.getMethod(); }\n\n    ### Response:", "ground_truth": "Resolves action method for given action class ane method name.", "predict": " Resolve the action method for the given action class and method name.\n\n@param actionClass\nThe action class.\n@param methodName\nThe method name.\n@return The action method.\n\n    "}, {"ID": 1412, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SqlStringFilter createSqlStringFilter(ActionRuntime runtime) { final Method actionMethod = runtime.getExecuteMethod(); return newRomanticTraceableSqlStringFilter(actionMethod, () -> { return buildSqlMarkingAdditionalInfo(); // lazy because it may be auto-login later }); }\n\n    ### Response: Create the filter of SQL string for DBFlute.\n@param runtime The runtime meta of action execute. (NotNull)\n@return The filter of SQL string. (NullAllowed: if null, no filter).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime registerAction(final Class actionClass, final String actionMethodName, final ActionDefinition actionDefinition) { Method actionMethod = resolveActionMethod(actionClass, actionMethodName); return registerAction(actionClass, actionMethod, actionDefinition); }\n\n    ### Response:", "ground_truth": "Registers action with provided action class and method name.\n@see #registerAction(Class, Method, ActionDefinition)", "predict": " Register the action to the runtime meta of action execute.\n@param actionClass The class of action. (NotNull)\n@param actionMethodName The method name of action. (NotNull)\n@param actionDefinition The definition of action. (NotNull)\n@return The runtime meta of action execute. (NotNull)\n\n    "}, {"ID": 1413, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void overrideDatabaseTerminationToken(Map<Object, Object> props) { String overrideTermToken = null; String platformClassName = _dbMgr.getDatabasePlatformClassName(_pui); if (platformClassName != null) { overrideTermToken = platformTerminationToken.get(platformClassName); } if (overrideTermToken != null) { String existing = (String) props.get(PersistenceUnitProperties.TARGET_DATABASE_PROPERTIES); if (existing != null) { existing = existing + \",\"; } else { existing = \"\"; } existing = (existing + \"StoredProcedureTerminationToken=\" + overrideTermToken); props.put(PersistenceUnitProperties.TARGET_DATABASE_PROPERTIES, existing); } }\n\n    ### Response: Helper method that will override the termination token if the database detected is in our\nplatformTerminationToken list..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPathAlias(final String alias, final String path) { final String existing = pathAliases.put(alias, path); if (existing != null) { throw new MadvocException(\"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing); } }\n\n    ### Response:", "ground_truth": "Registers new path alias.", "predict": " Registers a new path alias for the given alias and path. If an alias with the same name already exists, an exception will be thrown.\n\n    "}, {"ID": 1414, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized boolean addUnique(int key, int value) { if (count == capacity) { if (fixedSize) { return false; } else { doubleCapacity(); } } if (!sorted) { fastQuickSort(); } targetSearchValue = sortOnValues ? value : key; int i = binaryEmptySlotSearch(); if (i == -1) { return false; } hasChanged = true; if (count != i) { moveRows(i, i + 1, count - i); } keys[i] = key; values[i] = value; count++; return true; }\n\n    ### Response: Adds a pair, ensuring no duplicate key xor value already exists in the\ncurrent search target column.\n@param key the key\n@param value the value\n@return true or false depending on success.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean next() { if (!looping) { return false; } if (last) { return false; } if (count == 0) { value = start; first = true; } else { value += step; first = false; } count++; last = isLastIteration(value + step); return true; }\n\n    ### Response:", "ground_truth": "Iterates to next value at the beginning of the loop.", "predict": " Moves the search value to the next value in the sequence.\n@return true or false depending on success.\n\n    "}, {"ID": 1415, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final synchronized int readData(final long startPos, final byte[] buffer, final int offset, final int len) throws IOException { seek(startPos); return read(buffer, offset, len); }\n\n    ### Response: Read file data, starting at the specified position.\n\n@return the number of bytes read into the buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CharArraySequence from(final char[] value, final int offset, final int len) { final char[] buffer = new char[value.length]; System.arraycopy(value, offset, buffer, 0, len); return new CharArraySequence(buffer); }\n\n    ### Response:", "ground_truth": "Static constructor that creates a char sequence by making a copy of provided char array.", "predict": " Create a new CharArraySequence from the specified character array.\n\n@param value the character array to copy from\n@param offset the starting offset in the character array\n@param len the number of characters to copy\n@return the new CharArraySequence\n\n    "}, {"ID": 1416, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class forName(String name) throws ClassNotFoundException { // try with caller classloader ClassLoader loader = getClassLoaderContextAt(3); try { return Class.forName(name, true, loader); } catch (ClassNotFoundException e) { // try with context classloader if set & different ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); if (contextLoader == null || contextLoader == loader) { throw e; } else { return Class.forName(name, true, contextLoader); } } }\n\n    ### Response: Loads a specified class. First, the caller's classloader is used to load\nthe class and if it fails the thread's context classloader is used to\nload the specified class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object execute() throws Exception { String methodName = ProxyTarget.targetMethodName(); Class[] argTypes = ProxyTarget.createArgumentsClassArray(); Object[] args = ProxyTarget.createArgumentsArray(); // lookup method on target object class (and not #targetClass!() Class type = _target.getClass(); Method method = type.getMethod(methodName, argTypes); // remember context classloader ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Object result; try { // change class loader Thread.currentThread().setContextClassLoader(type.getClassLoader()); // invoke result = method.invoke(_target, args); } finally { // return context classloader Thread.currentThread().setContextClassLoader(contextClassLoader); } return ProxyTarget.returnValue(result); }\n\n    ### Response:", "ground_truth": "Looks up for method in target object and invokes it using reflection.", "predict": " Executes the target method on the target object. The method name, argument types, and arguments are obtained from the ProxyTarget class. The target object's class is obtained using the #targetClass() method, which is not recommended. Instead, the target object's class should be obtained using the #getClass() method. The method is then looked up on the target object's class using the #getMethod() method. The context classloader is saved and changed to the target object's classloader using the #setContextClassLoader() method. The method is then invoked on the target object using the #invoke() method. If an exception is thrown during the method invocation, it is caught and rethrown as an exception of type Exception. Finally, the context classloader is returned to its original value using the #setContextClassLoader() method and the result is returned using the ProxyTarget#returnValue() method."}, {"ID": 1417, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean startsWith(Bytes prefix) { Objects.requireNonNull(prefix, \"startWith(Bytes prefix) cannot have null parameter\"); if (prefix.length > this.length) { return false; } else { int end = this.offset + prefix.length; for (int i = this.offset, j = prefix.offset; i < end; i++, j++) { if (this.data[i] != prefix.data[j]) { return false; } } } return true; }\n\n    ### Response: Checks if this has the passed prefix\n\n@param prefix is a Bytes object to compare to this\n@return true or false\n@since 1.1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final boolean matchUpperCase(final char[] uppercaseTarget) { if (ndx + uppercaseTarget.length > total) { return false; } int j = ndx; for (int i = 0; i < uppercaseTarget.length; i++, j++) { final char c = CharUtil.toUpperAscii(input[j]); if (c != uppercaseTarget[i]) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Matches char buffer given in uppercase with content at current location, that will\nbe converted to upper case to make case-insensitive matching.", "predict": " Checks if the input matches the uppercase target\n\n@param uppercaseTarget is the target string to compare to\n@return true or false\n@since 1.1.0."}, {"ID": 1418, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Interval fromTo(int from, int to) { if (from <= to) { return Interval.fromToBy(from, to, 1); } return Interval.fromToBy(from, to, -1); }\n\n    ### Response: Returns an Interval starting from the value from to the specified value to with a step value of 1..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final CharSequence charSequence(final int from, final int to) { if (from == to) { return CharArraySequence.EMPTY; } return CharArraySequence.of(input, from, to - from); }\n\n    ### Response:", "ground_truth": "Creates char sub-sequence from the input.", "predict": " Returns a CharArraySequence that represents the substring of the input character array starting from the specified index from and ending at the specified index to. If from and to are equal, an empty CharArraySequence is returned."}, {"ID": 1419, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassLoader getDefaultClassLoader(Class<?> clazz) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (classLoader == null) { classLoader = clazz.getClassLoader(); } return classLoader; }\n\n    ### Response: Determines the 'default' classloader. That is context class loader, if\ndefined, or else classloader which loaded the given class.\n\n@param clazz\t\tto which classloader to fall back\n@return classloader.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { URLClassLoader urlClassLoader = (URLClassLoader) classLoader; URL[] allURLS = urlClassLoader.getURLs(); Collections.addAll(urls, allURLS); break; } URL classUrl = classModuleUrl(classLoader, clazz); if (classUrl != null) { urls.add(classUrl); } classUrl = classModuleUrl(classLoader, ClassPathURLs.class); if (classUrl != null) { urls.add(classUrl); } ModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor(); if (moduleDescriptor != null) { moduleDescriptor.requires().forEach(req -> { ModuleLayer.boot() .findModule(req.name()) .ifPresent(mod -> { ClassLoader moduleClassLoader = mod.getClassLoader(); if (moduleClassLoader != null) { URL url = moduleClassLoader.getResource(MANIFEST); if (url != null) { url = fixManifestUrl(url); urls.add(url); } } }); }); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); }\n\n    ### Response:", "ground_truth": "Returns urls for the classloader.\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": " Returns the URLs of the given classloader and its parent classloaders.\n\n@param classLoader\tto get URLs from\n@param clazz\t\tto which classloader to fall back\n@return array of URLs.\n\n    "}, {"ID": 1420, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function build(Email $email): Email { foreach ($this->parts as $part) { $resolver = $this->registry->getResolverForPart($part); $resolver->addPart($email, $part); } $this->parts = []; return $email; }\n\n    ### Response: Build email from parts.\n\n@param Email $email\n\n@return Email.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Email bcc(final EmailAddress... bccs) { this.bcc = ArraysUtil.join(this.bcc, valueOrEmptyArray(bccs)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends one or more BCC addresses.\n\n@param bccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " Add bcc recipients to the email.\n\n@param bccs The bcc recipients to add.\n\n@return This email object."}, {"ID": 1421, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:hiddenfield\") public <T, U extends T> void register(final Class<T> type, final Set<EventHandler<U>> handlers) { this.handlers.put(type, new ExceptionHandlingEventHandler<>( new BroadCastEventHandler<>(handlers), this.errorHandler)); }\n\n    ### Response: Register a new event handler.\n\n@param type     Message type to process with this handler.\n@param handlers A set of handlers that process that type of message.\n@param       Message type.\n@param       Type of message that event handler supports. Must be a subclass of T..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void register(final Class type, final TypeJsonSerializer typeJsonSerializer) { map.put(type, typeJsonSerializer); cache.clear(); }\n\n    ### Response:", "ground_truth": "Registers new serializer.", "predict": " Register a new type serializer.\n\n@param type                Type to register a serializer for.\n@param typeJsonSerializer  Type serializer to register."}, {"ID": 1422, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class normalizeType(Class type) { SimonType simonType = SimonTypeFactory.getValueFromType(type); Class normalizedType; if (simonType == null) { simonType = SimonTypeFactory.getValueFromSampleType(type); if (simonType == null) { normalizedType = type; } else { normalizedType = simonType.getSampleType(); } } else { normalizedType = simonType.getType(); } return normalizedType; }\n\n    ### Response: Get the main interface of the type.\n\n@param type Implementation class\n@return Main interface class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeJsonSerializer lookupSerializer(final Class type) { TypeJsonSerializer tjs = map.get(type); if (tjs == null) { if (defaultSerializerMap != null) { tjs = defaultSerializerMap.map.get(type); } } return tjs; }\n\n    ### Response:", "ground_truth": "Get type serializer from map. First the current map is used.\nIf element is missing, default map will be used, if exist.", "predict": " Get the serializer for the given type.\n\n@param type Class to get serializer for\n@return Serializer for the given type or null if not found."}, {"ID": 1423, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookie[] parseCookieHeader( String header ) { if ((header == null) || (header.length() < 1)) { return (new Cookie[0]); } ArrayList<Cookie> cookies = new ArrayList<Cookie>(); while (header.length() > 0) { int semicolon = header.indexOf(';'); if (semicolon < 0) { semicolon = header.length(); } if (semicolon == 0) { break; } String token = header.substring(0, semicolon); if (semicolon < header.length()) { header = header.substring(semicolon + 1); } else { header = \"\"; } try { int equals = token.indexOf('='); if (equals > 0) { String name = token.substring(0, equals).trim(); String value = token.substring(equals + 1).trim(); cookies.add(new Cookie(name, value)); } } catch (Throwable e) { // do nothing ?! } } return cookies.toArray(new Cookie[cookies.size()]); }\n\n    ### Response: Parse a cookie header into an array of cookies according to RFC 2109.\n\n@param header Value of an HTTP \"Cookie\" header\n@return the cookies.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parseRequestStream(final InputStream inputStream, final String encoding) throws IOException { setParsed(); MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream); input.readBoundary(); while (true) { FileUploadHeader header = input.readDataHeader(encoding); if (header == null) { break; } if (header.isFile) { String fileName = header.fileName; if (fileName.length() > 0) { if (header.contentType.indexOf(\"application/x-macbinary\") > 0) { input.skipBytes(128); } } FileUpload newFile = fileUploadFactory.create(input); newFile.processStream(); if (fileName.length() == 0) { // file was specified, but no name was provided, therefore it was not uploaded if (newFile.getSize() == 0) { newFile.size = -1; } } putFile(header.formFieldName, newFile); } else { // no file, therefore it is regular form parameter. FastByteArrayOutputStream fbos = new FastByteArrayOutputStream(); input.copyAll(fbos); String value = encoding != null ? new String(fbos.toByteArray(), encoding) : new String(fbos.toByteArray()); putParameter(header.formFieldName, value); } input.skipBytes(1); input.mark(1); // read byte, but may be end of stream int nextByte = input.read(); if (nextByte == -1 || nextByte == '-') { input.reset(); break; } input.reset(); } }\n\n    ### Response:", "ground_truth": "Extracts uploaded files and parameters from the request data.", "predict": " Parse a request stream containing multipart/form-data content.\n\n@param inputStream the input stream to parse\n@param encoding the encoding to use for decoding the request stream\n@throws IOException if an I/O error occurs while parsing the request stream\n\n    "}, {"ID": 1424, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParameter(final String _key) { String value = null; if (this.parameters != null) { final String[] values = this.parameters.get(_key); if (values != null && values.length > 0) { value = values[0]; } } return value; }\n\n    ### Response: Method to get a parameter from the context.\n\n@param _key Key for the parameter\n@return String value of the parameter.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParameter(final String paramName) { if (requestParameters == null) { return null; } String[] values = requestParameters.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; }\n\n    ### Response:", "ground_truth": "Returns single value of a parameter. If parameter name is used for\nmore then one parameter, only the first one will be returned.\n\n@return parameter value, or null if not found", "predict": " Method to get a parameter from the request.\n\n@param paramName Name of the parameter\n@return String value of the parameter."}, {"ID": 1425, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParamString(String paramName) { Object paramValue = getParam(paramName); if (paramValue == null) { return null; } return paramValue.toString(); }\n\n    ### Response: Get the value of the parameter with the given name belonging to this service as a\nString. If the parameter is not found, null is returned.\n\n@param paramName Name of parameter to find.\n@return          Parameter found as a String if found, otherwise null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getParameterValues(final String paramName) { if (requestParameters == null) { return null; } return requestParameters.get(paramName); }\n\n    ### Response:", "ground_truth": "Returns all values all of the values the given request parameter has.", "predict": " Get the values of the parameter with the given name belonging to this service as an array of Strings. If the parameter is not found, null is returned.\n\n@param paramName Name of parameter to find.\n@return          Parameter found as an array of Strings if found, otherwise null."}, {"ID": 1426, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParameter(String name) { String[] values = parameters.get(name); if (values == null) { return null; } if (values.length == 0) { return \"\"; } return values[0]; }\n\n    ### Response: Get a single parameter of the parsed URI\n\n@param name parameter name\n@return the value of the parameter or null\nif no such parameter is stored.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FileUpload getFile(final String paramName) { if (requestFiles == null) { return null; } FileUpload[] values = requestFiles.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; }\n\n    ### Response:", "ground_truth": "Returns uploaded file.\n@param paramName parameter name of the uploaded file\n@return uploaded file or null if parameter name not found", "predict": " Get the first file upload parameter with the given name\n\n@param paramName parameter name\n@return the first file upload parameter with the given name or null if no such parameter is found."}, {"ID": 1427, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParamString(String paramName) { Object paramValue = getParam(paramName); if (paramValue == null) { return null; } return paramValue.toString(); }\n\n    ### Response: Get the value of the parameter with the given name belonging to this service as a\nString. If the parameter is not found, null is returned.\n\n@param paramName Name of parameter to find.\n@return          Parameter found as a String if found, otherwise null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FileUpload[] getFiles(final String paramName) { if (requestFiles == null) { return null; } return requestFiles.get(paramName); }\n\n    ### Response:", "ground_truth": "Returns all uploaded files the given request parameter has.", "predict": " Get the uploaded files with the given parameter name. If the parameter is not found, null is returned.\n\n@param paramName Name of parameter to find.\n@return          Uploaded files found as an array of FileUpload objects if found, otherwise null."}, {"ID": 1428, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(FilterConfig filterConfig) throws ServletException { this.filterConfig = filterConfig; this.encoding = filterConfig.getInitParameter(\"encoding\"); String value = filterConfig.getInitParameter(\"ignore\"); if (value == null) this.ignore = true; else if (value.equalsIgnoreCase(\"true\")) this.ignore = true; else if (value.equalsIgnoreCase(\"yes\")) this.ignore = true; else this.ignore = false; }\n\n    ### Response: Place this filter into service.\n\n@param filterConfig The filter configuration object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final FilterConfig filterConfig) { this.filterConfig = filterConfig; this.encoding = filterConfig.getInitParameter(\"encoding\"); if (this.encoding == null) { this.encoding = JoddCore.encoding; } this.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true); }\n\n    ### Response:", "ground_truth": "Place this filter into service.\n\n@param filterConfig The filter configuration object", "predict": " Initializes the filter with the given filter configuration.\n\n@param filterConfig The filter configuration object."}, {"ID": 1429, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int divide(char separator, Text[] parts) { int pointer = pos; int limit = pos + len; int mark = pointer; int count = 0; while (pointer < limit) { if (chars[pointer] == separator) { parts[count].strain(chars, mark, pointer - mark); mark = pointer + 1; count++; if (count == parts.length - 1) { break; } } pointer++; } if(limit > mark) { parts[count].strain(chars, mark, limit - mark); count++; } return count; }\n\n    ### Response: Divides text into parts using given separator and writes results\ninto the parts array.\n\n@param separator the character used for splitting\n@param parts the array used to hold parts of the text\n@return the number of parts..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parse(final DbSqlBuilder sqlBuilder, final String template) { int length = template.length(); int last = 0; while (true) { int mark = template.indexOf('$', last); if (mark == -1) { if (last < length) { sqlBuilder.appendRaw(template.substring(last)); } break; } int escapesCount = countEscapes(template, mark); // check if escaped if (escapesCount > 0) { boolean isEscaped = escapesCount % 2 != 0; int escapesToAdd = escapesCount >> 1; sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$'); if (isEscaped) { last = mark + 1; continue; } } else { sqlBuilder.appendRaw(template.substring(last, mark)); } int end; if (template.startsWith(MACRO_TABLE, mark)) { mark += MACRO_TABLE.length(); end = findMacroEnd(template, mark); onTable(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_COLUMN, mark)) { mark += MACRO_COLUMN.length(); end = findMacroEnd(template, mark); onColumn(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_MATCH, mark)) { mark += MACRO_MATCH.length(); end = findMacroEnd(template, mark); onMatch(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_VALUE, mark)) { mark += MACRO_VALUE.length(); end = findMacroEnd(template, mark); onValue(sqlBuilder, template.substring(mark, end)); } else { mark++; // reference found end = mark; // find macro end while (end < length) { if (!isReferenceChar(template, end)) { break; } end++; } onReference(sqlBuilder, template.substring(mark, end)); end--; } end++; last = end; } }\n\n    ### Response:", "ground_truth": "Parses template and returns generated sql builder.", "predict": " Parses the given SQL template and generates SQL statements using the given DbSqlBuilder.\n\n@param sqlBuilder the DbSqlBuilder used to generate SQL statements\n@param template the SQL template to parse\n@throws IllegalArgumentException if the template is invalid\n\n    "}, {"ID": 1430, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int validateRange(final int startIndex, int endIndex) { if (startIndex < 0) { throw new StringIndexOutOfBoundsException(startIndex); } if (endIndex > size) { endIndex = size; } if (startIndex > endIndex) { throw new StringIndexOutOfBoundsException(\"end < start\"); } return endIndex; }\n\n    ### Response: Validates parameters defining a range of the builder.\n\n@param startIndex  the start index, inclusive, must be valid\n@param endIndex  the end index, exclusive, must be valid except\nthat if too large it is treated as end of string\n@return the new string\n@throws IndexOutOfBoundsException if the index is invalid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int findMacroEnd(final String template, final int fromIndex) { int endIndex = template.indexOf('}', fromIndex); if (endIndex == -1) { throw new DbSqlBuilderException(\"Template syntax error, some macros are not closed. Error at: '...\" + template.substring(fromIndex)); } return endIndex; }\n\n    ### Response:", "ground_truth": "Finds macros end.", "predict": " Finds the end index of a macro in a SQL template.\n\n@param template  the SQL template\n@param fromIndex  the start index of the macro to find\n@return the end index of the macro\n@throws DbSqlBuilderException if the macro is not closed\n\n    "}, {"ID": 1431, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int parseIndent(final String template, final String indentOf) { int indent = 0; int indexOf = template.indexOf(indentOf); while ((indexOf >= 0) && (template.charAt(indexOf) != '\\n')) { if (template.charAt(indexOf) == '\\t') { indent++; } indexOf--; } return indent; }\n\n    ### Response: Parses the given XML and determines the indent of the given String namespaces that Metawidget introduces..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int countEscapes(final String template, int macroIndex) { macroIndex--; int escapeCount = 0; while (macroIndex >= 0) { if (template.charAt(macroIndex) != ESCAPE_CHARACTER) { break; } escapeCount++; macroIndex--; } return escapeCount; }\n\n    ### Response:", "ground_truth": "Count escapes to the left.", "predict": " Counts the number of escape characters in the given XML template before the given macro index."}, {"ID": 1432, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String toVersionString(@Nonnull final List<String> groups) { final StringBuilder builder = new StringBuilder(6); int count = 0; for (final String segment : groups) { if (EMPTY_GROUP.equals(segment)) { break; } else { if (count > 0) { builder.append(SEPARATOR); } builder.append(segment); } count++; } return builder.toString(); }\n\n    ### Response: Converts the given list of numbers in a version string. The groups of the version number will be separated by a\ndot.\n\n@param groups\nlist of numbers of a version number\n@return a formated version string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) { if (queryMap.isEmpty()) { return StringPool.EMPTY; } int queryMapSize = queryMap.size(); StringBand query = new StringBand(queryMapSize * 4); int count = 0; for (Map.Entry<String, ?> entry : queryMap) { String key = entry.getKey(); key = URLCoder.encodeQueryParam(key, encoding); Object value = entry.getValue(); if (value == null) { if (count != 0) { query.append('&'); } query.append(key); count++; } else { if (count != 0) { query.append('&'); } query.append(key); count++; query.append('='); String valueString = URLCoder.encodeQueryParam(value.toString(), encoding); query.append(valueString); } } return query.toString(); }\n\n    ### Response:", "ground_truth": "Builds a query string from given query map.", "predict": " Builds a query string from the given HttpMultiMap. The query string will be encoded using the given encoding.\n\n@param queryMap\nthe query parameters\n@param encoding\nthe encoding to use for encoding the query string\n@return the query string\n\n    "}, {"ID": 1433, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) { final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap(); if (StringUtil.isBlank(query)) { return queryMap; } int lastNdx = 0; while (lastNdx < query.length()) { int ndx = query.indexOf('&', lastNdx); if (ndx == -1) { ndx = query.length(); } final String paramAndValue = query.substring(lastNdx, ndx); ndx = paramAndValue.indexOf('='); if (ndx == -1) { queryMap.add(paramAndValue, null); } else { String name = paramAndValue.substring(0, ndx); if (decode) { name = URLDecoder.decodeQuery(name); } String value = paramAndValue.substring(ndx + 1); if (decode) { value = URLDecoder.decodeQuery(value); } queryMap.add(name, value); } lastNdx += paramAndValue.length() + 1; } return queryMap; }\n\n    ### Response:", "ground_truth": "Parses query from give query string. Values are optionally decoded.", "predict": " Parse a query string into a multi-value map.  If the query string is null or empty, an empty map is returned.  If the query string contains a parameter without a value, the value is set to null.  If the decode parameter is true, the parameter and value are decoded using the URLDecoder class.\n\n@param query the query string to parse\n@param decode true to decode the parameter and value using the URLDecoder class\n@return a multi-value map of the query parameters and values"}, {"ID": 1434, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toJavaDateTimeFormat(String strftime) { if (!StringUtils.contains(strftime, '%')) { return replaceL(strftime); } StringBuilder result = new StringBuilder(); for (int i = 0; i < strftime.length(); i++) { char c = strftime.charAt(i); if (c == '%') { c = strftime.charAt(++i); boolean stripLeadingZero = false; if (c == '-') { stripLeadingZero = true; c = strftime.charAt(++i); } if (stripLeadingZero) { result.append(CONVERSIONS[c].substring(1)); } else { result.append(CONVERSIONS[c]); } } else if (Character.isLetter(c)) { result.append(\"'\"); while (Character.isLetter(c)) { result.append(c); if (++i < strftime.length()) { c = strftime.charAt(i); } else { c = 0; } } result.append(\"'\"); --i; // re-consume last char } else { result.append(c); } } return replaceL(result.toString()); }\n\n    ### Response: Parses a string in python strftime format, returning the equivalent string in java date time format.\n\n@param strftime\n@return date formatted as string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); }\n\n    ### Response:", "ground_truth": "Makes nice header names.", "predict": " Converts a header name to a valid HTTP header parameter name.\n\n@param headerName\n@return valid HTTP header parameter name."}, {"ID": 1435, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getRequestHeaderContentType() { String contentType = getRequestHeaderValue(\"Content-Type\"); if (contentType != null) { // remove parameter (Content-Type := type \"/\" subtype *[\";\" parameter] ) int index = contentType.indexOf(';'); if (index > 0) contentType = contentType.substring(0, index); contentType = contentType.trim(); } return contentType; }\n\n    ### Response: get Content-Type from URLConnection.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String extractMediaType(final String contentType) { int index = contentType.indexOf(';'); if (index == -1) { return contentType; } return contentType.substring(0, index); }\n\n    ### Response:", "ground_truth": "Extracts media-type from value of \"Content Type\" header.", "predict": " Extract media type from content type string."}, {"ID": 1436, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void doResolveOnto(Appendable appendable) throws IOException { doRender(appendable); content = appendable.toString(); if (kind == null) { resolved = StringData.forValue(content); } else { resolved = UnsafeSanitizedContentOrdainer.ordainAsSafe(content, kind); } }\n\n    ### Response: Resolves the value by writing it to appendable\n\n@param appendable An Appendable that you can call toString on to get the appended value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String toHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visit(renderer); return appendable.toString(); }\n\n    ### Response:", "ground_truth": "Renders node to appendable.", "predict": "Renders the given node to HTML and appends it to the given appendable.\n\n@param node The node to render.\n@param appendable An Appendable that you can call append on to append the rendered HTML.\n@return The rendered HTML as a string."}, {"ID": 1437, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void doResolveOnto(Appendable appendable) throws IOException { doRender(appendable); content = appendable.toString(); if (kind == null) { resolved = StringData.forValue(content); } else { resolved = UnsafeSanitizedContentOrdainer.ordainAsSafe(content, kind); } }\n\n    ### Response: Resolves the value by writing it to appendable\n\n@param appendable An Appendable that you can call toString on to get the appended value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String toInnerHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visitChildren(renderer); return appendable.toString(); }\n\n    ### Response:", "ground_truth": "Renders node children to appendable.", "predict": "Renders the given node and its children to HTML and appends the result to the given Appendable.\n\n@param node The node to render.\n@param appendable An Appendable that you can call append on to append the rendered HTML.\n@return The rendered HTML as a string."}, {"ID": 1438, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected List<ServletDefinition> initJawrSpringControllers( ServletContext servletContext) throws ServletException { SpringControllerBundleProcessor springBundleProcessor = new SpringControllerBundleProcessor(); return springBundleProcessor.initJawrSpringServlets(servletContext); }\n\n    ### Response: Initialize the Jawr spring controller\n\n@param servletContext\nthe servlet context\n@return the Jawr spring controller\n@throws ServletException\nif a servlet exception occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void configureWith(final ServletContext servletContext) { webAppClassName = servletContext.getInitParameter(PARAM_MADVOC_WEBAPP); paramsFiles = Converter.get().toStringArray(servletContext.getInitParameter(PARAM_MADVOC_PARAMS)); madvocConfiguratorClassName = servletContext.getInitParameter(PARAM_MADVOC_CONFIGURATOR); }\n\n    ### Response:", "ground_truth": "Configures Madvoc by reading context init parameters.", "predict": " Configure the Madvoc servlet\n\n@param servletContext\nthe servlet context\n@throws ServletException\nif a servlet exception occurs.\n\n    "}, {"ID": 1439, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { if (_refs != null) { _refs.clear(); _refCount = 0; } _classRefs.clear(); _typeRefs = null; _offset = 0; _isPacket = false; _isUnshared = false; }\n\n    ### Response: Resets all counters and references.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void reset() { this.ndx = 0; this.textLen = 0; this.path = new Path(); this.notFirstObject = false; if (useAltPaths) { path.altPath = new Path(); } if (classMetadataName != null) { mapToBean = createMapToBean(classMetadataName); } }\n\n    ### Response:", "ground_truth": "Resets JSON parser, so it can be reused.", "predict": " Resets all counters and references.\n\n    "}, {"ID": 1440, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function(factoryName, object) { if (_.isUndefined(object)) { object = factoryName; factoryName = undefined; } var that = this; return function() { var factory = !_.isUndefined(factoryName) ? that.getFactory(factoryName) : that.getDefaultFactory(); var params = _.isFunction(object) ? object.call(that) : object; return _.isFunction(factory) ? factory(params) : factory.create(params); } }\n\n    ### Response: Creates object creator\n\n@param {string}    factoryName Factory name\n@param {*|factory} object      Object or its factory function\n@returns {Function} Object     creator\n\n@this {Injector}\n@private.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonParser lazy(final boolean lazy) { this.lazy = lazy; this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER; this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER; return this; }\n\n    ### Response:", "ground_truth": "Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\nIn the lazy mode, not everything is parsed, but some things are left lazy.\nThis way we gain performance, especially on partial usage of the whole JSON.\nHowever, be aware that parser holds the input memory until the returned\nobjects are disposed.", "predict": " Sets lazy mode for the parser\n\n@param {boolean} lazy Lazy mode\n@return {JsonParser} This instance\n@private."}, {"ID": 1441, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getVariableType(String type) throws IOException { if (getVariableTypes() != null) { String newType = getVariableTypes().get(type); if (newType != null) return newType; } return type; }\n\n    ### Response: If the type argument needs to be mapped to a new variable type class,\nreturns the new class name; otherwise returns the unmodified argument..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class replaceWithMappedTypeForPath(final Class target) { if (mappings == null) { return target; } Class newType; // first try alt paths Path altPath = path.getAltPath(); if (altPath != null) { if (!altPath.equals(path)) { newType = mappings.get(altPath); if (newType != null) { return newType; } } } // now check regular paths newType = mappings.get(path); if (newType != null) { return newType; } return target; }\n\n    ### Response:", "ground_truth": "Replaces type with mapped type for current path.", "predict": " If the target argument needs to be mapped to a new class based on the current path,\nreturns the new class; otherwise returns the unmodified argument."}, {"ID": 1442, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> List<T> getComponentInstancesOfType(Class<T> componentType) { return container.getComponentInstancesOfType(componentType); }\n\n    ### Response: Returns list of components of specific type.\n\n@param componentType\ncomponent type\n@return List of Object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> List<T> parseAsList(final String string, final Class<T> componentType) { return new JsonParser() .map(JsonParser.VALUES, componentType) .parse(string); }\n\n    ### Response:", "ground_truth": "Parses input JSON to a list with specified component type.", "predict": " Parses a string as a list of components of specific type.\n\n@param string\nstring to be parsed\n@param componentType\ncomponent type\n@return List of Object."}, {"ID": 1443, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> MultipleRequestBuilder<K, V> newMultipleRequest(Key.Type<K> keyType, Class<V> valueType) { return new MultipleRequestBuilderImpl<K, V>(newViewRequestParameters(keyType.getType(), valueType)); }\n\n    ### Response: Create a new builder for multiple unpaginated requests on the view.\n\n@param keyType   {@link com.cloudant.client.api.views.Key.Type} of the key emitted by the\nview\n@param valueType class of the type of value emitted by the view\n@param        type of key emitted by the view\n@param        type of value emitted by the view\n@return a new {@link MultipleRequestBuilder} for the database view specified by this\nViewRequestBuilder.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> Map<K, V> parseAsMap( final String string, final Class<K> keyType, final Class<V> valueType) { return new JsonParser() .map(JsonParser.KEYS, keyType) .map(JsonParser.VALUES, valueType) .parse(string); }\n\n    ### Response:", "ground_truth": "Parses input JSON to a list with specified key and value types.", "predict": " Parse the given JSON string as a map of key-value pairs.\n\n@param string    the JSON string to parse\n@param keyType   class of the type of key in the map\n@param valueType class of the type of value in the map\n@return a map of key-value pairs parsed from the JSON string\n@throws IOException if the JSON string cannot be parsed"}, {"ID": 1444, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Object toSafeJsonValue(Object value) { if (value == null) { return null; } else { if (value instanceof Boolean || value instanceof String || value instanceof Number) { return value; } if (value instanceof Iterable) { Iterable iterable = (Iterable) value; List answer = new ArrayList<>(); for (Object item : iterable) { Object itemJson = toSafeJsonValue(item); if (itemJson != null) { answer.add(itemJson); } } return answer; } if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } value = Proxies.unwrap(value); if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } if (isJsonObject(value)) { return value; } return value.toString(); } }\n\n    ### Response: Lets return a safe JSON value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object resolveLazyValue(Object value) { if (value instanceof Supplier) { value = ((Supplier)value).get(); } return value; }\n\n    ### Response:", "ground_truth": "Resolves lazy value during the parsing runtime.", "predict": " This method resolves a lazy value by calling the supplier if it is a supplier."}, {"ID": 1445, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String formatXPathForJavaXPath(String xpath) throws Exception { String newXPath = \"\"; if (xpath.startsWith(\"xpath=\")) { xpath = xpath.replace(\"xpath=\", \"\"); } boolean convertIndicator = true; boolean onSlash = false; boolean onSingleQuote = false; boolean onDoubleQuote = false; for (int i = 0; i < xpath.length(); i++) { char c = xpath.charAt(i); if (c == '/') { if (!onSingleQuote && !onDoubleQuote) { if (convertIndicator) { if (!onSlash) { onSlash = true; } else { onSlash = false; } } else { convertIndicator = true; onSlash = true; } } } else if (c == '[') { if (!onSingleQuote && !onDoubleQuote) convertIndicator = false; } else if (c == ']') { if (!onSingleQuote && !onDoubleQuote) convertIndicator = true; } else if (c == '\\'') { if (!onSingleQuote) onSingleQuote = true; else onSingleQuote = false; } else if (c == '\\\"') { if (!onDoubleQuote) onDoubleQuote = true; else onDoubleQuote = false; } if (convertIndicator) newXPath = newXPath + String.valueOf(c).toLowerCase(); else newXPath = newXPath + String.valueOf(c); } return newXPath; }\n\n    ### Response: Format the xpath to work with Java XPath API\n\n@param xpath\nthe xpath to be formatted\n@return String the formatted xpath\n@throws Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void skipObject() { int bracketCount = 1; boolean insideString = false; while (ndx < total) { final char c = input[ndx]; if (insideString) { if (c == '\\\"' && notPrecededByEvenNumberOfBackslashes()) { insideString = false; } } else if (c == '\\\"') { insideString = true; } else if (c == '{') { bracketCount++; } else if (c == '}') { bracketCount--; if (bracketCount == 0) { ndx++; return; } } ndx++; } }\n\n    ### Response:", "ground_truth": "Skips over complete object. It is not parsed, just skipped. It will be\nparsed later, but only if required.", "predict": " Skip the current object in the JSON input\n\n@throws IOException if there is an error reading the input.\n\n    "}, {"ID": 1446, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private char retrieveWrappingQuoteTypeOfJsonMemberNames(String jsonString) { char quote = '\\\"'; // the default quote character used to specify json member names and string value according to the json specification for (char c : jsonString.toCharArray()) { if (c == '\\'' || c == '\\\"') { quote = c; break; } } return quote; }\n\n    ### Response: Returns the quote character used for specifying json member names and String values of json members\n\n@param jsonString the source json from which to extract the wrapping quote\n@return either one of the characters ' (single quote)or \" (double quote).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); }\n\n    ### Response:", "ground_truth": "Parses a string.", "predict": " Parses a string value from the input stream.\n\n@return the parsed string value.\n\n    "}, {"ID": 1447, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BigInteger parseCharacter(String input) { int pos = 1; char c = input.charAt(pos++); if (c == '\\\\') { // escape code switch (input.charAt(pos++)) { case 'b': c = '\\b'; break; case 't': c = '\\t'; break; case 'n': c = '\\n'; break; case 'f': c = '\\f'; break; case 'r': c = '\\r'; break; case '\"': c = '\\\"'; break; case '\\'': c = '\\''; break; case '\\\\': c = '\\\\'; break; default: throw new RuntimeException(\"unrecognised escape character\"); } } return BigInteger.valueOf(c); }\n\n    ### Response: Parse a character from a string of the form 'c' or '\\c'.\n\n@param input\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseStringContent(final char quote) { final int startNdx = ndx; // roll-out until the end of the string or the escape char while (true) { final char c = input[ndx]; if (c == quote) { // no escapes found, just use existing string ndx++; return new String(input, startNdx, ndx - 1 - startNdx); } if (c == '\\\\') { break; } ndx++; } // escapes found, proceed differently textLen = ndx - startNdx; growEmpty(); // for (int i = startNdx, j = 0; j < textLen; i++, j++) { // text[j] = input[i]; // } System.arraycopy(input, startNdx, text, 0, textLen); // escape char, process everything until the end while (true) { char c = input[ndx]; if (c == quote) { // done ndx++; final String str = new String(text, 0, textLen); textLen = 0; return str; } if (c == '\\\\') { // escape char found ndx++; c = input[ndx]; switch (c) { case '\\\"' : c = '\\\"'; break; case '\\\\' : c = '\\\\'; break; case '/' : c = '/'; break; case 'b' : c = '\\b'; break; case 'f' : c = '\\f'; break; case 'n' : c = '\\n'; break; case 'r' : c = '\\r'; break; case 't' : c = '\\t'; break; case 'u' : ndx++; c = parseUnicode(); break; default: if (looseMode) { if (c != '\\'') { c = '\\\\'; ndx--; } } else { syntaxError(\"Invalid escape char: \" + c); } } } text[textLen] = c; textLen++; growAndCopy(); ndx++; } }\n\n    ### Response:", "ground_truth": "Parses string content, once when starting quote has been consumed.", "predict": " Parse a string content from a string of the form \"abc\" or 'abc'.\n\n@param quote the quote character that starts the string content\n@return the parsed string content\n\n    "}, {"ID": 1448, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long read32(byte[] buffer, int offset) { byte b0 = buffer[offset]; byte b1 = buffer[offset + 1]; byte b2 = buffer[offset + 2]; byte b3 = buffer[offset + 3]; // convert signed bytes to unsigned values int i0 = ((b0 & 0x80) == 0x80 ? (b0 & 0x7F) + 0x80 : b0); int i1 = ((b1 & 0x80) == 0x80 ? (b1 & 0x7F) + 0x80 : b1); int i2 = ((b2 & 0x80) == 0x80 ? (b2 & 0x7F) + 0x80 : b2); int i3 = ((b3 & 0x80) == 0x80 ? (b3 & 0x7F) + 0x80 : b3); return ((long) i0 << 24) + ((long) i1 << 16) + ((long) i2 << 8) + (long) i3; }\n\n    ### Response: Reads an unsigned 32 bit big endian number from the given offset in the buffer..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected char parseUnicode() { int i0 = CharUtil.hex2int(input[ndx++]); int i1 = CharUtil.hex2int(input[ndx++]); int i2 = CharUtil.hex2int(input[ndx++]); int i3 = CharUtil.hex2int(input[ndx]); return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3); }\n\n    ### Response:", "ground_truth": "Parses 4 characters and returns unicode character.", "predict": " Parses a Unicode character from the input buffer starting at the current index."}, {"ID": 1449, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Number parseNumber() throws ParseException { final int startIdx = getPosition(); if (peekMatches(\"Infinity\")) { advance(8); return Double.POSITIVE_INFINITY; } else if (peekMatches(\"-Infinity\")) { advance(9); return Double.NEGATIVE_INFINITY; } else if (peekMatches(\"NaN\")) { advance(3); return Double.NaN; } if (peek() == '-') { next(); } final int integralStartIdx = getPosition(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } final int integralEndIdx = getPosition(); final int numIntegralDigits = integralEndIdx - integralStartIdx; if (numIntegralDigits == 0) { throw new ParseException(this, \"Expected a number\"); } final boolean hasFractionalPart = peek() == '.'; if (hasFractionalPart) { next(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } if (getPosition() - (integralEndIdx + 1) == 0) { throw new ParseException(this, \"Expected digits after decimal point\"); } } final boolean hasExponentPart = peek() == '.'; if (hasExponentPart) { next(); final char sign = peek(); if (sign == '-' || sign == '+') { next(); } final int exponentStart = getPosition(); for (; hasMore(); next()) { final char c = peek(); if (c < '0' || c > '9') { break; } } if (getPosition() - exponentStart == 0) { throw new ParseException(this, \"Expected an exponent\"); } } final int endIdx = getPosition(); final String numberStr = getSubstring(startIdx, endIdx); if (hasFractionalPart || hasExponentPart) { return Double.valueOf(numberStr); } else if (numIntegralDigits < 9) { return Integer.valueOf(numberStr); } else if (numIntegralDigits == 9) { // For 9-digit numbers, could be int or long final long longVal = Long.parseLong(numberStr); if (longVal >= Integer.MIN_VALUE && longVal <= Integer.MAX_VALUE) { return (int) longVal; } else { return longVal; } } else { return Long.valueOf(numberStr); } }\n\n    ### Response: Parses and returns Integer, Long or Double type.\n\n\n\nNumber \u2190 Minus? IntegralPart FractionalPart? ExponentPart?\n\nMinus \u2190 \"-\"\n\nIntegralPart \u2190 \"0\" / [1-9] [0-9]*\n\nFractionalPart \u2190 \".\" [0-9]+\n\nExponentPart \u2190 ( \"e\" / \"E\" ) ( \"+\" / \"-\" )? [0-9]+\n\n\n\n@return the number\n@throws ParseException\nif parsing fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseUnquotedStringContent() { final int startNdx = ndx; while (true) { final char c = input[ndx]; if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) { final int currentNdx = ndx; // done skipWhiteSpaces(); return new String(input, startNdx, currentNdx - startNdx); } ndx++; } }\n\n    ### Response:", "ground_truth": "Parses un-quoted string content.", "predict": "Parses and returns the unquoted string content.\n\n\n\n@return the unquoted string content\n@throws ParseException\nif parsing fails.\n\n    "}, {"ID": 1450, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private JsonToken decodeNumber(char[] chars, int offset, int length) { int i = offset; int c = chars[i]; if (c == '-') { c = chars[++i]; } if (c == '0') { c = chars[++i]; } else if (c >= '1' && c <= '9') { c = chars[++i]; while (c >= '0' && c <= '9') { c = chars[++i]; } } else { return JsonToken.STRING; } if (c == '.') { c = chars[++i]; while (c >= '0' && c <= '9') { c = chars[++i]; } } if (c == 'e' || c == 'E') { c = chars[++i]; if (c == '+' || c == '-') { c = chars[++i]; } if (c >= '0' && c <= '9') { c = chars[++i]; while (c >= '0' && c <= '9') { c = chars[++i]; } } else { return JsonToken.STRING; } } if (i == offset + length) { return JsonToken.NUMBER; } else { return JsonToken.STRING; } }\n\n    ### Response: Determine whether the characters is a JSON number. Numbers are of the\nform -12.34e+56. Fractional and exponential parts are optional. Leading\nzeroes are not allowed in the value or exponential part, but are allowed\nin the fraction..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Number parseNumber() { final int startIndex = ndx; char c = input[ndx]; boolean isDouble = false; boolean isExp = false; if (c == '-') { ndx++; } while (true) { if (isEOF()) { break; } c = input[ndx]; if (c >= '0' && c <= '9') { ndx++; continue; } if (c <= 32) { // white space break; } if (c == ',' || c == '}' || c == ']') { // delimiter break; } if (c == '.') { isDouble = true; } else if (c == 'e' || c == 'E') { isExp = true; } ndx++; } final String value = new String(input, startIndex, ndx - startIndex); if (isDouble) { return Double.valueOf(value); } long longNumber; if (isExp) { longNumber = Double.valueOf(value).longValue(); } else { if (value.length() >= 19) { // if string is 19 chars and longer, it can be over the limit BigInteger bigInteger = new BigInteger(value); if (isGreaterThanLong(bigInteger)) { return bigInteger; } longNumber = bigInteger.longValue(); } else { longNumber = Long.parseLong(value); } } if ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) { return (int) longNumber; } return longNumber; }\n\n    ### Response:", "ground_truth": "Parses JSON numbers.", "predict": " Parse a JSON number from the input buffer starting at the current index. The number can be an integer or a floating-point number. The method returns a Number object, which can be an Integer, Long, or Double. If the number is too large to be represented as a Long, it is returned as a BigInteger. The method advances the input buffer index to the next character after the end of the number."}, {"ID": 1451, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, Class<T> targetType, boolean required) throws WebApplicationException { String value = get(key); if (value == null) { if (required) { throw new BadRequestException(\"Missing parameter: \" + key); } Object result = null; if (targetType.isPrimitive()) { if (targetType == boolean.class) { result = Boolean.FALSE; } else if (targetType == int.class) { result = Integer.valueOf(0); } else if (targetType == long.class) { result = Long.valueOf(0); } else if (targetType == double.class) { result = Double.valueOf(0); } else if (targetType == float.class) { result = Float.valueOf(0); } else if (targetType == byte.class) { result = Byte.valueOf((byte) 0); } else if (targetType == short.class) { result = Short.valueOf((short) 0); } else if (targetType == char.class) { result = '\\0'; } } return (T) result; } try { return convertValue(value, targetType); } catch (WebApplicationException e) { throw e; } catch (Exception e) { throw new BadRequestException(\"Failed to convert '\" + value + \"' to type \" + targetType); } }\n\n    ### Response: Gets the single parameter in a generic and flexible way.\n\n@param  is the generic type of targetType.\n@param key is the {@link java.util.Map#get(Object) key} of the parameter to get.\n@param targetType is the {@link Class} reflecting the type to convert the value to. Supports common Java standard\ntypes such as {@link String}, {@link Long}, {@link Double}, {@link BigDecimal}, etc.\n@param required - {@code true} if the value is required and a {@link BadRequestException} is thrown if it is not\npresent, {@code false} otherwise (if optional).\n@return the value for the given key converted to the given targetType. May be\n{@code null} if required is {@code false} .\n@throws WebApplicationException if an error occurred. E.g. {@link BadRequestException} if a required parameter is\nmissing or {@link InternalServerErrorException} if the given targetType is not supported..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object parseArrayContent(Class targetType, Class componentType) { // detect special case if (targetType == Object.class) { targetType = List.class; } // continue targetType = replaceWithMappedTypeForPath(targetType); if (componentType == null && targetType != null && targetType.isArray()) { componentType = targetType.getComponentType(); } path.push(VALUES); componentType = replaceWithMappedTypeForPath(componentType); Collection<Object> target = newArrayInstance(targetType); boolean koma = false; mainloop: while (true) { skipWhiteSpaces(); char c = input[ndx]; if (c == ']') { if (koma) { syntaxError(\"Trailing comma\"); } ndx++; path.pop(); return target; } Object value = parseValue(componentType, null, null); target.add(value); skipWhiteSpaces(); c = input[ndx]; switch (c) { case ']': ndx++; break mainloop; case ',': ndx++; koma = true; break; default: syntaxError(\"Invalid char: expected ] or ,\"); } } path.pop(); if (targetType != null) { return convertType(target, targetType); } return target; }\n\n    ### Response:", "ground_truth": "Parses arrays, once when open bracket has been consumed.", "predict": " Parses an array content.\n\n@param targetType is the target type of the array. May be {@code null} if the target type is not known in advance.\n@param componentType is the component type of the array. May be {@code null} if the component type is not known in advance.\n@return the parsed array content.\n@throws WebApplicationException if an error occurred. E.g. {@link BadRequestException} if the input is invalid or\n{@link InternalServerErrorException} if the target type is not supported."}, {"ID": 1452, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { if (isInstrumentableClass()) { // Add a field to hold the trace state if needed if (isTraceObjectFieldDefinitionRequired()) { int access = (Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC); String name = getTraceObjectFieldName(); String desc = getTraceObjectFieldType().getDescriptor(); visitField(access, name, desc, null, null); } // Add a static initializer to setup trace if needed if (isStaticInitializerRequired() && !isStaticInitDefined()) { staticInitializerGenerated = true; MethodVisitor mv = visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null); Label lineNumberLabel = new Label(); mv.visitCode(); mv.visitLabel(lineNumberLabel); mv.visitLineNumber(65535, lineNumberLabel); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 0); mv.visitEnd(); } } super.visitEnd(); }\n\n    ### Response: Visit the end of the class. All of the methods and fieldInfos defined in\nthe class have been visited at this point. If we didn't encounter a\ntrace state field or static initializer, we'll add them now..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createEmptyCtor() { final MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC, INIT, \"()V\", null, null); mv.visitCode(); mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitMethodInsn( Opcodes.INVOKESPECIAL, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT, INIT, \"()V\", false); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Created empty default constructor.", "predict": "Create an empty constructor for the class. This constructor will be used to create instances of the class without any arguments."}, {"ID": 1453, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { if (isInstrumentableClass()) { // Add a field to hold the trace state if needed if (isTraceObjectFieldDefinitionRequired()) { int access = (Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC); String name = getTraceObjectFieldName(); String desc = getTraceObjectFieldType().getDescriptor(); visitField(access, name, desc, null, null); } // Add a static initializer to setup trace if needed if (isStaticInitializerRequired() && !isStaticInitDefined()) { staticInitializerGenerated = true; MethodVisitor mv = visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null); Label lineNumberLabel = new Label(); mv.visitCode(); mv.visitLabel(lineNumberLabel); mv.visitLineNumber(65535, lineNumberLabel); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 0); mv.visitEnd(); } } super.visitEnd(); }\n\n    ### Response: Visit the end of the class. All of the methods and fieldInfos defined in\nthe class have been visited at this point. If we didn't encounter a\ntrace state field or static initializer, we'll add them now..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createSimpleMethodWrapper(final MethodSignatureVisitor msign) { int access = msign.getAccessFlags(); access &= ~ACC_ABSTRACT; access &= ~ACC_NATIVE; MethodVisitor mv = wd.dest.visitMethod( access, msign.getMethodName(), msign.getDescription(), msign.getAsmMethodSignature(), msign.getExceptions()); mv.visitCode(); mv.visitVarInsn(ALOAD, 0); mv.visitFieldInsn(GETFIELD, wd.thisReference, wd.wrapperRef, wd.wrapperType); loadVirtualMethodArguments(mv, msign); if (wd.wrapInterface) { mv.visitMethodInsn( INVOKEINTERFACE, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), true); } else { mv.visitMethodInsn( INVOKEVIRTUAL, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), false); } ProxettaAsmUtil.prepareReturnValue(mv, msign, 0); visitReturn(mv, msign, true); mv.visitMaxs(0, 0); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Creates simple method wrapper without proxy.", "predict": " Create a simple method wrapper for the given method signature. This method will create a new method in the destination class that simply calls the given method on the wrapper object. The method will have the same access flags as the original method, but without the abstract and native flags. The method will also have the same name, description, signature, and exceptions as the original method. The method will also load the arguments to the method on the stack, call the method on the wrapper object, and then prepare and return the return value."}, {"ID": 1454, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class<?> getJavaType(int sqlType, String typeName, int size, int digits, String tableName, String columnName) { // table.column mapped class Type<?> type = javaTypeMapping.getType(tableName, columnName); if (type != null) { return type.getReturnedClass(); } else if (typeName != null && !typeName.isEmpty()) { typeName = typeName.toLowerCase(); // typename mapped class Class<?> clazz = typeToName.get(typeName); if (clazz != null) { return clazz; } if (sqlType == Types.ARRAY) { if (typeName.startsWith(\"_\")) { typeName = typeName.substring(1); } else if (typeName.endsWith(\" array\")) { typeName = typeName.substring(0, typeName.length() - 6); } if (typeName.contains(\"[\")) { typeName = typeName.substring(0, typeName.indexOf(\"[\")); } if (typeName.contains(\"(\")) { typeName = typeName.substring(0, typeName.indexOf(\"(\")); } Integer sqlComponentType = templates.getCodeForTypeName(typeName); if (sqlComponentType == null) { logger.warn(\"Found no JDBC type for \" + typeName + \" using OTHER instead\"); sqlComponentType = Types.OTHER; } Class<?> componentType = jdbcTypeMapping.get(sqlComponentType, size, digits); return Array.newInstance(componentType, 0).getClass(); } } // sql type mapped class return jdbcTypeMapping.get(sqlType, size, digits); }\n\n    ### Response: Get the java type for the given jdbc type, table name and column name\n\n@param sqlType JDBC type\n@param typeName JDBC type name\n@param size size\n@param digits digits\n@param tableName table name\n@param columnName column name\n@return Java type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String resolveRawTypeName(String typeName) { if (typeName == null) { return null; } boolean isArray = typeName.startsWith(StringPool.LEFT_SQ_BRACKET); if (isArray) { typeName = typeName.substring(1); } String rawTypeName; if (generics.containsKey(typeName)) { rawTypeName = generics.get(typeName); } else { rawTypeName = declaredTypeGeneric.getOrDefault(typeName, typeName); } if (isArray) { rawTypeName = '[' + rawTypeName; } return rawTypeName; }\n\n    ### Response:", "ground_truth": "Resolves raw type name using the generics information from the class\nor method information.", "predict": " Resolve the raw type name for the given type name.\n\n@param typeName Type name\n@return Raw type name."}, {"ID": 1455, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function findReferences(schema) { if (schema.$ref) { return [schema.$ref]; } let references = []; if (schema.allOf) { references = references.concat(...schema.allOf.map(findReferences)); } if (schema.anyOf) { references = references.concat(...schema.anyOf.map(findReferences)); } if (schema.oneOf) { references = references.concat(...schema.oneOf.map(findReferences)); } if (schema.not) { references = references.concat(...findReferences(schema.not)); } // Array if (schema.items) { if (Array.isArray(schema.items)) { references = references.concat(...schema.items.map(findReferences)); } else { references = references.concat(findReferences(schema.items)); } } if (schema.additionalItems && typeof schema.additionalItems === 'object') { references = references.concat(findReferences(schema.additionalItems)); } // Object if (schema.properties) { Object.keys(schema.properties).forEach((key) => { references = references.concat(findReferences(schema.properties[key])); }); } if (schema.patternProperties) { Object.keys(schema.patternProperties).forEach((key) => { references = references.concat(findReferences(schema.patternProperties[key])); }); } if (schema.additionalProperties && typeof schema.additionalProperties === 'object') { references = references.concat(findReferences(schema.additionalProperties)); } return references; }\n\n    ### Response: Traverses the entire schema to find all of the references\n@returns array of each reference that is found in the schema.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) { BeanReferences references; if (refName == null || refName.isEmpty()) { references = buildDefaultReference(propertyDescriptor); } else { references = BeanReferences.of(refName); } references = references.removeDuplicateNames(); return references; }\n\n    ### Response:", "ground_truth": "Resolves reference from given values. Returns bean reference of given value or defaults\nif given name is blank.", "predict": " Resolves the reference name from the property descriptor and creates a BeanReferences object with the reference name. If the reference name is null or empty, it creates a default reference using the property descriptor. The BeanReferences object is then checked for duplicate names and returned."}, {"ID": 1456, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void retrieveServerMetadata() throws Exception { if (get() == null) { throw new IllegalStateException(\"Cannot retrieve the server metadata - no reference to Chameleon stored \" + \"in the holder\"); } int factor = Integer.getInteger(\"time.factor\", 1); if (factor != 1) { TimeUtils.TIME_FACTOR = factor; } // Before checking, ensure stability. ServiceReference[] references = get().waitForStability().context().getAllServiceReferences(WisdomEngine.class .getName(), null); if (references == null || references.length == 0) { references = get().waitForStability().context().getAllServiceReferences(WisdomEngine.class.getName(), null); } if (references == null || references.length == 0) { throw new IllegalStateException(\"Cannot retrieve the Wisdom Engine service\"); } Object engine = get().context().getService(references[0]); HOST_NAME = (String) engine.getClass().getMethod(\"hostname\").invoke(engine); HTTP_PORT = (int) engine.getClass().getMethod(\"httpPort\").invoke(engine); HTTPS_PORT = (int) engine.getClass().getMethod(\"httpsPort\").invoke(engine); }\n\n    ### Response: Methods call by the test framework to discover the server name and port.\n\n@throws Exception if the service is not running..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) { BeanReferences[] references = convertRefToReferences(parameterReferences); if (references == null || references.length == 0) { references = buildDefaultReferences(methodOrCtor); } if (methodOrCtor.getParameterTypes().length != references.length) { throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName()); } removeAllDuplicateNames(references); return references; }\n\n    ### Response:", "ground_truth": "Takes given parameters references and returns reference set for given method or constructor.", "predict": " This method resolves the references from the parameter values and returns an array of BeanReferences. If the parameter references are null or empty, it builds the default references based on the method or constructor parameter types. If the number of parameter types and references are different, it throws a PetiteException. It also removes all duplicate names from the references."}, {"ID": 1457, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function findReferences(schema) { if (schema.$ref) { return [schema.$ref]; } let references = []; if (schema.allOf) { references = references.concat(...schema.allOf.map(findReferences)); } if (schema.anyOf) { references = references.concat(...schema.anyOf.map(findReferences)); } if (schema.oneOf) { references = references.concat(...schema.oneOf.map(findReferences)); } if (schema.not) { references = references.concat(...findReferences(schema.not)); } // Array if (schema.items) { if (Array.isArray(schema.items)) { references = references.concat(...schema.items.map(findReferences)); } else { references = references.concat(findReferences(schema.items)); } } if (schema.additionalItems && typeof schema.additionalItems === 'object') { references = references.concat(findReferences(schema.additionalItems)); } // Object if (schema.properties) { Object.keys(schema.properties).forEach((key) => { references = references.concat(findReferences(schema.properties[key])); }); } if (schema.patternProperties) { Object.keys(schema.patternProperties).forEach((key) => { references = references.concat(findReferences(schema.patternProperties[key])); }); } if (schema.additionalProperties && typeof schema.additionalProperties === 'object') { references = references.concat(findReferences(schema.additionalProperties)); } return references; }\n\n    ### Response: Traverses the entire schema to find all of the references\n@returns array of each reference that is found in the schema.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) { PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class); final Parameter[] parameters = methodOrCtor.getParameters(); BeanReferences[] references; final boolean hasAnnotationOnMethodOrCtor; if (petiteInject != null) { references = convertAnnValueToReferences(petiteInject.value()); hasAnnotationOnMethodOrCtor = true; } else { references = new BeanReferences[parameters.length]; hasAnnotationOnMethodOrCtor = false; } int parametersWithAnnotationCount = 0; for (int i = 0; i < parameters.length; i++) { Parameter parameter = parameters[i]; petiteInject = parameter.getAnnotation(PetiteInject.class); if (petiteInject == null) { // no annotation on argument continue; } // there is annotation on argument, override values String annotationValue = readAnnotationValue(petiteInject); if (annotationValue != null) { references[i] = BeanReferences.of(annotationValue); } parametersWithAnnotationCount++; } if (!hasAnnotationOnMethodOrCtor) { if (parametersWithAnnotationCount == 0) { return null; } if (parametersWithAnnotationCount != parameters.length) { throw new PetiteException(\"All arguments must be annotated with PetiteInject\"); } } references = updateReferencesWithDefaultsIfNeeded(methodOrCtor, references); removeAllDuplicateNames(references); return references; }\n\n    ### Response:", "ground_truth": "Extracts references from method or constructor annotation.", "predict": " Reads the PetiteInject annotation and converts the value to a BeanReferences array. If the annotation is not present on the method or constructor, it creates a new array with the same length as the number of parameters. It then loops through the parameters and checks if there is an annotation on each one. If there is, it reads the value and converts it to a BeanReferences object. It then counts the number of parameters with an annotation and throws an exception if there are any parameters without an annotation. If there are no annotations on the method or constructor, it returns null. If there are annotations on the method or constructor and all parameters have an annotation, it updates the references with any default values specified in the annotation. Finally, it removes any duplicate names from the references array."}, {"ID": 1458, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String[][] getDataTokens(Relation frame) { if (frame.rowCount() == 0) return new String[0][0]; final int rowCount = Math.min(maxRows, frame.rowCount()); final boolean truncated = frame.rowCount() > maxRows; final int colCount = frame.columnCount(); final String[][] data; if (truncated) { data = new String[rowCount + 1][colCount]; int i; for (i = 0; i < Math.ceil((double) rowCount / 2); i++) { for (int j = 0; j < colCount; j++) { data[i][j] = frame.getString(i, j); } } for (int j = 0; j < colCount; j++) { data[i][j] = \"...\"; } for (++i; i <= rowCount; i++) { for (int j = 0; j < colCount; j++) { data[i][j] = frame.getString(frame.rowCount() - maxRows + i - 1, j); } } } else { data = new String[rowCount][colCount]; for (int i = 0; i < rowCount; i++) { for (int j = 0; j < colCount; j++) { String value = frame.getString(i, j); data[i][j] = value == null ? \"\" : value; } } } return data; }\n\n    ### Response: Returns the 2-D array of data tokens from the frame specified\n\n@param frame the DataFrame from which to create 2D array of formatted tokens\n@return the array of data tokens.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] buildDefaultReferences(final Executable methodOrCtor) { final boolean useParamo = petiteConfig.getUseParamo(); final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); MethodParameter[] methodParameters = null; if (useParamo) { methodParameters = Paramo.resolveParameters(methodOrCtor); } final Class[] paramTypes = methodOrCtor.getParameterTypes(); final BeanReferences[] references = new BeanReferences[paramTypes.length]; for (int j = 0; j < paramTypes.length; j++) { String[] ref = new String[lookupReferences.length]; references[j] = BeanReferences.of(ref); for (int i = 0; i < ref.length; i++) { switch (lookupReferences[i]) { case NAME: ref[i] = methodParameters != null ? methodParameters[j].getName() : null; break; case TYPE_SHORT_NAME: ref[i] = StringUtil.uncapitalize(paramTypes[j].getSimpleName()); break; case TYPE_FULL_NAME: ref[i] = paramTypes[j].getName(); break; } } } return references; }\n\n    ### Response:", "ground_truth": "Builds default method references.", "predict": " Builds the default references for the given method or constructor.\n\n@param methodOrCtor the method or constructor for which to build default references\n@return the array of default references for the method or constructor parameters\n\n    "}, {"ID": 1459, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getStringValue(final Element element) { final StringBuilder buf = new StringBuilder(); final NodeList children = element.getChildNodes(); for (int i = 0; i < children.getLength(); i++) { final Node n = children.item(i); switch (n.getNodeType()) { case Node.TEXT_NODE: buf.append(n.getNodeValue()); break; case Node.ELEMENT_NODE: buf.append(getStringValue((Element) n)); break; } } return buf.toString(); }\n\n    ### Response: Get element node string value.\n\n@param element element to get string value for\n@return concatenated text node descendant values.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences buildDefaultReference(final PropertyDescriptor propertyDescriptor) { final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); final String[] references = new String[lookupReferences.length]; for (int i = 0; i < references.length; i++) { switch (lookupReferences[i]) { case NAME: references[i] = propertyDescriptor.getName(); break; case TYPE_SHORT_NAME: references[i] = StringUtil.uncapitalize(propertyDescriptor.getType().getSimpleName()); break; case TYPE_FULL_NAME: references[i] = propertyDescriptor.getType().getName(); break; } } return BeanReferences.of(references); }\n\n    ### Response:", "ground_truth": "Builds default field references.", "predict": " Build default bean reference for property descriptor.\n\n@param propertyDescriptor property descriptor to build reference for\n@return default bean reference for property descriptor\n\n    "}, {"ID": 1460, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void softmax() { double max = Double.NEGATIVE_INFINITY; for (int i = 0; i < outputLayer.units; i++) { if (outputLayer.output[i] > max) { max = outputLayer.output[i]; } } double sum = 0.0; for (int i = 0; i < outputLayer.units; i++) { double out = Math.exp(outputLayer.output[i] - max); outputLayer.output[i] = out; sum += out; } for (int i = 0; i < outputLayer.units; i++) { outputLayer.output[i] /= sum; } }\n\n    ### Response: Calculate softmax activation function in output layer without overflow..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeAllDuplicateNames(final BeanReferences[] allBeanReferences) { for (int i = 0; i < allBeanReferences.length; i++) { BeanReferences references = allBeanReferences[i]; allBeanReferences[i] = references.removeDuplicateNames(); } }\n\n    ### Response:", "ground_truth": "Removes duplicate names from bean references.", "predict": " Remove all duplicate names from the given array of BeanReferences."}, {"ID": 1461, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getDbStoragePaths() { if (localRocksDbDirectories == null) { return null; } else { String[] paths = new String[localRocksDbDirectories.length]; for (int i = 0; i < paths.length; i++) { paths[i] = localRocksDbDirectories[i].toString(); } return paths; } }\n\n    ### Response: Gets the configured local DB storage paths, or null, if none were configured.\n\nUnder these directories on the TaskManager, RocksDB stores its SST files and\nmetadata files. These directories do not need to be persistent, they can be ephermeral,\nmeaning that they are lost on a machine failure, because state in RocksDB is persisted\nin checkpoints.\n\nIf nothing is configured, these directories default to the TaskManager's local\ntemporary file directories..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] convertRefToReferences(final String[] references) { if (references == null) { return null; } BeanReferences[] ref = new BeanReferences[references.length]; for (int i = 0; i < references.length; i++) { ref[i] = BeanReferences.of(references[i]); } return ref; }\n\n    ### Response:", "ground_truth": "Converts single string array to an array of bean references.", "predict": " Converts an array of references to BeanReferences.\n\nThe input array contains the string representation of the BeanReferences. The method\nconverts each string to a BeanReferences object and returns an array of these objects."}, {"ID": 1462, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getArrayFilter(String key) { String value = filters.get(key); if (value == null) return null; String[] array = new String[0]; if (value.startsWith(\"[\")) { if (value.length() > 2) array = value.substring(1, value.length() - 1).split(\",\"); } else if (value.length() > 1) { array = value.split(\",\"); } for (int i = 0; i < array.length; i++) { String item = array[i]; if ((item.startsWith(\"\\\"\") && item.endsWith(\"\\\"\")) || (item.startsWith(\"'\") && item.endsWith(\"'\")) && item.length() > 1) array[i] = item.substring(1, item.length() - 2); } return array; }\n\n    ### Response: Empty list returns null;.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] convertAnnValueToReferences(String value) { if (value == null) { return null; } value = value.trim(); if (value.length() == 0) { return null; } String[] refNames = Converter.get().toStringArray(value); BeanReferences[] references = new BeanReferences[refNames.length]; for (int i = 0; i < refNames.length; i++) { references[i] = BeanReferences.of(refNames[i].trim()); } return references; }\n\n    ### Response:", "ground_truth": "Converts comma-separated string into array of Bean references.", "predict": " Converts a string value to an array of BeanReferences."}, {"ID": 1463, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <R> R executeTransactionalCommand(final TransactionalCommand<R> command, final TransactionStyle style) throws MithraBusinessException { String commandName = command.getClass().getName(); MithraTransaction tx = this.getCurrentTransaction(); if (tx != null) { try { return command.executeTransaction(tx); } catch(RuntimeException e) { throw e; } catch (Throwable throwable) { getLogger().error(commandName+\" rolled back tx, will not retry.\", throwable); tx.expectRollbackWithCause(throwable); throw new MithraBusinessException(commandName+\" transaction failed\", throwable); } } R result = null; int retryCount = style.getRetries() + 1; do { try { tx = this.startOrContinueTransaction(style); tx.setTransactionName(\"Transactional Command: \"+commandName); result = command.executeTransaction(tx); tx.commit(); retryCount = 0; } catch (Throwable throwable) { retryCount = MithraTransaction.handleTransactionException(tx, throwable, retryCount, style); } } while(retryCount > 0); return result; }\n\n    ### Response: executes the given transactional command with the custom transaction style.\n@param command\n@param style\n@throws MithraBusinessException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void runJoy(final Consumer<JoddJoyRuntime> consumer) { final JoddJoy joddJoy = new JoddJoy(); final JoddJoyRuntime joyRuntime = joddJoy.startOnlyBackend(); joddJoy.withDb(joyDb -> setJtxManager(joyRuntime.getJtxManager())); final JtxTransaction tx = startRwTx(); final Print print = new Print(); try { print.line(\"START\", 80); print.newLine(); consumer.accept(joyRuntime); print.newLine(); print.line(\"END\", 80); if (tx != null) { tx.commit(); } } catch (Throwable throwable) { throwable.printStackTrace(); if (tx != null) { tx.rollback(); } } joddJoy.stop(); }\n\n    ### Response:", "ground_truth": "Runs JOY in standalone mode, with only backend.", "predict": " starts a JoddJoy runtime and runs the given consumer with the runtime.\n@param consumer\n@throws Throwable."}, {"ID": 1464, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method getPublicMethodNamed(Class c, String methodName) { for( Method m : c.getMethods() ) if(m.getName().equals(methodName)) return m; return null; }\n\n    ### Response: Finds a public method of the given name, regardless of its parameter definitions,.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method findMethod(final Class c, final String methodName) { return findDeclaredMethod(c, methodName, true); }\n\n    ### Response:", "ground_truth": "Returns method from an object, matched by name. This may be considered as\na slow operation, since methods are matched one by one.\nReturns only accessible methods.\nOnly first method is matched.\n\n@param c          class to examine\n@param methodName Full name of the method.\n@return null if method not found", "predict": " Finds a declared method of the given name, regardless of its parameter definitions, and returns it. If no such method is found, returns null."}, {"ID": 1465, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"all\" }) public static <T> Constructor<T> findConstructor(Class<T> type, Object... arguments) { for (Constructor<?> constructor : type.getDeclaredConstructors()) { Class<?>[] parameterTypes = constructor.getParameterTypes(); if (ArrayUtils.nullSafeLength(arguments) == parameterTypes.length) { boolean match = true; for (int index = 0; match && index < parameterTypes.length; index++) { match &= instanceOf(arguments[index], parameterTypes[index]); } if (match) { return (Constructor<T>) constructor; } } } return null; }\n\n    ### Response: Attempts to find a compatible constructor on the given class type with a signature having parameter types\nsatisfying the specified arguments.\n\n@param  the generic class type to search for the constructor.\n@param type the Class type to search for the desired constructor.\n@param arguments an array of Object arguments used to match the constructor's signature.\n@return a Constructor from the given class type whose signature matches the specified arguments.\n@see java.lang.Class\n@see java.lang.Class#getDeclaredConstructors()\n@see java.lang.reflect.Constructor.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds constructor with given parameter types. First matched ctor is returned.", "predict": "Attempts to find a constructor on the given class type with a signature having parameter types\nsatisfying the specified parameterTypes.\n\n@param clazz the Class type to search for the desired constructor.\n@param parameterTypes an array of Class arguments used to match the constructor's signature.\n@return a Constructor from the given class type whose signature matches the specified parameterTypes.\n@see java.lang.Class\n@see java.lang.Class#getConstructors()\n@see java.lang.reflect.Constructor."}, {"ID": 1466, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static <T> Class[] findTypes(Collection<T> c) { Set<Class> types = new HashSet<>(); types.add(JAXBCollection.class); for (T o : c) { if (o != null) { types.add(o.getClass()); } } return types.toArray(new Class[0]); }\n\n    ### Response: Discovers all the classes in the given Collection. These need to be in the JAXBContext if you\nwant to marshal those objects. Unfortunatly there's no way of getting the generic type at\nruntime.\n\n@param c Collection that needs to be scanned\n@return Classes found in the collection, including JAXBCollection..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class[] resolveAllInterfaces(final Class type) { Set<Class> bag = new LinkedHashSet<>(); _resolveAllInterfaces(type, bag); return bag.toArray(new Class[0]); }\n\n    ### Response:", "ground_truth": "Resolves all interfaces of a type. No duplicates are returned.\nDirect interfaces are prior the interfaces of subclasses in\nthe returned array.", "predict": "Resolves all the interfaces implemented by the given type and its superclasses.\n\n@param type Type to resolve interfaces for\n@return Interfaces implemented by the type and its superclasses\n\n    "}, {"ID": 1467, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static boolean typesMatch(Class<?>[] c1, Class[] c2) { if (c1.length != c2.length) { return false; } for (int i = 0; i < c1.length; i++) { if (!inSameHierarchy(c1[i], c2[i]) && !isConvertible(c1[i], c2[i])) { return false; } } return true; }\n\n    ### Response: Determines if the two given arrays of class are compatible with one another.\n\n@param c1 array 1\n@param c2 array 2\n@return True if all classes are the same or those c1 are assignable from c2, otherwise false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean compareParameters(final Class[] first, final Class[] second) { if (first.length != second.length) { return false; } for (int i = 0; i < first.length; i++) { if (first[i] != second[i]) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Compares classes, usually method or ctor parameters.", "predict": " Compares two arrays of classes to see if they are the same.\n\n@param first array 1\n@param second array 2\n@return True if the arrays are the same, otherwise false."}, {"ID": 1468, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String get(String name, String def) { String val = null; final String fname = name; if (System.getSecurityManager() != null) { try { val = AccessController.doPrivileged(new PrivilegedAction<String>() { @Override public String run() { return System.getProperty(fname); } }); } catch (AccessControlException e) { // ignore // TODO log this message } } else { val = System.getProperty(name); } if (val == null) { val = CONFIG_PROPS.getProperty(name, def); } return val; }\n\n    ### Response: Get ICU configuration property value for the given name.\n@param name The configuration property name\n@param def The default value\n@return The configuration property value.  If the property does not\nexist, def is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void forceAccess(final AccessibleObject accObject) { try { if (System.getSecurityManager() == null) accObject.setAccessible(true); else { AccessController.doPrivileged((PrivilegedAction) () -> { accObject.setAccessible(true); return null; }); } } catch (SecurityException sex) { // ignore } }\n\n    ### Response:", "ground_truth": "Suppress access check against a reflection object. SecurityException is silently ignored.\nChecks first if the object is already accessible.", "predict": " Force accessibility of the given AccessibleObject.\n@param accObject The AccessibleObject to be made accessible."}, {"ID": 1469, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T createInstance(final String className, final Class<T> clazz, final Object... args) { if (className == null) { return null; } try { Class<?> loaded = UtilityElf.class.getClassLoader().loadClass(className); if (args.length == 0) { return clazz.cast(loaded.newInstance()); } Class<?>[] argClasses = new Class<?>[args.length]; for (int i = 0; i < args.length; i++) { argClasses[i] = args[i].getClass(); } Constructor<?> constructor = loaded.getConstructor(argClasses); return clazz.cast(constructor.newInstance(args)); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response: Create and instance of the specified class using the constructor matching the specified\narguments.\n\n@param  the class type\n@param className the name of the class to instantiate\n@param clazz a class to cast the result as\n@param args arguments to a constructor\n@return an instance of the specified class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T newInstance(final Class<T> clazz, final Object... params) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException { if (params.length == 0) { return newInstance(clazz); } final Class<?>[] paramTypes = getClasses(params); final Constructor<?> constructor = findConstructor(clazz, paramTypes); if (constructor == null) { throw new InstantiationException(\"No constructor matched parameter types.\"); } return (T) constructor.newInstance(params); }\n\n    ### Response:", "ground_truth": "Creates new instance of given class with given optional arguments.", "predict": " Create a new instance of the specified class using the constructor matching the specified arguments.\n\n@param  the class type\n@param clazz the class to instantiate\n@param params arguments to a constructor\n@return an instance of the specified class.\n\n    "}, {"ID": 1470, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] getSortedPropTypes() { int count = 0; for (PropListItem x = propListHead; x != null; x = x.next) { count++; } byte[] keys = new byte[count]; for (PropListItem x = propListHead; x != null; x = x.next) { count--; keys[count] = x.propType; } Arrays.sort(keys); return keys; }\n\n    ### Response: Gets all the property types, in sorted order..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class[] getSuperclasses(final Class type) { int i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { i++; } Class[] result = new Class[i]; i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { result[i] = x; i++; } return result; }\n\n    ### Response:", "ground_truth": "Returns all superclasses.", "predict": " Gets all the superclasses of a given class."}, {"ID": 1471, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasSuperClass(Class<?> clazz, Class<?> superClazz) { if (clazz == null || superClazz == null || clazz == superClazz) { return false; } if (clazz.isInterface()) { return superClazz.isAssignableFrom(clazz); } Class<?> parent = clazz.getSuperclass(); while (parent != null) { if (parent == superClazz) { return true; } parent = parent.getSuperclass(); } return false; }\n\n    ### Response: Tells if a class is a sub-class of a super-class.\n\nNote:\n\nSub-class against super-class: this method returns {@code true}.\nSub-interface against super-interface: this method returns\n{@code true}.\nClass against interface: this method returns {@code false}.\n\n\n@param clazz\nclass to check\n@param superClazz\nthe super-class to check\n@return {@code true} if {@code superClazz} is indeed the super-class of\n{@code clazz}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> childClassOf(final Class<?> parentClass, final Object instance) { if (instance == null || instance == Object.class) { return null; } if (parentClass != null) { if (parentClass.isInterface()) { return null; } } Class<?> childClass = instance.getClass(); while (true) { Class<?> parent = childClass.getSuperclass(); if (parent == parentClass) { return childClass; } if (parent == null) { return null; } childClass = parent; } }\n\n    ### Response:", "ground_truth": "Returns the class of the immediate subclass of the given parent class for\nthe given object instance; or null if such immediate subclass cannot be\nuniquely identified for the given object instance.", "predict": " Returns the child class of a parent class for a given instance.\n\nNote:\n\nChild class against parent class: this method returns the child class of\nthe parent class.\nChild interface against parent interface: this method returns\n{@code null}.\nChild class against parent interface: this method returns\n{@code null}.\nChild interface against parent class: this method returns\n{@code null}.\n\n@param parentClass\nthe parent class to check\n@param instance\nthe instance to check\n@return the child class of the parent class for the given instance, or\n{@code null} if the instance is not an instance of the parent class or\nif the parent class is an interface."}, {"ID": 1472, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File getCanonicalFileFromFileUrl(final URL url) { File file = null; if (url == null) { throw new NullPointerException(\"The URL cannot be null.\"); } if (\"file\".equals(url.getProtocol())) { final String fileName = url.getFile(); final String path = URLUtils.uncorrect(fileName); file = new File(path); try { file = file.getCanonicalFile(); } catch (final IOException e) { // Does not exist. file = file.getAbsoluteFile(); } } return file; }\n\n    ### Response: On Windows names of files from network neighborhood must be corrected\nbefore open.\n\n@param url\nThe file URL.\n@return The canonical or absolute file, or null if the protocol is not\nfile..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JarFile jarFileOf(final Class<?> klass) { URL url = klass.getResource( \"/\" + klass.getName().replace('.', '/') + \".class\"); if (url == null) { return null; } String s = url.getFile(); int beginIndex = s.indexOf(\"file:\") + \"file:\".length(); int endIndex = s.indexOf(\".jar!\"); if (endIndex == -1) { return null; } endIndex += \".jar\".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, \"UTF-8\"); File file = new File(f); try { return file.exists() ? new JarFile(file) : null; } catch (IOException e) { throw new IllegalStateException(e); } }\n\n    ### Response:", "ground_truth": "Returns the jar file from which the given class is loaded; or null\nif no such jar file can be located.", "predict": " Returns the JarFile of the given class.\n\n@param klass\nThe class to get the JarFile for.\n@return The JarFile of the given class or null if it cannot be found.\n\n    "}, {"ID": 1473, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void sleep(long ms) throws IOException { try { Thread.sleep(ms); } catch (InterruptedException e) { LOG.error(\"Interrupted when sleeping\", e); Thread.currentThread().interrupt(); throw new IOException(\"Received interruption\"); } }\n\n    ### Response: Sleep for n milliseconds.\nThrow IOException when interrupted.\n@param ms\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void sleep(final long ms) { try { Thread.sleep(ms); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Puts a thread to sleep, without throwing an InterruptedException.\n\n@param ms     the length of time to sleep in milliseconds", "predict": " Sleep for n milliseconds.\n@param ms\n\n    "}, {"ID": 1474, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void sleep() { try { Thread.sleep(sleepIntervalInMillis); } catch (InterruptedException exception) { Thread.currentThread().interrupt(); throw new SelendroidException(exception); } }\n\n    ### Response: Sleeps for a few milliseconds..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void sleep() { try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Puts a thread to sleep forever.", "predict": " Sleeps indefinitely until interrupted."}, {"ID": 1475, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void waitForSizeQueue(final int queueSize) { synchronized (this.queue) { while (this.queue.size() > queueSize) { try { this.queue.wait(250L); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } try { Thread.sleep(500L); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } this.queue.notifyAll(); } }\n\n    ### Response: For test purposes only..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void wait(final Object obj) { synchronized (obj) { try { obj.wait(); } catch (InterruptedException inex) { Thread.currentThread().interrupt(); } } }\n\n    ### Response:", "ground_truth": "Waits for a object for synchronization purposes.", "predict": " For test purposes only.."}, {"ID": 1476, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ThreadFactory getThreadFactory(String groupName) { return new ThreadFactory() { final AtomicInteger threadCount = new AtomicInteger(); @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r, groupName + \"-\" + threadCount.incrementAndGet()); thread.setDaemon(true); return thread; } }; }\n\n    ### Response: Creates and returns a thread factory that will create threads with the given name prefix.\n\n@param groupName the name of the threads\n@return a thread factory.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ThreadFactory daemonThreadFactory(final String name, final int priority) { return new ThreadFactory() { private AtomicInteger count = new AtomicInteger(); @Override public Thread newThread(final Runnable r) { Thread thread = new Thread(r); thread.setName(name + '-' + count.incrementAndGet()); thread.setDaemon(true); thread.setPriority(priority); return thread; } }; }\n\n    ### Response:", "ground_truth": "Creates new daemon thread factory.", "predict": " Creates and returns a thread factory that will create daemon threads with the given name prefix and priority.\n\n@param name the name of the threads\n@param priority the priority of the threads\n@return a thread factory."}, {"ID": 1477, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Supplier<T> memoizedNonEmpty(Supplier<T> actual) { return new Supplier<T>() { Supplier<T> delegate = this::initialize; boolean initialized; public T get() { return delegate.get(); } private synchronized T initialize() { if (!initialized) { T value = actual.get(); if (value == null) { return null; } if (value instanceof Optional) { if (!((Optional) value).isPresent()) { return value; } } delegate = () -> value; initialized = true; } return delegate.get(); } }; }\n\n    ### Response: Caches the result of supplier in a thread safe manner. The result\nis only cached if it is non null or non empty if an optional.\n\n@param actual The supplier providing the result\n@param  The type of result\n@return A new supplier that will cache the result.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T get() { if (!initialized) { synchronized (this) { if (!initialized) { final T t = supplier.get(); value = t; initialized = true; supplier = null; return t; } } } return value; }\n\n    ### Response:", "ground_truth": "Returns the value. Value will be computed on first call.", "predict": " Returns the cached value of the supplier. If the value is not cached, it will be computed and cached.\n\n@return The cached value of the supplier."}, {"ID": 1478, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitParameter(String name, int access) { if (mv != null) { mv.visitParameter(name, access); } }\n\n    ### Response: Visits a parameter of this method.\n\n@param name\nparameter name or null if none is provided.\n@param access\nthe parameter's access flags, only ACC_FINAL,\nACC_SYNTHETIC or/and ACC_MANDATED are\nallowed (see {@link Opcodes})..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitParameter(final String name, final int access) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitParameter(name, access); } }\n\n    ### Response:", "ground_truth": "Visits a parameter of this method.\n\n@param name parameter name or null if none is provided.\n@param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\nor/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).", "predict": " Visits a parameter of this method.\n\n@param name\nparameter name or null if none is provided.\n@param access\nthe parameter's access flags, only ACC_FINAL,\nACC_SYNTHETIC or/and ACC_MANDATED are\nallowed (see {@link Opcodes}).\n@throws UnsupportedOperationException\nif the method is called by a class file version\nless than 52.0 (ASM 5.0).\n\n    "}, {"ID": 1479, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) { if (mv != null) { return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible); } return null; }\n\n    ### Response: Visits an annotation on a local variable type.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#LOCAL_VARIABLE\nLOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE\nRESOURCE_VARIABLE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param start\nthe fist instructions corresponding to the continuous ranges\nthat make the scope of this local variable (inclusive).\n@param end\nthe last instructions corresponding to the continuous ranges\nthat make the scope of this local variable (exclusive). This\narray must have the same size as the 'start' array.\n@param index\nthe local variable's index in each range. This array must have\nthe same size as the 'start' array.\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of this method.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "Visits an annotation of a method parameter, method return type, or a field.\n\n@param descriptor\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation."}, {"ID": 1480, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) { if (mv != null) { return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible); } return null; }\n\n    ### Response: Visits an annotation on a local variable type.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#LOCAL_VARIABLE\nLOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE\nRESOURCE_VARIABLE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param start\nthe fist instructions corresponding to the continuous ranges\nthat make the scope of this local variable (inclusive).\n@param end\nthe last instructions corresponding to the continuous ranges\nthat make the scope of this local variable (exclusive). This\narray must have the same size as the 'start' array.\n@param index\nthe local variable's index in each range. This array must have\nthe same size as the 'start' array.\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitTypeAnnotation( final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation on a type in the method signature.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\nTypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\nTypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\nTypeReference#THROWS}. See {@link TypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "Visits a type annotation.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#EXTENDS_BOUNDS\nEXTENDS_BOUNDS}, {@link TypeReference#TYPE_PARAMETER\nTYPE_PARAMETER}, {@link TypeReference#SUPERTYPE_OF_CLASS\nSUPERTYPE_OF_CLASS}, {@link TypeReference#IMPLEMENTS_INTERFACE\nIMPLEMENTS_INTERFACE}, or {@link TypeReference#WITHIN_TYPE\nWITHIN_TYPE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param descriptor\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation"}, {"ID": 1481, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) { if (mv != null) { return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible); } return null; }\n\n    ### Response: Visits an annotation on a local variable type.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#LOCAL_VARIABLE\nLOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE\nRESOURCE_VARIABLE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param start\nthe fist instructions corresponding to the continuous ranges\nthat make the scope of this local variable (inclusive).\n@param end\nthe last instructions corresponding to the continuous ranges\nthat make the scope of this local variable (exclusive). This\narray must have the same size as the 'start' array.\n@param index\nthe local variable's index in each range. This array must have\nthe same size as the 'start' array.\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitParameterAnnotation( final int parameter, final String descriptor, final boolean visible) { if (mv != null) { return mv.visitParameterAnnotation(parameter, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of a parameter this method.\n\n@param parameter the parameter index. This index must be strictly smaller than the number of\nparameters in the method descriptor, and strictly smaller than the parameter count\nspecified in {@link #visitAnnotableParameterCount}. Important note: a parameter index i\nis not required to correspond to the i'th parameter descriptor in the method\ndescriptor", "predict": "Visits an annotation on a parameter of the method.\n\n@param parameter\nthe index of the parameter. This index is relative to the\nmethod's parameters, as declared in the Java Virtual Machine\nsignature.\n@param descriptor\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation."}, {"ID": 1482, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onVisitFieldInsn(int opcode, String owner, String name, String descriptor) { super.visitFieldInsn(opcode, owner, name, descriptor); }\n\n    ### Response: Visits a field instruction.\n\n@param opcode     The visited opcode.\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitFieldInsn( final int opcode, final String owner, final String name, final String descriptor) { if (mv != null) { mv.visitFieldInsn(opcode, owner, name, descriptor); } }\n\n    ### Response:", "ground_truth": "Visits a field instruction. A field instruction is an instruction that loads or stores the\nvalue of a field of an object.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nGETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n@param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).", "predict": " Visits a field instruction.\n\n@param opcode     The visited opcode.\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor."}, {"ID": 1483, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) { if (mv != null) { mv.visitMethodInsn(opcode, owner, name, desc, itf); } }\n\n    ### Response: Visits a method instruction. A method instruction is an instruction that\ninvokes a method.\n\n@param opcode\nthe opcode of the type instruction to be visited. This opcode\nis either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or\nINVOKEINTERFACE.\n@param owner\nthe internal name of the method's owner class (see\n{@link Type#getInternalName() getInternalName}).\n@param name\nthe method's name.\n@param desc\nthe method's descriptor (see {@link Type Type}).\n@param itf\nif the method's owner class is an interface..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitMethodInsn( final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) { if (api < Opcodes.ASM5) { if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) { throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\"); } visitMethodInsn(opcode, owner, name, descriptor); return; } if (mv != null) { mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface); } }\n\n    ### Response:", "ground_truth": "Visits a method instruction. A method instruction is an instruction that invokes a method.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nINVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n@param owner the internal name of the method's owner class (see {@link\nType#getInternalName()}).\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param isInterface if the method's owner class is an interface.", "predict": "Visits a method instruction. A method instruction is an instruction that invokes a method.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n@param owner the internal name of the method's owner class (see {@link Type#getInternalName() getInternalName}).\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type Type}).\n@param isInterface if the method's owner class is an interface."}, {"ID": 1484, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String addParameter(final String url, final String name, final String value) { if (url != null) { final StringBuilder sb = new StringBuilder(); sb.append(url); if (name != null) { if (url.indexOf(\"?\") >= 0) { sb.append(\"&\"); } else { sb.append(\"?\"); } sb.append(name); sb.append(\"=\"); if (value != null) { sb.append(urlEncode(value)); } } return sb.toString(); } return null; }\n\n    ### Response: Add a new parameter to an url.\n\n@param url   url\n@param name  name of the parameter\n@param value value of the parameter\n@return the new url with the parameter appended.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitInvokeDynamicInsn( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments); } }\n\n    ### Response:", "ground_truth": "Visits an invokedynamic instruction.\n\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param bootstrapMethodHandle the bootstrap method.\n@param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\nan {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\nType}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\nthe content of the array so a caller should expect that this array may change.", "predict": " Visit an invokedynamic instruction.\n\n@param name                  the method name\n@param descriptor            the method descriptor (see {@link org.objectweb.asm.Type Type})\n@param bootstrapMethodHandle the bootstrap method handle\n@param bootstrapMethodArguments the bootstrap method arguments\n@throws UnsupportedOperationException if invokedynamic is not supported by this class version."}, {"ID": 1485, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitJumpInsn(final int opcode, final Label lbl) { super.visitJumpInsn(opcode, lbl); LabelNode ln = ((JumpInsnNode) instructions.getLast()).label; if (opcode == JSR && !subroutineHeads.containsKey(ln)) { subroutineHeads.put(ln, new BitSet()); } }\n\n    ### Response: Detects a JSR instruction and sets a flag to indicate we will need to do\ninlining..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } }\n\n    ### Response:", "ground_truth": "Visits a jump instruction. A jump instruction is an instruction that may jump to another\ninstruction.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\nIFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\nIF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n@param label the operand of the instruction to be visited. This operand is a label that\ndesignates the instruction to which the jump instruction may jump.", "predict": " This method is responsible for visiting a jump instruction. It calls the visitJumpInsn method of the MethodVisitor object passed in as a parameter."}, {"ID": 1486, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitRequire(String module, int access, String version) { if (mv != null) { mv.visitRequire(module, access, version); } }\n\n    ### Response: Visits a dependence of the current module.\n\n@param module the qualified name of the dependence.\n@param access the access flag of the dependence among\nACC_TRANSITIVE, ACC_STATIC_PHASE, ACC_SYNTHETIC\nand ACC_MANDATED.\n@param version the module version at compile time or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) { if (mv != null) { mv.visitMultiANewArrayInsn(descriptor, numDimensions); } }\n\n    ### Response:", "ground_truth": "Visits a MULTIANEWARRAY instruction.\n\n@param descriptor an array type descriptor (see {@link Type}).\n@param numDimensions the number of dimensions of the array to allocate.", "predict": "Visits a multiple array creation instruction.\n\n@param descriptor an array type descriptor (see {@link Type Type}).\n@param numDimensions the number of dimensions of the array to be created."}, {"ID": 1487, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitTryCatchBlock(Label start, Label end, Label handler, String type) { if (type != null) { handlers.put(handler, type); } super.visitTryCatchBlock(start, end, handler, type); }\n\n    ### Response: Visit a try catch block. We will use this to determine the exception\nhandler labels for the try block.\n\n@param start\nthe beginning of the try block\n@param end\nthe end of the try block\n@param handler\nthe exception handler\n@param type\nthe internal name of the throwable being handled.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitTryCatchBlock( final Label start, final Label end, final Label handler, final String type) { if (mv != null) { mv.visitTryCatchBlock(start, end, handler, type); } }\n\n    ### Response:", "ground_truth": "Visits a try catch block.\n\n@param start the beginning of the exception handler's scope (inclusive).\n@param end the end of the exception handler's scope (exclusive).\n@param handler the beginning of the exception handler's code.\n@param type the internal name of the type of exceptions handled by the handler, or {@literal\nnull} to catch any exceptions (for \"finally\" blocks).\n@throws IllegalArgumentException if one of the labels has already been visited by this visitor\n(by the {@link #visitLabel} method).", "predict": "Visit a try catch block. We will use this to determine the exception\nhandler labels for the try block.\n\n@param start\nthe beginning of the try block\n@param end\nthe end of the try block\n@param handler\nthe exception handler\n@param type\nthe internal name of the throwable being handled."}, {"ID": 1488, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) { if (mv != null) { return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible); } return null; }\n\n    ### Response: Visits an annotation on a local variable type.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#LOCAL_VARIABLE\nLOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE\nRESOURCE_VARIABLE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param start\nthe fist instructions corresponding to the continuous ranges\nthat make the scope of this local variable (inclusive).\n@param end\nthe last instructions corresponding to the continuous ranges\nthat make the scope of this local variable (exclusive). This\narray must have the same size as the 'start' array.\n@param index\nthe local variable's index in each range. This array must have\nthe same size as the 'start' array.\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation( final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitLocalVariableAnnotation( typeRef, typePath, start, end, index, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation on a local variable type.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\nTypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param start the fist instructions corresponding to the continuous ranges that make the scope\nof this local variable (inclusive).\n@param end the last instructions corresponding to the continuous ranges that make the scope of\nthis local variable (exclusive). This array must have the same size as the 'start' array.\n@param index the local variable's index in each range. This array must have the same size as\nthe 'start' array.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation on a local variable type.\n\n@param typeRef\na reference to the annotated type. The sort of this type\nreference must be {@link TypeReference#LOCAL_VARIABLE\nLOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE\nRESOURCE_VARIABLE}. See {@link TypeReference}.\n@param typePath\nthe path to the annotated type argument, wildcard bound, array\nelement type, or static inner type within 'typeRef'. May be\nnull if the annotation targets 'typeRef' as a whole.\n@param start\nthe fist instructions corresponding to the continuous ranges\nthat make the scope of this local variable (inclusive).\n@param end\nthe last instructions corresponding to the continuous ranges\nthat make the scope of this local variable (exclusive). This\narray must have the same size as the 'start' array.\n@param index\nthe local variable's index in each range. This array must have\nthe same size as the 'start' array.\n@param descriptor\nthe class descriptor"}, {"ID": 1489, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void load(final Properties properties, final InputStream stream) throws IOException { try { properties.load(stream); } finally { stream.close(); } }\n\n    ### Response: Puts all properties from a stream to an existing properties object. Already existing properties will be\noverridden.\n\n@param properties\nRead properties will be put to this properties object\n@param stream\nInput stream with a properties file\n@throws IOException\nFailed reading properties from input stream.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException { final BufferedWriter bw = getBufferedWriter(writer); writeBaseAndProfileProperties(bw, properties, profiles); writeProfilePropertiesThatAreNotInTheBase(bw, properties, profiles); bw.flush(); }\n\n    ### Response:", "ground_truth": "Convert Java Properties to Jodd Props format\n\n@param writer     Writer to write Props formatted file content to\n@param properties Properties to convert to Props format\n@param profiles   Properties per profile to convert and add to the Props format\n@throws IOException On any I/O error when writing to the writer", "predict": " Converts properties to a writer.\n\n@param writer\nWriter to write the properties to\n@param properties\nProperties to be written\n@param profiles\nMap of profile names and their properties\n@throws IOException\nFailed writing to writer.\n\n    "}, {"ID": 1490, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"rawtypes\") @Override public long sizeInputStreamData(Map isd) throws UnsupportedEncodingException, IllegalStateException { validateInputStreamData(isd); // The length of IMPUT_STREAM_CONTENT_TYPE won't exceed Integer.MAX_VALUE long size = LENGTH_INT + LENGTH_LONG; String type = (String)isd.get(INPUT_STREAM_CONTENT_TYPE); if (type != null) { size += type.getBytes(\"UTF-8\").length; } else { size +=1; // if the size is zero, one byte data will be used for placeholder. } byte [] data = (byte [])isd.get(INPUT_STREAM_CONTENT_DATA); if (data != null) { size += data.length; } if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable (Level.FINE)) logger.logp(Level.FINE, CLASS_NAME,\"sizeInputStreamData\", Long.toString(size)); return size; }\n\n    ### Response: returns estimated size of serialized InputStreamData\nthis code does not consider that the length in long overwraps..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void processStream() throws IOException { FastByteArrayOutputStream out = new FastByteArrayOutputStream(); size = 0; if (maxFileSize == -1) { size += input.copyAll(out); } else { size += input.copyMax(out, maxFileSize + 1); // one more byte to detect larger files if (size > maxFileSize) { fileTooBig = true; valid = false; input.skipToBoundary(); return; } } data = out.toByteArray(); size = data.length; valid = true; }\n\n    ### Response:", "ground_truth": "Reads data from input stream into byte array and stores file size.", "predict": " reads the input stream and stores the data in a byte array. If the size of the data exceeds the maximum file size, the file is marked as too big and the input stream is advanced to the next boundary."}, {"ID": 1491, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <E extends Exception, E2 extends Exception> void parse(final ResultSet rs, long offset, long count, final int processThreadNum, final int queueSize, final Try.Consumer<Object[], E> rowParser, final Try.Runnable<E2> onComplete) throws UncheckedSQLException, E, E2 { final Iterator<Object[]> iter = new ObjIterator<Object[]>() { private final JdbcUtil.BiRecordGetter<Object[], RuntimeException> biFunc = BiRecordGetter.TO_ARRAY; private List<String> columnLabels = null; private boolean hasNext; @Override public boolean hasNext() { if (hasNext == false) { try { hasNext = rs.next(); } catch (SQLException e) { throw new UncheckedSQLException(e); } } return hasNext; } @Override public Object[] next() { if (hasNext() == false) { throw new NoSuchElementException(); } hasNext = false; try { if (columnLabels == null) { columnLabels = JdbcUtil.getColumnLabelList(rs); } return biFunc.apply(rs, columnLabels); } catch (SQLException e) { throw new UncheckedSQLException(e); } } }; Iterables.parse(iter, offset, count, processThreadNum, queueSize, rowParser, onComplete); }\n\n    ### Response: Parse the ResultSet.\n\n@param stmt\n@param offset\n@param count\n@param processThreadNum new threads started to parse/process the lines/records\n@param queueSize size of queue to save the processing records/lines loaded from source data. Default size is 1024.\n@param rowParser\n@param onComplete\n@throws UncheckedSQLException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T next() { if (hasNext == null) { hasNext = Boolean.valueOf(moveToNext()); } if (hasNext == false) { throw new NoSuchElementException(); } if (!entityAwareMode) { hasNext = null; return newElement; } count++; T result = previousElement; previousElement = newElement; hasNext = null; return result; }\n\n    ### Response:", "ground_truth": "Returns next mapped object.", "predict": " Get the next element from the iterator.\n\n@return the next element in the iteration.\n\n    "}, {"ID": 1492, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isConsistentWith(final BaseBankCardTrackData other) { if (this == other) { return true; } if (other == null) { return false; } boolean equals = true; if (hasAccountNumber() && other.hasAccountNumber()) { if (!getAccountNumber().equals(other.getAccountNumber())) { equals = false; } } if (hasExpirationDate() && other.hasExpirationDate()) { if (!getExpirationDate().equals(other.getExpirationDate())) { equals = false; } } if (hasServiceCode() && other.hasServiceCode()) { if (!getServiceCode().equals(other.getServiceCode())) { equals = false; } } return equals; }\n\n    ### Response: Verifies that the available data is consistent between Track 1 and\nTrack 2, or any other track.\n\n@return True if the data is consistent..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean moveToNext() { if (last) { // last has been set to true, so no more rows to iterate - close everything if (closeOnEnd) { query.close(); } else { query.closeResultSet(resultSetMapper.getResultSet()); } return false; } while (true) { if (!resultSetMapper.next()) { // no more rows, no more parsing, previousElement is the last one to iterate last = true; return entityAwareMode; } // parse row Object[] objects = resultSetMapper.parseObjects(types); Object row = query.resolveRowResults(objects); newElement = (T) row; if (entityAwareMode) { if (count == 0 && previousElement == null) { previousElement = newElement; continue; } if (previousElement != null && newElement != null) { boolean equals; if (newElement.getClass().isArray()) { equals = Arrays.equals((Object[]) previousElement, (Object[]) newElement); } else { equals = previousElement.equals(newElement); } if (equals) { continue; } } } break; } return true; }\n\n    ### Response:", "ground_truth": "Moves to next element.", "predict": " Moves the cursor to the next row in the result set.\n\n@return True if there is a next row, false otherwise."}, {"ID": 1493, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nonnull @MayContainNull @Weight(Weight.Unit.NORMAL) public static <T> T[] joinArrays(@MayContainNull final T[]... arrays) { int commonLength = 0; for (final T[] array : arrays) { if (array != null) { commonLength += array.length; } } @SuppressWarnings(\"unchecked\") final T[] result = (T[]) Array.newInstance(arrays.getClass().getComponentType().getComponentType(), commonLength); int position = 0; for (final T[] array : arrays) { if (array != null) { System.arraycopy(array, 0, result, position, array.length); position += array.length; } } return result; }\n\n    ### Response: Join arrays provided as parameters, all arrays must be the same type, null\nvalues allowed.\n\n@param  type of array\n@param arrays array of arrays to be joined\n@return all joined arrays as single array\n@since 1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(T[]... arrays) { Class<T> componentType = (Class<T>) arrays.getClass().getComponentType().getComponentType(); return join(componentType, arrays); }\n\n    ### Response:", "ground_truth": "Joins arrays. Component type is resolved from the array argument.", "predict": " Joins multiple arrays of the same type into a single array.\n\n@param arrays array of arrays to be joined\n@return all joined arrays as single array\n@since 1.0."}, {"ID": 1494, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs public static <T> T[] concat(T[] first, T[]... rest) { int length = first.length; for (T[] array : rest) { length += array.length; } T[] result = Arrays.copyOf(first, length); int offset = first.length; for (T[] array : rest) { System.arraycopy(array, 0, result, offset, array.length); offset += array.length; } return result; }\n\n    ### Response: Concatenates several reference arrays.\n\n@param  the type of the elements in the array\n@param first the first array\n@param rest the rest of the arrays\n@return a single array containing all elements in all arrays.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(Class<T> componentType, T[][] arrays) { if (arrays.length == 1) { return arrays[0]; } int length = 0; for (T[] array : arrays) { length += array.length; } T[] result = (T[]) Array.newInstance(componentType, length); length = 0; for (T[] array : arrays) { System.arraycopy(array, 0, result, length, array.length); length += array.length; } return result; }\n\n    ### Response:", "ground_truth": "Joins arrays using provided component type.", "predict": " Joins several arrays of the same type into a single array.\n\n@param componentType the type of the elements in the arrays\n@param arrays the arrays to join\n@return a single array containing all elements in all arrays."}, {"ID": 1495, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] arrayCopyOf(T[] array, int newSize) { @SuppressWarnings(\"unchecked\") T[] newArr = (T[]) Array.newInstance(array.getClass().getComponentType(), newSize); System.arraycopy(array, 0, newArr, 0, Math.min(newSize, newArr.length)); return newArr; }\n\n    ### Response: Utility method similar to Java 1.6 Arrays.copyOf, used instead of that method to stick to Java 1.5 only API.\n\n@param  the type of the array entries\n@param array the array to copy\n@param newSize the size of the new array\n@return a new array of the specified size containing the supplied array elements at the beginning.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] resize(T[] buffer, int newSize) { Class<T> componentType = (Class<T>) buffer.getClass().getComponentType(); T[] temp = (T[]) Array.newInstance(componentType, newSize); System.arraycopy(buffer, 0, temp, 0, buffer.length >= newSize ? newSize : buffer.length); return temp; }\n\n    ### Response:", "ground_truth": "Resizes an array.", "predict": " Utility method to resize an array.\n\n@param buffer the array to resize\n@param newSize the new size of the array\n@return a new array of the specified size containing the elements of the original array. If the original array is larger than the new size, the extra elements are discarded. If the original array is smaller than the new size, the new elements are initialized to null."}, {"ID": 1496, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] add(final T[] ar, final T e) { final int s = ar.length; final T[] t = Arrays.copyOf(ar, s + 1); t[s] = e; return t; }\n\n    ### Response: Adds an entry to the end of an array and returns the new array.\n\n@param ar  array to be resized\n@param e   entry to be added\n@param  array type\n@return array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] append(T[] buffer, T newElement) { T[] t = resize(buffer, buffer.length + 1); t[buffer.length] = newElement; return t; }\n\n    ### Response:", "ground_truth": "Appends an element to array.", "predict": " Adds an entry to the end of an array and returns the new array.\n\n@param buffer  array to be resized\n@param newElement  entry to be added\n@param  array type\n@return resized array."}, {"ID": 1497, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) { byte[] temp = new byte[length + 1]; getOctalBytes( value, temp, 0, length + 1 ); System.arraycopy( temp, 0, buf, offset, length ); return offset + length; }\n\n    ### Response: Write an octal long integer to a header buffer.\n\n@param value\nThe value to write.\n@param buf\nThe header buffer from which to parse.\n@param offset\nThe offset into the buffer from which to parse.\n@param length\nThe number of header bytes to parse.\n\n@return The long value of the octal bytes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] remove(T[] buffer, int offset, int length, Class<T> componentType) { int len2 = buffer.length - length; T[] temp = (T[]) Array.newInstance(componentType, len2); System.arraycopy(buffer, 0, temp, 0, offset); System.arraycopy(buffer, offset + length, temp, offset, len2 - offset); return temp; }\n\n    ### Response:", "ground_truth": "Removes sub-array.", "predict": " Remove a range of elements from an array.\n\n@param buffer\nThe array from which to remove elements.\n@param offset\nThe offset of the first element to remove.\n@param length\nThe number of elements to remove.\n@param componentType\nThe type of the elements to remove.\n\n@return A new array with the specified elements removed."}, {"ID": 1498, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findNot(int[] array, int value) { for (int i = 0; i < array.length; i++) { if (array[i] != value) { return i; } } return -1; }\n\n    ### Response: Finds the first element of the array that is not equal to the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(char[] array, char value) { for (int i = 0; i < array.length; i++) { if (array[i] == value) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds the first occurrence of an element in an array.", "predict": " Finds the index of the first occurrence of the given value in the array. If the value is not found, returns -1."}, {"ID": 1499, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findNot(int[] array, int value) { for (int i = 0; i < array.length; i++) { if (array[i] != value) { return i; } } return -1; }\n\n    ### Response: Finds the first element of the array that is not equal to the given value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(Object[] array, Object value) { for (int i = 0; i < array.length; i++) { if (array[i].equals(value)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds the first occurrence in an array.", "predict": " Finds the index of the first occurrence of the specified value in the specified array. If the value is not found, returns -1."}, {"ID": 1500, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte readByte(boolean[] rawbits, int startIndex) { int n = rawbits.length - startIndex; if (n >= 8) { return (byte) readCode(rawbits, startIndex, 8); } return (byte) (readCode(rawbits, startIndex, n) << (8 - n)); }\n\n    ### Response: Reads a code of length 8 in an array of bits, padding with zeros.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(byte[] array, byte[] sub, int startIndex) { return indexOf(array, sub, startIndex, array.length); }\n\n    ### Response:", "ground_truth": "Finds the first occurrence in an array from specified given position.", "predict": " Finds the index of the first occurrence of the specified subarray within the specified array, starting the search at the specified index.\n\n    "}, {"ID": 1501, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function hasTag($tag) { // check if all tags exist if (is_array($tag)) { foreach ($tag as $t) { if (!$this->hasTag($t)) { return false; } } return true; } // check if tag exist $a = explode('#', $tag); $tag = array_shift($a); //$ref = array_shift($a); // unused return isset($this->tags[$tag]) || $this->isTopTag($tag); }\n\n    ### Response: Checks if template has defined a specified tag.\nIf multiple tags are passed in as array, then return true if all of them exist.\n\n@param string|array $tag\n\n@return bool.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LagartoDOMBuilder enableXhtmlMode() { config.ignoreWhitespacesBetweenTags = false; // collect all whitespaces config.setCaseSensitive(true); // XHTML is case sensitive config.setEnableRawTextModes(false); // all tags are parsed in the same way config.enabledVoidTags = true; // list of void tags config.selfCloseVoidTags = true; // self close void tags config.impliedEndTags = false; // no implied tag ends config.setEnableConditionalComments(false); // don't enable IE conditional comments config.setParseXmlTags(false); // enable XML mode in parsing return this; }\n\n    ### Response:", "ground_truth": "Enables XHTML mode.", "predict": " Enables XHTML mode for the LagartoDOMBuilder.\n\n@return LagartoDOMBuilder."}, {"ID": 1502, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Element parseBodyFragment(String content) { Document doc = Jsoup.parseBodyFragment(content); return doc.body(); }\n\n    ### Response: A generic method to use jsoup parser on an arbitrary HTML body fragment. Allows writing\nHTML manipulations in the template without adding Java code to the class.\n\n@param content\nHTML content to parse\n@return the wrapper element for the parsed content (i.e. the body element as if the content\nwas body contents).\n@since 1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Document parse(final char[] content) { LagartoParser lagartoParser = new LagartoParser(content); return doParse(lagartoParser); }\n\n    ### Response:", "ground_truth": "Creates DOM tree from provided content.", "predict": " Parses the given HTML content using the Lagarto parser.\n\n@param content\nthe HTML content to parse\n@return the parsed document\n@throws IOException\nif an I/O error occurs during parsing\n@since 1.0.0\n\n    "}, {"ID": 1503, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Document getDocument(InputStream in) throws Exception { DocumentBuilder builder = XmlTransformUtility.borrowDocumentBuilder(); Document doc = null; try { doc = builder.parse(in); } finally { XmlTransformUtility.returnDocumentBuilder(builder); } return doc; }\n\n    ### Response: Get a new DOM Document object from parsing the specified InputStream.\n\n@param in\nthe InputStream to parse.\n@return a new DOM Document object.\n@throws ParserConfigurationException\nif a DocumentBuilder cannot be created.\n@throws SAXException\nIf any parse errors occur.\n@throws IOException\nIf any IO errors occur..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Document doParse(final LagartoParser lagartoParser) { lagartoParser.setConfig(config); LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this); lagartoParser.parse(domBuilderTagVisitor); return domBuilderTagVisitor.getDocument(); }\n\n    ### Response:", "ground_truth": "Parses the content using provided lagarto parser.", "predict": " Parse the specified LagartoParser object and return a new DOM Document object.\n\n@param lagartoParser\nthe LagartoParser object to parse.\n@return a new DOM Document object.\n@throws ParserConfigurationException\nif a DocumentBuilder cannot be created.\n@throws SAXException\nIf any parse errors occur.\n@throws IOException\nIf any IO errors occur."}, {"ID": 1504, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void noSuccessor() { if (compute == FRAMES) { Label l = new Label(); l.frame = new Frame(); l.frame.owner = l; l.resolve(this, code.length, code.data); previousBlock.successor = l; previousBlock = l; } else { currentBlock.outputStackMax = maxStackSize; } currentBlock = null; }\n\n    ### Response: Ends the current basic block. This method must be used in the case where\nthe current basic block does not have any successor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void endCurrentBasicBlockWithNoSuccessor() { if (compute == COMPUTE_ALL_FRAMES) { Label nextBasicBlock = new Label(); nextBasicBlock.frame = new Frame(nextBasicBlock); nextBasicBlock.resolve(code.data, code.length); lastBasicBlock.nextBasicBlock = nextBasicBlock; lastBasicBlock = nextBasicBlock; currentBasicBlock = null; } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) { currentBasicBlock.outputStackMax = (short) maxRelativeStackSize; currentBasicBlock = null; } }\n\n    ### Response:", "ground_truth": "Ends the current basic block. This method must be used in the case where the current basic\nblock does not have any successor.\n\nWARNING: this method must be called after the currently visited instruction has been put in\n{@link #code} (if frames are computed, this method inserts a new Label to start a new basic\nblock after the current instruction).", "predict": "Ends the current basic block. This method must be used in the case where the current basic block does not have any successor."}, {"ID": 1505, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private TextWatcher createTextChangeListener() { return new TextWatcher() { @Override public final void beforeTextChanged(final CharSequence s, final int start, final int count, final int after) { } @Override public final void onTextChanged(final CharSequence s, final int start, final int before, final int count) { } @Override public final void afterTextChanged(final Editable s) { if (isValidatedOnValueChange()) { validate(); } adaptMaxNumberOfCharactersMessage(); } }; }\n\n    ### Response: Creates and returns a listener, which allows to validate the value of the view, when its text\nhas been changed.\n\n@return The listener, which has been created, as an instance of the type {@link TextWatcher}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void collectAttributePrototypes(final Attribute.Set attributePrototypes) { attributePrototypes.addAttributes(firstAttribute); attributePrototypes.addAttributes(firstCodeAttribute); }\n\n    ### Response:", "ground_truth": "Collects the attributes of this method into the given set of attribute prototypes.\n\n@param attributePrototypes a set of attribute prototypes.", "predict": " Collects the attribute prototypes of the view, which are used to define the attributes of the view.\n\n@param attributePrototypes The attribute prototypes, which have been collected, as an instance of the type {@link Attribute.Set}."}, {"ID": 1506, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function lookupProxy($lookupName) { // load the initial context instance $initialContext = $this->getInitialContext(); // query whether a request context is available if ($servletRequest = RequestHandler::getRequestContext()) { // inject the servlet request to handle SFSBs correctly $initialContext->injectServletRequest($servletRequest); } // return the proxy instance return $initialContext->lookup($lookupName); }\n\n    ### Response: This returns a proxy to the requested session bean. If the proxy has already been\ninstanciated for the actual request, the existing instance will be returned.\n\n@param string $lookupName The lookup name for the requested session bean\n\n@return \\AppserverIo\\RemoteMethodInvocation\\RemoteObjectInterface The proxy instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectContext(final Object targetObject) { final Class targetType = targetObject.getClass(); final ScopeData scopeData = scopeDataInspector.inspectClassScopesWithCache(targetType); final Targets targets = new Targets(targetObject, scopeData); // inject no context scopeResolver.forEachScope(madvocScope -> madvocScope.inject(targets)); // inject special case scopeResolver.forScope(ParamsScope.class, scope -> scope.inject(targets)); // inject servlet context final ServletContext servletContext = madvocController.getApplicationContext(); if (servletContext != null) { scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); } }\n\n    ### Response:", "ground_truth": "Inject context into target.", "predict": " This method injects the required context into the given target object. The method uses the scope data inspector to determine the required scopes for the target object and then injects them using the scope resolver.\n\n@param targetObject The object to inject the context into.\n\n@return void"}, {"ID": 1507, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void scanAllNodes(Parent parent, PseudoClass pseudoClass) { parent.getChildrenUnmodifiable().addListener(new ListChangeListener<Node>() { @Override public void onChanged(javafx.collections.ListChangeListener.Change<? extends Node> c) { while (c.next()) { if (!c.wasPermutated() && !c.wasUpdated()) { for (Node addedNode : c.getAddedSubList()) { if (addedNode instanceof Parent) { scanAllNodes((Parent) addedNode, pseudoClass); } } } } } }); for (Node component : parent.getChildrenUnmodifiable()) { if (component instanceof Pane) { ((Pane) component).getChildren().addListener(new ListChangeListener<Node>() { @Override public void onChanged(javafx.collections.ListChangeListener.Change<? extends Node> c) { while (c.next()) { if (!c.wasPermutated() && !c.wasUpdated()) { for (Node addedNode : c.getAddedSubList()) { if (addedNode instanceof Parent) { scanAllNodes((Parent) addedNode, pseudoClass); } } } } } }); //if the component is a container, scan its children scanAllNodes((Pane) component, pseudoClass); } else if (component instanceof ScrollPane) { ((ScrollPane) component).contentProperty().addListener((o, oldVal, newVal) -> { scanAllNodes((Parent) newVal, pseudoClass); }); //if the component is a container, scan its children if (((ScrollPane) component).getContent() instanceof Parent) { scanAllNodes((Parent) ((ScrollPane) component).getContent(), pseudoClass); } } else if (component instanceof Control) { //if the component is an instance of IInputControl, add to list component.pseudoClassStateChanged(PSEUDO_CLASS_EX_SMALL, pseudoClass == PSEUDO_CLASS_EX_SMALL); component.pseudoClassStateChanged(PSEUDO_CLASS_SMALL, pseudoClass == PSEUDO_CLASS_SMALL); component.pseudoClassStateChanged(PSEUDO_CLASS_MEDIUM, pseudoClass == PSEUDO_CLASS_MEDIUM); component.pseudoClassStateChanged(PSEUDO_CLASS_LARGE, pseudoClass == PSEUDO_CLASS_LARGE); } } }\n\n    ### Response: scans all nodes in the scene and apply the css pseduoClass to them.\n\n@param parent      stage parent node\n@param pseudoClass css class for certain device.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerPseudoClass(final Class<? extends PseudoClass> pseudoClassType) { PseudoClass pseudoClass; try { pseudoClass = ClassUtil.newInstance(pseudoClassType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass); }\n\n    ### Response:", "ground_truth": "Registers pseudo class.", "predict": "registers a pseudo class to the pseudo class map.\n\n@param pseudoClassType pseudo class type to be registered."}, {"ID": 1508, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String getAttribute(Node node, String name, boolean required) { NamedNodeMap attributes = node.getAttributes(); Node idNode = attributes.getNamedItem(name); if (idNode == null) { if (required) { throw new IllegalArgumentException(toPath(node) + \" has no \" + name + \" attribute\"); } else { return \"\"; } } else { String value = idNode.getNodeValue(); if (value == null) { return \"\"; } return value; } }\n\n    ### Response: Get an Attribute from the given node and throwing an exception in the case it is required but\nnot present\n\n@param node\n@param name\n@param required\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PseudoClass lookupPseudoClass(final String pseudoClassName) { PseudoClass pseudoClass = PSEUDO_CLASS_MAP.get(pseudoClassName); if (pseudoClass == null) { throw new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName); } return pseudoClass; }\n\n    ### Response:", "ground_truth": "Lookups pseudo class for given pseudo class name.", "predict": " Lookup the PseudoClass for the given pseudo class name.\n\n@param pseudoClassName\n@return the PseudoClass for the given pseudo class name.\n\n    "}, {"ID": 1509, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Weight(value = Weight.Unit.VARIABLE, comment = \"Depends on the current call stack depth\") public static void processDeferredActions() { final int stackDepth = ThreadUtils.stackDepth(); final List<Deferred> list = REGISTRY.get(); final Iterator<Deferred> iterator = list.iterator(); while (iterator.hasNext()) { final Deferred deferred = iterator.next(); if (deferred.getStackDepth() >= stackDepth) { try { deferred.executeDeferred(); } catch (Exception ex) { final UnexpectedProcessingError error = new UnexpectedProcessingError(\"Error during deferred action processing\", ex); MetaErrorListeners.fireError(error.getMessage(), error); } finally { iterator.remove(); } } } if (list.isEmpty()) { REGISTRY.remove(); } }\n\n    ### Response: Process all defer actions for the current stack depth level.\n\n@since 1.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void invoke(final ActionRequest actionRequest) { if (executorService == null) { throw new MadvocException(\"No action is marked as async!\"); } final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); log.debug(() -> \"Async call to: \" + actionRequest); final AsyncContext asyncContext = servletRequest.startAsync(); executorService.submit(() -> { try { actionRequest.invoke(); } catch (Exception ex) { log.error(\"Invoking async action path failed: \" , ExceptionUtil.unwrapThrowable(ex)); } finally { asyncContext.complete(); } }); }\n\n    ### Response:", "ground_truth": "Invokes an action asynchronously by submitting it to the thread pool.", "predict": "Invoke the action request asynchronously.\n\n@since 1.0."}, {"ID": 1510, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ParserContext singleBackingTypeParserContext() throws ExpressionCompileException { ParserContext context = new ParserContext(); context.setStrongTyping(true); context.addInput(\"this\", backingType); PropertyDescriptor[] propertyDescriptors; try { propertyDescriptors = Introspector.getBeanInfo(backingType).getPropertyDescriptors(); } catch (IntrospectionException e) { throw new ExpressionCompileException(\"Could not read class \" + backingType); } // read @Visible annotated fields. for (Field field : backingType.getDeclaredFields()) { if (field.isAnnotationPresent(Visible.class)) { context.addInput(field.getName(), field.getType()); if (!field.getAnnotation(Visible.class).readOnly()) { writeableProperties.add(field.getName()); } } } // read javabean properties -- these override @Visible fields. for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { // skip getClass() if (CLASS.equals(propertyDescriptor.getName())) continue; if (null != propertyDescriptor.getWriteMethod()) { writeableProperties.add(propertyDescriptor.getName()); } // if this is a collection, determine its type parameter if (Collection.class.isAssignableFrom(propertyDescriptor.getPropertyType())) { Type propertyType; if (propertyDescriptor.getReadMethod() != null) { propertyType = propertyDescriptor.getReadMethod().getGenericReturnType(); } else { propertyType = propertyDescriptor.getWriteMethod().getGenericParameterTypes()[0]; } ParameterizedType collectionType = (ParameterizedType) Generics .getExactSuperType(propertyType, Collection.class); Class<?>[] parameterClasses = new Class[1]; Type parameterType = collectionType.getActualTypeArguments()[0]; parameterClasses[0] = Generics.erase(parameterType); context.addInput(propertyDescriptor.getName(), propertyDescriptor.getPropertyType(), parameterClasses); } else { context.addInput(propertyDescriptor.getName(), propertyDescriptor.getPropertyType()); } } return context; }\n\n    ### Response: generates a parsing context with type information from the backing type's javabean properties.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] getAllBeanPropertyNames(final Class type, final boolean declared) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); ArrayList<String> names = new ArrayList<>(propertyDescriptors.length); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { MethodDescriptor getter = propertyDescriptor.getReadMethodDescriptor(); if (getter != null) { if (getter.matchDeclared(declared)) { names.add(propertyDescriptor.getName()); } } else if (includeFields) { FieldDescriptor field = propertyDescriptor.getFieldDescriptor(); if (field != null) { if (field.matchDeclared(declared)) { names.add(field.getName()); } } } } return names.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Returns all bean property names.", "predict": " returns an array of all the property names of a given class, including both declared and inherited properties."}, {"ID": 1511, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getAsText() { Object value = getValue(); if (value == null) { return \"\"; } String propertyName = null; // used in error handling below try { StringBuffer label = new StringBuffer(); for (int i = 0; i < properties.length; i++) { propertyName = properties[i]; Class<?> propertyType = PropertyUtils.getPropertyType(value, propertyName); Object propertyValue = PropertyUtils.getNestedProperty(value, propertyName); PropertyEditor editor = registry.findCustomEditor(propertyType, registryPropertyNamePrefix + propertyName); if (editor == null) { label.append(propertyValue); } else { editor.setValue(propertyValue); label.append(editor.getAsText()); editor.setValue(null); } if (i < (properties.length - 1)) { label.append(separator); } } return label.toString(); } catch (Exception e) { throw new IllegalArgumentException(\"Couldn't access \" + propertyName + \" of \" + value.getClass().getName() + \" : \" + e.getMessage(), e); } }\n\n    ### Response: Format the Object as String of concatenated properties..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit() { String[] properties = resolveProperties(source, declared); for (String name : properties) { if (name == null) { continue; } if (!rules.match(name, blacklist)) { continue; } Object value; String propertyName = name; if (isSourceMap) { propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } if (declared) { value = BeanUtil.declared.getProperty(source, propertyName); } else { value = BeanUtil.pojo.getProperty(source, propertyName); } if (value == null && ignoreNullValues) { continue; } if (value instanceof String && StringUtil.isEmpty((String) value)) { continue; } visitProperty(name, value); } }\n\n    ### Response:", "ground_truth": "Starts visiting properties.", "predict": " This method visits all the properties of the source object and applies the given rules to each property. If the property is not blacklisted and its value is not null or empty string, the visitProperty method is called with the property name and value."}, {"ID": 1512, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final File file) { if (file != null) { if (file.isDirectory()) { return true; } final String extension = getExtension(file); if (extension != null && filters.containsKey(extension)) { return true; } } return false; }\n\n    ### Response: Return true if this file should be shown in the directory pane, false if it shouldn't.\n\nFiles that begin with \".\" are ignored.\n\n@return boolean\n@param file\nFile\n@see #getExtension\n@see javax.swing.filechooser.FileFilter#accept.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final String propertyName, final String rule, final boolean include) { return propertyName.equals(rule); }\n\n    ### Response:", "ground_truth": "Compares property name to the rules.", "predict": " Return true if the given property name matches the given rule, false otherwise.\n\n@return boolean\n@param propertyName\nString\n@param rule\nString\n@param include\nboolean"}, {"ID": 1513, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MethodNode findSAM(ClassNode type) { if (!Modifier.isAbstract(type.getModifiers())) return null; if (type.isInterface()) { List<MethodNode> methods = type.getMethods(); MethodNode found=null; for (MethodNode mi : methods) { // ignore methods, that are not abstract and from Object if (!Modifier.isAbstract(mi.getModifiers())) continue; // ignore trait methods which have a default implementation if (Traits.hasDefaultImplementation(mi)) continue; if (mi.getDeclaringClass().equals(OBJECT_TYPE)) continue; if (OBJECT_TYPE.getDeclaredMethod(mi.getName(), mi.getParameters())!=null) continue; // we have two methods, so no SAM if (found!=null) return null; found = mi; } return found; } else { List<MethodNode> methods = type.getAbstractMethods(); MethodNode found = null; if (methods!=null) { for (MethodNode mi : methods) { if (!hasUsableImplementation(type, mi)) { if (found!=null) return null; found = mi; } } } return found; } }\n\n    ### Response: Returns the single abstract method of a class node, if it is a SAM type, or null otherwise.\n@param type a type for which to search for a single abstract method\n@return the method node if type is a SAM type, null otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodInjectionPoint[] resolve(final Class type) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method)) { // ignore setters continue; } if (method.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjectionPoints; if (list.isEmpty()) { methodInjectionPoints = MethodInjectionPoint.EMPTY; } else { methodInjectionPoints = list.toArray(new MethodInjectionPoint[0]); } return methodInjectionPoints; }\n\n    ### Response:", "ground_truth": "Resolve method injection points in given class.", "predict": " Resolves method injection points for a given class.\n@param type the class for which to resolve method injection points\n@return an array of method injection points, or an empty array if no method injection points were found."}, {"ID": 1514, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setGenericConf(Configuration conf, String nameserviceId, String... keys) { for (String key : keys) { String value = conf.get(getNameServiceIdKey(key, nameserviceId)); if (value != null) { conf.set(key, value); } } }\n\n    ### Response: Sets the node specific setting into generic configuration key. Looks up\nvalue of \"key.nameserviceId\" and if found sets that value into generic key\nin the conf. Note that this only modifies the runtime conf.\n\n@param conf\nConfiguration object to lookup specific key and to set the value\nto the key passed. Note the conf object is modified.\n@param nameserviceId\nnameservice Id to construct the node specific key.\n@param keys\nThe key for which node specific value is looked up.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void readFilterConfigParameters(final FilterConfig filterConfig, final Object target, final String... parameters) { for (String parameter : parameters) { String value = filterConfig.getInitParameter(parameter); if (value != null) { BeanUtil.declared.setProperty(target, parameter, value); } } }\n\n    ### Response:", "ground_truth": "Reads filter config parameters and set into destination target.", "predict": " Reads the filter configuration parameters and sets them to the target object.\n\n@param filterConfig\nFilterConfig object to lookup the parameters.\n@param target\nObject to set the parameters to.\n@param parameters\nThe parameters to lookup and set to the target object."}, {"ID": 1515, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(File sourceFile, File targetFile) throws IOException { FileInputStream in = new FileInputStream(sourceFile); try { FileOutputStream out = new FileOutputStream(targetFile); try { copy(in, out); } finally { out.close(); } } finally { in.close(); } }\n\n    ### Response: This method performs a simple copy of sourceFile to targetFile.\n\n@param sourceFile\nis the source file where it is to be copied from.\n@param targetFile\nis the file to which everything is to be copied to.\n@throws IOException\nis thrown in cases of IO issues..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void sendBundleFile(final HttpServletResponse resp, final File bundleFile) throws IOException { OutputStream out = resp.getOutputStream(); FileInputStream fileInputStream = new FileInputStream(bundleFile); try { StreamUtil.copy(fileInputStream, out); } finally { StreamUtil.close(fileInputStream); } }\n\n    ### Response:", "ground_truth": "Outputs bundle file to the response.", "predict": " This method sends the bundle file to the client.\n\n@param resp\nis the HTTP response object.\n@param bundleFile\nis the file that needs to be sent to the client.\n@throws IOException\nis thrown in case of any IO issues."}, {"ID": 1516, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private File resolveBasedir() throws IOException { String path = null; if (project != null) { File file = project.getBasedir(); if (file != null) { path = file.getAbsolutePath(); } } if (path == null) { path = session.getExecutionRootDirectory(); } if (path == null) { path = System.getProperty(\"user.dir\"); } return new File(path).getCanonicalFile(); }\n\n    ### Response: Resolves the base directory for the current execution..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File lookupBundleFile(String bundleId) { if ((mirrors != null) && (!mirrors.isEmpty())) { String realBundleId = mirrors.remove(bundleId); if (realBundleId != null) { bundleId = realBundleId; } } return createBundleFile(bundleId); }\n\n    ### Response:", "ground_truth": "Lookups for bundle file.", "predict": "Looks up the bundle file for the given bundle ID. If the bundle ID is in the mirror map, it will be replaced with the real bundle ID. The bundle file is then created using the bundle ID."}, {"ID": 1517, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File getHubOverride(String path) throws IOException { if (getOverrideRoot() != null) { File hubOverride = new File(getOverrideRoot() + path); if (hubOverride.isFile()) return hubOverride; } if (getDevOverrideRoot() != null && isDev()) { File devOverride = new File(getDevOverrideRoot() + path); if (devOverride.isFile()) return devOverride; } return null; }\n\n    ### Response: Finds overridden hub artifacts among assets.\nCore dev override is also supported for vanilla hub development..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File lookupGzipBundleFile(final File file) throws IOException { String path = file.getPath() + ZipUtil.GZIP_EXT; File gzipFile = new File(path); if (!gzipFile.exists()) { if (log.isDebugEnabled()) { log.debug(\"gzip bundle to \" + path); } ZipUtil.gzip(file); } return gzipFile; }\n\n    ### Response:", "ground_truth": "Locates gzipped version of bundle file. If gzip file\ndoes not exist, it will be created.", "predict": " Looks up the gzip bundle file for the given file. If it doesn't exist, it creates a gzip bundle file from the given file.\n\n    "}, {"ID": 1518, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String enumToString(final Enum<?> value) { if (value == null) { return null; } final String underscored = value.name(); final StringBuilder sb = new StringBuilder(); for (int i = 0; i < underscored.length(); i++) { final char c = underscored.charAt(i); if (c == '_') { sb.append(Character.toUpperCase(underscored.charAt(++i))); } else { sb.append(Character.toLowerCase(c)); } } return sb.toString(); }\n\n    ### Response: Convert an enumeration to a String representation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) { if (tempBundleId == null || sources.isEmpty()) { if (strategy == Strategy.ACTION_MANAGED) { // page does not include any resource source file actionBundles.put(actionPath, StringPool.EMPTY); } return null; } // create unique digest from the collected sources String[] sourcesArray = sources.toArray(new String[0]); for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) { sourcesArray[i] = sourcesArray[i].trim().toLowerCase(); } if (sortResources) { Arrays.sort(sourcesArray); } StringBand sb = new StringBand(sourcesArray.length); for (String src : sourcesArray) { sb.append(src); } String sourcesString = sb.toString(); String bundleId = createDigest(sourcesString); bundleId += '.' + bundleContentType; // bundle appears for the first time, create the bundle if (strategy == Strategy.ACTION_MANAGED) { actionBundles.put(actionPath, bundleId); mirrors.put(tempBundleId, bundleId); } try { createBundle(contextPath, actionPath, bundleId, sources); } catch (IOException ioex) { throw new HtmlStaplerException(\"Can't create bundle\", ioex); } return bundleId; }\n\n    ### Response:", "ground_truth": "Registers new bundle that consist of provided list of source paths.\nReturns the real bundle id, as provided one is just a temporary bundle id.", "predict": " Register a bundle for a given action path and sources. The bundle will be created if it does not exist yet. The bundle will be registered for the given action path and will be mirrored to the temporary bundle id. The bundle will be created using the given content type and sources. The method is synchronized to ensure thread safety."}, {"ID": 1519, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getAvatarHash() { byte[] bytes = getAvatar(); if (bytes == null) { return null; } MessageDigest digest; try { digest = MessageDigest.getInstance(\"SHA-1\"); } catch (NoSuchAlgorithmException e) { LOGGER.log(Level.SEVERE, \"Failed to get message digest\", e); return null; } digest.update(bytes); return StringUtils.encodeHex(digest.digest()); }\n\n    ### Response: Returns the SHA-1 Hash of the Avatar image.\n\n@return the SHA-1 Hash of the Avatar image..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createDigest(final String source) { final DigestEngine digestEngine = DigestEngine.sha256(); final byte[] bytes = digestEngine.digest(CharUtil.toSimpleByteArray(source)); String digest = Base32.encode(bytes); if (uniqueDigestKey != null) { digest += uniqueDigestKey; } return digest; }\n\n    ### Response:", "ground_truth": "Creates digest i.e. bundle id from given string.\nReturned digest must be filename safe, for all platforms.", "predict": " Generates a SHA-256 hash of the given source string and returns it as a Base32 encoded string. If a unique key is set, it is appended to the end of the hash.\n\n@param source the source string to generate the hash for\n@return the SHA-256 hash of the source string as a Base32 encoded string. If a unique key is set, it is appended to the end of the hash."}, {"ID": 1520, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getContent(TreeLogger logger, String path, String src) throws UnableToCompleteException { HttpURLConnection connection = null; InputStream in = null; try { if (!src.matches(\"(?i)https?://.*\")) { String file = path + \"/\" + src; in = this.getClass().getClassLoader().getResourceAsStream(file); if (in == null) { // If we didn't find the resource relative to the package, assume it is absolute. file = src; in = this.getClass().getClassLoader().getResourceAsStream(file); } if (in != null) { logger.log(TreeLogger.INFO, getClass().getSimpleName() + \" - importing external javascript: \" + file); } else { logger.log(TreeLogger.ERROR, \"Unable to read javascript file: \" + file); } } else { logger.log(TreeLogger.INFO, getClass().getSimpleName() + \" - downloading external javascript: \" + src); URL url = new URL(src); connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\"); connection.setRequestProperty(\"Host\", url.getHost()); connection.setConnectTimeout(3000); connection.setReadTimeout(3000); int status = connection.getResponseCode(); if (status != HttpURLConnection.HTTP_OK) { logger.log(TreeLogger.ERROR, \"Server Error: \" + status + \" \" + connection.getResponseMessage()); throw new UnableToCompleteException(); } String encoding = connection.getContentEncoding(); in = connection.getInputStream(); if (\"gzip\".equalsIgnoreCase(encoding)) { in = new GZIPInputStream(in); } else if (\"deflate\".equalsIgnoreCase(encoding)) { in = new InflaterInputStream(in); } } return inputStreamToString(in); } catch (IOException e) { logger.log(TreeLogger.ERROR, \"Error: \" + e.getMessage()); throw new UnableToCompleteException(); } finally { if (connection != null) { connection.disconnect(); } } }\n\n    ### Response: Get the content of a javascript source. It supports remote sources hosted in CDN's..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException { final File bundleFile = createBundleFile(bundleId); if (bundleFile.exists()) { return; } StringBand sb = new StringBand(sources.size() * 2); for (String src : sources) { if (sb.length() != 0) { sb.append(StringPool.NEWLINE); } String content; if (isExternalResource(src)) { content = downloadString(src); } else { if (!downloadLocal) { // load local resource from file system String localFile = webRoot; if (src.startsWith(contextPath + '/')) { src = src.substring(contextPath.length()); } if (src.startsWith(StringPool.SLASH)) { // absolute path localFile += src; } else { // relative path localFile += '/' + FileNameUtil.getPathNoEndSeparator(actionPath) + '/' + src; } // trim link parameters, if any int qmndx = localFile.indexOf('?'); if (qmndx != -1) { localFile = localFile.substring(0, qmndx); } try { content = FileUtil.readString(localFile); } catch (IOException ioex) { if (notFoundExceptionEnabled) { throw ioex; } if (log.isWarnEnabled()) { log.warn(ioex.getMessage()); } content = null; } } else { // download local resource String localUrl = localAddressAndPort; if (src.startsWith(StringPool.SLASH)) { localUrl += contextPath + src; } else { localUrl += contextPath + FileNameUtil.getPath(actionPath) + '/' + src; } content = downloadString(localUrl); } if (content != null) { if (isCssResource(src)) { content = fixCssRelativeUrls(content, src); } } } if (content != null) { content = onResourceContent(content); sb.append(content); } } FileUtil.writeString(bundleFile, sb.toString()); if (log.isInfoEnabled()) { log.info(\"Bundle created: \" + bundleId); } }\n\n    ### Response:", "ground_truth": "Creates bundle file by loading resource files content. If bundle file already\nexist it will not be recreated!", "predict": " Create a bundle file containing the specified sources. The sources can be local or remote resources. If a local resource is specified, it will be loaded from the file system. If a remote resource is specified, it will be downloaded and its content will be included in the bundle. The bundle file will be saved in the bundle directory specified in the configuration.\n\n    "}, {"ID": 1521, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initOffsets() { if (offsets == null) { int count; int index; // count names count = 0; index = 0; while (index < path.length) { byte c = path[index++]; if (c != '/') { count++; while (index < path.length && path[index] != '/') index++; } } // populate offsets int[] result = new int[count]; count = 0; index = 0; while (index < path.length) { byte c = path[index]; if (c == '/') { index++; } else { result[count++] = index++; while (index < path.length && path[index] != '/') index++; } } synchronized (this) { if (offsets == null) offsets = result; } } }\n\n    ### Response: create offset list if not already created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void reset() { if (strategy == Strategy.ACTION_MANAGED) { actionBundles.clear(); mirrors.clear(); } final FindFile ff = new FindFile(); ff.includeDirs(false); ff.searchPath(new File(bundleFolder, staplerPath)); File f; int count = 0; while ((f = ff.nextFile()) != null) { f.delete(); count++; } if (log.isInfoEnabled()) { log.info(\"reset: \" + count + \" bundle files deleted.\"); } }\n\n    ### Response:", "ground_truth": "Clears all settings and removes all created bundle files from file system.", "predict": " delete all bundle files in the bundle folder."}, {"ID": 1522, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Range convert(final String source) { final Matcher matcher = rangePattern.matcher(source); if (!matcher.matches()) { return new Range(); } final String from = matcher.group(1); final String to = matcher.group(2); final long start; if (from.equals(\"\")) { start = 0; } else { start = parseLong(from); } final long end; if (to.equals(\"\")) { end = -1; } else { end = parseLong(to); } return new Range(start, end); }\n\n    ### Response: Convert an HTTP Range header to a Range object\n@param source the source\n@return range object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String fixCssRelativeUrls(final String content, final String src) { final String path = FileNameUtil.getPath(src); final Matcher matcher = CSS_URL_PATTERN.matcher(content); final StringBuilder sb = new StringBuilder(content.length()); int start = 0; while (matcher.find()) { sb.append(content, start, matcher.start()); final String matchedUrl = StringUtil.removeChars(matcher.group(1), \"'\\\"\"); final String url; if (matchedUrl.startsWith(\"https://\") || matchedUrl.startsWith(\"http://\") || matchedUrl.startsWith(\"data:\")) { url = \"url('\" + matchedUrl + \"')\"; } else { url = fixRelativeUrl(matchedUrl, path); } sb.append(url); start = matcher.end(); } sb.append(content.substring(start)); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns the content with all relative URLs fixed.", "predict": " Fix relative URLs in CSS content\n@param content the CSS content\n@param src the source URL\n@return fixed CSS content.\n\n    "}, {"ID": 1523, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object tryConvert( final MfClientHttpRequestFactory clientHttpRequestFactory, final Object rowValue) throws URISyntaxException, IOException { if (this.converters.isEmpty()) { return rowValue; } String value = String.valueOf(rowValue); for (TableColumnConverter<?> converter: this.converters) { if (converter.canConvert(value)) { return converter.resolve(clientHttpRequestFactory, value); } } return rowValue; }\n\n    ### Response: If converters are set on a table, this function tests if these can convert a cell value. The first\nconverter, which claims that it can convert, will be used to do the conversion..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbSqlBuilder updateColumn(final Object entity, final String columnRef) { final Object value = BeanUtil.pojo.getProperty(entity, columnRef); return updateColumn(entity, columnRef, value); }\n\n    ### Response:", "ground_truth": "Reads property value and updates the DB.", "predict": " This method updates a column in the database based on the value of an entity's property. The method takes an entity and a column reference as input, and returns a DbSqlBuilder object that can be used to build the SQL update statement."}, {"ID": 1524, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Object convertToEntity(Class entityType, String id, ObjectNode document) { try { if (ObjectNode.class.equals(entityType)) { return document; } Object defaultValue = InMemoryDocumentSessionOperations.getDefaultValue(entityType); Object entity = defaultValue; String documentType =_session.getConventions().getJavaClass(id, document); if (documentType != null) { Class type = Class.forName(documentType); if (entityType.isAssignableFrom(type)) { entity = _session.getConventions().getEntityMapper().treeToValue(document, type); } } if (entity == defaultValue) { entity = _session.getConventions().getEntityMapper().treeToValue(document, entityType); } if (id != null) { _session.getGenerateEntityIdOnTheClient().trySetIdentity(entity, id); } return entity; } catch (Exception e) { throw new IllegalStateException(\"Could not convert document \" + id + \" to entity of type \" + entityType.getName(), e); } }\n\n    ### Response: Converts a json object to an entity.\n@param entityType Class of entity\n@param id Id of entity\n@param document Raw entity\n@return Entity instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String createTableRefName(final Object entity) { Class type = entity.getClass(); type = (type == Class.class ? (Class) entity : type); return (type.getSimpleName() + '_'); }\n\n    ### Response:", "ground_truth": "Creates table reference name from entity type.\nAlways appends an underscore to reference name in order\nto circumvent SQL compatibility issues when entity class name\nequals to a reserved word.", "predict": " Creates a table reference name for the given entity.\n@param entity Entity instance.\n@return Table reference name."}, {"ID": 1525, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function otherTrans(array $transaction = null) { // morph Transaction extension - will read the type of transaction // and instantiate the correct class extending Transaction. $morphed = Transaction::create($transaction ?: $this->getAttribute(\"otherTrans\")); if ($morphed->type === TransactionType::MULTISIG) { // cannot nest multisig in another multisig. throw new InvalidArgumentException(\"It is forbidden to nest a Multisig transaction in another Multisig transaction.\"); } elseif ($morphed->type === TransactionType::MULTISIG_SIGNATURE) { // cannot nest multisig in another multisig. throw new InvalidArgumentException(\"It is forbidden to nest a Signature transaction in the inner transaction of a Multisig transaction.\"); } return $morphed; }\n\n    ### Response: Mutator for the `otherTrans` sub DTO.\n\n@param   array                   $transaction\n@return  \\NEM\\Models\\Transaction.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public DbSession getDbSession() { log.debug(\"Requesting db TX manager session\"); final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction(); if (jtx == null) { throw new DbSqlException( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\"); } return jtx.requestResource(); }\n\n    ### Response:", "ground_truth": "Returns session from JTX transaction manager and started transaction.", "predict": "Getter for the `DbSession` resource.\n\n@return  DbSession."}, {"ID": 1526, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] ensureCapacity(final T[] oldElements, final int requiredLength) { T[] result = oldElements; if (oldElements.length < requiredLength) { result = Arrays.copyOf(oldElements, requiredLength); } return result; }\n\n    ### Response: Ensure an array has the required capacity. Resizing only if needed.\n\n@param oldElements    to ensure that are long enough.\n@param requiredLength to ensure.\n@param             type of the array.\n@return an array of the required length..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T[] convertToSingleElementArray(final Object value) { T[] singleElementArray = createArray(1); singleElementArray[0] = convertType(value); return singleElementArray; }\n\n    ### Response:", "ground_truth": "Creates an array with single element.", "predict": " Convert the given value to an array of one element.\n\n@param value to be converted.\n@param      type of the array.\n@return an array of one element.\n\n    "}, {"ID": 1527, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, String> attributesByBeanRef(String beanRef) { Map<String, String> result = null; for (Entry<String, String> e : map.entrySet()) { final String k = e.getKey(); if (k.startsWith(beanRef) && k.startsWith(DOT, beanRef.length())) { if (result == null) { result = new HashMap<String,String>(); } result.put(k.substring(beanRef.length() + DOT.length()), e.getValue()); } } if (result == null) { return Collections.emptyMap(); } else { return result; } }\n\n    ### Response: Return an attribute name to attribute value map\n\n@param beanRef\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) { if (signature == null) { return Collections.emptyMap(); } final Map<String, String> genericsMap = new HashMap<>(); SignatureReader sr = new SignatureReader(signature); StringBuilder sb = new StringBuilder(); TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) { String genericName; @Override public void visitFormalTypeParameter(final String name) { genericName = name; super.visitFormalTypeParameter(name); } @Override public void visitClassType(final String name) { if (genericName != null) { genericsMap.put(genericName, 'L' + name + ';'); genericName = null; } super.visitClassType(name); } }; sr.accept(v); return genericsMap; }\n\n    ### Response:", "ground_truth": "Parses signature for generic information and returns a map where key is generic name\nand value is raw type. Returns an empty map if signature does not define any generics.", "predict": " Parse the signature string and return a map of generic type names to their corresponding signature characters.\n\n@param signature The signature string to parse.\n@param isInterface True if the signature is for an interface, false otherwise.\n@return A map of generic type names to their corresponding signature characters."}, {"ID": 1528, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private final boolean checkRef(ComponentTag tag) { boolean ok = false; if (!tag.getName().equals(\"a\")) { IValueMap attributes = tag.getAttributes(); String ref = attributes.getString(\"href\"); if (ref == null) { ref = attributes.getString(\"src\"); } if ((ref != null) && (isJawrImageTag(tag) || (ref.indexOf(\":\") == -1))) { ok = true; } } return ok; }\n\n    ### Response: Checks if if tag ref is a correct one or not\n\n@param tag\nthe component tag\n@return true if if tag ref is a correct one or not and that a component\nshould be created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SetInjectionPoint[] resolve(final Class type, final boolean autowire) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<SetInjectionPoint> list = new ArrayList<>(); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { if (propertyDescriptor.isGetterOnly()) { continue; } Class propertyType = propertyDescriptor.getType(); if (!ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } MethodDescriptor writeMethodDescriptor = propertyDescriptor.getWriteMethodDescriptor(); FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); PetiteInject ref = null; if (writeMethodDescriptor != null) { ref = writeMethodDescriptor.getMethod().getAnnotation(PetiteInject.class); } if (ref == null && fieldDescriptor != null) { ref = fieldDescriptor.getField().getAnnotation(PetiteInject.class); } if ((!autowire) && (ref == null)) { continue; } list.add(new SetInjectionPoint(propertyDescriptor)); } SetInjectionPoint[] fields; if (list.isEmpty()) { fields = SetInjectionPoint.EMPTY; } else { fields = list.toArray(new SetInjectionPoint[0]); } return fields; }\n\n    ### Response:", "ground_truth": "Resolves all collections for given type.", "predict": " Resolves the injection points for the given type.\n\n@param type\nthe type to resolve injection points for\n@param autowire\ntrue to autowire the injection points, false otherwise\n@return the injection points for the given type\n\n    "}, {"ID": 1529, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matches(PathAddress address) { if (address == null) { return false; } if (equals(address)) { return true; } if (size() != address.size()) { return false; } for (int i = 0; i < size(); i++) { PathElement pe = getElement(i); PathElement other = address.getElement(i); if (!pe.matches(other)) { // Could be a multiTarget with segments if (pe.isMultiTarget() && !pe.isWildcard()) { boolean matched = false; for (String segment : pe.getSegments()) { if (segment.equals(other.getValue())) { matched = true; break; } } if (!matched) { return false; } } else { return false; } } } return true; }\n\n    ### Response: Check if this path matches the address path.\nAn address matches this address if its path elements match or are valid\nmulti targets for this path elements. Addresses that are equal are matching.\n\n@param address The path to check against this path. If null, this method\nreturns false.\n@return true if the provided path matches, false otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) { if (!include) { return false; } if (propertyType != null) { if (!jsonSerializer.deep) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector.get().lookup(propertyType); if (propertyTypeClassDescriptor.isArray()) { return false; } if (propertyTypeClassDescriptor.isCollection()) { return false; } if (excludeMaps) { if (propertyTypeClassDescriptor.isMap()) { return false; } } } // still not excluded, continue with excluded types and type names // + excluded types if (jsonSerializer.excludedTypes != null) { for (Class excludedType : jsonSerializer.excludedTypes) { if (ClassUtil.isTypeOf(propertyType, excludedType)) { return false; } } } // + exclude type names final String propertyTypeName = propertyType.getName(); if (jsonSerializer.excludedTypeNames != null) { for (String excludedTypeName : jsonSerializer.excludedTypeNames) { if (Wildcard.match(propertyTypeName, excludedTypeName)) { return false; } } } } return true; }\n\n    ### Response:", "ground_truth": "Matches property types that are ignored by default.", "predict": " Check if the given property type should be included in the serialization process.\n\n@param propertyType The type of the property to check.\n@param excludeMaps If true, maps will be excluded from the serialization process.\n@param include If true, the property type will be included in the serialization process.\n@return true if the property type should be included, false otherwise."}, {"ID": 1530, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ProjectFile read(String accessDatabaseFileName) throws MPXJException { try { Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\"); String url = \"jdbc:odbc:DRIVER=Microsoft Access Driver (*.mdb);DBQ=\" + accessDatabaseFileName; m_connection = DriverManager.getConnection(url); m_projectID = Integer.valueOf(1); return (read()); } catch (ClassNotFoundException ex) { throw new MPXJException(\"Failed to load JDBC driver\", ex); } catch (SQLException ex) { throw new MPXJException(\"Failed to create connection\", ex); } finally { if (m_connection != null) { try { m_connection.close(); } catch (SQLException ex) { // silently ignore exceptions when closing connection } } } }\n\n    ### Response: This is a convenience method which reads the first project\nfrom the named MPD file using the JDBC-ODBC bridge driver.\n\n@param accessDatabaseFileName access database file name\n@return ProjectFile instance\n@throws MPXJException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void openConnectionForQuery() { if (connection == null) { connection = connectionProvider.getConnection(); txActive = false; // txAction should already be false try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Failed to open non-TX connection\", sex); } } }\n\n    ### Response:", "ground_truth": "Opens connection in auto-commit mode, if already not opened.", "predict": " This method opens a connection to the database for a query.\n\n@throws DbSqlException."}, {"ID": 1531, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void withTransaction(Closure closure) throws SQLException { boolean savedCacheConnection = cacheConnection; cacheConnection = true; Connection connection = null; boolean savedAutoCommit = true; try { connection = createConnection(); savedAutoCommit = connection.getAutoCommit(); connection.setAutoCommit(false); callClosurePossiblyWithConnection(closure, connection); connection.commit(); } catch (SQLException e) { handleError(connection, e); throw e; } catch (RuntimeException e) { handleError(connection, e); throw e; } catch (Error e) { handleError(connection, e); throw e; } catch (Exception e) { handleError(connection, e); throw new SQLException(\"Unexpected exception during transaction\", e); } finally { if (connection != null) { try { connection.setAutoCommit(savedAutoCommit); } catch (SQLException e) { LOG.finest(\"Caught exception resetting auto commit: \" + e.getMessage() + \" - continuing\"); } } cacheConnection = false; closeResources(connection, null); cacheConnection = savedCacheConnection; if (dataSource != null && !cacheConnection) { useConnection = null; } } }\n\n    ### Response: Performs the closure within a transaction using a cached connection.\nIf the closure takes a single argument, it will be called\nwith the connection, otherwise it will be called with no arguments.\n\n@param closure the given closure\n@throws SQLException if a database error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void openTx() { if (connection == null) { connection = connectionProvider.getConnection(); } txActive = true; try { connection.setAutoCommit(false); if (txMode.getIsolation() != DbTransactionMode.ISOLATION_DEFAULT) { connection.setTransactionIsolation(txMode.getIsolation()); } connection.setReadOnly(txMode.isReadOnly()); } catch (SQLException sex) { throw new DbSqlException(\"Open TX failed\", sex); } }\n\n    ### Response:", "ground_truth": "Opens a transaction.", "predict": " Opens a new transaction on the current connection.\n\n@throws DbSqlException if a database error occurs.\n\n    "}, {"ID": 1532, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void updateMembers(IEntityGroup eg) throws GroupsException { Connection conn = null; EntityGroupImpl egi = (EntityGroupImpl) eg; if (egi.isDirty()) try { conn = RDBMServices.getConnection(); setAutoCommit(conn, false); try { primUpdateMembers(egi, conn); commit(conn); } catch (SQLException sqle) { rollback(conn); throw new GroupsException(\"Problem updating memberships for \" + egi, sqle); } } catch (SQLException sqlex) { throw new GroupsException(sqlex); } finally { if (conn != null) { try { setAutoCommit(conn, true); } catch (SQLException sqle) { throw new GroupsException(sqle); } finally { RDBMServices.releaseConnection(conn); } } } }\n\n    ### Response: Insert and delete group membership rows inside a transaction.\n\n@param eg IEntityGroup.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void closeTx() { txActive = false; try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Close TX failed\", sex); } }\n\n    ### Response:", "ground_truth": "Closes current transaction.", "predict": "Close the transaction and set the auto-commit mode to true.\n\n@throws DbSqlException if the auto-commit mode cannot be set to true."}, {"ID": 1533, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void updateMembers(IEntityGroup eg) throws GroupsException { Connection conn = null; EntityGroupImpl egi = (EntityGroupImpl) eg; if (egi.isDirty()) try { conn = RDBMServices.getConnection(); setAutoCommit(conn, false); try { primUpdateMembers(egi, conn); commit(conn); } catch (SQLException sqle) { rollback(conn); throw new GroupsException(\"Problem updating memberships for \" + egi, sqle); } } catch (SQLException sqlex) { throw new GroupsException(sqlex); } finally { if (conn != null) { try { setAutoCommit(conn, true); } catch (SQLException sqle) { throw new GroupsException(sqle); } finally { RDBMServices.releaseConnection(conn); } } } }\n\n    ### Response: Insert and delete group membership rows inside a transaction.\n\n@param eg IEntityGroup.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commitTransaction() { log.debug(\"Committing transaction\"); assertTxIsActive(); try { connection.commit(); } catch (SQLException sex) { throw new DbSqlException(\"Commit TX failed\", sex); } finally { closeTx(); } }\n\n    ### Response:", "ground_truth": "Commit the current transaction, writing any unflushed changes to the database.\nTransaction mode is closed.", "predict": " Commits the current transaction.\n\n@throws DbSqlException if the commit fails."}, {"ID": 1534, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void updateMembers(IEntityGroup eg) throws GroupsException { Connection conn = null; EntityGroupImpl egi = (EntityGroupImpl) eg; if (egi.isDirty()) try { conn = RDBMServices.getConnection(); setAutoCommit(conn, false); try { primUpdateMembers(egi, conn); commit(conn); } catch (SQLException sqle) { rollback(conn); throw new GroupsException(\"Problem updating memberships for \" + egi, sqle); } } catch (SQLException sqlex) { throw new GroupsException(sqlex); } finally { if (conn != null) { try { setAutoCommit(conn, true); } catch (SQLException sqle) { throw new GroupsException(sqle); } finally { RDBMServices.releaseConnection(conn); } } } }\n\n    ### Response: Insert and delete group membership rows inside a transaction.\n\n@param eg IEntityGroup.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void rollbackTransaction() { log.debug(\"Rolling-back transaction\"); assertTxIsActive(); try { connection.rollback(); } catch (SQLException sex) { throw new DbSqlException(\"Rollback TX failed\", sex); } finally { closeTx(); } }\n\n    ### Response:", "ground_truth": "Roll back the current transaction. Transaction mode is closed.", "predict": " Rollback the current transaction.\n\n@throws DbSqlException if the rollback operation fails."}, {"ID": 1535, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties readFilelistToProperties(final File input) throws IOException { final List<String> list = readLinesInList(input, null); final Properties prop = new Properties(); for (int i = 0; i < list.size(); i++) { final String element = list.get(i); prop.put(i + \"\", element); } return prop; }\n\n    ### Response: Read filelist to properties.\n\n@param input\nthe input\n@return the properties\n@throws IOException\nSignals that an I/O exception has occurred..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromFile(final File file) throws IOException { Properties prop = new Properties(); loadFromFile(prop, file); return prop; }\n\n    ### Response:", "ground_truth": "Create properties from the file.\n\n@param file properties file to load", "predict": " Create properties from file.\n\n@param file\nthe input file\n@return the properties\n@throws IOException\nSignals that an I/O exception has occurred.\n\n    "}, {"ID": 1536, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Properties readProperties() throws IOException { Properties p; try (Reader src = newReader()) { p = new Properties(); p.load(src); } return p; }\n\n    ### Response: Reads properties with the encoding for this node.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromString(final String data) throws IOException { Properties p = new Properties(); loadFromString(p, data); return p; }\n\n    ### Response:", "ground_truth": "Creates properties from string.", "predict": " Creates a Properties object from a string.\n\n    "}, {"ID": 1537, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void readPropertiesFile(final String custConfFileName) { final Properties p = new Properties(); LOGGER.log(READ_CONF_FILE, custConfFileName); try (InputStream is = ClasspathUtility.loadInputStream(custConfFileName)) { // Read the properties file p.load(is); for (final Map.Entry<Object, Object> entry : p.entrySet()) { if (this.propertiesParametersMap.containsKey(entry.getKey())) { LOGGER.log(UPDATE_PARAMETER, entry.getKey(), entry.getValue()); } else { LOGGER.log(STORE_PARAMETER, entry.getKey(), entry.getValue()); } storePropertiesParameter(entry); } } catch (final IOException e) { LOGGER.error(CONF_READING_ERROR, custConfFileName); } }\n\n    ### Response: Read a customized configuration file to load parameters values.\n\n@param custConfFileName the file to load.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadFromString(final Properties p, final String data) throws IOException { try (ByteArrayInputStream is = new ByteArrayInputStream(data.getBytes(StringPool.ISO_8859_1))) { p.load(is); } }\n\n    ### Response:", "ground_truth": "Loads properties from string.", "predict": " Load properties from a string.\n\n@param p the properties object to load.\n@param data the string to load from."}, {"ID": 1538, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Properties getProperties(String prefix, boolean removePrefix) { Properties result = new Properties(); for (String key : getPropertyNames()) { if (key.startsWith(prefix)) { result.put((removePrefix) ? key.substring(prefix.length()) : key, getProperty(key)); } } return result; }\n\n    ### Response: Gets all properties with a key starting with prefix.\n\n@param prefix\n@param removePrefix\nremove prefix in the resulting properties or not\n@return properties starting with prefix.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties subset(final Properties p, String prefix, final boolean stripPrefix) { if (StringUtil.isBlank(prefix)) { return p; } if (!prefix.endsWith(StringPool.DOT)) { prefix += '.'; } Properties result = new Properties(); int baseLen = prefix.length(); for (Object o : p.keySet()) { String key = (String) o; if (key.startsWith(prefix)) { result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key)); } } return result; }\n\n    ### Response:", "ground_truth": "Creates new Properties object from the original one, by copying\nthose properties that have specified first part of the key name.\nPrefix may be optionally stripped during this process.\n\n@param p         source properties, from which new object will be created\n@param prefix    key names prefix\n\n@return subset properties", "predict": " Returns a subset of the given properties with keys starting with the given prefix.\n\n@param p\nthe properties to subset\n@param prefix\nthe prefix to match\n@param stripPrefix\nwhether to strip the prefix from the resulting keys or not\n@return a subset of the given properties with keys starting with the given prefix."}, {"ID": 1539, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties loadProperties(File file) throws IOException { FileInputStream finp = new FileInputStream(file); try { Properties p = new Properties(); p.load(finp); return p; } finally { ArchiveUtils.closeQuietly(finp); } }\n\n    ### Response: Load Properties instance from a File\n\n@param file\n@return Properties\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromClasspath(final String... rootTemplate) { Properties p = new Properties(); return loadFromClasspath(p, rootTemplate); }\n\n    ### Response:", "ground_truth": "Creates properties from classpath.", "predict": " Create Properties instance from classpath\n\n@param rootTemplate\n@return Properties\n\n    "}, {"ID": 1540, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getProperty(String key, String defaultValue) { String val = properties.get(key); if (val == null) { val = defaultValue; } return val; }\n\n    ### Response: Gets a property associated to this file.\n@param key property key\n@param defaultValue default value to use if the key does not exist or the value is null\n@return property value or the default value passed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getProperty(final Map map, final String key, final String defaultValue) { Object val = map.get(key); return (val instanceof String) ? (String) val : defaultValue; }\n\n    ### Response:", "ground_truth": "Returns String property from a map.\n@see #getProperty(java.util.Map, String)", "predict": " Gets a property from a map.\n@param map map containing the property\n@param key property key\n@param defaultValue default value to use if the key does not exist or the value is null\n@return property value or the default value passed."}, {"ID": 1541, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addToSystemConfig(String prefix, Properties prop) { for (Entry<Object, Object> entry : prop.entrySet()) { String key = prefix.concat(entry.getKey().toString()); String value = entry.getValue().toString(); System.setProperty(key, value); } }\n\n    ### Response: Adds the to system config.\n\n@param prefix the prefix\n@param prop   the prop.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void resolveAllVariables(final Properties prop) { for (Object o : prop.keySet()) { String key = (String) o; String value = resolveProperty(prop, key); prop.setProperty(key, value); } }\n\n    ### Response:", "ground_truth": "Resolves all variables.", "predict": " Resolves all variables.\n\n@param prop the prop."}, {"ID": 1542, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getRawPropertyValue(String key) { String value = super.getProperty(key); if (value != null) { return value; } for (Properties properties : defaults) { value = properties.getProperty(key); if (value != null) { return value; } } return null; }\n\n    ### Response: Returns raw value of a property without any replacements.\n@param key property name\n@return raw property value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveProperty(final Map map, final String key) { String value = getProperty(map, key); if (value == null) { return null; } value = stp.parse(value, macroName -> getProperty(map, macroName)); return value; }\n\n    ### Response:", "ground_truth": "Returns property with resolved variables.", "predict": " Resolves a property value by replacing any macros with their corresponding values.\n@param map map of properties\n@param key property name\n@return resolved property value."}, {"ID": 1543, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ConfigurationContext getManagerContext(final CacheManager mgr) { ConfigurationContext ctx = manager2defaultConfig.get(mgr); if (ctx != null) { return ctx; } synchronized (this) { ctx = manager2defaultConfig.get(mgr); if (ctx != null) { return ctx; } if (mgr.isDefaultManager()) { ctx = classLoader2config.get(mgr.getClassLoader()); } if (ctx == null) { ctx = createContext(mgr.getClassLoader(), mgr.getName(), getFileName(mgr)); } Map<CacheManager, ConfigurationContext> m2 = new HashMap<CacheManager, ConfigurationContext>(manager2defaultConfig); m2.put(mgr, ctx); manager2defaultConfig = m2; return ctx; } }\n\n    ### Response: Hold the cache default configuration of a manager in a hash table. This is reused for all caches of\none manager..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveScope(final Class type, final String methodName) { if (scopePattern == null) { return null; } String ctx = scopePattern; ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_CLASS, type.getName()); ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_METHOD, methodName); return ctx; }\n\n    ### Response:", "ground_truth": "Resolves tx scope from scope pattern.", "predict": " Resolves the scope for a given type and method name using a pattern. The pattern can contain the following placeholders:\n\n- {class}: the fully qualified class name of the type\n- {method}: the method name\n\nIf the pattern is null, the method returns null."}, {"ID": 1544, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T to(Class<T> targetType) { if (targetType == String.class) { return (T) value; } try { final String methodName; final Class type; if (targetType.isPrimitive()) { final String typeName = targetType.getSimpleName(); methodName = \"parse\" + typeName.substring(0, 1).toUpperCase() + typeName.substring(1); type = PRIMITIVE_TO_OBJECT_TYPE_MAP.get(targetType); } else { methodName = \"valueOf\"; type = targetType; } return (T) type.getMethod(methodName, String.class).invoke(null, value); } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) { throw new RuntimeException(\"Could not convert value '\" + value + \"' to type \" + targetType.getName(), e); } }\n\n    ### Response: Converts the underlying string value to a primitive value.\n\n@param targetType\nthe type into which the string value should be converted.\n\n@param \nthe type of the target type\n\n@return the converted value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) { String signature = type.getName() + '#' + methodName + '%' + unique; JtxTransactionMode txMode = txmap.get(signature); if (txMode == null) { if (!txmap.containsKey(signature)) { final Method m; try { m = type.getMethod(methodName, methodArgTypes); } catch (NoSuchMethodException nsmex) { throw new ProxettaException(nsmex); } final TransactionAnnotationValues txAnn = readTransactionAnnotation(m); if (txAnn != null) { txMode = new JtxTransactionMode( txAnn.propagation(), txAnn.isolation(), txAnn.readOnly(), txAnn.timeout() ); } else { txMode = defaultTransactionMode; } txmap.put(signature, txMode); } } return txMode; }\n\n    ### Response:", "ground_truth": "Reads transaction mode from method annotation. Annotations are cached for better performances.\n@param type target class\n@param methodName target method name over which the transaction should be wrapped\n@param methodArgTypes types of arguments, used to find the method\n@param unique unique method fingerprint that contains return and arguments type information", "predict": " Retrieves the transaction mode for the given method signature.\n\n@param type\nthe type on which the method is defined\n\n@param methodName\nthe name of the method\n\n@param methodArgTypes\nthe argument types of the method\n\n@param unique\na unique string that identifies the method signature\n\n@return the transaction mode for the given method signature.\n\n    "}, {"ID": 1545, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initBeforeList() { final List<ProcessAdvice> beforeRequestProcessAdvices = new ArrayList<>(); final Method invokeHolder = getInvokeHolder(); final Class<?> processorClass = invokeHolder.getDeclaringClass(); // 1. process class advice if (null != processorClass && processorClass.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = processorClass.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } // 2. process method advice if (invokeHolder.isAnnotationPresent(Before.class)) { final Class<? extends ProcessAdvice>[] bcs = invokeHolder.getAnnotation(Before.class).value(); for (int i = 0; i < bcs.length; i++) { final Class<? extends ProcessAdvice> bc = bcs[i]; final ProcessAdvice beforeRequestProcessAdvice = BeanManager.getInstance().getReference(bc); beforeRequestProcessAdvices.add(beforeRequestProcessAdvice); } } this.beforeRequestProcessAdvices = beforeRequestProcessAdvices; }\n\n    ### Response: Initializes before process advices..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings( {\"unchecked\"}) public void registerAnnotations(final Class<? extends Annotation>[] annotations) { this.annotations = annotations; this.annotationParsers = new AnnotationParser[annotations.length]; for (int i = 0; i < annotations.length; i++) { annotationParsers[i] = TransactionAnnotationValues.parserFor(annotations[i]); } }\n\n    ### Response:", "ground_truth": "Registers new TX annotations.", "predict": " Registers the given annotations and creates annotation parsers for them.\n\n    "}, {"ID": 1546, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Optional<SoyType> soyTypeForProtoOrEnum(Class<?> type, Method method) { // Message isn't supported because we can't get a descriptor from it. if (type == Message.class) { reporter.invalidReturnType(Message.class, method); return Optional.absent(); } Optional<String> fullName = nameFromDescriptor(type); if (!fullName.isPresent()) { reporter.incompatibleReturnType(type, method); return Optional.absent(); } SoyType returnType = registry.getType(fullName.get()); if (returnType == null) { reporter.incompatibleReturnType(type, method); return Optional.absent(); } return Optional.of(returnType); }\n\n    ### Response: Attempts to discover the SoyType for a proto or proto enum, reporting an error if unable to..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TransactionAnnotationValues readTransactionAnnotation(final Method method) { for (AnnotationParser annotationParser : annotationParsers) { TransactionAnnotationValues tad = TransactionAnnotationValues.of(annotationParser, method); if (tad != null) { return tad; } } return null; }\n\n    ### Response:", "ground_truth": "Finds TX annotation.", "predict": "Attempts to read the transaction annotation values for the given method, returning null if none are found."}, {"ID": 1547, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Transformers.ResourceIgnoredTransformationRegistry createServerIgnoredRegistry(final RequiredConfigurationHolder rc, final Transformers.ResourceIgnoredTransformationRegistry delegate) { return new Transformers.ResourceIgnoredTransformationRegistry() { @Override public boolean isResourceTransformationIgnored(PathAddress address) { final int length = address.size(); if (length == 0) { return false; } else if (length >= 1) { if (delegate.isResourceTransformationIgnored(address)) { return true; } final PathElement element = address.getElement(0); final String type = element.getKey(); switch (type) { case ModelDescriptionConstants.EXTENSION: // Don't ignore extensions for now return false; // if (local) { // return false; // Always include all local extensions // } else if (rc.getExtensions().contains(element.getValue())) { // return false; // } // break; case ModelDescriptionConstants.PROFILE: if (rc.getProfiles().contains(element.getValue())) { return false; } break; case ModelDescriptionConstants.SERVER_GROUP: if (rc.getServerGroups().contains(element.getValue())) { return false; } break; case ModelDescriptionConstants.SOCKET_BINDING_GROUP: if (rc.getSocketBindings().contains(element.getValue())) { return false; } break; } } return true; } }; }\n\n    ### Response: Create the ResourceIgnoredTransformationRegistry when fetching missing content, only including relevant pieces\nto a server-config.\n\n@param rc       the resolution context\n@param delegate the delegate ignored resource transformation registry for manually ignored resources\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final Node node) { // match element name with node name if (!matchElement(node)) { return false; } // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case ATTRIBUTE: if (!((AttributeSelector) selector).accept(node)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(node)) { return false; } break; case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(node)) { return false; } break; } } return true; }\n\n    ### Response:", "ground_truth": "Accepts single node.", "predict": " Check if the given node matches the selector criteria.\n\n@param node the node to check\n@return true if the node matches the selector criteria, false otherwise."}, {"ID": 1548, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean containsElmentWithId(Node node, String id) { String nodeName = node.getNodeName(); if (\"channel\".equals(nodeName) || \"folder\".equals(nodeName)) { Element e = (Element) node; if (id.equals(e.getAttribute(\"ID\"))) { return true; } if (\"folder\".equals(nodeName)) { for (Node child = e.getFirstChild(); child != null; child = child.getNextSibling()) { if (containsElmentWithId(child, id)) { return true; } } } } return false; }\n\n    ### Response: Recursevly find out whether node contains a folder or channel with given identifier.\n\n@param node Where to search.\n@param id Identifier to search for.\n@return true if node or any of its descendats contain an element with given identifier, false\notherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean matchElement(final Node node) { if (node.getNodeType() != Node.NodeType.ELEMENT) { return false; } String element = getElement(); String nodeName = node.getNodeName(); return element.equals(StringPool.STAR) || element.equals(nodeName); }\n\n    ### Response:", "ground_truth": "Matches element to css selector. All non-element types are ignored.", "predict": "Check if the given node matches the element pattern.\n\n@param node Node to check.\n@return true if the node matches the element pattern, false otherwise."}, {"ID": 1549, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestedLocalProperties filterByNodesConstantSet(OptimizerNode node, int input) { if (this.ordering != null) { final FieldList involvedIndexes = this.ordering.getInvolvedIndexes(); for (int i = 0; i < involvedIndexes.size(); i++) { if (!node.isFieldConstant(input, involvedIndexes.get(i))) { return null; } } } else if (this.groupedFields != null) { // check, whether the local key grouping is preserved for (Integer index : this.groupedFields) { if (!node.isFieldConstant(input, index)) { return null; } } } return this; }\n\n    ### Response: Filters these properties by what can be preserved through a user function's constant fields set.\nSince interesting properties are filtered top-down, anything that partially destroys the ordering\nmakes the properties uninteresting.\n\n@param node The optimizer node that potentially modifies the properties.\n@param input The input of the node which is relevant.\n\n@return True, if the resulting properties are non trivial..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean accept(final List<Node> currentResults, final Node node, final int index) { // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(currentResults, node, index)) { return false; } break; default: } } return true; }\n\n    ### Response:", "ground_truth": "Accepts node within current results.", "predict": " Checks whether the given node matches the selectors of this selector list.\n\n@param currentResults The current list of matching nodes.\n@param node The node to check.\n@param index The index of the node in the list.\n\n@return True, if the node matches all selectors."}, {"ID": 1550, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String stripDotSuffix(final String value) { if (value == null) { return null; } final int index = value.indexOf(\".\"); if (index != -1) { return value.substring(0, index); } return value; }\n\n    ### Response: Strip dot suffix from a name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String unescape(final String value) { if (value.indexOf('\\\\') == -1) { return value; } return StringUtil.remove(value, '\\\\'); }\n\n    ### Response:", "ground_truth": "Unescapes CSS string by removing all backslash characters from it.", "predict": " Unescape a string.\n\n    "}, {"ID": 1551, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void formatMonth(StringBuilder b, ZonedDateTime d, int width, FieldVariants months) { int month = d.getMonth().getValue(); switch (width) { case 5: b.append(months.narrow[month-1]); break; case 4: b.append(months.wide[month-1]); break; case 3: b.append(months.abbreviated[month-1]); break; case 2: if (month < 10) { b.append('0'); } // fall through case 1: b.append(month); break; } }\n\n    ### Response: Format the month, numeric or a string name variant..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String[] buildJrePackages(final int javaVersionNumber) { final ArrayList<String> packages = new ArrayList<>(); switch (javaVersionNumber) { case 9: case 8: case 7: case 6: case 5: // in Java1.5, the apache stuff moved packages.add(\"com.sun.org.apache\"); // fall through... case 4: if (javaVersionNumber == 4) { packages.add(\"org.apache.crimson\"); packages.add(\"org.apache.xalan\"); packages.add(\"org.apache.xml\"); packages.add(\"org.apache.xpath\"); } packages.add(\"org.ietf.jgss\"); packages.add(\"org.w3c.dom\"); packages.add(\"org.xml.sax\"); // fall through... case 3: packages.add(\"org.omg\"); packages.add(\"com.sun.corba\"); packages.add(\"com.sun.jndi\"); packages.add(\"com.sun.media\"); packages.add(\"com.sun.naming\"); packages.add(\"com.sun.org.omg\"); packages.add(\"com.sun.rmi\"); packages.add(\"sunw.io\"); packages.add(\"sunw.util\"); // fall through... case 2: packages.add(\"com.sun.java\"); packages.add(\"com.sun.image\"); // fall through... case 1: default: // core stuff packages.add(\"sun\"); packages.add(\"java\"); packages.add(\"javax\"); break; } return packages.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Builds a set of java core packages.", "predict": " Build an array of package names for the specified Java version."}, {"ID": 1552, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyAttributes(Element source, Map<String, String> dest) { NamedNodeMap attributes = source.getAttributes(); if (attributes != null) { for (int i = 0; i < attributes.getLength(); i++) { Node attribute = attributes.item(i); dest.put(attribute.getNodeName(), attribute.getNodeValue()); } } }\n\n    ### Response: Copy attributes from a DOM node to a map.\n\n@param source DOM node.\n@param dest Destination map..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T extends Node> T cloneTo(final T dest) { // dest.nodeValue = nodeValue; // already in clone implementations! dest.parentNode = parentNode; if (attributes != null) { dest.attributes = new ArrayList<>(attributes.size()); for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) { Attribute attr = attributes.get(i); dest.attributes.add(attr.clone()); } } if (childNodes != null) { dest.childNodes = new ArrayList<>(childNodes.size()); for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node child = childNodes.get(i); Node childClone = child.clone(); childClone.parentNode = dest; // fix parent! dest.childNodes.add(childClone); } } return dest; }\n\n    ### Response:", "ground_truth": "Copies all non-final values to the empty cloned object.\nCache-related values are not copied.", "predict": " Clone a DOM node to a new node of the same type.\n\n@param dest Destination node.\n@return The cloned node."}, {"ID": 1553, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void firePropertyChildAdded(TreeNodeAddedEvent event) { if (this.nodeListeners != null) { for (final TreeNodeListener listener : this.nodeListeners) { if (listener != null) { listener.treeNodeChildAdded(event); } } } final N parentNode = getParentNode(); assert parentNode != this; if (parentNode != null) { parentNode.firePropertyChildAdded(event); } }\n\n    ### Response: Fire the event for the node child sets.\n\n@param event the event..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void detachFromParent() { if (parentNode == null) { return; } if (parentNode.childNodes != null) { parentNode.childNodes.remove(siblingIndex); parentNode.reindexChildren(); } parentNode = null; }\n\n    ### Response:", "ground_truth": "Removes this node from DOM tree.", "predict": " Detach the node from its parent.\n\n@return void."}, {"ID": 1554, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Link> connect(int bandwidth, Switch sw, Node... nodes) { List<Link> l = new ArrayList<>(); for (Node n : nodes) { l.add(connect(bandwidth, sw, n)); } return l; }\n\n    ### Response: Create connections between a single switch and multiple nodes\n\n@param bandwidth the maximal bandwidth for the connection\n@param sw        the switch to connect\n@param nodes     a list of nodes to connect\n@return a list of links.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addChild(final Node... nodes) { if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode = this; initChildNodes(node); childNodes.add(node); } reindexChildrenOnAdd(nodes.length); }\n\n    ### Response:", "ground_truth": "Appends several child nodes at once.\nReindex is done only once, after all children are added.", "predict": " Add child nodes to the current node\n\n@param nodes the child nodes to add\n@throws IllegalArgumentException if the node is already a child of this node or if it is the same as this node.\n\n    "}, {"ID": 1555, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addChild(HelpTopicNode node, int index) { node.detach(); node.parent = this; if (index < 0) { children.add(node); } else { children.add(index, node); } }\n\n    ### Response: Inserts a child node at the specified position.\n\n@param node Child node to insert.\n@param index Insertion position (-1 to append)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertChild(final Node node, final int index) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); }\n\n    ### Response:", "ground_truth": "Inserts node at given index.", "predict": " Inserts a child node at the specified position.\n\n@param node Child node to insert.\n@param index Insertion position (-1 to append)."}, {"ID": 1556, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parseFilterConfig(final Node node, final ConfigSettings config) { String name; Node nnode; final NodeList list = node.getChildNodes(); final int length = list.getLength(); for (int i = 0; i < length; i++) { nnode = list.item(i); name = nnode.getNodeName().toUpperCase(); if (name.equals(SUBSECTION_FILTER_NAMESPACES)) { parseNamespaceFilterConfig(nnode, config); } } }\n\n    ### Response: Parses the filter parameter section.\n\n@param node\nReference to the current used xml node\n@param config\nReference to the ConfigSettings.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertBefore(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChild, siblingIndex); }\n\n    ### Response:", "ground_truth": "Inserts node before provided node.", "predict": " Inserts a new child node before a reference child node.\n\n@param newChild\nThe new child node to be inserted\n@param refChild\nThe reference child node to be used as the insertion point"}, {"ID": 1557, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Node[] processCurrNode(final Node theNode, final Document theTargetDocument, final IndexEntryFoundListener theIndexEntryFoundListener) { final NodeList childNodes = theNode.getChildNodes(); if (checkElementName(theNode) && !excludedDraftSection.peek()) { return processIndexNode(theNode, theTargetDocument, theIndexEntryFoundListener); } else { final Node result = theTargetDocument.importNode(theNode, false); if (!includeDraft && checkDraftNode(theNode)) { excludedDraftSection.add(true); } for (int i = 0; i < childNodes.getLength(); i++) { final Node[] processedNodes = processCurrNode(childNodes.item(i), theTargetDocument, theIndexEntryFoundListener); for (final Node node : processedNodes) { result.appendChild(node); } } if (!includeDraft && checkDraftNode(theNode)) { excludedDraftSection.pop(); } return new Node[]{result}; } }\n\n    ### Response: Processes curr node. Copies node to the target document if its is not a text node of index entry element.\nOtherwise it process it and creates nodes with \"prefix\" in given \"namespace_url\" from the parsed index entry text.\n\n@param theNode                    node to process\n@param theTargetDocument          target document used to import and create nodes\n@param theIndexEntryFoundListener listener to notify that new index entry was found\n@return the array of nodes after processing input node.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertBefore(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChilds, siblingIndex); }\n\n    ### Response:", "ground_truth": "Inserts several child nodes before provided node.", "predict": " Inserts new child nodes before the reference child node.\n\n@param newChilds  the new child nodes to insert\n@param refChild   the reference child node to insert before"}, {"ID": 1558, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function getSibling(node, relativeIndex) { var parent = node.parentNode; if (parent === null) { return null; } var currentIndex = parent.childNodes.indexOf(node); var siblingIndex = currentIndex + relativeIndex; if (siblingIndex < 0 || siblingIndex > parent.childNodes.length - 1) { return null; } return parent.childNodes[siblingIndex]; }\n\n    ### Response: returns a sibling of given node.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertAfter(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChild); } else { refChild.parentNode.insertChild(newChild, siblingIndex); } }\n\n    ### Response:", "ground_truth": "Inserts node after provided node.", "predict": " inserts a new child node after the given reference child node."}, {"ID": 1559, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void processStatus(final HttpServerExchange exchange, final RequestData requestData) throws IOException { final String jvmRoute = requestData.getFirst(JVMROUTE); final String loadValue = requestData.getFirst(LOAD); if (loadValue == null || jvmRoute == null) { processError(TYPESYNTAX, SMISFLD, exchange); return; } UndertowLogger.ROOT_LOGGER.receivedNodeLoad(jvmRoute, loadValue); final int load = Integer.parseInt(loadValue); if (load > 0 || load == -2) { final Node node = container.getNode(jvmRoute); if (node == null) { processError(MCMPErrorCode.CANT_READ_NODE, exchange); return; } final NodePingUtil.PingCallback callback = new NodePingUtil.PingCallback() { @Override public void completed() { final String response = \"Type=STATUS-RSP&State=OK&JVMRoute=\" + jvmRoute + \"&id=\" + creationTime; try { if (load > 0) { node.updateLoad(load); } sendResponse(exchange, response); } catch (Exception e) { UndertowLogger.ROOT_LOGGER.failedToSendPingResponse(e); } } @Override public void failed() { final String response = \"Type=STATUS-RSP&State=NOTOK&JVMRoute=\" + jvmRoute + \"&id=\" + creationTime; try { node.markInError(); sendResponse(exchange, response); } catch (Exception e) { UndertowLogger.ROOT_LOGGER.failedToSendPingResponseDBG(e, node.getJvmRoute(), jvmRoute); } } }; // Ping the node node.ping(exchange, callback); } else if (load == 0) { final Node node = container.getNode(jvmRoute); if (node != null) { node.hotStandby(); sendResponse(exchange, \"Type=STATUS-RSP&State=OK&JVMRoute=\" + jvmRoute + \"&id=\" + creationTime); } else { processError(MCMPErrorCode.CANT_READ_NODE, exchange); } } else if (load == -1) { // Error, disable node final Node node = container.getNode(jvmRoute); if (node != null) { node.markInError(); sendResponse(exchange, \"Type=STATUS-RSP&State=NOTOK&JVMRoute=\" + jvmRoute + \"&id=\" + creationTime); } else { processError(MCMPErrorCode.CANT_READ_NODE, exchange); } } else { processError(TYPESYNTAX, SMISFLD, exchange); } }\n\n    ### Response: Process the status request.\n\n@param exchange the http server exchange\n@param requestData the request data\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertAfter(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChilds); } else { refChild.parentNode.insertChild(newChilds, siblingIndex); } }\n\n    ### Response:", "ground_truth": "Inserts several child nodes after referent node.", "predict": "Insert the new child nodes after the reference child node.\n\n@param newChilds the new child nodes to be inserted\n@param refChild the reference child node\n@throws IllegalArgumentException if the reference child node is null or not a child of its parent node."}, {"ID": 1560, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void release() { if (mCurrentRequests != null) { synchronized (mCurrentRequests) { mCurrentRequests.clear(); mCurrentRequests = null; } } if (mDownloadQueue != null) { mDownloadQueue = null; } if (mDownloadDispatchers != null) { stop(); for (int i = 0; i < mDownloadDispatchers.length; i++) { mDownloadDispatchers[i] = null; } mDownloadDispatchers = null; } }\n\n    ### Response: Cancels all the pending & running requests and releases all the dispatchers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeAllChilds() { List<Node> removedNodes = childNodes; childNodes = null; childElementNodes = null; childElementNodesCount = 0; if (removedNodes != null) { for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) { Node removedNode = removedNodes.get(i); removedNode.detachFromParent(); } } }\n\n    ### Response:", "ground_truth": "Removes all child nodes. Each child node will be detached from this parent.", "predict": "Removes all the child nodes from the current node and detaches them from their parent."}, {"ID": 1561, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node getNode(final String name) { if (name == null) { return null; } for (final Node node : nodeList) { if (name.equals(node.settings().get(NODE_NAME))) { return node; } } return null; }\n\n    ### Response: Return a node by the name.\n\n@param name A node name\n@return null if the node is not found by the name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node findChildNodeWithName(final String name) { if (childNodes == null) { return null; } for (final Node childNode : childNodes) { if (childNode.getNodeName().equals(name)) { return childNode; } } return null; }\n\n    ### Response:", "ground_truth": "Finds the first child node with given node name.", "predict": " Find a child node by the name.\n\n@param name A child node name\n@return null if the child node is not found by the name."}, {"ID": 1562, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected List<NodeData> getChildNodesData(final NodeData nodeData, boolean forcePersistentRead) throws RepositoryException { List<NodeData> childNodes = null; if (!forcePersistentRead && cache.isEnabled()) { childNodes = cache.getChildNodes(nodeData); if (childNodes != null) { return childNodes; } } final DataRequest request = new DataRequest(nodeData.getIdentifier(), DataRequest.GET_NODES); try { request.start(); if (!forcePersistentRead && cache.isEnabled()) { // Try first to get the value from the cache since a // request could have been launched just before childNodes = cache.getChildNodes(nodeData); if (childNodes != null) { return childNodes; } } return executeAction(new PrivilegedExceptionAction<List<NodeData>>() { public List<NodeData> run() throws RepositoryException { List<NodeData> childNodes = CacheableWorkspaceDataManager.super.getChildNodesData(nodeData); if (cache.isEnabled()) { cache.addChildNodes(nodeData, childNodes); } return childNodes; } }); } finally { request.done(); } }\n\n    ### Response: Get child NodesData.\n\n@param nodeData\nparent\n@param forcePersistentRead\ntrue if persistent read is required (without cache)\n@return List of NodeData\n@throws RepositoryException\nRepository error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node[] filterChildNodes(final Predicate<Node> nodePredicate) { if (childNodes == null) { return new Node[0]; } return childNodes.stream() .filter(nodePredicate) .toArray(Node[]::new); }\n\n    ### Response:", "ground_truth": "Filters child nodes.", "predict": " Filter child nodes.\n\n@param nodePredicate\nPredicate to filter nodes\n@return filtered nodes array\n@throws RepositoryException\nRepository error."}, {"ID": 1563, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasChildsOf(final Element parentElement, XsdElementEnum child) { NodeList nodeList = parentElement.getChildNodes(); for (int i = 0; i < nodeList.getLength(); i++) { final Node childNode = nodeList.item(i); if (childNode.getNodeType() == Node.ELEMENT_NODE) { final Element childElement = (Element) childNode; if (child.isTagNameEqual(childElement.getTagName())) { return true; } if (childElement.hasChildNodes()) { if (hasChildsOf(childElement, child)) { return true; } } } } return false; }\n\n    ### Response: Checks the existence of a w3c child element.\n\n@param parentElement\nthe element from which the search starts.\n@param child\nthe XsdElementEnum specifying the child element.\n@return true, if found, otherwise false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean check() { if (childNodes == null) { return true; } // children int siblingElementIndex = 0; for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); if (childNode.siblingIndex != i) { return false; } if (childNode.getNodeType() == NodeType.ELEMENT) { if (childNode.siblingElementIndex != siblingElementIndex) { return false; } siblingElementIndex++; } } if (childElementNodesCount != siblingElementIndex) { return false; } // child element nodes if (childElementNodes != null) { if (childElementNodes.length != childElementNodesCount) { return false; } int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { if (childElementNodes[child.siblingElementIndex] != child) { return false; } } } } // sibling names if (siblingNameIndex != -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { if (sibling.siblingNameIndex != index++) { return false; } } } } // process children for (Node childNode : childNodes) { if (!childNode.check()) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Checks the health of child nodes. Useful during complex tree manipulation,\nto check if everything is OK. Not optimized for speed, should be used just\nfor testing purposes.", "predict": " Checks the validity of the node and its children.\n\n@return true, if valid, otherwise false."}, {"ID": 1564, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UIComponent findChild(UIComponent parent, String id) { int childCount = parent.getChildCount(); if (childCount > 0) { for (int i = 0; i < childCount; i++) { UIComponent child = parent.getChildren().get(i); if (id.equals(child.getId())) { return child; } } } return null; }\n\n    ### Response: A lighter-weight version of UIComponent's findChild.\n\n@param parent\nparent to start searching from\n@param id\nto match to\n@return UIComponent found or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initChildElementNodes() { if (childElementNodes == null) { childElementNodes = new Element[childElementNodesCount]; int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { childElementNodes[child.siblingElementIndex] = (Element) child; } } } }\n\n    ### Response:", "ground_truth": "Initializes list of child elements.", "predict": " Initializes the child element nodes array.\n\n@return void.\n\n    "}, {"ID": 1565, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int indexOf(int[] sequence) { int index = -1; for (int i = 0; index == -1 && i <= currentSize - sequence.length; i++) { if (buffer[i] == sequence[0]) { boolean matches = true; for (int j = 1; matches && j < sequence.length; j++) { if (buffer[i + j] != sequence[j]) { matches = false; } } if (matches) { index = i; } } } return index; }\n\n    ### Response: finds sequence in current buffer.\n\n@return index of sequence or -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initSiblingNames() { if (siblingNameIndex == -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { sibling.siblingNameIndex = index++; } } } }\n\n    ### Response:", "ground_truth": "Initializes siblings elements of the same name.", "predict": " initializes sibling names for current node.\n\n@param parentNode parent node of current node.\n@param nodeType type of current node.\n@param nodeName name of current node."}, {"ID": 1566, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected List<NodeData> getChildNodesData(final NodeData nodeData, boolean forcePersistentRead) throws RepositoryException { List<NodeData> childNodes = null; if (!forcePersistentRead && cache.isEnabled()) { childNodes = cache.getChildNodes(nodeData); if (childNodes != null) { return childNodes; } } final DataRequest request = new DataRequest(nodeData.getIdentifier(), DataRequest.GET_NODES); try { request.start(); if (!forcePersistentRead && cache.isEnabled()) { // Try first to get the value from the cache since a // request could have been launched just before childNodes = cache.getChildNodes(nodeData); if (childNodes != null) { return childNodes; } } return executeAction(new PrivilegedExceptionAction<List<NodeData>>() { public List<NodeData> run() throws RepositoryException { List<NodeData> childNodes = CacheableWorkspaceDataManager.super.getChildNodesData(nodeData); if (cache.isEnabled()) { cache.addChildNodes(nodeData, childNodes); } return childNodes; } }); } finally { request.done(); } }\n\n    ### Response: Get child NodesData.\n\n@param nodeData\nparent\n@param forcePersistentRead\ntrue if persistent read is required (without cache)\n@return List of NodeData\n@throws RepositoryException\nRepository error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initChildNodes(final Node newNode) { if (childNodes == null) { childNodes = new ArrayList<>(); } if (ownerDocument != null) { if (newNode.ownerDocument != ownerDocument) { changeOwnerDocument(newNode, ownerDocument); } } }\n\n    ### Response:", "ground_truth": "Initializes child nodes list when needed.\nAlso fix owner document for new node, if needed.", "predict": " Initialize child nodes.\n\n@param newNode\nnew node to initialize child nodes for\n@throws RepositoryException\nRepository error."}, {"ID": 1567, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getCenterXChildPosition(RecyclerView recyclerView) { int childCount = recyclerView.getChildCount(); for (int i = 0; i < childCount; i++) { View child = recyclerView.getChildAt(i); if (isChildInCenterX(recyclerView, child)) { return recyclerView.getChildAdapterPosition(child); } } return childCount; }\n\n    ### Response: Get position of center child in X Axes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void changeOwnerDocument(final Node node, final Document ownerDocument) { node.ownerDocument = ownerDocument; int childCount = node.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = node.getChild(i); changeOwnerDocument(child, ownerDocument); } }\n\n    ### Response:", "ground_truth": "Changes owner document for given node and all its children.", "predict": " Change owner document of a node and its children recursively."}, {"ID": 1568, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int lastIndexOf(Object o, Object[] elements, int index) { if (o == null) { for (int i = index; i >= 0; i--) if (elements[i] == null) return i; } else { for (int i = index; i >= 0; i--) if (o.equals(elements[i])) return i; } return -1; }\n\n    ### Response: static version of lastIndexOf.\n\n@param o element to search for\n@param elements the array\n@param index first index to search\n@return index of element, or -1 if absent.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node getPreviousSiblingName() { if (nodeName == null) { return null; } initSiblingNames(); int index = siblingNameIndex -1; for (int i = siblingIndex; i >= 0; i--) { Node sibling = parentNode.childNodes.get(i); if ((index == sibling.siblingNameIndex) && nodeName.equals(sibling.getNodeName())) { return sibling; } } return null; }\n\n    ### Response:", "ground_truth": "Returns this node's previous sibling element with the same name.", "predict": " get the previous sibling with the same name as the current node.\n\n@return the previous sibling with the same name as the current node, or null if none exists."}, {"ID": 1569, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String setStandardHELMFourthSection(List<AnnotationNotation> annotations) { StringBuilder sb = new StringBuilder(); for (AnnotationNotation annotation : annotations) { sb.append(annotation.toHELM2() + \"|\"); } if (sb.length() > 1) { sb.setLength(sb.length() - 1); } return sb.toString(); }\n\n    ### Response: method to transform the fourth section into HELM1-Format\n\n@param annotations List of AnnotationNotation\n@return the fourth section of an Standard HELM.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTextContent() { StringBuilder sb = new StringBuilder(getChildNodesCount() + 1); appendTextContent(sb); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns the text content of this node and its descendants.\n@see #appendTextContent(Appendable)", "predict": " method to get the text content of a node and its children\n\n@return the text content of the node and its children."}, {"ID": 1570, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Formatter getFormatter() { Formatter formatter = out.get(); if (formatter == null) { formatter = new Formatter(new StringBuilder()); out.set(formatter); } else { StringBuilder sb = (StringBuilder) formatter.out(); sb.setLength(0); } return formatter; }\n\n    ### Response: Returns thread-local formatter. Inner Appendable is StringBuider which's\nlength is set to 0.\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toHtml(this, new StringBuilder()); }\n\n    ### Response:", "ground_truth": "Generates HTML.", "predict": " Returns HTML representation of the document. If the document has no owner document, it uses the default configuration. If the document has an owner document, it uses the configuration of the owner document. The HTML representation is generated using a LagartoHtmlRenderer. The output is a StringBuilder.\n@return."}, {"ID": 1571, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Formatter getFormatter() { Formatter formatter = out.get(); if (formatter == null) { formatter = new Formatter(new StringBuilder()); out.set(formatter); } else { StringBuilder sb = (StringBuilder) formatter.out(); sb.setLength(0); } return formatter; }\n\n    ### Response: Returns thread-local formatter. Inner Appendable is StringBuider which's\nlength is set to 0.\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getInnerHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toInnerHtml(this, new StringBuilder()); }\n\n    ### Response:", "ground_truth": "Generates inner HTML.", "predict": " Returns the inner HTML of the element. If the element has no child elements, returns an empty string.\n@return."}, {"ID": 1572, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void traverseStoredDescendants(ItemData parent, DataManager dataManager, int action, Map<String, ItemData> ret, boolean listOnly, Collection<ItemState> transientDescendants) throws RepositoryException { if (parent.isNode() && !isNew(parent.getIdentifier())) { if (action != MERGE_PROPS) { List<NodeData> childNodes = dataManager.getChildNodesData((NodeData)parent); for (int i = 0, length = childNodes.size(); i < length; i++) { NodeData childNode = childNodes.get(i); ret.put(childNode.getIdentifier(), childNode); } } if (action != MERGE_NODES) { List<PropertyData> childProps = listOnly ? dataManager.listChildPropertiesData((NodeData)parent) : dataManager .getChildPropertiesData((NodeData)parent); outer : for (int i = 0, length = childProps.size(); i < length; i++) { PropertyData childProp = childProps.get(i); for (ItemState transientState : transientDescendants) { if (!transientState.isNode() && !transientState.isDeleted() && transientState.getData().getQPath().getDepth() == childProp.getQPath().getDepth() && transientState.getData().getQPath().getName().equals(childProp.getQPath().getName())) { continue outer; } } if (!childProp.getQPath().isDescendantOf(parent.getQPath(), true)) { // In case we get the data from the cache, we need to set the correct path QPath qpath = QPath.makeChildPath(parent.getQPath(), childProp.getQPath().getName()); childProp = new PersistedPropertyData(childProp.getIdentifier(), qpath, childProp.getParentIdentifier(), childProp.getPersistedVersion(), childProp.getType(), childProp.isMultiValued(), childProp.getValues(), new SimplePersistedSize( ((PersistedPropertyData)childProp).getPersistedSize())); } ret.put(childProp.getIdentifier(), childProp); } } } }\n\n    ### Response: Calculate all stored descendants for the given parent node\n\n@param parent\n@param dataManager\n@param action\n@param ret\n@throws RepositoryException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void visitChildren(final NodeVisitor nodeVisitor) { if (childNodes != null) { for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); childNode.visit(nodeVisitor); } } }\n\n    ### Response:", "ground_truth": "Visits children nodes.", "predict": "Visit all child nodes of this node.\n\n@param nodeVisitor\nThe visitor to be called for each child node."}, {"ID": 1573, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPath() { final StringBuilder path = new StringBuilder(); if (getPrevious() != null) { path.append(getPrevious().getPath()); } return path.toString(); }\n\n    ### Response: Gets the path.\n\n@return the path\n@throws EFapsException the eFaps exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getCssPath() { StringBuilder path = new StringBuilder(); Node node = this; while (node != null) { String nodeName = node.getNodeName(); if (nodeName != null) { StringBuilder sb = new StringBuilder(); sb.append(' ').append(nodeName); String id = node.getAttribute(\"id\"); if (id != null) { sb.append('#').append(id); } path.insert(0, sb); } node = node.getParentNode(); } if (path.charAt(0) == ' ') { return path.substring(1); } return path.toString(); }\n\n    ### Response:", "ground_truth": "Returns CSS path to this node from document root.", "predict": " Gets the CSS path.\n\n@return the CSS path\n@throws EFapsException the eFaps exception."}, {"ID": 1574, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTag(Tag<?> tag) throws IOException { String name = tag.getName(); byte[] nameBytes = name.getBytes(NBTConstants.CHARSET.name()); os.writeByte(tag.getType().getId()); os.writeShort(nameBytes.length); os.write(nameBytes); if (tag.getType() == TagType.TAG_END) { throw new IOException(\"Named TAG_End not permitted.\"); } writeTagPayload(tag); }\n\n    ### Response: Writes a tag.\n\n@param tag The tag to write.\n@throws java.io.IOException if an I/O error occurs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onDecoraTag(final Tag tag) { String tagName = tag.getName().toString(); if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); return; } // closed tag type decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); decoraTagDefaultValueEnd = tag.getTagPosition(); defineDecoraTag(); }\n\n    ### Response:", "ground_truth": "Handle Decora tags.", "predict": " Handles a decora tag.\n\n@param tag The tag to handle."}, {"ID": 1575, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void maybeProcessDomTagName(Node n) { if (NodeUtil.isLValue(n)) { return; } String prefix = \"goog$dom$TagName$\"; String tagName; if (n.isName() && n.getString().startsWith(prefix)) { tagName = n.getString().substring(prefix.length()); } else if (n.isGetProp() && !n.getParent().isGetProp() && n.getFirstChild().matchesQualifiedName(\"goog.dom.TagName\")) { tagName = n.getSecondChild().getString() .replaceFirst(\".*\\\\$\", \"\"); // Added by DisambiguateProperties. } else { return; } Node stringNode = IR.string(tagName).srcref(n); n.replaceWith(stringNode); compiler.reportChangeToEnclosingScope(stringNode); }\n\n    ### Response: Converts the given node to string if it is safe to do so..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onIdAttrStart(final Tag tag) { String id = tag.getId().toString().substring(7); String tagName; String idName; int dashIndex = id.indexOf('-'); if (dashIndex == -1) { tagName = id; idName = null; } else { tagName = id.substring(0, dashIndex); idName = id.substring(dashIndex + 1); } if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); closingTagName = tag.getName().toString(); closingTagDeepLevel = tag.getDeepLevel(); } }\n\n    ### Response:", "ground_truth": "Handle open and empty ID attribute tags.", "predict": " This method is responsible for handling the start of an id attribute in a tag. It extracts the tag name and id name from the id attribute value and stores them in the corresponding instance variables. If the tag is a self-closing tag, it checks if there are any nested decora tags and defines the decora tag if necessary. If the tag is a start tag, it checks if there are any nested decora tags and stores the tag name, id name, start position, and default value start position in the corresponding instance variables."}, {"ID": 1576, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setStringValue(String input) { this.bValue = null; this.sValue = input; this.offset = 0; this.valueLength = (null == input) ? 0 : input.length(); if (ELEM_ADDED != this.status) { this.status = ELEM_CHANGED; } }\n\n    ### Response: Set the string value to the given input.\n\n@param input.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void defineDecoraTag() { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd) : new DecoraTag( decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd, decoraTagDefaultValueStart, decoraTagDefaultValueEnd - decoraTagDefaultValueStart); decoraTags.add(decoraTag); decoraTagName = null; decoraIdName = null; closingTagName = null; decoraTagDefaultValueStart = 0; }\n\n    ### Response:", "ground_truth": "Defines Decora tag position inside decorator content.\nResets current Decora tag tracking.", "predict": " Define a new DecoraTag object and add it to the list of decora tags.\n\n@param decoraTagStart.\n@param decoraTagEnd.\n@param decoraTagDefaultValueStart.\n@param decoraTagDefaultValueEnd."}, {"ID": 1577, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public MutableCapabilities merge(Capabilities extraCapabilities) { if (extraCapabilities == null) { return this; } extraCapabilities.asMap().forEach(this::setCapability); return this; }\n\n    ### Response: Merge the extra capabilities provided into this DesiredCapabilities instance. If capabilities\nwith the same name exist in this instance, they will be overridden by the values from the\nextraCapabilities object.\n\n@param extraCapabilities Additional capabilities to be added.\n@return The DesiredCapabilities instance after the merge..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; }\n\n    ### Response:", "ground_truth": "Adds a proxy aspect.", "predict": "Add a new ProxyAspect to the list of aspects to be applied to the proxy.\n\n@param proxyAspect The ProxyAspect to add.\n@return This JoyProxetta instance."}, {"ID": 1578, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function(currentCauses, nextCause, facts, constants, rule) { var substitutedNextCauses = [], mappings = []; for (var i = 0; i < currentCauses.length; i++) { for (var j = 0; j < facts.length; j++) { // Get the mapping of the current cause ... var mapping = currentCauses[i].mapping, substitutedNextCause, newMapping; // ... or build a fresh one if it does not exist if (mapping === undefined) { mapping = {}; mapping.__facts__ = []; } // Update the mapping using pattern matching newMapping = this.factMatches(facts[j], currentCauses[i], mapping, constants, rule); // If the current fact matches the current cause ... if (newMapping) { // If there are other causes to be checked... if (nextCause) { // Substitute the next cause's variable with the new mapping substitutedNextCause = this.substituteFactVariables(newMapping, nextCause); substitutedNextCause.mapping = newMapping; substitutedNextCauses.push(substitutedNextCause); } else { // Otherwise, add the new mapping to the global mapping array mappings.push(newMapping); } } } } if(nextCause) { return substitutedNextCauses; } else { return mappings; } }\n\n    ### Response: Updates the mapping of the current cause\ngiven the next cause of a rule, over a\nset of facts.\n@param currentCauses\n@param nextCause\n@param facts\n@returns {Array}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addRootPackage(final String rootPackage, String mapping) { if (packages == null) { packages = new String[0]; } if (mappings == null) { mappings = new String[0]; } // fix mapping if (mapping.length() > 0) { // mapping must start with the slash if (!mapping.startsWith(StringPool.SLASH)) { mapping = StringPool.SLASH + mapping; } // mapping must NOT end with the slash if (mapping.endsWith(StringPool.SLASH)) { mapping = StringUtil.substring(mapping, 0, -1); } } // detect duplicates for (int i = 0; i < packages.length; i++) { if (packages[i].equals(rootPackage)) { if (mappings[i].equals(mapping)) { // both package and the mappings are the same return; } throw new MadvocException(\"Different mappings for the same root package: \" + rootPackage); } } packages = ArraysUtil.append(packages, rootPackage); mappings = ArraysUtil.append(mappings, mapping); }\n\n    ### Response:", "ground_truth": "Adds root package and its path mapping. Duplicate root packages\nare ignored, if mapping path is equals, otherwise exception is thrown.", "predict": " Adds a new root package to the list of packages and their mappings.\n@param rootPackage\n@param mapping\n@throws MadvocException if the root package is already registered with a different mapping.\n\n    "}, {"ID": 1579, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addNewMapping(final Class<?> type, final String property, final String mapping) { allowedColmns.computeIfAbsent(type, k -> new HashMap<>()); allowedColmns.get(type).put(property, mapping); }\n\n    ### Response: Add new mapping - property name and alias.\n\n@param type\nentity type\n@param property\nalias of property\n@param mapping\nproperty name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addRootPackageOf(final Class actionClass, final String mapping) { addRootPackage(actionClass.getPackage().getName(), mapping); }\n\n    ### Response:", "ground_truth": "Sets root package to package of given class.", "predict": " Add root package of action class.\n\n@param actionClass\naction class\n@param mapping\nmapping of action class."}, {"ID": 1580, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int findIndex(final Job job) { int size = jobList.size(); boolean found = false; int i = 0; for (; i < size; i++) { ScheduledJobEntry se = (ScheduledJobEntry) jobList.get(i); if (se.job == job) { found = true; break; } } if (found) { return i; } else { return -1; } }\n\n    ### Response: Find the index of a given job.\n@param job job\n@return -1 if the job could not be found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String findRootPackageForActionPath(final String actionPath) { if (mappings == null) { return null; } int ndx = -1; int delta = Integer.MAX_VALUE; for (int i = 0; i < mappings.length; i++) { String mapping = mappings[i]; boolean found = false; if (actionPath.equals(mapping)) { found = true; } else { mapping += StringPool.SLASH; if (actionPath.startsWith(mapping)) { found = true; } } if (found) { int distance = actionPath.length() - mapping.length(); if (distance < delta) { ndx = i; delta = distance; } } } if (ndx == -1) { return null; } return packages[ndx]; }\n\n    ### Response:", "ground_truth": "Finds closest root package for the given action path.", "predict": " Find the root package for a given action path.\n@param actionPath action path\n@return the root package or null if not found."}, {"ID": 1581, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getElementID(final String relativePath) { final String fragment = FileUtils.getFragment(relativePath); if (fragment != null) { if (fragment.lastIndexOf(SLASH) != -1) { final String id = fragment.substring(fragment.lastIndexOf(SLASH) + 1); return id.isEmpty() ? null : id; } } return null; }\n\n    ### Response: Retrieve the element ID from the path\n\n@param relativePath path\n@return element ID, may be {@code null}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveValidationMessage(final HttpServletRequest request, final Violation violation) { ValidationConstraint vc = violation.getConstraint(); String key = vc != null ? vc.getClass().getName() : violation.getName(); String msg = LocalizationUtil.findMessage(request, key); if (msg != null) { return beanTemplateParser.parseWithBean(msg, violation); } return null; }\n\n    ### Response:", "ground_truth": "Prepares validation messages.\nKey is either validation constraint class name or violation name.", "predict": " Resolve the validation message for the given violation\n\n@param request HTTP request\n@param violation violation\n@return validation message, may be {@code null}"}, {"ID": 1582, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Node select_parser(int partnum, String mime, Element instruction) { if (null == instruction) return null; NodeList instructions = instruction.getElementsByTagNameNS(PARSERS_NS, \"parse\"); Node parserNode = null; instructionsLoop: for (int i = 0; i < instructions.getLength(); i++) { Element parse = (Element) instructions.item(i); if (partnum != 0) { String part_i = parse.getAttribute(\"part\"); if (part_i.length() > 0) { int n = Integer.parseInt(part_i); if (n != partnum) { continue; } } } if (mime != null) { String mime_i = parse.getAttribute(\"mime\"); if (mime_i.length() > 0) { String[] mime_parts = mime_i.split(\";\\\\s*\"); if (!mime.startsWith(mime_parts[0])) { continue; } boolean ok = true; for (int j = 1; j < mime_parts.length; j++) { if (mime.indexOf(mime_parts[j]) < 0) { ok = false; break; } } if (!ok) { continue; } } } NodeList children = parse.getChildNodes(); for (int j = 0; j < children.getLength(); j++) { if (children.item(j).getNodeType() == Node.ELEMENT_NODE) { parserNode = children.item(j); break instructionsLoop; } } } return parserNode; }\n\n    ### Response: Selects a parser for a message part based on the part number and MIME\nformat type, if supplied in instructions.\n\n@param partnum\nAn integer indicating the message part number.\n@param mime\nA MIME media type.\n@param instruction\nAn Element representing parser instructions.\n@return A Node containing parser info, or {@code null} if no matching\nparser is found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences removeDuplicateNames() { if (names.length < 2) { return this; } int nullCount = 0; for (int i = 1; i < names.length; i++) { String thisRef = names[i]; if (thisRef == null) { nullCount++; continue; } for (int j = 0; j < i; j++) { if (names[j] == null) { continue; } if (thisRef.equals(names[j])) { names[i] = null; break; } } } if (nullCount == 0) { return this; } String[] newRefs = new String[names.length - nullCount]; int ndx = 0; for (String name : names) { if (name == null) { continue; } newRefs[ndx] = name; ndx++; } return new BeanReferences(newRefs); }\n\n    ### Response:", "ground_truth": "Removes later duplicated references in an array.\nReturns new instance of BeanReferences if there was changes,\notherwise returns the same instance.", "predict": " Removes duplicate names from a BeanReferences object.\n\n@return A new BeanReferences object with duplicate names removed.\n\n    "}, {"ID": 1583, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ListenableFuture<List<String>> listHosts(final String namePattern) { return listHosts(ImmutableMultimap.of(\"namePattern\", namePattern)); }\n\n    ### Response: Returns a list of all hosts registered in the Helios cluster whose name matches the given\npattern..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JoyProps addPropsFile(final String namePattern) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); return this; }\n\n    ### Response:", "ground_truth": "Adds props files or patterns.", "predict": " Adds a pattern to the list of patterns that will be used to search for properties files to load. The pattern is a simple string that can contain the wildcard characters '*' and '?'. The method returns the updated instance of JoyProps."}, {"ID": 1584, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T consumeAndGetSelf(T target, Consumer<T> targetConsumer) { targetConsumer.accept(target); return target; }\n\n    ### Response: Consume and get self t.\n\n@param             the type parameter\n@param target         the target\n@param targetConsumer the target consumer\n@return the t.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTarget(final Consumer<Target> targetConsumer) { for (final Target target : targets) { targetConsumer.accept(target); } }\n\n    ### Response:", "ground_truth": "Iterates all targets.", "predict": " For each target.\n\n@param targetConsumer the target consumer"}, {"ID": 1585, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doElim(final int cand) { assert this.schedule; assert var(cand).free(); final CLOccs p = occs(cand); final CLOccs n = occs(-cand); for (final CLClause c : p) { this.stats.steps++; if (c.dumped() || satisfied(c)) { continue; } for (final CLClause d : n) { this.stats.steps++; if (d.dumped() || satisfied(d)) { continue; } doResolve(c, cand, d); } } final int extend; final CLOccs e; if (p.count() < n.count()) { extend = cand; e = p; } else { extend = -cand; e = n; } for (final CLClause c : e) { if (c.dumped() || satisfied(c)) { continue; } this.stats.steps++; pushExtension(c, extend); } pushExtension(0); pushExtension(-extend); while (!p.clauses().empty()) { final CLClause c = p.clauses().back(); this.stats.steps++; p.clauses().pop(); if (c.satisfied() || c.dumped()) { continue; } this.stats.clausesEliminated++; dumpClause(c); } p.clauses().release(); while (!n.clauses().empty()) { final CLClause c = n.clauses().back(); this.stats.steps++; n.clauses().pop(); if (c.satisfied() || c.dumped()) { continue; } this.stats.clausesEliminated++; dumpClause(c); } n.clauses().release(); var(cand).setState(CLVar.State.ELIMINATED); this.stats.varsEliminated++; final CLClause conflict = bcp(); if (conflict != null) { analyze(conflict); assert this.empty != null; } touchFixed(); }\n\n    ### Response: Performs blocking variable elimination on a candidate.\n@param cand the candidate literal.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.in() == null) { continue; } for (final InjectionPoint in : scopeData.in()) { if (in.scope() != scope) { continue; } biConsumer.accept(target, in); } } }\n\n    ### Response:", "ground_truth": "Iterates all targets and for each target iterates all IN injection points of given scope.", "predict": "Iterates over all targets in the given scope and their injection points, invoking the given consumer for each pair.\n@param scope the scope to search for targets and injection points.\n@param biConsumer the consumer to invoke for each target and injection point."}, {"ID": 1586, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doElim(final int cand) { assert this.schedule; assert var(cand).free(); final CLOccs p = occs(cand); final CLOccs n = occs(-cand); for (final CLClause c : p) { this.stats.steps++; if (c.dumped() || satisfied(c)) { continue; } for (final CLClause d : n) { this.stats.steps++; if (d.dumped() || satisfied(d)) { continue; } doResolve(c, cand, d); } } final int extend; final CLOccs e; if (p.count() < n.count()) { extend = cand; e = p; } else { extend = -cand; e = n; } for (final CLClause c : e) { if (c.dumped() || satisfied(c)) { continue; } this.stats.steps++; pushExtension(c, extend); } pushExtension(0); pushExtension(-extend); while (!p.clauses().empty()) { final CLClause c = p.clauses().back(); this.stats.steps++; p.clauses().pop(); if (c.satisfied() || c.dumped()) { continue; } this.stats.clausesEliminated++; dumpClause(c); } p.clauses().release(); while (!n.clauses().empty()) { final CLClause c = n.clauses().back(); this.stats.steps++; n.clauses().pop(); if (c.satisfied() || c.dumped()) { continue; } this.stats.clausesEliminated++; dumpClause(c); } n.clauses().release(); var(cand).setState(CLVar.State.ELIMINATED); this.stats.varsEliminated++; final CLClause conflict = bcp(); if (conflict != null) { analyze(conflict); assert this.empty != null; } touchFixed(); }\n\n    ### Response: Performs blocking variable elimination on a candidate.\n@param cand the candidate literal.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.out() == null) { continue; } for (final InjectionPoint out : scopeData.out()) { if (out.scope() != scope) { continue; } biConsumer.accept(target, out); } } }\n\n    ### Response:", "ground_truth": "Iterates all targets and for each target iterates all OUT injection points of given scope.", "predict": "Iterates over all targets in the given scope and their corresponding output injection points, invoking the given consumer for each pair.\n@param scope the scope to iterate over.\n@param biConsumer the consumer to invoke for each target and output injection point."}, {"ID": 1587, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object[] getRowData() throws SQLException { Object[] row = new Object[columnCount]; for (int i = 1; i < columnCount + 1; i++) { row[i - 1] = getObject(i); } return row; }\n\n    ### Response: Retrieve the raw row data as an array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object[] extractParametersValues() { final Object[] values = new Object[targets.length - 1]; for (int i = 1; i < targets.length; i++) { values[i - 1] = targets[i].value(); } return values; }\n\n    ### Response:", "ground_truth": "Collects all parameters from target into an array.", "predict": " Extract the values of the parameters from the target objects and store them in an array."}, {"ID": 1588, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private final void parseTargetSpecificSettings (final Element root) { final NodeList targets = root.getElementsByTagName(ELEMENT_TARGET); Node target; Node parameter; NodeList parameters; try { for (int i = 0; i < targets.getLength(); i++) { target = targets.item(i); parameters = target.getChildNodes(); // extract target address and the port (if specified) SessionConfiguration sc = new SessionConfiguration(); sc.setAddress(target.getAttributes().getNamedItem(ATTRIBUTE_ADDRESS).getNodeValue(), Integer.parseInt(target.getAttributes().getNamedItem(ATTRIBUTE_PORT).getNodeValue())); // extract the parameters for this target for (int j = 0; j < parameters.getLength(); j++) { parameter = parameters.item(j); if (parameter.getNodeType() == Node.ELEMENT_NODE) { sc.addSessionSetting(OperationalTextKey.valueOfEx(parameter.getNodeName()), parameter.getTextContent()); } } synchronized (sessionConfigs) { sessionConfigs.put(target.getAttributes().getNamedItem(ATTRIBUTE_ID).getNodeValue(), sc); } } } catch (UnknownHostException e) { if (LOGGER.isErrorEnabled()) { LOGGER.error(\"The given host is not reachable: \" + e.getLocalizedMessage()); } } }\n\n    ### Response: Parses all target-specific settings form the main configuration file.\n\n@param root The root element of the configuration..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Target[] makeTargets(final Target actionTarget, final MethodParam[] methodParams) { if (methodParams == null) { // action does not have method parameters, so there is just one target return new Target[]{actionTarget}; } // action has method arguments, so there is more then one target final Target[] target = new Target[methodParams.length + 1]; target[0] = actionTarget; final Object action = actionTarget.value(); for (int i = 0; i < methodParams.length; i++) { final MethodParam methodParam = methodParams[i]; final Class paramType = methodParam.type(); final Target paramTarget; if (methodParam.annotationType() == null) { // parameter is NOT annotated, create new value for the target // the class itself will be a base class, and should be scanned final ScopeData newScopeData = methodParam.scopeData().inspector().inspectClassScopesWithCache(paramType); paramTarget = Target.ofValue(createActionMethodArgument(paramType, action), newScopeData); } else if (methodParam.annotationType() == Out.class) { // parameter is annotated with *only* OUT annotation // create the output value now AND to save the type paramTarget = Target.ofMethodParam(methodParam, createActionMethodArgument(paramType, action)); } else { // parameter is annotated with any IN annotation // create target with NO value, as the value will be created later paramTarget = Target.ofMethodParam(methodParam, type -> createActionMethodArgument(type, action)); } target[i + 1] = paramTarget; } return target; }\n\n    ### Response:", "ground_truth": "Joins action and parameters into one single array of Targets.", "predict": " Creates an array of targets for the given action and method parameters.\n\n@param actionTarget The target for the action.\n@param methodParams The method parameters for the action.\n\n    "}, {"ID": 1589, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Object getAdditionalFieldValue(String value, String fieldType) { Object result = null; if (fieldType.equalsIgnoreCase(FIELD_TYPE_DISCOVER)) { Result discoveredType = ValueDiscovery.discover(value); if (discoveredType == Result.STRING) { return value; } if (discoveredType == Result.LONG) { try { // try adding the value as a long return Long.parseLong(value); } catch (NumberFormatException ex) { // fallback on the double value return value; } } try { return Double.parseDouble(value); } catch (NumberFormatException ex) { // fallback on the string value return value; } } if (fieldType.equalsIgnoreCase(FIELD_TYPE_STRING)) { result = value; } if (fieldType.equals(FIELD_TYPE_DOUBLE) || fieldType.equalsIgnoreCase(FIELD_TYPE_DOUBLE2)) { try { result = Double.parseDouble(value); } catch (NumberFormatException ex) { if (fieldType.equals(FIELD_TYPE_DOUBLE)) { result = Double.valueOf(0); } } } if (fieldType.equals(FIELD_TYPE_LONG) || fieldType.equalsIgnoreCase(FIELD_TYPE_LONG2)) { try { result = (long) Double.parseDouble(value); } catch (NumberFormatException ex) { if (fieldType.equals(FIELD_TYPE_LONG)) { result = Long.valueOf(0); } } } return result; }\n\n    ### Response: Get the field value as requested data type.\n\n@param value the value as string\n@param fieldType see field types\n@return the field value in the appropriate data type or {@literal null}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodArgument(final Class type, final Object action) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) { // regular or static class return ClassUtil.newInstance(type); } else { // member class Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass()); ctor.setAccessible(true); return ctor.newInstance(action); } } catch (Exception ex) { throw new MadvocException(ex); } }\n\n    ### Response:", "ground_truth": "Creates action method arguments.", "predict": " Create a new instance of the given type, taking into account that it may be a member class or a static class.\n\n@param type the type of the argument to create\n@param action the action object to pass to the constructor\n@return a new instance of the given type, or {@literal null} if the type is {@literal null}"}, {"ID": 1590, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void sessionCreated(final HttpSessionEvent event) { counter++; final HttpSession session = event.getSession(); final String id = session.getId(); SESSIONS.put(id, session); }\n\n    ### Response: Fires whenever a new session is created..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void sessionCreated(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.putIfAbsent(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionCreated(httpSessionEvent); } }\n\n    ### Response:", "ground_truth": "Stores session in map and broadcasts event to registered listeners.", "predict": " Fires whenever a new session is created."}, {"ID": 1591, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void sessionDestroyed(final HttpSessionEvent event) { final HttpSession session = event.getSession(); final String id = session.getId(); SESSIONS.remove(id); counter--; }\n\n    ### Response: Fires whenever a session is destroyed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(session.getId()); for (HttpSessionListener listener : listeners) { listener.sessionDestroyed(httpSessionEvent); } }\n\n    ### Response:", "ground_truth": "Removes session from a map and broadcasts event to registered listeners.", "predict": " Fires whenever a session is destroyed."}, {"ID": 1592, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProxySettings addHeader(String name, String value) { if (name == null || name.length() == 0) { return this; } List<String> list = mHeaders.get(name); if (list == null) { list = new ArrayList<String>(); mHeaders.put(name, list); } list.add(value); return this; }\n\n    ### Response: Add an additional HTTP header passed to the proxy server.\n\n@param name\nThe name of an HTTP header (case-insensitive).\nIf {@code null} or an empty string is given,\nnothing is added.\n\n@param value\nThe value of the HTTP header.\n\n@return\n{@code this} object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonArray add(Object value) { Objects.requireNonNull(value); value = JsonObject.resolveValue(value); list.add(value); return this; }\n\n    ### Response:", "ground_truth": "Adds an object to the JSON array.", "predict": " Adds the specified element to the end of this array.\n\n@param value\nthe element to be added to this array.\n\n@return\nthis array.\n\n    "}, {"ID": 1593, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static List<String> toIdentifiers( JsonArray array) { return IntStream.range( 0, array.size()) .mapToObj( i -> validIdentifier( array.getString( i))) .collect( toList()); }\n\n    ### Response: Returns the contents of the given JSON array as a list of identifiers..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonArray addAll(final JsonArray array) { Objects.requireNonNull(array); list.addAll(array.list); return this; }\n\n    ### Response:", "ground_truth": "Appends all of the elements in the specified array to the end of this JSON array.", "predict": " Adds all elements of the given JSON array to this array.\n\n    "}, {"ID": 1594, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <R> R get(@NotNull final String name) { // do some conversions for JsonObject/JsonArray Object o = context.get(name); if (o instanceof Map) { return (R) new JsonObject((Map) o); } if (o instanceof List) { return (R) new JsonArray((List) o); } return (R) o; }\n\n    ### Response: Allow getting properties in a generified way.\n\n@param name The key to get\n@return {R} The found object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object remove(final int pos) { Object removed = list.remove(pos); if (removed instanceof Map) { return new JsonObject((Map) removed); } if (removed instanceof ArrayList) { return new JsonArray((List) removed); } return removed; }\n\n    ### Response:", "ground_truth": "Removes the value at the specified position in the JSON array.", "predict": " Remove an element from the list and return it in a generified way.\n\n@param pos The position of the element to remove\n@return {Object} The removed element."}, {"ID": 1595, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Pure @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static URL getParentURL(URL url) throws MalformedURLException { if (url == null) { return url; } String path = url.getPath(); final String prefix; final String parentStr; switch (URISchemeType.getSchemeType(url)) { case JAR: final int index = path.indexOf(JAR_URL_FILE_ROOT); assert index > 0; prefix = path.substring(0, index + 1); path = path.substring(index + 1); parentStr = URL_PATH_SEPARATOR; break; case FILE: prefix = null; parentStr = \"..\" + URL_PATH_SEPARATOR; //$NON-NLS-1$ break; //$CASES-OMITTED$ default: prefix = null; parentStr = URL_PATH_SEPARATOR; } if (path == null || \"\".equals(path)) { //$NON-NLS-1$ path = parentStr; } int index = path.lastIndexOf(URL_PATH_SEPARATOR_CHAR); if (index == -1) { path = parentStr; } else if (index == path.length() - 1) { index = path.lastIndexOf(URL_PATH_SEPARATOR_CHAR, index - 1); if (index == -1) { path = parentStr; } else { path = path.substring(0, index + 1); } } else { path = path.substring(0, index + 1); } if (prefix != null) { path = prefix + path; } return new URL(url.getProtocol(), url.getHost(), url.getPort(), path); }\n\n    ### Response: Replies the parent URL for the given URL.\n\n@param url the URL.\n@return the parent URL\n@throws MalformedURLException if the parent URL cannot be built..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveTarget(final ActionRequest actionRequest, final String resultValue) { String resultBasePath = actionRequest.getActionRuntime().getResultBasePath(); ResultPath resultPath = resultMapper.resolveResultPath(resultBasePath, resultValue); String actionPath = resultPath.path(); String path = actionPath; String value = resultPath.value(); if (StringUtil.isEmpty(value)) { value = null; } String target; while (true) { // variant #1: with value if (value != null) { if (path == null) { // only value remains int lastSlashNdx = actionPath.lastIndexOf('/'); if (lastSlashNdx != -1) { target = actionPath.substring(0, lastSlashNdx + 1) + value; } else { target = '/' + value; } } else { target = path + '.' + value; } target = locateTarget(actionRequest, target); if (target != null) { break; } } if (path != null) { // variant #2: without value target = locateTarget(actionRequest, path); if (target != null) { break; } } // continue if (path == null) { // path not found return null; } int dotNdx = MadvocUtil.lastIndexOfDotAfterSlash(path); if (dotNdx == -1) { path = null; } else { path = path.substring(0, dotNdx); } } return target; }\n\n    ### Response:", "ground_truth": "Locates the target file from action path and the result value.", "predict": " Resolves the target for the given action request and result value.\n\n@param actionRequest the action request.\n@param resultValue the result value.\n@return the target URL or null if not found.\n\n    "}, {"ID": 1596, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void runScript(String alias, int levelC) throws IOException { String scriptFile = alias; InputStream stream; try { stream = getInputStream(scriptFile); if (stream == null) { System.out.println(\"Error. Script file is not found: \" + scriptFile); return; } } catch (IOException e) { System.out.println(\"Error. Could not load script file \" + scriptFile + \": \" + e.getMessage()); return; } final BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); try { doLines(levelC + 1, new LineReader() { @Override public String getNextLine(String prompt) throws IOException { return reader.readLine(); } }, true); } finally { reader.close(); } }\n\n    ### Response: Run a script. This might go recursive if we run from within a script..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void targetNotFound(final ActionRequest actionRequest, final String actionAndResultPath) throws IOException { final HttpServletResponse response = actionRequest.getHttpServletResponse(); if (!response.isCommitted()) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath); } }\n\n    ### Response:", "ground_truth": "Called when target not found. By default sends 404 to the response.", "predict": " Send a 404 error if the target is not found."}, {"ID": 1597, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getParentWBS(String wbs) { String result; int index = wbs.lastIndexOf('.'); if (index == -1) { result = null; } else { result = wbs.substring(0, index); } return result; }\n\n    ### Response: Extract the parent WBS from a WBS.\n\n@param wbs current WBS\n@return parent WBS.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String valueToString(final String name, final Object valueObject) { if (!valueObject.getClass().isArray()) { return valueObject.toString(); } // array String[] array = (String[]) valueObject; if (valueNameIndexes == null) { valueNameIndexes = new HashMap<>(); } MutableInteger index = valueNameIndexes.get(name); if (index == null) { index = new MutableInteger(0); valueNameIndexes.put(name, index); } if (index.value >= array.length) { return null; } String result = array[index.value]; index.value++; return result; }\n\n    ### Response:", "ground_truth": "Converts value to a string.", "predict": " Extract the next value from an array of values.\n\n@param name name of the array\n@param valueObject array of values\n@return next value in the array or null if there are no more values."}, {"ID": 1598, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T extends List<?>> Class<T> getListDefaultImplementation(Type listType) { return (Class<T>)getImplementation(LISTS, listType); }\n\n    ### Response: Get default implementation for requested list type.\n\n@param listType raw list type.\n@param  list type.\n@return default implementation for requested list..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) { filtersManager.resolve(actionFilterClass); return this; }\n\n    ### Response:", "ground_truth": "Returns action filter instance for further configuration.", "predict": " Add action filter to the router.\n\n@param actionFilterClass action filter class.\n@return this router instance."}, {"ID": 1599, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resourceName(final String className) { String name = className; if (!name.startsWith(\"/\")) { name = \"/\" + name; } if (!name.endsWith(DOT_GROOVY)) { name = name.replace('.', '/'); name += DOT_GROOVY; } return name; }\n\n    ### Response: Translate class-name into resource-name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPseudoFunctionName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; }\n\n    ### Response:", "ground_truth": "Returns pseudo-function name.", "predict": " Get the pseudo-function name for the class. The pseudo-function name is the class name in lower case with underscores replaced with hyphens."}, {"ID": 1600, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:npathcomplexity\") public static String dump(Object object, boolean includeStaticField) { if (object == null) { return new String(); } final StringBuilder buffer = new StringBuilder(); final LinkedList<Class<?>> types = new LinkedList<>(); types.add(object.getClass()); while (!types.isEmpty()) { final Class<?> type = types.removeFirst(); final Class<?> supertype = type.getSuperclass(); if (supertype != null && !supertype.equals(Object.class)) { types.add(supertype); } if (buffer.length() > 0) { buffer.append(\"\\n\"); //$NON-NLS-1$ } final Field[] fields = type.getDeclaredFields(); buffer.append(type.getSimpleName()).append(\" {\\n\"); //$NON-NLS-1$ boolean firstRound = true; for (final Field field : fields) { if (!includeStaticField && Flags.isStatic(field.getModifiers())) { continue; } if (!firstRound) { buffer.append(\",\\n\"); //$NON-NLS-1$ } firstRound = false; field.setAccessible(true); try { final Object fieldObj = field.get(object); final String value; if (null == fieldObj) { value = \"null\"; //$NON-NLS-1$ } else { value = fieldObj.toString(); } buffer.append('\\t').append(field.getName()).append('=').append('\"'); buffer.append(org.eclipse.xtext.util.Strings.convertToJavaString(value)); buffer.append(\"\\\"\\n\"); //$NON-NLS-1$ } catch (IllegalAccessException ignore) { //this should never happen } } buffer.append('}'); } return buffer.toString(); }\n\n    ### Response: Dump the object.\n\n@param object the object.\n@param includeStaticField indicates if the static fields should be included.\n@return the string representation of the object.\n@since 0.6.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyInjectionPoint[] resolve(Class type, final boolean autowire) { final List<PropertyInjectionPoint> list = new ArrayList<>(); final Set<String> usedPropertyNames = new HashSet<>(); // lookup fields while (type != Object.class) { final ClassDescriptor cd = ClassIntrospector.get().lookup(type); final PropertyDescriptor[] allPropertyDescriptors = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allPropertyDescriptors) { if (propertyDescriptor.isGetterOnly()) { continue; } if (usedPropertyNames.contains(propertyDescriptor.getName())) { continue; } Class propertyType = propertyDescriptor.getType(); if (ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } BeanReferences reference = referencesResolver.readReferenceFromAnnotation(propertyDescriptor); if (reference == null) { if (!autowire) { continue; } else { reference = referencesResolver.buildDefaultReference(propertyDescriptor); } } list.add(new PropertyInjectionPoint(propertyDescriptor, reference)); usedPropertyNames.add(propertyDescriptor.getName()); } // go to the supertype type = type.getSuperclass(); } final PropertyInjectionPoint[] fields; if (list.isEmpty()) { fields = PropertyInjectionPoint.EMPTY; } else { fields = list.toArray(new PropertyInjectionPoint[0]); } return fields; }\n\n    ### Response:", "ground_truth": "Resolves all properties for given type.", "predict": " Resolve the property injection points for the given type.\n\n@param type the type.\n@param autowire indicates if the references should be autowired.\n@return the property injection points.\n@since 0.6."}, {"ID": 1601, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean[] readBoolArray(final int items) throws IOException { int pos = 0; byte[] buffer; if (items < 0) { buffer = new byte[INITIAL_ARRAY_BUFFER_SIZE]; // till end while (true) { final int read = this.read(buffer, pos, buffer.length - pos); if (read < 0) { break; } pos += read; if (buffer.length == pos) { final byte[] newbuffer = new byte[buffer.length << 1]; System.arraycopy(buffer, 0, newbuffer, 0, buffer.length); buffer = newbuffer; } } } else { // number buffer = new byte[items]; int len = items; while (len > 0) { final int read = this.read(buffer, pos, len); if (read < 0) { throw new EOFException(\"Have read only \" + pos + \" bit portions instead of \" + items); } pos += read; len -= read; } } final boolean[] result = new boolean[pos]; for (int i = 0; i < pos; i++) { result[i] = buffer[i] != 0; } return result; }\n\n    ### Response: Read array of boolean values.\n\n@param items number of items to be read, if less than zero then read whole\nstream till the end\n@return read values as boolean array\n@throws IOException it will be thrown for transport error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Socket createSocks4ProxySocket(final String host, final int port) { Socket socket = null; final String proxyHost = proxy.getProxyAddress(); final int proxyPort = proxy.getProxyPort(); final String user = proxy.getProxyUsername(); try { socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout); final InputStream in = socket.getInputStream(); final OutputStream out = socket.getOutputStream(); socket.setTcpNoDelay(true); byte[] buf = new byte[1024]; // 1) CONNECT int index = 0; buf[index++] = 4; buf[index++] = 1; buf[index++] = (byte) (port >>> 8); buf[index++] = (byte) (port & 0xff); InetAddress addr = InetAddress.getByName(host); byte[] byteAddress = addr.getAddress(); for (byte byteAddres : byteAddress) { buf[index++] = byteAddres; } if (user != null) { System.arraycopy(user.getBytes(), 0, buf, index, user.length()); index += user.length(); } buf[index++] = 0; out.write(buf, 0, index); // 2) RESPONSE int len = 6; int s = 0; while (s < len) { int i = in.read(buf, s, len - s); if (i <= 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"stream is closed\"); } s += i; } if (buf[0] != 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned VN \" + buf[0]); } if (buf[1] != 90) { try { socket.close(); } catch (Exception ignore) { } throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned CD \" + buf[1]); } byte[] temp = new byte[2]; in.read(temp, 0, 2); return socket; } catch (RuntimeException rtex) { closeSocket(socket); throw rtex; } catch (Exception ex) { closeSocket(socket); throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex); } }\n\n    ### Response:", "ground_truth": "Connects to the SOCKS4 proxy and returns proxified socket.", "predict": " Create a socket to the SOCKS4 proxy server.\n\n@param host the host to connect to\n@param port the port to connect to\n@return the socket connected to the SOCKS4 proxy server\n@throws HttpException if any error occurs during the connection process\n\n    "}, {"ID": 1602, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final int getCount() { int count = 0; Attribute attr = this; while (attr != null) { count += 1; attr = attr.next; } return count; }\n\n    ### Response: Returns the length of the attribute list that begins with this attribute.\n\n@return the length of the attribute list that begins with this attribute..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final int getAttributeCount() { int count = 0; Attribute attribute = this; while (attribute != null) { count += 1; attribute = attribute.nextAttribute; } return count; }\n\n    ### Response:", "ground_truth": "Returns the number of attributes of the attribute list that begins with this attribute.\n\n@return the number of attributes of the attribute list that begins with this attribute.", "predict": " Returns the length of the attribute list that begins with this attribute.\n\n@return the length of the attribute list that begins with this attribute."}, {"ID": 1603, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final Set<String> impliedSet(String... views) { Set<String> set = new HashSet<>(); for (String view : views) { set.addAll(impliesMap.get(view)); } return set; }\n\n    ### Response: Returns a set that contains given views as well as all implied views.\n@param views\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<ActionResult> getAllActionResults() { final Set<ActionResult> set = new HashSet<>(allResults.size()); allResults.forEachValue(set::add); return set; }\n\n    ### Response:", "ground_truth": "Returns all action results as new set.", "predict": " Returns a set of all action results.\n@return."}, {"ID": 1604, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isValidPosixFileName(String name) { for (int i = 0; i < name.length(); i++) { char c = name.charAt(i); if (i == 0) { if (c == '-') { return false; } } if (!isValidPosixFileChar(c)) { return false; } } return true; }\n\n    ### Response: Test whether filename is a valid posix filename\nA posix filename must contain characters A-Za-z0-9._- and - must not be\nthe first character.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsOne(final char c, final CharSequence match) { for (int i = 0; i < match.length(); i++) { char aMatch = match.charAt(i); if (c == aMatch) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Match if one character equals to any of the given character.\n\n@return true if characters match any character from given array,\notherwise false", "predict": " Test whether a character is equal to any character in a string\n\nThis method takes a character and a string as input and returns true if the character is equal to any character in the string."}, {"ID": 1605, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int indexOf(Object o, Object[] elements, int index, int fence) { if (o == null) { for (int i = index; i < fence; i++) if (elements[i] == null) return i; } else { for (int i = index; i < fence; i++) if (o.equals(elements[i])) return i; } return -1; }\n\n    ### Response: static version of indexOf, to allow repeated calls without\nneeding to re-acquire array each time.\n\n@param o element to search for\n@param elements the array\n@param index first index to search\n@param fence one past last index to search\n@return index of element, or -1 if absent.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) { for (int i = index; i < source.length(); i++) { if (equalsOne(source.charAt(i), match)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given charsequence the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Finds the index of the first character in the source that matches the first character in the match.\n\n@param source the source string\n@param index the starting index\n@param match the string to match\n@return the index of the first match, or -1 if no match is found.\n\n    "}, {"ID": 1606, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int indexOf(Object o, Object[] elements, int index, int fence) { if (o == null) { for (int i = index; i < fence; i++) if (elements[i] == null) return i; } else { for (int i = index; i < fence; i++) if (o.equals(elements[i])) return i; } return -1; }\n\n    ### Response: static version of indexOf, to allow repeated calls without\nneeding to re-acquire array each time.\n\n@param o element to search for\n@param elements the array\n@param index first index to search\n@param fence one past last index to search\n@return index of element, or -1 if absent.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstEqual(final char[] source, final int index, final char match) { for (int i = index; i < source.length; i++) { if (source[i] == match) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given array the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Finds the index of the first occurrence of the specified character in the specified character array starting at the specified index.\n\n@param source the character array to search\n@param index the starting index\n@param match the character to find\n@return the index of the first occurrence of the specified character in the specified character array starting at the specified index, or -1 if the character is not found."}, {"ID": 1607, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static SysProperties toSystemProperties(final String[] arguments) { final SysProperties retVal = new SysProperties(); if (arguments != null && arguments.length != 0) { for (final String argument : arguments) { if (argument.startsWith(\"-D\")) { Variable var = AntTaskHelper.toVariable(argument); retVal.addVariable(var); } } } return retVal; }\n\n    ### Response: Converts array of JVM arguments to ANT SysProperties object.\n\n@param arguments to be converted.\n@return ANT SysProperties object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CommandLine args(final String... arguments) { if (arguments != null && arguments.length > 0) { Collections.addAll(cmdLine, arguments); } return this; }\n\n    ### Response:", "ground_truth": "Adds several arguments.", "predict": " Adds the given arguments to the command line.\n\n@param arguments to be added to the command line.\n@return this CommandLine object."}, {"ID": 1608, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Launcher addEnvironmentVariable(final String key, final String value) { env.put(key, value); return this; }\n\n    ### Response: Adds an environment variable to the process being created.\n\n@param key   they key for the variable\n@param value the value for the variable\n\n@return the launcher.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CommandLine env(final String key, final String value) { if (env == null) { env = new HashMap<>(); } env.put(key, value); return this; }\n\n    ### Response:", "ground_truth": "Sets environment variable.", "predict": " Adds an environment variable to the command line.\n\n@param key   they key for the variable\n@param value the value for the variable\n\n@return the command line."}, {"ID": 1609, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] gzip(String input) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gzos = null; try { gzos = new GZIPOutputStream(baos); gzos.write(input.getBytes(\"UTF-8\")); } catch (IOException e) { e.printStackTrace(); } finally { if (gzos != null) { try { gzos.close(); } catch (IOException ignore) { } } } return baos.toByteArray(); }\n\n    ### Response: GZip compress a string of bytes\n\n@param input\n@return a byte array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProcessRunner.ProcessResult run() { ByteArrayOutputStream baos = new ByteArrayOutputStream(); out = err = baos; try { baos.write(StringUtil.join(cmdLine, ' ').getBytes()); baos.write(StringPool.BYTES_NEW_LINE); } catch (IOException ignore) { } ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(cmdLine); if (cleanEnvironment) { processBuilder.environment().clear(); } if (env != null) { processBuilder.environment().putAll(env); } processBuilder.directory(workingDirectory); Process process = null; try { process = processBuilder.start(); } catch (IOException ioex) { return writeException(baos, ioex); } StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix); StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix); outputGobbler.start(); errorGobbler.start(); int result; try { result = process.waitFor(); } catch (InterruptedException iex) { return writeException(baos, iex); } outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessRunner.ProcessResult(result, baos.toString()); }\n\n    ### Response:", "ground_truth": "Runs command and returns process result.", "predict": " Run a command and capture its output and error streams.\n\n@return a ProcessResult object containing the exit code and output/error strings.\n\n    "}, {"ID": 1610, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void delPoint() { if (!isEnabled()) { return; } if (selected == null) { return; } if (list.indexOf(selected) == 0) { return; } if (list.indexOf(selected) == list.size()-1) { return; } list.remove(selected); sortPoints(); repaint(0); fireUpdate(); }\n\n    ### Response: Delete the currently selected point.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void invoke(final Object listener, final Class listenerType) { if (listenerType == Init.class) { ((Init) listener).init(); return; } if (listenerType == Start.class) { ((Start) listener).start(); return; } if (listenerType == Ready.class) { ((Ready) listener).ready(); return; } if (listenerType == Stop.class) { ((Stop) listener).stop(); return; } throw new MadvocException(\"Invalid listener\"); }\n\n    ### Response:", "ground_truth": "Invoke the listener based on type.\nNot very OOP, but works.", "predict": " Invoke the appropriate method on the given listener object based on its type."}, {"ID": 1611, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int nLocal, final Object[] local, final int nStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < nLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int nStackTop = 0; for (int i = 0; i < nStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++nStackTop; } } inputStack = new int[nStack + nStackTop]; int inputStackIndex = 0; for (int i = 0; i < nStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; }\n\n    ### Response: Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param nLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param nStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void copyFrom(final Frame frame) { inputLocals = frame.inputLocals; inputStack = frame.inputStack; outputStackStart = 0; outputLocals = frame.outputLocals; outputStack = frame.outputStack; outputStackTop = frame.outputStackTop; initializationCount = frame.initializationCount; initializations = frame.initializations; }\n\n    ### Response:", "ground_truth": "Sets this frame to the value of the given frame.\n\nWARNING: after this method is called the two frames share the same data structures. It is\nrecommended to discard the given frame to avoid unexpected side effects.\n\n@param frame The new frame value.", "predict": " Copies the input and output frames from the given frame.\n\n@param frame the frame to copy from."}, {"ID": 1612, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String getString(Type type) { if (type instanceof GenericObjectType) { return ((GenericObjectType) type).toString(true); } else if (type instanceof ArrayType) { return TypeCategory.asString((ArrayType) type); } else { return type.toString(); } }\n\n    ### Response: Get String representation of a Type including Generic information.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) { if (type instanceof Integer) { return CONSTANT_KIND | ((Integer) type).intValue(); } else if (type instanceof String) { String descriptor = Type.getObjectType((String) type).getDescriptor(); return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0); } else { return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset); } }\n\n    ### Response:", "ground_truth": "Returns the abstract type corresponding to the given public API frame element type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param type a frame element type described using the same format as in {@link\nMethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\nOpcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n{@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\na NEW instruction (for uninitialized types).\n@return the abstract type corresponding to the given frame element type.", "predict": " Get the abstract type from API format.\n\n    "}, {"ID": 1613, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TypeDesc forDescriptor(final String desc) throws IllegalArgumentException { TypeDesc type = cDescriptorsToInstances.get(desc); if (type != null) { return type; } // TODO: Support generics in descriptor. String rootDesc = desc; int cursor = 0; int dim = 0; try { char c; while ((c = rootDesc.charAt(cursor++)) == '[') { dim++; } switch (c) { case 'V': type = VOID; break; case 'Z': type = BOOLEAN; break; case 'C': type = CHAR; break; case 'B': type = BYTE; break; case 'S': type = SHORT; break; case 'I': type = INT; break; case 'J': type = LONG; break; case 'F': type = FLOAT; break; case 'D': type = DOUBLE; break; case 'L': if (dim > 0) { rootDesc = rootDesc.substring(dim); cursor = 1; } StringBuffer name = new StringBuffer(rootDesc.length() - 2); while ((c = rootDesc.charAt(cursor++)) != ';') { if (c == '/') { c = '.'; } name.append(c); } type = intern(new ObjectType(rootDesc, name.toString())); break; default: throw invalidDescriptor(desc); } } catch (NullPointerException e) { throw invalidDescriptor(desc); } catch (IndexOutOfBoundsException e) { throw invalidDescriptor(desc); } if (cursor != rootDesc.length()) { throw invalidDescriptor(desc); } while (--dim >= 0) { type = type.toArrayType(); } cDescriptorsToInstances.put(desc, type); return type; }\n\n    ### Response: Acquire a TypeDesc from a type descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getAbstractTypeFromDescriptor( final SymbolTable symbolTable, final String buffer, final int offset) { String internalName; switch (buffer.charAt(offset)) { case 'V': return 0; case 'Z': case 'C': case 'B': case 'S': case 'I': return INTEGER; case 'F': return FLOAT; case 'J': return LONG; case 'D': return DOUBLE; case 'L': internalName = buffer.substring(offset + 1, buffer.length() - 1); return REFERENCE_KIND | symbolTable.addType(internalName); case '[': int elementDescriptorOffset = offset + 1; while (buffer.charAt(elementDescriptorOffset) == '[') { ++elementDescriptorOffset; } int typeValue; switch (buffer.charAt(elementDescriptorOffset)) { case 'Z': typeValue = BOOLEAN; break; case 'C': typeValue = CHAR; break; case 'B': typeValue = BYTE; break; case 'S': typeValue = SHORT; break; case 'I': typeValue = INTEGER; break; case 'F': typeValue = FLOAT; break; case 'J': typeValue = LONG; break; case 'D': typeValue = DOUBLE; break; case 'L': internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1); typeValue = REFERENCE_KIND | symbolTable.addType(internalName); break; default: throw new IllegalArgumentException(); } return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue; default: throw new IllegalArgumentException(); } }\n\n    ### Response:", "ground_truth": "Returns the abstract type corresponding to the given type descriptor.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param buffer a string ending with a type descriptor.\n@param offset the start offset of the type descriptor in buffer.\n@return the abstract type corresponding to the given type descriptor.", "predict": " Get the abstract type from a descriptor."}, {"ID": 1614, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int nLocal, final Object[] local, final int nStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < nLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int nStackTop = 0; for (int i = 0; i < nStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++nStackTop; } } inputStack = new int[nStack + nStackTop]; int inputStackIndex = 0; for (int i = 0; i < nStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; }\n\n    ### Response: Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param nLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param nStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < numLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int numStackTop = 0; for (int i = 0; i < numStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++numStackTop; } } inputStack = new int[numStack + numStackTop]; int inputStackIndex = 0; for (int i = 0; i < numStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; }\n\n    ### Response:", "ground_truth": "Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param numLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param numStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}.", "predict": " Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param numLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param numStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}.."}, {"ID": 1615, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function hasAppliedValue() { $customFunction = $this->getHasAppliedValueFunction(); if (is_callable($customFunction)) { $result = call_user_func($customFunction, $this); if (!is_bool($result)) { throw new FilterException('Returned value from callable function must be boolean.'); } return $result; } $convertedValue = $this->getConvertedValue(); if (is_array($convertedValue)) { return count($convertedValue) > 0; } if (is_string($convertedValue)) { return $convertedValue !== ''; } // Fallback to empty() function by default. // If the value is int/float and it is equal to 0, it will be considered that the value has not been applied. // To change this behaviour, please override this method. return !empty($convertedValue); }\n\n    ### Response: Checks if the filter value was applied.\nNote, that the converted value is used for checking.\n\nIf there is a custom function for checking if the filter value is applied,\nit will be executed instead of default checking.\nNote, that custom function must return boolean result of checking if the filter value has been applied.\n\n@see AbstractFilter::getConvertedValue()\n@see AbstractFilter::getHasAppliedValueFunction() for custom function for checking if the filter value is applied\n\n@return bool\n\n@throws FilterException On invalid custom function returned value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getLocal(final int localIndex) { if (outputLocals == null || localIndex >= outputLocals.length) { // If this local has never been assigned in this basic block, it is still equal to its value // in the input frame. return LOCAL_KIND | localIndex; } else { int abstractType = outputLocals[localIndex]; if (abstractType == 0) { // If this local has never been assigned in this basic block, so it is still equal to its // value in the input frame. abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex; } return abstractType; } }\n\n    ### Response:", "ground_truth": "Returns the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the local variable whose value must be returned.\n@return the abstract type stored at the given local variable index in the output frame.", "predict": "Returns the abstract type of the local variable at the given index.\n\nThe abstract type is a combination of the local variable kind (e.g. parameter, local, or instance variable) and the index of the local variable in the method's local variable array.\n\nIf the local variable has never been assigned in this basic block, the abstract type is equal to the local variable index.\n\nIf the local variable has been assigned in this basic block, the abstract type is equal to the assigned value.\n\n@param localIndex the index of the local variable to get the abstract type of\n@return the abstract type of the local variable at the given index\n\n@see LocalVariableTable#getLocalVariableType(int) for getting the local variable type from the local variable table"}, {"ID": 1616, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int type) { // creates and/or resizes the output stack array if necessary if (outputStack == null) { outputStack = new int[10]; } int n = outputStack.length; if (outputStackTop >= n) { int[] t = new int[Math.max(outputStackTop + 1, 2 * n)]; System.arraycopy(outputStack, 0, t, 0, n); outputStack = t; } // pushes the type on the output stack outputStack[outputStackTop++] = type; // updates the maximun height reached by the output stack, if needed int top = owner.inputStackTop + outputStackTop; if (top > owner.outputStackMax) { owner.outputStackMax = top; } }\n\n    ### Response: Pushes a new type onto the output frame stack.\n\n@param type the type that must be pushed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setLocal(final int localIndex, final int abstractType) { // Create and/or resize the output local variables array if necessary. if (outputLocals == null) { outputLocals = new int[10]; } int outputLocalsLength = outputLocals.length; if (localIndex >= outputLocalsLength) { int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)]; System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength); outputLocals = newOutputLocals; } // Set the local variable. outputLocals[localIndex] = abstractType; }\n\n    ### Response:", "ground_truth": "Replaces the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the output frame local variable that must be set.\n@param abstractType the value that must be set.", "predict": " Sets the value of a local variable in the output frame.\n\n@param localIndex the index of the local variable to be set.\n@param abstractType the abstract type of the value to be set."}, {"ID": 1617, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int type) { // creates and/or resizes the output stack array if necessary if (outputStack == null) { outputStack = new int[10]; } int n = outputStack.length; if (outputStackTop >= n) { int[] t = new int[Math.max(outputStackTop + 1, 2 * n)]; System.arraycopy(outputStack, 0, t, 0, n); outputStack = t; } // pushes the type on the output stack outputStack[outputStackTop++] = type; // updates the maximun height reached by the output stack, if needed int top = owner.inputStackTop + outputStackTop; if (top > owner.outputStackMax) { owner.outputStackMax = top; } }\n\n    ### Response: Pushes a new type onto the output frame stack.\n\n@param type the type that must be pushed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int abstractType) { // Create and/or resize the output stack array if necessary. if (outputStack == null) { outputStack = new int[10]; } int outputStackLength = outputStack.length; if (outputStackTop >= outputStackLength) { int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)]; System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength); outputStack = newOutputStack; } // Pushes the abstract type on the output stack. outputStack[outputStackTop++] = abstractType; // Updates the maximum size reached by the output stack, if needed (note that this size is // relative to the input stack size, which is not known yet). short outputStackSize = (short) (outputStackStart + outputStackTop); if (outputStackSize > owner.outputStackMax) { owner.outputStackMax = outputStackSize; } }\n\n    ### Response:", "ground_truth": "Pushes the given abstract type on the output frame stack.\n\n@param abstractType an abstract type.", "predict": " Pushes a new abstract type onto the output frame stack.\n\n@param abstractType the abstract type that must be pushed."}, {"ID": 1618, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void initInputFrame( final ClassWriter cw, final int access, final Type[] args, final int maxLocals) { inputLocals = new int[maxLocals]; inputStack = new int[0]; int i = 0; if ((access & Opcodes.ACC_STATIC) == 0) { if ((access & MethodWriter.ACC_CONSTRUCTOR) == 0) { inputLocals[i++] = OBJECT | cw.addType(cw.thisName); } else { inputLocals[i++] = UNINITIALIZED_THIS; } } for (int j = 0; j < args.length; ++j) { int t = type(cw, args[j].getDescriptor()); inputLocals[i++] = t; if (t == LONG || t == DOUBLE) { inputLocals[i++] = TOP; } } while (i < maxLocals) { inputLocals[i++] = TOP; } }\n\n    ### Response: Initializes the input frame of the first basic block from the method\ndescriptor.\n\n@param cw the ClassWriter to which this label belongs.\n@param access the access flags of the method to which this label belongs.\n@param args the formal parameter types of this method.\n@param maxLocals the maximum number of local variables of this method..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final SymbolTable symbolTable, final String descriptor) { int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0; int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset); if (abstractType != 0) { push(abstractType); if (abstractType == LONG || abstractType == DOUBLE) { push(TOP); } } }\n\n    ### Response:", "ground_truth": "Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param descriptor a type or method descriptor (in which case its return type is pushed).", "predict": " Pushes the abstract type represented by the given descriptor onto the operand stack.\n\n@param symbolTable the symbol table to use for resolving the descriptor.\n@param descriptor the descriptor of the abstract type to push onto the operand stack."}, {"ID": 1619, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean parseSource(HttpMessage message, Source source, int depth, String baseURL) { log.debug(\"Parsing an HTML message...\"); boolean resourcesfound = false; // Process A elements List<Element> elements = source.getAllElements(HTMLElementName.A); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"href\"); } // Process AREA elements elements = source.getAllElements(HTMLElementName.AREA); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"href\"); } // Process Frame Elements elements = source.getAllElements(HTMLElementName.FRAME); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"src\"); } // Process IFrame Elements elements = source.getAllElements(HTMLElementName.IFRAME); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"src\"); } // Process Link elements elements = source.getAllElements(HTMLElementName.LINK); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"href\"); } // Process Script elements with src elements = source.getAllElements(HTMLElementName.SCRIPT); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"src\"); } // Process Img elements elements = source.getAllElements(HTMLElementName.IMG); for (Element el : elements) { resourcesfound |= processAttributeElement(message, depth, baseURL, el, \"src\"); } // Process META elements elements = source.getAllElements(HTMLElementName.META); for (Element el : elements) { // If we have http-equiv attribute, then urls can be found. String equiv = el.getAttributeValue(\"http-equiv\"); String content = el.getAttributeValue(\"content\"); if (equiv != null && content != null) { // For the following cases: // http-equiv=\"refresh\" content=\"0;URL=http://foo.bar/...\" // http-equiv=\"location\" content=\"url=http://foo.bar/...\" if (equiv.equalsIgnoreCase(\"refresh\") || equiv.equalsIgnoreCase(\"location\")) { Matcher matcher = urlPattern.matcher(content); if (matcher.find()) { String url = matcher.group(1); processURL(message, depth, url, baseURL); resourcesfound = true; } } } } return resourcesfound; }\n\n    ### Response: Parses the HTML Jericho source for the elements that contain references to other resources.\n\n@param message the message\n@param source the source\n@param depth the depth\n@param baseURL the base url\n@return {@code true} if at least one URL was found, {@code false} otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pop(final int elements) { if (outputStackTop >= elements) { outputStackTop -= elements; } else { // If the number of elements to be popped is greater than the number of elements in the output // stack, clear it, and pop the remaining elements from the input stack. outputStackStart -= elements - outputStackTop; outputStackTop = 0; } }\n\n    ### Response:", "ground_truth": "Pops the given number of abstract types from the output frame stack.\n\n@param elements the number of abstract types that must be popped.", "predict": " Pops the specified number of elements from the output stack.\n\n@param elements the number of elements to pop."}, {"ID": 1620, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pop(final String desc) { char c = desc.charAt(0); if (c == '(') { pop((MethodWriter.getArgumentsAndReturnSizes(desc) >> 2) - 1); } else if (c == 'J' || c == 'D') { pop(2); } else { pop(1); } }\n\n    ### Response: Pops a type from the output frame stack.\n\n@param desc the descriptor of the type to be popped. Can also be a method\ndescriptor (in this case this method pops the types corresponding\nto the method arguments)..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pop(final String descriptor) { char firstDescriptorChar = descriptor.charAt(0); if (firstDescriptorChar == '(') { pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1); } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') { pop(2); } else { pop(1); } }\n\n    ### Response:", "ground_truth": "Pops as many abstract types from the output frame stack as described by the given descriptor.\n\n@param descriptor a type or method descriptor (in which case its argument types are popped).", "predict": " Pops a type from the output frame stack.\n\n@param descriptor the descriptor of the type to be popped. Can also be a method\ndescriptor (in this case this method pops the types corresponding\nto the method arguments)."}, {"ID": 1621, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int type) { // creates and/or resizes the output stack array if necessary if (outputStack == null) { outputStack = new int[10]; } int n = outputStack.length; if (outputStackTop >= n) { int[] t = new int[Math.max(outputStackTop + 1, 2 * n)]; System.arraycopy(outputStack, 0, t, 0, n); outputStack = t; } // pushes the type on the output stack outputStack[outputStackTop++] = type; // updates the maximun height reached by the output stack, if needed int top = owner.inputStackTop + outputStackTop; if (top > owner.outputStackMax) { owner.outputStackMax = top; } }\n\n    ### Response: Pushes a new type onto the output frame stack.\n\n@param type the type that must be pushed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addInitializedType(final int abstractType) { // Create and/or resize the initializations array if necessary. if (initializations == null) { initializations = new int[2]; } int initializationsLength = initializations.length; if (initializationCount >= initializationsLength) { int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)]; System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength); initializations = newInitializations; } // Store the abstract type. initializations[initializationCount++] = abstractType; }\n\n    ### Response:", "ground_truth": "Adds an abstract type to the list of types on which a constructor is invoked in the basic\nblock.\n\n@param abstractType an abstract type on a which a constructor is invoked.", "predict": " Adds a new abstract type to the list of initialized types.\n\n@param abstractType the abstract type to be added to the list of initialized types."}, {"ID": 1622, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int readBits(final JBBPBitNumber numOfBitsToRead) throws IOException { int result; final int numOfBitsAsNumber = numOfBitsToRead.getBitNumber(); if (this.bitsInBuffer == 0 && numOfBitsAsNumber == 8) { result = this.readByteFromStream(); if (result >= 0) { this.byteCounter++; } return result; } else { result = 0; if (numOfBitsAsNumber == this.bitsInBuffer) { result = this.bitBuffer; this.bitBuffer = 0; this.bitsInBuffer = 0; this.byteCounter++; return result; } int i = numOfBitsAsNumber; int theBitBuffer = this.bitBuffer; int theBitBufferCounter = this.bitsInBuffer; final boolean doIncCounter = theBitBufferCounter != 0; while (i > 0) { if (theBitBufferCounter == 0) { if (doIncCounter) { this.byteCounter++; } final int nextByte = this.readByteFromStream(); if (nextByte < 0) { if (i == numOfBitsAsNumber) { return nextByte; } else { break; } } else { theBitBuffer = nextByte; theBitBufferCounter = 8; } } result = (result << 1) | (theBitBuffer & 1); theBitBuffer >>= 1; theBitBufferCounter--; i--; } this.bitBuffer = theBitBuffer; this.bitsInBuffer = theBitBufferCounter; return JBBPUtils.reverseBitsInByte(JBBPBitNumber.decode(numOfBitsAsNumber - i), (byte) result) & 0xFF; } }\n\n    ### Response: Read number of bits from the input stream. It reads bits from input stream\nsince 0 bit and make reversion to return bits in the right order when 0 bit\nis 0 bit. if the stream is completed early than the data read then reading\nis just stopped and read value returned. The First read bit is placed as\n0th bit.\n\n@param numOfBitsToRead the number of bits to be read, must be 1..8\n@return the read bits as integer, -1 if the end of stream has been reached\n@throws IOException          it will be thrown for transport errors to be read\n@throws NullPointerException if number of bits to be read is null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) { if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) { for (int i = 0; i < initializationCount; ++i) { int initializedType = initializations[i]; int dim = initializedType & DIM_MASK; int kind = initializedType & KIND_MASK; int value = initializedType & VALUE_MASK; if (kind == LOCAL_KIND) { initializedType = dim + inputLocals[value]; } else if (kind == STACK_KIND) { initializedType = dim + inputStack[inputStack.length - value]; } if (abstractType == initializedType) { if (abstractType == UNINITIALIZED_THIS) { return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName()); } else { return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value); } } } } return abstractType; }\n\n    ### Response:", "ground_truth": "Returns the \"initialized\" abstract type corresponding to the given abstract type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type.\n@return the REFERENCE_KIND abstract type corresponding to abstractType if it is\nUNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\nconstructor is invoked in the basic block. Otherwise returns abstractType.", "predict": " Get the initialized type for the given abstract type. If the abstract type is not initialized yet, it will try to find the initialization in the initialization table. If the initialization is found, it will return the initialized type. Otherwise, it will return the abstract type as it is.\n\n@param symbolTable the symbol table to be used for type resolution\n@param abstractType the abstract type to be initialized\n@return the initialized type for the given abstract type\n\n    "}, {"ID": 1623, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void visitFrameAfterMethodReturnCallback() { if (!visitFramesAfterCallbacks) return; Type returnType = getReturnTypeForTrace(); if (!Type.VOID_TYPE.equals(getReturnTypeForTrace()) && !isConstructor()) { Object typeDescriptor = null; switch (returnType.getSort()) { case Type.BOOLEAN: case Type.BYTE: case Type.CHAR: case Type.INT: case Type.SHORT: typeDescriptor = INTEGER; break; case Type.DOUBLE: typeDescriptor = DOUBLE; break; case Type.FLOAT: typeDescriptor = FLOAT; break; case Type.LONG: typeDescriptor = LONG; break; default: typeDescriptor = returnType.getInternalName(); break; } visitFrame(F_SAME1, 0, null, 1, new Object[] { typeDescriptor }); } else { visitFrame(F_SAME, 0, null, 0, null); } }\n\n    ### Response: Generate the stack frame that's needed after visiting the\nmethod exit trace guard target injected by tracing adapters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void putAbstractType( final SymbolTable symbolTable, final int abstractType, final ByteVector output) { int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT; if (arrayDimensions == 0) { int typeValue = abstractType & VALUE_MASK; switch (abstractType & KIND_MASK) { case CONSTANT_KIND: output.putByte(typeValue); break; case REFERENCE_KIND: output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index); break; case UNINITIALIZED_KIND: output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data); break; default: throw new AssertionError(); } } else { // Case of an array type, we need to build its descriptor first. StringBuilder typeDescriptor = new StringBuilder(); while (arrayDimensions-- > 0) { typeDescriptor.append('['); } if ((abstractType & KIND_MASK) == REFERENCE_KIND) { typeDescriptor .append('L') .append(symbolTable.getType(abstractType & VALUE_MASK).value) .append(';'); } else { switch (abstractType & VALUE_MASK) { case Frame.ITEM_ASM_BOOLEAN: typeDescriptor.append('Z'); break; case Frame.ITEM_ASM_BYTE: typeDescriptor.append('B'); break; case Frame.ITEM_ASM_CHAR: typeDescriptor.append('C'); break; case Frame.ITEM_ASM_SHORT: typeDescriptor.append('S'); break; case Frame.ITEM_INTEGER: typeDescriptor.append('I'); break; case Frame.ITEM_FLOAT: typeDescriptor.append('F'); break; case Frame.ITEM_LONG: typeDescriptor.append('J'); break; case Frame.ITEM_DOUBLE: typeDescriptor.append('D'); break; default: throw new AssertionError(); } } output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index); } }\n\n    ### Response:", "ground_truth": "Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\nformat used in StackMapTable attributes.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\nFrame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n@param output where the abstract type must be put.\n@see JVMS\n4.7.4", "predict": " Generate the stack frame that's needed to store an abstract type in the constant pool of a class file."}, {"ID": 1624, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int size(PersistentStore store) { int count = 0; readLock.lock(); try { RowIterator it = firstRow(null, store); while (it.hasNext()) { it.getNextRow(); count++; } return count; } finally { readLock.unlock(); } }\n\n    ### Response: Returns the node count..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected int pruneCache() { int count = 0; Iterator<CacheObject<K,V>> values = cacheMap.values().iterator(); while (values.hasNext()) { CacheObject co = values.next(); if (co.isExpired()) { values.remove(); count++; } } return count; }\n\n    ### Response:", "ground_truth": "Prunes expired elements from the cache. Returns the number of removed objects.", "predict": " Removes expired cache objects from the cache and returns the count of removed objects."}, {"ID": 1625, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startPeriodicStatsPrinting() { if (m_statsTimer == null) { m_statsTimer = new Timer(); m_statsTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { printStats(); } }, 5000, 5000); } }\n\n    ### Response: Start a timer that prints cache stats to the console every 5s.\nUsed for development until we get better stats integration..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void schedulePrune(final long delay) { if (pruneTimer != null) { pruneTimer.cancel(); } pruneTimer = new Timer(); pruneTimer.schedule( new TimerTask() { @Override public void run() { prune(); } }, delay, delay ); }\n\n    ### Response:", "ground_truth": "Schedules prune.", "predict": " Schedule a timer to prune the cache every delay seconds."}, {"ID": 1626, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitRequire(String module, int access, String version) { if (mv != null) { mv.visitRequire(module, access, version); } }\n\n    ### Response: Visits a dependence of the current module.\n\n@param module the qualified name of the dependence.\n@param access the access flag of the dependence among\nACC_TRANSITIVE, ACC_STATIC_PHASE, ACC_SYNTHETIC\nand ACC_MANDATED.\n@param version the module version at compile time or null..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ModuleVisitor visitModule(final String name, final int access, final String version) { if (api < Opcodes.ASM6) { throw new UnsupportedOperationException(\"This feature requires ASM6\"); } if (cv != null) { return cv.visitModule(name, access, version); } return null; }\n\n    ### Response:", "ground_truth": "Visit the module corresponding to the class.\n\n@param name the fully qualified name (using dots) of the module.\n@param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\nACC_MANDATED}.\n@param version the module version, or {@literal null}.\n@return a visitor to visit the module values, or {@literal null} if this visitor is not\ninterested in visiting this module.", "predict": " Visits a module declaration.\n\n@param name the name of the module.\n@param access the access flags of this module, among\nACC_OPEN, ACC_TRANSITIVE, ACC_STATIC_PHASE,\nACC_SYNTHETIC and ACC_MANDATED.\n@param version the version of this module, or null if not specified.\n@return a visitor to visit the module members, or null if this visitor is not interested in visiting the module members."}, {"ID": 1627, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateLockingValues(Object obj) throws PersistenceBrokerException { FieldDescriptor[] fields = getLockingFields(); for (int i = 0; i < fields.length; i++) { FieldDescriptor fmd = fields[i]; if (fmd.isUpdateLock()) { PersistentField f = fmd.getPersistentField(); Object cv = f.get(obj); // int if ((f.getType() == int.class) || (f.getType() == Integer.class)) { int newCv = 0; if (cv != null) { newCv = ((Number) cv).intValue(); } newCv++; f.set(obj, new Integer(newCv)); } // long else if ((f.getType() == long.class) || (f.getType() == Long.class)) { long newCv = 0; if (cv != null) { newCv = ((Number) cv).longValue(); } newCv++; f.set(obj, new Long(newCv)); } // Timestamp else if (f.getType() == Timestamp.class) { long newCv = System.currentTimeMillis(); f.set(obj, new Timestamp(newCv)); } } } }\n\n    ### Response: updates the values for locking fields , BRJ\nhandles int, long, Timestamp\nrespects updateLock so locking field are only updated when updateLock is true\n@throws PersistenceBrokerException if there is an erros accessing obj field values.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitNestHost(final String nestHost) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestHost(nestHost); } }\n\n    ### Response:", "ground_truth": "Visits the nest host class of the class. A nest is a set of classes of the same package that\nshare access to their private members. One of these classes, called the host, lists the other\nmembers of the nest, which in turn should link to the host of their nest. This method must be\ncalled only once and only if the visited class is a non-host member of a nest. A class is\nimplicitly its own nest, so it's invalid to call this method with the visited class name as\nargument.\n\n@param nestHost the internal name of the host class of the nest.", "predict": " visits the nest host attribute of the class, BRJ\n@throws UnsupportedOperationException if the api version is less than 7\n@throws IllegalArgumentException if the nestHost is null or empty"}, {"ID": 1628, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onVisitFieldInsn(int opcode, String owner, String name, String descriptor) { super.visitFieldInsn(opcode, owner, name, descriptor); }\n\n    ### Response: Visits a field instruction.\n\n@param opcode     The visited opcode.\n@param owner      The field's owner.\n@param name       The field's name.\n@param descriptor The field's descriptor..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitOuterClass(final String owner, final String name, final String descriptor) { if (cv != null) { cv.visitOuterClass(owner, name, descriptor); } }\n\n    ### Response:", "ground_truth": "Visits the enclosing class of the class. This method must be called only if the class has an\nenclosing class.\n\n@param owner internal name of the enclosing class of the class.\n@param name the name of the method that contains the class, or {@literal null} if the class is\nnot enclosed in a method of its enclosing class.\n@param descriptor the descriptor of the method that contains the class, or {@literal null} if\nthe class is not enclosed in a method of its enclosing class.", "predict": " Visits the enclosing method of the class.\n\n@param owner      The internal name of the class enclosing the method.\n@param name       The method's name.\n@param descriptor The method's descriptor."}, {"ID": 1629, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(String desc, boolean visible) { if (fv != null) { return fv.visitAnnotation(desc, visible); } return null; }\n\n    ### Response: Visits an annotation of the field.\n\n@param desc\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (cv != null) { return cv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of the class.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation of the class.\n\n@param descriptor\nthe class descriptor of the annotation class.\n@param visible\ntrue if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or null if\nthis visitor is not interested in visiting this annotation."}, {"ID": 1630, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateLockingValues(Object obj) throws PersistenceBrokerException { FieldDescriptor[] fields = getLockingFields(); for (int i = 0; i < fields.length; i++) { FieldDescriptor fmd = fields[i]; if (fmd.isUpdateLock()) { PersistentField f = fmd.getPersistentField(); Object cv = f.get(obj); // int if ((f.getType() == int.class) || (f.getType() == Integer.class)) { int newCv = 0; if (cv != null) { newCv = ((Number) cv).intValue(); } newCv++; f.set(obj, new Integer(newCv)); } // long else if ((f.getType() == long.class) || (f.getType() == Long.class)) { long newCv = 0; if (cv != null) { newCv = ((Number) cv).longValue(); } newCv++; f.set(obj, new Long(newCv)); } // Timestamp else if (f.getType() == Timestamp.class) { long newCv = System.currentTimeMillis(); f.set(obj, new Timestamp(newCv)); } } } }\n\n    ### Response: updates the values for locking fields , BRJ\nhandles int, long, Timestamp\nrespects updateLock so locking field are only updated when updateLock is true\n@throws PersistenceBrokerException if there is an erros accessing obj field values.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitNestMember(final String nestMember) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestMember(nestMember); } }\n\n    ### Response:", "ground_truth": "Visits a member of the nest. A nest is a set of classes of the same package that share access\nto their private members. One of these classes, called the host, lists the other members of the\nnest, which in turn should link to the host of their nest. This method must be called only if\nthe visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\nit's invalid to call this method with the visited class name as argument.\n\n@param nestMember the internal name of a nest member.", "predict": " visits a nest member, BRJ\n@param nestMember the name of the nest member to visit\n@throws UnsupportedOperationException if the ASM version is less than 7"}, {"ID": 1631, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitInnerClass(String name, String outerName, String innerName, int access) { // Make sure the class is annotated. ensureAnnotated(); if (name.equals(getClassInternalName())) { StringBuilder sb = new StringBuilder(); sb.append(outerName); sb.append(\"$\"); sb.append(innerName); isInnerClass = name.equals(sb.toString()); } super.visitInnerClass(name, outerName, innerName, access); }\n\n    ### Response: Visit the information about an inner class. We use this to determine\nwhether or not the we're visiting an inner class. This callback is\nalso used to ensure that appropriate class level annotations exist..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitInnerClass( final String name, final String outerName, final String innerName, final int access) { if (cv != null) { cv.visitInnerClass(name, outerName, innerName, access); } }\n\n    ### Response:", "ground_truth": "Visits information about an inner class. This inner class is not necessarily a member of the\nclass being visited.\n\n@param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@param outerName the internal name of the class to which the inner class belongs (see {@link\nType#getInternalName()}). May be {@literal null} for not member classes.\n@param innerName the (simple) name of the inner class inside its enclosing class. May be\n{@literal null} for anonymous inner classes.\n@param access the access flags of the inner class as originally declared in the enclosing\nclass.", "predict": "Visit an inner class. This method is called by the JVM when it encounters an inner class definition. The name, outerName, innerName, and access parameters are used to identify the inner class being visited. If a ConstantVisitor (cv) has been registered with this visitor, it will be notified of the inner class being visited."}, {"ID": 1632, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public FieldVisitor visitField(int access, String name, String desc, String signature, Object defaultValue) { if (scanPolicyIsExternal() || !isDetailEnabled()) { visitEnd(); throw VISIT_ENDED_DETAIL; } return fieldVisitor; }\n\n    ### Response: visiting the field..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldVisitor visitField( final int access, final String name, final String descriptor, final String signature, final Object value) { if (cv != null) { return cv.visitField(access, name, descriptor, signature, value); } return null; }\n\n    ### Response:", "ground_truth": "Visits a field of the class.\n\n@param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\nthe field is synthetic and/or deprecated.\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).\n@param signature the field's signature. May be {@literal null} if the field's type does not use\ngeneric types.\n@param value the field's initial value. This parameter, which may be {@literal null} if the\nfield does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\nLong}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\nor {@code String} fields respectively). This parameter is only used for static\nfields. Its value is ignored for non static fields, which must be initialized through\nbytecode instructions in constructors or methods.\n@return a visitor to visit field annotations and attributes, or {@literal null} if this class\nvisitor is not interested in visiting these annotations and attributes.", "predict": " visiting the field.."}, {"ID": 1633, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized Session getSession() { if (session == null) { if (authenticator != null) { session = Session.getInstance(properties, authenticator); } else { session = Session.getInstance(properties); } } return session; }\n\n    ### Response: Gets the Session-object.\n\n@return 's the Session-object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbThreadSession getThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session == null) { session = new DbThreadSession(); } return session; }\n\n    ### Response:", "ground_truth": "Returns existing thread session, or new one if already not exist. If session doesn't exist, it will be created\nusing default connection provider.", "predict": " Gets the DbThreadSession object for the current thread.\n\n@return the DbThreadSession object for the current thread."}, {"ID": 1634, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onCreate(Bundle savedInstanceState) { Session session = Session.getActiveSession(); if (session == null) { if (savedInstanceState != null) { session = Session.restoreSession(activity, null, callback, savedInstanceState); } if (session == null) { session = new Session(activity); } Session.setActiveSession(session); } if (savedInstanceState != null) { pendingFacebookDialogCall = savedInstanceState.getParcelable(DIALOG_CALL_BUNDLE_SAVE_KEY); } }\n\n    ### Response: To be called from an Activity or Fragment's onCreate method.\n\n@param savedInstanceState the previously saved state.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session != null) { session.closeSession(); } }\n\n    ### Response:", "ground_truth": "Closes thread session.", "predict": " To be called from a background thread to close the database session.\n\n@throws SQLException if there is an error closing the database session."}, {"ID": 1635, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StrBuilder deleteAll(final String str) { final int len = (str == null ? 0 : str.length()); if (len > 0) { int index = indexOf(str, 0); while (index >= 0) { deleteImpl(index, index + len, len); index = indexOf(str, index); } } return this; }\n\n    ### Response: Deletes the string wherever it occurs in the builder.\n\n@param str  the string to delete, null causes no action\n@return this, to enable chaining.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionWrapper[] createExecutionArray() { int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0); int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0); ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1]; // filters int index = 0; if (totalFilters > 0) { System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters); index += totalFilters; } // result is executed AFTER the action AND interceptors executionArray[index++] = actionRequest -> { Object actionResult = actionRequest.invoke(); ActionRequest.this.madvocController.render(ActionRequest.this, actionResult); return actionResult; }; // interceptors if (totalInterceptors > 0) { System.arraycopy(actionRuntime.getInterceptors(), 0, executionArray, index, totalInterceptors); index += totalInterceptors; } // action executionArray[index] = actionRequest -> { actionResult = invokeActionMethod(); return actionResult; }; return executionArray; }\n\n    ### Response:", "ground_truth": "Creates execution array that will invoke all filters, actions and results\nin correct order.", "predict": " Creates an array of ActionWrappers that will be executed in order to process the action request.\n\n@return an array of ActionWrappers that will be executed in order to process the action request."}, {"ID": 1636, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object invokeTarget(Object target, Method method, Object[] args) throws Throwable { Object returnValue; try { returnValue = method.invoke(target, args); } catch(InvocationTargetException ite) { throw ite.getTargetException(); } return returnValue; }\n\n    ### Response: Invoke the underlying method, catching any InvocationTargetException and rethrowing the target exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeActionMethod() throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return null; } final Object[] params = targets.extractParametersValues(); try { return actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } }\n\n    ### Response:", "ground_truth": "Invokes action method after starting all interceptors.\nAfter method invocation, all interceptors will finish, in opposite order.", "predict": " Invoke the action method on the action object, passing in the extracted parameters values. If an action handler is defined, invoke it instead. If an exception is thrown, wrap it in a new exception and rethrow it."}, {"ID": 1637, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void sendAsync(BasicMessageWithExtraData<? extends BasicMessage> messageWithData) { if (!isConnected()) { throw new IllegalStateException(\"WebSocket connection was closed. Cannot send any messages\"); } BasicMessage message = messageWithData.getBasicMessage(); configurationAuthentication(message); sendExecutor.execute(new Runnable() { @Override public void run() { try { if (messageWithData.getBinaryData() == null) { String messageString = ApiDeserializer.toHawkularFormat(message); @SuppressWarnings(\"resource\") Buffer buffer = new Buffer().writeUtf8(messageString); RequestBody requestBody = RequestBody.create(WebSocket.TEXT, buffer.readByteArray()); FeedCommProcessor.this.webSocket.sendMessage(requestBody); } else { BinaryData messageData = ApiDeserializer.toHawkularFormat(message, messageWithData.getBinaryData()); RequestBody requestBody = new RequestBody() { @Override public MediaType contentType() { return WebSocket.BINARY; } @Override public void writeTo(BufferedSink bufferedSink) throws IOException { emitToSink(messageData, bufferedSink); } }; FeedCommProcessor.this.webSocket.sendMessage(requestBody); } } catch (Throwable t) { log.errorFailedToSendOverFeedComm(message.getClass().getName(), t); } } }); }\n\n    ### Response: Sends a message to the server asynchronously. This method returns immediately; the message may not go out until\nsome time in the future.\n\n@param messageWithData the message to send.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String readRequestBody() { if (requestBody == null) { try { requestBody = ServletUtil.readRequestBodyFromStream(getHttpServletRequest()); } catch (IOException ioex) { requestBody = StringPool.EMPTY; } } return requestBody; }\n\n    ### Response:", "ground_truth": "Reads request body only once and returns it to user.", "predict": " Reads the request body from the input stream and returns it as a string.\n\n@return the request body as a string."}, {"ID": 1638, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> subList(final List<T> list, int pageSize, int page) { if (pageSize <= 0 || page == 0) { return Collections.EMPTY_LIST; } int size = list.size(); int fromIndex = page > 0 ? (page - 1) * pageSize : size + (page * pageSize); int toIndex = fromIndex + pageSize; int finalFromIndex = Math.max(0, fromIndex); int finalToIndex = Math.min(size, Math.max(0, toIndex)); // prevent fromIndex to be greater than toIndex if (finalFromIndex > finalToIndex) { finalFromIndex = finalToIndex; } try { return list.subList(finalFromIndex, finalToIndex); } catch (Throwable t) { logger.warn(\"Invalid range for sublist in paging, pageSize {}, page {}: {}\", new Object[] { pageSize, page, t.getMessage() }); } return Collections.EMPTY_LIST; }\n\n    ### Response: Return a single page of the list with the given paging parameters.\n\n@param list\n@param pageSize\n@param page\n@return subList.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) { if (total == 0) { return 0; } if (page < 1) { page = 1; } int first = (page - 1) * pageSize; if (first >= total) { first = ((total - 1) / pageSize) * pageSize; // first item on the last page } return first; }\n\n    ### Response:", "ground_truth": "Calculates the first item index of requested page.", "predict": " Calculate the index of the first item on the given page.\n\n@param page\n@param pageSize\n@param total\n@return index of the first item on the given page."}, {"ID": 1639, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void showProgress(final int id, final int sofar, final int total) { final T notification = get(id); if (notification == null) { return; } notification.updateStatus(FileDownloadStatus.progress); notification.update(sofar, total); }\n\n    ### Response: Show the notification with the exact progress.\n\n@param id    The download id.\n@param sofar The downloaded bytes so far.\n@param total The total bytes of this task..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int calcFirstItemIndexOfPage(final PageRequest pageRequest, final int total) { return calcFirstItemIndexOfPage(pageRequest.getPage(), pageRequest.getSize(), total); }\n\n    ### Response:", "ground_truth": "Calculates first item index of the page.", "predict": " Calculate the index of the first item on the specified page.\n\n@param pageRequest The page request object.\n@param total       The total number of items.\n@return The index of the first item on the specified page."}, {"ID": 1640, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int gcd(int a, int b) { while (a != b) { if (a > b) { int na = a % b; if (na == 0) return b; a = na; } else { int nb = b % a; if (nb == 0) return a; b = nb; } } return a; }\n\n    ### Response: duplicated here to avoid dependencies.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean match(final int value) { if (a == 0) { return value == b; } if (a > 0) { if (value < b) { return false; } return (value - b) % a == 0; } if (value > b) { return false; } return (b - value) % (-a) == 0; }\n\n    ### Response:", "ground_truth": "Matches expression with the value.", "predict": "/**\n     * Checks if the given value matches the pattern defined by the current instance of the class.\n     * \n     * @param value the value to check against the pattern\n     * @return true if the value matches the pattern, false otherwise\n     */\n    public boolean match(final int value) {\n        if (a == 0) {\n            return value == b;\n        }\n        if (a > 0) {\n            if (value < b) {\n                return false;\n            }\n            return (value - b) % a == 0;\n        }\n        if (value > b) {\n            return false;\n        }\n        return (b - value) % (-a) == 0;\n    }"}, {"ID": 1641, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int stringToUTFBytes(String str, HsqlByteArrayOutputStream out) { int strlen = str.length(); int c, count = 0; if (out.count + strlen + 8 > out.buffer.length) { out.ensureRoom(strlen + 8); } char[] arr = str.toCharArray(); for (int i = 0; i < strlen; i++) { c = arr[i]; if (c >= 0x0001 && c <= 0x007F) { out.buffer[out.count++] = (byte) c; count++; } else if (c > 0x07FF) { out.buffer[out.count++] = (byte) (0xE0 | ((c >> 12) & 0x0F)); out.buffer[out.count++] = (byte) (0x80 | ((c >> 6) & 0x3F)); out.buffer[out.count++] = (byte) (0x80 | ((c >> 0) & 0x3F)); count += 3; } else { out.buffer[out.count++] = (byte) (0xC0 | ((c >> 6) & 0x1F)); out.buffer[out.count++] = (byte) (0x80 | ((c >> 0) & 0x3F)); count += 2; } if (out.count + 8 > out.buffer.length) { out.ensureRoom(strlen - i + 8); } } return count; }\n\n    ### Response: Writes a string to the specified DataOutput using UTF-8 encoding in a\nmachine-independent manner.\n\n@param      str   a string to be written.\n@param      out   destination to write to\n@return     The number of bytes written out..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] toRawByteArray(final char[] carr) { byte[] barr = new byte[carr.length << 1]; for (int i = 0, bpos = 0; i < carr.length; i++) { char c = carr[i]; barr[bpos++] = (byte) ((c & 0xFF00) >> 8); barr[bpos++] = (byte) (c & 0x00FF); } return barr; }\n\n    ### Response:", "ground_truth": "Converts char array into byte array by replacing each character with two bytes.", "predict": " Converts a char array to a byte array in big-endian order.\n\n@param      carr  the char array to be converted\n@return     the resulting byte array\n\n    "}, {"ID": 1642, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int indexOf(Object o, Object[] elements, int index, int fence) { if (o == null) { for (int i = index; i < fence; i++) if (elements[i] == null) return i; } else { for (int i = index; i < fence; i++) if (o.equals(elements[i])) return i; } return -1; }\n\n    ### Response: static version of indexOf, to allow repeated calls without\nneeding to re-acquire array each time.\n\n@param o element to search for\n@param elements the array\n@param index first index to search\n@param fence one past last index to search\n@return index of element, or -1 if absent.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstDiff(final char[] source, final int index, final char[] match) { for (int i = index; i < source.length; i++) { if (!equalsOne(source[i], match)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given array the differs from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Finds the index of the first character in the source array that is different from the corresponding character in the match array.\n\n@param source the array to search\n@param index the starting index\n@param match the array to compare against\n@return the index of the first difference, or -1 if all characters match."}, {"ID": 1643, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String applyTransformations(String src) { switch (transform) { case LOWERCASE: return src.toLowerCase(); case UPPERCASE: return src.toUpperCase(); case CAPITALIZE: StringBuilder ret = new StringBuilder(src.length()); boolean ws = true; for (int i = 0; i < src.length(); i++) { char ch = src.charAt(i); if (Character.isWhitespace(ch)) ws = true; else { if (ws) ch = Character.toUpperCase(ch); ws = false; } ret.append(ch); } return ret.toString(); default: return src; } }\n\n    ### Response: Applies the text transformations to a string according to the current style.\n@param src The source string\n@return the string after transformations.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; }\n\n    ### Response:", "ground_truth": "Renders node name.", "predict": " Resolves the node name according to the current style.\n@param node The node to resolve the name for\n@return the resolved node name."}, {"ID": 1644, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Object getDataValuesForType(Entity entity, Attribute attribute) { String attributeName = attribute.getName(); switch (attribute.getDataType()) { case DATE: return entity.getLocalDate(attributeName); case DATE_TIME: return entity.getInstant(attributeName); case BOOL: return entity.getBoolean(attributeName); case DECIMAL: return entity.getDouble(attributeName); case LONG: return entity.getLong(attributeName); case INT: return entity.getInt(attributeName); case HYPERLINK: case ENUM: case HTML: case TEXT: case SCRIPT: case EMAIL: case STRING: return entity.getString(attributeName); case CATEGORICAL: case XREF: case FILE: Entity refEntity = entity.getEntity(attributeName); if (refEntity != null) return refEntity.getIdValue(); else return \"\"; case CATEGORICAL_MREF: case MREF: List<String> mrefValues = newArrayList(); for (Entity mrefEntity : entity.getEntities(attributeName)) { if (mrefEntity != null) { mrefValues.add(mrefEntity.getIdValue().toString()); } } return mrefValues; case COMPOUND: return \"\"; default: return \"\"; } }\n\n    ### Response: Package-private for testability..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveAttributeName(final Node node, final Attribute attribute) { switch (attributeCase) { case DEFAULT: return attribute.getName(); case RAW: return attribute.getRawName(); case LOWERCASE: return attribute.getRawName().toLowerCase(); case UPPERCASE: return attribute.getRawName().toUpperCase(); } return null; }\n\n    ### Response:", "ground_truth": "Renders attribute name.", "predict": " Resolves the attribute name based on the attribute case.\n\n    "}, {"ID": 1645, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getAttributeValue( Node node, String attributeName, String defaultValue) { NamedNodeMap attributes = node.getAttributes(); Node attributeNode = attributes.getNamedItem(attributeName); if (attributeNode == null) { return defaultValue; } String value = attributeNode.getNodeValue(); if (value == null) { return defaultValue; } return value; }\n\n    ### Response: Returns the attribute with the given name from the given node.\nIf the respective attribute could not be obtained, the given\ndefault value will be returned\n\n@param node The node to obtain the attribute from\n@param attributeName The name of the attribute\n@param defaultValue The default value to return when the specified\nattribute could not be obtained\n@return The value of the attribute, or the default value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDoubleQuoted(value)); appendable.append('\\\"'); } }\n\n    ### Response:", "ground_truth": "Renders attribute.", "predict": " Renders the given attribute of the given node to the given appendable.\n\n@param node The node to render the attribute from\n@param attribute The attribute to render\n@param appendable The appendable to write the attribute to\n@throws IOException If an error occurs while writing to the appendable\n\n    "}, {"ID": 1646, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] receiveMessages() { try { final byte[] data; final int size = in.available(); if (size <= 0) { data = null; } else { data = new byte[size]; in.readFully(data); } return data; } catch (final IOException exception) { Verbose.exception(exception); return new byte[0]; } }\n\n    ### Response: Receive messages data from the client.\n\n@return The messages data..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final File file) throws IOException { final String extension = FileNameUtil.getExtension(file.getAbsolutePath()); final String data; if (extension.equalsIgnoreCase(\"properties\")) { data = FileUtil.readString(file, StringPool.ISO_8859_1); } else { data = FileUtil.readString(file); } parse(data); return this; }\n\n    ### Response:", "ground_truth": "Loads props from the file. Assumes UTF8 encoding unless\nthe file ends with '.properties', than it uses ISO 8859-1.", "predict": " Load the properties file.\n\n@param file The properties file to load.\n@return The loaded properties file.\n@throws IOException If an error occurs while loading the properties file."}, {"ID": 1647, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void load(final InputStream is, final String encoding) throws IOException { load(new InputStreamReader(is, encoding)); }\n\n    ### Response: Loads properties from the specified stream. The caller of this method is responsible for\nclosing the stream.\n\n@param is\nThe input stream\n@param encoding\nThe encoding.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final File file, final String encoding) throws IOException { parse(FileUtil.readString(file, encoding)); return this; }\n\n    ### Response:", "ground_truth": "Loads properties from the file in provided encoding.", "predict": " Loads properties from the specified file. The caller of this method is responsible for\nclosing the file.\n\n@param file\nThe file\n@param encoding\nThe encoding."}, {"ID": 1648, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] copyToByteArray(InputStream in) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE); copy(in, out); return out.toByteArray(); }\n\n    ### Response: Copy the contents of the given InputStream into a new byte array.\nCloses the stream when done.\n\n@param in the stream to copy from\n@return the new byte array that has been copied to\n@throws IOException in case of I/O errors.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final InputStream in) throws IOException { final Writer out = new FastCharArrayWriter(); StreamUtil.copy(in, out); parse(out.toString()); return this; }\n\n    ### Response:", "ground_truth": "Loads properties from input stream. Stream is not closed at the end.", "predict": " Load properties from the given input stream.\n\n@param in the input stream to load from\n@return this Props object\n@throws IOException in case of I/O errors\n\n    "}, {"ID": 1649, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String objectToString(Object value) { if (value == null) { return null; } if (value instanceof String) { return (String)value; } if (value instanceof String[]) { return StringUtils.join(encodeString((String[])value), ARRAY_DELIMITER); } else if (value instanceof Integer) { return Integer.toString((Integer)value); } else if (value instanceof Long) { return Long.toString((Long)value); } else if (value instanceof Double) { return Double.toString((Double)value); } else if (value instanceof Boolean) { return Boolean.toString((Boolean)value); } else if (value instanceof Map) { Map<?, ?> map = (Map<?, ?>)value; StringBuilder stringValue = new StringBuilder(); Map.Entry<?, ?>[] entries = Iterators.toArray(map.entrySet().iterator(), Map.Entry.class); for (int i = 0; i < entries.length; i++) { Map.Entry<?, ?> entry = entries[i]; String entryKey = encodeString(Objects.toString(entry.getKey(), \"\")); String entryValue = encodeString(Objects.toString(entry.getValue(), \"\")); stringValue.append(entryKey).append(KEY_VALUE_DELIMITER).append(entryValue); if (i < entries.length - 1) { stringValue.append(ARRAY_DELIMITER); } } return stringValue.toString(); } throw new IllegalArgumentException(\"Unsupported type: \" + value.getClass().getName()); }\n\n    ### Response: Converts a typed value to it's string representation.\n@param value Typed value\n@return String value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final Map<?, ?> p) { for (final Map.Entry<?, ?> entry : p.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(name, value.toString(), false); } return this; }\n\n    ### Response:", "ground_truth": "Loads base properties from the provided java properties.\nNull values are ignored.", "predict": " Loads properties from a map into a Props object.\n@param p Map of properties\n@return Props object with loaded properties."}, {"ID": 1650, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Properties difference(final Map map) { final Properties difference = new Properties(); for (final Object o : map.entrySet()) { final Map.Entry entry = (Map.Entry) o; final String key = (String) entry.getKey(); final String val = (String) entry.getValue(); if (!properties.containsKey(key)) { difference.setProperty(key, val); } } return difference; }\n\n    ### Response: Reads map of input properties and returns a collection of those that are unique\nto that input set.\n\n@param map Map of key/value pairs\n@return Properties unique to map.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Props load(final Map<?, ?> map, final String prefix) { String realPrefix = prefix; realPrefix += '.'; for (final Map.Entry entry : map.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(realPrefix + name, value.toString(), false); } return this; }\n\n    ### Response:", "ground_truth": "Loads base properties from java Map using provided prefix.\nNull values are ignored.", "predict": " Loads properties from a map into a Props object.\n\n@param map Map of key/value pairs\n@param prefix Prefix to apply to all keys in the map\n@return This Props object\n@throws IllegalArgumentException If a key in the map is not a string or if a value is not a string or null"}, {"ID": 1651, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addFilePatternsToPackageResourceGuard(final Application application, final String... patterns) { final IPackageResourceGuard packageResourceGuard = application.getResourceSettings() .getPackageResourceGuard(); if (packageResourceGuard instanceof SecurePackageResourceGuard) { final SecurePackageResourceGuard guard = (SecurePackageResourceGuard)packageResourceGuard; for (final String pattern : patterns) { guard.addPattern(pattern); } } }\n\n    ### Response: Adds the given file patterns to package resource guard from the given application.\n\n@param application\nthe application\n@param patterns\nthe patterns.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props loadFromClasspath(final String... patterns) { ClassScanner.create() .registerEntryConsumer(entryData -> { String usedEncoding = JoddCore.encoding; if (StringUtil.endsWithIgnoreCase(entryData.name(), \".properties\")) { usedEncoding = StringPool.ISO_8859_1; } final String encoding = usedEncoding; UncheckedException.runAndWrapException(() -> load(entryData.openInputStream(), encoding)); }) .includeResources(true) .ignoreException(true) .excludeCommonJars() .excludeAllEntries(true) .includeEntries(patterns) .scanDefaultClasspath() .start(); return this; }\n\n    ### Response:", "ground_truth": "Loads props and properties from the classpath.", "predict": " Loads properties files from the classpath.\n\n@param patterns\nthe patterns to include.\n\n    "}, {"ID": 1652, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParam(@NotNull final String name, String defaultValue) { String value = getParam(name); if (value == null) { return defaultValue; } return value; }\n\n    ### Response: Allow getting parameters in a generified way and return defaultValue if the key does not exist.\n\n@param name The key to get\n@param defaultValue value returned when the key does not exist\n@return {String} The found object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; }\n\n    ### Response:", "ground_truth": "Returns value of property, using active profiles or default value if not found.", "predict": " Get the value of a key from the configuration, or return a default value if the key does not exist.\n\n@param key The key to get\n@param defaultValue The value to return if the key does not exist\n@return {String} The value of the key, or the default value if it does not exist."}, {"ID": 1653, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addAttribute(String name, final String value) { if (m_elemContext.m_startTagOpen) { final String patchedName = patchName(name); final String localName = getLocalName(patchedName); final String uri = getNamespaceURI(patchedName, false); addAttributeAlways(uri,localName, patchedName, \"CDATA\", value, false); } }\n\n    ### Response: Adds  the given attribute to the set of collected attributes,\nbut only if there is a currently open element.\n\n@param name the attribute's qualified name\n@param value the value of the attribute.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setValue(final String key, final String value, final String profile) { if (profile == null) { data.putBaseProperty(key, value, false); } else { data.putProfileProperty(key, value, profile, false); } initialized = false; }\n\n    ### Response:", "ground_truth": "Sets value on some profile.", "predict": " Sets the value of the specified property in the specified profile, or in the base profile if the profile is null.\n\n@param key the property key\n@param value the property value\n@param profile the profile name, or null for the base profile"}, {"ID": 1654, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initializeAsync(final InitializationFinishedCallback finishedCallback) { Async.go(new Runnable() { @Override public void run() { try { initialize(); finishedCallback.initializationFinished(OmemoManager.this); } catch (Exception e) { finishedCallback.initializationFailed(e); } } }); }\n\n    ### Response: Initialize the manager without blocking. Once the manager is successfully initialized, the finishedCallback will\nbe notified. It will also get notified, if an error occurs.\n\n@param finishedCallback callback that gets called once the manager is initialized..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractProps(final Map target) { initialize(); data.extract(target, activeProfiles, null, null); }\n\n    ### Response:", "ground_truth": "Extracts props belonging to active profiles.", "predict": " Extract the properties of the OMEMO manager to the given map. The properties will include the active OMEMO profiles, the\nidentity keys of the OMEMO sessions, and the prekeys for the OMEMO sessions.\n\n@param target the map to which the properties should be extracted."}, {"ID": 1655, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void modifyOrInsertProfiles(File destination, Profile... profiles) { final Map<String, Profile> modifications = new LinkedHashMap<String, Profile>(); for (Profile profile : profiles) { modifications.put(profile.getProfileName(), profile); } modifyProfiles(destination, modifications); }\n\n    ### Response: Modify or insert new profiles into an existing credentials file by\nin-place modification. Only the properties of the affected profiles will\nbe modified; all the unaffected profiles and comment lines will remain\nthe same. This method does not support renaming a profile.\n\n@param destination\nThe destination file to modify\n@param profiles\nAll the credential profiles to be written..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractProps(final Map target, final String... profiles) { initialize(); data.extract(target, profiles, null, null); }\n\n    ### Response:", "ground_truth": "Extract props of given profiles.", "predict": " Extracts the properties of the specified profiles from the credentials file and adds them to the specified map.\n\n@param target\nThe map to which the properties will be added\n@param profiles\nThe names of the profiles to extract\n\n@throws IOException\nIf an error occurs while reading the credentials file\n@throws CredentialsException\nIf an error occurs while parsing the credentials file"}, {"ID": 1656, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); addEventListener(eventSource, listenerType, listener); }\n\n    ### Response: Binds an event listener to a specific method on a specific object.\n\n@param           the event listener type\n@param target       the target object\n@param methodName   the name of the method to be called\n@param eventSource  the object which is generating events (JButton, JList, etc.)\n@param listenerType the listener interface (ActionListener.class, SelectionListener.class, etc.)\n@param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\nsupported).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractSubProps(final Map target, final String... wildcardPatterns) { initialize(); data.extract(target, activeProfiles, wildcardPatterns, null); }\n\n    ### Response:", "ground_truth": "Extracts subset of properties that matches given wildcards.", "predict": " Extracts properties from the current active profiles and adds them to the specified map.\n\n@param target           the map to which the properties will be added\n@param wildcardPatterns the wildcard patterns to match the property names (e.g. \"foo.*.bar\" will match \"foo.bar.baz\",\n\"foo.spam.bar\", etc.)\n\n    "}, {"ID": 1657, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getCachedETag(HttpHost host, String file) { Map<String, Object> cachedETags = readCachedETags(); @SuppressWarnings(\"unchecked\") Map<String, Object> hostMap = (Map<String, Object>)cachedETags.get(host.toURI()); if (hostMap == null) { return null; } @SuppressWarnings(\"unchecked\") Map<String, String> etagMap = (Map<String, String>)hostMap.get(file); if (etagMap == null) { return null; } return etagMap.get(\"ETag\"); }\n\n    ### Response: Get the cached ETag for the given host and file\n@param host the host\n@param file the file\n@return the cached ETag or null if there is no ETag in the cache.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Map<String, Object> innerMap(final String prefix) { initialize(); return data.extract(null, activeProfiles, null, prefix); }\n\n    ### Response:", "ground_truth": "Returns inner map from the props with given prefix. Keys in returned map\nwill not have the prefix.", "predict": " Get the inner map for the given prefix\n@param prefix the prefix\n@return the inner map or null if there is no inner map for the given prefix.\n\n    "}, {"ID": 1658, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String asString(Map<?, ?> map) { if (map == null) { return NULL; } StringBuilder builder = new StringBuilder(); builder.append('{'); boolean first = true; for (Map.Entry<?, ?> entry : map.entrySet()) { if (first) { first = false; } else { builder.append(','); } builder.append(asString(entry.getKey())) .append(':') .append(asString(entry.getValue())); } builder.append('}'); return builder.toString(); }\n\n    ### Response: Make a minimal printable string value from a typed map.\n\n@param map The map to stringify.\n@return The resulting string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } for (Map.Entry<?, ?> entry : map.entrySet()) { String key = entry.getKey().toString(); key = prefix + key; setValue(key, entry.getValue().toString(), profile); } }\n\n    ### Response:", "ground_truth": "Adds child map to the props on given prefix.", "predict": " Add all key-value pairs from a typed map to the configuration under a given prefix and profile.\n\n@param prefix The prefix to use for all keys.\n@param map The map to add.\n@param profile The profile to use for all values."}, {"ID": 1659, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean isProfileActive( MavenProject project, String profileName ) { @SuppressWarnings( \"unchecked\" ) List<Profile> activeProfiles = project.getActiveProfiles(); if ( activeProfiles != null && !activeProfiles.isEmpty() ) { for ( Profile profile : activeProfiles ) { if ( profile.getId().equals( profileName ) ) { return true; } } } return false; }\n\n    ### Response: Checks if profile is active.\n\n@param project the project\n@param profileName the profile name\n@return true if profile is active, otherwise false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void resolveActiveProfiles() { if (activeProfilesProp == null) { activeProfiles = null; return; } final PropsEntry pv = data.getBaseProperty(activeProfilesProp); if (pv == null) { // no active profile set as the property, exit return; } final String value = pv.getValue(); if (StringUtil.isBlank(value)) { activeProfiles = null; return; } activeProfiles = StringUtil.splitc(value, ','); StringUtil.trimAll(activeProfiles); }\n\n    ### Response:", "ground_truth": "Resolves active profiles from special property.\nThis property can be only a base property!\nIf default active property is not defined, nothing happens.\nOtherwise, it will replace currently active profiles.", "predict": " Resolves active profiles.\n\n@param data the project properties\n@param activeProfilesProp the property name for active profiles\n\n    "}, {"ID": 1660, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) { if(experimentalTechniques==null){ return new String[0]; } String[] outArray = new String[experimentalTechniques.size()]; int index = 0; for (ExperimentalTechnique experimentalTechnique : experimentalTechniques) { outArray[index] = experimentalTechnique.getName(); index++; } return outArray; }\n\n    ### Response: Converts the set of experimental techniques to an array of strings.\n@param experimentalTechniques the input set of experimental techniques\n@return the array of strings describing the methods used..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getAllProfiles() { String[] profiles = new String[data.profileProperties.size()]; int index = 0; for (String profileName : data.profileProperties.keySet()) { profiles[index] = profileName; index++; } return profiles; }\n\n    ### Response:", "ground_truth": "Returns all profiles names.", "predict": " Returns an array of all the profile names in the data object.\n@return the array of profile names."}, {"ID": 1661, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String getParameter(HttpServletRequest request, String[] aliases) { final String sourceMethod = \"getParameter\"; //$NON-NLS-1$ boolean isTraceLogging = log.isLoggable(Level.FINER); if (isTraceLogging) { log.entering(sourceClass, sourceMethod, new Object[]{request.getQueryString(), Arrays.asList(aliases)}); } Map<String, String[]> params = request.getParameterMap(); String result = null; for (Map.Entry<String, String[]> entry : params.entrySet()) { String name = entry.getKey(); for (String alias : aliases) { if (alias.equalsIgnoreCase(name)) { String[] values = entry.getValue(); result = values[values.length-1]; // return last value in array } } } if (isTraceLogging) { log.exiting(sourceClass, sourceMethod, result); } return result; }\n\n    ### Response: Returns the value of the requested parameter from the request, or null\n\n@param request\nthe request object\n@param aliases\narray of query arg names by which the request may be specified\n@return the value of the param, or null if it is not specified under the\nspecified names.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getProfilesFor(final String propKeyNameWildcard) { HashSet<String> profiles = new HashSet<>(); profile: for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) { String profileName = entries.getKey(); Map<String, PropsEntry> value = entries.getValue(); for (String propKeyName : value.keySet()) { if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) { profiles.add(profileName); continue profile; } } } return profiles.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Returns all the profiles that define certain prop's key name.\nKey name is given as a wildcard, or it can be matched fully.", "predict": " Returns an array of profile names that have properties that match the specified wildcard.\n\n@param propKeyNameWildcard\nthe wildcard pattern to match property key names\n@return an array of profile names that have properties that match the specified wildcard."}, {"ID": 1662, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PrefixedProperties createCascadingPrefixProperties(final String[] prefixes) { PrefixedProperties properties = null; for (final String aPrefix : prefixes) { if (properties == null) { properties = new PrefixedProperties(aPrefix); } else { properties = new PrefixedProperties(properties, aPrefix); } } return properties; }\n\n    ### Response: Creates the cascading prefix properties by using the given Prefixes.\n\n@param prefixes\nthe prefixes\n@return the prefixed properties.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addPropertyInjectionPoint(final PropertyInjectionPoint pip) { if (properties == null) { properties = new PropertyInjectionPoint[1]; properties[0] = pip; } else { properties = ArraysUtil.append(properties, pip); } }\n\n    ### Response:", "ground_truth": "Adds property injection point.", "predict": " Adds the property injection point to the list of property injection points.\n\n@param pip\nthe property injection point to be added."}, {"ID": 1663, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (s endpointSet) Get() (sets [][]string) { var k = uint64(0) endpoints := s.getEndpoints() for i := range s.setIndexes { for j := range s.setIndexes[i] { sets = append(sets, endpoints[k:s.setIndexes[i][j]+k]) k = s.setIndexes[i][j] + k } } return sets }\n\n    ### Response: // Get returns the sets representation of the endpoints\n// this function also intelligently decides on what will\n// be the right set size etc..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addSetInjectionPoint(final SetInjectionPoint sip) { if (sets == null) { sets = new SetInjectionPoint[1]; sets[0] = sip; } else { sets = ArraysUtil.append(sets, sip); } }\n\n    ### Response:", "ground_truth": "Adds set injection point.", "predict": " // addSetInjectionPoint adds a new set injection point to the list of sets\n// if the list is null, it creates a new array with one element\n// otherwise, it appends the new element to the existing array using ArraysUtil.append() method."}, {"ID": 1664, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Method[] getMethodList(Class<?> clazz) { Method[] methods = null; try { // getDeclaredMethods may be rejected by the security manager // but getMethods is more expensive if (!sawSecurityException) methods = clazz.getDeclaredMethods(); } catch (SecurityException e) { // If we get an exception once, give up on getDeclaredMethods sawSecurityException = true; } if (methods == null) { methods = clazz.getMethods(); } int count = 0; for (int i=0; i < methods.length; i++) { if (sawSecurityException ? methods[i].getDeclaringClass() != clazz : !Modifier.isPublic(methods[i].getModifiers())) { methods[i] = null; } else { count++; } } Method[] result = new Method[count]; int j=0; for (int i=0; i < methods.length; i++) { if (methods[i] != null) result[j++] = methods[i]; } return result; }\n\n    ### Response: Returns all public methods declared by the specified class. This excludes\ninherited methods.\n\n@param clazz the class from which to pull public declared methods\n@return the public methods declared in the specified class\n@see Class#getDeclaredMethods().\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addMethodInjectionPoint(final MethodInjectionPoint mip) { if (methods == null) { methods = new MethodInjectionPoint[1]; methods[0] = mip; } else { methods = ArraysUtil.append(methods, mip); } }\n\n    ### Response:", "ground_truth": "Adds method injection point.", "predict": " Adds a method injection point to the list of method injection points.\n\n@param mip the method injection point to add\n@see #getMethodInjectionPoints()"}, {"ID": 1665, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function self_method(data, methods) { if (!data) { return data; } var i, ii, prop; if (data.constructor === ({}).constructor) { for (prop in data) { if (_.isUndefined(data[prop])) { delete data[prop]; continue; } data[prop] = self_method(data[prop], methods); } } else if (_.isArray(data)) { for (i = 0, ii = data.length; i < ii; ++i) { if (_.isUndefined(data[i])) { --i; --ii; continue; } data[i] = self_method(data[i], methods); } } else { methods = _.extend({}, methods, { __getData: null }); _.each(methods, function(params, method) { if (!_.isFunction(data[method])) { return; } if (_.isNull(params) || _.isUndefined(params)) { params = []; } if (!_.isArray(params)) { params = [params]; } data = data[method].apply(data, params); }); } return data; }\n\n    ### Response: Process object data\n\n@param {object} data    Object data\n@param {object} methods Getter methods\n@returns {object} Processed data\n\n@this {clazz|object}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addInitMethodPoints(final InitMethodPoint[] methods) { if (initMethods == null) { initMethods = methods; } else { initMethods = ArraysUtil.join(initMethods, methods); } }\n\n    ### Response:", "ground_truth": "Adds init methods.", "predict": " Add initialization method points\n\n@param {InitMethodPoint[]} methods Initialization method points to add\n@this {AbstractModule}"}, {"ID": 1666, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function self_method(data, methods) { if (!data) { return data; } var i, ii, prop; if (data.constructor === ({}).constructor) { for (prop in data) { if (_.isUndefined(data[prop])) { delete data[prop]; continue; } data[prop] = self_method(data[prop], methods); } } else if (_.isArray(data)) { for (i = 0, ii = data.length; i < ii; ++i) { if (_.isUndefined(data[i])) { --i; --ii; continue; } data[i] = self_method(data[i], methods); } } else { methods = _.extend({}, methods, { __getData: null }); _.each(methods, function(params, method) { if (!_.isFunction(data[method])) { return; } if (_.isNull(params) || _.isUndefined(params)) { params = []; } if (!_.isArray(params)) { params = [params]; } data = data[method].apply(data, params); }); } return data; }\n\n    ### Response: Process object data\n\n@param {object} data    Object data\n@param {object} methods Getter methods\n@returns {object} Processed data\n\n@this {clazz|object}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addDestroyMethodPoints(final DestroyMethodPoint[] methods) { if (destroyMethods == null) { destroyMethods = methods; } else { destroyMethods = ArraysUtil.join(destroyMethods, methods); } }\n\n    ### Response:", "ground_truth": "Adds destroy methods.", "predict": " Add destroy method points\n\n@param {DestroyMethodPoint[]} methods Destroy method points to add\n@this {AbstractModule}"}, {"ID": 1667, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Object compareClasses(Object parameter, Class trgClass) { Class srcClass = parameter.getClass(); trgClass = primitiveToWrapperType(trgClass); try { if (parameter instanceof ObjectWrap) parameter = ((ObjectWrap) parameter).getEmbededObject(); // parameter is already ok if (srcClass == trgClass) return parameter; else if (instaceOf(srcClass, trgClass)) { return parameter; } else if (trgClass.getName().equals(\"java.lang.String\")) { return Caster.toString(parameter); } else if (trgClass.getName().equals(\"java.lang.Boolean\")) { return Caster.toBoolean(parameter); } else if (trgClass.getName().equals(\"java.lang.Byte\")) { return new Byte(Caster.toString(parameter)); } else if (trgClass.getName().equals(\"java.lang.Character\")) { String str = Caster.toString(parameter); if (str.length() == 1) return new Character(str.toCharArray()[0]); return null; } else if (trgClass.getName().equals(\"java.lang.Short\")) { return Short.valueOf((short) Caster.toIntValue(parameter)); } else if (trgClass.getName().equals(\"java.lang.Integer\")) { return Integer.valueOf(Caster.toIntValue(parameter)); } else if (trgClass.getName().equals(\"java.lang.Long\")) { return Long.valueOf((long) Caster.toDoubleValue(parameter)); } else if (trgClass.getName().equals(\"java.lang.Float\")) { return Float.valueOf((float) Caster.toDoubleValue(parameter)); } else if (trgClass.getName().equals(\"java.lang.Double\")) { return Caster.toDouble(parameter); } } catch (PageException e) { return null; } return null; }\n\n    ### Response: compare parameter with whished parameter class and convert parameter to whished type\n\n@param parameter parameter to compare\n@param trgClass whished type of the parameter\n@return converted parameter (to whished type) or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class resolveTargetClass(final Class proxy) { final String name = proxy.getName(); if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) { return proxy.getSuperclass(); } if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) { return getTargetWrapperType(proxy); } return proxy; }\n\n    ### Response:", "ground_truth": "Returns target class if proxetta applied on given class.\nIf not, returns given class as result.", "predict": " resolve the target class of a proxy or wrapper class.\n\n@param proxy the proxy or wrapper class\n@return the target class of the proxy or wrapper class."}, {"ID": 1668, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addItemToList(final Object target, final String fieldName, final Object value) { try { List list = (List) getFieldValue(target, fieldName); list.add(value); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response: Adds the item to list.\n\n@param target    the target\n@param fieldName the field name\n@param value     the value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void injectTargetIntoWrapper(final Object target, final Object wrapper) { injectTargetIntoWrapper(target, wrapper, ProxettaNames.wrapperTargetFieldName); }\n\n    ### Response:", "ground_truth": "Injects target instance into proxy using default target field name.\n@see #injectTargetIntoWrapper(Object, Object, String)", "predict": " Injects the target into the wrapper.\n\n@param target    the target\n@param wrapper   the wrapper\n@param fieldName the field name (default is ProxettaNames.wrapperTargetFieldName)"}, {"ID": 1669, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Field findField(Class<?> pClazz, String pField) { Class c = pClazz; do { try { return c.getDeclaredField(pField); } catch (NoSuchFieldException e) { c = pClazz.getSuperclass(); } } while (c != null); return null; }\n\n    ### Response: Find a field in an inheritance hierarchy.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class getTargetWrapperType(final Class wrapperClass) { try { final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName); return field.getType(); } catch (NoSuchFieldException nsfex) { throw new ProxettaException(nsfex); } }\n\n    ### Response:", "ground_truth": "Returns wrapper target type.", "predict": " Get the target class of a wrapper class.\n\n    "}, {"ID": 1670, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private FieldDescriptor getFldFromJoin(TableAlias aTableAlias, String aColName) { FieldDescriptor fld = null; // Search Join Structure for attribute if (aTableAlias.joins != null) { Iterator itr = aTableAlias.joins.iterator(); while (itr.hasNext()) { Join join = (Join) itr.next(); ClassDescriptor cld = join.right.cld; if (cld != null) { fld = cld.getFieldDescriptorByName(aColName); if (fld != null) { break; } } } } return fld; }\n\n    ### Response: Get FieldDescriptor from joined superclass..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected FieldDescriptor findField(final String fieldName) { FieldDescriptor fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } // field descriptor not found in this class // try to locate it in the superclasses Class[] superclasses = classDescriptor.getAllSuperclasses(); for (Class superclass : superclasses) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(superclass); fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } } // nothing found return null; }\n\n    ### Response:", "ground_truth": "Locates property field. Field is being searched also in all\nsuperclasses of current class.", "predict": " Find a field in the hierarchy of the class.\n\n    "}, {"ID": 1671, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized static TypeDesc forClass(Class<?> clazz) { if (clazz == null) { return null; } TypeDesc type = cClassesToInstances.get(clazz); if (type != null) { return type; } if (clazz.isArray()) { type = forClass(clazz.getComponentType()).toArrayType(); } else if (clazz.isPrimitive()) { if (clazz == int.class) { type = INT; } if (clazz == boolean.class) { type = BOOLEAN; } if (clazz == char.class) { type = CHAR; } if (clazz == byte.class) { type = BYTE; } if (clazz == long.class) { type = LONG; } if (clazz == float.class) { type = FLOAT; } if (clazz == double.class) { type = DOUBLE; } if (clazz == short.class) { type = SHORT; } if (clazz == void.class) { type = VOID; } } else { String name = clazz.getName(); type = intern(new ObjectType(generateDescriptor(name), name)); } cClassesToInstances.put(clazz, type); return type; }\n\n    ### Response: Acquire a TypeDesc from any class, including primitives and arrays..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class getType() { if (type == null) { if (fieldDescriptor != null) { type = fieldDescriptor.getRawType(); } else if (readMethodDescriptor != null) { type = getGetter(true).getGetterRawType(); //type = readMethodDescriptor.getGetterRawType(); } else if (writeMethodDescriptor != null) { type = getSetter(true).getSetterRawType(); //type = writeMethodDescriptor.getSetterRawType(); } } return type; }\n\n    ### Response:", "ground_truth": "Returns property type. Raw types are detected.", "predict": " Get the class of the field, getter, or setter."}, {"ID": 1672, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function (beanDef, beanName, packageDef) { var keyType = beanDef.$keyType; var parentKeyType = null; var parent = beanDef[jv._MD_PARENTDEF]; if (!parent[jv._MD_BUILTIN]) { parentKeyType = parent.$keyType; if (keyType == null) { beanDef.$keyType = parentKeyType; return; } } else if (keyType == null) { // keyType not specified return; } jv._preprocessBean(keyType, beanName + \".$keyType\", packageDef); if (parentKeyType != null) { __checkInheritance(parentKeyType, keyType); } // in all cases, keyType must be a sub-type of aria.core.JsonTypes.String if (keyType[jv._MD_BASETYPE].typeName != \"String\") { jv._logError(jv.INHERITANCE_EXPECTED, [keyType[jv._MD_TYPENAME], jv._BASE_TYPES_PACKAGE + \".String\"]); return; } }\n\n    ### Response: Preprocess the key type of the given bean definition\n@private\n@param {aria.core.BaseTypes:Bean} beanDef bean to be preprocessed\n@param {String} beanName fully qualified name for this bean\n@param {aria.core.BaseTypes:Package} packageDef reference package.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class resolveKeyType(final boolean declared) { Class keyType = null; Getter getter = getGetter(declared); if (getter != null) { keyType = getter.getGetterRawKeyComponentType(); } if (keyType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { keyType = fieldDescriptor.getRawKeyComponentType(); } } return keyType; }\n\n    ### Response:", "ground_truth": "Resolves key type for given property descriptor.", "predict": " Resolves the key type of the given bean definition\n@public\n@param {Boolean} declared whether to consider only declared fields or not\n@return {Class} the key type of the bean definition\n\n    "}, {"ID": 1673, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class<? extends SlingBean> getComponentType() throws ClassNotFoundException { if (componentType == null) { String type = getType(); if (StringUtils.isNotBlank(type)) { componentType = (Class<? extends SlingBean>) context.getType(type); } } return componentType; }\n\n    ### Response: get the content type class object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class resolveComponentType(final boolean declared) { Class componentType = null; Getter getter = getGetter(declared); if (getter != null) { componentType = getter.getGetterRawComponentType(); } if (componentType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { componentType = fieldDescriptor.getRawComponentType(); } } return componentType; }\n\n    ### Response:", "ground_truth": "Resolves component type for given property descriptor.", "predict": " resolve the component type of the getter or field descriptor."}, {"ID": 1674, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toJson(Object object) { Objects.requireNonNull(object, Required.OBJECT.toString()); String json = null; try { json = mapper.writeValueAsString(object); } catch (JsonProcessingException e) { LOG.error(\"Failed to convert object to json\", e); } return json; }\n\n    ### Response: Converts a given object to a Json string\n\n@param object The object to convert\n@return json string or null if conversion fails.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonResult of(final Object object) { final String json = JsonSerializer.create().deep(true).serialize(object); return new JsonResult(json); }\n\n    ### Response:", "ground_truth": "Creates JSON result from given object. The object will be serialized to JSON.", "predict": " Creates a new JsonResult object with the given object serialized to a json string.\n\n@param object The object to serialize\n@return A new JsonResult object with the serialized json string."}, {"ID": 1675, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void ajaxGetPermissions(final Project project, final HashMap<String, Object> ret) { final ArrayList<HashMap<String, Object>> permissions = new ArrayList<>(); for (final Pair<String, Permission> perm : project.getUserPermissions()) { final HashMap<String, Object> permObj = new HashMap<>(); final String userId = perm.getFirst(); permObj.put(\"username\", userId); permObj.put(\"permission\", perm.getSecond().toStringArray()); permissions.add(permObj); } ret.put(\"permissions\", permissions); }\n\n    ### Response: this only returns user permissions, but not group permissions and proxy users.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonResult of(final Exception exception) { final HashMap<String, Object> errorMap = new HashMap<>(); errorMap.put(\"message\", ExceptionUtil.message(exception)); errorMap.put(\"error\", exception.getClass().getName()); errorMap.put(\"cause\", exception.getCause() != null ? exception.getCause().getClass().getName() : null); final ArrayList<String> details = new ArrayList<>(); final StackTraceElement[] ste = ExceptionUtil.getStackTrace(exception, null, null); for (StackTraceElement stackTraceElement : ste) { details.add(stackTraceElement.toString()); } errorMap.put(\"details\", details); final String json = JsonSerializer.create().deep(true).serialize(errorMap); return new JsonResult(json).status(HttpStatus.error500().internalError()); }\n\n    ### Response:", "ground_truth": "Creates a JSON response from an exception. Response body will have information about the\nexception and response status will be set to 500.", "predict": " This method creates a JSON object with the error message, error class name, cause class name, and stack trace. It then returns a JsonResult object with the JSON string and a 500 Internal Server Error status code."}, {"ID": 1676, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int howManyGreaterThans(final String aLine) { if (aLine == null) { return -1; } int i = 0; final int len = aLine.length(); while (i < len) { if (aLine.charAt(i) == '>') { i++; } else { break; } } return i; }\n\n    ### Response: How many greater thans.\n\n@param aLine the a line\n@return the int.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveHttpMethodFromMethodName(final String methodName) { int i = 0; while (i < methodName.length()) { if (CharUtil.isUppercaseAlpha(methodName.charAt(i))) { break; } i++; } final String name = methodName.substring(0, i).toUpperCase(); for (final HttpMethod httpMethod : HttpMethod.values()) { if (httpMethod.equalsName(name)) { return httpMethod.name(); } } return null; }\n\n    ### Response:", "ground_truth": "Resolves HTTP method name from method name.\nIf method name or first camel-case word of a method equals to\na HTTP method, it will be used as that HTTP methods.", "predict": " Resolves the HTTP method from the method name.\n\n@param methodName the method name\n@return the string."}, {"ID": 1677, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isFloatNoExponent(String str) { int len = str.length(); if (len == 0) { return false; } // skip first char if sign char char c = str.charAt(0); int i = ((c == '-') || (c == '+')) ? 1 : 0; // is it only a sign? if (i >= len) { return false; } boolean decimalPointFound = false; do { c = str.charAt(i); if (c == '.') { // is this a second dot? if (decimalPointFound) { return false; } decimalPointFound = true; } else if (!Character.isDigit(c)) { return false; } i++; } while (i < len); return true; }\n\n    ### Response: Checks that the string represents a floating point number that CANNOT be\nin exponential notation\n\n@param str the string to check\n\n@return boolean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) { int pLen = pattern.length(); if (pLen == 1) { if (pattern.charAt(0) == '*') { // speed-up return true; } } int sLen = string.length(); boolean nextIsNotWildcard = false; while (true) { // check if end of string and/or pattern occurred if ((sNdx >= sLen)) { // end of string still may have pending '*' in pattern while ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) { pNdx++; } return pNdx >= pLen; } if (pNdx >= pLen) { // end of pattern, but not end of the string return false; } char p = pattern.charAt(pNdx); // pattern char // perform logic if (!nextIsNotWildcard) { if (p == '\\\\') { pNdx++; nextIsNotWildcard = true; continue; } if (p == '?') { sNdx++; pNdx++; continue; } if (p == '*') { char pNext = 0; // next pattern char if (pNdx + 1 < pLen) { pNext = pattern.charAt(pNdx + 1); } if (pNext == '*') { // double '*' have the same effect as one '*' pNdx++; continue; } int i; pNdx++; // find recursively if there is any substring from the end of the // line that matches the rest of the pattern !!! for (i = string.length(); i >= sNdx; i--) { if (match(string, pattern, i, pNdx)) { return true; } } return false; } } else { nextIsNotWildcard = false; } // check if pattern char and string char are equals if (p != string.charAt(sNdx)) { return false; } // everything matches for now, continue sNdx++; pNdx++; } }\n\n    ### Response:", "ground_truth": "Internal matching recursive function.", "predict": " Matches the string against the pattern.\n\n@param string the string to match\n@param pattern the pattern to match against\n@param sNdx starting index in the string\n@param pNdx starting index in the pattern\n\n@return boolean.\n\n    "}, {"ID": 1678, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isMonitorable(Class<?> clazz) { // Faster(?) path if (notMonitorable.contains(clazz)) { return false; } else if (monitorable.contains(clazz)) { return true; } boolean isMonitorable = true; if (!instrumentation.isModifiableClass(clazz)) { isMonitorable = false; } else if (clazz.isInterface()) { isMonitorable = false; } else if (clazz.isArray()) { isMonitorable = false; } else if (Proxy.isProxyClass(clazz)) { isMonitorable = false; } else if (clazz.isPrimitive()) { isMonitorable = false; } else if (isExcludedClass(Type.getInternalName(clazz))) { isMonitorable = false; } else if (!includeBootstrap && clazz.getClassLoader() == null) { isMonitorable = false; } // Update collections if (!isMonitorable) { synchronized (notMonitorable) { notMonitorable.add(clazz); } } else { monitorable.add(clazz); } return isMonitorable; }\n\n    ### Response: Determine of the specified class can be monitored via the probes\ninfrastructure.\n\n@param clazz the monitoring candidate\n\n@return false if the class can't be monitored.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Loading resolveLoading(final boolean parentFirstStrategy, final String className) { boolean withParent = true; boolean withLoader = true; if (parentFirstStrategy) { if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } else if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } } else { if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } else if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } } return new Loading(withParent, withLoader); }\n\n    ### Response:", "ground_truth": "Resolves loading rules.", "predict": " Determine the loading strategy for the specified class name based on the specified rules.\n\n@param parentFirstStrategy true if the parent-first strategy should be used, false otherwise\n@param className the class name to resolve the loading strategy for\n\n@return the loading strategy for the specified class name based on the specified rules\n\n    "}, {"ID": 1679, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getResourceClassName(String strBasePackage, String resourceName) { if (resourceName == null) resourceName = strBasePackage.substring(strBasePackage.lastIndexOf('.') + 1); strBasePackage = strBasePackage.substring(0, strBasePackage.lastIndexOf('.') + 1); resourceName = Utility.getFullClassName(null, strBasePackage, resourceName); resourceName = Utility.convertClassName(resourceName, Constants.RES_SUBPACKAGE); return strBasePackage; }\n\n    ### Response: Given a class name in the program package, get this resource's class name in the res package.\n@param strBasePackage A class name in the same program directory as the res class.\n@param resourceName The base resource class name.\n@return The full resource class name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Loading resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) { if (matchResourcesAsPackages) { resourceName = StringUtil.replaceChar(resourceName, '/', '.'); } return resolveLoading(parentFirstStrategy, resourceName); }\n\n    ### Response:", "ground_truth": "Resolves resources.", "predict": " Resolve the loading of a resource based on the parent-first strategy and the resource name.\n@param parentFirstStrategy Whether to load resources from parent first or child first.\n@param resourceName The name of the resource to load.\n@return The loading object for the resource."}, {"ID": 1680, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected synchronized Class loadClass(final String name, boolean resolve) throws ClassNotFoundException { Class c = this.findLoadedClass(name); if (c != null) return c; c = (Class) customClasses.get(name); if (c != null) return c; try { c = oldFindClass(name); } catch (ClassNotFoundException cnfe) { // IGNORE } if (c == null) c = super.loadClass(name, resolve); if (resolve) resolveClass(c); return c; }\n\n    ### Response: loads a class using the name of the class.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException { // check first if the class has already been loaded Class<?> c = findLoadedClass(className); if (c != null) { if (resolve) { resolveClass(c); } return c; } // class not loaded yet Loading loading = resolveLoading(parentFirst, className); if (parentFirst) { // PARENT FIRST if (loading.withParent) { try { c = parentClassLoader.loadClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withLoader) { c = this.findClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } else { // THIS FIRST if (loading.withLoader) { try { c = this.findClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withParent) { c = parentClassLoader.loadClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } if (resolve) { resolveClass(c); } return c; }\n\n    ### Response:", "ground_truth": "Loads class using parent-first or parent-last strategy.", "predict": " loads a class using the name of the class."}, {"ID": 1681, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL locateOnClasspath(String resourceName) { URL url = null; // attempt to load from the context classpath ClassLoader loader = Thread.currentThread().getContextClassLoader(); if (loader != null) { url = loader.getResource(resourceName); if (url != null) { log.debug(\"Located '{}' in the context classpath\", resourceName); } } // attempt to load from the system classpath if (url == null) { url = ClassLoader.getSystemResource(resourceName); if (url != null) { log.debug(\"Located '{}' in the system classpath\", resourceName); } } return url; }\n\n    ### Response: Tries to find a resource with the given name in the classpath.\n\n@param resourceName the name of the resource\n@return the URL to the found resource or null if the resource\ncannot be found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public URL getResource(final String resourceName) { URL url = null; Loading loading = resolveResourceLoading(parentFirst, resourceName); if (parentFirst) { // PARENT FIRST if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } if (url == null) { if (loading.withLoader) { url = this.findResource(resourceName); } } } else { // THIS FIRST if (loading.withLoader) { url = this.findResource(resourceName); } if (url == null) { if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } } } return url; }\n\n    ### Response:", "ground_truth": "Returns a resource using parent-first or parent-last strategy.", "predict": "Returns the URL to the resource with the specified name.\n\n@param resourceName the name of the resource\n@return the URL to the resource with the specified name, or null if the resource cannot be found.\n\n    "}, {"ID": 1682, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void await() { boolean intr = false; final Object lock = this.lock; try { synchronized (lock) { while (! readClosed) { try { lock.wait(); } catch (InterruptedException e) { intr = true; } } } } finally { if (intr) { Thread.currentThread().interrupt(); } } }\n\n    ### Response: Wait for the read side to close.  Used when the writer needs to know when\nthe reader finishes consuming a message..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void waitFor() { try { synchronized (lock) { if (!end) { lock.wait(); } } } catch (InterruptedException ignore) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Waits for gobbler to end.", "predict": "Wait for the end of the operation to complete.  Used when the writer needs to know when\nthe reader finishes consuming a message."}, {"ID": 1683, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Set<Annotation> getAnnotations(final Annotation[] annotations, final Class<? extends Annotation> neededAnnotationType) { final Set<Annotation> ret = new HashSet<>(); for (final Annotation annotation : annotations) { annotation.annotationType().getAnnotations(); final Annotation[] metaAnnotations = annotation.annotationType().getAnnotations(); for (final Annotation metaAnnotation : metaAnnotations) { if (metaAnnotation.annotationType().equals(neededAnnotationType)) { ret.add(annotation); } } } return ret; }\n\n    ### Response: Gets annotations match the needed annotation type from the specified annotation.\n\n@param annotations          the specified annotations\n@param neededAnnotationType the needed annotation type\n@return annotation set, returns an empty set if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) { for (final Annotation annotation : annotations) { if (annotation instanceof In) { return annotation.annotationType(); } else if (annotation instanceof Out) { return annotation.annotationType(); } } return null; }\n\n    ### Response:", "ground_truth": "Scans annotation and returns type of Madvoc annotations.", "predict": " Detects the annotation type of the specified annotations.\n\n@param annotations the specified annotations\n@return annotation type, returns null if not found."}, {"ID": 1684, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String single(final CharSequence name, final String def) throws IOException { final String value; final Iterator<String> params = this.param(name).iterator(); if (params.hasNext()) { value = params.next(); } else { value = def; } return value; }\n\n    ### Response: Get single param or default.\n@param name Name of query param\n@param def Default, if not found\n@return Value of it\n@throws IOException if something fails reading parameters.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected InjectionPoint buildInjectionPoint( final String annotationValue, final String propertyName, final Class propertyType, final Class<? extends MadvocScope> scope) { final String value = annotationValue.trim(); final String name, targetName; if (StringUtil.isNotBlank(value)) { name = value; targetName = propertyName; } else { name = propertyName; targetName = null; } return new InjectionPoint(propertyType, name, targetName, scopeResolver.defaultOrScopeType(scope)); }\n\n    ### Response:", "ground_truth": "Builds injection point.", "predict": " Build injection point.\n@param annotationValue Value of annotation\n@param propertyName Name of property\n@param propertyType Type of property\n@param scope Scope of property\n@return Injection point\n\n    "}, {"ID": 1685, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> getMutablePropertyNamesOptional( Class<?> beanClass) { List<PropertyDescriptor> propertyDescriptors = getPropertyDescriptorsOptional(beanClass); List<String> result = new ArrayList<String>(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { String propertyName = propertyDescriptor.getName(); Method readMethod = getReadMethodOptional(beanClass, propertyName); Method writeMethod = getWriteMethodOptional(beanClass, propertyName); if (readMethod != null && writeMethod != null) { result.add(propertyName); } } return Collections.unmodifiableList(result); }\n\n    ### Response: Returns an unmodifiable list of all property names of the given bean\nclass for which a read method and a write method exists. If the bean\nclass can not be introspected, an empty list will be returned.\n\n@param beanClass The bean class\n@return The property names.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit() { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); if (classMetadataName != null) { // process first 'meta' fields 'class' onProperty(classMetadataName, null, false); } PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { String propertyName = propertyDescriptor.getName(); boolean isTransient = false; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); if (fieldDescriptor != null) { isTransient = Modifier.isTransient(fieldDescriptor.getField().getModifiers()); } onProperty(propertyName, propertyDescriptor, isTransient); } } }\n\n    ### Response:", "ground_truth": "Visits a type.", "predict": " Visits all properties of the given type and calls the given visitor for each property.\n\n@param type The type to visit\n@param visitor The visitor to call for each property\n@param declared Whether to visit declared properties only or also inherited properties\n@param classMetadataName The name of the class metadata property to include in the output (optional)"}, {"ID": 1686, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassLoader getDefaultClassLoader(Class<?> clazz) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (classLoader == null) { classLoader = clazz.getClassLoader(); } return classLoader; }\n\n    ### Response: Determines the 'default' classloader. That is context class loader, if\ndefined, or else classloader which loaded the given class.\n\n@param clazz\t\tto which classloader to fall back\n@return classloader.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { final URLClassLoader urlClassLoader = (URLClassLoader) classLoader; return urlClassLoader.getURLs(); } final URL url = classModuleUrl(classLoader, clazz); if (url != null) { urls.add(url); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); }\n\n    ### Response:", "ground_truth": "Returns urls for the classloader\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": " Returns the URLs of the classloader. If the classloader is a URLClassLoader, it returns the URLs of that classloader. Otherwise, it tries to find the URL of the classloader by calling classModuleUrl method. If the URL is found, it adds it to the set of URLs. Finally, it returns the set of URLs as an array.\n\n@param classLoader\tto get URLs from\n@param clazz\t\t\tto which classloader to fall back\n@return array of URLs."}, {"ID": 1687, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"WeakerAccess\", \"unused\", \"unchecked\"}) @Internal @UsedByGeneratedCode protected Object postConstruct(BeanResolutionContext resolutionContext, BeanContext context, Object bean) { DefaultBeanContext defaultContext = (DefaultBeanContext) context; Collection<BeanRegistration<BeanInitializedEventListener>> beanInitializedEventListeners = ((DefaultBeanContext) context).beanInitializedEventListeners; if (CollectionUtils.isNotEmpty(beanInitializedEventListeners)) { for (BeanRegistration<BeanInitializedEventListener> registration : beanInitializedEventListeners) { BeanDefinition<BeanInitializedEventListener> definition = registration.getBeanDefinition(); List<Argument<?>> typeArguments = definition.getTypeArguments(BeanInitializedEventListener.class); if (CollectionUtils.isEmpty(typeArguments) || typeArguments.get(0).getType().isAssignableFrom(getBeanType())) { BeanInitializedEventListener listener = registration.getBean(); bean = listener.onInitialized(new BeanInitializingEvent(context, this, bean)); if (bean == null) { throw new BeanInstantiationException(resolutionContext, \"Listener [\" + listener + \"] returned null from onInitialized event\"); } } } } for (int i = 0; i < methodInjectionPoints.size(); i++) { MethodInjectionPoint methodInjectionPoint = methodInjectionPoints.get(i); if (methodInjectionPoint.isPostConstructMethod() && methodInjectionPoint.requiresReflection()) { injectBeanMethod(resolutionContext, defaultContext, i, bean); } } if (bean instanceof LifeCycle) { bean = ((LifeCycle) bean).start(); } return bean; }\n\n    ### Response: Default postConstruct hook that only invokes methods that require reflection. Generated subclasses should\noverride to call methods that don't require reflection.\n\n@param resolutionContext The resolution hook\n@param context           The context\n@param bean              The bean\n@return The bean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setBean(final Object bean) { this.bean = bean; this.cd = (bean == null ? null : introspector.lookup(bean.getClass())); this.first = false; this.updateProperty = true; }\n\n    ### Response:", "ground_truth": "Sets new bean instance.", "predict": "Sets the bean and updates the introspector and property update flags.\n\n@param bean The bean to set."}, {"ID": 1688, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void merge(final Object from, final Object target, final NullHandlingPolicy nullPolicy) { if (from == null || target == null) { return; } final BeanWrapper fromWrapper = beanWrapper(from); final BeanWrapper targetWrapper = beanWrapper(target); final DomainTypeAdministrationConfiguration domainTypeAdministrationConfiguration = configuration.forManagedDomainType(target.getClass()); final PersistentEntity<?, ?> entity = domainTypeAdministrationConfiguration.getPersistentEntity(); entity.doWithProperties(new SimplePropertyHandler() { @Override public void doWithPersistentProperty(PersistentProperty<?> persistentProperty) { Object sourceValue = fromWrapper.getPropertyValue(persistentProperty.getName()); Object targetValue = targetWrapper.getPropertyValue(persistentProperty.getName()); if (entity.isIdProperty(persistentProperty)) { return; } if (nullSafeEquals(sourceValue, targetValue)) { return; } if (propertyIsHiddenInFormView(persistentProperty, domainTypeAdministrationConfiguration)) { return; } if (nullPolicy == APPLY_NULLS || sourceValue != null) { targetWrapper.setPropertyValue(persistentProperty.getName(), sourceValue); } } }); entity.doWithAssociations(new SimpleAssociationHandler() { @Override @SuppressWarnings(\"unchecked\") public void doWithAssociation(Association<? extends PersistentProperty<?>> association) { PersistentProperty<?> persistentProperty = association.getInverse(); Object fromValue = fromWrapper.getPropertyValue(persistentProperty.getName()); Object targetValue = targetWrapper.getPropertyValue(persistentProperty.getName()); if (propertyIsHiddenInFormView(persistentProperty, domainTypeAdministrationConfiguration)) { return; } if ((fromValue == null && nullPolicy == APPLY_NULLS)) { targetWrapper.setPropertyValue(persistentProperty.getName(), fromValue); } if (persistentProperty.isCollectionLike()) { Collection<Object> sourceCollection = (Collection) fromValue; Collection<Object> targetCollection = (Collection) targetValue; Collection<Object> candidatesForAddition = candidatesForAddition(sourceCollection, targetCollection, persistentProperty); Collection<Object> candidatesForRemoval = candidatesForRemoval(sourceCollection, targetCollection, persistentProperty); removeReferencedItems(targetCollection, candidatesForRemoval); addReferencedItems(targetCollection, candidatesForAddition); return; } if (!nullSafeEquals(fromValue, targetWrapper.getPropertyValue(persistentProperty.getName()))) { targetWrapper.setPropertyValue(persistentProperty.getName(), fromValue); } } }); }\n\n    ### Response: Merges the given target object into the source one.\n\n@param from       can be {@literal null}.\n@param target     can be {@literal null}.\n@param nullPolicy how to handle {@literal null} values in the source object..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateBean(final Object bean) { this.setBean(bean); if (this.cd != null && this.cd.isSupplier()) { final Object newBean = ((Supplier)this.bean).get(); setBean(newBean); } }\n\n    ### Response:", "ground_truth": "Updates the bean. Detects special case of suppliers.", "predict": "Updates the bean with the given object.\n\n@param bean the object to update the bean with."}, {"ID": 1689, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static PropertyDescriptor getPropertyDescriptor( final Class<?> type, final String propertyName ) { Exceptions.requireNonNull(type); Exceptions.requireNonNull(propertyName); if ( !propertyName.contains( \".\" ) ) { return doGetPropertyDescriptor( type, propertyName ); } else { String[] propertyNames = propertyName.split( \"[.]\" ); Class<?> clazz = type; PropertyDescriptor propertyDescriptor = null; for ( String pName : propertyNames ) { propertyDescriptor = doGetPropertyDescriptor( clazz, pName ); if ( propertyDescriptor == null ) { return null; } clazz = propertyDescriptor.getPropertyType(); } return propertyDescriptor; } }\n\n    ### Response: This needs refactor and put into Refleciton..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void loadPropertyDescriptor() { if (updateProperty) { if (cd == null) { propertyDescriptor = null; } else { propertyDescriptor = cd.getPropertyDescriptor(name, true); } updateProperty = false; } }\n\n    ### Response:", "ground_truth": "Loads property descriptor, if property was updated.", "predict": " This method is responsible for loading the property descriptor for a given property name. It first checks if the property descriptor needs to be updated. If it does, it checks if the class descriptor is null. If it is, it sets the property descriptor to null. Otherwise, it uses the class descriptor to get the property descriptor for the given property name. Finally, it sets the updateProperty flag to false to indicate that the property descriptor is no longer in need of an update."}, {"ID": 1690, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static PropertyDescriptor getPropertyDescriptor( final Class<?> type, final String propertyName ) { Exceptions.requireNonNull(type); Exceptions.requireNonNull(propertyName); if ( !propertyName.contains( \".\" ) ) { return doGetPropertyDescriptor( type, propertyName ); } else { String[] propertyNames = propertyName.split( \"[.]\" ); Class<?> clazz = type; PropertyDescriptor propertyDescriptor = null; for ( String pName : propertyNames ) { propertyDescriptor = doGetPropertyDescriptor( clazz, pName ); if ( propertyDescriptor == null ) { return null; } clazz = propertyDescriptor.getPropertyType(); } return propertyDescriptor; } }\n\n    ### Response: This needs refactor and put into Refleciton..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; }\n\n    ### Response:", "ground_truth": "Returns getter.", "predict": " This method is used to get the getter method of the property. It first checks if the property descriptor is loaded or not. If it is loaded, it returns the getter method of the property. If it is not loaded, it loads the property descriptor and then returns the getter method of the property."}, {"ID": 1691, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static PropertyDescriptor getPropertyDescriptor( final Class<?> type, final String propertyName ) { Exceptions.requireNonNull(type); Exceptions.requireNonNull(propertyName); if ( !propertyName.contains( \".\" ) ) { return doGetPropertyDescriptor( type, propertyName ); } else { String[] propertyNames = propertyName.split( \"[.]\" ); Class<?> clazz = type; PropertyDescriptor propertyDescriptor = null; for ( String pName : propertyNames ) { propertyDescriptor = doGetPropertyDescriptor( clazz, pName ); if ( propertyDescriptor == null ) { return null; } clazz = propertyDescriptor.getPropertyType(); } return propertyDescriptor; } }\n\n    ### Response: This needs refactor and put into Refleciton..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Setter getSetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getSetter(declared) : null; }\n\n    ### Response:", "ground_truth": "Returns setter.", "predict": " This method is used to get the setter method for the property of the class. It first checks if the property descriptor is already loaded or not. If not loaded, it loads the property descriptor using the loadPropertyDescriptor() method. Then it returns the setter method for the property of the class. If the property descriptor is null, it returns null."}, {"ID": 1692, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function connect() { if ($this->connection) { $this->countConnections++; return false; } $connection = $this->implementation->connect($this->params, $errorInfo, $errorCode); if (!$connection) { throw new Connect($errorInfo, $errorCode); } $this->connection = $connection; $this->countConnections = 1; return true; }\n\n    ### Response: The connection requirement\n\n@return bool\nTRUE if connection has been established in this time\n@throws \\go\\DB\\Exceptions\\Connect\na connect error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbOom connect() { connectionProvider.init(); final DbDetector dbDetector = new DbDetector(); dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig); return this; }\n\n    ### Response:", "ground_truth": "Initializes the DbOom by connecting to the database. Database will be detected\nand DbOom will be configured to match it.", "predict": " The connect method initializes the connection provider and detects the database type and configures the DbOom accordingly.\n\n@return DbOom\nthe configured DbOom instance\n@throws DbOomException\nif the database type cannot be detected or configured correctly."}, {"ID": 1693, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final String metricsName, final MetricsBase theMetricsObj) { if (metricsList.putIfAbsent(metricsName, theMetricsObj) != null) { throw new IllegalArgumentException(\"Duplicate metricsName:\" + metricsName); } }\n\n    ### Response: Add a new metrics to the registry\n@param metricsName - the name\n@param theMetricsObj - the metrics\n@throws IllegalArgumentException if a name is already registered.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Iterator<T> iterator) { if (allIterators.contains(iterator)) { throw new IllegalArgumentException(\"Duplicate iterator\"); } allIterators.add(iterator); }\n\n    ### Response:", "ground_truth": "Adds an iterator to this composite.", "predict": " Add an iterator to the registry\n@param iterator - the iterator to add\n@throws IllegalArgumentException if the iterator is already registered."}, {"ID": 1694, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> RPromise<T> deferredPromise () { return new RPromise<T>() { @Override public void succeed (final T value) { invokeLater(new Runnable() { public void run () { superSucceed(value); } }); } @Override public void fail (final Throwable cause) { invokeLater(new Runnable() { public void run () { superFail(cause); } }); } private void superSucceed (T value) { super.succeed(value); } private void superFail (Throwable cause) { super.fail(cause); } }; }\n\n    ### Response: Creates a promise which defers notification of success or failure to the game thread,\nregardless of what thread on which it is completed. Note that even if it is completed on the\ngame thread, it will still defer completion until the next frame..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void printLogo() { System.out.println(Chalk256.chalk().yellow().on(Jodd.JODD)); }\n\n    ### Response:", "ground_truth": "Prints a logo.", "predict": " Prints the Jodd logo in yellow using the Chalk library."}, {"ID": 1695, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeRemoteResources() { if (reader != null) { try { reader.close(); } catch (final IOException ignore) { } reader = null; } if (writer != null) { writer.close(); writer = null; } if (socketOutstream != null) { try { socketOutstream.close(); } catch (final IOException ignore) { } socketOutstream = null; } if (socketInstream != null) { try { socketInstream.close(); } catch (final IOException ignore) { } socketInstream = null; } if (socket != null) { try { socket.close(); } catch (final IOException ignore) { } socket = null; } }\n\n    ### Response: Safely close remote resources.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop() { joyProps.stop(); try { joyDb.stop(); joyPetite.stop(); } catch (Exception ignore) { } if (log != null) { log.info(\"Joy is down. Bye, bye!\"); } }\n\n    ### Response:", "ground_truth": "Stops the Joy.", "predict": "Stop the Joy application.\n\n    "}, {"ID": 1696, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException { if (params == null) { throw new IllegalArgumentException(\"Parameters may not be null\"); } int timeout = params.getConnectionTimeout(); if (timeout == 0) { InetAddress hostAddress = getCachedMisconfiguredHost(host, port); if (hostAddress != null) { return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } try { SSLSocket sslSocket = (SSLSocket) clientSSLSockFactory.createSocket(host, port, localAddress, localPort); sslSocket.startHandshake(); return sslSocket; } catch (SSLException e) { if (!e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)) { throw e; } hostAddress = InetAddress.getByName(host); cacheMisconfiguredHost(host, port, hostAddress); return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } } Socket socket = clientSSLSockFactory.createSocket(); SocketAddress localAddr = new InetSocketAddress(localAddress, localPort); socket.bind(localAddr); SocketAddress remoteAddr = new InetSocketAddress(host, port); socket.connect(remoteAddr, timeout); return socket; }\n\n    ### Response: Attempts to get a new socket connection to the given host within the\ngiven time limit.\n\n@param host\nthe host name/IP\n@param port\nthe port on the host\n@param localAddress\nthe local host name/IP to bind the socket to\n@param localPort\nthe port on the local machine\n@param params\n{@link HttpConnectionParams Http connection parameters}\n\n@return Socket a new socket\n\n@throws IOException\nif an I/O error occurs while creating the socket\n@throws UnknownHostException\nif the IP address of the host cannot be determined\n@throws \tConnectTimeoutException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Socket createSocket(final String host, final int port, final int connectionTimeout) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, false, false, connectionTimeout); if (connectionTimeout < 0) { return socketFactory.createSocket(host, port); } else { // creates unconnected socket Socket socket = socketFactory.createSocket(); socket.connect(new InetSocketAddress(host, port), connectionTimeout); return socket; } }\n\n    ### Response:", "ground_truth": "Creates a socket using socket factory.", "predict": "Attempts to create a new socket connection to the given host within the given time limit.\n\n@param host\nthe host name/IP\n@param port\nthe port on the host\n@param connectionTimeout\nthe connection timeout in milliseconds\n\n@return Socket a new socket\n\n@throws IOException\nif an I/O error occurs while creating the socket\n\n    "}, {"ID": 1697, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException { if (params == null) { throw new IllegalArgumentException(\"Parameters may not be null\"); } int timeout = params.getConnectionTimeout(); if (timeout == 0) { InetAddress hostAddress = getCachedMisconfiguredHost(host, port); if (hostAddress != null) { return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } try { SSLSocket sslSocket = (SSLSocket) clientSSLSockFactory.createSocket(host, port, localAddress, localPort); sslSocket.startHandshake(); return sslSocket; } catch (SSLException e) { if (!e.getMessage().contains(CONTENTS_UNRECOGNIZED_NAME_EXCEPTION)) { throw e; } hostAddress = InetAddress.getByName(host); cacheMisconfiguredHost(host, port, hostAddress); return clientSSLSockFactory.createSocket(hostAddress, port, localAddress, localPort); } } Socket socket = clientSSLSockFactory.createSocket(); SocketAddress localAddr = new InetSocketAddress(localAddress, localPort); socket.bind(localAddr); SocketAddress remoteAddr = new InetSocketAddress(host, port); socket.connect(remoteAddr, timeout); return socket; }\n\n    ### Response: Attempts to get a new socket connection to the given host within the\ngiven time limit.\n\n@param host\nthe host name/IP\n@param port\nthe port on the host\n@param localAddress\nthe local host name/IP to bind the socket to\n@param localPort\nthe port on the local machine\n@param params\n{@link HttpConnectionParams Http connection parameters}\n\n@return Socket a new socket\n\n@throws IOException\nif an I/O error occurs while creating the socket\n@throws UnknownHostException\nif the IP address of the host cannot be determined\n@throws \tConnectTimeoutException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SSLSocket createSSLSocket( final String host, final int port, final int connectionTimeout, final boolean trustAll, final boolean verifyHttpsHost) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll, connectionTimeout); final Socket socket; if (connectionTimeout < 0) { socket = socketFactory.createSocket(host, port); } else { // creates unconnected socket // unfortunately, this does not work always // sslSocket = (SSLSocket) socketFactory.createSocket(); // sslSocket.connect(new InetSocketAddress(host, port), connectionTimeout); // // Note: SSLSocketFactory has several create() methods. // Those that take arguments all connect immediately // and have no options for specifying a connection timeout. // // So, we have to create a socket and connect it (with a // connection timeout), then have the SSLSocketFactory wrap // the already-connected socket. // socket = Sockets.connect(host, port, connectionTimeout); //sock.setSoTimeout(readTimeout); //socket.connect(new InetSocketAddress(host, port), connectionTimeout); // continue to wrap this plain socket with ssl socket... } // wrap plain socket in an SSL socket SSLSocket sslSocket; if (socket instanceof SSLSocket) { sslSocket = (SSLSocket) socket; } else { if (socketFactory instanceof SSLSocketFactory) { sslSocket = (SSLSocket) ((SSLSocketFactory)socketFactory).createSocket(socket, host, port, true); } else { sslSocket = (SSLSocket) (getDefaultSSLSocketFactory(trustAll)).createSocket(socket, host, port, true); } } // sslSocket is now ready if (secureEnabledProtocols != null) { final String[] values = StringUtil.splitc(secureEnabledProtocols, ','); StringUtil.trimAll(values); sslSocket.setEnabledProtocols(values); } // set SSL parameters to allow host name verifier if (verifyHttpsHost) { final SSLParameters sslParams = new SSLParameters(); sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\"); sslSocket.setSSLParameters(sslParams); } return sslSocket; }\n\n    ### Response:", "ground_truth": "Creates a SSL socket. Enables default secure enabled protocols if specified.", "predict": "Attempts to create a new SSL socket connection to the given host within the given time limit.\n\n@param host\nthe host name/IP\n@param port\nthe port on the host\n@param connectionTimeout\nthe connection timeout in milliseconds\n@param trustAll\nwhether to trust all SSL certificates\n@param verifyHttpsHost\nwhether to verify the host name in the SSL certificate\n\n@return SSLSocket a new SSL socket\n\n@throws IOException\nif an I/O error occurs while creating the socket\n@throws SSLHandshakeException\nif the SSL handshake fails\n@throws SSLPeerUnverifiedException\nif the SSL certificate cannot be verified\n\n    "}, {"ID": 1698, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SSLSocketFactory createSslSocketFactory() { try { SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, new TrustManager[]{this}, null); return sslContext.getSocketFactory(); } catch (NoSuchAlgorithmException | KeyManagementException e) { throw new AssertionError(e); } }\n\n    ### Response: Creates a new SSL socket factory that generates SSL sockets that trust all certificates unconditionally.\n\n@return A new SSL socket factory that generates SSL sockets that trust all certificates unconditionally..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SSLSocketFactory getDefaultSSLSocketFactory(final boolean trustAllCertificates) throws IOException { if (trustAllCertificates) { try { SSLContext sc = SSLContext.getInstance(sslProtocol); sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom()); return sc.getSocketFactory(); } catch (NoSuchAlgorithmException | KeyManagementException e) { throw new IOException(e); } } else { return (SSLSocketFactory) SSLSocketFactory.getDefault(); } }\n\n    ### Response:", "ground_truth": "Returns default SSL socket factory allowing setting trust managers.", "predict": " Returns the default SSL socket factory for the current JVM.\n\n@param trustAllCertificates If true, the SSL socket factory will trust all certificates unconditionally.\n@return The default SSL socket factory for the current JVM.\n@throws IOException If an error occurs while creating the SSL socket factory."}, {"ID": 1699, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final boolean isValidEndTypeForPattern() { if (getEndType() == null) { return false; } switch (getPatternType()) { case DAILY: case WEEKLY: case MONTHLY: case YEARLY: return (getEndType().equals(EndType.DATE) || getEndType().equals(EndType.TIMES)); case INDIVIDUAL: case NONE: return getEndType().equals(EndType.SINGLE); default: return false; } }\n\n    ### Response: Checks, if the end type is valid for the set pattern type.\n@return a flag, indicating if the end type is valid for the pattern type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SocketFactory getSocketFactory( final ProxyInfo proxy, final boolean ssl, final boolean trustAllCertificates, final int connectionTimeout) throws IOException { switch (proxy.getProxyType()) { case NONE: if (ssl) { return getDefaultSSLSocketFactory(trustAllCertificates); } else { return SocketFactory.getDefault(); } case HTTP: return new HTTPProxySocketFactory(proxy, connectionTimeout); case SOCKS4: return new Socks4ProxySocketFactory(proxy, connectionTimeout); case SOCKS5: return new Socks5ProxySocketFactory(proxy, connectionTimeout); default: return null; } }\n\n    ### Response:", "ground_truth": "Returns socket factory based on proxy type and SSL requirements.", "predict": " Returns a SocketFactory based on the given proxy information, SSL flag, trustAllCertificates flag and connection timeout.\n@param proxy the proxy information to use for creating the SocketFactory\n@param ssl a flag indicating if SSL should be used\n@param trustAllCertificates a flag indicating if all certificates should be trusted\n@param connectionTimeout the connection timeout to use for the SocketFactory\n@return a SocketFactory based on the given proxy information, SSL flag, trustAllCertificates flag and connection timeout.\n\n    "}, {"ID": 1700, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) { if (count == cached.length()) { int i = start; int j = 0; while (count-- != 0) { if (charBuf[i++] != cached.charAt(j++)) return false; } return true; } return false; }\n\n    ### Response: Check if the value of the provided range equals the string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String random(int count, final char[] chars) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; while (count-- > 0) { result[count] = chars[rnd.nextInt(chars.length)]; } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the set of characters specified.", "predict": " Generate a random string of the given length using the provided character set."}, {"ID": 1701, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) { if (count == cached.length()) { int i = start; int j = 0; while (count-- != 0) { if (charBuf[i++] != cached.charAt(j++)) return false; } return true; } return false; }\n\n    ### Response: Check if the value of the provided range equals the string..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String random(int count, final char start, final char end) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; final int len = end - start + 1; while (count-- > 0) { result[count] = (char) (rnd.nextInt(len) + start); } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the provided range.", "predict": " Generate a random string of the specified length, consisting of characters within the specified range."}, {"ID": 1702, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] tokenize(String text) { final int len = text.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } final List<String> list = new ArrayList<>(); int i = 0; while (i < len) { char ch = text.charAt(i); int ch32 = text.codePointAt(i); if (isSymbolChar(ch32)) { list.add(new String(Character.toChars(ch32))); i += Character.isHighSurrogate(ch) ? 2 : 1; continue; } if (isWordChar(ch)) { int wordStart = i; while (i < len && isWordChar(text.codePointAt(i))) { i++; } list.add(text.substring(wordStart, i)); continue; } i++; } return list.toArray(new String[list.size()]); }\n\n    ### Response: Tokenizes a string by splitting on non-word characters. This should be equivalent to splitting on \\W+ in Python.\nThe meaning of \\W is different in Android, Java 7, Java 8 hence the non-use of regular expressions.\n@param text the input text\n@return the string tokens.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String randomRanges(int count, final char... ranges) { if (count == 0) { return StringPool.EMPTY; } int i = 0; int len = 0; final int[] lens = new int[ranges.length]; while (i < ranges.length) { int gap = ranges[i + 1] - ranges[i] + 1; len += gap; lens[i] = len; i += 2; } final char[] result = new char[count]; while (count-- > 0) { char c = 0; int r = rnd.nextInt(len); for (i = 0; i < ranges.length; i += 2) { if (r < lens[i]) { r += ranges[i]; if (i != 0) { r -= lens[i - 2]; } c = (char) r; break; } } result[count] = c; } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the multiple sets defined by range pairs.\nAll ranges must be in acceding order.", "predict": " Generates a random string of characters from the given ranges. The ranges are specified as a sequence of characters, where each pair of characters represents a range of characters. For example, if the ranges are 'a' to 'z' and '0' to '9', then the resulting string will contain only lowercase letters and digits.\n@param count the number of characters to generate\n@param ranges the character ranges to choose from\n@return the random string\n\n    "}, {"ID": 1703, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, Class<T> targetType, boolean required) throws WebApplicationException { String value = get(key); if (value == null) { if (required) { throw new BadRequestException(\"Missing parameter: \" + key); } Object result = null; if (targetType.isPrimitive()) { if (targetType == boolean.class) { result = Boolean.FALSE; } else if (targetType == int.class) { result = Integer.valueOf(0); } else if (targetType == long.class) { result = Long.valueOf(0); } else if (targetType == double.class) { result = Double.valueOf(0); } else if (targetType == float.class) { result = Float.valueOf(0); } else if (targetType == byte.class) { result = Byte.valueOf((byte) 0); } else if (targetType == short.class) { result = Short.valueOf((short) 0); } else if (targetType == char.class) { result = '\\0'; } } return (T) result; } try { return convertValue(value, targetType); } catch (WebApplicationException e) { throw e; } catch (Exception e) { throw new BadRequestException(\"Failed to convert '\" + value + \"' to type \" + targetType); } }\n\n    ### Response: Gets the single parameter in a generic and flexible way.\n\n@param  is the generic type of targetType.\n@param key is the {@link java.util.Map#get(Object) key} of the parameter to get.\n@param targetType is the {@link Class} reflecting the type to convert the value to. Supports common Java standard\ntypes such as {@link String}, {@link Long}, {@link Double}, {@link BigDecimal}, etc.\n@param required - {@code true} if the value is required and a {@link BadRequestException} is thrown if it is not\npresent, {@code false} otherwise (if optional).\n@return the value for the given key converted to the given targetType. May be\n{@code null} if required is {@code false} .\n@throws WebApplicationException if an error occurred. E.g. {@link BadRequestException} if a required parameter is\nmissing or {@link InternalServerErrorException} if the given targetType is not supported..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Collection<Object> newArrayInstance(final Class targetType) { if (targetType == null || targetType == List.class || targetType == Collection.class || targetType.isArray()) { return listSupplier.get(); } if (targetType == Set.class) { return new HashSet<>(); } try { return (Collection<Object>) targetType.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new JsonException(e); } }\n\n    ### Response:", "ground_truth": "Creates new type for JSON array objects.\nIt returns a collection.\nLater, the collection will be converted into the target type.", "predict": " Creates a new instance of the given targetType.\n\n@param targetType is the {@link Class} reflecting the type to create a new instance of. Supports common Java standard\ntypes such as {@link List}, {@link Set}, {@link Collection}, etc.\n@return a new instance of the given targetType.\n@throws JsonException if an error occurred. E.g. if the given targetType is not supported or if the constructor of the\ntargetType throws an exception."}, {"ID": 1704, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void convertAndAdd(final CommonProfile profile, final AttributeLocation attributeLocation, final String name, final Object value) { if (value != null) { final Object convertedValue; final AttributeConverter<? extends Object> converter = this.converters.get(name); if (converter != null) { convertedValue = converter.convert(value); if (convertedValue != null) { logger.debug(\"converted to => key: {} / value: {} / {}\", name, convertedValue, convertedValue.getClass()); } } else { convertedValue = value; logger.debug(\"no conversion => key: {} / value: {} / {}\", name, convertedValue, convertedValue.getClass()); } if (attributeLocation.equals(AUTHENTICATION_ATTRIBUTE)) { profile.addAuthenticationAttribute(name, convertedValue); } else { profile.addAttribute(name, convertedValue); } } }\n\n    ### Response: Convert a profile or authentication attribute, if necessary, and add it to the profile.\n\n@param profile The profile.\n@param attributeLocation Location of the attribute inside the profile: classic profile attribute, authentication attribute, ...\n@param name The attribute name.\n@param value The attribute value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) { Object convertedValue = value; if (value != null) { Class targetClass = pd.getType(); convertedValue = convertType(value, targetClass); } try { Setter setter = pd.getSetter(true); if (setter != null) { setter.invokeSetter(target, convertedValue); } } catch (Exception ex) { throw new JsonException(ex); } }\n\n    ### Response:", "ground_truth": "Injects value into the targets property.", "predict": " Inject a value into an object property, converting it to the target property type if necessary.\n\n@param target The object to inject the value into.\n@param pd The property descriptor for the target property.\n@param value The value to inject.\n\n    "}, {"ID": 1705, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class getValueClass() { if (valueClass == null) { if (valueClassName != null) { try { valueClass = Class.forName(valueClassName); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } } return valueClass; }\n\n    ### Response: Get java class object for the parameter value\n\n@return java class object for the parameter value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object convertType(final Object value, final Class targetType) { final Class valueClass = value.getClass(); if (valueClass == targetType) { return value; } try { return TypeConverterManager.get().convertType(value, targetType); } catch (Exception ex) { if (!strictTypes) { return null; } throw new JsonException(\"Type conversion failed\", ex); } }\n\n    ### Response:", "ground_truth": "Converts type of the given value.", "predict": " Convert the given value to the target type.\n\n@param value the value to be converted\n@param targetType the target type to which the value should be converted\n@return the converted value\n@throws JsonException if the conversion fails and strictTypes is true"}, {"ID": 1706, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitExport(String packaze, int access, String... modules) { if (mv != null) { mv.visitExport(packaze, access, modules); } }\n\n    ### Response: Visit an exported package of the current module.\n\n@param packaze the qualified name of the exported package.\n@param access the access flag of the exported package,\nvalid values are among {@code ACC_SYNTHETIC} and\n{@code ACC_MANDATED}.\n@param modules the qualified names of the modules that can access to\nthe public classes of the exported package or\nnull..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitProvide(final String service, final String... providers) { if (mv != null) { mv.visitProvide(service, providers); } }\n\n    ### Response:", "ground_truth": "Visit an implementation of a service.\n\n@param service the internal name of the service.\n@param providers the internal names of the implementations of the service (there is at least\none provider).", "predict": " Visit a provider of a service.\n\n@param service the qualified name of the service provided.\n@param providers the qualified names of the providers of the service\nor null."}, {"ID": 1707, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <A> A[] toArray(Class<A> elementClass) { return stream().toArray(size -> (A[])Array.newInstance(elementClass, size)); }\n\n    ### Response: Returns an array containing all the stream elements using the supplied\nelement type class to allocate an array.\n\n\nThis is a terminal\noperation.\n\n@param  the element type of the resulting array\n@param elementClass the type of array elements\n@return an array containing the elements in this stream\n@throws ArrayStoreException if the runtime type of the array returned\nfrom the array generator is not a supertype of the runtime type\nof every element in this stream\n@see #toArray(java.util.function.IntFunction)\n@since 0.6.3.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); }\n\n    ### Response:", "ground_truth": "Creates default implementation of the type cache.", "predict": " Creates a new instance of the default implementation of the TypeCache interface.\n\n@param <A> the type of elements in the cache\n@return a new instance of the default implementation of the TypeCache interface\n@since 0.6.3.\n\n    "}, {"ID": 1708, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T put(final Class<T> type, final Consumer<HttpConfig> configuration) { return type.cast(interceptors.get(HttpVerb.PUT).apply(configureRequest(type, HttpVerb.PUT, configuration), this::doPut)); }\n\n    ### Response: Executes a PUT request on the configured URI, with additional configuration provided by the configuration function. The result will be cast to\nthe specified `type`.\n\nThis method is generally used for Java-specific configuration.\n\n[source,groovy]\n----\nHttpBuilder http = HttpBuilder.configure(config -> {\nconfig.getRequest().setUri(\"http://localhost:10101\");\n});\nString result = http.get(String.class, config -> {\nconfig.getRequest().getUri().setPath(\"/foo\");\n});\n----\n\nThe `configuration` {@link Consumer} allows additional configuration for this request based on the {@link HttpConfig} interface.\n\n@param type the type of the response content\n@param configuration the additional configuration function (delegated to {@link HttpConfig})\n@return the resulting content cast to the specified type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T put(final Class<?> type, final T value) { return map.put(type, value); }\n\n    ### Response:", "ground_truth": "Add values to the map.", "predict": " Adds the specified value to the map, associated with the specified type.\n\nThis method is generally used for Java-specific configuration.\n\n[source,groovy]\n----\nMap<Class<?>, Object> map = new HashMap<>();\nmap.put(String.class, \"Hello, World!\");\nString result = (String) map.get(String.class);\n----\n\nThe `value` parameter is the value to be added to the map, and the `type` parameter specifies the key for the value.\n\n@param type the type of the value to be added\n@param value the value to be added to the map\n@return the previous value associated with the specified type, or null if there was no mapping for the type\n"}, {"ID": 1709, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodDescriptor[] getTeaContextMethodDescriptors( Class<?> contextClass, boolean specifiedClassOnly) { Vector<MethodDescriptor> v = new Vector<MethodDescriptor>(); MethodDescriptor[] methodDescriptors = null; try { BeanInfo beanInfo = getBeanInfo(contextClass); methodDescriptors = beanInfo.getMethodDescriptors(); } catch (Throwable e) { e.printStackTrace(); } if (methodDescriptors != null) { Method[] methods = contextClass.getMethods(); if (methods.length > methodDescriptors.length) { methodDescriptors = addMissingContextMethodDescriptors( methods, methodDescriptors); } for (int i = 0; i < methodDescriptors.length; i++) { MethodDescriptor md = methodDescriptors[i]; Class<?> declaringClass = md.getMethod().getDeclaringClass(); if (declaringClass != Object.class && !md.isHidden() && (!specifiedClassOnly || declaringClass == contextClass)) { v.addElement(md); } } } methodDescriptors = new MethodDescriptor[v.size()]; v.copyInto(methodDescriptors); sortMethodDescriptors(methodDescriptors); return methodDescriptors; }\n\n    ### Response: Gets the MethodDescriptors of the specified context class\n\n@param contextClass the Tea context Class to introspect (any class will\nwork fine)\n@param specifiedClassOnly true indicates that this function should\nonly return MethodDescriptors declared by the specified Class..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodDescriptor[] getAllMethodDescriptors() { if (allMethods == null) { final List<MethodDescriptor> allMethodsList = new ArrayList<>(); for (MethodDescriptor[] methodDescriptors : methodsMap.values()) { Collections.addAll(allMethodsList, methodDescriptors); } final MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]); Arrays.sort(allMethods, Comparator.comparing(md -> md.getMethod().getName())); this.allMethods = allMethods; } return allMethods; }\n\n    ### Response:", "ground_truth": "Returns all methods. Cached. Lazy.", "predict": " Gets all the MethodDescriptors of all the classes in the\nmethodsMap\n\n@return an array of all the MethodDescriptors of all the classes in the\nmethodsMap"}, {"ID": 1710, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return (InetAddress) u.hostAddress; String host = u.getHost(); if (host == null || host.equals(\"\")) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); } catch (UnknownHostException ex) { return null; } catch (SecurityException se) { return null; } } return (InetAddress) u.hostAddress; }\n\n    ### Response: Get the IP address of our host. An empty host field or a DNS failure\nwill result in a null return.\n\n@param u a URL object\n@return an {@code InetAddress} representing the host\nIP address.\n@since 1.3.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveIpAddress(final String hostname) { try { InetAddress netAddress; if (hostname == null || hostname.equalsIgnoreCase(LOCAL_HOST)) { netAddress = InetAddress.getLocalHost(); } else { netAddress = Inet4Address.getByName(hostname); } return netAddress.getHostAddress(); } catch (UnknownHostException ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Resolves IP address from a hostname.", "predict": " Resolves the IP address of a given hostname.\n\n@param hostname the hostname to resolve\n@return the IP address of the hostname, or null if it cannot be resolved\n@since 1.0.0"}, {"ID": 1711, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getClassNameRepresentation(String name) { if (name == null || name.length() == 0) { return \"\"; } StringBuilder buf = new StringBuilder(); String[] tokens = name.split(\"[^\\\\w\\\\d]\"); for (String token1 : tokens) { String token = token1.trim(); int length = token.length(); if (length > 0) { buf.append(token.substring(0, 1).toUpperCase(Locale.ENGLISH)); if (length > 1) { buf.append(token.substring(1)); } } } return buf.toString(); }\n\n    ### Response: Returns the class name representation of the given name.\n\n@param name The name to convert\n@return The property name representation.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getIpAsInt(final String ipAddress) { int ipIntValue = 0; String[] tokens = StringUtil.splitc(ipAddress, '.'); for (String token : tokens) { if (ipIntValue > 0) { ipIntValue <<= 8; } ipIntValue += Integer.parseInt(token); } return ipIntValue; }\n\n    ### Response:", "ground_truth": "Returns IP address as integer.", "predict": " Returns the integer value of the given IP address.\n\n@param ipAddress The IP address to convert\n@return The integer value of the IP address."}, {"ID": 1712, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean mayBeIPv6Address(String input) { if (input == null) { return false; } boolean result = false; int colonsCounter = 0; int length = input.length(); for (int i = 0; i < length; i++) { char c = input.charAt(i); if (c == '.' || c == '%') { // IPv4 in IPv6 or Zone ID detected, end of checking. break; } if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || c == ':')) { return false; } else if (c == ':') { colonsCounter++; } } if (colonsCounter >= 2) { result = true; } return result; }\n\n    ### Response: Heuristic check if string might be an IPv6 address.\n\n@param input Any string or null\n@return true, if input string contains only hex digits and at least two colons, before '.' or '%' character..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validateAgaintIPAdressV4Format(final String input) { if (input == null) { return false; } int hitDots = 0; char[] data = input.toCharArray(); for (int i = 0; i < data.length; i++) { char c = data[i]; int b = 0; do { if (c < '0' || c > '9') { return false; } b = (b * 10 + c) - 48; if (++i >= data.length) { break; } c = data[i]; } while (c != '.'); if (b > 255) { return false; } hitDots++; } return hitDots == 4; }\n\n    ### Response:", "ground_truth": "Checks given string against IP address v4 format.\n\n@param input an ip address - may be null\n@return true if param has a valid ip v4 format false otherwise\n@see ip address v4", "predict": " Validate if a string is a valid IPv4 address.\n\n@param input Any string or null\n@return true, if input string contains only digits and dots separated by 3 digits each."}, {"ID": 1713, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static InetAddress getInetAddress(String ip) { if (ip == null) return null; InetAddress addr = null; try { addr = InetAddress.getByName(ip); } catch (UnknownHostException e) { Log.err(e); H2O.exit(-1); } return addr; }\n\n    ### Response: Get address for given IP.\n@param ip  textual representation of IP (host)\n@return IPv4 or IPv6 address which matches given IP and is in specified range.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveHostName(final byte[] ip) { try { InetAddress address = InetAddress.getByAddress(ip); return address.getHostName(); } catch (UnknownHostException ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Resolves host name from IP address bytes.", "predict": " Get the hostname for the given IP address.\n@param ip  byte array representation of IP address\n@return hostname for the given IP address or null if it cannot be resolved."}, {"ID": 1714, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] toByteArray(URL url) throws IOException { try (InputStream inputStream = url.openStream()) { return ByteStreams.toByteArray(inputStream); } }\n\n    ### Response: Reads all bytes from a URL into a byte array.\n\n@param url the URL to read from\n@return a byte array containing all the bytes from the URL\n@throws IOException if an I/O error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] downloadBytes(final String url) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return StreamUtil.readBytes(inputStream); } }\n\n    ### Response:", "ground_truth": "Downloads resource as byte array.", "predict": " Downloads all bytes from a URL into a byte array.\n\n@param url the URL to download from\n@return a byte array containing all the bytes from the URL\n@throws IOException if an I/O error occurs."}, {"ID": 1715, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readStreamToString(InputStream is, String encoding) throws IOException { try { StringBuilder sb = new StringBuilder(); byte[] buf = new byte[1024 * 10]; int read; while ((read = is.read(buf)) >= 0) { sb.append(new String(buf, 0, read, encoding)); } return sb.toString(); } finally { is.close(); } }\n\n    ### Response: Reads a string from a stream. Closes the stream after reading.\n@param is the stream\n@param encoding the character encoding\n@return the string\n@throws IOException if the stream contents could not be read.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String downloadString(final String url, final String encoding) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return new String(StreamUtil.readChars(inputStream, encoding)); } }\n\n    ### Response:", "ground_truth": "Downloads resource as String.", "predict": " Downloads a string from a URL.\n@param url the URL to download from\n@param encoding the character encoding\n@return the downloaded string\n@throws IOException if the URL could not be opened or read."}, {"ID": 1716, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File writeToFile(InputStream inputStream, File file) throws IOException { try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) { ReadableByteChannel inputChannel = Channels.newChannel(inputStream); FileChannel fileChannel = raf.getChannel(); fastChannelCopy(inputChannel, fileChannel); } return file; }\n\n    ### Response: Writes from an InputStream to a file.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void downloadFile(final String url, final File file) throws IOException { try ( InputStream inputStream = new URL(url).openStream(); ReadableByteChannel rbc = Channels.newChannel(inputStream); FileChannel fileChannel = FileChannel.open( file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE) ) { fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE); } }\n\n    ### Response:", "ground_truth": "Downloads resource to a file, potentially very efficiently.", "predict": " Downloads a file from a URL to a local file."}, {"ID": 1717, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initTemplateEngineCfg() { configuration = new Configuration(); configuration.setDefaultEncoding(\"UTF-8\"); final ServletContext servletContext = AbstractServletListener.getServletContext(); configuration.setServletContextForTemplateLoading(servletContext, \"/plugins/\" + dirName); LOGGER.log(Level.DEBUG, \"Initialized template configuration\"); }\n\n    ### Response: Initializes template engine configuration..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void inject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(actionRequest, targets)); }\n\n    ### Response:", "ground_truth": "Performs injection.", "predict": " Injects dependencies into the action request.\n\n    "}, {"ID": 1718, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void storeInteractionManifest(String interactionManifest) { try { InteractionManifest payload = new InteractionManifest(interactionManifest); Interactions interactions = payload.getInteractions(); Targets targets = payload.getTargets(); if (interactions != null && targets != null) { setTargets(targets.toString()); setInteractions(interactions.toString()); } else { ApptentiveLog.e(CONVERSATION, \"Unable to save InteractionManifest.\"); } } catch (JSONException e) { ApptentiveLog.w(CONVERSATION, \"Invalid InteractionManifest received.\"); logException(e); } }\n\n    ### Response: Made public for testing. There is no other reason to use this method directly..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void outject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets)); }\n\n    ### Response:", "ground_truth": "Performs outjection.", "predict": " Made protected for testing. There is no other reason to use this method directly.."}, {"ID": 1719, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket accept(ServerSocket serverSocket, final boolean runInANewThread, @ClosureParams(value=SimpleType.class, options=\"java.net.Socket\") final Closure closure) throws IOException { final Socket socket = serverSocket.accept(); if (runInANewThread) { new Thread(new Runnable() { public void run() { invokeClosureWithSocket(socket, closure); } }).start(); } else { invokeClosureWithSocket(socket, closure); } return socket; }\n\n    ### Response: Accepts a connection and passes the resulting Socket to the closure\nwhich runs in a new Thread or the calling thread, as needed.\n\n@param serverSocket    a ServerSocket\n@param runInANewThread This flag should be true, if the closure should be invoked in a new thread, else false.\n@param closure         a Closure\n@return a Socket\n@throws IOException if an IOException occurs.\n@see java.net.ServerSocket#accept()\n@since 1.7.6.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket connect(final String hostname, final int port) throws IOException { final Socket socket = new Socket(); socket.connect(new InetSocketAddress(hostname, port)); return socket; }\n\n    ### Response:", "ground_truth": "Creates a socket.", "predict": "Establishes a connection to the specified host and port.\n\n@param hostname the hostname or IP address to connect to\n@param port the port to connect to\n@return a Socket\n@throws IOException if an IOException occurs.\n@see java.net.Socket#connect(java.net.SocketAddress)\n@since 1.7.6."}, {"ID": 1720, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket accept(ServerSocket serverSocket, final boolean runInANewThread, @ClosureParams(value=SimpleType.class, options=\"java.net.Socket\") final Closure closure) throws IOException { final Socket socket = serverSocket.accept(); if (runInANewThread) { new Thread(new Runnable() { public void run() { invokeClosureWithSocket(socket, closure); } }).start(); } else { invokeClosureWithSocket(socket, closure); } return socket; }\n\n    ### Response: Accepts a connection and passes the resulting Socket to the closure\nwhich runs in a new Thread or the calling thread, as needed.\n\n@param serverSocket    a ServerSocket\n@param runInANewThread This flag should be true, if the closure should be invoked in a new thread, else false.\n@param closure         a Closure\n@return a Socket\n@throws IOException if an IOException occurs.\n@see java.net.ServerSocket#accept()\n@since 1.7.6.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException { final Socket socket = new Socket(); if (connectionTimeout <= 0) { socket.connect(new InetSocketAddress(hostname, port)); } else { socket.connect(new InetSocketAddress(hostname, port), connectionTimeout); } return socket; }\n\n    ### Response:", "ground_truth": "Creates a socket with a timeout.", "predict": "Establishes a connection to the specified host and port.\n\n@param hostname         the hostname or IP address to connect to\n@param port             the port to connect to\n@param connectionTimeout the connection timeout in milliseconds, or 0 for infinite timeout\n@return a Socket\n@throws IOException if an IOException occurs.\n@see java.net.Socket#connect(java.net.SocketAddress)\n@see java.net.Socket#connect(java.net.SocketAddress, int)\n@since 1.7.6."}, {"ID": 1721, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getPackage(final String fullyQualifiedClassName) { int dotIndex = fullyQualifiedClassName.lastIndexOf('.'); if (dotIndex == -1) { return null; } else { return fullyQualifiedClassName.substring(0, dotIndex); } }\n\n    ### Response: Gets the package name from a fully qualified class name.\n\n@param fullyQualifiedClassName\nFully qualified class name\n@return Package name or {@code null} for default package.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getPrimitiveClassNameIndex(final String className) { int dotIndex = className.indexOf('.'); if (dotIndex != -1) { return -1; } return Arrays.binarySearch(PRIMITIVE_TYPE_NAMES, className); }\n\n    ### Response:", "ground_truth": "Detects if provided class name is a primitive type.\nReturns >= 0 number if so.", "predict": " Gets the index of a primitive class name in the array of primitive type names.\n\n@param className\nClass name\n@return Index of the class name in the array of primitive type names, or -1 if the class name is not a primitive type.\n\n    "}, {"ID": 1722, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> loadClass( String name, ClassLoader callerClassLoader) throws ClassNotFoundException { Class<?> clazz = null; try { ClassLoader loader = getContextClassLoader(); if (loader != null) { clazz = loader.loadClass(name); } } catch (ClassNotFoundException e) { // treat as though loader not set } if (clazz == null) { if (callerClassLoader != null) { clazz = callerClassLoader.loadClass(name); } else { clazz = Class.forName(name); } } return clazz; }\n\n    ### Response: Loads the class with the specified name.  For Java 2 callers, the\ncurrent thread's context class loader is preferred, falling back on the\nclass loader of the caller when the current thread's context is not set,\nor the caller is pre Java 2.  If the callerClassLoader is null, then\nfall back on the system class loader.\n\n@param     name  the name of the class\n@param     callerClassLoader  the calling class loader context\n@return    the resulting Class object\n@exception ClassNotFoundException if the class was not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Class loadClass(final String className, final ClassLoader classLoader) throws ClassNotFoundException { String arrayClassName = prepareArrayClassnameForLoading(className); if ((className.indexOf('.') == -1) && (arrayClassName == null)) { // maybe a primitive int primitiveNdx = getPrimitiveClassNameIndex(className); if (primitiveNdx >= 0) { return PRIMITIVE_TYPES[primitiveNdx]; } } // try #1 - using provided class loader if (classLoader != null) { Class klass = loadClass(className, arrayClassName, classLoader); if (klass != null) { return klass; } } // try #2 - using thread class loader ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader(); if ((currentThreadClassLoader != null) && (currentThreadClassLoader != classLoader)) { Class klass = loadClass(className, arrayClassName, currentThreadClassLoader); if (klass != null) { return klass; } } // try #3 - using caller classloader, similar as Class.forName() //Class callerClass = ReflectUtil.getCallerClass(2); Class callerClass = ClassUtil.getCallerClass(); ClassLoader callerClassLoader = callerClass.getClassLoader(); if ((callerClassLoader != classLoader) && (callerClassLoader != currentThreadClassLoader)) { Class klass = loadClass(className, arrayClassName, callerClassLoader); if (klass != null) { return klass; } } // try #4 - everything failed, try alternative array loader if (arrayClassName != null) { try { return loadArrayClassByComponentType(className, classLoader); } catch (ClassNotFoundException ignore) { } } throw new ClassNotFoundException(\"Class not found: \" + className); }\n\n    ### Response:", "ground_truth": "Loads class by name.", "predict": " Loads the class with the specified name.  The class loader to use is determined in the following order:\n\n1. If the provided class loader is not null, attempt to load the class using that class loader.\n2. If the current thread's context class loader is not null and is not the same as the provided class loader, attempt to load the class using that class loader.\n3. If the caller class loader is not null and is not the same as the provided class loader or the current thread's context class loader, attempt to load the class using that class loader.\n4. If the class name is an array class name, attempt to load the class using the array class loader.\n5. If all attempts to load the class fail, throw a ClassNotFoundException.\n\n@param     className  the name of the class\n@param     classLoader  the class loader to use, or null to use the default class loader\n@return    the resulting Class object\n@exception ClassNotFoundException if the class was not found."}, {"ID": 1723, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void reset() { xyMax = new int[] {0, 0}; xyStart = new int[] {0, 0}; scores = null; types = (gapPenalty == null || gapPenalty.getType() == GapPenalty.Type.LINEAR) ? new String[] { null } : new String[] { \"Substitution\", \"Deletion\", \"Insertion\" }; time = -1; profile = null; }\n\n    ### Response: Resets output fields; should be overridden to set max and min.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class loadArrayClassByComponentType(final String className, final ClassLoader classLoader) throws ClassNotFoundException { int ndx = className.indexOf('['); int multi = StringUtil.count(className, '['); String componentTypeName = className.substring(0, ndx); Class componentType = loadClass(componentTypeName, classLoader); if (multi == 1) { return Array.newInstance(componentType, 0).getClass(); } int[] multiSizes; if (multi == 2) { multiSizes = new int[] {0, 0}; } else if (multi == 3) { multiSizes = new int[] {0, 0, 0}; } else { multiSizes = (int[]) Array.newInstance(int.class, multi); } return Array.newInstance(componentType, multiSizes).getClass(); }\n\n    ### Response:", "ground_truth": "Loads array class using component type.", "predict": " Loads a class for an array of the specified component type and dimensions.\n\n    "}, {"ID": 1724, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void shutdown() { synchronized (connections) { parent.channelCloses(this); for (final MessageInbound connection : connections) { try { connection.getWsOutbound().close(0, null); } catch (final IOException e) { LOG.error(\"Connection [\" + connection.toString() + \"] can't be closed.\", e); } finally { final ExecutorService executorService = connectionThreads.get(connection); if (executorService != null) { executorService.shutdown(); } connectionThreads.remove(connection); } } connections.clear(); } callback = null; }\n\n    ### Response: Disconnects all clients and makes the servlet refuse new connections..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); }\n\n    ### Response:", "ground_truth": "Iterate all beans and invokes registered destroy methods.", "predict": "Destroys all the instances of the servlet and removes them from the instances map."}, {"ID": 1725, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <C extends Comparable> Ordering<Range<C>> orderingByLowerEndpoint() { return new Ordering<Range<C>>() { @Override public int compare(final Range<C> left, final Range<C> right) { return ComparisonChain.start() .compare(left.hasLowerBound(), right.hasLowerBound()) .compare(left.lowerEndpoint(), right.lowerEndpoint()) .result(); } }; }\n\n    ### Response: Return an ordering by lower endpoint over ranges.\n\n@param  range endpoint type\n@return an ordering by lower endpoint over ranges.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Comparable> BinarySearch<T> forArray(final T[] array) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return array[index].compareTo(element); } @Override protected int getLastIndex() { return array.length - 1; } }; }\n\n    ### Response:", "ground_truth": "Creates binary search wrapper over an array.", "predict": " Return a binary search implementation for the given array.\n\n@param  array the array to search\n@return a binary search implementation for the given array."}, {"ID": 1726, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Comparator<RequestMapperBean> newComparator() { return new Comparator<RequestMapperBean>() { @Override public int compare(final RequestMapperBean o1, final RequestMapperBean o2) { return o1.getCompatibilityScore() - o2.getCompatibilityScore(); } }; }\n\n    ### Response: Factory method for creating a new Comparator for sort the compatibility score. This method is\ninvoked in the method initializeRequestMappers and can be overridden so users can provide\ntheir own version of a Comparator.\n\n@return the new Comparator..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return comparator.compare(array[index], element); } @Override protected int getLastIndex() { return array.length - 1; } }; }\n\n    ### Response:", "ground_truth": "Creates binary search wrapper over an array with given comparator.", "predict": " Factory method for creating a new BinarySearch for an array of elements. This method is\ninvoked in the method initializeRequestMappers and can be overridden so users can provide\ntheir own version of a BinarySearch.\n\n@param array the array of elements to search\n@param comparator the comparator to use for comparing elements\n@return the new BinarySearch for the array and comparator."}, {"ID": 1727, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <V> Reflecter<T> populate(String json, String... excludes) { return JSONer.addJsonExchangeFunc(this).populate(JSONer.readNoneNullMap(json), excludes); }\n\n    ### Response: Populate the JavaBeans properties of this delegate object, based on the JSON string\n\n@see ReadJSON#asObject(Object).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T exclude(final String... excludes) { for (String ex : excludes) { rules.exclude(ex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines excluded property names.", "predict": " Exclude the specified fields from the JSON serialization of this object.\n\n@see WriteJSON#exclude(String...)."}, {"ID": 1728, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean check(String id, List<String> includes) { if (null != includes) { for (String check : includes) { if (check(id, check)) { return true; } } } return false; }\n\n    ### Response: Check whether the given is is matched by one of the include expressions.\n\n@param id id to check\n@param includes list of include regular expressions\n@return true when id is included.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T include(final String... includes) { for (String in : includes) { rules.include(in); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines included property names.", "predict": " Add the given include expressions to the current set of include expressions.\n\n@param includes include expressions to add\n@return this object\n\n    "}, {"ID": 1729, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Enum> T getSelector(SlingHttpServletRequest request, T defaultValue) { String[] selectors = request.getRequestPathInfo().getSelectors(); Class type = defaultValue.getClass(); for (String selector : selectors) { try { T value = (T) T.valueOf(type, selector); return value; } catch (IllegalArgumentException iaex) { // ok, try next } } return defaultValue; }\n\n    ### Response: Returns an enum value from selectors if an appropriate selector\ncan be found otherwise the default value given.\n\n@param request      the request object with the selector info\n@param defaultValue the default enum value\n@param           the enum type derived from the default value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T includeAs(final Class template) { blacklist = false; String[] properties = getAllBeanPropertyNames(template, false); include(properties); return _this(); }\n\n    ### Response:", "ground_truth": "Defines included property names as public properties\nof given template class. Sets to black list mode.", "predict": " Includes all properties of the given template class as properties of the current object.\n\n@param template the template class to include properties from\n@return         the current object for chaining\n\n    "}, {"ID": 1730, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function Join(name) { this.name = name; this.criteria = null; this.table = null; this.map = null; this.type = this.ONE_TO_ONE; this.default = false; }\n\n    ### Response: a join model.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final int startIndex) { this.tagStartIndex = startIndex; this.name = null; this.idNdx = -1; this.attributesCount = 0; this.tagLength = 0; this.modified = false; this.type = TagType.START; this.rawTag = false; }\n\n    ### Response:", "ground_truth": "Starts the tag with the index of first '<'.\nResets all tag data.", "predict": " initializes the tag with the given start index.\n\n    "}, {"ID": 1731, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getProperty(final String name, final Class<T> clazz) { if (containsProperty(name)) { val item = this.properties.get(name); if (item == null) { return null; } if (!clazz.isAssignableFrom(item.getClass())) { throw new ClassCastException(\"Object [\" + item + \" is of type \" + item.getClass() + \" when we were expecting \" + clazz); } return (T) item; } return null; }\n\n    ### Response: Gets property.\n\n@param    the type parameter\n@param name  the name\n@param clazz the clazz\n@return the property.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> void registerComponent(final String name, final Class<T> component, final Consumer<T> consumer) { log.debug(() -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component.getName()); madpc.removeBean(name); madpc.registerPetiteBean(component, name, null, null, false, consumer); }\n\n    ### Response:", "ground_truth": "Registers Madvoc component with given name.", "predict": " Registers component.\n\n@param name         the name\n@param component    the component\n@param consumer     the consumer"}, {"ID": 1732, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<String> populateTableNames(String url) throws SQLException { Set<String> tableNames = new HashSet<String>(); Connection connection = null; ResultSet rs = null; try { connection = DriverManager.getConnection(url); DatabaseMetaData dmd = connection.getMetaData(); rs = dmd.getTables(null, null, null, null); while (rs.next()) { tableNames.add(rs.getString(\"TABLE_NAME\").toUpperCase()); } } finally { if (rs != null) { rs.close(); } if (connection != null) { connection.close(); } } return tableNames; }\n\n    ### Response: Open a database and build a set of table names.\n\n@param url database URL\n@return set containing table names.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void resolveColumnDbSqlType(final Connection connection, final DbEntityColumnDescriptor dec) { if (dec.dbSqlType != SqlType.DB_SQLTYPE_UNKNOWN) { return; } ResultSet rs = null; DbEntityDescriptor ded = dec.getDbEntityDescriptor(); try { DatabaseMetaData dmd = connection.getMetaData(); rs = dmd.getColumns(null, ded.getSchemaName(), ded.getTableName(), dec.getColumnName()); if (rs.next()) { dec.dbSqlType = rs.getInt(\"DATA_TYPE\"); } else { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not available: \" + ded.toString() + '.' + dec.getColumnName()); } } } catch (SQLException sex) { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not resolved: \" + ded.toString() + '.' + dec.getColumnName(), sex); } } finally { DbUtil.close(rs); } }\n\n    ### Response:", "ground_truth": "Resolves column db sql type and populates it in column descriptor if missing.", "predict": " Resolve the database SQL type for a column.\n\n@param connection database connection\n@param dec column descriptor\n@throws SQLException if an error occurs while resolving the SQL type."}, {"ID": 1733, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Range<String> transformClosed(Range<String> range) { if (range.hasLowerBound()) { String lower = range.lowerEndpoint(); // the special case, (a, _] and apply(a) == a is handled by skipping a String afterLower = domain.next(apply(lower)); if (afterLower != null) { if (range.hasUpperBound()) { String upper = range.upperEndpoint(); String upperImage = apply(upper); // meaning: at the endpoint if (upper.equals(upperImage) && range.isUpperBoundClosed()) { // include upper return Ranges.closed(afterLower, upperImage); } else { String beforeUpper = domain.previous(upperImage); if (afterLower.compareTo(beforeUpper) <= 0) { return Ranges.closed(afterLower, beforeUpper); } } } else { return Ranges.atLeast(afterLower); } } } else if (range.hasUpperBound()) { String upper = range.upperEndpoint(); String upperImage = apply(upper); if (upper.equals(upperImage) && range.isUpperBoundClosed()) { // include upper return Ranges.atMost(upperImage); } else { String beforeUpper = domain.previous(upperImage); if (beforeUpper != null) { return Ranges.atMost(beforeUpper); } } } return null; }\n\n    ### Response: Transforms a Range predicate to a closed range on this partitioner's upper\nbounds. Handles edge cases correctly.\n\n@param range a Range of Strings\n@return a Range of upper-bound Strings.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String preprocessSql(String sqlString) { // detects callable statement if (sqlString.charAt(0) == '{') { return sqlString; } // quickly detect if SQL string is a key if (!CharUtil.isAlpha(sqlString.charAt(0))) { sqlString = sqlString.substring(1); } else if (sqlString.indexOf(' ') != -1) { return sqlString; } final String sqlFromMap = dbOom.queryMap().getQuery(sqlString); if (sqlFromMap != null) { sqlString = sqlFromMap.trim(); } return sqlString; }\n\n    ### Response:", "ground_truth": "Pre-process SQL before using it. If string starts with a non-ascii char\nor it has no spaces, it will be loaded from the query map.", "predict": "Preprocesses a SQL string to detect if it is a callable statement or a key.\n\n@param sqlString the SQL string to preprocess\n@return the preprocessed SQL string\n\n    "}, {"ID": 1734, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs protected final List<ValidationError> contOnValidationError(final Set<ConstraintViolation<Object>>... violationsArray) { final List<ValidationError> errors = new ArrayList<>(); for (final Set<ConstraintViolation<Object>> violations : violationsArray) { for (final ConstraintViolation violation : violations) { if (violation.getPropertyPath().iterator().next().getName() != null) { final String path = violation.getPropertyPath() != null ? violation.getPropertyPath().toString() : null; final String message = violation.getMessage() != null ? StringUtils.removeStart(violation.getMessage(), path + \".\") : null; final String messageTemplate = violation.getMessageTemplate(); final String invalidValue = violation.getInvalidValue() != null ? violation.getInvalidValue().toString() : null; final ValidationError error = new ValidationError(message, messageTemplate, path, invalidValue); errors.add(error); } } } return errors; }\n\n    ### Response: Accepts the result from one of the many validation methods available and\nreturns a List of ValidationErrors. If the size of the List is 0, no errors\nwere encounter during validation.\n\nUsage:\n\nValidator validator = getValidator();\nList&lt;ValidationError&gt; errors = contOnValidationError(\nvalidator.validateProperty(myObject, \"uuid\"),\nvalidator.validateProperty(myObject, \"name\")\n);\n// If validation fails, this line will be reached.\n\n\n@param violationsArray a Set of one or more ConstraintViolations\n@return a List of zero or more ValidationErrors\n@since 1.0.0.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ResultSetMapper createResultSetMapper(final ResultSet resultSet) { final Map<String, ColumnData> columnAliases = sqlgen != null ? sqlgen.getColumnData() : null; return new DefaultResultSetMapper(dbOom, resultSet, columnAliases, cacheEntities, this); }\n\n    ### Response:", "ground_truth": "Factory for result sets mapper.", "predict": " Creates a ResultSetMapper for the given ResultSet.\n\n@param resultSet the ResultSet to map\n@return a ResultSetMapper for the given ResultSet\n@since 1.0.0."}, {"ID": 1735, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getNamedObject(String name, Class<T> type) { return type.cast(_named.get(name)); }\n\n    ### Response: Retrieves a named object of a specific type from this binder..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T findGeneratedKey(final Class<T> type) { return find(new Class[] {type}, false, getGeneratedColumns()); }\n\n    ### Response:", "ground_truth": "Finds generated key column of given type.", "predict": " Finds a generated key of a specific type from this binder. The generated key is the first column in the generated columns list.\n\n    "}, {"ID": 1736, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void collectPrefixes(FieldInfos fieldInfos, String field, ComponentField fieldInfo, Status status) throws IOException { if (fieldInfo.prefix != null) { FieldInfo fi = fieldInfos.fieldInfo(field); if (fi != null) { String singlePositionPrefixes = fi.getAttribute( MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SINGLE_POSITION); String multiplePositionPrefixes = fi.getAttribute( MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_MULTIPLE_POSITION); String setPositionPrefixes = fi.getAttribute( MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_SET_POSITION); String intersectingPrefixes = fi.getAttribute( MtasCodecPostingsFormat.MTAS_FIELDINFO_ATTRIBUTE_PREFIX_INTERSECTION); if (singlePositionPrefixes != null) { String[] prefixes = singlePositionPrefixes .split(Pattern.quote(MtasToken.DELIMITER)); for (int i = 0; i < prefixes.length; i++) { fieldInfo.prefix.addSinglePosition(prefixes[i]); } } if (multiplePositionPrefixes != null) { String[] prefixes = multiplePositionPrefixes .split(Pattern.quote(MtasToken.DELIMITER)); for (int i = 0; i < prefixes.length; i++) { fieldInfo.prefix.addMultiplePosition(prefixes[i]); } } if (setPositionPrefixes != null) { String[] prefixes = setPositionPrefixes .split(Pattern.quote(MtasToken.DELIMITER)); for (int i = 0; i < prefixes.length; i++) { fieldInfo.prefix.addSetPosition(prefixes[i]); } } if (intersectingPrefixes != null) { String[] prefixes = intersectingPrefixes .split(Pattern.quote(MtasToken.DELIMITER)); for (int i = 0; i < prefixes.length; i++) { fieldInfo.prefix.addIntersecting(prefixes[i]); } } } } }\n\n    ### Response: Collect prefixes.\n\n@param fieldInfos\nthe field infos\n@param field\nthe field\n@param fieldInfo\nthe field info\n@throws IOException\nSignals that an I/O exception has occurred..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void populateGeneratedKeys(final Object entity) { final String[] generatedColumns = getGeneratedColumnNames(); if (generatedColumns == null) { return; } DbEntityDescriptor ded = dbOom.entityManager().lookupType(entity.getClass()); // prepare key types Class[] keyTypes = new Class[generatedColumns.length]; String[] properties = new String[generatedColumns.length]; for (int i = 0; i < generatedColumns.length; i++) { String column = generatedColumns[i]; DbEntityColumnDescriptor decd = ded.findByColumnName(column); if (decd != null) { keyTypes[i] = decd.getPropertyType(); properties[i] = decd.getPropertyName(); } } final Object keyValues = findGeneratedColumns(keyTypes); if (!keyValues.getClass().isArray()) { BeanUtil.declared.setProperty(entity, properties[0], keyValues); } else { for (int i = 0; i < properties.length; i++) { BeanUtil.declared.setProperty(entity, properties[i], ((Object[]) keyValues)[i]); } } }\n\n    ### Response:", "ground_truth": "Populates entity with generated column values from executed query.", "predict": " Populate generated keys.\n\n@param entity\nthe entity to populate\n@throws SQLException\nSignals that a database access error has occurred.\n\n    "}, {"ID": 1737, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DialectFactory createDialectFactory() { DialectFactoryImpl factory = new DialectFactoryImpl(); factory.injectServices(new ServiceRegistryImplementor() { @Override public <R extends Service> R getService(Class<R> serviceRole) { if (serviceRole == DialectResolver.class) { return (R) new StandardDialectResolver(); } else if (serviceRole == StrategySelector.class) { return (R) new StrategySelectorImpl(new ClassLoaderServiceImpl(Thread.currentThread().getContextClassLoader())); } return null; } @Override public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) { return null; } @Override public void destroy() { } @Override public void registerChild(ServiceRegistryImplementor child) { } @Override public void deRegisterChild(ServiceRegistryImplementor child) { } @Override public ServiceRegistry getParentServiceRegistry() { return null; } }); return factory; }\n\n    ### Response: should be using the ServiceRegistry, but getting it from the SessionFactory at startup fails in Spring.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); }\n\n    ### Response:", "ground_truth": "Acquires interceptor from Petite container.", "predict": "This method creates a wrapper for the given action interceptor class using the Petite container. The wrapper is created by calling the `createBean` method of the container, which creates a new instance of the given class and injects any dependencies that it requires. The `createBean` method returns the new instance of the wrapper."}, {"ID": 1738, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Entity toEntity(final EntityType meta, final Map<String, Object> request) { final Entity entity = entityManager.create(meta, POPULATE); for (Attribute attr : meta.getAtomicAttributes()) { if (attr.getExpression() == null) { String paramName = attr.getName(); if (request.containsKey(paramName)) { final Object paramValue = request.get(paramName); Attribute idAttribute = meta.getIdAttribute(); Object idValue = request.get(idAttribute.getName()); final Object value = this.toEntityValue(attr, paramValue, idValue); entity.set(attr.getName(), value); } } } return entity; }\n\n    ### Response: Creates a new entity based from a HttpServletRequest. For file attributes persists the file in\nthe file store and persist a file meta data entity.\n\n@param meta entity meta data\n@param request HTTP request parameters\n@return entity created from HTTP request parameters.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p.name; if (paramName.startsWith(beanNamePrefix)) { final String propertyName = paramName.substring(beanNamePrefix.length()); if (BeanUtil.declared.hasRootProperty(bean, propertyName)) { final Object value = BeanUtil.declared.getProperty(bean, propertyName); setObject(paramName, value); } } }); return _this(); }\n\n    ### Response:", "ground_truth": "Sets bean parameters from bean. Non-existing bean properties are ignored.", "predict": " Sets the bean properties to the query parameters.\n\n@param beanName bean name\n@param bean bean object\n@return query object with bean properties set to query parameters."}, {"ID": 1739, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String parameterize(String config, ConfigParams parameters) throws IOException { if (parameters == null) { return config; } Handlebars handlebars = new Handlebars(); Template template = handlebars.compileInline(config); return template.apply(parameters); }\n\n    ### Response: Parameterized configuration template given as string with dynamic parameters.\n\nThe method uses Handlebars template engine.\n\n@param config     a string with configuration template to be parameterized\n@param parameters dynamic parameters to inject into the template\n@return a parameterized configuration string.\n@throws IOException when input/output error occured..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setMap(final Map parameters) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName = p.name; setObject(paramName, parameters.get(paramName)); }); return _this(); }\n\n    ### Response:", "ground_truth": "Sets properties from the map.", "predict": " Sets the map of parameters for the query.\n\n@param parameters the map of parameters to set for the query.\n@return the query instance.\n\n    "}, {"ID": 1740, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int hashObjects(final Object... objects) { final int prime = 31; int result = 1; for (final Object object : objects) { result = prime * result + ((object == null) ? 0 : object.hashCode()); } return result; }\n\n    ### Response: Hash a bunch of objects\n@param objects the objects\n@return a hash code.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setObjects(final Object... objects) { int index = 1; for (final Object object : objects) { setObject(index++, object); } return _this(); }\n\n    ### Response:", "ground_truth": "Sets an array of objects parameters in given order.", "predict": " Set a bunch of objects\n@param objects the objects\n@return the current object."}, {"ID": 1741, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void removeEntry(T entry) { T prev = entry.getPrev(); T next = entry.getNext(); if (prev != null) { prev.setNext(next); } else { head = next; } if (next != null) { next.setPrev(prev); } else { last = prev; } size--; }\n\n    ### Response: Removes an entry from the list.\n\n@param entry\nthe entry to remove..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertChunkAfter(final SqlChunk previous) { SqlChunk next = previous.nextChunk; previous.nextChunk = this; this.previousChunk = previous; if (next != null) { next.previousChunk = this; this.nextChunk = next; } }\n\n    ### Response:", "ground_truth": "Appends chunk to previous one and maintains the double-linked list of the previous chunk.\nCurrent surrounding connections of this chunk will be cut-off.", "predict": " Inserts a chunk after the specified chunk.\n\n@param previous\nthe chunk to insert after."}, {"ID": 1742, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected IPortletEntity wrapEntity(IPortletEntity portletEntity) { if (portletEntity == null) { return null; } final String persistentLayoutNodeId = portletEntity.getLayoutNodeId(); if (persistentLayoutNodeId.startsWith(TransientUserLayoutManagerWrapper.SUBSCRIBE_PREFIX)) { final IUserLayoutManager userLayoutManager = this.getUserLayoutManager(); if (userLayoutManager == null) { this.logger.warn( \"Could not find IUserLayoutManager when trying to wrap transient portlet entity: \" + portletEntity); return portletEntity; } final IPortletDefinition portletDefinition = portletEntity.getPortletDefinition(); final String fname = portletDefinition.getFName(); final String layoutNodeId = userLayoutManager.getSubscribeId(fname); return new TransientPortletEntity(portletEntity, layoutNodeId); } return portletEntity; }\n\n    ### Response: Adds a TransientPortletEntity wrapper to the portletEntity if it is needed. If the specified\nentity is transient but no transient subscribe id has been registered for it yet in the\ntransientIdMap null is returned. If no wrapping is needed the original entity is returned..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor lookupType(final Class entity) { final DbEntityDescriptor ded = dbEntityManager.lookupType(entity); if (ded == null) { throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName()); } return ded; }\n\n    ### Response:", "ground_truth": "Lookups for entity name and throws an exception if entity type is invalid.", "predict": " Looks up the DbEntityDescriptor for the specified entity class. If the entity is not a persistent entity or has not been registered with the DbEntityManager, a DbSqlBuilderException is thrown."}, {"ID": 1743, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Properties loadProperties(Resource resource, String filename) throws IOException { InputStream is = resource.getInputStream(); Properties props = new Properties(); try { if (resource.getFilename().endsWith(XML_SUFFIX)) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.loadFromXml(props, is); } else { String encoding = null; if (this.fileEncodings != null) { encoding = this.fileEncodings.getProperty(filename); } if (encoding == null) { encoding = this.defaultEncoding; } if (encoding != null) { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\"); } this.propertiesPersister.load(props, new InputStreamReader(is, encoding)); } else { if (logger.isDebugEnabled()) { logger.debug(\"Loading properties [\" + resource.getFilename() + \"]\"); } this.propertiesPersister.load(props, is); } } return props; } finally { is.close(); } }\n\n    ### Response: Load the properties from the given resource.\n@param resource the resource to load from\n@param filename the original bundle filename (basename + Locale)\n@return the populated Properties instance\n@throws IOException if properties loading failed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor findColumnRef(final String columnRef) { DbEntityDescriptor ded = templateData.findTableDescriptorByColumnRef(columnRef); if (ded == null) { throw new DbSqlBuilderException(\"Invalid column reference: [\" + columnRef + \"]\"); } return ded; }\n\n    ### Response:", "ground_truth": "Finds a table that contains given column.", "predict": " Find the DbEntityDescriptor for the given column reference.\n@param columnRef the column reference to find the descriptor for\n@return the DbEntityDescriptor for the given column reference\n@throws DbSqlBuilderException if the column reference is invalid or no descriptor can be found for it."}, {"ID": 1744, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function (tableAlias) { tableAlias = this._toTableName(tableAlias); var usedAliases = [], from, join; if ((from = this.__opts.from) != null) { usedAliases = usedAliases.concat(from.map(function (n) { return this._toTableName(n); }, this)); } if ((join = this.__opts.join) != null) { usedAliases = usedAliases.concat(join.map(function (join) { if (join.tableAlias) { return this.__toAliasedTableName(join.tableAlias); } else { return this._toTableName(join.table); } }, this)); } if (usedAliases.indexOf(tableAlias) !== -1) { var base = tableAlias, i = 0; do { tableAlias = string.format(\"%s%d\", base, i++); } while (usedAliases.indexOf(tableAlias) !== -1); } return tableAlias; }\n\n    ### Response: Creates a unique table alias that hasn't already been used in this dataset.\n\n@example\n\nDB.from(\"table\").unusedTableAlias(\"t\");\n//=> \"t\"\n\nDB.from(\"table\").unusedTableAlias(\"table\");\n//=> \"table0\"\n\nDB.from(\"table\", \"table0\"]).unusedTableAlias(\"table\");\n//=> \"table1\"\n\n@param {String|patio.sql.Identifier} tableAlias the table to get an unused alias for.\n\n@return {String} the implicit alias that is in tableAlias with a possible \"N\"\nif the alias has already been used, where N is an integer starting at 0..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveTable(final String tableRef, final DbEntityDescriptor ded) { String tableAlias = templateData.getTableAlias(tableRef); if (tableAlias != null) { return tableAlias; } return ded.getTableNameForQuery(); }\n\n    ### Response:", "ground_truth": "Resolves table name or alias that will be used in the query.", "predict": "Resolves a table reference to a table alias. If the table alias has already been resolved, it will be returned. Otherwise, the table name will be returned.\n\n@example\n\ntemplateData.resolveTable(\"table\", entity);\n//=> \"table\"\n\ntemplateData.resolveTable(\"table\", entity);\n//=> \"table0\"\n\n@param {String} tableRef the table reference to resolve.\n@param {patio.sql.DbEntityDescriptor} ded the entity descriptor for the table.\n\n@return {String} the table alias or table name."}, {"ID": 1745, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Class detectClass(final Object object) { if (object instanceof Class) { return (Class) object; } return object.getClass(); }\n\n    ### Response: Method detects the class of the given instance. In case the instance itself is the class these one is directly returned.\n\n@param object\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Class resolveClass(final Object object) { Class type = object.getClass(); return type == Class.class ? (Class) object : type; }\n\n    ### Response:", "ground_truth": "Resolves object to a class.", "predict": " Method resolves the class of the given instance. In case the instance itself is the class, it is directly returned.\n\n@param object\n@return."}, {"ID": 1746, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int checkVlen(int i) { int count = 0; if (i >= -112 && i <= 127) { return 1; } else { int len = -112; if (i < 0) { i ^= -1L; // take one's complement' len = -120; } long tmp = i; while (tmp != 0) { tmp = tmp >> 8; len--; } count++; len = (len < -120) ? -(len + 120) : -(len + 112); while (len != 0) { count++; len--; } return count; } }\n\n    ### Response: Determines the number bytes required to store a variable length\n\n@param i length of Bytes\n@return number of bytes needed.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendMissingSpace(final StringBuilder out) { int len = out.length(); if (len == 0) { return; } len--; if (!CharUtil.isWhitespace(out.charAt(len))) { out.append(' '); } }\n\n    ### Response:", "ground_truth": "Appends missing space if the output doesn't end with whitespace.", "predict": " Appends a missing space to the end of the StringBuilder if the last character is not a whitespace.\n\n@param out StringBuilder to append the missing space to."}, {"ID": 1747, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonComparator getComparator(List<String> context, JsonNode node1, JsonNode node2) { if (node1 == null) { if (node2 == null) { return NODIFF_CMP; } else { return null; } } else if (node2 == null) { return null; } else { if (node1 instanceof NullNode) { if (node2 instanceof NullNode) { return NODIFF_CMP; } else { return null; } } else if (node2 instanceof NullNode) { return null; } // Nodes are not null, and they are not null node if (node1.isContainerNode() && node2.isContainerNode()) { if (node1 instanceof ObjectNode) { return objectComparator; } else if (node1 instanceof ArrayNode) { return arrayComparator; } } else if (node1.isValueNode() && node2.isValueNode()) { return valueComparator; } } return null; }\n\n    ### Response: Returns the comparator for the give field, and nodes. This method can be\noverriden to customize comparison logic..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Enumeration<String> getFileParameterNames() { if (mreq == null) { return null; } return Collections.enumeration(mreq.getFileParameterNames()); }\n\n    ### Response:", "ground_truth": "Get an enumeration of the parameter names for uploaded files", "predict": " Returns an enumeration of the names of all file parameters in the request."}, {"ID": 1748, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { final HttpServletRequest req = (HttpServletRequest) request; final HttpServletResponse res = (HttpServletResponse) response; final String requestUri = req.getRequestURI(); if (requestUri != null) { boolean allowed = false; for (final String url: allowUrls) { if (requestUri.equals(\"/\")) { if (url.trim().equals(\"/\")) { allowed = true; } } else if (requestUri.startsWith(url.trim())) { allowed = true; } } if (!allowed) { res.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } } chain.doFilter(request, response); }\n\n    ### Response: Check for allowed URLs being requested.\n\n@param request The request object.\n@param response The response object.\n@param chain Refers to the {@code FilterChain} object to pass control to the next {@code Filter}.\n@throws IOException a IOException\n@throws ServletException a ServletException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException { RequestDispatcher dispatcher = request.getRequestDispatcher(page); if (dispatcher != null) { dispatcher.include(request, response); return true; } return false; }\n\n    ### Response:", "ground_truth": "Include page which path is relative to the current HTTP request.", "predict": " Includes the specified page in the current web page being generated.\n\n@param request The request object.\n@param response The response object.\n@param page The page to be included.\n@return true if the page was included successfully, false otherwise.\n@throws IOException a IOException\n@throws ServletException a ServletException."}, {"ID": 1749, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AbstractFileResolvingResource getResource(HttpServletRequest request) throws MalformedURLException { String servletPath; String pathInfo; boolean included = request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI) != null; if (included) { servletPath = (String) request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); pathInfo = (String) request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO); if (servletPath == null && pathInfo == null) { servletPath = request.getServletPath(); pathInfo = request.getPathInfo(); } } else { servletPath = request.getServletPath(); pathInfo = request.getPathInfo(); } String pathInContext = addPaths(servletPath, pathInfo); return getResource(pathInContext); }\n\n    ### Response: Gets a resource from a servlet request\n\n@param request the servlet request\n@return the resource or null if not found\n@throws java.net.MalformedURLException thrown when malformed URL..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getUrl(final HttpServletRequest request) { String servletPath = request.getServletPath(); String query = request.getQueryString(); if ((query != null) && (query.length() != 0)) { servletPath += '?' + query; } return servletPath; }\n\n    ### Response:", "ground_truth": "Returns url, without context path, convenient for request dispatcher.", "predict": " Gets the URL of the current request.\n\n@param request the current request\n@return the URL of the current request"}, {"ID": 1750, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getForwardURI(HttpServletRequest request) { String result = (String) request.getAttribute(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE); if (GrailsStringUtils.isBlank(result)) result = request.getRequestURI(); return result; }\n\n    ### Response: Obtains the forwardURI from the request, since Grails uses a forwarding technique for URL mappings. The actual\nrequest URI is held within a request attribute\n\n@param request The request\n@return The forward URI.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; }\n\n    ### Response:", "ground_truth": "Get current request uri.", "predict": " Retrieves the request URI from the request. If the request is an include request, the include request URI is returned instead.\n\n@param request The request\n@return The request URI."}, {"ID": 1751, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] getFieldNames(Class clazz) { Field[] fields = clazz.getFields(); String[] names = new String[fields.length]; for (int i = 0; i < names.length; i++) { names[i] = fields[i].getName(); } return names; }\n\n    ### Response: return all field names as String array\n\n@param clazz class to get field names from\n@return field names.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] resolveParamNames(final Method actionClassMethod) { MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); String[] names = new String[methodParameters.length]; for (int i = 0; i < methodParameters.length; i++) { names[i] = methodParameters[i].getName(); } return names; }\n\n    ### Response:", "ground_truth": "Returns method parameter names.", "predict": " return all parameter names as String array\n\n@param actionClassMethod method to resolve parameter names from\n@return parameter names."}, {"ID": 1752, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable @DevelopersNote (\"This is only for project-internal use!\") public static ISessionWebScope internalGetOrCreateSessionScope (@Nonnull final HttpSession aHttpSession, final boolean bCreateIfNotExisting, final boolean bItsOkayToCreateANewScope) { ValueEnforcer.notNull (aHttpSession, \"HttpSession\"); // Do we already have a session web scope for the session? final String sSessionID = aHttpSession.getId (); ISessionScope aSessionWebScope = ScopeSessionManager.getInstance ().getSessionScopeOfID (sSessionID); if (aSessionWebScope == null && bCreateIfNotExisting) { if (!bItsOkayToCreateANewScope) { // This can e.g. happen in tests, when there are no registered // listeners for session events! if (LOGGER.isWarnEnabled ()) LOGGER.warn (\"Creating a new session web scope for ID '\" + sSessionID + \"' but there should already be one!\" + \" Check your HttpSessionListener implementation.\"); } // Create a new session scope aSessionWebScope = onSessionBegin (aHttpSession); } try { return (ISessionWebScope) aSessionWebScope; } catch (final ClassCastException ex) { throw new IllegalStateException (\"Session scope object is not a web scope but: \" + aSessionWebScope, ex); } }\n\n    ### Response: Internal method which does the main logic for session web scope creation\n\n@param aHttpSession\nThe underlying HTTP session\n@param bCreateIfNotExisting\nif true if a new session web scope is created, if none\nis present\n@param bItsOkayToCreateANewScope\nif true no warning is emitted, if a new session scope\nmust be created. This is e.g. used when renewing a session or when\nactivating a previously passivated session.\n@return null if no session scope is present, and\nbCreateIfNotExisting is false.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void start() { initLogger(); log.info(\"PETITE start ----------\"); petiteContainer = createPetiteContainer(); if (externalsCache) { petiteContainer.setExternalsCache(TypeCache.createDefault()); } log.info(\"Web application? \" + isWebApplication); if (!isWebApplication) { // make session scope to act as singleton scope // if this is not a web application (and http session is not available). petiteContainer.registerScope(SessionScope.class, new SingletonScope(petiteContainer)); } // load parameters from properties files petiteContainer.defineParameters(joyPropsSupplier.get().getProps()); // automagic configuration if (autoConfiguration) { final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator(petiteContainer); automagicPetiteConfigurator.registerAsConsumer(joyScannerSupplier.get().getClassScanner()); } petiteContainerConsumers.accept(this.petiteContainer); log.info(\"PETITE OK!\"); }\n\n    ### Response:", "ground_truth": "Creates and initializes Petite container.\nIt will be auto-magically configured by scanning the classpath.", "predict": " Initializes the PETITE container and starts the application.\n\n@param externalsCache\nif true, the externals cache is enabled, which caches the externalized objects to avoid re-externalizing them.\n@param isWebApplication\nif true, the application is a web application and the session scope is registered as a singleton scope.\n@param autoConfiguration\nif true, the automagic configuration is enabled, which automatically configures the PETITE container based on the scanned classes.\n@param petiteContainerConsumers\na consumer that can register additional consumers to the PETITE container."}, {"ID": 1753, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void stop() throws Exception { if (this.serverChannel != null) { this.serverChannel.close().awaitUninterruptibly(); this.serverChannel = null; } if (bootstrap != null) { if (bootstrap.group() != null) { bootstrap.group().shutdownGracefully(); } bootstrap = null; } }\n\n    ### Response: Stops the artifact server.\n@throws Exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void stop() { if (log != null) { log.info(\"PETITE stop\"); } if (petiteContainer != null) { petiteContainer.shutdown(); } petiteContainer = null; }\n\n    ### Response:", "ground_truth": "Stops Petite container.", "predict": " Stops the artifact server.\n\n    "}, {"ID": 1754, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter subject(final String subject) { final SearchTerm subjectTerm = new SubjectTerm(subject); concat(subjectTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for SUBJECT field.\n\n@param subject The SUBJECT.\n@return this", "predict": " Add a subject filter to the email filter.\n\n@param subject\nthe subject to filter on.\n@return\nthe updated email filter."}, {"ID": 1755, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter messageId(final String messageId) { final SearchTerm msgIdTerm = new MessageIDTerm(messageId); concat(msgIdTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for message id.\n\n@param messageId The message ID.\n@return this", "predict": " Message ID filter.\n\n@param messageId\nthe message ID to filter on.\n@return\nthe updated EmailFilter object.\n\n    "}, {"ID": 1756, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter from(final String fromAddress) { final SearchTerm fromTerm = new FromStringTerm(fromAddress); concat(fromTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for FROM field.\n\n@param fromAddress The FROM address\n@return this", "predict": " Add a filter to the email search to only include emails from the specified address.\n\n@param fromAddress\nthe email address to filter by\n@return\nthe updated EmailFilter object\n\n    "}, {"ID": 1757, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static SecurityBreachHandler createBreachHandler(Main main, SystemMail systemMail, String toAddress) throws IllegalAccessException { if (!exists) { SecurityBreachHandler breachHandler = new SecurityBreachHandler(main, systemMail, toAddress); exists = true; return breachHandler; } throw new IllegalAccessException(\"Cannot create more than one instance of SecurityBreachHandler\"); }\n\n    ### Response: Creates a SecurityBreachHandler. There can only be one single SecurityBreachHandler, so calling this method twice\nwill cause an illegal access exception.\n\n@param main the main instance of izou\n@param systemMail the system mail object in order to send e-mails to owner in case of emergency\n@param toAddress the email address to send error reports to\n@return an SecurityBreachHandler\n@throws IllegalAccessException thrown if this method is called more than once.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter to(final String toAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, toAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for TO field.\n\n@param toAddress The TO address.\n@return this", "predict": " Adds a recipient to the email filter.\n\n@param toAddress the email address to add to the filter\n@return the email filter with the recipient added\n\n    "}, {"ID": 1758, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter cc(final String ccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.CC, ccAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for CC field.\n\n@param ccAddress CC addreses.\n@return this", "predict": " Add a CC recipient to the search term.\n\n@param ccAddress\nthe CC recipient address.\n@return\nthe updated EmailFilter object."}, {"ID": 1759, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter bcc(final String bccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.BCC, bccAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for BCC field.\n\n@param bccAddress BCC address.\n@return this", "predict": " Add a BCC recipient to the email filter.\n\n@param bccAddress\nthe email address to add as a BCC recipient.\n@return\nthe updated email filter."}, {"ID": 1760, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @NonNull public final ItemBinding<T> bindExtra(int variableId, Object value) { if (extraBindings == null) { extraBindings = new SparseArray<>(1); } extraBindings.put(variableId, value); return this; }\n\n    ### Response: Bind an extra variable to the view with the given variable id. The same instance will be\nprovided to all views the binding is bound to..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter flags(final Flags flags, final boolean value) { final SearchTerm flagTerm = new FlagTerm(flags, value); concat(flagTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for many flags at once.\n\n@param flags The {@link Flags} to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " Add a flag term to the filter with the given flags and value. The same instance will be provided to all filters the term is added to."}, {"ID": 1761, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Flags flagList(ImapRequestLineReader request) throws ProtocolException { Flags flags = new Flags(); request.nextWordChar(); consumeChar(request, '('); CharacterValidator validator = new NoopCharValidator(); String nextWord = consumeWord(request, validator); while (!nextWord.endsWith(\")\")) { setFlag(nextWord, flags); nextWord = consumeWord(request, validator); } // Got the closing \")\", may be attached to a word. if (nextWord.length() > 1) { setFlag(nextWord.substring(0, nextWord.length() - 1), flags); } return flags; }\n\n    ### Response: Reads a \"flags\" argument from the request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter flag(final Flag flag, final boolean value) { final Flags flags = new Flags(); flags.add(flag); return flags(flags, value); }\n\n    ### Response:", "ground_truth": "Defines filter for single flag.\n\n@param flag  The flag to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " Sets the given flag to the given value.\n\n    "}, {"ID": 1762, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter receivedDate(final Operator operator, final long milliseconds) { final SearchTerm term = new ReceivedDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for received date.\n\n@return this", "predict": " Filter emails by received date.\n\n@param operator\noperator to compare the received date with\n@param milliseconds\nthe date in milliseconds\n@return the updated EmailFilter object\n\n    "}, {"ID": 1763, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter sentDate(final Operator operator, final long milliseconds) { final SearchTerm term = new SentDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for sent date.\n\n@param operator     {@link Operator} to use.\n@param milliseconds the milliseconds since January 1, 1970, 00:00:00 GMT.\n@return this", "predict": " Sent date filter.\n\n@param operator\noperator to compare the date\n@param milliseconds\ndate in milliseconds\n@return\nthe email filter with the sent date filter added\n\n    "}, {"ID": 1764, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String randomString(final int size) { final StringBuilder builder = new StringBuilder(); while (builder.length() < size) { final String suffix = java.util.UUID.randomUUID().toString().replace(\"-\", \"\"); builder.append(suffix); } return builder.substring(0, size); }\n\n    ### Response: Return a random string of a certain size.\n\n@param size the size\n@return the random size.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter size(final Operator comparison, final int size) { final SearchTerm term = new SizeTerm(comparison.value, size); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for message size.\n\n@param comparison {@link Operator}.\n@param size       size of message.\n@return this", "predict": " Add a size filter to the email filter.\n\n@param comparison the comparison operator\n@param size the size\n@return the email filter with the size filter added."}, {"ID": 1765, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String characterPad(final String s, final int fieldLength, final char padChar, final boolean postpend) { final char[] chArr = s.toCharArray(); final int sLen = chArr.length; if (sLen < fieldLength) { final char[] out = new char[fieldLength]; final int blanks = fieldLength - sLen; if (postpend) { for (int i = 0; i < sLen; i++) { out[i] = chArr[i]; } for (int i = sLen; i < fieldLength; i++) { out[i] = padChar; } } else { //prepend for (int i = 0; i < blanks; i++) { out[i] = padChar; } for (int i = blanks; i < fieldLength; i++) { out[i] = chArr[i - blanks]; } } return String.valueOf(out); } return s; }\n\n    ### Response: Prepend or postpend the given string with the given character to fill the given field length.\nIf the given string is equal or greater than the given field length, it will be returned\nwithout modification.\n@param s the given string\n@param fieldLength the desired field length\n@param padChar the desired pad character\n@param postpend if true append the pacCharacters to the end of the string.\n@return prepended or postpended given string with the given character to fill the given field\nlength..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter and(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new AndTerm(searchTerms)); return this; }\n\n    ### Response:", "ground_truth": "Defines AND group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to AND.\n@return this", "predict": " Adds the given email filters to the current filter using the AND operator.\n@param emailFilters the email filters to add\n@return the updated email filter\n\n    "}, {"ID": 1766, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final String characterPad(final String s, final int fieldLength, final char padChar, final boolean postpend) { final char[] chArr = s.toCharArray(); final int sLen = chArr.length; if (sLen < fieldLength) { final char[] out = new char[fieldLength]; final int blanks = fieldLength - sLen; if (postpend) { for (int i = 0; i < sLen; i++) { out[i] = chArr[i]; } for (int i = sLen; i < fieldLength; i++) { out[i] = padChar; } } else { //prepend for (int i = 0; i < blanks; i++) { out[i] = padChar; } for (int i = blanks; i < fieldLength; i++) { out[i] = chArr[i - blanks]; } } return String.valueOf(out); } return s; }\n\n    ### Response: Prepend or postpend the given string with the given character to fill the given field length.\nIf the given string is equal or greater than the given field length, it will be returned\nwithout modification.\n@param s the given string\n@param fieldLength the desired field length\n@param padChar the desired pad character\n@param postpend if true append the pacCharacters to the end of the string.\n@return prepended or postpended given string with the given character to fill the given field\nlength..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter or(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new OrTerm(searchTerms)); return this; }\n\n    ### Response:", "ground_truth": "Defines OR group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to OR.\n@return this", "predict": " Adds the given email filters to the current filter using the OR operator.\n@param emailFilters the email filters to add\n@return the updated email filter\n\n    "}, {"ID": 1767, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Experimental(name = \"validActivationEmail\") @RetryOnFailure(attempts = 3, delay = 60) @Conditioned @Et(\"Je valide le mail d'activation '(.*)'[\\\\.|\\\\?]\") @And(\"I valid activation email '(.*)'[\\\\.|\\\\?]\") public void validActivationEmail(String mailHost, String mailUser, String mailPassword, String senderMail, String subjectMail, String firstCssQuery, List<GherkinStepCondition> conditions) throws FailureException, TechnicalException { try { final Properties props = System.getProperties(); props.setProperty(\"mail.store.protocol\", \"imap\"); final Session session = Session.getDefaultInstance(props, null); final Store store = session.getStore(\"imaps\"); store.connect(mailHost, mailUser, mailPassword); final Folder inbox = store.getFolder(\"Inbox\"); inbox.open(Folder.READ_ONLY); final SearchTerm filterA = new FlagTerm(new Flags(Flags.Flag.SEEN), false); final SearchTerm filterB = new FromTerm(new InternetAddress(senderMail)); final SearchTerm filterC = new SubjectTerm(subjectMail); final SearchTerm[] filters = { filterA, filterB, filterC }; final SearchTerm searchTerm = new AndTerm(filters); final Message[] messages = inbox.search(searchTerm); for (final Message message : messages) { validateActivationLink(subjectMail, firstCssQuery, message); } } catch (final Exception e) { new Result.Failure<>(\"\", Messages.format(Messages.getMessage(Messages.FAIL_MESSAGE_MAIL_ACTIVATION), subjectMail), false, Context.getCallBack(Callbacks.RESTART_WEB_DRIVER)); } }\n\n    ### Response: Valid activation email.\n\n@param mailHost\nexample: imap.gmail.com\n@param mailUser\nlogin of mail box\n@param mailPassword\npassword of mail box\n@param firstCssQuery\nthe first matching element\n@param conditions\nlist of 'expected' values condition and 'actual' values ({@link com.github.noraui.gherkin.GherkinStepCondition}).\n@throws TechnicalException\nis throws if you have a technical error (format, configuration, datas, ...) in NoraUi.\nException with message and with screenshot and with exception if functional error but no screenshot and no exception if technical error.\n@throws FailureException\nif the scenario encounters a functional error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter not(final EmailFilter emailFilter) { final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm); concat(searchTerm); return this; }\n\n    ### Response:", "ground_truth": "Appends single filter as NOT.\n\n@param emailFilter {@link EmailFilter} to append.\n@return this", "predict": " Negates the filter.\n\n@param emailFilter\nthe filter to negate\n@return\nthe negated filter\n\n    "}, {"ID": 1768, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function(array, property, searchTerm) { for (var i = 0, len = array.length; i < len; ++i) { var value = array[i][property]; if (value === searchTerm || value.indexOf(searchTerm) !== -1) { return i }; } return -1; }\n\n    ### Response: Return index of array on search by term in specific property.\n\n@param  {Array} array\n@param  {String} property\n@param  {String} searchTerm\n@return {Integer} Index.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void concat(SearchTerm searchTerm) { if (nextIsNot) { searchTerm = new NotTerm(searchTerm); nextIsNot = false; } if (operatorAnd) { and(searchTerm); } else { or(searchTerm); } }\n\n    ### Response:", "ground_truth": "Concatenates last search term with new one.\n\n@param searchTerm searchTerm {@link SearchTerm} concatenate.\n@see #and(SearchTerm)\n@see #or(SearchTerm)", "predict": " Concatenate search term with current search term.\n\n@param  {SearchTerm} searchTerm\n@return {void}\n\n    "}, {"ID": 1769, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static byte[] decodeBase32(String str) { // each base-32 character encodes 5 bits int numBytes = ((str.length() * 5) + 7) / 8; byte[] result = new byte[numBytes]; int resultIndex = 0; int which = 0; int working = 0; for (int i = 0; i < str.length(); i++) { char ch = str.charAt(i); int val; if (ch >= 'a' && ch <= 'z') { val = ch - 'a'; } else if (ch >= 'A' && ch <= 'Z') { val = ch - 'A'; } else if (ch >= '2' && ch <= '7') { val = 26 + (ch - '2'); } else if (ch == '=') { // special case which = 0; break; } else { throw new IllegalArgumentException(\"Invalid base-32 character: \" + ch); } /* * There are probably better ways to do this but this seemed the most straightforward. */ switch (which) { case 0: // all 5 bits is top 5 bits working = (val & 0x1F) << 3; which = 1; break; case 1: // top 3 bits is lower 3 bits working |= (val & 0x1C) >> 2; result[resultIndex++] = (byte) working; // lower 2 bits is upper 2 bits working = (val & 0x03) << 6; which = 2; break; case 2: // all 5 bits is mid 5 bits working |= (val & 0x1F) << 1; which = 3; break; case 3: // top 1 bit is lowest 1 bit working |= (val & 0x10) >> 4; result[resultIndex++] = (byte) working; // lower 4 bits is top 4 bits working = (val & 0x0F) << 4; which = 4; break; case 4: // top 4 bits is lowest 4 bits working |= (val & 0x1E) >> 1; result[resultIndex++] = (byte) working; // lower 1 bit is top 1 bit working = (val & 0x01) << 7; which = 5; break; case 5: // all 5 bits is mid 5 bits working |= (val & 0x1F) << 2; which = 6; break; case 6: // top 2 bits is lowest 2 bits working |= (val & 0x18) >> 3; result[resultIndex++] = (byte) working; // lower 3 bits of byte 6 is top 3 bits working = (val & 0x07) << 5; which = 7; break; case 7: // all 5 bits is lower 5 bits working |= (val & 0x1F); result[resultIndex++] = (byte) working; which = 0; break; } } if (which != 0) { result[resultIndex++] = (byte) working; } if (resultIndex != result.length) { result = Arrays.copyOf(result, resultIndex); } return result; }\n\n    ### Response: Decode base-32 method. I didn't want to add a dependency to Apache Codec just for this decode method. Exposed for\ntesting..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode(final byte[] bytes) { StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i < bytes.length) { // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] & 255; base32.append(CHARS[currByte >> 3]); digit = (currByte & 7) << 2; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 6)]); base32.append(CHARS[(currByte >> 1) & 31]); digit = (currByte & 1) << 4; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 4)]); digit = (currByte & 15) << 1; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 7)]); base32.append(CHARS[(currByte >> 2) & 31]); digit = (currByte & 3) << 3; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 5)]); base32.append(CHARS[currByte & 31]); } return base32.toString(); }\n\n    ### Response:", "ground_truth": "Encode an array of binary bytes into a Base32 string.", "predict": " Encode method. This method takes a byte array and encodes it as a base-32 string. The method uses a StringBuilder to build the base-32 string. The method uses a loop to iterate through the bytes of the input array. The loop uses bitwise operations to extract the 5-bit chunks from the bytes and insert them into the base-32 string. The loop also uses bitwise operations to insert the appropriate number of padding characters at the end of the base-32 string. The method returns the base-32 string."}, {"ID": 1770, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Object toSafeJsonValue(Object value) { if (value == null) { return null; } else { if (value instanceof Boolean || value instanceof String || value instanceof Number) { return value; } if (value instanceof Iterable) { Iterable iterable = (Iterable) value; List answer = new ArrayList<>(); for (Object item : iterable) { Object itemJson = toSafeJsonValue(item); if (itemJson != null) { answer.add(itemJson); } } return answer; } if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } value = Proxies.unwrap(value); if (value instanceof ProjectProvider) { ProjectProvider projectProvider = (ProjectProvider) value; return projectProvider.getType(); } if (value instanceof ProjectType) { ProjectType projectType = (ProjectType) value; return projectType.getType(); } if (value instanceof StackFacet) { StackFacet stackFacet = (StackFacet) value; Stack stack = stackFacet.getStack(); if (stack != null) { return stack.getName(); } else { return null; } } if (isJsonObject(value)) { return value; } return value.toString(); } }\n\n    ### Response: Lets return a safe JSON value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected byte[] convertValueToArray(final Object value) { if (value instanceof Blob) { final Blob blob = (Blob) value; try { final long length = blob.length(); if (length > Integer.MAX_VALUE) { throw new TypeConversionException(\"Blob is too big.\"); } return blob.getBytes(1, (int) length); } catch (SQLException sex) { throw new TypeConversionException(value, sex); } } if (value instanceof File) { try { return FileUtil.readBytes((File) value); } catch (IOException ioex) { throw new TypeConversionException(value, ioex); } } if (value instanceof Collection) { final Collection collection = (Collection) value; final byte[] target = new byte[collection.size()]; int i = 0; for (final Object element : collection) { target[i] = convertType(element); i++; } return target; } if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final ArrayList<Byte> byteArrayList = new ArrayList<>(); for (final Object element : iterable) { final byte convertedValue = convertType(element); byteArrayList.add(Byte.valueOf(convertedValue)); } final byte[] array = new byte[byteArrayList.size()]; for (int i = 0; i < byteArrayList.size(); i++) { final Byte b = byteArrayList.get(i); array[i] = b.byteValue(); } return array; } if (value instanceof CharSequence) { final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS); return convertArrayToArray(strings); } // everything else: return convertToSingleElementArray(value); }\n\n    ### Response:", "ground_truth": "Converts non-array value to array. Detects various\ntypes and collections, iterates them to make conversion\nand to create target array.", "predict": " Converts a value to an array of bytes.\n\n    "}, {"ID": 1771, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean mergeEffects(String expr, Effect[] effects, float[] results) { boolean result; if (expr.equals(\"some(where (p_eft == allow))\")) { result = false; for (Effect eft : effects) { if (eft == Effect.Allow) { result = true; break; } } } else if (expr.equals(\"!some(where (p_eft == deny))\")) { result = true; for (Effect eft : effects) { if (eft == Effect.Deny) { result = false; break; } } } else if (expr.equals(\"some(where (p_eft == allow)) && !some(where (p_eft == deny))\")) { result = false; for (Effect eft : effects) { if (eft == Effect.Allow) { result = true; } else if (eft == Effect.Deny) { result = false; break; } } } else if (expr.equals(\"priority(p_eft) || deny\")) { result = false; for (Effect eft : effects) { if (eft != Effect.Indeterminate) { if (eft == Effect.Allow) { result = true; } else { result = false; } break; } } } else { throw new Error(\"unsupported effect\"); } return result; }\n\n    ### Response: mergeEffects merges all matching results collected by the enforcer into a single decision..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean isGzipEligible(final HttpServletRequest request) { // request parameter name if (requestParameterName.length() != 0) { String forceGzipString = request.getParameter(requestParameterName); if (forceGzipString != null) { return Converter.get().toBooleanValue(forceGzipString, false); } } // extract uri String uri = request.getRequestURI(); if (uri == null) { return false; } uri = uri.toLowerCase(); boolean result = false; // check uri if (matches == null) { // match == * if (extensions == null) { // extensions == * return true; } // extension String extension = FileNameUtil.getExtension(uri); if (extension.length() > 0) { extension = extension.toLowerCase(); if (StringUtil.equalsOne(extension, extensions) != -1) { result = true; } } } else { if (wildcards) { result = Wildcard.matchPathOne(uri, matches) != -1; } else { for (String match : matches) { if (uri.contains(match)) { result = true; break; } } } } if ((result) && (excludes != null)) { if (wildcards) { if (Wildcard.matchPathOne(uri, excludes) != -1) { result = false; } } else { for (String exclude : excludes) { if (uri.contains(exclude)) { result = false; // excludes founded break; } } } } return result; }\n\n    ### Response:", "ground_truth": "Determine if request is eligible for GZipping.", "predict": " isGzipEligible checks if the request should be compressed using gzip.\n\n    "}, {"ID": 1772, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initialize(ControlBean bean, Object target) { initServices(bean, target); initControls(bean, target); initEventProxies(bean, target); }\n\n    ### Response: Initializes a new ControlImplementation instance associated with the specified bean..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Violation> validate(final Object target) { return validate(ValidationContext.resolveFor(target.getClass()), target); }\n\n    ### Response:", "ground_truth": "Validate object using context from the annotations.", "predict": " Validates the specified target object using the default validation context and returns a list of violations.\n\n    "}, {"ID": 1773, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Pure @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\"}) public static String[] getAllCommandLineParameters() { final int osize = commandLineOptions == null ? 0 : commandLineOptions.size(); final int psize = commandLineParameters == null ? 0 : commandLineParameters.length; final int tsize = (osize > 0 && psize > 0) ? 1 : 0; final List<String> params = new ArrayList<>(osize + tsize); if (osize > 0) { List<Object> values; String name; String prefix; String v; for (final Entry<String, List<Object>> entry : commandLineOptions.entrySet()) { name = entry.getKey(); prefix = (name.length() > 1) ? \"--\" : \"-\"; //$NON-NLS-1$ //$NON-NLS-2$ values = entry.getValue(); if (values == null || values.isEmpty()) { params.add(prefix + name); } else { for (final Object value : values) { if (value != null) { v = value.toString(); if (v != null && v.length() > 0) { params.add(prefix + name + \"=\" + v); //$NON-NLS-1$ } else { params.add(prefix + name); } } } } } } if (tsize > 0) { params.add(\"--\"); //$NON-NLS-1$ } final String[] tab = new String[params.size() + psize]; params.toArray(tab); params.clear(); if (psize > 0) { System.arraycopy(commandLineParameters, 0, tab, osize + tsize, psize); } return tab; }\n\n    ### Response: Replies the command line including the options and the standard parameters.\n\n@return  the command line..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) { for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) { String name = entry.getKey(); Object value = BeanUtil.declaredSilent.getProperty(target, name); String valueName = targetName != null ? (targetName + '.' + name) : name; // move up ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName); for (Check check : entry.getValue()) { String[] checkProfiles = check.getProfiles(); if (!matchProfiles(checkProfiles)) { continue; } if (check.getSeverity() < severity) { continue; } ValidationConstraint constraint = check.getConstraint(); if (!constraint.isValid(vcc, value)) { addViolation(new Violation(valueName, target, value, check)); } } } return getViolations(); }\n\n    ### Response:", "ground_truth": "Performs validation of provided validation context and appends violations.", "predict": " Validates the given target object against the validation constraints defined in the validation context.\n\n@param ctx the validation context\n@param target the target object to be validated\n@param targetName the name of the target object\n@return the list of violations found during validation\n\n    "}, {"ID": 1774, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean supports(ServiceProfile profile) { if (profile == null) { return false; } if (supportedServiceProfiles == null) { return false; } for (ServiceProfile supportedProfile : supportedServiceProfiles) { if (supportedProfile == profile) { return true; } } return false; }\n\n    ### Response: Check if this service supports the specified profile.\n\nIf {@code null} is given, {@code false} is returned.\nIf the supported service profiles are not set to this service,\n{@code false} is returned.\n\n@param profile\nA service profile.\n\n@return\n{@code true} if this service supports the service profile.\n\n@since 2.12.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useProfile(final String profile) { if (profile == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } this.enabledProfiles.add(profile); }\n\n    ### Response:", "ground_truth": "Enables single profile.", "predict": " Enable the specified profile for this service.\n\nIf {@code null} is given, nothing is done.\nIf the enabled profiles are not set for this service, a new set is created.\n\n@param profile\nA profile to enable."}, {"ID": 1775, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void excludeClass(String... classNames) { if (classNames == null) { excludeClassNames = null; } else { for (String className : classNames) { if (!isExcludePackage(className)) { if (excludeClassNames == null) { excludeClassNames = new HashSet<>(); } excludeClassNames.add(className); } } } }\n\n    ### Response: Adds classes that this ClassLoader should not handle.\nAny class whose fully-qualified name starts with the name registered here will be handled\nby the parent ClassLoader in the usual fashion.\n\n@param classNames class names that we be compared against fully qualified class names to exclude.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useProfiles(final String... enabledProfiles) { if (enabledProfiles == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } Collections.addAll(this.enabledProfiles, enabledProfiles); }\n\n    ### Response:", "ground_truth": "Enables list of profiles.", "predict": " Sets the enabled profiles for this application.\n\n@param enabledProfiles the enabled profiles for this application."}, {"ID": 1776, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isExplicitlyRequested(String candidate, String... indices) { boolean result = false; for (String indexOrAlias : indices) { boolean include = true; if (indexOrAlias.charAt(0) == '+' || indexOrAlias.charAt(0) == '-') { include = indexOrAlias.charAt(0) == '+'; indexOrAlias = indexOrAlias.substring(1); } if (indexOrAlias.equals(\"*\") || indexOrAlias.equals(\"_all\")) { return false; } if (Regex.isSimpleMatchPattern(indexOrAlias)) { if (Regex.simpleMatch(indexOrAlias, candidate)) { if (include) { result = true; } else { return false; } } } else { if (candidate.equals(indexOrAlias)) { if (include) { result = true; } else { return false; } } } } return result; }\n\n    ### Response: Checks if the provided candidate is explicitly contained in the provided indices..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean matchProfiles(final String[] checkProfiles) { // test for all profiles if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) { return true; } if (enabledProfiles == null || enabledProfiles.isEmpty()) { if (validateAllProfilesByDefault) { return true; // all profiles are considered as enabled } // only default profile is enabled if ((checkProfiles == null) || (checkProfiles.length == 0)) { return true; } for (String profile : checkProfiles) { if (StringUtil.isEmpty(profile)) { return true; // default profile } if (profile.equals(DEFAULT_PROFILE)) { return true; } } return false; } // there are enabled profiles if ((checkProfiles == null) || (checkProfiles.length == 0)) { return enabledProfiles.contains(DEFAULT_PROFILE); } boolean result = false; for (String profile : checkProfiles) { boolean b = true; boolean must = false; if (StringUtil.isEmpty(profile)) { profile = DEFAULT_PROFILE; } else if (profile.charAt(0) == '-') { profile = profile.substring(1); b = false; } else if (profile.charAt(0) == '+') { profile = profile.substring(1); must = true; } if (enabledProfiles.contains(profile)) { if (!b) { return false; } result = true; } else { if (must) { return false; } } } return result; }\n\n    ### Response:", "ground_truth": "Determine if any of checks profiles is among enabled profiles.", "predict": " Matches the provided checkProfiles with the enabled profiles.\n\n    "}, {"ID": 1777, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable protected <T> T convert(Object source, Class<T> targetType) { return this.conversionService.convert(source, targetType); }\n\n    ### Response: Convert given object into target type\n\n@param source\n@param targetType\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object parseRequestBody(final String body, final Class targetType) { return JsonParser.create().parse(body, targetType); }\n\n    ### Response:", "ground_truth": "Parses request body into the target type.", "predict": " Parse the given JSON string into the target type\n\n@param body\n@param targetType\n@return."}, {"ID": 1778, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Long getApproximateZoomLevel(double[] lengths, List<TileMatrix> tileMatrices, double length) { Long lengthZoomLevel = null; double minLength = lengths[0]; double maxLength = lengths[lengths.length - 1]; // Length is zoomed in further than available tiles if (length < minLength) { double levelsIn = Math.log(length / minLength) / Math.log(.5); long zoomAbove = (long) Math.floor(levelsIn); long zoomBelow = (long) Math.ceil(levelsIn); double lengthAbove = minLength * Math.pow(.5, zoomAbove); double lengthBelow = minLength * Math.pow(.5, zoomBelow); lengthZoomLevel = tileMatrices.get(tileMatrices.size() - 1) .getZoomLevel(); if (lengthAbove - length <= length - lengthBelow) { lengthZoomLevel += zoomAbove; } else { lengthZoomLevel += zoomBelow; } } // Length is zoomed out further than available tiles else if (length > maxLength) { double levelsOut = Math.log(length / maxLength) / Math.log(2); long zoomAbove = (long) Math.ceil(levelsOut); long zoomBelow = (long) Math.floor(levelsOut); double lengthAbove = maxLength * Math.pow(2, zoomAbove); double lengthBelow = maxLength * Math.pow(2, zoomBelow); lengthZoomLevel = tileMatrices.get(0).getZoomLevel(); if (length - lengthBelow <= lengthAbove - length) { lengthZoomLevel -= zoomBelow; } else { lengthZoomLevel -= zoomAbove; } } // Length is between the available tiles else { int lengthIndex = Arrays.binarySearch(lengths, length); if (lengthIndex < 0) { lengthIndex = (lengthIndex + 1) * -1; } double zoomDistance = Math.log(length / lengths[lengthIndex]) / Math.log(.5); long zoomLevelAbove = getTileMatrixAtLengthIndex(tileMatrices, lengthIndex).getZoomLevel(); zoomLevelAbove += Math.round(zoomDistance); lengthZoomLevel = zoomLevelAbove; } return lengthZoomLevel; }\n\n    ### Response: Get the approximate zoom level for length using the factor of 2 rule\nbetween zoom levels\n\n@param lengths\nsorted lengths\n@param tileMatrices\ntile matrices\n@param length\nlength in default units\n@return approximate zoom level.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long toMilliseconds() { double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY; then += (integer - JD_1970.integer) * MILLIS_IN_DAY; then += then > 0 ? 1.0e-6 : -1.0e-6; return (long) then; }\n\n    ### Response:", "ground_truth": "Converts to milliseconds.", "predict": " Convert the fractional part of the Julian Date to milliseconds since the epoch.\n\n@return milliseconds since the epoch."}, {"ID": 1779, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JulianDate date(int prolepticYear, int month, int dayOfMonth) { return JulianDate.of(prolepticYear, month, dayOfMonth); }\n\n    ### Response: Obtains a local date in Julian calendar system from the\nproleptic-year, month-of-year and day-of-month fields.\n\n@param prolepticYear  the proleptic-year\n@param month  the month-of-year\n@param dayOfMonth  the day-of-month\n@return the Julian local date, not null\n@throws DateTimeException if unable to create the date.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JulianDate add(final JulianDate jds) { int i = this.integer + jds.integer; double f = this.fraction + jds.fraction; return new JulianDate(i, f); }\n\n    ### Response:", "ground_truth": "Adds a JD to current instance.", "predict": " Adds the specified JulianDate to this instance.\n\n@param jds  the JulianDate to add, not null\n@return the result of the addition, not null"}, {"ID": 1780, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JulianDate date(int prolepticYear, int month, int dayOfMonth) { return JulianDate.of(prolepticYear, month, dayOfMonth); }\n\n    ### Response: Obtains a local date in Julian calendar system from the\nproleptic-year, month-of-year and day-of-month fields.\n\n@param prolepticYear  the proleptic-year\n@param month  the month-of-year\n@param dayOfMonth  the day-of-month\n@return the Julian local date, not null\n@throws DateTimeException if unable to create the date.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JulianDate sub(final JulianDate jds) { int i = this.integer - jds.integer; double f = this.fraction -jds.fraction; return new JulianDate(i, f); }\n\n    ### Response:", "ground_truth": "Subtracts a JD from current instance.", "predict": " Subtracts a JulianDate from this JulianDate.\n\n@param jds  the JulianDate to subtract, not null\n@return the result of the subtraction, not null"}, {"ID": 1781, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static double normInf(double[] x) { int n = x.length; double f = Math.abs(x[0]); for (int i = 1; i < n; i++) { f = Math.max(f, Math.abs(x[i])); } return f; }\n\n    ### Response: L-infinity vector norm. Maximum absolute value..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void set(final int i, double f) { integer = i; int fi = (int) f; f -= fi; integer += fi; if (f < 0) { f += 1; integer--; } this.fraction = f; }\n\n    ### Response:", "ground_truth": "Sets integer and fractional part with normalization.\nNormalization means that if double is out of range,\nvalues will be correctly fixed.", "predict": " Sets the fractional part of the decimal number.\n\n    "}, {"ID": 1782, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String readFileAsString(File file) throws java.io.IOException { StringBuilder fileData = new StringBuilder(1000); try (BufferedReader reader = new BufferedReader(ReaderFactory.newReader(file, this.encoding))) { char[] buf = new char[1024]; int numRead = 0; while ((numRead = reader.read(buf)) != -1) { String readData = String.valueOf(buf, 0, numRead); fileData.append(readData); buf = new char[1024]; } } return fileData.toString(); }\n\n    ### Response: Read the given file and return the content as a string.\n\n@param file\nthe file\n@return the string\n@throws IOException\nSignals that an I/O exception has occurred..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void initialize(final char[] input) { super.initialize(input); this.tag = new ParsedTag(); this.doctype = new ParsedDoctype(); this.text = new char[1024]; this.textLen = 0; this.parsingTime = -1; }\n\n    ### Response:", "ground_truth": "Initializes parser.", "predict": " Initializes the parser with the input character array.\n\n@param input\nthe input character array."}, {"ID": 1783, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void parse() { template = text; if (StringUtils.isEmptyTrimmed(template)) return; int index = 0; while (template.indexOf(\"${\") != -1) { int from = template.lastIndexOf(\"${\"); int to = template.indexOf(\"}\", from + 2); if (to == -1) { template = text; complex = false; entities.clear(); return; } int dv = template.indexOf(\":\", from + 2); if (dv != -1 && dv > to) { dv = -1; } String systemProperty = null; String defaultValue = null; String s = template.substring(from + 2, to); if (\"/\".equals(s)) { systemProperty = File.separator; } else if (\":\".equals(s)) { systemProperty = File.pathSeparator; dv = -1; } else { systemProperty = SecurityActions.getSystemProperty(s); } if (dv != -1) { s = template.substring(from + 2, dv); systemProperty = SecurityActions.getSystemProperty(s); defaultValue = template.substring(dv + 1, to); } String prefix = \"\"; String postfix = \"\"; String key = StringUtils.createKey(index++); updateComplex(defaultValue); entities.put(key, new Expression(s, defaultValue, systemProperty)); if (from != 0) { prefix = template.substring(0, from); } if (to + 1 < template.length()) { postfix = template.substring(to + 1); } template = prefix + key + postfix; } updateComplex(template); }\n\n    ### Response: Parse a text and get a template and expression entities.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void emitComment(final int from, final int to) { if (config.enableConditionalComments) { // CC: downlevel-hidden starting if (match(CC_IF, from)) { int endBracketNdx = find(']', from + 3, to); CharSequence expression = charSequence(from + 1, endBracketNdx); ndx = endBracketNdx + 1; char c = input[ndx]; if (c != '>') { errorInvalidToken(); } visitor.condComment(expression, true, true, false); state = DATA_STATE; return; } if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) { // CC: downlevel-hidden ending visitor.condComment(_ENDIF, false, true, true); state = DATA_STATE; return; } } CharSequence comment = charSequence(from, to); visitor.comment(comment); commentStart = -1; }\n\n    ### Response:", "ground_truth": "Emits a comment. Also checks for conditional comments!", "predict": " Emit a comment to the output.\n\n    "}, {"ID": 1784, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function _done (cb, message) { var valid = false if (typeof message === 'string') { message = [message] } else if (Object.prototype.toString.call(message) === '[object Array]') { if (message.length === 0) { valid = true } } else { valid = true } if (isFunction(cb)) { if (valid) { cb(valid, []) } else { cb(valid, message) } } return valid }\n\n    ### Response: Formats error messages, calls the callback\n@method done\n@private\n@param cb {Function} callback\n@param [message] {Function} callback\n@return {Boolean} is the object valid or not?.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void _error(String message) { if (config.calculatePosition) { Position currentPosition = position(ndx); message = message .concat(StringPool.SPACE) .concat(currentPosition.toString()); } else { message = message .concat(\" [@\") .concat(Integer.toString(ndx)) .concat(StringPool.RIGHT_SQ_BRACKET); } visitor.error(message); }\n\n    ### Response:", "ground_truth": "Prepares error message and reports it to the visitor.", "predict": " Logs an error message with the current position of the node in the input string.\n@method error\n@protected\n@param message {String} error message\n@return {Void}\n\n    "}, {"ID": 1785, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String createHash(char[] password) throws NoSuchAlgorithmException, InvalidKeySpecException { // Generate a random salt SecureRandom random = new SecureRandom(); byte[] salt = new byte[SALT_BYTE_SIZE]; random.nextBytes(salt); // Hash the password byte[] hash = pbkdf2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE); // format iterations:salt:hash return PBKDF2_ITERATIONS + \":\" + toHex(salt) + \":\" + toHex(hash); }\n\n    ### Response: Returns a salted PBKDF2 hash of the password.\n\n@param password\nthe password to hash\n@return a salted PBKDF2 hash of the password\n@throws NoSuchAlgorithmException if jdk does not support the algorithm\n@throws InvalidKeySpecException if the password or salt are invalid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String createHash(final char[] password) { // Generate a random salt SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltBytes]; random.nextBytes(salt); // Hash the password byte[] hash = pbkdf2(password, salt, pbkdf2Iterations, hashBytes); // format iterations:salt:hash return pbkdf2Iterations + \":\" + StringUtil.toHexString(salt) + \":\" + StringUtil.toHexString(hash); }\n\n    ### Response:", "ground_truth": "Returns a salted PBKDF2 hash of the password.\n\n@param password the password to hash\n@return a salted PBKDF2 hash of the password", "predict": " Returns a salted PBKDF2 hash of the password.\n\n@param password\nthe password to hash\n@return a salted PBKDF2 hash of the password\n@throws NoSuchAlgorithmException if jdk does not support the algorithm\n@throws InvalidKeySpecException if the password or salt are invalid."}, {"ID": 1786, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean validateToken(String originalToken, String storedToken) throws NoSuchAlgorithmException, InvalidKeySpecException { String[] parts = storedToken.split(\":\"); int iterations = Integer.parseInt(parts[0]); byte[] salt = fromHex(parts[1]); byte[] hash = fromHex(parts[2]); PBEKeySpec spec = new PBEKeySpec(originalToken.toCharArray(), salt, iterations, hash.length * 8); SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\"); byte[] testHash = skf.generateSecret(spec).getEncoded(); int diff = hash.length ^ testHash.length; for (int i = 0; i < hash.length && i < testHash.length; i++) { diff |= hash[i] ^ testHash[i]; } return diff == 0; }\n\n    ### Response: Implementation of PBKDF2WithHmacSHA1.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] pbkdf2(final char[] password, final byte[] salt, final int iterations, final int bytes) { PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8); try { SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM); return skf.generateSecret(spec).getEncoded(); } catch (NoSuchAlgorithmException ignore) { return null; } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } }\n\n    ### Response:", "ground_truth": "Computes the PBKDF2 hash of a password.\n\n@param password the password to hash.\n@param salt the salt\n@param iterations the iteration count (slowness factor)\n@param bytes the length of the hash to compute in bytes\n@return the PBDKF2 hash of the password", "predict": " Implementation of PBKDF2 algorithm."}, {"ID": 1787, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] asByteArray(String hex) { byte[] bts = new byte[hex.length() / 2]; for (int i = 0; i < bts.length; i++) { bts[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16); } return bts; }\n\n    ### Response: Converts a hex string representation to a byte array.\n\n@param hex the string holding the hex values\n@return the resulting byte array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] fromHex(final String hex) { final byte[] binary = new byte[hex.length() / 2]; for (int i = 0; i < binary.length; i++) { binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16); } return binary; }\n\n    ### Response:", "ground_truth": "Converts a string of hexadecimal characters into a byte array.\n\n@param hex the hex string\n@return the hex string decoded into a byte array", "predict": " Converts a hex string representation to a byte array.\n\n@param hex the string holding the hex values\n@return the resulting byte array."}, {"ID": 1788, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ImageIcon loadIcon(final Class clasz, final String name) { final URL url = Utils4J.getResource(clasz, name); return new ImageIcon(url); }\n\n    ### Response: Load an icon located in the same package as a given class.\n\n@param clasz\nClass with the same package where the icon is located.\n@param name\nFilename of the icon.\n\n@return New icon instance..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProviderDefinition[] resolveProviderDefinitions(final Class type, final String name) { return providerResolver.resolve(type, name); }\n\n    ### Response:", "ground_truth": "Resolves provider definition defined in a bean.", "predict": " Resolves provider definitions for a given type and name.\n\n@param type\nType of the provider to resolve.\n@param name\nName of the provider to resolve.\n\n@return Array of provider definitions."}, {"ID": 1789, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static <T> String name(T item, String name) { if (name != null && !name.isEmpty()) { return name; } else if (item instanceof HasMetadata) { HasMetadata h = (HasMetadata) item; return h.getMetadata() != null ? h.getMetadata().getName() : null; } return null; }\n\n    ### Response: Returns the name and falls back to the item name.\n@param item  The item.\n@param name  The name to check.\n@param \n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailAttachmentBuilder name(final String name) { if (name != null && !name.trim().isEmpty()) { this.name = name; } return this; }\n\n    ### Response:", "ground_truth": "Sets file name.\n\n@param name File name to set.\n@return this", "predict": " Sets the name of the attachment.\n@param name  The name of the attachment.\n@return  The EmailAttachmentBuilder instance."}, {"ID": 1790, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String stringify() { if (type == TokenType.TEXT) { return defaultValue; } StringBuilder sb = new StringBuilder(); if (type == TokenType.BEAN) { sb.append(BEAN_SYMBOL); sb.append(START_BRACKET); if (name != null) { sb.append(name); } if (value != null) { sb.append(VALUE_SEPARATOR); sb.append(value); } if (getterName != null) { sb.append(GETTER_SEPARATOR); sb.append(getterName); } } else if (type == TokenType.TEMPLATE) { sb.append(TEMPLATE_SYMBOL); sb.append(START_BRACKET); if (name != null) { sb.append(name); } } else if (type == TokenType.PARAMETER) { sb.append(PARAMETER_SYMBOL); sb.append(START_BRACKET); if (name != null) { sb.append(name); } } else if (type == TokenType.ATTRIBUTE) { sb.append(ATTRIBUTE_SYMBOL); sb.append(START_BRACKET); if (name != null) { sb.append(name); } if (getterName != null) { sb.append(GETTER_SEPARATOR); sb.append(getterName); } } else if (type == TokenType.PROPERTY) { sb.append(PROPERTY_SYMBOL); sb.append(START_BRACKET); if (name != null) { sb.append(name); } if (value != null) { sb.append(VALUE_SEPARATOR); sb.append(value); } if (getterName != null) { sb.append(GETTER_SEPARATOR); sb.append(getterName); } } else { throw new InvalidTokenException(\"Unknown token type: \" + type, this); } if (defaultValue != null) { sb.append(VALUE_SEPARATOR); sb.append(defaultValue); } sb.append(END_BRACKET); return sb.toString(); }\n\n    ### Response: Convert a Token object into a string.\n\n@return a string representation of the token.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected EmailAttachmentBuilder setContentIdFromNameIfMissing() { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; }\n\n    ### Response:", "ground_truth": "Set content ID if it is missing.\n\n@return this\n@see #contentId(String)", "predict": " Set the content ID of the attachment to the name of the file if it is missing.\n\n@return the EmailAttachmentBuilder instance."}, {"ID": 1791, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String truncate(String contentType) { if (contentType == null) { contentType = NO_TYPE_MIMETYPE; } else { Matcher matcher = TRUNCATION_REGEX.matcher(contentType); if (matcher.matches()) { contentType = matcher.group(1); } else { contentType = NO_TYPE_MIMETYPE; } } return contentType; }\n\n    ### Response: Truncate passed mimetype.\n\nEnsure no spaces.  Strip encoding.  Truncation required by\nARC files.\n\nTruncate at delimiters [;, ].\nTruncate multi-part content type header at ';'.\nApache httpclient collapses values of multiple instances of the\nheader into one comma-separated value,therefore truncated at ','.\nCurrent ia_tools that work with arc files expect 5-column\nspace-separated meta-lines, therefore truncate at ' '.\n\n@param contentType Raw content-type.\n\n@return Computed content-type made from passed content-type after\nrunning it through a set of rules..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveContentType(final String contentType) { if (contentType != null) { return contentType; } if (name == null) { return MimeTypes.MIME_APPLICATION_OCTET_STREAM; } final String extension = FileNameUtil.getExtension(name); return MimeTypes.getMimeType(extension); }\n\n    ### Response:", "ground_truth": "Resolves content type from all data.\n\n@param contentType Content type if we know it. {@code null} is fine to use.\n@return content type", "predict": " Resolve content type from file name.\n\n@param contentType Content type from HTTP header.\n\n@return Resolved content type based on file name or default value."}, {"ID": 1792, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeMethodInfoSize() { // If this method_info must be copied from an existing one, the size computation is trivial. if (sourceOffset != 0) { // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index. return 6 + sourceLength; } // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (code.length > 0) { if (code.length > 65535) { throw new IndexOutOfBoundsException(\"Method code too large!\"); } symbolTable.addConstantUtf8(Constants.CODE); // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack, // max_locals, code_length and attributes_count, plus the bytecode and the exception table. size += 16 + code.length + Handler.getExceptionTableSize(firstHandler); if (stackMapTableEntries != null) { boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6; symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\"); // 6 header bytes and 2 bytes for number_of_entries. size += 8 + stackMapTableEntries.length; } if (lineNumberTable != null) { symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE); // 6 header bytes and 2 bytes for line_number_table_length. size += 8 + lineNumberTable.length; } if (localVariableTable != null) { symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE); // 6 header bytes and 2 bytes for local_variable_table_length. size += 8 + localVariableTable.length; } if (localVariableTypeTable != null) { symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE); // 6 header bytes and 2 bytes for local_variable_type_table_length. size += 8 + localVariableTypeTable.length; } if (firstCodeAttribute != null) { size += firstCodeAttribute.computeAttributesSize( symbolTable, code.data, code.length, maxStack, maxLocals); } } if (numberOfExceptions > 0) { symbolTable.addConstantUtf8(Constants.EXCEPTIONS); size += 8 + 2 * numberOfExceptions; } boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (defaultValue != null) { symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT); size += 6 + defaultValue.length; } if (parameters != null) { symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS); // 6 header bytes and 1 byte for parameters_count. size += 7 + parameters.length; } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; }\n\n    ### Response: Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\nnames of the attributes of this method in the constant pool.\n\n@return the size in bytes of the method_info JVMS structure..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeAttributesSize() { symbolTable.addConstantUtf8(Constants.MODULE); // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; if (packageCount > 0) { symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES); // 6 attribute header bytes, and 2 bytes for package_count. size += 8 + packageIndex.length; } if (mainClassIndex > 0) { symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS); // 6 attribute header bytes, and 2 bytes for main_class_index. size += 8; } return size; }\n\n    ### Response:", "ground_truth": "Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\nModuleWriter. Also add the names of these attributes in the constant pool.\n\n@return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.", "predict": " Returns the size of the attributes JVMS structure generated by this ModuleWriter. Also add the names of the attributes in the constant pool.\n\n@return the size in bytes of the attributes JVMS structure."}, {"ID": 1793, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int type) { // creates and/or resizes the output stack array if necessary if (outputStack == null) { outputStack = new int[10]; } int n = outputStack.length; if (outputStackTop >= n) { int[] t = new int[Math.max(outputStackTop + 1, 2 * n)]; System.arraycopy(outputStack, 0, t, 0, n); outputStack = t; } // pushes the type on the output stack outputStack[outputStackTop++] = type; // updates the maximun height reached by the output stack, if needed int top = owner.inputStackTop + outputStackTop; if (top > owner.outputStackMax) { owner.outputStackMax = top; } }\n\n    ### Response: Pushes a new type onto the output frame stack.\n\n@param type the type that must be pushed..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putAttributes(final ByteVector output) { // 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; output .putShort(symbolTable.addConstantUtf8(Constants.MODULE)) .putInt(moduleAttributeLength) .putShort(moduleNameIndex) .putShort(moduleFlags) .putShort(moduleVersionIndex) .putShort(requiresCount) .putByteArray(requires.data, 0, requires.length) .putShort(exportsCount) .putByteArray(exports.data, 0, exports.length) .putShort(opensCount) .putByteArray(opens.data, 0, opens.length) .putShort(usesCount) .putByteArray(usesIndex.data, 0, usesIndex.length) .putShort(providesCount) .putByteArray(provides.data, 0, provides.length); if (packageCount > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)) .putInt(2 + packageIndex.length) .putShort(packageCount) .putByteArray(packageIndex.data, 0, packageIndex.length); } if (mainClassIndex > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)) .putInt(2) .putShort(mainClassIndex); } }\n\n    ### Response:", "ground_truth": "Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\nin the given ByteVector.\n\n@param output where the attributes must be put.", "predict": " Adds the module attribute to the constant pool of the given output byte vector.\n\n@param output the output byte vector where the module attribute must be added."}, {"ID": 1794, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(String scheme, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(scheme, encoding, HierarchicalUriComponents.Type.SCHEME); }\n\n    ### Response: Encodes the given URI scheme with the given encoding.\n@param scheme the scheme to be encoded\n@param encoding the character encoding to encode to\n@return the encoded scheme\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(final String source, final String encoding) { return decode(source, encoding, false); }\n\n    ### Response:", "ground_truth": "Decodes URL elements. This method may be used for all\nparts of URL, except for the query parts, since it does\nnot decode the '+' character.\n@see #decodeQuery(String, String)", "predict": " Decodes the given source string with the given encoding.\n@param source the source string to be decoded\n@param encoding the character encoding to decode with\n@param isPath whether the source string represents a path or not\n@return the decoded string\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    "}, {"ID": 1795, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(String scheme, String encoding) throws UnsupportedEncodingException { return HierarchicalUriComponents.encodeUriComponent(scheme, encoding, HierarchicalUriComponents.Type.SCHEME); }\n\n    ### Response: Encodes the given URI scheme with the given encoding.\n@param scheme the scheme to be encoded\n@param encoding the character encoding to encode to\n@return the encoded scheme\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decodeQuery(final String source, final String encoding) { return decode(source, encoding, true); }\n\n    ### Response:", "ground_truth": "Decodes query name or value.", "predict": " Decodes the given query string with the given encoding.\n@param source the query string to be decoded\n@param encoding the character encoding to decode with\n@return the decoded query string\n@throws UnsupportedEncodingException when the given encoding parameter is not supported.\n\n    "}, {"ID": 1796, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateProgress(final Table table, final int currentRow) { final TableProgressInformationPanel tableProgressInformationPanel = getTableProgressInformationPanel(table, -1); final boolean greater = tableProgressInformationPanel.setProgress(currentRow); if (!greater) { // this may happen because of the multithreaded nature of the // execution - sometimes a notification can come in later than // previous notifications return; } ProgressCounter counter = _progressTimingCounters.get(table); if (counter == null) { counter = new ProgressCounter(); final ProgressCounter previous = _progressTimingCounters.put(table, counter); if (previous != null) { counter = previous; } } final boolean log; final int previousCount = counter.get(); if (currentRow - previousCount > 1000) { log = counter.setIfSignificantToUser(currentRow); } else { log = false; } if (log) { addUserLog(\"Progress of \" + table.getName() + \": \" + formatNumber(currentRow) + \" rows processed\"); } }\n\n    ### Response: Informs the panel that the progress for a table is updated\n\n@param table\n@param currentRow.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings(\"unchecked\") public void start() { initLogger(); if (!databaseEnabled) { log.info(\"DB not enabled.\"); return; } log.info(\"DB start ----------\"); final PetiteContainer petiteContainer = joyPetiteSupplier.get().getPetiteContainer(); // connection pool connectionProvider = createConnectionProviderIfNotSupplied(); petiteContainer.addBean(beanNamePrefix() + \"pool\", connectionProvider); if (connectionProvider instanceof CoreConnectionPool) { final CoreConnectionPool pool = (CoreConnectionPool) connectionProvider; if (pool.getDriver() == null) { databaseEnabled = false; log.warn(\"DB configuration not set (\" + beanNamePrefix() + \"pool.*). DB will be disabled.\"); return; } } connectionProvider.init(); checkConnectionProvider(); // transactions manager jtxManager = createJtxTransactionManager(connectionProvider); jtxManager.setValidateExistingTransaction(true); final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager(new LeanJtxWorker(jtxManager), jtxScopePattern); AnnotationTxAdviceSupport.manager = annTxAdviceManager; // create proxy joyProxettaSupplier.get().getProxetta().withAspect(createTxProxyAspects(annTxAdviceManager.getAnnotations())); final DbSessionProvider sessionProvider = new DbJtxSessionProvider(jtxManager); // querymap final long startTime = System.currentTimeMillis(); final QueryMap queryMap = new DbPropsQueryMap(); log.debug(\"Queries loaded in \" + (System.currentTimeMillis() - startTime) + \"ms.\"); log.debug(\"Total queries: \" + queryMap.size()); // dboom dbOom = DbOom.create() .withConnectionProvider(connectionProvider) .withSessionProvider(sessionProvider) .withQueryMap(queryMap) .get(); dbOom.connect(); final DbEntityManager dbEntityManager = dbOom.entityManager(); dbEntityManager.reset(); petiteContainer.addBean(beanNamePrefix() + \"query\", dbOom.queryConfig()); petiteContainer.addBean(beanNamePrefix() + \"oom\", dbOom.config()); // automatic configuration if (autoConfiguration) { final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator(dbEntityManager, true); automagicDbOomConfigurator.registerAsConsumer( joyScannerSupplier.get().getClassScanner()); } dbEntityManagerConsumers.accept(dbEntityManager); log.info(\"DB OK!\"); }\n\n    ### Response:", "ground_truth": "Initializes database. First, creates connection pool.\nand transaction manager. Then, Jodds DbEntityManager is\nconfigured. It is also configured automagically, by scanning\nthe class path for entities.", "predict": " Initializes the database connection pool and starts the database session.\n\n@param joyPetiteSupplier\n@param joyScannerSupplier\n@param databaseEnabled\n@param autoConfiguration\n@param beanNamePrefix\n@param connectionProvider\n@param jtxManager\n@param jtxScopePattern\n@param annTxAdviceManager\n@param sessionProvider\n@param queryMap\n@param dbOom\n@param dbEntityManager\n@param dbEntityManagerConsumers."}, {"ID": 1797, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void discoverConnnectionProperties() { Connection connection = null; try { connection = getConnection(); if (connection == null) { getLogger().warn(\"Could not get a conneciton\"); return; } DatabaseMetaData meta = connection.getMetaData(); Util util = new Util(); util.setLoggerRepository(repository); if (overriddenSupportsGetGeneratedKeys != null) { supportsGetGeneratedKeys = overriddenSupportsGetGeneratedKeys .booleanValue(); } else { supportsGetGeneratedKeys = util.supportsGetGeneratedKeys(meta); } supportsBatchUpdates = util.supportsBatchUpdates(meta); dialectCode = Util.discoverSQLDialect(meta); } catch (SQLException se) { getLogger().warn(\"Could not discover the dialect to use.\", se); } finally { DBHelper.closeConnection(connection); } }\n\n    ### Response: Learn relevant information about this connection source..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void checkConnectionProvider() { final Connection connection = connectionProvider.getConnection(); try { final DatabaseMetaData databaseMetaData = connection.getMetaData(); String name = databaseMetaData.getDatabaseProductName(); String version = databaseMetaData.getDatabaseProductVersion(); if (log.isInfoEnabled()) { log.info(\"Connected to database: \" + name + \" v\" + version); } } catch (SQLException sex) { log.error(\"DB connection failed: \", sex); } finally { connectionProvider.closeConnection(connection); } }\n\n    ### Response:", "ground_truth": "Checks if connection provider can return a connection.", "predict": " Check the validity of the connection provider and get the database metadata."}, {"ID": 1798, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public MethodVisitor visitMethod(int access, final String name, String desc, String signature, String[] exceptions) { MethodVisitor mv = cv.visitMethod(access | Opcodes.ACC_SYNTHETIC, name, desc, signature, exceptions); return new LineNumberingMethodAdapter(mv, access | Opcodes.ACC_SYNTHETIC, name, desc) { @Override protected void onMethodEnter() { this.lineNumbers = LineNumberingClassAdapter.this.lineNumbers; super.onMethodEnter(); } }; }\n\n    ### Response: Visits the specified method, adding line numbering..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { // if ((access & AsmUtil.ACC_FINAL) != 0) { // return null; // skip finals // } MethodSignatureVisitor msign = createMethodSignature(access, name, desc, signature, exceptions, thisReference, this.generics); String key = ProxettaAsmUtil.createMethodSignaturesKey(access, name, desc, thisReference); methodSignatures.put(key, msign); allMethodSignatures.add(msign.getCleanSignature()); return new MethodAnnotationReader(msign); }\n\n    ### Response:", "ground_truth": "Stores method signature for target method.", "predict": " Visits the specified method, adding line numbering.."}, {"ID": 1799, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void configure() { InputStream inputStream = null; try { URL configUrl = getConfigUrl(); if (configUrl == null) { throw new ConfigurationException(\"esigate.properties configuration file \" + \"was not found in the classpath\"); } inputStream = configUrl.openStream(); Properties merged = new Properties(); if (inputStream != null) { Properties props = new Properties(); props.load(inputStream); merged.putAll(props); } configure(merged); } catch (IOException e) { throw new ConfigurationException(\"Error loading configuration\", e); } finally { try { if (inputStream != null) { inputStream.close(); } } catch (IOException e) { throw new ConfigurationException(\"failed to close stream\", e); } } }\n\n    ### Response: Loads all instances according to default configuration file..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { // prepare class annotations if (classAnnotations != null) { annotations = classAnnotations.toArray(new AnnotationInfo[0]); classAnnotations = null; } List<String> superList = new ArrayList<>(); Set<String> allInterfaces = new HashSet<>(); if (nextInterfaces != null) { allInterfaces.addAll(nextInterfaces); } // check all public super methods that are not overridden in superclass while (nextSupername != null) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex); } finally { StreamUtil.close(inputStream); } superList.add(nextSupername); superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { Collections.addAll(allInterfaces, cr.getInterfaces()); } } superClasses = superList.toArray(new String[0]); // check all interface methods that are not overridden in super-interface Set<String> todoInterfaces = new HashSet<>(allInterfaces); Set<String> newCollectedInterfaces = new HashSet<>(); while (true) { for (String next : todoInterfaces) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(next, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super interface: \" + next, ioex); } finally { StreamUtil.close(inputStream); } superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { for (String newInterface : cr.getInterfaces()) { if (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) { // new interface found newCollectedInterfaces.add(newInterface); } } } } // perform collection allInterfaces.addAll(todoInterfaces); if (newCollectedInterfaces.isEmpty()) { // no new interface found break; } todoInterfaces.clear(); todoInterfaces.addAll(newCollectedInterfaces); newCollectedInterfaces.clear(); } }\n\n    ### Response:", "ground_truth": "Stores signatures for all super public methods not already overridden by target class.\nAll this methods will be accepted for proxyfication.", "predict": " Visits the end of the class, preparing the annotations and interfaces."}, {"ID": 1800, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MethodIdentifier of(final String containingClass, final String methodName, final String signature, final boolean staticMethod) { final String returnType = JavaUtils.getReturnType(signature); final List<String> parameters = JavaUtils.getParameters(signature); return new MethodIdentifier(containingClass, methodName, parameters, returnType, staticMethod); }\n\n    ### Response: Creates an identifier of the given parameters.\n\n@param containingClass The class name\n@param methodName      The method name\n@param signature       The method signature\n@param staticMethod    If the method is static\n@return The method identifier.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MethodSignatureVisitor createMethodSignature( final int access, final String methodName, final String description, final String signature, final String[] exceptions, final String classname, final Map<String, String> declaredTypeGenerics) { MethodSignatureVisitor v = new MethodSignatureVisitor(methodName, access, classname, description, exceptions, signature, declaredTypeGenerics, this); new SignatureReader(signature != null ? signature : description).accept(v); return v; }\n\n    ### Response:", "ground_truth": "Creates method signature from method name.", "predict": " Creates a method signature visitor for the given parameters.\n\n@param access           The method access flags\n@param methodName       The method name\n@param description      The method description\n@param signature        The method signature\n@param exceptions       The method exceptions\n@param classname        The class name\n@param declaredTypeGenerics The declared type generics\n@return The method signature visitor."}, {"ID": 1801, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String getServiceName(final String methodName) { if (methodName != null) { int ndx = methodName.indexOf(this.separator); if (ndx > 0) { return methodName.substring(0, ndx); } } return methodName; }\n\n    ### Response: Get the service name from the methodNode.  JSON-RPC methods with the form\nService.method will result in \"Service\" being returned in this case.\n\n@param methodName method name\n@return the name of the service, or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toCsvString(final Object... elements) { StringBuilder line = new StringBuilder(); int last = elements.length -1; for (int i = 0; i < elements.length; i++) { if (elements[i] == null) { if (i != last) { line.append(FIELD_SEPARATOR); } continue; } String field = elements[i].toString(); // check for special cases int ndx = field.indexOf(FIELD_SEPARATOR); if (ndx == -1) { ndx = field.indexOf(FIELD_QUOTE); } if (ndx == -1) { if (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) { ndx = 1; } } if (ndx == -1) { ndx = StringUtil.indexOfChars(field, SPECIAL_CHARS); } // add field if (ndx != -1) { line.append(FIELD_QUOTE); } field = StringUtil.replace(field, StringPool.QUOTE, DOUBLE_QUOTE); line.append(field); if (ndx != -1) { line.append(FIELD_QUOTE); } // last if (i != last) { line.append(FIELD_SEPARATOR); } } return line.toString(); }\n\n    ### Response:", "ground_truth": "Parse fields as csv string,", "predict": " Convert an array of objects to a CSV string.\n\n@param elements the objects to convert\n@return the CSV string\n\n    "}, {"ID": 1802, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isFloatNoExponent(String str) { int len = str.length(); if (len == 0) { return false; } // skip first char if sign char char c = str.charAt(0); int i = ((c == '-') || (c == '+')) ? 1 : 0; // is it only a sign? if (i >= len) { return false; } boolean decimalPointFound = false; do { c = str.charAt(i); if (c == '.') { // is this a second dot? if (decimalPointFound) { return false; } decimalPointFound = true; } else if (!Character.isDigit(c)) { return false; } i++; } while (i < len); return true; }\n\n    ### Response: Checks that the string represents a floating point number that CANNOT be\nin exponential notation\n\n@param str the string to check\n\n@return boolean.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toStringArray(final String line) { List<String> row = new ArrayList<>(); boolean inQuotedField = false; int fieldStart = 0; final int len = line.length(); for (int i = 0; i < len; i++) { char c = line.charAt(i); if (c == FIELD_SEPARATOR) { if (!inQuotedField) { // ignore we are quoting addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 1; } } else if (c == FIELD_QUOTE) { if (inQuotedField) { if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) { // we are already quoting - peek to see if this is the end of the field addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 2; i++; // and skip the comma inQuotedField = false; } } else if (fieldStart == i) { inQuotedField = true; // this is a beginning of a quote fieldStart++; // move field start } } } // add last field - but only if string was not empty if (len > 0 && fieldStart <= len) { addField(row, line, fieldStart, len, inQuotedField); } return row.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Converts CSV line to string array.", "predict": " Converts a line of CSV data into an array of strings.\n\n@param line the line of CSV data to convert\n\n@return an array of strings representing the fields in the line of CSV data.\n\n    "}, {"ID": 1803, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function findReferences(schema) { if (schema.$ref) { return [schema.$ref]; } let references = []; if (schema.allOf) { references = references.concat(...schema.allOf.map(findReferences)); } if (schema.anyOf) { references = references.concat(...schema.anyOf.map(findReferences)); } if (schema.oneOf) { references = references.concat(...schema.oneOf.map(findReferences)); } if (schema.not) { references = references.concat(...findReferences(schema.not)); } // Array if (schema.items) { if (Array.isArray(schema.items)) { references = references.concat(...schema.items.map(findReferences)); } else { references = references.concat(findReferences(schema.items)); } } if (schema.additionalItems && typeof schema.additionalItems === 'object') { references = references.concat(findReferences(schema.additionalItems)); } // Object if (schema.properties) { Object.keys(schema.properties).forEach((key) => { references = references.concat(findReferences(schema.properties[key])); }); } if (schema.patternProperties) { Object.keys(schema.patternProperties).forEach((key) => { references = references.concat(findReferences(schema.patternProperties[key])); }); } if (schema.additionalProperties && typeof schema.additionalProperties === 'object') { references = references.concat(findReferences(schema.additionalProperties)); } return references; }\n\n    ### Response: Traverses the entire schema to find all of the references\n@returns array of each reference that is found in the schema.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor); if (ctorReferences == null) { continue; } if (foundedCtor != null) { throw new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName()); } foundedCtor = ctor; references = ctorReferences; } if (foundedCtor == null) { // there is no annotated constructor if (allCtors.length == 1) { foundedCtor = allCtors[0].getConstructor(); } else { foundedCtor = defaultCtor; } if (foundedCtor == null) { // no matching ctor found // still this is not an error if bean is already instantiated. return CtorInjectionPoint.EMPTY; } references = referencesResolver.readAllReferencesFromAnnotation(foundedCtor); if (references == null) { references = new BeanReferences[0]; } } return new CtorInjectionPoint(foundedCtor, references); }\n\n    ### Response:", "ground_truth": "Resolves constructor injection point from type. Looks for single annotated constructor.\nIf no annotated constructors found, the total number of constructors will be checked.\nIf there is only one constructor, that one will be used as injection point. If more\nconstructors exist, the default one will be used as injection point. Otherwise, exception\nis thrown.", "predict": " Resolves the constructor injection point for the given type.\n@param type the type for which to resolve the constructor injection point\n@param useAnnotation whether to use the annotation to resolve the constructor injection point\n@return the constructor injection point for the given type, or an empty constructor injection point if none is found and the bean is not yet instantiated"}, {"ID": 1804, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parse(RuleAppender ruleAppender) throws Exception { InputStream inputStream = null; try { ruleAppender.setNodeTracker(parser.getNodeTracker()); inputStream = ruleAppender.getInputStream(); InputSource inputSource = new InputSource(inputStream); inputSource.setSystemId(ruleAppender.getQualifiedName()); parser.parse(inputSource); } catch (Exception e) { throw new Exception(\"Error parsing aspectran configuration\", e); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { // ignore } } } }\n\n    ### Response: Parses the aspectran configuration.\n\n@param ruleAppender the rule appender\n@throws Exception the exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) { InputStream inputStream = null; try { inputStream = ClassLoaderUtil.getClassAsStream(advice); return new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(ioex); } finally { StreamUtil.close(inputStream); } }\n\n    ### Response:", "ground_truth": "Creates advice's class reader.", "predict": " Creates a class reader for the given advice class.\n\n@param advice the advice class\n@return the class reader\n@throws ProxettaException if an I/O error occurs\n\n    "}, {"ID": 1805, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassReader instance(Context context) { ClassReader instance = context.get(classReaderKey); if (instance == null) instance = new ClassReader(context, true); return instance; }\n\n    ### Response: Get the ClassReader instance for this invocation..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) { if (adviceClassReaderCache == null) { adviceClassReaderCache = TypeCache.createDefault(); } ClassReader adviceReader = adviceClassReaderCache.get(advice); if (adviceReader == null) { adviceReader = createAdviceClassReader(advice); adviceClassReaderCache.put(advice, adviceReader); } return adviceReader; }\n\n    ### Response:", "ground_truth": "Returns class reader for advice.", "predict": " Get the ClassReader instance for the given advice class. If it is not in the cache, create a new ClassReader instance for it and cache it for future use."}, {"ID": 1806, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode_password(String decoded_string, String crypto_algorithm, Map<String, String> properties) { /* * encoding process: * * -- check for empty algorithm tag * -- convert input String to byte[] UTF8 conversion code * -- encipher byte[] * -- convert byte[] to String using using base64 encoding */ StringBuilder buffer = new StringBuilder(); buffer.append(CRYPTO_ALGORITHM_STARTED); if (crypto_algorithm.length() == 0) { // crypto algorithm is empty ... don't encode password buffer.append(CRYPTO_ALGORITHM_STOPPED).append(decoded_string); } else { // encode password with specified crypto algorithm String encoded_string = null; EncryptedInfo info = null; if (decoded_string.length() > 0) { // convert decoded password string to byte[] byte[] decrypted_bytes = convert_to_bytes(decoded_string); if (decrypted_bytes.length > 0) { // encrypt decrypted password byte[] with specified crypto algorithm byte[] encrypted_bytes = null; boolean done = false; while (!done) { try { info = PasswordCipherUtil.encipher_internal(decrypted_bytes, crypto_algorithm, properties); if (info != null) { encrypted_bytes = info.getEncryptedBytes(); } done = true; } catch (InvalidPasswordCipherException e) { logger.logp(Level.SEVERE, PasswordUtil.class.getName(), \"encode_password\", \"PASSWORDUTIL_CYPHER_EXCEPTION\", e); return null; } catch (UnsupportedCryptoAlgorithmException e) { logger.logp(Level.SEVERE, PasswordUtil.class.getName(), \"encode_password\", \"PASSWORDUTIL_UNKNOWN_ALGORITHM_EXCEPTION\", e); return null; } } if ((encrypted_bytes != null) && (encrypted_bytes.length > 0)) { // convert encrypted password byte[] to viewable string encoded_string = convert_viewable_to_string(encrypted_bytes); if (encoded_string == null) { // base64 encoding failed return null; } } } } buffer.append(crypto_algorithm); String alias = (null == info) ? null : info.getKeyAlias(); if (alias != null && 0 < alias.length()) { buffer.append(':').append(alias); } buffer.append(CRYPTO_ALGORITHM_STOPPED); if ((encoded_string != null) && (encoded_string.length() > 0)) { // append encoded string buffer.append(encoded_string); } } return buffer.toString(); }\n\n    ### Response: Encode the provided string by using the specified encoding algorithm and properties\n\n@param decoded_string the string to be encoded.\n@param crypto_algorithm the algorithm to be used for encoding. The supported values are xor, aes, or hash.\n@param properties the properties for the encryption.\n@return The encoded string. null if there is any failure during encoding, or invalid or null decoded_string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encrypt(final String str) { try { byte[] utf8 = StringUtil.getBytes(str); // encode the string into bytes using utf-8 byte[] enc = ecipher.doFinal(utf8); // encrypt return Base64.encodeToString(enc); // encode bytes to base64 to get a string } catch (Throwable ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Symmetrically encrypts the string.", "predict": " Encrypt the provided string using the specified encryption algorithm and properties.\n\n@param str the string to be encrypted.\n@return The encrypted string. null if there is any failure during encryption, or invalid or null str."}, {"ID": 1807, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String decryptAndVerify(byte[] data) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, SignatureException, InvalidAlgorithmParameterException, InvalidCipherTextException, IOException { // decode base64 byte[] base64DecodedData = Base64.decode(data); // decrypt data byte[] decryptedData = decryptBytes(base64DecodedData); // parse json structure JSONObject json = new JSONObject(new String(decryptedData)); String base64Data = json.getString(\"data\"); String base64Sign = json.getString(\"signature\"); // decode base64 of the original data and signature byte[] oriData = Base64.decode(base64Data.getBytes()); byte[] signature = Base64.decode(base64Sign.getBytes()); // verify the signature boolean verifyOK = verifyData(oriData, signature); if (!verifyOK) { return null; } // return the original data return new String(oriData); }\n\n    ### Response: decrypt and verify signature of data\n\n@param data\ndata byte array to decrypt and verify\n@return original plain text\n@throws NoSuchAlgorithmException\nNoSuchAlgorithmException\n@throws NoSuchProviderException\nNoSuchProviderException\n@throws NoSuchPaddingException\nNoSuchPaddingException\n@throws InvalidKeyException\nInvalidKeyException\n@throws IllegalBlockSizeException\nIllegalBlockSizeException\n@throws BadPaddingException\nBadPaddingException\n@throws SignatureException\nSignatureException\n@throws InvalidAlgorithmParameterException\nInvalidAlgorithmParameterException\n@throws IOException\nIOException\n@throws InvalidCipherTextException\nInvalidCipherTextException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String decrypt(String str) { try { str = StringUtil.replaceChar(str, ' ', '+'); // replace spaces with chars. byte[] dec = Base64.decode(str); // decode base64 to get bytes byte[] utf8 = dcipher.doFinal(dec); // decrypt return new String(utf8, UTF_8); // decode using utf-8 } catch (Throwable ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Symmetrically decrypts the string.", "predict": " decrypt the given string\n\n@param str\nstring to decrypt\n@return decrypted string\n@throws IOException\nIOException\n@throws InvalidCipherTextException\nInvalidCipherTextException."}, {"ID": 1808, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Logger getLogger(final String consumerName) throws LoggingException { Logger log = consumerLoggingIndex.get(consumerName); if (log == null) { throw ErrorFactory .createLoggingException(ErrorKeys.LOGGING_LOGGINGFACTORY_NO_SUCH_LOGGER); } return log; }\n\n    ### Response: Returns an already created Logger.\n\n@param consumerName\nConsumer Name\n@return The referenced Logger\n\n@throws LoggingException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Logger getLogger(final String name) { if (loggers == null) { return loggerProvider.apply(name); } return loggers.computeIfAbsent(name, loggerProvider); }\n\n    ### Response:", "ground_truth": "Returns logger for given name. Repeated calls to this method with the\nsame argument should return the very same instance of the logger.", "predict": " Returns a Logger for the specified name.\n\n@param name\nThe name of the logger to retrieve.\n@return The Logger for the specified name.\n\n@throws LoggingException."}, {"ID": 1809, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String quoteNameIfNecessary(String name) { int len = name.length(); for (int i = 0; i < len; i++) { char c = name.charAt(i); if (! ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ') || (c >= '0' && c <= '9'))) { return '\"' + quoteName(name) + '\"'; } } return name; }\n\n    ### Response: Returns the name, conservatively quoting it if there are any\ncharacters that are likely to cause trouble outside of a\nquoted string, or returning it literally if it seems safe..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setName(final String name) { if (name.contains(\";\") || name.contains(\",\") || name.startsWith(\"$\")) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } for (int n = 0; n < name.length(); n++) { char c = name.charAt(n); if (c <= 0x20 || c >= 0x7f) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } } this.name = name; }\n\n    ### Response:", "ground_truth": "Sets the cookie name and checks for validity.", "predict": " Sets the name of the cookie. If the name contains a semicolon, comma, or starts with a dollar sign, an IllegalArgumentException is thrown. If the name contains any control characters (ASCII codes less than 0x20 or greater than or equal to 0x7f), an IllegalArgumentException is also thrown. Otherwise, the name is set."}, {"ID": 1810, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException, ServletException { final HttpServletRequest request = (HttpServletRequest) servletRequest; final String path = ServletUtils.getContextRelativePath(request); final boolean serve = shouldServe(path); //invocations of the chain end at the first matched servlet if (serve) { doService(servletRequest, servletResponse); } //return false if no servlet matched (so we can proceed down to the web.xml servlets) return serve; }\n\n    ### Response: Wrapper around the service chain to ensure a servlet is servicing what it must and provides it\nwith a wrapped request.\n\n@return Returns true if this servlet triggered for the given request. Or false if guice-servlet\nshould continue dispatching down the servlet pipeline.\n@throws IOException If thrown by underlying servlet\n@throws ServletException If thrown by underlying servlet.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionRequest createActionRequest( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionRequest(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); }\n\n    ### Response:", "ground_truth": "", "predict": " Creates a new ActionRequest object for the given action and request.\n\n@param actionPath The path of the action being executed.\n@param actionPathChunks The path of the action being executed split into chunks.\n@param actionRuntime The runtime information for the action being executed.\n@param action The action object being executed.\n@param servletRequest The original servlet request.\n@param servletResponse The original servlet response.\n@return A new ActionRequest object for the given action and request."}, {"ID": 1811, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DialectFactory createDialectFactory() { DialectFactoryImpl factory = new DialectFactoryImpl(); factory.injectServices(new ServiceRegistryImplementor() { @Override public <R extends Service> R getService(Class<R> serviceRole) { if (serviceRole == DialectResolver.class) { return (R) new StandardDialectResolver(); } else if (serviceRole == StrategySelector.class) { return (R) new StrategySelectorImpl(new ClassLoaderServiceImpl(Thread.currentThread().getContextClassLoader())); } return null; } @Override public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) { return null; } @Override public void destroy() { } @Override public void registerChild(ServiceRegistryImplementor child) { } @Override public void deRegisterChild(ServiceRegistryImplementor child) { } @Override public ServiceRegistry getParentServiceRegistry() { return null; } }); return factory; }\n\n    ### Response: should be using the ServiceRegistry, but getting it from the SessionFactory at startup fails in Spring.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); }\n\n    ### Response:", "ground_truth": "Acquires filter from Petite container.", "predict": "This method creates a new instance of the specified wrapper class using the Petite container. The container is obtained from the SessionFactory at startup, which fails in Spring."}, {"ID": 1812, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void delPoint() { if (!isEnabled()) { return; } if (selected == null) { return; } if (list.indexOf(selected) == 0) { return; } if (list.indexOf(selected) == list.size()-1) { return; } list.remove(selected); sortPoints(); repaint(0); fireUpdate(); }\n\n    ### Response: Delete the currently selected point.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void destroyBean(final BeanData beanData) { if (destroyableBeans == null) { return; } if (!isBeanDestroyable(beanData)) { return; } if (destroyableBeans.remove(beanData)) { beanData.callDestroyMethods(); } }\n\n    ### Response:", "ground_truth": "Removes destroyable bean from the list and calls it destroy methods.\nIf bean is not destroyable, does nothing. Bean gets destroyed only once.", "predict": " Destroy the specified bean."}, {"ID": 1813, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void shutdown() { if (open == 0 || shutdown) { return; } shutdown = true; sink.getIoThread().execute(new Runnable() { @Override public void run() { synchronized (ServerSentEventConnection.this) { if (queue.isEmpty() && pooled == null) { exchange.endExchange(); } } } }); }\n\n    ### Response: execute a graceful shutdown once all data has been sent.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void shutdown() { if (destroyableBeans == null) { return; } for (final BeanData destroyableBean : destroyableBeans) { destroyableBean.callDestroyMethods(); } destroyableBeans.clear(); }\n\n    ### Response:", "ground_truth": "Shutdowns the scope and calls all collected destroyable beans.", "predict": "destroy all beans that implement the Destroyable interface."}, {"ID": 1814, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ImageView createImageInstance(Context context) { if (sImageClass != null) { if (imageViewConstructor == null) { try { imageViewConstructor = sImageClass.getConstructor(Context.class); } catch (NoSuchMethodException e) { e.printStackTrace(); } } if (imageViewConstructor != null) { try { return (ImageView) imageViewConstructor.newInstance(context); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } return null; }\n\n    ### Response: create a custom ImageView instance\n@param context activity context\n@return an instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ReceivedEmail[] get() { if (fromFolder != null) { session.useFolder(fromFolder); } return session.receiveMessages(filter, flagsToSet, flagsToUnset, envelopeOnly, messages -> { if (targetFolder != null) { try { session.folder.copyMessages(messages, session.getFolder(targetFolder)); } catch (MessagingException e) { throw new MailException(\"Copying messages failed\"); } } }); }\n\n    ### Response:", "ground_truth": "Receives the emails as specified by the builder.", "predict": " get the list of received emails\n@param filter the filter to apply to the emails\n@param flagsToSet the flags to set on the emails\n@param flagsToUnset the flags to unset on the emails\n@param envelopeOnly whether to retrieve only the envelope of the emails\n@param targetFolder the folder to copy the emails to\n@return the list of received emails."}, {"ID": 1815, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) throws Exception { String propertyFile = System.getProperty(\"propertyFile\"); final Properties properties = new Properties(); try { properties.load(new FileInputStream(propertyFile)); } catch (IOException ie) { ie.printStackTrace(); } run(properties); }\n\n    ### Response: Main method for running a single evaluation metric.\n\n@param args the arguments.\n@throws Exception see {@link #run(java.util.Properties)}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) { loadPropertiesFiles(args); try (ClusteredServiceContainer container = launch()) { container.context().shutdownSignalBarrier().await(); System.out.println(\"Shutdown ClusteredServiceContainer...\"); } }\n\n    ### Response:", "ground_truth": "Launch the clustered service container and await a shutdown signal.\n\n@param args command line argument which is a list for properties files as URLs or filenames.", "predict": " Main method for running a single evaluation metric.\n\n@param args the arguments.\n@throws Exception see {@link #loadPropertiesFiles(java.lang.String[])}.\n\n    "}, {"ID": 1816, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void progress() { count++; if (count % period == 0 && LOG.isInfoEnabled()) { final double percent = 100 * (count / (double) totalIterations); final long tock = System.currentTimeMillis(); final long timeInterval = tock - tick; final long linesPerSec = (count - prevCount) * 1000 / timeInterval; tick = tock; prevCount = count; final int etaSeconds = (int) ((totalIterations - count) / linesPerSec); final long hours = SECONDS.toHours(etaSeconds); final long minutes = SECONDS.toMinutes(etaSeconds - HOURS.toSeconds(hours)); final long seconds = SECONDS.toSeconds(etaSeconds - MINUTES.toSeconds(minutes)); LOG.info(String.format(\"[%3.0f%%] Completed %d iterations of %d total input. %d iters/s. ETA %02d:%02d:%02d\", percent, count, totalIterations, linesPerSec, hours, minutes, seconds)); } }\n\n    ### Response: Logs the progress..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void run() { do { LockSupport.parkNanos(parkNs); final long currentTotalMessages = totalMessages; final long currentTotalBytes = totalBytes; final long currentTimestamp = System.nanoTime(); final long timeSpanNs = currentTimestamp - lastTimestamp; final double messagesPerSec = ((currentTotalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs; final double bytesPerSec = ((currentTotalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs; reportingFunc.onReport(messagesPerSec, bytesPerSec, currentTotalMessages, currentTotalBytes); lastTotalBytes = currentTotalBytes; lastTotalMessages = currentTotalMessages; lastTimestamp = currentTimestamp; } while (!halt); }\n\n    ### Response:", "ground_truth": "Run loop for the rate reporter", "predict": " Reports the progress of the system."}, {"ID": 1817, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void doPublish(final Jedis jedis, final String namespace, final String channel, final String jobJson) { jedis.publish(JesqueUtils.createKey(namespace, CHANNEL, channel), jobJson); }\n\n    ### Response: Helper method that encapsulates the minimum logic for publishing a job to\na channel.\n\n@param jedis\nthe connection to Redis\n@param namespace\nthe Resque namespace\n@param channel\nthe channel name\n@param jobJson\nthe job serialized as JSON.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); }\n\n    ### Response:", "ground_truth": "Generic error handler that just prints message to stdout.\n\n@param channel   for the error\n@param streamId  for the error\n@param sessionId for the error, if source\n@param message   indicating what the error was\n@param cause     of the error", "predict": " Helper method that encapsulates the minimum logic for printing an error message to\nthe console.\n\n@param channel\nthe channel name\n@param streamId\nthe stream ID\n@param sessionId\nthe session ID\n@param message\nthe error message\n@param cause\nthe header that caused the error."}, {"ID": 1818, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void progress() { count++; if (count % period == 0 && LOG.isInfoEnabled()) { final double percent = 100 * (count / (double) totalIterations); final long tock = System.currentTimeMillis(); final long timeInterval = tock - tick; final long linesPerSec = (count - prevCount) * 1000 / timeInterval; tick = tock; prevCount = count; final int etaSeconds = (int) ((totalIterations - count) / linesPerSec); final long hours = SECONDS.toHours(etaSeconds); final long minutes = SECONDS.toMinutes(etaSeconds - HOURS.toSeconds(hours)); final long seconds = SECONDS.toSeconds(etaSeconds - MINUTES.toSeconds(minutes)); LOG.info(String.format(\"[%3.0f%%] Completed %d iterations of %d total input. %d iters/s. ETA %02d:%02d:%02d\", percent, count, totalIterations, linesPerSec, hours, minutes, seconds)); } }\n\n    ### Response: Logs the progress..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); }\n\n    ### Response:", "ground_truth": "Print the rates to stdout\n\n@param messagesPerSec being reported\n@param bytesPerSec    being reported\n@param totalMessages  being reported\n@param totalBytes     being reported", "predict": "Prints the rate of messages and payload bytes per second."}, {"ID": 1819, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(File source, File dest) throws IOException { if (dest.isDirectory()) { dest = new File(dest + File.separator + source.getName()); } FileChannel in = null, out = null; try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(dest).getChannel(); long size = in.size(); MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); out.write(buf); } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } }\n\n    ### Response: Fast and simple file copy.\n\n@param source source file\n@param dest destination file or directory.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MappedByteBuffer mapExistingFileReadOnly(final File location) { if (!location.exists()) { final String msg = \"file not found: \" + location.getAbsolutePath(); throw new IllegalStateException(msg); } MappedByteBuffer mappedByteBuffer = null; try (RandomAccessFile file = new RandomAccessFile(location, \"r\"); FileChannel channel = file.getChannel()) { mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size()); } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } return mappedByteBuffer; }\n\n    ### Response:", "ground_truth": "Map an existing file as a read only buffer.\n\n@param location of file to map.\n@return the mapped file.", "predict": " Maps an existing file in read-only mode.\n\n@param location file to map\n@return mapped byte buffer\n\n    "}, {"ID": 1820, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected State replaceOrRegister(State state) { StateSignature sig = state.getSignature(); State other = register.get(sig); if (other != null) { if (state != other) { for (int i = 0; i < sig.successors.array.length; i++) { State succ = sig.successors.array[i]; if (succ != null) { succ.decreaseIncoming(); } } } return other; } register.put(sig, state); return state; }\n\n    ### Response: Returns the canonical state for the given state's signature, or registers the state as canonical if no state with\nthat signature exists.\n\n@param state\nthe state\n\n@return the canonical state for the given state's signature.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { final State state = this.state; if (State.CLOSED != state) { if (isReplayActive) { isReplayActive = false; archive.stopReplay(replaySessionId); } if (State.MERGED != state) { subscription.removeDestination(replayDestination); } state(State.CLOSED); } }\n\n    ### Response:", "ground_truth": "Close the merge and stop any active replay. Will remove the replay destination from the subscription. Will\nNOT remove the live destination if it has been added.", "predict": " Closes the subscription and stops any active replay.\n\n@throws JMSException\nif an error occurs while closing the subscription.\n\n    "}, {"ID": 1821, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long countClearBits() throws IOException { byte[] temp; long size = mFile.size(); if (size > 1024) { temp = new byte[1024]; } else { temp = new byte[(int)size]; } long pos = 0; long count = 0; try { lock().acquireReadLock(); while (true) { int amt = mFile.read(pos, temp, 0, temp.length); if (amt <= 0) { break; } for (int i=0; i<amt; i++) { byte val = temp[i]; switch (val & 15) { case 0: count += 4; break; case 1: case 2: case 4: case 8: count += 3; break; case 3: case 5: case 6: case 9: case 10: case 12: count += 2; break; case 7: case 11: case 13: case 14: count++; break; default: break; } switch ((val >> 4) & 15) { case 0: count += 4; break; case 1: case 2: case 4: case 8: count += 3; break; case 3: case 5: case 6: case 9: case 10: case 12: count += 2; break; case 7: case 11: case 13: case 14: count++; break; default: break; } } pos += amt; } } catch (InterruptedException e) { throw new InterruptedIOException(); } finally { lock().releaseLock(); } return count; }\n\n    ### Response: Counts all the clear bits..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int doWork() { int workCount = 0; switch (state) { case AWAIT_INITIAL_RECORDING_POSITION: workCount += awaitInitialRecordingPosition(); break; case AWAIT_REPLAY: workCount += awaitReplay(); break; case AWAIT_CATCH_UP: workCount += awaitCatchUp(); break; case AWAIT_CURRENT_RECORDING_POSITION: workCount += awaitUpdatedRecordingPosition(); break; case AWAIT_STOP_REPLAY: workCount += awaitStopReplay(); break; } return workCount; }\n\n    ### Response:", "ground_truth": "Process the operation of the merge. Do not call the processing of fragments on the subscription.\n\n@return indication of work done processing the merge.", "predict": "Performs the required work based on the current state of the object."}, {"ID": 1822, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sortFileList() { if (this.size() > 1) { Collections.sort(this.fileList, new Comparator() { public final int compare(final Object o1, final Object o2) { final File f1 = (File) o1; final File f2 = (File) o2; final Object[] f1TimeAndCount = backupSuffixHelper .backupTimeAndCount(f1.getName(), baseFile); final Object[] f2TimeAndCount = backupSuffixHelper .backupTimeAndCount(f2.getName(), baseFile); final long f1TimeSuffix = ((Long) f1TimeAndCount[0]).longValue(); final long f2TimeSuffix = ((Long) f2TimeAndCount[0]).longValue(); if ((0L == f1TimeSuffix) && (0L == f2TimeSuffix)) { final long f1Time = f1.lastModified(); final long f2Time = f2.lastModified(); if (f1Time < f2Time) { return -1; } if (f1Time > f2Time) { return 1; } return 0; } if (f1TimeSuffix < f2TimeSuffix) { return -1; } if (f1TimeSuffix > f2TimeSuffix) { return 1; } final int f1Count = ((Integer) f1TimeAndCount[1]).intValue(); final int f2Count = ((Integer) f2TimeAndCount[1]).intValue(); if (f1Count < f2Count) { return -1; } if (f1Count > f2Count) { return 1; } if (f1Count == f2Count) { if (fileHelper.isCompressed(f1)) { return -1; } if (fileHelper.isCompressed(f2)) { return 1; } } return 0; } }); } }\n\n    ### Response: Sort by time bucket, then backup count, and by compression state..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long position() { if (isClosed) { return CLOSED; } final long rawTail = rawTailVolatile(logMetaDataBuffer); final int termOffset = termOffset(rawTail, termBufferLength); return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId); }\n\n    ### Response:", "ground_truth": "Get the current position to which the publication has advanced for this stream.\n\n@return the current position to which the publication has advanced for this stream or {@link #CLOSED}.", "predict": " Get the current position of the log file. If the log file is closed, return the CLOSED constant. Otherwise, get the tail offset from the log metadata buffer, compute the position based on the term ID, term offset, position bits to shift, and initial term ID."}, {"ID": 1823, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int[] calculateInYearsMonthsDaysHoursMinutesAndSeconds(final long compute) { long uebrig = -1; final int[] result = new int[6]; final int years = (int)this.calculateInYears(compute); if (0 < years) { result[0] = years; uebrig = compute - years * ONE_YEAR; } else { result[0] = 0; } final int months = (int)this.calculateInDefaultMonth(uebrig); if (0 < months) { result[1] = months; uebrig -= months * ONE_DEFAULT_MONTH; } else { result[1] = 0; } final int days = (int)this.calculateInDays(uebrig); if (0 < days) { result[2] = days; uebrig -= days * ONE_DAY; } else { result[2] = 0; } final int hours = (int)this.calculateInHours(uebrig); if (0 < hours) { result[3] = hours; uebrig -= hours * ONE_HOUR; } else { result[3] = 0; } final int minutes = (int)this.calculateInMinutes(uebrig); if (0 < minutes) { result[4] = minutes; uebrig -= minutes * ONE_MINUTE; } else { result[4] = 0; } final int seconds = (int)this.calculateInSeconds(uebrig); if (0 < seconds) { result[5] = seconds; } else { result[5] = 0; } return result; }\n\n    ### Response: Calculate in years months days hours minutes and seconds.\n\n@param compute\nThe long to calculate.\n@return the int[] Returns an int array where the first element is the years the second\nelement the months the third element the days then hours, minutes and seconds..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) { final int length = DirectBufferVector.validateAndComputeLength(vectors); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { final int result; if (length <= maxPayloadLength) { result = termAppender.appendUnfragmentedMessage( termId, termOffset, headerWriter, vectors, length, reservedValueSupplier); } else { checkMaxMessageLength(length); result = termAppender.appendFragmentedMessage( termId, termOffset, headerWriter, vectors, length, maxPayloadLength, reservedValueSupplier); } newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; }\n\n    ### Response:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message.\n\n@param vectors               which make up the message.\n@param reservedValueSupplier {@link ReservedValueSupplier} for the frame.\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.", "predict": " Offer a message to the publication.\n\n@param vectors\nThe DirectBufferVector[] to offer.\n@param reservedValueSupplier\nThe ReservedValueSupplier to use for reserving values.\n@return the long Returns the new position of the publication.\n\n    "}, {"ID": 1824, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    long purge(final int sampleSize) { final int limit = Math.min(sampleSize, getNumActive()); int numSamples = 0; int i = 0; final long[] samples = new long[limit]; while (numSamples < limit) { if (isActive(i)) { samples[numSamples] = values[i]; numSamples++; } i++; } final long val = QuickSelect.select(samples, 0, numSamples - 1, limit / 2); adjustAllValuesBy(-1 * val); keepOnlyPositiveCounts(); return val; }\n\n    ### Response: This function is called when a key is processed that is not currently assigned a counter, and\nall the counters are in use. This function estimates the median of the counters in the sketch\nvia sampling, decrements all counts by this estimate, throws out all counters that are no\nlonger positive, and increments offset accordingly.\n@param sampleSize number of samples\n@return the median value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long appendPadding(final int length) { checkMaxMessageLength(length); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { checkPositiveLength(length); final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length); newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; }\n\n    ### Response:", "ground_truth": "Append a padding record log of a given length to make up the log to a position.\n\n@param length of the range to claim, in bytes..\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.\n@throws IllegalArgumentException if the length is greater than {@link #maxMessageLength()}.", "predict": " This function is called when a new message is being appended to the log. It first checks if the message length is within the maximum allowed length, and then appends the padding to the current term. If the current position is beyond the position limit, it backs off and returns the new position.\n@param length the length of the padding to be appended\n@return the new position after appending the padding."}, {"ID": 1825, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { lock.lock(); try { if (writeTarget == null) { closePending = true; return; } } finally { lock.unlock(); } writeTarget.closeConnection(); }\n\n    ### Response: Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { lock.lock(); try { if (!isClosed) { isClosed = true; archiveProxy.closeSession(controlSessionId); if (!context.ownsAeronClient()) { CloseHelper.close(controlResponsePoller.subscription()); CloseHelper.close(archiveProxy.publication()); } context.close(); } } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Notify the archive that this control session is closed so it can promptly release resources then close the\nlocal resources associated with the client.", "predict": " Closes the session with the archive and releases resources associated with the session. If the context is not owned by the Aeron client, it also closes the subscription and publication associated with the session."}, {"ID": 1826, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean addIfOpen(E element) { requireNonNull(element); lock.lock(); try { if (open) { elements.addLast(element); if (elements.size() == 1) { nonEmpty.signalAll(); } } return open; } finally { lock.unlock(); } }\n\n    ### Response: Tries to add an element to the queue, if the queue is still open. Checking whether the queue\nis open and adding the element is one atomic operation.\n\nUnlike the {@link #add(Object)} method, this method never throws an exception,\nbut only indicates via the return code if the element was added or the\nqueue was closed.\n\n@param element The element to add.\n@return True, if the element was added, false if the queue was closes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String pollForErrorResponse() { lock.lock(); try { ensureOpen(); if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) { if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) { return controlResponsePoller.errorMessage(); } } return null; } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Poll the response stream once for an error. If another message is present then it will be skipped over\nso only call when not expecting another response.\n\n@return the error String otherwise null if no error is found.", "predict": "Polls the control response queue for an error response message.\n\n@return The error message, or null if no error message was found.\n\n    "}, {"ID": 1827, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void inc(final int numOps, final long time) { lock.lock(); try { currentData.numOperations += numOps; currentData.time += time; long timePerOps = time/numOps; minMax.update(timePerOps); } finally { lock.unlock(); } }\n\n    ### Response: Increment the metrics for numOps operations\n@param numOps - number of operations\n@param time - time for numOps operations.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stopReplay(final long replaySessionId) { lock.lock(); try { ensureOpen(); final long correlationId = aeron.nextCorrelationId(); if (!archiveProxy.stopReplay(replaySessionId, correlationId, controlSessionId)) { throw new ArchiveException(\"failed to send stop replay request\"); } pollForResponse(correlationId); } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Stop a replay session.\n\n@param replaySessionId to stop replay for.", "predict": " Stop the replay for the given replaySessionId\n@param replaySessionId - id of the replay session to stop.\n\n    "}, {"ID": 1828, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.println(String.format(\"Available image on %s streamId=%d sessionId=%d from %s\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity())); }\n\n    ### Response: Print the information for an available image to stdout.\n\n@param image that has been created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void eventAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"new image on %s streamId %x sessionId %x from %s%n\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity()); }\n\n    ### Response:", "ground_truth": "Print the information for an available image to stdout.\n\n@param image that has been created", "predict": " Log a message indicating that a new image has been received.\n\n@param image that has been created."}, {"ID": 1829, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.println(String.format(\"Available image on %s streamId=%d sessionId=%d from %s\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity())); }\n\n    ### Response: Print the information for an available image to stdout.\n\n@param image that has been created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void eventUnavailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"inactive image on %s streamId %d sessionId %x%n\", subscription.channel(), subscription.streamId(), image.sessionId()); }\n\n    ### Response:", "ground_truth": "This handler is called when image is unavailable\n\n@param image that has gone inactive", "predict": " Log an event for an unavailable image to the console.\n\n@param image that has been removed."}, {"ID": 1830, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletableFuture<Void> shutDownInternal() { synchronized (lock) { CompletableFuture<?> channelFuture = new CompletableFuture<>(); if (serverChannel != null) { serverChannel.close().addListener(finished -> { if (finished.isSuccess()) { channelFuture.complete(null); } else { channelFuture.completeExceptionally(finished.cause()); } }); serverChannel = null; } final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>(); channelFuture.thenRun(() -> { CompletableFuture<?> groupFuture = new CompletableFuture<>(); CompletableFuture<?> childGroupFuture = new CompletableFuture<>(); final Time gracePeriod = Time.seconds(10L); if (bootstrap != null) { final ServerBootstrapConfig config = bootstrap.config(); final EventLoopGroup group = config.group(); if (group != null) { group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS) .addListener(finished -> { if (finished.isSuccess()) { groupFuture.complete(null); } else { groupFuture.completeExceptionally(finished.cause()); } }); } else { groupFuture.complete(null); } final EventLoopGroup childGroup = config.childGroup(); if (childGroup != null) { childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS) .addListener(finished -> { if (finished.isSuccess()) { childGroupFuture.complete(null); } else { childGroupFuture.completeExceptionally(finished.cause()); } }); } else { childGroupFuture.complete(null); } bootstrap = null; } else { // complete the group futures since there is nothing to stop groupFuture.complete(null); childGroupFuture.complete(null); } CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture)); combinedFuture.whenComplete( (Void ignored, Throwable throwable) -> { if (throwable != null) { channelTerminationFuture.completeExceptionally(throwable); } else { channelTerminationFuture.complete(null); } }); }); return channelTerminationFuture; } }\n\n    ### Response: Stops this REST server endpoint.\n\n@return Future which is completed once the shut down has been finished..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == SendChannelStatus.SEND_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; }\n\n    ### Response:", "ground_truth": "Return the read-only status indicator for the given send channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the send channel.\n@return read-only status indicator that can be used to query the status of the send channel or null\n@see ChannelEndpointStatus for status values and indications.", "predict": "Returns a status reader for the given channel.\n\n@param countersReader The counters reader to search for the channel status.\n@param channel The channel to search for.\n@return A status reader for the given channel or null if the channel is not found."}, {"ID": 1831, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletableFuture<Void> shutDownInternal() { synchronized (lock) { CompletableFuture<?> channelFuture = new CompletableFuture<>(); if (serverChannel != null) { serverChannel.close().addListener(finished -> { if (finished.isSuccess()) { channelFuture.complete(null); } else { channelFuture.completeExceptionally(finished.cause()); } }); serverChannel = null; } final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>(); channelFuture.thenRun(() -> { CompletableFuture<?> groupFuture = new CompletableFuture<>(); CompletableFuture<?> childGroupFuture = new CompletableFuture<>(); final Time gracePeriod = Time.seconds(10L); if (bootstrap != null) { final ServerBootstrapConfig config = bootstrap.config(); final EventLoopGroup group = config.group(); if (group != null) { group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS) .addListener(finished -> { if (finished.isSuccess()) { groupFuture.complete(null); } else { groupFuture.completeExceptionally(finished.cause()); } }); } else { groupFuture.complete(null); } final EventLoopGroup childGroup = config.childGroup(); if (childGroup != null) { childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS) .addListener(finished -> { if (finished.isSuccess()) { childGroupFuture.complete(null); } else { childGroupFuture.completeExceptionally(finished.cause()); } }); } else { childGroupFuture.complete(null); } bootstrap = null; } else { // complete the group futures since there is nothing to stop groupFuture.complete(null); childGroupFuture.complete(null); } CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture)); combinedFuture.whenComplete( (Void ignored, Throwable throwable) -> { if (throwable != null) { channelTerminationFuture.completeExceptionally(throwable); } else { channelTerminationFuture.complete(null); } }); }); return channelTerminationFuture; } }\n\n    ### Response: Stops this REST server endpoint.\n\n@return Future which is completed once the shut down has been finished..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StatusIndicatorReader receiveChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; }\n\n    ### Response:", "ground_truth": "Return the read-only status indicator for the given receive channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the receive channel.\n@return read-only status indicator that can be used to query the status of the receive channel or null.\n@see ChannelEndpointStatus for status values and indications.", "predict": "Returns a status reader for the given channel.\n\n@param countersReader The counters reader to use.\n@param channel The channel to get the status reader for.\n@return The status reader for the given channel or null if no status reader exists for the channel."}, {"ID": 1832, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setOffscreenPageLimit(int limit) { if (limit < DEFAULT_OFFSCREEN_PAGES) { Log.w(TAG, \"Requested offscreen page limit \" + limit + \" too small; defaulting to \" + DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES; } if (limit != mOffscreenPageLimit) { mOffscreenPageLimit = limit; populate(); } }\n\n    ### Response: Set the number of pages that should be retained to either side of the\ncurrent page in the view hierarchy in an idle state. Pages beyond this\nlimit will be recreated from the adapter when needed.\n\nThis is offered as an optimization. If you know in advance the number\nof pages you will need to support or have lazy-loading mechanisms in place\non your pages, tweaking this setting can have benefits in perceived smoothness\nof paging animations and interaction. If you have a small number of pages (3-4)\nthat you can keep active all at once, less time will be spent in layout for\nnewly created view subtrees as the user pages back and forth.\n\nYou should keep this limit low, especially if your pages have complex layouts.\nThis setting defaults to 1.\n\n@param limit How many pages will be kept offscreen in an idle state..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void limit(final int limit) { if (limit < 0 || limit >= buffer.capacity()) { throw new IllegalArgumentException( \"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit); } this.limit = limit; }\n\n    ### Response:", "ground_truth": "Set this limit for this buffer as the position at which the next append operation will occur.\n\n@param limit to be the new value.", "predict": " Set the maximum number of elements that can be stored in the buffer.\n\n@param limit The maximum number of elements that can be stored in the buffer."}, {"ID": 1833, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BufferBuilder append(ClientProtocolBuffer srcBuffer, int srcOffset, int length) { ensureCapacity(length); srcBuffer.getBytes(srcOffset, protocolBuffer.byteArray(), position, length); position += length; return this; }\n\n    ### Response: Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; }\n\n    ### Response:", "ground_truth": "Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage.", "predict": " Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage."}, {"ID": 1834, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void resetAnalysisState() { m_countOfIndependentlyPartitionedTables = -1; m_countOfPartitionedTables = -1; m_fullColumnName = null; m_inferredExpression.clear(); m_inferredParameterIndex = -1; m_inferredValue = null; m_isDML = false; setJoinValid(true); setJoinInvalidReason(null); m_partitionColForDML = null; }\n\n    ### Response: Sometimes when we fail to plan a statement, we try again with different inputs\nusing the same StatementPartitioning object.  In this case, it's incumbent on\ncallers to reset the cached analysis state set by calling this method.\n\nTODO: one could imagine separating this class into two classes:\n- One for partitioning context (such as AdHoc, stored proc, row limit delete\ntrigger), which is immutable\n- One to capture the results of partitioning analysis, which can be GC'd when no\nlonger needed\nThis might avoid some of the pitfalls of reused stateful objects..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int poll() { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = null; pollComplete = false; return subscription.controlledPoll(fragmentAssembler, fragmentLimit); }\n\n    ### Response:", "ground_truth": "Poll for control response events.\n\n@return the number of fragments read during the operation. Zero if no events are available.", "predict": " This method polls the subscription for new messages and returns the number of messages received. It also updates the controlSessionId, correlationId, relevantId, templateId, errorMessage, and pollComplete fields. The subscription is obtained from the session's subscription manager. The fragmentAssembler is a callback object that is called for each received message fragment. The fragmentLimit is the maximum number of fragments to receive."}, {"ID": 1835, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nonnull public static String getWithTrailing (@Nullable final String sSrc, @Nonnegative final int nMinLen, final char cEnd) { return _getWithLeadingOrTrailing (sSrc, nMinLen, cEnd, false); }\n\n    ### Response: Get a string that is filled at the end with the passed character until the\nminimum length is reached. If the input string is empty, the result is a\nstring with the provided len only consisting of the passed characters. If the\ninput String is longer than the provided length, it is returned unchanged.\n\n@param sSrc\nSource string. May be null.\n@param nMinLen\nMinimum length. Should be &gt; 0.\n@param cEnd\nThe character to be used at the end\n@return A non-null string that has at least nLen chars.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MappedByteBuffer mapLossReport(final String aeronDirectoryName, final int reportFileLength) { return mapNewFile(file(aeronDirectoryName), reportFileLength, false); }\n\n    ### Response:", "ground_truth": "Map a new loss report in the Aeron directory for a given length.\n\n@param aeronDirectoryName in which to create the file.\n@param reportFileLength   for the file.\n@return the newly mapped buffer for the file.", "predict": " Map a file into memory for reading or writing.\n\n@param aeronDirectoryName\nThe directory where the file is located.\n@param reportFileLength\nThe length of the file to be mapped.\n@return A mapped byte buffer that can be used to read or write the file.\n\n    "}, {"ID": 1836, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void rememberReloadableType(int typeId, ReloadableType rtype) { if (typeId >= reloadableTypes.length) { resizeReloadableTypeArray(typeId); } reloadableTypes[typeId] = rtype; if ((typeId + 1) > reloadableTypesSize) { reloadableTypesSize = typeId + 1; } }\n\n    ### Response: Sometimes we discover the reloadabletype during program execution, for example A calls B and we haven't yet seen\nB. We find B has been loaded by a parent classloader, let's remember B here so we can do fast lookups for it.\n\n@param typeId the id for the type\n@param rtype the ReloadableType to associate with the id.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<StreamCompositeKey, List<StreamPosition>> snapshot() { final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamPosition position = new StreamPosition( keyBuffer.getLong(REGISTRATION_ID_OFFSET), counters.getCounterValue(counterId), typeId); streams .computeIfAbsent(key, (ignore) -> new ArrayList<>()) .add(position); } }); return streams; }\n\n    ### Response:", "ground_truth": "Take a snapshot of all the counters and group them by streams.\n\n@return a snapshot of all the counters and group them by streams.", "predict": " This method is used to create a snapshot of the current state of the counters. It iterates over all the counters and creates a map of StreamCompositeKey to a list of StreamPosition. The StreamCompositeKey contains the session id, stream id and channel name. The StreamPosition contains the registration id, counter value and type id. The type id is used to filter out counters that are not relevant to streams. The method returns the map of streams."}, {"ID": 1837, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int[] readIntArray(final int items, final JBBPByteOrder byteOrder) throws IOException { int pos = 0; if (items < 0) { int[] buffer = new int[INITIAL_ARRAY_BUFFER_SIZE]; // till end while (hasAvailableData()) { final int next = readInt(byteOrder); if (buffer.length == pos) { final int[] newbuffer = new int[buffer.length << 1]; System.arraycopy(buffer, 0, newbuffer, 0, buffer.length); buffer = newbuffer; } buffer[pos++] = next; } if (buffer.length == pos) { return buffer; } final int[] result = new int[pos]; System.arraycopy(buffer, 0, result, 0, pos); return result; } else { // number final int[] buffer = new int[items]; for (int i = 0; i < items; i++) { buffer[i] = readInt(byteOrder); } return buffer; } }\n\n    ### Response: Read number of integer items from the input stream.\n\n@param items     number of items to be read from the input stream, if less than\nzero then all stream till the end will be read\n@param byteOrder the order of bytes to be used to decode values\n@return read items as an integer array\n@throws IOException it will be thrown for any transport problem during the\noperation\n@see JBBPByteOrder#BIG_ENDIAN\n@see JBBPByteOrder#LITTLE_ENDIAN.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) { final UnsafeBuffer buffer = new UnsafeBuffer( BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH)); buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION); buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS); buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN); buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN); buffer.putInt(STREAM_ID_FIELD_OFFSET, streamId, LITTLE_ENDIAN); buffer.putInt(TERM_ID_FIELD_OFFSET, termId, LITTLE_ENDIAN); buffer.putLong(RESERVED_VALUE_OFFSET, DEFAULT_RESERVE_VALUE); return buffer; }\n\n    ### Response:", "ground_truth": "Return an initialised default Data Frame Header.\n\n@param sessionId for the header\n@param streamId  for the header\n@param termId    for the header\n@return byte array containing the header", "predict": " Create a default header buffer with the given session id, stream id and term id.\n\n@param sessionId the session id to be set in the header\n@param streamId  the stream id to be set in the header\n@param termId    the term id to be set in the header\n@return a new buffer with the default header values set\n@see #CURRENT_VERSION\n@see #BEGIN_AND_END_FLAGS\n@see #HDR_TYPE_DATA\n@see #LITTLE_ENDIAN\n@see #SESSION_ID_FIELD_OFFSET\n@see #STREAM_ID_FIELD_OFFSET\n@see #TERM_ID_FIELD_OFFSET\n@see #RESERVED_VALUE_OFFSET\n@see #DEFAULT_RESERVE_VALUE"}, {"ID": 1838, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEach(final MetaData metaData) { int counterId = 0; final AtomicBuffer metaDataBuffer = this.metaDataBuffer; for (int i = 0, capacity = metaDataBuffer.capacity(); i < capacity; i += METADATA_LENGTH) { final int recordStatus = metaDataBuffer.getIntVolatile(i); if (RECORD_ALLOCATED == recordStatus) { final int typeId = metaDataBuffer.getInt(i + TYPE_ID_OFFSET); final String label = labelValue(metaDataBuffer, i); final DirectBuffer keyBuffer = new UnsafeBuffer(metaDataBuffer, i + KEY_OFFSET, MAX_KEY_LENGTH); metaData.accept(counterId, typeId, keyBuffer, label); } else if (RECORD_UNUSED == recordStatus) { break; } counterId++; } }\n\n    ### Response: Iterate over all the metadata in the buffer.\n\n@param metaData function to be called for each metadata record..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) { buffer.putInt(KEY_LENGTH_OFFSET, keyLength); if (null != keyBuffer && keyLength > 0) { buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength); } return this; }\n\n    ### Response:", "ground_truth": "Fill the key buffer.\n\n@param keyBuffer containing the optional key for the counter.\n@param keyOffset within the keyBuffer at which the key begins.\n@param keyLength of the key in the keyBuffer.\n@return flyweight", "predict": " Set the key buffer and its length in the message flyweight.\n\n@param keyBuffer the buffer containing the key.\n@param keyOffset the offset in the buffer where the key starts.\n@param keyLength the length of the key in bytes.\n@return this flyweight."}, {"ID": 1839, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AsciiSequenceView wrap(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; }\n\n    ### Response: Wrap a range of an existing buffer containing an ASCII sequence.\n\n@param buffer containing the ASCII sequence.\n@param offset at which the ASCII sequence begins.\n@param length of the ASCII sequence in bytes.\n@return this for a fluent API..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CounterMessageFlyweight labelBuffer( final DirectBuffer labelBuffer, final int labelOffset, final int labelLength) { buffer.putInt(labelOffset(), labelLength); buffer.putBytes(labelBufferOffset(), labelBuffer, labelOffset, labelLength); return this; }\n\n    ### Response:", "ground_truth": "Fill the label buffer.\n\n@param labelBuffer containing the mandatory label for the counter.\n@param labelOffset within the labelBuffer at which the label begins.\n@param labelLength of the label in the labelBuffer.\n@return flyweight", "predict": " Set the label buffer and its length for the counter message.\n\n@param labelBuffer containing the label.\n@param labelOffset at which the label begins.\n@param labelLength of the label in bytes.\n@return this for a fluent API."}, {"ID": 1840, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private AccessLogRecordData toAccessLogRecordData(final HttpRequestMessage request, final HttpResponseMessage response, final String version, final String userId, final String remoteAddr, final long numBytes) { final HttpRequestMessage request2 = request; // request.duplicate(); final HttpResponseMessage response2 = response; // response.duplicate(); final long timestamp; final long startTime; final long elapsedTime; final String localIP; final String localPort; // ** timestamp timestamp = System.currentTimeMillis(); // ** Request Start Time startTime = AccessLogStartTime.getStartTime(response2, request2, null); // ** Elapsed Request Time elapsedTime = AccessLogElapsedRequestTime.getElapsedRequestTime(response2, request2, null); // ** LocalIP localIP = AccessLogLocalIP.getLocalIP(response2, request2, null); // ** LocalPort localPort = AccessLogLocalPort.getLocalPort(response2, request2, null); // ** AccessLogRecordData AccessLogRecordData recordData = new AccessLogRecordData() { @Override public long getTimestamp() { return timestamp; } @Override public String getVersion() { return version; } @Override public String getUserId() { return userId; } @Override public HttpResponseMessage getResponse() { return response2; } @Override public HttpRequestMessage getRequest() { return request2; } @Override public String getRemoteAddress() { return remoteAddr; } @Override public long getBytesWritten() { return numBytes; } @Override public long getStartTime() { return startTime; } @Override public long getElapsedTime() { return elapsedTime; } @Override public String getLocalIP() { return localIP; } @Override public String getLocalPort() { return localPort; } }; return recordData; }\n\n    ### Response: Return a AccessLogRecordData instance\n\n@param request\n@param response\n@param version\n@param userId\n@param remoteAddr\n@param numBytes\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); return offerWithTimeout(connectRequestEncoder.encodedLength(), null); }\n\n    ### Response:", "ground_truth": "Connect to an archive on its control interface providing the response stream details.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " Connect to the archive and request a session for a given responseChannel and responseStreamId.\n\n@param responseChannel\n@param responseStreamId\n@param correlationId\n@return true if the request was successfully sent, false otherwise.\n\n    "}, {"ID": 1841, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String maskExcept(final String s, final int unmaskedLength, final char maskChar) { if (s == null) { return null; } final boolean maskLeading = unmaskedLength > 0; final int length = s.length(); final int maskedLength = Math.max(0, length - Math.abs(unmaskedLength)); if (maskedLength > 0) { final String mask = StringUtils.repeat(maskChar, maskedLength); if (maskLeading) { return StringUtils.overlay(s, mask, 0, maskedLength); } return StringUtils.overlay(s, mask, length - maskedLength, length); } return s; }\n\n    ### Response: Returns a masked string, leaving only the given number of characters unmasked.\n\n@param s\nstring that requires masking\n@param unmaskedLength\nnumber of characters to leave unmasked; if positive, the unmasked characters are\nat the end of the string, otherwise the unmasked characters are at the start of\nthe string.\n@param maskChar\ncharacter to be used for masking\n@return a masked string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength(); return publication.offer(buffer, 0, length) > 0; }\n\n    ### Response:", "ground_truth": "Try Connect to an archive on its control interface providing the response stream details. Only one attempt will\nbe made to offer the request.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " Attempts to connect to the archive for the given response channel, stream id, and correlation id.\n\n@param responseChannel\nresponse channel for the connection request\n@param responseStreamId\nstream id for the response messages\n@param correlationId\ncorrelation id for the connection request\n@return true if the connection request was successfully sent, false otherwise."}, {"ID": 1842, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RunList<R> byTimestamp(final long start, final long end) { return limit(new CountingPredicate<R>() { public boolean apply(int index, R r) { return start<=r.getTimeInMillis(); } }).filter(new Predicate<R>() { public boolean apply(R r) { return r.getTimeInMillis()<end; } }); }\n\n    ### Response: Filter the list by timestamp.\n\n{@code s&lt=;e}.\nWarning: this method mutates the original list and then returns it..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean closeSession(final long controlSessionId) { closeSessionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId); return offer(closeSessionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Close this control session with the archive.\n\n@param controlSessionId with the archive.\n@return true if successfully offered otherwise false.", "predict": " Close a session.\n\nWarning: this method mutates the original buffer and then returns true if the message was successfully added to the outbound queue."}, {"ID": 1843, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized CollectorController createHttpController( final String collectorHost, final int collectorPort, final EventType eventType, final long httpMaxWaitTimeInMillis, final long httpMaxKeepAliveInMillis, final String spoolDirectoryName, final boolean isFlushEnabled, final int flushIntervalInSeconds, final SyncType syncType, final int syncBatchSize, final long maxUncommittedWriteCount, final int maxUncommittedPeriodInSeconds, final int httpWorkersPoolSize ) throws IOException { if (singletonController == null) { singletonController = new HttpCollectorFactory( collectorHost, collectorPort, eventType, httpMaxWaitTimeInMillis, httpMaxKeepAliveInMillis, spoolDirectoryName, isFlushEnabled, flushIntervalInSeconds, syncType, syncBatchSize, maxUncommittedWriteCount, maxUncommittedPeriodInSeconds, httpWorkersPoolSize ).get(); } return singletonController; }\n\n    ### Response: Factory method for tests cases.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean startRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long correlationId, final long controlSessionId) { startRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(startRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Start recording streams for a given channel and stream id pairing.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Starts recording on a channel.\n\n    "}, {"ID": 1844, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized CollectorController createHttpController( final String collectorHost, final int collectorPort, final EventType eventType, final long httpMaxWaitTimeInMillis, final long httpMaxKeepAliveInMillis, final String spoolDirectoryName, final boolean isFlushEnabled, final int flushIntervalInSeconds, final SyncType syncType, final int syncBatchSize, final long maxUncommittedWriteCount, final int maxUncommittedPeriodInSeconds, final int httpWorkersPoolSize ) throws IOException { if (singletonController == null) { singletonController = new HttpCollectorFactory( collectorHost, collectorPort, eventType, httpMaxWaitTimeInMillis, httpMaxKeepAliveInMillis, spoolDirectoryName, isFlushEnabled, flushIntervalInSeconds, syncType, syncBatchSize, maxUncommittedWriteCount, maxUncommittedPeriodInSeconds, httpWorkersPoolSize ).get(); } return singletonController; }\n\n    ### Response: Factory method for tests cases.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean stopRecording( final String channel, final int streamId, final long correlationId, final long controlSessionId) { stopRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .channel(channel); return offer(stopRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Stop an active recording.\n\n@param channel          to be stopped.\n@param streamId         to be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Sends a stop recording request to the media driver.\n\n    "}, {"ID": 1845, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean replay( final long recordingId, final long position, final long length, final String replayChannel, final int replayStreamId, final long correlationId, final long controlSessionId) { replayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .position(position) .length(length) .replayStreamId(replayStreamId) .replayChannel(replayChannel); return offer(replayRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Replay a recording from a given position.\n\n@param recordingId      to be replayed.\n@param position         from which the replay should be started.\n@param length           of the stream to be replayed. Use {@link Long#MAX_VALUE} to follow a live stream.\n@param replayChannel    to which the replay should be sent.\n@param replayStreamId   to which the replay should be sent.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Replay a recording.\n\n    "}, {"ID": 1846, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) { stopReplayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .replaySessionId(replaySessionId); return offer(replayRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Stop an existing replay session.\n\n@param replaySessionId  that should be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Stop replay for a given replay session."}, {"ID": 1847, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId) { listRecordingsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount); return offer(listRecordingsRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a range of recording descriptors.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " List recordings request."}, {"ID": 1848, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized CollectorController createHttpController( final String collectorHost, final int collectorPort, final EventType eventType, final long httpMaxWaitTimeInMillis, final long httpMaxKeepAliveInMillis, final String spoolDirectoryName, final boolean isFlushEnabled, final int flushIntervalInSeconds, final SyncType syncType, final int syncBatchSize, final long maxUncommittedWriteCount, final int maxUncommittedPeriodInSeconds, final int httpWorkersPoolSize ) throws IOException { if (singletonController == null) { singletonController = new HttpCollectorFactory( collectorHost, collectorPort, eventType, httpMaxWaitTimeInMillis, httpMaxKeepAliveInMillis, spoolDirectoryName, isFlushEnabled, flushIntervalInSeconds, syncType, syncBatchSize, maxUncommittedWriteCount, maxUncommittedPeriodInSeconds, httpWorkersPoolSize ).get(); } return singletonController; }\n\n    ### Response: Factory method for tests cases.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordingsForUri( final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) { listRecordingsForUriRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount) .streamId(streamId) .channel(channelFragment); return offer(listRecordingsForUriRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a range of recording descriptors which match a channel URI fragment and stream id.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param channelFragment  to match recordings on from the original channel URI in the archive descriptor.\n@param streamId         to match recordings on.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Sends a request to list recordings for a given URI.\n\n    "}, {"ID": 1849, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) { listRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(listRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a recording descriptor for a given recording id.\n\n@param recordingId      at which to begin listing.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " List recording request."}, {"ID": 1850, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized CollectorController createHttpController( final String collectorHost, final int collectorPort, final EventType eventType, final long httpMaxWaitTimeInMillis, final long httpMaxKeepAliveInMillis, final String spoolDirectoryName, final boolean isFlushEnabled, final int flushIntervalInSeconds, final SyncType syncType, final int syncBatchSize, final long maxUncommittedWriteCount, final int maxUncommittedPeriodInSeconds, final int httpWorkersPoolSize ) throws IOException { if (singletonController == null) { singletonController = new HttpCollectorFactory( collectorHost, collectorPort, eventType, httpMaxWaitTimeInMillis, httpMaxKeepAliveInMillis, spoolDirectoryName, isFlushEnabled, flushIntervalInSeconds, syncType, syncBatchSize, maxUncommittedWriteCount, maxUncommittedPeriodInSeconds, httpWorkersPoolSize ).get(); } return singletonController; }\n\n    ### Response: Factory method for tests cases.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean extendRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long recordingId, final long correlationId, final long controlSessionId) { extendRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(extendRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Extend an existing, non-active, recorded stream for a the same channel and stream id.\n\nThe channel must be configured for the initial position from which it will be extended. This can be done\nwith {@link ChannelUriStringBuilder#initialPosition(long, int, int)}. The details required to initialise can\nbe found by calling {@link #listRecording(long, long, long)}.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param recordingId      to be extended.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Adds a new source location to an existing recording.\n\n    "}, {"ID": 1851, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) { recordingPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(recordingPositionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Get the recorded position of an active recording.\n\n@param recordingId      of the active recording that the position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Get recording position for a given recording id, correlation id and control session id."}, {"ID": 1852, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean intersection( final long pX0, final long pY0, final long pX1, final long pY1, final long pX2, final long pY2, final long pX3, final long pY3 ) { return SegmentIntersection.intersection( pX0, pY0, pX1, pY1, pX2, pY2, pX3, pY3, mOptimIntersection); }\n\n    ### Response: Intersection of two segments.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) { stopPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(stopPositionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Get the stop position of a recording.\n\n@param recordingId      of the recording that the stop position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Request to stop a recording.\n\n    "}, {"ID": 1853, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static synchronized CollectorController createHttpController( final String collectorHost, final int collectorPort, final EventType eventType, final long httpMaxWaitTimeInMillis, final long httpMaxKeepAliveInMillis, final String spoolDirectoryName, final boolean isFlushEnabled, final int flushIntervalInSeconds, final SyncType syncType, final int syncBatchSize, final long maxUncommittedWriteCount, final int maxUncommittedPeriodInSeconds, final int httpWorkersPoolSize ) throws IOException { if (singletonController == null) { singletonController = new HttpCollectorFactory( collectorHost, collectorPort, eventType, httpMaxWaitTimeInMillis, httpMaxKeepAliveInMillis, spoolDirectoryName, isFlushEnabled, flushIntervalInSeconds, syncType, syncBatchSize, maxUncommittedWriteCount, maxUncommittedPeriodInSeconds, httpWorkersPoolSize ).get(); } return singletonController; }\n\n    ### Response: Factory method for tests cases.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordingSubscriptions( final int pseudoIndex, final int subscriptionCount, final String channelFragment, final int streamId, final boolean applyStreamId, final long correlationId, final long controlSessionId) { listRecordingSubscriptionsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .pseudoIndex(pseudoIndex) .subscriptionCount(subscriptionCount) .applyStreamId(applyStreamId ? BooleanType.TRUE : BooleanType.FALSE) .streamId(streamId) .channel(channelFragment); return offer(listRecordingSubscriptionsRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List registered subscriptions in the archive which have been used to record streams.\n\n@param pseudoIndex       in the list of active recording subscriptions.\n@param subscriptionCount for the number of descriptors to be listed.\n@param channelFragment   for a contains match on the stripped channel used with the registered subscription.\n@param streamId          for the subscription.\n@param applyStreamId     when matching.\n@param correlationId     for this request.\n@param controlSessionId  for this request.\n@return true if successfully offered otherwise false.", "predict": " Sends a request to list recording subscriptions for a given channel fragment and stream id.\n\n    "}, {"ID": 1854, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public function checkViewDataPerms($fld) { if ($fld && isset($fld->FldOpts) && intVal($fld->FldOpts) > 0) { if ($fld->FldOpts%7 > 0 && $fld->FldOpts%11 > 0 && $fld->FldOpts%13 > 0) { return true; } if (in_array($GLOBALS[\"SL\"]->x[\"pageView\"], ['full', 'full-pdf', 'full-xml'])) { return true; } if ($fld->FldOpts%13 == 0 || $fld->FldOpts%11 == 0) { return false; } return true; } return false; }\n\n    ### Response: FldOpts %1 XML Public Data; %7 XML Private Data; %11 XML Sensitive Data; %13 XML Internal Use Data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matchesTag(final UdpChannel udpChannel) { if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) { return false; } if (udpChannel.remoteData().getAddress().isAnyLocalAddress() && udpChannel.remoteData().getPort() == 0 && udpChannel.localData().getAddress().isAnyLocalAddress() && udpChannel.localData().getPort() == 0) { return true; } throw new IllegalArgumentException(\"matching tag has set endpoint or control address\"); }\n\n    ### Response:", "ground_truth": "Does this channel have a tag match to another channel including endpoints.\n\n@param udpChannel to match against.\n@return true if there is a match otherwise false.", "predict": " Matches the tag of the UDP channel. If the tag is not set or does not match, returns false. If the remote and local endpoints are both set to any local address and port, returns true. Otherwise, throws an IllegalArgumentException."}, {"ID": 1855, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<SVGPath> loadSVGIconFromFile(final File file) throws CouldNotPerformException { try { if (!file.exists()) { throw new NotAvailableException(file.getAbsolutePath()); } return generateSvgPathList(FileUtils.readFileToString(file, StandardCharsets.UTF_8)); } catch (final Exception ex) { throw new CouldNotPerformException(\"Could not load path File[\" + file + \"]\", ex); } }\n\n    ### Response: Method tries to build one or more SVGPaths out of the passed file.\nBy this the file content is interpreted as svg xml and new SVGPath instances are generated for each found path element\n\n@param file the svg xml file\n\n@return a list of SVGPaths instances where each is representing one found path element\n\n@throws CouldNotPerformException is thrown if the file does not exist or it does not contain any path elements..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InetSocketAddress destinationAddress(final ChannelUri uri) { try { validateConfiguration(uri); return getEndpointAddress(uri); } catch (final Exception ex) { throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex); } }\n\n    ### Response:", "ground_truth": "Get the endpoint address from the URI.\n\n@param uri to check\n@return endpoint address for URI", "predict": " Method returns the destination address of the channel based on the provided ChannelUri.\n\n@param uri the channel uri\n\n@return the destination address of the channel\n\n@throws InvalidChannelException is thrown if the channel uri is not valid or if the destination address cannot be determined."}, {"ID": 1856, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final String exceptionMessage(String msg) { if (msg == null) { msg = \"\"; } StringBuilder buf = new StringBuilder(128 + msg.length()) .append(protocol()) .append(\", \") .append(authScheme()) .append(\", \") .append(proxyAddress) .append(\" => \") .append(destinationAddress); if (!msg.isEmpty()) { buf.append(\", \").append(msg); } return buf.toString(); }\n\n    ### Response: Decorates the specified exception message with the common information such as the current protocol,\nauthentication scheme, proxy address, and destination address..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String description() { final StringBuilder builder = new StringBuilder(\"UdpChannel - \"); if (null != localInterface) { builder .append(\"interface: \") .append(localInterface.getDisplayName()) .append(\", \"); } builder .append(\"localData: \").append(localData) .append(\", remoteData: \").append(remoteData) .append(\", ttl: \").append(multicastTtl); return builder.toString(); }\n\n    ### Response:", "ground_truth": "Used for debugging to get a human readable description of the channel.\n\n@return a human readable description of the channel.", "predict": " Returns a string representation of the UDP channel, including the local interface, local data, remote data, and multicast TTL."}, {"ID": 1857, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parse(final SelectStatement selectStatement) { if (!lexerEngine.skipIfEqual(SQLServerKeyword.OFFSET)) { return; } int offsetValue = -1; int offsetIndex = -1; if (lexerEngine.equalAny(Literals.INT)) { offsetValue = Integer.parseInt(lexerEngine.getCurrentToken().getLiterals()); } else if (lexerEngine.equalAny(Symbol.QUESTION)) { offsetIndex = selectStatement.getParametersIndex(); selectStatement.setParametersIndex(selectStatement.getParametersIndex() + 1); } else { throw new SQLParsingException(lexerEngine); } lexerEngine.nextToken(); Limit limit = new Limit(); if (lexerEngine.skipIfEqual(DefaultKeyword.FETCH)) { lexerEngine.nextToken(); int rowCountValue = -1; int rowCountIndex = -1; lexerEngine.nextToken(); if (lexerEngine.equalAny(Literals.INT)) { rowCountValue = Integer.parseInt(lexerEngine.getCurrentToken().getLiterals()); } else if (lexerEngine.equalAny(Symbol.QUESTION)) { rowCountIndex = selectStatement.getParametersIndex(); selectStatement.setParametersIndex(selectStatement.getParametersIndex() + 1); } else { throw new SQLParsingException(lexerEngine); } lexerEngine.nextToken(); lexerEngine.nextToken(); limit.setRowCount(new LimitValue(rowCountValue, rowCountIndex, false)); limit.setOffset(new LimitValue(offsetValue, offsetIndex, true)); } else { limit.setOffset(new LimitValue(offsetValue, offsetIndex, true)); } selectStatement.setLimit(limit); }\n\n    ### Response: Parse offset.\n\n@param selectStatement select statement.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) { imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1); if (transport.isMulticast()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl()); } else if (transport.hasExplicitControl()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.explicitControlAddress()); } }\n\n    ### Response:", "ground_truth": "Add a destination to this image so it can merge streams.\n\n@param transportIndex from which packets will arrive.\n@param transport      from which packets will arrive.", "predict": " Add destination.\n\n@param transportIndex transport index.\n@param transport transport."}, {"ID": 1858, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean exactlyEqual(final Sketch sketchA, final Sketch sketchB) { //Corner case checks if ((sketchA == null) || (sketchB == null)) { return false; } if (sketchA == sketchB) { return true; } if (sketchA.isEmpty() && sketchB.isEmpty()) { return true; } if (sketchA.isEmpty() || sketchB.isEmpty()) { return false; } final int countA = sketchA.getRetainedEntries(); final int countB = sketchB.getRetainedEntries(); //Create the Union final Union union = SetOperation.builder().setNominalEntries(ceilingPowerOf2(countA + countB)).buildUnion(); union.update(sketchA); union.update(sketchB); final Sketch unionAB = union.getResult(); final long thetaLongUAB = unionAB.getThetaLong(); final long thetaLongA = sketchA.getThetaLong(); final long thetaLongB = sketchB.getThetaLong(); final int countUAB = unionAB.getRetainedEntries(); //Check for identical counts and thetas if ((countUAB == countA) && (countUAB == countB) && (thetaLongUAB == thetaLongA) && (thetaLongUAB == thetaLongB)) { return true; } return false; }\n\n    ### Response: Returns true if the two given sketches have exactly the same hash values and the same\ntheta values. Thus, they are equivalent.\n@param sketchA the given sketch A\n@param sketchB the given sketch B\n@return true if the two given sketches have exactly the same hash values and the same\ntheta values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int insertPacket( final int termId, final int termOffset, final UnsafeBuffer buffer, final int length, final int transportIndex, final InetSocketAddress srcAddress) { final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length); final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId); final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length; if (!isFlowControlUnderRun(packetPosition) && !isFlowControlOverRun(proposedPosition)) { trackConnection(transportIndex, srcAddress, lastPacketTimestampNs); if (isHeartbeat) { if (DataHeaderFlyweight.isEndOfStream(buffer) && !isEndOfStream && allEos(transportIndex)) { LogBufferDescriptor.endOfStreamPosition(rawLog.metaData(), proposedPosition); isEndOfStream = true; } heartbeatsReceived.incrementOrdered(); } else { final UnsafeBuffer termBuffer = termBuffers[indexByPosition(packetPosition, positionBitsToShift)]; TermRebuilder.insert(termBuffer, termOffset, buffer, length); } lastPacketTimestampNs = cachedNanoClock.nanoTime(); hwmPosition.proposeMaxOrdered(proposedPosition); } return length; }\n\n    ### Response:", "ground_truth": "Insert frame into term buffer.\n\n@param termId         for the data packet to insert into the appropriate term.\n@param termOffset     for the start of the packet in the term.\n@param buffer         for the data packet to insert into the appropriate term.\n@param length         of the data packet\n@param transportIndex which the packet came from.\n@param srcAddress     which the packet came from.\n@return number of bytes applied as a result of this insertion.", "predict": " Inserts a packet into the log buffer.\n@param termId the term id of the packet\n@param termOffset the term offset of the packet\n@param buffer the buffer containing the packet data\n@param length the length of the packet data\n@param transportIndex the transport index of the packet\n@param srcAddress the source address of the packet\n@return the length of the packet data\n\n    "}, {"ID": 1859, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> boolean fastUnorderedRemove(final ArrayList<T> list, final T e) { for (int i = 0, size = list.size(); i < size; i++) { if (e == list.get(i)) { fastUnorderedRemove(list, i, size - 1); return true; } } return false; }\n\n    ### Response: Removes element but instead of copying all elements to the left, moves into the same slot the last element.\nThis avoids the copy costs, but spoils the list order. If element is the last element then it is just removed.\n\n@param list to be modified.\n@param e    to be removed.\n@param   element type.\n@return true if found and removed, false otherwise..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter findControlToggle(final CountersReader counters) { final AtomicBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { final int recordOffset = CountersReader.metaDataOffset(i); if (counters.getCounterState(i) == RECORD_ALLOCATED && buffer.getInt(recordOffset + TYPE_ID_OFFSET) == CONTROL_TOGGLE_TYPE_ID) { return new AtomicCounter(counters.valuesBuffer(), i, null); } } return null; }\n\n    ### Response:", "ground_truth": "Find the control toggle counter or return null if not found.\n\n@param counters to search for the control toggle.\n@return the control toggle counter or return null if not found.", "predict": " Finds the control toggle counter in the counters metadata buffer.\n\n@param counters to be searched.\n@return the control toggle counter or null if not found.\n\n    "}, {"ID": 1860, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String put(final String key, final String value) { return propsMap.put(key, value); }\n\n    ### Response: Sets the property with the specified key.\n\n@param key\nThe key (may not be {@code null})\n@param value\nThe value (may not be {@code null})\n@return The previous value of the property, or {@code null} if it did not have one.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String put(final String key, final String value) { return params.put(key, value); }\n\n    ### Response:", "ground_truth": "Put a key and value pair in the map of params.\n\n@param key   of the param to be put.\n@param value of the param to be put.\n@return the existing value otherwise null.", "predict": " Adds a new parameter to the request.\n\n@param key\nThe parameter name (may not be {@code null})\n@param value\nThe parameter value (may not be {@code null})\n@return The previous value of the parameter, or {@code null} if it did not have one."}, {"ID": 1861, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTagValue(String tagName) { Tag[] tags = getTagMap().get(tagName); if (tags == null || tags.length == 0) { return null; } return tags[tags.length - 1].getText(); }\n\n    ### Response: Gets the text value of the first tag in doc that matches tagName.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; }\n\n    ### Response:", "ground_truth": "Get the channel tag, if it exists, that refers to an another channel.\n\n@return channel tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Gets the value of the channel tag in the doc."}, {"ID": 1862, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTagValue(String tagName) { Tag[] tags = getTagMap().get(tagName); if (tags == null || tags.length == 0) { return null; } return tags[tags.length - 1].getText(); }\n\n    ### Response: Gets the text value of the first tag in doc that matches tagName.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String entityTag() { return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null; }\n\n    ### Response:", "ground_truth": "Get the entity tag, if it exists, that refers to an entity such as subscription or publication.\n\n@return entity tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Gets the entity tag from the tags array."}, {"ID": 1863, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Session getSession(final String sessionId) { final Session elem = this.cache.getIfPresent(sessionId); return elem; }\n\n    ### Response: Returns the cached session using the session id..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String addSessionId(final String channel, final int sessionId) { final ChannelUri channelUri = ChannelUri.parse(channel); channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId)); return channelUri.toString(); }\n\n    ### Response:", "ground_truth": "Add a sessionId to a given channel.\n\n@param channel   to add sessionId to.\n@param sessionId to add to channel.\n@return new string that represents channel with sessionId added.", "predict": " Adds the session id to the channel uri and returns the modified channel uri."}, {"ID": 1864, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static final long gatherPartialLongLE(final byte[] data, final int index, final int available) { if(available >= 4) { int i = gatherIntLE(data, index); long l = uintToLong(i); int left = available - 4; if(left == 0) { return l; } int i2 = gatherPartialIntLE(data, index + 4, left); l <<= (left << 3); l |= (long) i2; return l; } else { return (long) gatherPartialIntLE(data, index, available); } }\n\n    ### Response: gather a partial long from the specified index using the specified number\nof bytes into the byte array.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getTag(final String paramValue) { return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG; }\n\n    ### Response:", "ground_truth": "Get the value of the tag from a given parameter value.\n\n@param paramValue to extract the tag value from.\n@return the value of the tag or {@link #INVALID_TAG} if not tagged.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " get the tag value from the specified parameter value. If the parameter value is tagged, extract the tag value from the parameter value using the specified start and end indices. Otherwise, return the invalid tag value."}, {"ID": 1865, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int calculateHeaderSize(final Header header, final Header lastHeader) { final byte headerType = getHeaderType(header, lastHeader); int channelIdAdd = 0; int channelId = header.getChannelId(); if (channelId > 320) { channelIdAdd = 2; } else if (channelId > 63) { channelIdAdd = 1; } return RTMPUtils.getHeaderLength(headerType) + channelIdAdd; }\n\n    ### Response: Calculate number of bytes necessary to encode the header.\n\n@param header\nRTMP message header\n@param lastHeader\nPrevious header\n@return Calculated size.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int appendPadding( final int termId, final int termOffset, final HeaderWriter header, final int length) { final int frameLength = length + HEADER_LENGTH; final int alignedLength = align(frameLength, FRAME_ALIGNMENT); final UnsafeBuffer termBuffer = this.termBuffer; final int termLength = termBuffer.capacity(); int resultingOffset = termOffset + alignedLength; putRawTailOrdered(termId, resultingOffset); if (resultingOffset > termLength) { resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId); } else { header.write(termBuffer, termOffset, frameLength, termId); frameType(termBuffer, termOffset, PADDING_FRAME_TYPE); frameLengthOrdered(termBuffer, termOffset, frameLength); } return resultingOffset; }\n\n    ### Response:", "ground_truth": "Pad a length of the term buffer with a padding record.\n\n@param termId     for the current term.\n@param termOffset in the term at which to append.\n@param header     for writing the default header.\n@param length     of the padding to be written.\n@return the resulting offset of the term after success otherwise {@link #FAILED}.", "predict": " Append padding to the end of the log.\n\n@param termId\nTerm ID\n@param termOffset\nTerm offset\n@param header\nHeader writer\n@param length\nLength of the padding\n@return Resulting offset.\n\n    "}, {"ID": 1866, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sortFileList() { if (this.size() > 1) { Collections.sort(this.fileList, new Comparator() { public final int compare(final Object o1, final Object o2) { final File f1 = (File) o1; final File f2 = (File) o2; final Object[] f1TimeAndCount = backupSuffixHelper .backupTimeAndCount(f1.getName(), baseFile); final Object[] f2TimeAndCount = backupSuffixHelper .backupTimeAndCount(f2.getName(), baseFile); final long f1TimeSuffix = ((Long) f1TimeAndCount[0]).longValue(); final long f2TimeSuffix = ((Long) f2TimeAndCount[0]).longValue(); if ((0L == f1TimeSuffix) && (0L == f2TimeSuffix)) { final long f1Time = f1.lastModified(); final long f2Time = f2.lastModified(); if (f1Time < f2Time) { return -1; } if (f1Time > f2Time) { return 1; } return 0; } if (f1TimeSuffix < f2TimeSuffix) { return -1; } if (f1TimeSuffix > f2TimeSuffix) { return 1; } final int f1Count = ((Integer) f1TimeAndCount[1]).intValue(); final int f2Count = ((Integer) f2TimeAndCount[1]).intValue(); if (f1Count < f2Count) { return -1; } if (f1Count > f2Count) { return 1; } if (f1Count == f2Count) { if (fileHelper.isCompressed(f1)) { return -1; } if (fileHelper.isCompressed(f2)) { return 1; } } return 0; } }); } }\n\n    ### Response: Sort by time bucket, then backup count, and by compression state..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final int updatePublisherLimit() { int workCount = 0; final long senderPosition = this.senderPosition.getVolatile(); if (hasReceivers || (spiesSimulateConnection && spyPositions.length > 0)) { long minConsumerPosition = senderPosition; for (final ReadablePosition spyPosition : spyPositions) { minConsumerPosition = Math.min(minConsumerPosition, spyPosition.getVolatile()); } final long proposedPublisherLimit = minConsumerPosition + termWindowLength; if (publisherLimit.proposeMaxOrdered(proposedPublisherLimit)) { cleanBuffer(proposedPublisherLimit); workCount = 1; } } else if (publisherLimit.get() > senderPosition) { publisherLimit.setOrdered(senderPosition); } return workCount; }\n\n    ### Response:", "ground_truth": "Update the publishers limit for flow control as part of the conductor duty cycle.\n\n@return 1 if the limit has been updated otherwise 0.", "predict": " Update the publisher limit based on the current sender position and the positions of the receivers and spies. If the proposed publisher limit is greater than the current publisher limit, update the publisher limit and return 1 to indicate that some work was done. Otherwise, return 0 to indicate that no work was done."}, {"ID": 1867, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookie newCookie(final String name, final String value, final String purpose, final String domain, final int maxAge, final String path, final boolean secure) { final Cookie cookie = new Cookie(name, value); cookie.setComment(purpose); cookie.setDomain(domain); cookie.setMaxAge(maxAge); cookie.setPath(path); return cookie; }\n\n    ### Response: Creates a new cookie.\n\n@param name\nthe name\n@param value\nthe value\n@param purpose\nthe purpose\n@param domain\nthe domain\n@param maxAge\nthe max age\n@param path\nthe path\n@param secure\nthe secure\n@return the cookie.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, streamId, channel), countersManager); }\n\n    ### Response:", "ground_truth": "Allocate a counter for tracking a position on a stream of messages.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@param sessionId       for the stream of messages.\n@param streamId        for the stream of messages.\n@param channel         for the stream of messages.\n@return a new {@link UnsafeBufferPosition} for tracking the stream.", "predict": " Allocates a new position in the counters buffer.\n\n@param tempBuffer\nthe temporary buffer\n@param name\nthe name\n@param typeId\nthe type id\n@param countersManager\nthe counters manager\n@param registrationId\nthe registration id\n@param sessionId\nthe session id\n@param streamId\nthe stream id\n@param channel\nthe channel\n@return the position in the counters buffer."}, {"ID": 1868, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String getLevelTag(final int logLevel) { switch (logLevel) { case LogLevelConst.FATAL: return LogConstants.TAG_FATAL; case LogLevelConst.ERROR: return LogConstants.TAG_ERROR; case LogLevelConst.WARNING: return LogConstants.TAG_WARNING; case LogLevelConst.INFO: return LogConstants.TAG_INFO; case LogLevelConst.DEBUG: return LogConstants.TAG_DEBUG; default: return \"[DEFAULT]\"; } }\n\n    ### Response: Gets the string representation of the log level.\n\n@param logLevel Level of the log message.\n@return String representation of the log level..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String labelName(final int typeId) { switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: return PublisherLimit.NAME; case SenderPos.SENDER_POSITION_TYPE_ID: return SenderPos.NAME; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: return ReceiverHwm.NAME; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: return SubscriberPos.NAME; case ReceiverPos.RECEIVER_POS_TYPE_ID: return ReceiverPos.NAME; case SenderLimit.SENDER_LIMIT_TYPE_ID: return SenderLimit.NAME; case PublisherPos.PUBLISHER_POS_TYPE_ID: return PublisherPos.NAME; case SenderBpe.SENDER_BPE_TYPE_ID: return SenderBpe.NAME; default: return \"<unknown>\"; } }\n\n    ### Response:", "ground_truth": "Return the label name for a counter type identifier.\n\n@param typeId of the counter.\n@return the label name as a String.", "predict": " Gets the name of the entity type based on the type ID.\n\n@param typeId ID of the entity type.\n@return Name of the entity type."}, {"ID": 1869, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @NonNull private Pair<Integer, Integer> addViewSpacing(@NonNull final Area previousArea, @NonNull final View previousView, @NonNull final Area area) { int scrollViewPaddingTop = 0; int scrollViewMarginBottom = 0; int padding = -1; if (previousArea == Area.TITLE) { padding = getResources().getDimensionPixelSize(R.dimen.dialog_title_bottom_padding); } else if (previousArea == Area.MESSAGE) { padding = getResources().getDimensionPixelSize(R.dimen.dialog_message_bottom_padding); } if (previousArea != Area.HEADER && !scrollableArea.isScrollable(previousArea) && scrollableArea.isScrollable(area)) { int originalPadding = padding; padding = originalPadding / 2; scrollViewPaddingTop = originalPadding - padding; } else if (area == Area.BUTTON_BAR && scrollableArea.isScrollable(previousArea) && !scrollableArea.isScrollable(area)) { int originalPadding = padding; padding = originalPadding / 2; scrollViewMarginBottom = originalPadding - padding; } if (padding != -1) { previousView.setPadding(previousView.getPaddingLeft(), previousView.getPaddingTop(), previousView.getPaddingRight(), previousView.getPaddingBottom() + padding); } return Pair.create(scrollViewPaddingTop, scrollViewMarginBottom); }\n\n    ### Response: Adds spacing to the view of a specific area. The spacing is added to the view's current\nbottom padding.\n\n@param previousArea\nThe area, the view, the spacing should be applied to, corresponds to, as an instance\nof the class {@link Area}. The area may not be null\n@param previousView\nThe view, the spacing should be applied to, as an instance of the class {@link View}.\nThe view may not be null\n@param area\nThe current area as a value of the enum {@link Area}. The area may not be null\n@return A pair, which contains the top and bottom padding, which should be added to the\ndialog's scroll view, as an instance of the class {@link Pair} value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) { final int limit = Math.min(maxLength, termBuffer.capacity() - offset); int available = 0; int padding = 0; do { final int termOffset = offset + available; final int frameLength = frameLengthVolatile(termBuffer, termOffset); if (frameLength <= 0) { break; } int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT); if (isPaddingFrame(termBuffer, termOffset)) { padding = alignedFrameLength - HEADER_LENGTH; alignedFrameLength = HEADER_LENGTH; } available += alignedFrameLength; if (available > limit) { available -= alignedFrameLength; padding = 0; break; } } while (0 == padding && available < limit); return pack(padding, available); }\n\n    ### Response:", "ground_truth": "Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.\n\n@param termBuffer to be scanned for new message fragments.\n@param offset     at which the scan should begin.\n@param maxLength  in bytes of how much should be scanned.\n@return resulting status of the scan which packs the available bytes and padding into a long.", "predict": " Scans the term buffer for the availability of data.\n\n@param termBuffer\nThe term buffer, which contains the data, as an instance of the class {@link UnsafeBuffer}.\nThe buffer may not be null\n@param offset\nThe offset at which the scan should start, as an integer\n@param maxLength\nThe maximum length of the data, which should be scanned, as an integer\n@return A long value, which represents the padding and available data, packed into a single\nlong value. The padding is stored in the most significant bits, while the available data is\nstored in the least significant bits. The padding is a positive integer, while the available\ndata is a non-negative integer. If the padding is zero, the available data is the actual\nlength of the data. If the padding is greater than zero, the available data is the maximum\nlength of the data, which can be read from the term buffer."}, {"ID": 1870, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clear() { this.attributes.clear(); this.queryParameters = null; this.inReader = null; this.streamActive = false; this.inStream = null; this.encoding = null; this.sessionData = null; this.strippedURI = null; this.srvContext = null; this.srvPath = null; this.pathInfo = null; this.pathInfoComputed = false; this.filters = null; }\n\n    ### Response: Clear all the temporary variables of this request..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder clear() { prefix = null; media = null; endpoint = null; networkInterface = null; controlEndpoint = null; controlMode = null; tags = null; alias = null; reliable = null; ttl = null; mtu = null; termLength = null; initialTermId = null; termId = null; termOffset = null; sessionId = null; linger = null; sparse = null; eos = null; tether = null; isSessionIdTagged = false; return this; }\n\n    ### Response:", "ground_truth": "Clear out all the values thus setting back to the initial state.\n\n@return this for a fluent API.", "predict": " Clear all the parameters of this channel URI builder."}, {"ID": 1871, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int moveCodePointOffset(String source, int offset16, int shift32) { int result = offset16; int size = source.length(); int count; char ch; if (offset16 < 0 || offset16 > size) { throw new StringIndexOutOfBoundsException(offset16); } if (shift32 > 0) { if (shift32 + offset16 > size) { throw new StringIndexOutOfBoundsException(offset16); } count = shift32; while (result < size && count > 0) { ch = source.charAt(result); if (isLeadSurrogate(ch) && ((result + 1) < size) && isTrailSurrogate(source.charAt(result + 1))) { result++; } count--; result++; } } else { if (offset16 + shift32 < 0) { throw new StringIndexOutOfBoundsException(offset16); } for (count = -shift32; count > 0; count--) { result--; if (result < 0) { break; } ch = source.charAt(result); if (isTrailSurrogate(ch) && result > 0 && isLeadSurrogate(source.charAt(result - 1))) { result--; } } } if (count != 0) { throw new StringIndexOutOfBoundsException(shift32); } return result; }\n\n    ### Response: Shifts offset16 by the argument number of codepoints\n\n@param source string\n@param offset16 UTF16 position to shift\n@param shift32 number of codepoints to shift\n@return new shifted offset16\n@exception IndexOutOfBoundsException if the new offset16 is out of bounds..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder validate() { if (null == media) { throw new IllegalStateException(\"media type is mandatory\"); } if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) { throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\"); } int count = 0; count += null == initialTermId ? 0 : 1; count += null == termId ? 0 : 1; count += null == termOffset ? 0 : 1; if (count > 0) { if (count < 3) { throw new IllegalStateException( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\"); } if (termId - initialTermId < 0) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId); } if (null != termLength && termOffset > termLength) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException(\"termOffset=\" + termOffset + \" > termLength=\" + termLength); } } return this; }\n\n    ### Response:", "ground_truth": "Validates that the collection of set parameters are valid together.\n\n@return this for a fluent API.\n@throws IllegalStateException if the combination of params is invalid.", "predict": " Validates the channel URI string and returns a new ChannelUriStringBuilder object.\n\n@return a new ChannelUriStringBuilder object\n@exception IllegalStateException if the channel URI string is invalid."}, {"ID": 1872, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPrefix(PackageElement packageElement) { if (packageElement == null) { return \"\"; } String packageName = packageElement.getQualifiedName().toString(); String prefix = getPrefix(packageName); if (prefix != null) { return prefix; } prefix = packageLookup.getObjectiveCName(packageName); if (prefix == null) { prefix = NameTable.camelCaseQualifiedName(packageName); } addPrefix(packageName, prefix); return prefix; }\n\n    ### Response: Return the prefix for a specified package. If a prefix was specified\nfor the package, then that prefix is returned. Otherwise, a camel-cased\nprefix is created from the package name..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder prefix(final String prefix) { if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid prefix: \" + prefix); } this.prefix = prefix; return this; }\n\n    ### Response:", "ground_truth": "Set the prefix for taking an addition action such as spying on an outgoing publication with \"aeron-spy\".\n\n@param prefix to be applied to the URI before the the scheme.\n@return this for a fluent API.\n@see ChannelUri#SPY_QUALIFIER", "predict": " Set the prefix for the channel URI. The prefix is used to identify the\napplication that is using the channel. The prefix must be a valid Java identifier\nand cannot be \"spy\" or an empty string.\n\n    "}, {"ID": 1873, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Matrix3d set(int column, int row, double value) { switch (column) { case 0: switch (row) { case 0: this.m00 = value; return this; case 1: this.m01 = value; return this; case 2: this.m02 = value; return this; default: break; } break; case 1: switch (row) { case 0: this.m10 = value; return this; case 1: this.m11 = value; return this; case 2: this.m12 = value; return this; default: break; } break; case 2: switch (row) { case 0: this.m20 = value; return this; case 1: this.m21 = value; return this; case 2: this.m22 = value; return this; default: break; } break; default: break; } throw new IllegalArgumentException(); }\n\n    ### Response: Set the matrix element at the given column and row to the specified value.\n\n@param column\nthe colum index in [0..2]\n@param row\nthe row index in [0..2]\n@param value\nthe value\n@return this.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder media(final String media) { switch (media) { case CommonContext.UDP_MEDIA: case CommonContext.IPC_MEDIA: break; default: throw new IllegalArgumentException(\"invalid media: \" + media); } this.media = media; return this; }\n\n    ### Response:", "ground_truth": "Set the media for this channel. Valid values are \"udp\" and \"ipc\".\n\n@param media for this channel.\n@return this for a fluent API.", "predict": " Set the media type for the channel URI.\n\n@param media\nthe media type, either \"udp\" or \"ipc\"\n@return this.\n\n    "}, {"ID": 1874, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static FormatOptions of(int flags, int width, int precision) { if (!checkFlagConsistency(flags, width != UNSET)) { throw new IllegalArgumentException(\"invalid flags: 0x\" + Integer.toHexString(flags)); } if ((width < 1 || width > MAX_ALLOWED_WIDTH) && width != UNSET) { throw new IllegalArgumentException(\"invalid width: \" + width); } if ((precision < 0 || precision > MAX_ALLOWED_PRECISION) && precision != UNSET) { throw new IllegalArgumentException(\"invalid precision: \" + precision); } return new FormatOptions(flags, width, precision); }\n\n    ### Response: Creates a options instance with the given values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder controlMode(final String controlMode) { if (null != controlMode && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_MANUAL) && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_DYNAMIC)) { throw new IllegalArgumentException(\"invalid control mode: \" + controlMode); } this.controlMode = controlMode; return this; }\n\n    ### Response:", "ground_truth": "Set the control mode for multi-destination-cast. Set to \"manual\" for allowing control from the publication API.\n\n@param controlMode for taking control of MDC.\n@return this for a fluent API.\n@see Publication#addDestination(String)\n@see Publication#removeDestination(String)\n@see CommonContext#MDC_CONTROL_MODE_PARAM_NAME\n@see CommonContext#MDC_CONTROL_MODE_MANUAL\n@see CommonContext#MDC_CONTROL_MODE_DYNAMIC", "predict": " Sets the control mode for the channel URI.\n\n    "}, {"ID": 1875, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final int getIndex(String name, Object... args) { Integer defaultIndex = methodIndexs.get(name); if (null != defaultIndex) return defaultIndex.intValue(); else { final List<MethodInfo> exists = methods.get(name); if (null != exists) { for (MethodInfo info : exists) if (info.matches(args)) return info.index; } return -1; } }\n\n    ### Response: Return method index,return -1 if not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder termLength(final Integer termLength) { if (null != termLength) { LogBufferDescriptor.checkTermLength(termLength); } this.termLength = termLength; return this; }\n\n    ### Response:", "ground_truth": "Set the length of buffer used for each term of the log. Valid values are powers of 2 in the 64K - 1G range.\n\n@param termLength of the buffer used for each term of the log.\n@return this for a fluent API.\n@see CommonContext#TERM_LENGTH_PARAM_NAME", "predict": " Set the term length for the channel URI. The term length must be between 1 and 65535 inclusive. If the term length is not set, the default value of 64KB will be used."}, {"ID": 1876, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void validate(int hours, int minutes, int seconds) { if (hours < -18 || hours > 18) { throw new DateTimeException(\"Zone offset hours not in valid range: value \" + hours + \" is not in the range -18 to 18\"); } if (hours > 0) { if (minutes < 0 || seconds < 0) { throw new DateTimeException(\"Zone offset minutes and seconds must be positive because hours is positive\"); } } else if (hours < 0) { if (minutes > 0 || seconds > 0) { throw new DateTimeException(\"Zone offset minutes and seconds must be negative because hours is negative\"); } } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) { throw new DateTimeException(\"Zone offset minutes and seconds must have the same sign\"); } if (Math.abs(minutes) > 59) { throw new DateTimeException(\"Zone offset minutes not in valid range: abs(value) \" + Math.abs(minutes) + \" is not in the range 0 to 59\"); } if (Math.abs(seconds) > 59) { throw new DateTimeException(\"Zone offset seconds not in valid range: abs(value) \" + Math.abs(seconds) + \" is not in the range 0 to 59\"); } if (Math.abs(hours) == 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) { throw new DateTimeException(\"Zone offset not in valid range: -18:00 to +18:00\"); } }\n\n    ### Response: Validates the offset fields.\n\n@param hours  the time-zone offset in hours, from -18 to +18\n@param minutes  the time-zone offset in minutes, from 0 to &plusmn;59\n@param seconds  the time-zone offset in seconds, from 0 to &plusmn;59\n@throws DateTimeException if the offset is not in the required range.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder termOffset(final Integer termOffset) { if (null != termOffset) { if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) { throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset); } if (0 != (termOffset & (FRAME_ALIGNMENT - 1))) { throw new IllegalArgumentException(\"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset); } } this.termOffset = termOffset; return this; }\n\n    ### Response:", "ground_truth": "Set the offset within a term at which a publication will start. This when combined with the term id can establish\na starting position.\n\n@param termOffset within a term at which a publication will start.\n@return this for a fluent API.\n@see CommonContext#TERM_OFFSET_PARAM_NAME", "predict": " Sets the term offset for the channel.\n\n@param termOffset the term offset for the channel, in bytes.\n@return this ChannelUriStringBuilder for chaining.\n@throws IllegalArgumentException if the term offset is not in the required range or not a multiple of FRAME_ALIGNMENT."}, {"ID": 1877, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirectoryPollerBuilder setPollingInterval(long interval, TimeUnit timeUnit) { if (interval < 0) { throw new IllegalArgumentException(\"Argument 'interval' is negative: \" + interval); } pollingIntervalInMillis = timeUnit.toMillis(interval); return this; }\n\n    ### Response: Set the interval between each poll cycle. Optional parameter.\nDefault value is 1000 milliseconds.\n\n@param interval - the interval between two poll-cycles.\n@param timeUnit - the unit of the interval. Example: TimeUnit.MINUTES\n@return {@link DirectoryPollerBuilder}\n@throws IllegalArgumentException if interval is negative..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder linger(final Long lingerNs) { if (null != lingerNs && lingerNs < 0) { throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs); } this.linger = lingerNs; return this; }\n\n    ### Response:", "ground_truth": "Set the time a network publication will linger in nanoseconds after being drained. This time is so that tail loss\ncan be recovered.\n\n@param lingerNs time for the publication after it is drained.\n@return this for a fluent API.\n@see CommonContext#LINGER_PARAM_NAME", "predict": " Set the linger timeout in nanoseconds.\n\n@param lingerNs - the linger timeout in nanoseconds.\n@return {@link ChannelUriStringBuilder}\n@throws IllegalArgumentException if lingerNs is negative."}, {"ID": 1878, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static function _batchUpdateHelper(Api\\MtBatchSmsUpdate $batch) { $fields = []; if (!empty($batch->getRecipientInsertions())) { $fields['to_add'] = $batch->getRecipientInsertions(); } if (!empty($batch->getRecipientRemovals())) { $fields['to_remove'] = $batch->getRecipientRemovals(); } if (null != $batch->getSender()) { $fields['from'] = $batch->getSender(); } if (null != $batch->getDeliveryReport()) { if ($batch->getDeliveryReport() === Api\\Reset::reset()) { $fields['delivery_report'] = null; } else { $fields['delivery_report'] = $batch->getDeliveryReport(); } } if (null != $batch->getSendAt()) { if ($batch->getSendAt() === Api\\Reset::reset()) { $fields['send_at'] = null; } else { $fields['send_at'] = Serialize::_dateTime($batch->getSendAt()); } } if (null != $batch->getExpireAt()) { if ($batch->getExpireAt() === Api\\Reset::reset()) { $fields['expire_at'] = null; } else { $fields['expire_at'] = Serialize::_dateTime($batch->getExpireAt()); } } if (null != $batch->getCallbackUrl()) { if ($batch->getCallbackUrl() === Api\\Reset::reset()) { $fields['callback_url'] = null; } else { $fields['callback_url'] = $batch->getCallbackUrl(); } } return $fields; }\n\n    ### Response: Helper that prepares the given batch for serialization\n\n@param Api\\MtBatchSmsUpdate $batch the batch to serialize\n\n@return [] associative array suitable for JSON serialization.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void openDatagramChannel(final AtomicCounter statusIndicator) { try { sendDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); receiveDatagramChannel = sendDatagramChannel; if (udpChannel.isMulticast()) { if (null != connectAddress) { receiveDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); } receiveDatagramChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); receiveDatagramChannel.bind(new InetSocketAddress(endPointAddress.getPort())); receiveDatagramChannel.join(endPointAddress.getAddress(), udpChannel.localInterface()); sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_IF, udpChannel.localInterface()); if (udpChannel.isHasMulticastTtl()) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, udpChannel.multicastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } else if (context.socketMulticastTtl() != 0) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, context.socketMulticastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } } else { sendDatagramChannel.bind(bindAddress); } if (null != connectAddress) { sendDatagramChannel.connect(connectAddress); } if (0 != context.socketSndbufLength()) { sendDatagramChannel.setOption(SO_SNDBUF, context.socketSndbufLength()); } if (0 != context.socketRcvbufLength()) { receiveDatagramChannel.setOption(SO_RCVBUF, context.socketRcvbufLength()); } sendDatagramChannel.configureBlocking(false); receiveDatagramChannel.configureBlocking(false); } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERRORED); } CloseHelper.quietClose(sendDatagramChannel); if (receiveDatagramChannel != sendDatagramChannel) { CloseHelper.quietClose(receiveDatagramChannel); } sendDatagramChannel = null; receiveDatagramChannel = null; throw new AeronException( \"channel error - \" + ex.getMessage() + \" (at \" + ex.getStackTrace()[0].toString() + \"): \" + udpChannel.originalUriString(), ex); } }\n\n    ### Response:", "ground_truth": "Create the underlying channel for reading and writing.\n\n@param statusIndicator to set for error status", "predict": " Opens the datagram channel for sending and receiving messages.\n\n@param statusIndicator an atomic counter that will be set to errored if an exception occurs during channel creation.\n\n@throws AeronException if an exception occurs during channel creation."}, {"ID": 1879, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void shutdown() { if (zombie) { return; } logger.info(\"Shutting down Rythm Engine: [%s]\", id()); if (null != _cacheService) { try { _cacheService.shutdown(); } catch (Exception e) { logger.error(e, \"Error shutdown cache service\"); } } if (null != _secureExecutor) { try { _secureExecutor.shutdown(); } catch (Exception e) { logger.error(e, \"Error shutdown secure executor\"); } } if (null != _resourceManager) { try { _resourceManager.shutdown(); } catch (Exception e) { logger.error(e, \"Error shutdown resource manager\"); } } if (null != shutdownListener) { try { shutdownListener.onShutdown(); } catch (Exception e) { logger.error(e, \"Error execute shutdown listener\"); } } if (null != nonExistsTemplatesChecker) { nonExistsTemplatesChecker.onShutdown(); } if (null != _templates) _templates.clear(); if (null != _classes) _classes.clear(); if (null != _nonExistsTags) _nonExistsTags.clear(); if (null != nonExistsTemplates) nonExistsTemplates.clear(); if (null != _nonTmpls) _nonTmpls.clear(); _classLoader = null; Rythm.RenderTime.clear(); zombie = true; }\n\n    ### Response: Shutdown this rythm engine.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (!isClosed) { isClosed = true; try { if (null != selectionKey) { selectionKey.cancel(); } if (null != transportPoller) { transportPoller.cancelRead(this); transportPoller.selectNowWithoutProcessing(); } if (null != sendDatagramChannel) { sendDatagramChannel.close(); } if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) { receiveDatagramChannel.close(); } if (null != transportPoller) { transportPoller.selectNowWithoutProcessing(); } } catch (final IOException ex) { errorLog.record(ex); } } }\n\n    ### Response:", "ground_truth": "Close transport, canceling any pending read operations and closing channel", "predict": " Close this socket."}, {"ID": 1880, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean regionMatches(int thisStart, CharSequence string, int start, int length) { if (string == null) { throw new NullPointerException(\"string\"); } if (start < 0 || string.length() - start < length) { return false; } final int thisLen = length(); if (thisStart < 0 || thisLen - thisStart < length) { return false; } if (length <= 0) { return true; } final int thatEnd = start + length; for (int i = start, j = thisStart + arrayOffset(); i < thatEnd; i++, j++) { if (b2c(value[j]) != string.charAt(i)) { return false; } } return true; }\n\n    ### Response: Compares the specified string to this string and compares the specified range of characters to determine if they\nare the same.\n\n@param thisStart the starting offset in this string.\n@param string the string to compare.\n@param start the starting offset in the specified string.\n@param length the number of characters to compare.\n@return {@code true} if the ranges of characters are equal, {@code false} otherwise\n@throws NullPointerException if {@code string} is {@code null}..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isValidFrame(final UnsafeBuffer buffer, final int length) { boolean isFrameValid = true; if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) { isFrameValid = false; invalidPackets.increment(); } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) { isFrameValid = false; invalidPackets.increment(); } return isFrameValid; }\n\n    ### Response:", "ground_truth": "Is the received frame valid. This method will do some basic checks on the header and can be\noverridden in a subclass for further validation.\n\n@param buffer containing the frame.\n@param length of the frame.\n@return true if the frame is believed valid otherwise false.", "predict": " Checks if the frame is valid or not.\n\n@param buffer the buffer containing the frame.\n@param length the length of the frame.\n@return {@code true} if the frame is valid, {@code false} otherwise.\n\n    "}, {"ID": 1881, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static LocalDateTime localDateTimeOf(final String value) { var result = (LocalDateTime) null; try { result = LocalDateTime.parse(value, DateTimeFormatter.ISO_LOCAL_DATE_TIME); } catch (final Exception e) { result = null; } if (result == null) { try { result = LocalDateTime.parse(value, DateTimeFormatter.ISO_ZONED_DATE_TIME); } catch (final Exception e) { result = null; } } if (result == null) { try { result = LocalDateTime.parse(value); } catch (final Exception e) { result = null; } } if (result == null) { try { result = LocalDateTime.parse(value.toUpperCase(), DateTimeFormatter.ofPattern(\"MM/dd/yyyy hh:mm a\")); } catch (final Exception e) { result = null; } } if (result == null) { try { result = LocalDateTime.parse(value.toUpperCase(), DateTimeFormatter.ofPattern(\"MM/dd/yyyy h:mm a\")); } catch (final Exception e) { result = null; } } if (result == null) { try { result = LocalDateTime.parse(value, DateTimeFormatter.ofPattern(\"MM/dd/yyyy HH:mm\")); } catch (final Exception e) { result = null; } } if (result == null) { try { val ld = LocalDate.parse(value, DateTimeFormatter.ofPattern(\"MM/dd/yyyy\")); result = LocalDateTime.of(ld, LocalTime.now()); } catch (final Exception e) { result = null; } } if (result == null) { try { val ld = LocalDate.parse(value); result = LocalDateTime.of(ld, LocalTime.now()); } catch (final Exception e) { result = null; } } return result; }\n\n    ### Response: Parse the given value as a local datetime.\n\n@param value the value\n@return the date/time instance.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public InetSocketAddress receive(final ByteBuffer buffer) { buffer.clear(); InetSocketAddress address = null; try { if (receiveDatagramChannel.isOpen()) { address = (InetSocketAddress)receiveDatagramChannel.receive(buffer); } } catch (final PortUnreachableException ignored) { } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } return address; }\n\n    ### Response:", "ground_truth": "Receive a datagram from the media layer.\n\n@param buffer into which the datagram will be received.\n@return the source address of the datagram if one is available otherwise false.", "predict": " Receive a datagram packet from the receiveDatagramChannel and return the address of the sender.\n\n@param buffer the buffer to receive the datagram packet\n@return the address of the sender or null if no packet was received.\n\n    "}, {"ID": 1882, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int[] calculateInYearsMonthsDaysHoursMinutesAndSeconds(final long compute) { long uebrig = -1; final int[] result = new int[6]; final int years = (int)this.calculateInYears(compute); if (0 < years) { result[0] = years; uebrig = compute - years * ONE_YEAR; } else { result[0] = 0; } final int months = (int)this.calculateInDefaultMonth(uebrig); if (0 < months) { result[1] = months; uebrig -= months * ONE_DEFAULT_MONTH; } else { result[1] = 0; } final int days = (int)this.calculateInDays(uebrig); if (0 < days) { result[2] = days; uebrig -= days * ONE_DAY; } else { result[2] = 0; } final int hours = (int)this.calculateInHours(uebrig); if (0 < hours) { result[3] = hours; uebrig -= hours * ONE_HOUR; } else { result[3] = 0; } final int minutes = (int)this.calculateInMinutes(uebrig); if (0 < minutes) { result[4] = minutes; uebrig -= minutes * ONE_MINUTE; } else { result[4] = 0; } final int seconds = (int)this.calculateInSeconds(uebrig); if (0 < seconds) { result[5] = seconds; } else { result[5] = 0; } return result; }\n\n    ### Response: Calculate in years months days hours minutes and seconds.\n\n@param compute\nThe long to calculate.\n@return the int[] Returns an int array where the first element is the years the second\nelement the months the third element the days then hours, minutes and seconds..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onNak( final int termId, final int termOffset, final int length, final int termLength, final RetransmitSender retransmitSender) { if (!isInvalid(termOffset, termLength)) { if (null == activeRetransmitsMap.get(termId, termOffset) && activeRetransmitsMap.size() < MAX_RETRANSMITS_DEFAULT) { final RetransmitAction action = assignRetransmitAction(); action.termId = termId; action.termOffset = termOffset; action.length = Math.min(length, termLength - termOffset); final long delay = delayGenerator.generateDelay(); if (0 == delay) { retransmitSender.resend(termId, termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else { action.delay(delay, nanoClock.nanoTime()); } activeRetransmitsMap.put(termId, termOffset, action); } } }\n\n    ### Response:", "ground_truth": "Called on reception of a NAK to start retransmits handling.\n\n@param termId           from the NAK and the term id of the buffer to retransmit from\n@param termOffset       from the NAK and the offset of the data to retransmit\n@param length           of the missing data\n@param termLength       of the term buffer.\n@param retransmitSender to call if an immediate retransmit is required", "predict": " On nak.\n\n@param termId\nThe term id.\n@param termOffset\nThe term offset.\n@param length\nThe length.\n@param termLength\nThe term length.\n@param retransmitSender\nThe retransmit sender.\n\n    "}, {"ID": 1883, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setChainLength(int nrClusters) throws IOException { if (nrClusters < 0) throw new IllegalArgumentException( \"negative cluster count\"); //NOI18N if ((this.startCluster == 0) && (nrClusters == 0)) { /* nothing to do */ } else if ((this.startCluster == 0) && (nrClusters > 0)) { final long[] chain = fat.allocNew(nrClusters); this.startCluster = chain[0]; } else { final long[] chain = fat.getChain(startCluster); if (nrClusters != chain.length) { if (nrClusters > chain.length) { /* grow the chain */ int count = nrClusters - chain.length; while (count > 0) { fat.allocAppend(getStartCluster()); count--; } } else { /* shrink the chain */ if (nrClusters > 0) { fat.setEof(chain[nrClusters - 1]); for (int i = nrClusters; i < chain.length; i++) { fat.setFree(chain[i]); } } else { for (int i=0; i < chain.length; i++) { fat.setFree(chain[i]); } this.startCluster = 0; } } } } }\n\n    ### Response: Sets the length of this cluster chain in clusters.\n\n@param nrClusters the new number of clusters this chain should contain,\nmust be {@code >= 0}\n@throws IOException on error updating the chain length\n@see #setSize(long).\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void processTimeouts(final long nowNs, final RetransmitSender retransmitSender) { if (activeRetransmitsMap.size() > 0) { for (final RetransmitAction action : retransmitActionPool) { if (DELAYED == action.state && (action.expireNs - nowNs < 0)) { retransmitSender.resend(action.termId, action.termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else if (LINGERING == action.state && (action.expireNs - nowNs < 0)) { action.cancel(); activeRetransmitsMap.remove(action.termId, action.termOffset); } } } }\n\n    ### Response:", "ground_truth": "Called to process any outstanding timeouts.\n\n@param nowNs            time in nanoseconds\n@param retransmitSender to call on retransmissions", "predict": " Processes any retransmit timeouts that have occurred since the last call to this method.\n\n@param nowNs the current time in nanoseconds\n@param retransmitSender the retransmit sender to use for sending retransmissions\n@see RetransmitSender\n\n    "}, {"ID": 1884, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getStatusAsString(int status) { if (status == STATUS_PENDING) { return \"PENDING\"; } else if (status == STATUS_ACTIVE) { return \"ACTIVE\"; } else if (status == STATUS_DONE) { return \"DONE\"; } else if (status == STATUS_FAILED) { return \"FAILED\"; } else if (status == STATUS_SUSPENDED) { return \"SUSPENDED\"; } else if (status == STATUS_UNSUBMITTED) { return \"UNSUBMITTED\"; } else if (status == STATUS_STAGE_IN) { return \"STAGE_IN\"; } else if (status == STATUS_STAGE_OUT) { return \"STAGE_OUT\"; } return \"Unknown\"; }\n\n    ### Response: Convert the status of a GramJob from an integer to a string. This\nmethod is not typically called by users.\n\n@return string representing the status of the GramJob passed as an\nargument..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String status(final long status) { if (INITIALIZING == status) { return \"INITIALIZING\"; } if (ERRORED == status) { return \"ERRORED\"; } if (ACTIVE == status) { return \"ACTIVE\"; } if (CLOSING == status) { return \"CLOSING\"; } return \"unknown id=\" + status; }\n\n    ### Response:", "ground_truth": "String representation of the channel status.\n\n@param status to be converted.\n@return representation of the channel status.", "predict": " Get the string representation of a status id. This method is\ntypically called by other classes to get a string representation of a\nstatus id.\n\n@param status the status id to convert to a string\n@return the string representation of the status id\n@throws IllegalArgumentException if the status id is not recognized"}, {"ID": 1885, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getArgumentUsage( final Map<String, NamedArgumentDefinition> allActualArguments, final Collection<CommandLinePluginDescriptor<?>> pluginDescriptors, final int argumentColumnWidth, final int descriptionColumnWidth) { final StringBuilder sb = new StringBuilder(); sb.append(\"--\").append(getLongName()); if (!getShortName().isEmpty()) { sb.append(\",-\").append(getShortName()); } sb.append(\":\").append(getUnderlyingFieldClass().getSimpleName()); int labelLength = sb.toString().length(); int numSpaces = argumentColumnWidth - labelLength; if (labelLength > argumentColumnWidth) { sb.append(\"\\n\"); numSpaces = argumentColumnWidth; } printSpaces(sb, numSpaces); final String description = getArgumentDescription(allActualArguments, pluginDescriptors); final String wrappedDescription = Utils.wrapParagraph(description, descriptionColumnWidth); final String[] descriptionLines = wrappedDescription.split(\"\\n\"); for (int i = 0; i < descriptionLines.length; ++i) { if (i > 0) { printSpaces(sb, argumentColumnWidth); } sb.append(descriptionLines[i]); sb.append(\"\\n\"); } sb.append(\"\\n\"); return sb.toString(); }\n\n    ### Response: Return a string with the usage statement for this argument.\n@param allActualArguments {code Map} of all namedArgumentDefinitions for the containing object\n@param pluginDescriptors Collection of {@code CommandLinePluginDescriptor} objects for the containing object\n@param argumentColumnWidth width reserved for argument name column display\n@param descriptionColumnWidth width reserved for argument description column display\n@return the usage string for this argument.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) { final int keyLength = tempBuffer.putStringWithoutLengthAscii( CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH); tempBuffer.putInt(CHANNEL_OFFSET, keyLength); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name); labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, \": \"); labelLength += tempBuffer.putStringWithoutLengthAscii( keyLength + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength); return countersManager.newCounter(typeId, tempBuffer, 0, keyLength, tempBuffer, keyLength, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate an indicator for tracking the status of a channel endpoint.\n\n@param tempBuffer      to be used for labels and metadata.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param channel         for the stream of messages.\n@return a new {@link AtomicCounter} for tracking the status.", "predict": " Allocate a new atomic counter with the given name, type id, and channel.\n@param tempBuffer {code MutableDirectBuffer} to use for temporary storage\n@param name {code String} name of the counter\n@param typeId {code int} type id of the counter\n@param countersManager {code CountersManager} to allocate the counter from\n@param channel {code String} channel to allocate the counter on\n@return the newly allocated atomic counter."}, {"ID": 1886, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AsciiSequenceView wrap(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; }\n\n    ### Response: Wrap a range of an existing buffer containing an ASCII sequence.\n\n@param buffer containing the ASCII sequence.\n@param offset at which the ASCII sequence begins.\n@param length of the ASCII sequence in bytes.\n@return this for a fluent API..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; }\n\n    ### Response:", "ground_truth": "Reset the values.\n\n@param buffer which is the super set.\n@param offset at which the vector begins.\n@param length of the vector.\n@return this for a fluent API.", "predict": " Reset the buffer and offset and length of this vector.\n\n@param buffer containing the data.\n@param offset at which the data begins.\n@param length of the data in bytes.\n@return this for a fluent API."}, {"ID": 1887, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StrBuilder insert(final int index, final char chars[], final int offset, final int length) { validateIndex(index); if (chars == null) { return insert(index, nullText); } if (offset < 0 || offset > chars.length) { throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset); } if (length < 0 || offset + length > chars.length) { throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length); } if (length > 0) { ensureCapacity(size + length); System.arraycopy(buffer, index, buffer, index + length, size - index); System.arraycopy(chars, offset, buffer, index, length); size += length; } return this; }\n\n    ### Response: Inserts part of the character array into this builder.\nInserting null will use the stored null text value.\n\n@param index  the index to add at, must be valid\n@param chars  the char array to insert\n@param offset  the offset into the character array to start at, must be valid\n@param length  the length of the character array part to copy, must be positive\n@return this, to enable chaining\n@throws IndexOutOfBoundsException if any index is invalid.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirectBufferVector validate() { final int capacity = buffer.capacity(); if (offset < 0 || offset >= capacity) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity); } if (length < 0 || length > (capacity - offset)) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length); } return this; }\n\n    ### Response:", "ground_truth": "Ensure the vector is valid for the buffer.\n\n@throws NullPointerException if the buffer is null.\n@throws IllegalArgumentException if the offset is out of range for the buffer.\n@throws IllegalArgumentException if the length is out of range for the buffer.\n@return this for a fluent API.", "predict": " Validates the buffer vector.\n\n@return this, to enable chaining\n@throws IllegalArgumentException if the buffer vector is invalid."}, {"ID": 1888, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getMessageLength() { // Message type int messageLength = 1; // Number of aliases messageLength += 4; if (this.aliases != null) { for (AttributeAlias alias : this.aliases) { // Alias number, name length messageLength += 8; try { messageLength += alias.attributeName.getBytes(\"UTF-16BE\").length; } catch (UnsupportedEncodingException e) { log.error(\"Unable to encode strings into UTF-16.\"); e.printStackTrace(); } } } return messageLength; }\n\n    ### Response: Returns the length of this message as encoded according to the\nClient-World Model protocol.\n@return the length of the encoded form of this message, in bytes..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int validateAndComputeLength(final DirectBufferVector[] vectors) { int messageLength = 0; for (final DirectBufferVector vector : vectors) { vector.validate(); messageLength += vector.length; if (messageLength < 0) { throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors)); } } return messageLength; }\n\n    ### Response:", "ground_truth": "Validate an array of vectors to make up a message and compute the total length.\n\n@param vectors to be validated summed.\n@return the sum of the vector lengths.", "predict": " Validates and computes the length of the given vectors.\n@param vectors the vectors to validate and compute the length of\n@return the length of the vectors, in bytes\n@throws IllegalStateException if the length overflows an int\n@throws NullPointerException if the vectors array is null or contains a null element"}, {"ID": 1889, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void animateTo(int x, int y) { // If no layout, delay this call if (!mMapView.isLayoutOccurred()) { mReplayController.animateTo(x, y); return; } if (!mMapView.isAnimating()) { mMapView.mIsFlinging = false; final int xStart = (int)mMapView.getMapScrollX(); final int yStart = (int)mMapView.getMapScrollY(); final int dx = x - mMapView.getWidth() / 2; final int dy = y - mMapView.getHeight() / 2; if (dx != xStart || dy != yStart) { mMapView.getScroller().startScroll(xStart, yStart, dx, dy, Configuration.getInstance().getAnimationSpeedDefault()); mMapView.postInvalidate(); } } }\n\n    ### Response: Start animating the map towards the given point..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) { int termWindowLength = termBufferLength / 2; if (0 != defaultTermWindowLength) { termWindowLength = Math.min(defaultTermWindowLength, termWindowLength); } return termWindowLength; }\n\n    ### Response:", "ground_truth": "How far ahead a producer can get from a consumer position.\n\n@param termBufferLength        for when default is not set and considering an appropriate minimum.\n@param defaultTermWindowLength to take priority.\n@return the length to be used for the producer window.", "predict": " Calculates the length of the producer window based on the term buffer length and the default term window length. The producer window is the window of data that is being produced by the producer. The length of the producer window is half of the term buffer length, unless the default term window length is specified, in which case the minimum of the two is used."}, {"ID": 1890, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void loop() throws IOException { final long start = System.currentTimeMillis(); final byte[] buf = new byte[maxRcvBuf]; try { if (timeout > 0) s.setSoTimeout(timeout); while (!quit) { if (total > 0) { final long now = System.currentTimeMillis(); int to = (int) (start + total - now); if (to <= 0) break; // query socket timeout directly from socket since subtypes might // have modified the timeout during looping final int sto = s.getSoTimeout(); if (sto > 0) to = Math.min(to, sto); s.setSoTimeout(to); } try { final DatagramPacket p = new DatagramPacket(buf, buf.length); s.receive(p); final byte[] data = p.getData(); onReceive((InetSocketAddress) p.getSocketAddress(), data, p.getOffset(), p.getLength()); } catch (final SocketTimeoutException e) { if (total == 0 || start + total > System.currentTimeMillis()) onTimeout(); } catch (final IOException e) { if (!reboundSocket) throw e; reboundSocket = false; } } } catch (final InterruptedIOException e) { Thread.currentThread().interrupt(); } catch (final IOException e) { if (!quit) throw e; } finally { quit(); } }\n\n    ### Response: Runs the looper.\n\n@throws IOException on socket I/O error.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateSocketBufferLengths(final MediaDriver.Context ctx) { try (DatagramChannel probe = DatagramChannel.open()) { final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE); final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); if (maxSoSndBuf < ctx.socketSndbufLength()) { System.err.format( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.socketSndbufLength(), maxSoSndBuf); } probe.setOption(StandardSocketOptions.SO_RCVBUF, Integer.MAX_VALUE); final int maxSoRcvBuf = probe.getOption(StandardSocketOptions.SO_RCVBUF); if (maxSoRcvBuf < ctx.socketRcvbufLength()) { System.err.format( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_RCVBUF_LENGTH_PROP_NAME, ctx.socketRcvbufLength(), maxSoRcvBuf); } final int soSndBuf = 0 == ctx.socketSndbufLength() ? defaultSoSndBuf : ctx.socketSndbufLength(); if (ctx.mtuLength() > soSndBuf) { throw new ConfigurationException(String.format( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.mtuLength(), soSndBuf)); } if (ctx.initialWindowLength() > maxSoRcvBuf) { throw new ConfigurationException(\"window length greater than socket SO_RCVBUF, increase '\" + Configuration.INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx.initialWindowLength() + \", SO_RCVBUF=\" + maxSoRcvBuf); } } catch (final IOException ex) { throw new AeronException(\"probe socket: \" + ex.toString(), ex); } }\n\n    ### Response:", "ground_truth": "Validate that the socket buffer lengths are sufficient for the media driver configuration.\n\n@param ctx to be validated.", "predict": "Validates the socket buffer lengths for the media driver.\n\n@throws ConfigurationException if the socket buffer lengths are not valid.\n@throws AeronException if an error occurs probing the socket."}, {"ID": 1891, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function checkLength(size, schema, key) { //Check if it is an int if (Number.isInteger(schema[SCHEMALENGTH])) { if (size != schema[SCHEMALENGTH]) { throw new ValidationException(\"Size of \" + key + \" is not correct.\"); } } else if (typeof schema[SCHEMALENGTH] == \"string\") { if ( size < getMin(schema[SCHEMALENGTH], key) || size > getMax(schema[SCHEMALENGTH], key) ) { throw new ValidationException(\"Size of \" + key + \" is not correct.\"); } } else { throw new ValidationException(SCHEMALENGTH + \" cast exception: \" + key); } }\n\n    ### Response: Check that an array fit its lenght\n@param  {[type]} size   [description]\n@param  {[type]} schema [description]\n@param  {[type]} key    [description]\n@return {[type]}        [description].\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validatePageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new ConfigurationException( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new ConfigurationException( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new ConfigurationException(\"page size not a power of 2: \" + pageSize); } }\n\n    ### Response:", "ground_truth": "Validate that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws ConfigurationException if the size is not as expected.", "predict": " Validate the page size\n@param  {[type]} pageSize [description]\n@return {[type]}          [description]."}, {"ID": 1892, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int findOptimalNodeOrder(final Node<K, V> node) { int low = MIN_B_ORDER; // minimal b-order int high = (blockSize / node.getStructEstimateSize(1)) << 2; // estimate high b-order while (low <= high) { int mid = ((low + high) >>> 1); mid += (1 - (mid % 2)); int nodeSize = node.getStructEstimateSize(mid); if (log.isDebugEnabled()) { log.debug(this.getClass().getName() + \"::findOptimalNodeOrder(\" + node.getClass().getName() + \") blockSize=\" + blockSize + \" nodeSize=\" + nodeSize + \" b_low=\" + low + \" b_order=\" + mid + \" b_high=\" + high); } if (nodeSize < blockSize) { low = mid + 2; } else if (nodeSize > blockSize) { high = mid - 2; } else { return mid; } } return low - 2; }\n\n    ### Response: Find b-order for a blockSize of this tree\n\n@param node of type Leaf or Integernal\n@return integer with b-order.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateSessionIdRange(final int low, final int high) { if (low > high) { throw new ConfigurationException(\"low session id value \" + low + \" must be <= high value \" + high); } if (Math.abs((long)high - low) > Integer.MAX_VALUE) { throw new ConfigurationException(\"reserved range to too large\"); } }\n\n    ### Response:", "ground_truth": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.\n\n@param low  value in the range.\n@param high value in the range.\n@throws ConfigurationException if the values are not valid.", "predict": " Validate the range of session ids\n\n@param low integer with the lowest session id value\n@param high integer with the highest session id value\n@throws ConfigurationException if the range is invalid\n\n    "}, {"ID": 1893, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void lessThan(long value, long maxValue, String name) { if (value <= 0) { throw new IllegalArgumentException(name + \" should be > 0, current value \" + value); } if (value > maxValue) { throw new IllegalArgumentException(name + \" should be <= \" + maxValue + \", current value \" + value); } }\n\n    ### Response: Checks that the given value is <= max value.\n@param value\n@param maxValue\n@param name.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateUnblockTimeout( final long publicationUnblockTimeoutNs, final long clientLivenessTimeoutNs, final long timerIntervalNs) { if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) { throw new ConfigurationException( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs); } if (clientLivenessTimeoutNs <= timerIntervalNs) { throw new ConfigurationException( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs); } }\n\n    ### Response:", "ground_truth": "Validate that the timeouts for unblocking publications from a client are valid.\n\n@param publicationUnblockTimeoutNs after which an uncommitted publication will be unblocked.\n@param clientLivenessTimeoutNs     after which a client will be considered not alive.\n@param timerIntervalNs             interval at which the driver will check timeouts.\n@throws ConfigurationException if the values are not valid.", "predict": " Validates the unblock timeout configuration.\n@param publicationUnblockTimeoutNs the publication unblock timeout in nanoseconds.\n@param clientLivenessTimeoutNs the client liveness timeout in nanoseconds.\n@param timerIntervalNs the timer interval in nanoseconds."}, {"ID": 1894, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MessageBuilder appendCode(String language, String code) { delegate.appendCode(language, code); return this; }\n\n    ### Response: Appends code to the message.\n\n@param language The language, e.g. \"java\".\n@param code The code.\n@return The current instance in order to chain call methods..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ErrorResponseFlyweight errorCode(final ErrorCode code) { buffer.putInt(offset + ERROR_CODE_OFFSET, code.value()); return this; }\n\n    ### Response:", "ground_truth": "Set the error code for the command.\n\n@param code for the error\n@return flyweight", "predict": " Sets the error code.\n\n@param code The error code.\n@return The current instance in order to chain call methods."}, {"ID": 1895, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { document = null; systemId = null; xsiNamespaces.clear(); schemas.clear(); bDtdUsed = false; bXsdUsed = false; bWellformed = false; bValid = false; }\n\n    ### Response: Reset fields..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { isBallotSent = false; isLeader = false; hasRequestedJoin = false; hasSentTerminationAck = false; vote = null; candidateTermId = Aeron.NULL_VALUE; leadershipTermId = Aeron.NULL_VALUE; logPosition = NULL_POSITION; }\n\n    ### Response:", "ground_truth": "Reset the state of a cluster member so it can be canvassed and reestablished.", "predict": " Reset fields.."}, {"ID": 1896, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String implode(String[] tabToConcatenate, String pathSeparator) { final StringBuilder builder = new StringBuilder(); for (int i = 0; i < tabToConcatenate.length; i++) { builder.append(tabToConcatenate[i]); if (i < tabToConcatenate.length - 1) { builder.append(pathSeparator); } } return builder.toString(); }\n\n    ### Response: Concatenates a tab in a string with a path separator given..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeAsString(final ClusterMember[] clusterMembers) { final StringBuilder builder = new StringBuilder(); for (int i = 0, length = clusterMembers.length; i < length; i++) { final ClusterMember member = clusterMembers[i]; builder .append(member.id()) .append(',') .append(member.endpointsDetail()); if ((length - 1) != i) { builder.append('|'); } } return builder.toString(); }\n\n    ### Response:", "ground_truth": "Encode member details from a cluster members array to a string.\n\n@param clusterMembers to fill the details from\n@return String representation suitable for use with {@link ClusterMember#parse}", "predict": " Encodes an array of ClusterMember objects into a string. Each ClusterMember object is represented by its id and endpointsDetail separated by a comma. The array is separated by a pipe symbol."}, {"ID": 1897, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean generatePythonConstructors(String container, List<? extends XtendMember> members, PyAppendable it, IExtraLanguageGeneratorContext context) { // Prepare field initialization boolean hasConstructor = false; for (final XtendMember member : members) { if (context.getCancelIndicator().isCanceled()) { return false; } if (member instanceof SarlConstructor) { hasConstructor = true; generate(member, it, context); it.newLine(); } } if (context.getCancelIndicator().isCanceled()) { return false; } if (!hasConstructor) { it.append(\"def __init__(self):\"); //$NON-NLS-1$ it.increaseIndentation().newLine(); final List<SarlField> fields = context.getMultimapValues(INSTANCE_VARIABLES_MEMENTO, container); if (fields.isEmpty()) { it.append(\"pass\"); //$NON-NLS-1$ } else { for (final SarlField field : fields) { generatePythonField(field, it, context); } } it.decreaseIndentation().newLine(); } return true; }\n\n    ### Response: Generate the constructors for a Python class.\n\n@param container the fully qualified name of the container.\n@param members the members to be added.\n@param it the output.\n@param context the generation context.\n@return {@code true} if a constructor was generated. {@code false} if no constructor was generated..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addMemberStatusPublications( final ClusterMember[] members, final ClusterMember exclude, final ChannelUri channelUri, final int streamId, final Aeron aeron) { for (final ClusterMember member : members) { if (member != exclude) { channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint()); member.publication = aeron.addExclusivePublication(channelUri.toString(), streamId); } } }\n\n    ### Response:", "ground_truth": "Add the publications for sending status messages to the other members of the cluster.\n\n@param members    of the cluster.\n@param exclude    this member when adding publications.\n@param channelUri for the publication.\n@param streamId   for the publication.\n@param aeron      to add the publications to.", "predict": " Add publications to the cluster members.\n\n@param members the cluster members.\n@param exclude the member to exclude from the publication.\n@param channelUri the channel URI to use for the publication.\n@param streamId the stream ID to use for the publication.\n@param aeron the Aeron instance to use for the publication."}, {"ID": 1898, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasAbstractMember(XtendTypeDeclaration declaration) { if (declaration != null) { for (final XtendMember member : declaration.getMembers()) { if (member instanceof XtendFunction) { if (((XtendFunction) member).isAbstract()) { return true; } } } } return false; }\n\n    ### Response: Replies if the given declaration has an abstract member.\n\n@param declaration - the declaration.\n@return true if the given type has an abstract function..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeMemberPublications(final ClusterMember[] clusterMembers) { for (final ClusterMember member : clusterMembers) { CloseHelper.close(member.publication); } }\n\n    ### Response:", "ground_truth": "Close the publications associated with members of the cluster.\n\n@param clusterMembers to close the publications for.", "predict": " Replies if the given cluster members have their publications closed.\n\n@param clusterMembers - the cluster members."}, {"ID": 1899, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validateTableRow(final Node row, final int numColumns) { assert row != null; assert row.getNodeName().equals(\"row\") || row.getNodeName().equals(\"tr\"); if (row.getNodeName().equals(\"row\")) { final List<Node> entries = XMLUtilities.getDirectChildNodes(row, \"entry\"); final List<Node> entryTbls = XMLUtilities.getDirectChildNodes(row, \"entrytbl\"); if ((entries.size() + entryTbls.size()) <= numColumns) { for (final Node entryTbl : entryTbls) { if (!validateEntryTbl((Element) entryTbl)) return false; } return true; } else { return false; } } else { final List<Node> nodes = XMLUtilities.getDirectChildNodes(row, \"td\", \"th\"); return nodes.size() <= numColumns; } }\n\n    ### Response: Check to ensure that a docbook row has the required number of columns for a table.\n\n@param row        The DOM row element to be checked.\n@param numColumns The number of entry elements that should exist in the row.\n@return True if the row has the required number of entries, otherwise false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasActiveQuorum( final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs) { int threshold = quorumThreshold(clusterMembers.length); for (final ClusterMember member : clusterMembers) { if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs)) { if (--threshold <= 0) { return true; } } } return false; }\n\n    ### Response:", "ground_truth": "Check if the cluster leader has an active quorum of cluster followers.\n\n@param clusterMembers for the current cluster.\n@param nowMs          for the current time.\n@param timeoutMs      after which a follower is not considered active.\n@return true if quorum of cluster members are considered active.", "predict": " Check to see if the cluster has reached an active quorum.\n\n@param clusterMembers An array of cluster members to check for quorum.\n@param nowMs          The current time in milliseconds.\n@param timeoutMs      The maximum time in milliseconds that a member can be behind before it is considered inactive.\n@return True if the cluster has reached an active quorum, otherwise false."}, {"ID": 1900, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] splitString(final String str, final char splitChar) { final int length = str.length(); final StringBuilder bulder = new StringBuilder(Math.max(8, length)); int counter = 1; for (int i = 0; i < length; i++) { if (str.charAt(i) == splitChar) { counter++; } } final String[] result = new String[counter]; int position = 0; for (int i = 0; i < length; i++) { final char chr = str.charAt(i); if (chr == splitChar) { result[position++] = bulder.toString(); bulder.setLength(0); } else { bulder.append(chr); } } if (position < result.length) { result[position] = bulder.toString(); } return result; }\n\n    ### Response: Split a string for a char used as the delimeter.\n\n@param str       a string to be split\n@param splitChar a char to be used as delimeter\n@return array contains split string parts without delimeter chars.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) { final int length = rankedPositions.length; for (int i = 0; i < length; i++) { rankedPositions[i] = 0; } for (final ClusterMember member : members) { long newPosition = member.logPosition; for (int i = 0; i < length; i++) { final long rankedPosition = rankedPositions[i]; if (newPosition > rankedPosition) { rankedPositions[i] = newPosition; newPosition = rankedPosition; } } } return rankedPositions[length - 1]; }\n\n    ### Response:", "ground_truth": "Calculate the position reached by a quorum of cluster members.\n\n@param members         of the cluster.\n@param rankedPositions temp array to be used for sorting the positions to avoid allocation.\n@return the position reached by a quorum of cluster members.", "predict": " Calculate the quorum position for a set of cluster members based on their log positions.\n\n@param members     an array of cluster members\n@param rankedPositions an array of long values representing the ranked positions of the cluster members\n@return the quorum position for the set of cluster members\n\n    "}, {"ID": 1901, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void unmap(final FileChannel fileChannel, final long address, final long length) { try { MappingMethods.UNMAP_ADDRESS.invoke(fileChannel, address, length); } catch (final IllegalAccessException | InvocationTargetException ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response: Unmap a region of a file.\n\n@param fileChannel which has been mapped.\n@param address     at which the mapping begins.\n@param length      of the mapped region..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) { for (final ClusterMember member : clusterMembers) { member.logPosition(logPosition); } }\n\n    ### Response:", "ground_truth": "Reset the log position of all the members to the provided value.\n\n@param clusterMembers to be reset.\n@param logPosition    to set for them all.", "predict": "Reset the log positions of all cluster members to the given log position.\n\n@param clusterMembers the cluster members to reset.\n@param logPosition    the log position to which to reset the log positions."}, {"ID": 1902, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean allEquals(final String value, final String... strings) { if (strings != null) { for (final String s : strings) { if (s == null && value != null || s != null && !s.equals(value)) { return false; } } } else { return value == null; } return true; }\n\n    ### Response: Return true if all strings are the same..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean haveVotersReachedPosition( final ClusterMember[] clusterMembers, final long position, final long leadershipTermId) { for (final ClusterMember member : clusterMembers) { if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Has the members of the cluster the voted reached the provided position in their log.\n\n@param clusterMembers   to check.\n@param position         to compare the {@link #logPosition()} against.\n@param leadershipTermId expected of the members.\n@return true if all members have reached this position otherwise false.", "predict": " Return true if all cluster members have reached the specified position and leadership term id."}, {"ID": 1903, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func VotesInBlock(bl *dcrutil.Block) []chainhash.Hash { votes := make([]chainhash.Hash, 0) for _, stx := range bl.STransactions() { if stake.DetermineTxType(stx.MsgTx()) == stake.TxTypeSSGen { h := stx.Hash() votes = append(votes, *h) } } return votes }\n\n    ### Response: // VotesInBlock finds all the votes in the block..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) { int votes = 0; for (final ClusterMember member : members) { if (null == member.vote || member.candidateTermId != candidateTermId) { return false; } votes += member.vote ? 1 : 0; } return votes >= ClusterMember.quorumThreshold(members.length); }\n\n    ### Response:", "ground_truth": "Has the candidate got unanimous support of the cluster?\n\n@param members         to check for votes.\n@param candidateTermId for the vote.\n@return false if any member has not voted for the candidate.", "predict": " // hasWonVoteOnFullCount checks if the cluster has won a vote on a full count."}, {"ID": 1904, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func VotesInBlock(bl *dcrutil.Block) []chainhash.Hash { votes := make([]chainhash.Hash, 0) for _, stx := range bl.STransactions() { if stake.DetermineTxType(stx.MsgTx()) == stake.TxTypeSSGen { h := stx.Hash() votes = append(votes, *h) } } return votes }\n\n    ### Response: // VotesInBlock finds all the votes in the block..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) { int votes = 0; for (final ClusterMember member : clusterMembers) { if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) { ++votes; } } return votes >= ClusterMember.quorumThreshold(clusterMembers.length); }\n\n    ### Response:", "ground_truth": "Has sufficient votes being counted for a majority?\n\n@param clusterMembers  to check for votes.\n@param candidateTermId for the vote.\n@return true if a majority of positive votes.", "predict": " // hasMajorityVote checks if the candidate term has a majority vote in the cluster."}, {"ID": 1905, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private CmsSpellcheckingRequest parseHttpRequest(final ServletRequest req, final CmsObject cms) { if ((null != cms) && OpenCms.getRoleManager().hasRole(cms, CmsRole.ROOT_ADMIN)) { try { if (null != req.getParameter(HTTP_PARAMETER_CHECKREBUILD)) { if (CmsSpellcheckDictionaryIndexer.updatingIndexNecessesary(cms)) { parseAndAddDictionaries(cms); } } if (null != req.getParameter(HTTP_PARAMTER_REBUILD)) { parseAndAddDictionaries(cms); } } catch (CmsRoleViolationException e) { LOG.error(e.getLocalizedMessage(), e); } } final String q = req.getParameter(HTTP_PARAMETER_WORDS); if (null == q) { LOG.debug(\"Invalid HTTP request: No parameter \\\"\" + HTTP_PARAMETER_WORDS + \"\\\" defined. \"); return null; } final StringTokenizer st = new StringTokenizer(q); final List<String> wordsToCheck = new ArrayList<String>(); while (st.hasMoreTokens()) { final String word = st.nextToken(); wordsToCheck.add(word); if (Character.isUpperCase(word.codePointAt(0))) { wordsToCheck.add(word.toLowerCase()); } } final String[] w = wordsToCheck.toArray(new String[wordsToCheck.size()]); final String dict = req.getParameter(HTTP_PARAMETER_LANG) == null ? LANG_DEFAULT : req.getParameter(HTTP_PARAMETER_LANG); return new CmsSpellcheckingRequest(w, dict); }\n\n    ### Response: Parse parameters from this request using HTTP.\n\n@param req The ServletRequest containing all request parameters.\n@param cms The OpenCms object.\n@return CmsSpellcheckingRequest object that contains parsed parameters..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClusterMember determineMember( final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) { ClusterMember member = NULL_VALUE != memberId ? ClusterMember.findMember(clusterMembers, memberId) : null; if ((null == clusterMembers || 0 == clusterMembers.length) && null == member) { member = ClusterMember.parseEndpoints(NULL_VALUE, memberEndpoints); } else { if (null == member) { throw new ClusterException(\"memberId=\" + memberId + \" not found in clusterMembers\"); } if (!\"\".equals(memberEndpoints)) { ClusterMember.validateMemberEndpoints(member, memberEndpoints); } } return member; }\n\n    ### Response:", "ground_truth": "Determine which member of a cluster this is and check endpoints.\n\n@param clusterMembers  for the current cluster which can be null.\n@param memberId        for this member.\n@param memberEndpoints for this member.\n@return the {@link ClusterMember} determined.", "predict": " Determine the cluster member based on the given memberId or memberEndpoints.\n\n@param clusterMembers The array of cluster members.\n@param memberId The id of the cluster member to find.\n@param memberEndpoints The endpoints of the cluster member to find.\n@return The cluster member found based on the given memberId or memberEndpoints.\n\n    "}, {"ID": 1906, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkFileExists(final File file, final String name) { if (!file.exists()) { final String msg = \"missing file for \" + name + \" : \" + file.getAbsolutePath(); throw new IllegalStateException(msg); } }\n\n    ### Response: Check that a file exists and throw an exception if not.\n\n@param file to check existence of.\n@param name to associate for the exception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) { final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints); if (!areSameEndpoints(member, endpointMember)) { throw new ClusterException( \"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints); } }\n\n    ### Response:", "ground_truth": "Check the member with the memberEndpoints\n\n@param member          to check memberEndpoints against\n@param memberEndpoints to check member against\n@see ConsensusModule.Context#memberEndpoints()\n@see ConsensusModule.Context#clusterMembers()", "predict": " Validate the member endpoints and throw an exception if they are not the same.\n\n@param member to validate.\n@param memberEndpoints to compare with.\n\n    "}, {"ID": 1907, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean primitiveIsAssignableFrom (Class<?> lhs, Class<?> rhs) { if (lhs == null || rhs == null) { return false; } if (!(lhs.isPrimitive() && rhs.isPrimitive())) { return false; } if (lhs.equals(rhs)) { return true; } Set<Class<?>> wideningSet = _primitiveWideningsMap.get(rhs); if (wideningSet == null) { return false; } return wideningSet.contains(lhs); }\n\n    ### Response: Tells whether an instance of the primitive class represented by 'rhs' can be assigned to an\ninstance of the primitive class represented by 'lhs'.\n\n@param lhs assignee class.\n@param rhs assigned class.\n\n@return true if compatible, false otherwise. If either argument is null, or one\nof the parameters does not represent a primitive (e.g. Byte.TYPE), returns false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) { return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint()); }\n\n    ### Response:", "ground_truth": "Are two cluster members using the same endpoints?\n\n@param lhs to check\n@param rhs to check\n@return true if both are using the same endpoints or false if not.", "predict": " Checks if two ClusterMembers have the same endpoints.\n\n@param lhs first ClusterMember.\n@param rhs second ClusterMember.\n\n@return true if the ClusterMembers have the same endpoints, false otherwise."}, {"ID": 1908, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isDescendant(TypeDef item, TypeDef candidate) { if (item == null || candidate == null) { return false; } else if (candidate.isAssignableFrom(item)) { return true; } return false; }\n\n    ### Response: Checks if a type is an descendant of an other type\n\n@param item      The base type.\n@param candidate The candidate type.\n@return true if candidate is a descendant of base type..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Has the member achieved a unanimous view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " Checks if a candidate is unanimous in a cluster.\n\n@param clusterMembers The cluster members.\n@param candidate      The candidate to check.\n@return true if candidate is unanimous in the cluster."}, {"ID": 1909, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void backward(final CLClause c, final int ignore) { int minlit = 0; int minoccs = Integer.MAX_VALUE; int litoccs; this.stats.steps++; for (int i = 0; i < c.lits().size(); i++) { final int lit = c.lits().get(i); if (lit == ignore) { continue; } if (val(lit) < 0) { continue; } litoccs = occs(lit).count(); if (minlit != 0 && minoccs >= litoccs) { continue; } minlit = lit; minoccs = litoccs; } if (minoccs >= this.config.bwocclim) { return; } assert minlit != 0; for (int i = 0; i < c.lits().size(); i++) { mark(c.lits().get(i)); } final CLOccs os = occs(minlit); for (final CLClause d : os) { if (d == c) { continue; } int lit; int count = this.seen.size(); int negated = 0; this.stats.steps++; for (int p = 0; count != 0 && p < d.lits().size(); p++) { lit = d.lits().get(p); final int m = marked(lit); if (m == 0) { continue; } assert count > 0; count--; if (m > 0) { continue; } assert m < 0; if (negated != 0) { count = Integer.MAX_VALUE; break; } negated = lit; } if (count != 0) { continue; } if (negated != 0) { this.tostrengthen.push(new Pair<>(d, negated)); this.stats.backwardStrengthened++; } else { this.stats.backwardSubsumed++; dumpClause(d); } } unmark(); }\n\n    ### Response: Backward subsumes from clause.\n@param c      the clause\n@param ignore the literal to ignore.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { int possibleVotes = 0; for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { continue; } ++possibleVotes; } return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length); }\n\n    ### Response:", "ground_truth": "Has the member achieved a quorum view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " Checks if a candidate is a quorum candidate.\n@param clusterMembers the array of cluster members\n@param candidate      the candidate to check\n\n    "}, {"ID": 1910, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean generatePythonConstructors(String container, List<? extends XtendMember> members, PyAppendable it, IExtraLanguageGeneratorContext context) { // Prepare field initialization boolean hasConstructor = false; for (final XtendMember member : members) { if (context.getCancelIndicator().isCanceled()) { return false; } if (member instanceof SarlConstructor) { hasConstructor = true; generate(member, it, context); it.newLine(); } } if (context.getCancelIndicator().isCanceled()) { return false; } if (!hasConstructor) { it.append(\"def __init__(self):\"); //$NON-NLS-1$ it.increaseIndentation().newLine(); final List<SarlField> fields = context.getMultimapValues(INSTANCE_VARIABLES_MEMENTO, container); if (fields.isEmpty()) { it.append(\"pass\"); //$NON-NLS-1$ } else { for (final SarlField field : fields) { generatePythonField(field, it, context); } } it.decreaseIndentation().newLine(); } return true; }\n\n    ### Response: Generate the constructors for a Python class.\n\n@param container the fully qualified name of the container.\n@param members the members to be added.\n@param it the output.\n@param context the generation context.\n@return {@code true} if a constructor was generated. {@code false} if no constructor was generated..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isNotDuplicateEndpoints(final ClusterMember[] members, final String memberEndpoints) { for (final ClusterMember member : members) { if (member.endpointsDetail().equals(memberEndpoints)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Is the string of member endpoints not duplicated in the members.\n\n@param members         to check if the provided endpoints have a duplicate.\n@param memberEndpoints to check for duplicates.\n@return true if no duplicate is found otherwise false.", "predict": " Check if a list of cluster members has duplicate endpoints.\n\n@param members the list of cluster members.\n@param memberEndpoints the endpoints to check.\n@return {@code true} if the list has no duplicate endpoints. {@code false} otherwise."}, {"ID": 1911, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int indexOfSerial(final double[] incr, final double v) { int index = -1; for (int i = 0; i < incr.length && index == -1; ++i) { if (incr[i] >= v) { index = i; } } return index; }\n\n    ### Response: Perform a serial-search on the summed probability array..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) { final int length = clusterMembers.length; int index = ArrayUtil.UNKNOWN_INDEX; for (int i = 0; i < length; i++) { if (clusterMembers[i].id() == memberId) { index = i; } } return index; }\n\n    ### Response:", "ground_truth": "Find the index at which a member id is present.\n\n@param clusterMembers to be searched.\n@param memberId       to search for.\n@return the index at which the member id is found otherwise {@link ArrayUtil#UNKNOWN_INDEX}.", "predict": " Find the index of the cluster member with the given ID in the given cluster member array. If the member is not found, return the value of UNKNOWN_INDEX (-1)."}, {"ID": 1912, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] getMemberData(String memberId) throws ZooKeeperConnectionException, KeeperException, InterruptedException { return zkClient.get().getData(getMemberPath(memberId), false, null); }\n\n    ### Response: Gets the data for one of this groups members by querying ZooKeeper synchronously.\n\n@param memberId the id of the member whose data to retrieve\n@return the data associated with the {@code memberId}\n@throws ZooKeeperConnectionException if there was a problem connecting to ZooKeeper\n@throws KeeperException if there was a problem reading this member's data\n@throws InterruptedException if this thread is interrupted retrieving the member data.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClusterMember[] removeMember(final ClusterMember[] oldMembers, final int memberId) { return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId)); }\n\n    ### Response:", "ground_truth": "Remove a member from an array if found, otherwise return the array unmodified.\n\n@param oldMembers to remove a member from.\n@param memberId   of the member to remove.\n@return a new array with the member removed or the existing array if not found.", "predict": " Removes a member from the given array of cluster members based on the member's ID.\n\n@param oldMembers the array of cluster members to remove a member from\n@param memberId the ID of the member to remove\n@return a new array with the member removed\n@throws IllegalArgumentException if the member ID is not found in the array\n\n    "}, {"ID": 1913, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int computeFieldSize(final FieldDescriptorLite<?> descriptor, final Object value) { WireFormat.FieldType type = descriptor.getLiteType(); int number = descriptor.getNumber(); if (descriptor.isRepeated()) { if (descriptor.isPacked()) { int dataSize = 0; for (final Object element : (List<?>)value) { dataSize += computeElementSizeNoTag(type, element); } return dataSize + CodedOutputStream.computeTagSize(number) + CodedOutputStream.computeRawVarint32Size(dataSize); } else { int size = 0; for (final Object element : (List<?>)value) { size += computeElementSize(type, number, element); } return size; } } else { return computeElementSize(type, number, value); } }\n\n    ### Response: Compute the number of bytes needed to encode a particular field..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; }\n\n    ### Response:", "ground_truth": "Find the highest member id in an array of members.\n\n@param clusterMembers to search for the highest id.\n@return the highest id otherwise {@link Aeron#NULL_VALUE} if empty.", "predict": " Find the highest member id in a cluster.\n\n    "}, {"ID": 1914, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Props loadPluginProps(final File pluginDir) { if (!pluginDir.exists()) { logger.error(\"Error! Plugin path \" + pluginDir.getPath() + \" doesn't exist.\"); return null; } if (!pluginDir.isDirectory()) { logger.error(\"The plugin path \" + pluginDir + \" is not a directory.\"); return null; } final File propertiesDir = new File(pluginDir, \"conf\"); if (propertiesDir.exists() && propertiesDir.isDirectory()) { final File propertiesFile = new File(propertiesDir, \"plugin.properties\"); final File propertiesOverrideFile = new File(propertiesDir, \"override.properties\"); if (propertiesFile.exists()) { if (propertiesOverrideFile.exists()) { return loadProps(null, propertiesFile, propertiesOverrideFile); } else { return loadProps(null, propertiesFile); } } else { logger.error(\"Plugin conf file \" + propertiesFile + \" not found.\"); return null; } } else { logger.error(\"Plugin conf path \" + propertiesDir + \" not found.\"); return null; } }\n\n    ### Response: Load plugin properties\n\n@param pluginDir plugin's Base Directory\n@return The properties.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MappedByteBuffer mapExistingCncFile(final Consumer<String> logger) { final File cncFile = new File(aeronDirectory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { if (null != logger) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); } return IoUtil.mapExistingFile(cncFile, CncFileDescriptor.CNC_FILE); } return null; }\n\n    ### Response:", "ground_truth": "Map the CnC file if it exists.\n\n@param logger for feedback\n@return a new mapping for the file if it exists otherwise null;", "predict": " Map existing CnC file\n\n@param logger the logger to use for logging\n@return the mapped byte buffer of the CnC file or null if it doesn't exist or is empty."}, {"ID": 1915, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean containsFileRecursive(final File parent, final File search) { final File toSearch = search.getAbsoluteFile(); boolean exists = false; final File[] children = parent.getAbsoluteFile().listFiles(); if (children == null) { return false; } final List<File> fileList = Arrays.asList(children); for (final File currentFile : fileList) { if (currentFile.isDirectory()) { exists = FileSearchExtensions.containsFileRecursive(currentFile, toSearch); if (exists) { return true; } } if (fileList.contains(toSearch)) { return true; } } return exists; }\n\n    ### Response: Checks if the given file contains only in the parent file recursively.\n\n@param parent\nThe parent directory to search.\n@param search\nThe file to search.\n@return 's true if the file exists in the parent directory otherwise false..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isDriverActive( final File directory, final long driverTimeoutMs, final Consumer<String> logger) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } return false; }\n\n    ### Response:", "ground_truth": "Is a media driver active in the given directory?\n\n@param directory       to check\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " Checks if the given directory contains a valid Aeron CnC file and if the driver is active.\n\n@param directory\nThe directory to search for the CnC file.\n@param driverTimeoutMs\nThe timeout in milliseconds to wait for the driver to become active.\n@param logger\nThe logger to use for logging messages.\n@return 's true if the driver is active otherwise false."}, {"ID": 1916, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final boolean push(final N n) { int spin = 0; for(;;) { final long writeLock = seqLock.tryWriteLock(); if(writeLock>0L) { try { final int stackTop = this.stackTop.get(); if(size>stackTop) { try { stack.set(stackTop, n); stackNotEmptyCondition.signal(); return true; } finally { this.stackTop.set(stackTop+1); } } else { return false; } } finally { seqLock.unlock(writeLock); } } spin = Condition.progressiveYield(spin); } }\n\n    ### Response: add an element to the stack, failing if the stack is unable to grow\n\n@param n - the element to push\n\n@return boolean - false if stack overflow, true otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger) { final MappedByteBuffer cncByteBuffer = mapExistingCncFile(logger); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } }\n\n    ### Response:", "ground_truth": "Is a media driver active in the current Aeron directory?\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " checks if the driver is active by reading the CNC file and checking the driver status.\n\n@param driverTimeoutMs - the timeout in milliseconds to wait for the driver to become active\n\n@param logger - the logger to use for logging messages\n\n@param cncByteBuffer - the mapped byte buffer containing the CNC file\n\n@return boolean - true if the driver is active, false otherwise."}, {"ID": 1917, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isTileToBeDownloaded(final ITileSource pTileSource, final long pMapTileIndex) { final Long expiration = mTileWriter.getExpirationTimestamp(pTileSource, pMapTileIndex); if (expiration == null) { return true; } final long now = System.currentTimeMillis(); return now > expiration; }\n\n    ### Response: \"Should we download this tile?\", either because it's not cached yet or because it's expired\n\n@since 5.6.5.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isDriverActive( final long driverTimeoutMs, final Consumer<String> logger, final ByteBuffer cncByteBuffer) { if (null == cncByteBuffer) { return false; } final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final long startTimeMs = System.currentTimeMillis(); int cncVersion; while (0 == (cncVersion = cncMetaDataBuffer.getIntVolatile(CncFileDescriptor.cncVersionOffset(0)))) { if (System.currentTimeMillis() > (startTimeMs + driverTimeoutMs)) { throw new DriverTimeoutException(\"CnC file is created but not initialised.\"); } sleep(1); } if (CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long timestamp = toDriverBuffer.consumerHeartbeatTime(); final long now = System.currentTimeMillis(); final long timestampAge = now - timestamp; logger.accept(\"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge); return timestampAge <= driverTimeoutMs; }\n\n    ### Response:", "ground_truth": "Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait for\nup to the driverTimeoutMs by checking for the cncVersion being set.\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@param cncByteBuffer   for the existing CnC file.\n@return true if a driver is active or false if not.", "predict": " \"Checks if the driver is active and ready to accept commands. If the driver is not active, it will throw a DriverTimeoutException. If the driver is active, it will check if the CnC version matches the required version. If the versions do not match, it will throw an AeronException. It will then check if the Aeron toDriver consumer heartbeat is within the specified timeout. If the heartbeat is not within the timeout, it will log an error message and return false. Otherwise, it will return true.\""}, {"ID": 1918, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isDotnetPath() { final String[] args = new String[2]; args[0] = \"dotnet\"; args[1] = \"--version\"; final ProcessBuilder pb = new ProcessBuilder(args); try { final Process proc = pb.start(); final int retCode = proc.waitFor(); if (retCode == 0) { return true; } final byte[] version = new byte[50]; final int read = proc.getInputStream().read(version); if (read > 0) { final String v = new String(version, UTF_8); if (v.length() > 0) { return true; } } } catch (IOException | InterruptedException ex) { LOGGER.debug(\"Path search failed for dotnet\", ex); } return false; }\n\n    ### Response: Tests to see if a file is in the system path.\n\n@return true if dotnet could be found in the path; otherwise\nfalse.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean requestDriverTermination( final File directory, final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final int cncVersion = cncMetaDataBuffer.getIntVolatile(cncVersionOffset(0)); if (CncFileDescriptor.CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long clientId = toDriverBuffer.nextCorrelationId(); final DriverProxy driverProxy = new DriverProxy(toDriverBuffer, clientId); return driverProxy.terminateDriver(tokenBuffer, tokenOffset, tokenLength); } finally { IoUtil.unmap(cncByteBuffer); } } return false; }\n\n    ### Response:", "ground_truth": "Request a driver to run its termination hook.\n\n@param directory for the driver.\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return true if request was sent or false if request could not be sent.", "predict": " Requests the termination of a driver by sending a message to the driver.\n\n@param directory      to the directory containing the CnC file.\n@param tokenBuffer    containing the token to be sent to the driver.\n@param tokenOffset    at which the token begins.\n@param tokenLength    of the token in bytes.\n@return true if the driver was terminated; otherwise false.\n\n    "}, {"ID": 1919, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static ByteBuf writePayload( final ByteBufAllocator alloc, final long requestId, final MessageType messageType, final byte[] payload) { final int frameLength = HEADER_LENGTH + REQUEST_ID_SIZE + payload.length; final ByteBuf buf = alloc.ioBuffer(frameLength + Integer.BYTES); buf.writeInt(frameLength); writeHeader(buf, messageType); buf.writeLong(requestId); buf.writeBytes(payload); return buf; }\n\n    ### Response: Helper for serializing the messages.\n\n@param alloc\t\t\tThe {@link ByteBufAllocator} used to allocate the buffer to serialize the message into.\n@param requestId\t\tThe id of the request to which the message refers to.\n@param messageType\tThe {@link MessageType type of the message}.\n@param payload\t\tThe serialized version of the message.\n@return A {@link ByteBuf} containing the serialized message..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) { int frameLength = buffer.getIntVolatile(termOffset); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } return frameLength; }\n\n    ### Response:", "ground_truth": "Get the length of a frame from the header as a volatile read.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@return the value for the frame length.", "predict": " Helper method to get the frame length from the term buffer.\n\n@param buffer\t\tThe term buffer from which to read the frame length.\n@param termOffset\tThe offset in the term buffer from which to read the frame length.\n@return The frame length as an integer."}, {"ID": 1920, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addAll(@NonNull final Collection<T> collection) { final int length = collection.size(); if (length == 0) { return; } synchronized (mLock) { final int position = getItemCount(); mObjects.addAll(collection); notifyItemRangeInserted(position, length); } }\n\n    ### Response: Adds the specified list of objects at the end of the array.\n\n@param collection The objects to add at the end of the array..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength) { int length = frameLength; if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { length = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(termOffset, length); }\n\n    ### Response:", "ground_truth": "Write the length header for a frame in a memory ordered fashion.\n\n@param buffer      containing the frame.\n@param termOffset  at which a frame begins.\n@param frameLength field to be set for the frame.", "predict": " Writes the frame length to the specified term offset in the buffer in the order specified by the system byte order.\n\n@param buffer The buffer to write the frame length to.\n@param termOffset The offset in the buffer to write the frame length to.\n@param frameLength The frame length to write to the buffer."}, {"ID": 1921, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final void getByteArray(byte[] data, int offset, int size, byte[] buffer, int bufferOffset) { System.arraycopy(data, offset, buffer, bufferOffset, size); }\n\n    ### Response: This method extracts a portion of a byte array and writes it into\nanother byte array.\n\n@param data Source data\n@param offset Offset into source data\n@param size Required size to be extracted from the source data\n@param buffer Destination buffer\n@param bufferOffset Offset into destination buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) { buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the type field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param type       type value for the frame.", "predict": " This method sets the frame type in a term buffer.\n\n@param buffer The term buffer to modify\n@param termOffset The offset in the term buffer where the frame header starts\n@param type The frame type to set."}, {"ID": 1922, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void verify(final int height, final EnumSet<VerifyFlag> flags) throws VerificationException { verifyHeader(); verifyTransactions(height, flags); }\n\n    ### Response: Verifies both the header and that the transactions hash to the merkle root.\n\n@param height block height, if known, or -1 otherwise.\n@param flags flags to indicate which tests should be applied (i.e.\nwhether to test for height in the coinbase transaction).\n@throws VerificationException if there was an error verifying the block..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) { buffer.putByte(flagsOffset(termOffset), flags); }\n\n    ### Response:", "ground_truth": "Write the flags field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param flags      value for the frame.", "predict": "Sets the flags for the specified term in the specified buffer.\n\n@param buffer the buffer containing the term.\n@param termOffset the offset of the term within the buffer.\n@param flags the flags to set."}, {"ID": 1923, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final void getByteArray(byte[] data, int offset, int size, byte[] buffer, int bufferOffset) { System.arraycopy(data, offset, buffer, bufferOffset, size); }\n\n    ### Response: This method extracts a portion of a byte array and writes it into\nanother byte array.\n\n@param data Source data\n@param offset Offset into source data\n@param size Required size to be extracted from the source data\n@param buffer Destination buffer\n@param bufferOffset Offset into destination buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) { buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the term offset field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.", "predict": " This method sets the term offset field in the frame header of a log buffer.\n\n@param buffer The log buffer to update\n@param termOffset The new term offset value to be set.\n\n    "}, {"ID": 1924, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final void getByteArray(byte[] data, int offset, int size, byte[] buffer, int bufferOffset) { System.arraycopy(data, offset, buffer, bufferOffset, size); }\n\n    ### Response: This method extracts a portion of a byte array and writes it into\nanother byte array.\n\n@param data Source data\n@param offset Offset into source data\n@param size Required size to be extracted from the source data\n@param buffer Destination buffer\n@param bufferOffset Offset into destination buffer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the term id field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param termId     value for the frame.", "predict": " This method writes a term ID into a term buffer at a given offset.\n\n@param buffer The term buffer to write to\n@param termOffset The offset in the term buffer to write to\n@param termId The term ID to write\n\n    "}, {"ID": 1925, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int indexOf(final Object o) { final int size = dataModel.getSize(); for (int i = 0; i < size; i++) { if (comparator == null) { if (o.equals(dataModel.getElementAt(i))) { return i; } } else if (comparator.compare(o, dataModel.getElementAt(i)) == 0) { return i; } } return -1; }\n\n    ### Response: Get the index of a given object in the underlying data model.\n\n@param o Object to locate\n@return index of object in model, -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for a stream based on the recording id.\n\n@param countersReader to search within.\n@param recordingId    for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find the counter id for a given recording id in the counters meta data.\n\n@param countersReader Counters reader to use\n@param recordingId Recording id to search for\n@return counter id for recording, NULL_COUNTER_ID if not found."}, {"ID": 1926, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int indexOf(final Object o) { final int size = dataModel.getSize(); for (int i = 0; i < size; i++) { if (comparator == null) { if (o.equals(dataModel.getElementAt(i))) { return i; } } else if (comparator.compare(o, dataModel.getElementAt(i)) == 0) { return i; } } return -1; }\n\n    ### Response: Get the index of a given object in the underlying data model.\n\n@param o Object to locate\n@return index of object in model, -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for a stream based on the session id.\n\n@param countersReader to search within.\n@param sessionId      for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find the counter id for a given session id in the counters reader.\n\n@param countersReader counters reader to search for counter id\n@param sessionId session id to search for\n@return counter id for given session id, NULL_COUNTER_ID if not found."}, {"ID": 1927, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:ReturnCount\") public static int compareBuff(final DirectBuffer o1, final DirectBuffer o2) { requireNonNull(o1); requireNonNull(o2); if (o1.equals(o2)) { return 0; } final int minLength = Math.min(o1.capacity(), o2.capacity()); final int minWords = minLength / Long.BYTES; for (int i = 0; i < minWords * Long.BYTES; i += Long.BYTES) { final long lw = o1.getLong(i, BIG_ENDIAN); final long rw = o2.getLong(i, BIG_ENDIAN); final int diff = Long.compareUnsigned(lw, rw); if (diff != 0) { return diff; } } for (int i = minWords * Long.BYTES; i < minLength; i++) { final int lw = Byte.toUnsignedInt(o1.getByte(i)); final int rw = Byte.toUnsignedInt(o2.getByte(i)); final int result = Integer.compareUnsigned(lw, rw); if (result != 0) { return result; } } return o1.capacity() - o2.capacity(); }\n\n    ### Response: Lexicographically compare two buffers.\n\n@param o1 left operand (required)\n@param o2 right operand (required)\n@return as specified by {@link Comparable} interface.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getRecordingId(final CountersReader countersReader, final int counterId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) { return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET); } } return NULL_RECORDING_ID; }\n\n    ### Response:", "ground_truth": "Get the recording id for a given counter id.\n\n@param countersReader to search within.\n@param counterId      for the active recording.\n@return the counter id if found otherwise {@link #NULL_RECORDING_ID}.", "predict": " Get the recording id for a given counter id.\n\n@param countersReader the counters reader to use (required)\n@param counterId the counter id to get the recording id for (required)\n@return the recording id for the given counter id or NULL_RECORDING_ID if the counter is not a recording position counter or if the counter is not allocated."}, {"ID": 1928, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean exactlyEqual(final Sketch sketchA, final Sketch sketchB) { //Corner case checks if ((sketchA == null) || (sketchB == null)) { return false; } if (sketchA == sketchB) { return true; } if (sketchA.isEmpty() && sketchB.isEmpty()) { return true; } if (sketchA.isEmpty() || sketchB.isEmpty()) { return false; } final int countA = sketchA.getRetainedEntries(); final int countB = sketchB.getRetainedEntries(); //Create the Union final Union union = SetOperation.builder().setNominalEntries(ceilingPowerOf2(countA + countB)).buildUnion(); union.update(sketchA); union.update(sketchB); final Sketch unionAB = union.getResult(); final long thetaLongUAB = unionAB.getThetaLong(); final long thetaLongA = sketchA.getThetaLong(); final long thetaLongB = sketchB.getThetaLong(); final int countUAB = unionAB.getRetainedEntries(); //Check for identical counts and thetas if ((countUAB == countA) && (countUAB == countB) && (thetaLongUAB == thetaLongA) && (thetaLongUAB == thetaLongB)) { return true; } return false; }\n\n    ### Response: Returns true if the two given sketches have exactly the same hash values and the same\ntheta values. Thus, they are equivalent.\n@param sketchA the given sketch A\n@param sketchB the given sketch B\n@return true if the two given sketches have exactly the same hash values and the same\ntheta values..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isActive(final CountersReader countersReader, final int counterId, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); return buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId; } return false; }\n\n    ### Response:", "ground_truth": "Is the recording counter still active.\n\n@param countersReader to search within.\n@param counterId      to search for.\n@param recordingId    to confirm it is still the same value.\n@return true if the counter is still active otherwise false.", "predict": " Returns true if the given counter is active for the given recording id.\n@param countersReader the given counters reader\n@param counterId the given counter id\n@param recordingId the given recording id\n@return true if the given counter is active for the given recording id."}, {"ID": 1929, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] safeCopy(byte[] source, int offset, int length) { if (length < 0 || source.length < offset+length) { return null; } byte[] copy = new byte[length]; System.arraycopy(source, offset, copy, 0, length); return copy; }\n\n    ### Response: Returns a copy of the source byte array, starting at offset for the given\nlength.  If the offset + length is out of bounds for the array, returns null.\n@param source\n@param offset\n@param length\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) { frameLength(HEADER_LENGTH + length); putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length); return this; }\n\n    ### Response:", "ground_truth": "Set the Application Specific Feedback for the Status Message.\n\n@param source of the feedback to set\n@param offset of the feedback in the source\n@param length of the feedback in bytes\n@return flyweight", "predict": " Sets the application specific feedback field in the message flyweight.\n@param source\n@param offset\n@param length\n@return."}, {"ID": 1930, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean refill() throws IOException { if (!byteBuffer.hasRemaining()) { byteBuffer.clear(); int nRead = 0; while (nRead == 0) { nRead = fileChannel.read(byteBuffer); } if (nRead < 0) { return false; } byteBuffer.flip(); } return true; }\n\n    ### Response: Checks weather data is left to be read from the input stream.\n@return true if data is left, false otherwise\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reload() { entries.clear(); indexByLeadershipTermIdMap.clear(); indexByLeadershipTermIdMap.compact(); nextEntryIndex = 0; byteBuffer.clear(); try { while (true) { final int bytes = fileChannel.read(byteBuffer); if (byteBuffer.remaining() == 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } if (-1 == bytes) { if (byteBuffer.position() > 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } break; } } } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response:", "ground_truth": "Reload the log from disk.", "predict": " Reloads the entries from the input stream.\n@throws IOException if an I/O error occurs."}, {"ID": 1931, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    TriggerDef getTrigger(String name) { for (int i = triggerList.length - 1; i >= 0; i--) { if (triggerList[i].name.name.equals(name)) { return triggerList[i]; } } return null; }\n\n    ### Response: Returns a trigger..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Entry findLastTerm() { for (int i = entries.size() - 1; i >= 0; i--) { final Entry entry = entries.get(i); if (ENTRY_TYPE_TERM == entry.type) { return entry; } } return null; }\n\n    ### Response:", "ground_truth": "Find the last leadership term in the recording log.\n\n@return the last leadership term in the recording log.", "predict": " Returns the last term entry in the list."}, {"ID": 1932, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sortFileList() { if (this.size() > 1) { Collections.sort(this.fileList, new Comparator() { public final int compare(final Object o1, final Object o2) { final File f1 = (File) o1; final File f2 = (File) o2; final Object[] f1TimeAndCount = backupSuffixHelper .backupTimeAndCount(f1.getName(), baseFile); final Object[] f2TimeAndCount = backupSuffixHelper .backupTimeAndCount(f2.getName(), baseFile); final long f1TimeSuffix = ((Long) f1TimeAndCount[0]).longValue(); final long f2TimeSuffix = ((Long) f2TimeAndCount[0]).longValue(); if ((0L == f1TimeSuffix) && (0L == f2TimeSuffix)) { final long f1Time = f1.lastModified(); final long f2Time = f2.lastModified(); if (f1Time < f2Time) { return -1; } if (f1Time > f2Time) { return 1; } return 0; } if (f1TimeSuffix < f2TimeSuffix) { return -1; } if (f1TimeSuffix > f2TimeSuffix) { return 1; } final int f1Count = ((Integer) f1TimeAndCount[1]).intValue(); final int f2Count = ((Integer) f2TimeAndCount[1]).intValue(); if (f1Count < f2Count) { return -1; } if (f1Count > f2Count) { return 1; } if (f1Count == f2Count) { if (fileHelper.isCompressed(f1)) { return -1; } if (fileHelper.isCompressed(f2)) { return 1; } } return 0; } }); } }\n\n    ### Response: Sort by time bucket, then backup count, and by compression state..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RecoveryPlan createRecoveryPlan(final AeronArchive archive, final int serviceCount) { final ArrayList<Snapshot> snapshots = new ArrayList<>(); final ArrayList<Log> logs = new ArrayList<>(); planRecovery(snapshots, logs, entries, archive, serviceCount); long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } if (!logs.isEmpty()) { final Log log = logs.get(0); lastLeadershipTermId = log.leadershipTermId; lastTermBaseLogPosition = log.termBaseLogPosition; appendedLogPosition = log.stopPosition; committedLogPosition = log.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, logs); }\n\n    ### Response:", "ground_truth": "Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the\nlatest stable state.\n\n@param archive      to lookup recording descriptors.\n@param serviceCount of services that may have snapshots.\n@return a new {@link RecoveryPlan} for the cluster.", "predict": " Create a recovery plan based on the available snapshots and logs. The plan includes the last leadership term id, last term base log position, appended log position, and committed log position. The plan also includes the list of snapshots and logs."}, {"ID": 1933, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Range convert(final String source) { final Matcher matcher = rangePattern.matcher(source); if (!matcher.matches()) { return new Range(); } final String from = matcher.group(1); final String to = matcher.group(2); final long start; if (from.equals(\"\")) { start = 0; } else { start = parseLong(from); } final long end; if (to.equals(\"\")) { end = -1; } else { end = parseLong(to); } return new Range(start, end); }\n\n    ### Response: Convert an HTTP Range header to a Range object\n@param source the source\n@return range object.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) { long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new ArrayList<>()); }\n\n    ### Response:", "ground_truth": "Create a recovery plan that has only snapshots. Used for dynamicJoin snapshot load.\n\n@param snapshots to construct plan from\n@return a new {@link RecoveryPlan} for the cluster", "predict": " Create a recovery plan from a list of recording log snapshots\n@param snapshots the list of recording log snapshots\n@return recovery plan object."}, {"ID": 1934, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Deferred<ArrayList<Object>> flush() { final int size = size(); if (size > 0) { LOG.info(\"Flushing all old outstanding rows out of \" + size + \" rows\"); } final long now = System.currentTimeMillis(); return flush(now / 1000 - Const.MAX_TIMESPAN - 1, Integer.MAX_VALUE); }\n\n    ### Response: Forces a flush of the all old entries in the compaction queue.\n@return A deferred that will be called back once everything has been\nflushed (or something failed, in which case the deferred will carry the\nexception).  In case of success, the kind of object returned is\nunspecified..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void appendTerm( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { final int size = entries.size(); if (size > 0) { final Entry lastEntry = entries.get(size - 1); if (lastEntry.type != NULL_VALUE && lastEntry.leadershipTermId >= leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + lastEntry.leadershipTermId + \" this \" + leadershipTermId); } } indexByLeadershipTermIdMap.put(leadershipTermId, nextEntryIndex); append( ENTRY_TYPE_TERM, recordingId, leadershipTermId, termBaseLogPosition, NULL_POSITION, timestamp, NULL_VALUE); }\n\n    ### Response:", "ground_truth": "Append a log entry for a leadership term.\n\n@param recordingId         of the log.\n@param leadershipTermId    for the current term.\n@param termBaseLogPosition reached at the beginning of the term.\n@param timestamp           at the beginning of the term.", "predict": " Appends a new term entry to the log.\n@param recordingId the id of the recording that produced this term\n@param leadershipTermId the id of the leadership term for which this term was produced\n@param termBaseLogPosition the base log position at the time of the term\n@param timestamp the timestamp of the term\n@throws ClusterException if the leadershipTermId is not in sequence with the previous term\n\n    "}, {"ID": 1935, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Deferred<ArrayList<Object>> flush() { final int size = size(); if (size > 0) { LOG.info(\"Flushing all old outstanding rows out of \" + size + \" rows\"); } final long now = System.currentTimeMillis(); return flush(now / 1000 - Const.MAX_TIMESPAN - 1, Integer.MAX_VALUE); }\n\n    ### Response: Forces a flush of the all old entries in the compaction queue.\n@return A deferred that will be called back once everything has been\nflushed (or something failed, in which case the deferred will carry the\nexception).  In case of success, the kind of object returned is\nunspecified..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) { final Entry entry = entries.get(size - 1); if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + entry.leadershipTermId + \" this \" + leadershipTermId); } } append( ENTRY_TYPE_SNAPSHOT, recordingId, leadershipTermId, termBaseLogPosition, logPosition, timestamp, serviceId); }\n\n    ### Response:", "ground_truth": "Append a log entry for a snapshot.\n\n@param recordingId         in the archive for the snapshot.\n@param leadershipTermId    for the current term\n@param termBaseLogPosition at the beginning of the leadership term.\n@param logPosition         for the position in the current term or length so far for that term.\n@param timestamp           at which the snapshot was taken.\n@param serviceId           for which the snapshot is recorded.", "predict": " Appends a snapshot entry to the log.\n@param recordingId the id of the recording that this snapshot is for.\n@param leadershipTermId the leadership term id of the leader that this snapshot is for.\n@param termBaseLogPosition the log position of the first entry in the term.\n@param logPosition the log position of the snapshot.\n@param timestamp the timestamp of the snapshot.\n@param serviceId the id of the service that this snapshot is for.\n@throws ClusterException if the leadershipTermId is not in sequence with the previous entry."}, {"ID": 1936, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void advise(long position, long length) throws IOException { final long ap = address+position; final long a = (ap)/PAGE_SIZE*PAGE_SIZE; final long l = Math.min(length+(ap-a), address+memory.length()-ap); final int err = madvise(a, l); if (err != 0) { throw new IOException(\"madvise failed with error code: \"+err); } }\n\n    ### Response: this is not particularly useful, the syscall takes forever.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commitLogPosition(final long leadershipTermId, final long logPosition) { final int index = getLeadershipTermEntryIndex(leadershipTermId); commitEntryValue(index, logPosition, LOG_POSITION_OFFSET); final Entry entry = entries.get(index); entries.set(index, new Entry( entry.recordingId, entry.leadershipTermId, entry.termBaseLogPosition, logPosition, entry.timestamp, entry.serviceId, entry.type, entry.entryIndex)); }\n\n    ### Response:", "ground_truth": "Commit the position reached in a leadership term before a clean shutdown.\n\n@param leadershipTermId for committing the term position reached.\n@param logPosition      reached in the leadership term.", "predict": " this method is not particularly useful, it just sets the log position for a leadership term."}, {"ID": 1937, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void fill(final FileChannel fileChannel, final long position, final long length, final byte value) { try { final byte[] filler; if (0 != value) { filler = new byte[BLOCK_SIZE]; Arrays.fill(filler, value); } else { filler = FILLER; } final ByteBuffer byteBuffer = ByteBuffer.wrap(filler); fileChannel.position(position); final int blocks = (int)(length / BLOCK_SIZE); final int blockRemainder = (int)(length % BLOCK_SIZE); for (int i = 0; i < blocks; i++) { byteBuffer.position(0); fileChannel.write(byteBuffer); } if (blockRemainder > 0) { byteBuffer.position(0); byteBuffer.limit(blockRemainder); fileChannel.write(byteBuffer); } } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response: Fill a region of a file with a given byte value.\n\n@param fileChannel to fill\n@param position    at which to start writing.\n@param length      of the region to write.\n@param value       to fill the region with..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void tombstoneEntry(final long leadershipTermId, final int entryIndex) { int index = -1; for (int i = 0, size = entries.size(); i < size; i++) { final Entry entry = entries.get(i); if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) { index = entry.entryIndex; if (ENTRY_TYPE_TERM == entry.type) { indexByLeadershipTermIdMap.remove(leadershipTermId); } break; } } if (-1 == index) { throw new ClusterException(\"unknown entry index: \" + entryIndex); } buffer.putInt(0, NULL_VALUE, LITTLE_ENDIAN); byteBuffer.limit(SIZE_OF_INT).position(0); final long filePosition = (index * (long)ENTRY_LENGTH) + ENTRY_TYPE_OFFSET; try { if (SIZE_OF_INT != fileChannel.write(byteBuffer, filePosition)) { throw new ClusterException(\"failed to write field atomically\"); } } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response:", "ground_truth": "Tombstone an entry in the log so it is no longer valid.\n\n@param leadershipTermId to match for validation.\n@param entryIndex       reached in the leadership term.", "predict": " Mark an entry as deleted in the log.\n\n@param leadershipTermId of the entry to delete.\n@param entryIndex       of the entry to delete.\n\n    "}, {"ID": 1938, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) { Tr.entry(tc, \"close, vc=\" + getVCHash()); } synchronized (closeSync) { if (closeCalled) { return; } closeCalled = true; if (null != this.netBuffer) { if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) { Tr.event(tc, \"Releasing netBuffer during close \" + SSLUtils.getBufferTraceInfo(netBuffer)); } this.netBuffer.release(); this.netBuffer = null; } cleanupDecBuffers(); if (unconsumedDecData != null) { if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) { Tr.event(tc, \"Releasing unconsumed decrypted buffers, \" + SSLUtils.getBufferTraceInfo(unconsumedDecData)); } WsByteBufferUtils.releaseBufferArray(unconsumedDecData); unconsumedDecData = null; } } if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) { Tr.exit(tc, \"close\"); } }\n\n    ### Response: Release the potential buffer that were created.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (null != publication && publication.isConnected()) { closeSession(); } if (!ctx.ownsAeronClient()) { CloseHelper.close(subscription); CloseHelper.close(publication); } ctx.close(); }\n\n    ### Response:", "ground_truth": "Close session and release associated resources.", "predict": " Release the resources that were created."}, {"ID": 1939, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized boolean waitOnBarrier(long maxWait, TimeUnit unit) throws Exception { long startMs = System.currentTimeMillis(); boolean hasMaxWait = (unit != null); long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE; boolean result; for(;;) { result = (client.checkExists().usingWatcher(watcher).forPath(barrierPath) == null); if ( result ) { break; } if ( hasMaxWait ) { long elapsed = System.currentTimeMillis() - startMs; long thisWaitMs = maxWaitMs - elapsed; if ( thisWaitMs <= 0 ) { break; } wait(thisWaitMs); } else { wait(); } } return result; }\n\n    ### Response: Blocks until the barrier no longer exists or the timeout elapses\n\n@param maxWait max time to block\n@param unit time unit\n@return true if the wait was successful, false if the timeout elapsed first\n@throws Exception errors.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBufferVector[] vectors) { if (headerVector != vectors[0]) { vectors[0] = headerVector; } return publication.offer(vectors, null); }\n\n    ### Response:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message. The first vector will be replaced by the cluster\ningress header so must be left unused.\n\n@param vectors which make up the message.\n@return the same as {@link Publication#offer(DirectBufferVector[])}.\n@see Publication#offer(DirectBufferVector[])", "predict": "Offers the specified message to the ring buffer.\n\n@param vectors the message to offer\n@return the sequence ID of the message within the ring buffer\n@throws IllegalStateException if the ring buffer is closed or not yet opened\n\n    "}, {"ID": 1940, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int hashSearch(final Memory mem, final int lgArrLongs, final long hash, final int memOffsetBytes) { final int arrayMask = (1 << lgArrLongs) - 1; final int stride = getStride(hash, lgArrLongs); int curProbe = (int) (hash & arrayMask); final int loopIndex = curProbe; do { final int curProbeOffsetBytes = (curProbe << 3) + memOffsetBytes; final long curArrayHash = mem.getLong(curProbeOffsetBytes); if (curArrayHash == EMPTY) { return -1; } else if (curArrayHash == hash) { return curProbe; } curProbe = (curProbe + stride) & arrayMask; } while (curProbe != loopIndex); return -1; }\n\n    ### Response: This is a classical Knuth-style Open Addressing, Double Hash search scheme for off-heap.\nReturns the index if found, -1 if not found.\n\n@param mem The Memory hash table to search.\n@param lgArrLongs See lgArrLongs.\nlgArrLongs &le; log2(hashTable.length).\n@param hash A hash value to search for. Must not be zero.\n@param memOffsetBytes offset in the memory where the hash array starts\n@return index if found, -1 if not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean unblock( final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) { final int positionBitsToShift = LogBufferDescriptor.positionBitsToShift(termLength); final int blockedTermCount = (int)(blockedPosition >> positionBitsToShift); final int blockedOffset = (int)blockedPosition & (termLength - 1); final int activeTermCount = activeTermCount(logMetaDataBuffer); if (activeTermCount == (blockedTermCount - 1) && blockedOffset == 0) { final int currentTermId = termId(rawTailVolatile(logMetaDataBuffer, indexByTermCount(activeTermCount))); return rotateLog(logMetaDataBuffer, activeTermCount, currentTermId); } final int blockedIndex = indexByTermCount(blockedTermCount); final long rawTail = rawTailVolatile(logMetaDataBuffer, blockedIndex); final int termId = termId(rawTail); final int tailOffset = termOffset(rawTail, termLength); final UnsafeBuffer termBuffer = termBuffers[blockedIndex]; switch (TermUnblocker.unblock(logMetaDataBuffer, termBuffer, blockedOffset, tailOffset, termId)) { case UNBLOCKED_TO_END: rotateLog(logMetaDataBuffer, blockedTermCount, termId); // fall through case UNBLOCKED: return true; } return false; }\n\n    ### Response:", "ground_truth": "Attempt to unblock a log buffer at given position\n\n@param termBuffers       for current blockedOffset\n@param logMetaDataBuffer for log buffer\n@param blockedPosition   to attempt to unblock\n@param termLength        of the buffer for each term in the log\n@return whether unblocked or not", "predict": " This method unblocks a term in the log buffer by rotating the log and updating the active term count.\n\n@param termBuffers The term buffers to search for the term to unblock.\n@param logMetaDataBuffer The log metadata buffer to update the active term count.\n@param blockedPosition The position of the blocked term.\n@param termLength The length of the term.\n@return true if the term was unblocked, false otherwise.\n\n    "}, {"ID": 1941, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Token scanIdentifier() { if ('`' == charAt(offset)) { int length = getLengthUntilTerminatedChar('`'); return new Token(Literals.IDENTIFIER, input.substring(offset, offset + length), offset + length); } if ('\"' == charAt(offset)) { int length = getLengthUntilTerminatedChar('\"'); return new Token(Literals.IDENTIFIER, input.substring(offset, offset + length), offset + length); } if ('[' == charAt(offset)) { int length = getLengthUntilTerminatedChar(']'); return new Token(Literals.IDENTIFIER, input.substring(offset, offset + length), offset + length); } int length = 0; while (isIdentifierChar(charAt(offset + length))) { length++; } String literals = input.substring(offset, offset + length); if (isAmbiguousIdentifier(literals)) { return new Token(processAmbiguousIdentifier(offset + length, literals), literals, offset + length); } return new Token(dictionary.findTokenType(literals, Literals.IDENTIFIER), literals, offset + length); }\n\n    ### Response: scan identifier.\n\n@return identifier token.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String channel() { final int length = buffer.getInt(offset + CHANNEL_OFFSET); lengthOfChannel = SIZE_OF_INT + length; return buffer.getStringAscii(offset + CHANNEL_OFFSET, length); }\n\n    ### Response:", "ground_truth": "Get the channel field as ASCII\n\n@return channel field", "predict": " get channel name.\n\n@return channel name.\n\n    "}, {"ID": 1942, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServerUpdater setVoiceChannel(User user, ServerVoiceChannel channel) { delegate.setVoiceChannel(user, channel); return this; }\n\n    ### Response: Queues a moving a user to a different voice channel.\n\n@param user The user who should be moved.\n@param channel The new voice channel of the user.\n@return The current instance in order to chain call methods..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ImageMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; }\n\n    ### Response:", "ground_truth": "Set the channel field as ASCII\n\n@param channel field value\n@return flyweight", "predict": " Sets the channel of the image message.\n\n@param channel The channel of the image message.\n@return The current instance in order to chain call methods."}, {"ID": 1943, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PrimitiveValue parse( final String value, final int length, final String characterEncoding) { if (value.length() > length) { throw new IllegalStateException(\"value.length=\" + value.length() + \" greater than length=\" + length); } byte[] bytes = value.getBytes(forName(characterEncoding)); if (bytes.length < length) { bytes = Arrays.copyOf(bytes, length); } return new PrimitiveValue(bytes, characterEncoding, length); }\n\n    ### Response: Parse constant value string and set representation based on type, length, and characterEncoding\n\n@param value             expressed as a String\n@param length            of the type\n@param characterEncoding of the String\n@return a new {@link PrimitiveValue} for the value.\n@throws IllegalArgumentException if parsing malformed type.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkTermLength(final int termLength) { if (termLength < TERM_MIN_LENGTH) { throw new IllegalStateException( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength); } if (termLength > TERM_MAX_LENGTH) { throw new IllegalStateException( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength); } if (!BitUtil.isPowerOfTwo(termLength)) { throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength); } }\n\n    ### Response:", "ground_truth": "Check that term length is valid and alignment is valid.\n\n@param termLength to be checked.\n@throws IllegalStateException if the length is not as expected.", "predict": " Check if the term length is within the allowed range and is a power of 2.\n\n@param termLength the length of the term to check\n@throws IllegalStateException if the term length is less than the minimum allowed length or more than the maximum allowed length or is not a power of 2."}, {"ID": 1944, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> List<T> subList(final List<T> list, int pageSize, int page) { if (pageSize <= 0 || page == 0) { return Collections.EMPTY_LIST; } int size = list.size(); int fromIndex = page > 0 ? (page - 1) * pageSize : size + (page * pageSize); int toIndex = fromIndex + pageSize; int finalFromIndex = Math.max(0, fromIndex); int finalToIndex = Math.min(size, Math.max(0, toIndex)); // prevent fromIndex to be greater than toIndex if (finalFromIndex > finalToIndex) { finalFromIndex = finalToIndex; } try { return list.subList(finalFromIndex, finalToIndex); } catch (Throwable t) { logger.warn(\"Invalid range for sublist in paging, pageSize {}, page {}: {}\", new Object[] { pageSize, page, t.getMessage() }); } return Collections.EMPTY_LIST; }\n\n    ### Response: Return a single page of the list with the given paging parameters.\n\n@param list\n@param pageSize\n@param page\n@return subList.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkPageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new IllegalStateException( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new IllegalStateException( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize); } }\n\n    ### Response:", "ground_truth": "Check that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws IllegalStateException if the size is not as expected.", "predict": " Check that the page size is within the allowed range and is a power of 2.\n\n@param pageSize\n@throws IllegalStateException if the page size is not within the allowed range or is not a power of 2."}, {"ID": 1945, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsIgnoreCase(final CharSequence left, final int leftOffset, final int leftLength, final CharSequence right, final int rightOffset, final int rightLength) { if (leftLength == rightLength) { for (int i = 0; i < rightLength; i++) { if (toLowerCase(left.charAt(i + leftOffset)) != toLowerCase(right.charAt(i + rightOffset))) { return false; } } return true; } return false; }\n\n    ### Response: Returns true if the specified section of the left CharSequence equals, ignoring case, the specified section of\nthe right CharSequence.\n\n@param left the left CharSequence\n@param leftOffset start index in the left CharSequence\n@param leftLength length of the section in the left CharSequence\n@param right the right CharSequence to compare a section of\n@param rightOffset start index in the right CharSequence\n@param rightLength length of the section in the right CharSequence\n@return true if equal ignoring case, false otherwise.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean casActiveTermCount( final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) { return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount); }\n\n    ### Response:", "ground_truth": "Compare and set the value of the current active term count.\n\n@param metadataBuffer    containing the meta data.\n@param expectedTermCount value of the active term count expected in the log\n@param updateTermCount   value of the active term count to be updated in the log\n@return true if successful otherwise false.", "predict": " Atomically updates the active term count in the metadata buffer to the given value if it is equal to the expected term count.\n\n@param metadataBuffer the metadata buffer to update\n@param expectedTermCount the expected term count\n@param updateTermCount the new term count to update to\n@return true if the update was successful, false otherwise."}, {"ID": 1946, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int hashSearch(final Memory mem, final int lgArrLongs, final long hash, final int memOffsetBytes) { final int arrayMask = (1 << lgArrLongs) - 1; final int stride = getStride(hash, lgArrLongs); int curProbe = (int) (hash & arrayMask); final int loopIndex = curProbe; do { final int curProbeOffsetBytes = (curProbe << 3) + memOffsetBytes; final long curArrayHash = mem.getLong(curProbeOffsetBytes); if (curArrayHash == EMPTY) { return -1; } else if (curArrayHash == hash) { return curProbe; } curProbe = (curProbe + stride) & arrayMask; } while (curProbe != loopIndex); return -1; }\n\n    ### Response: This is a classical Knuth-style Open Addressing, Double Hash search scheme for off-heap.\nReturns the index if found, -1 if not found.\n\n@param mem The Memory hash table to search.\n@param lgArrLongs See lgArrLongs.\nlgArrLongs &le; log2(hashTable.length).\n@param hash A hash value to search for. Must not be zero.\n@param memOffsetBytes offset in the memory where the hash array starts\n@return index if found, -1 if not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long computePosition( final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId) { final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover return (termCount << positionBitsToShift) + termOffset; }\n\n    ### Response:", "ground_truth": "Compute the current position in absolute number of bytes.\n\n@param activeTermId        active term id.\n@param termOffset          in the term.\n@param positionBitsToShift number of times to left shift the term count\n@param initialTermId       the initial term id that this stream started on\n@return the absolute position in bytes", "predict": " Computes the position in the postings list for a given term and position within the term.\n\n@param activeTermId The term ID of the current term.\n@param termOffset The position within the current term.\n@param positionBitsToShift The number of bits to shift the position by to get the final position.\n@param initialTermId The initial term ID of the current segment.\n@return The position in the postings list for the given term and position within the term."}, {"ID": 1947, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected function getMemoryUsageString() { switch (strtoupper(trim(ShopgateLogger::getInstance()->getMemoryAnalyserLoggingSizeUnit()))) { case 'GB': return (memory_get_usage() / (1024 * 1024 * 1024)) . \" GB (real usage \" . (memory_get_usage( true ) / (1024 * 1024 * 1024)) . \" GB)\"; case 'MB': return (memory_get_usage() / (1024 * 1024)) . \" MB (real usage \" . (memory_get_usage( true ) / (1024 * 1024)) . \" MB)\"; case 'KB': return (memory_get_usage() / 1024) . \" KB (real usage \" . (memory_get_usage(true) / 1024) . \" KB)\"; default: return memory_get_usage() . \" Bytes (real usage \" . memory_get_usage(true) . \" Bytes)\"; } }\n\n    ### Response: Gets the used memory and real used memory and returns it as a string\n\n@return string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long computeLogLength(final int termLength, final int filePageSize) { if (termLength < (1024 * 1024 * 1024)) { return align((termLength * PARTITION_COUNT) + LOG_META_DATA_LENGTH, filePageSize); } return (PARTITION_COUNT * (long)termLength) + align(LOG_META_DATA_LENGTH, filePageSize); }\n\n    ### Response:", "ground_truth": "Compute the total length of a log file given the term length.\n\nAssumes {@link #TERM_MAX_LENGTH} is 1GB and that filePageSize is 1GB or less and a power of 2.\n\n@param termLength   on which to base the calculation.\n@param filePageSize to use for log.\n@return the total length of the log file.", "predict": " Computes the length of the log file based on the term length and file page size.\n\n@param termLength the length of the term to be added to the log file.\n@param filePageSize the size of the file page.\n@return the length of the log file in bytes."}, {"ID": 1948, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void validateCreation(String method, SipApplicationSession app) { if (method.equals(Request.ACK)) { throw new IllegalArgumentException( \"Wrong method to create request with[\" + Request.ACK + \"]!\"); } if (method.equals(Request.PRACK)) { throw new IllegalArgumentException( \"Wrong method to create request with[\" + Request.PRACK + \"]!\"); } if (method.equals(Request.CANCEL)) { throw new IllegalArgumentException( \"Wrong method to create request with[\" + Request.CANCEL + \"]!\"); } if (!((MobicentsSipApplicationSession)app).isValidInternal()) { throw new IllegalArgumentException( \"Cant associate request with invalidaded sip session application!\"); } }\n\n    ### Response: Does basic check for illegal methods, wrong state, if it finds, it throws\nexception.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) { if (defaultHeader.capacity() != HEADER_LENGTH) { throw new IllegalArgumentException( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity()); } metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH); metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH); }\n\n    ### Response:", "ground_truth": "Store the default frame header to the log meta data buffer.\n\n@param metadataBuffer into which the default headers should be stored.\n@param defaultHeader  to be stored.\n@throws IllegalArgumentException if the defaultHeader larger than {@link #LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH}", "predict": " This method stores the default frame header in the metadata buffer. It first checks if the length of the default header is equal to the expected length of the header. If not, it throws an IllegalArgumentException. It then stores the length of the header and the header itself in the metadata buffer."}, {"ID": 1949, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public NDArrayMessage doGetUpdate(int index) { byte[] key = ByteBuffer.allocate(4).putInt(index).array(); try { UnsafeBuffer unsafeBuffer = new UnsafeBuffer(db.get(key)); return NDArrayMessage.fromBuffer(unsafeBuffer, 0); } catch (RocksDBException e) { throw new RuntimeException(e); } }\n\n    ### Response: A method for actually performing the implementation\nof retrieving the ndarray\n\n@param index the index of the {@link INDArray} to get\n@return the ndarray at the specified index.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void applyDefaultHeader( final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) { termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH); }\n\n    ### Response:", "ground_truth": "Apply the default header for a message in a term.\n\n@param metadataBuffer containing the default headers.\n@param termBuffer     to which the default header should be applied.\n@param termOffset     at which the default should be applied.", "predict": " A method for applying the default header to the term buffer.\n\n@param metadataBuffer the metadata buffer containing the default header\n@param termBuffer the term buffer to which the header should be applied\n@param termOffset the offset in the term buffer where the header should be applied\n@throws IllegalArgumentException if the metadata buffer is not of length {@link #HEADER_LENGTH}"}, {"ID": 1950, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int hashSearch(final Memory mem, final int lgArrLongs, final long hash, final int memOffsetBytes) { final int arrayMask = (1 << lgArrLongs) - 1; final int stride = getStride(hash, lgArrLongs); int curProbe = (int) (hash & arrayMask); final int loopIndex = curProbe; do { final int curProbeOffsetBytes = (curProbe << 3) + memOffsetBytes; final long curArrayHash = mem.getLong(curProbeOffsetBytes); if (curArrayHash == EMPTY) { return -1; } else if (curArrayHash == hash) { return curProbe; } curProbe = (curProbe + stride) & arrayMask; } while (curProbe != loopIndex); return -1; }\n\n    ### Response: This is a classical Knuth-style Open Addressing, Double Hash search scheme for off-heap.\nReturns the index if found, -1 if not found.\n\n@param mem The Memory hash table to search.\n@param lgArrLongs See lgArrLongs.\nlgArrLongs &le; log2(hashTable.length).\n@param hash A hash value to search for. Must not be zero.\n@param memOffsetBytes offset in the memory where the hash array starts\n@return index if found, -1 if not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = indexByTermCount(nextTermCount); final int expectedTermId = nextTermId - PARTITION_COUNT; long rawTail; do { rawTail = rawTail(metadataBuffer, nextIndex); if (expectedTermId != termId(rawTail)) { break; } } while (!casRawTail(metadataBuffer, nextIndex, rawTail, packTail(nextTermId, 0))); return casActiveTermCount(metadataBuffer, termCount, nextTermCount); }\n\n    ### Response:", "ground_truth": "Rotate the log and update the tail counter for the new term.\n\nThis method is safe for concurrent use.\n\n@param metadataBuffer for the log.\n@param termCount      from which to rotate.\n@param termId         to be used in the default headers.\n@return true if log was rotated.", "predict": " This method rotates the log by one term.\n\n@param metadataBuffer The buffer containing the metadata.\n@param termCount The current term count.\n@param termId The current term id.\n@return true if the rotation was successful, false otherwise.\n\n    "}, {"ID": 1951, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private TextWatcher createTextChangeListener() { return new TextWatcher() { @Override public final void beforeTextChanged(final CharSequence s, final int start, final int count, final int after) { } @Override public final void onTextChanged(final CharSequence s, final int start, final int before, final int count) { } @Override public final void afterTextChanged(final Editable s) { verifyPasswordStrength(); } }; }\n\n    ### Response: Creates and returns a listener, which allows to verify the password strength, when the\npassword has been changed.\n\n@return The listener, which has been created, as an instance of the type {@link TextWatcher}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void initialiseTailWithTermId( final UnsafeBuffer metadataBuffer, final int partitionIndex, final int termId) { metadataBuffer.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0)); }\n\n    ### Response:", "ground_truth": "Set the initial value for the termId in the upper bits of the tail counter.\n\n@param metadataBuffer contain the tail counter.\n@param partitionIndex to be initialised.\n@param termId         to be set.", "predict": "Initialises the tail counter for a given termId in a given partition.\n\n@param metadataBuffer The buffer containing the metadata for the log.\n@param partitionIndex The index of the partition to initialise the tail counter for.\n@param termId The termId to initialise the tail counter for."}, {"ID": 1952, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long encodeHi(long encoded, int hi) { long h = ((long) hi) & 0xFFFF_FFFFL; long l = encoded & 0xFFFF_FFFFL; return (h << 32) + l; }\n\n    ### Response: Sets the hi value into the given encoded value.\n\n@param encoded the encoded value\n@param hi      the hi value\n@return the new encoded value.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int termOffset(final long rawTail, final long termLength) { final long tail = rawTail & 0xFFFF_FFFFL; return (int)Math.min(tail, termLength); }\n\n    ### Response:", "ground_truth": "Read the termOffset from a packed raw tail value.\n\n@param rawTail    containing the termOffset.\n@param termLength that the offset cannot exceed.\n@return the termOffset value.", "predict": " Calculates the offset of the term in the raw tail.\n\n@param rawTail   the raw tail value\n@param termLength the length of the term\n@return the offset of the term in the raw tail."}, {"ID": 1953, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int computeRetainedItems(final int k, final long n) { final int bbCnt = computeBaseBufferItems(k, n); final long bitPattern = computeBitPattern(k, n); final int validLevels = computeValidLevels(bitPattern); return bbCnt + (validLevels * k); }\n\n    ### Response: Returns the number of retained valid items in the sketch given k and n.\n@param k the given configured k of the sketch\n@param n the current number of items seen by the sketch\n@return the number of retained items in the sketch given k and n..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) { final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer)); return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex)); }\n\n    ### Response:", "ground_truth": "Get the raw value of the tail for the current active partition.\n\n@param metadataBuffer containing the tail counters.\n@return the raw value of the tail for the current active partition.", "predict": " Returns the raw tail value for the given metadata buffer.\n@param metadataBuffer the given metadata buffer\n@return the raw tail value for the given metadata buffer.\n\n    "}, {"ID": 1954, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int computeRetainedItems(final int k, final long n) { final int bbCnt = computeBaseBufferItems(k, n); final long bitPattern = computeBitPattern(k, n); final int validLevels = computeValidLevels(bitPattern); return bbCnt + (validLevels * k); }\n\n    ### Response: Returns the number of retained valid items in the sketch given k and n.\n@param k the given configured k of the sketch\n@param n the current number of items seen by the sketch\n@return the number of retained items in the sketch given k and n..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean casRawTail( final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) { final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex); return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail); }\n\n    ### Response:", "ground_truth": "Compare and set the raw value of the tail for the given partition.\n\n@param metadataBuffer  containing the tail counters.\n@param partitionIndex  for the tail counter.\n@param expectedRawTail expected current value.\n@param updateRawTail   to be applied.\n@return true if the update was successful otherwise false.", "predict": " Atomically updates the raw tail of the given partition index in the metadata buffer to the given update value if the current value is equal to the expected value.\n@param metadataBuffer the metadata buffer to update\n@param partitionIndex the index of the partition to update\n@param expectedRawTail the expected value of the raw tail\n@param updateRawTail the new value for the raw tail\n@return true if the update was successful, false otherwise.\n\n    "}, {"ID": 1955, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"checkstyle:ReturnCount\") public static int compareBuff(final DirectBuffer o1, final DirectBuffer o2) { requireNonNull(o1); requireNonNull(o2); if (o1.equals(o2)) { return 0; } final int minLength = Math.min(o1.capacity(), o2.capacity()); final int minWords = minLength / Long.BYTES; for (int i = 0; i < minWords * Long.BYTES; i += Long.BYTES) { final long lw = o1.getLong(i, BIG_ENDIAN); final long rw = o2.getLong(i, BIG_ENDIAN); final int diff = Long.compareUnsigned(lw, rw); if (diff != 0) { return diff; } } for (int i = minWords * Long.BYTES; i < minLength; i++) { final int lw = Byte.toUnsignedInt(o1.getByte(i)); final int rw = Byte.toUnsignedInt(o2.getByte(i)); final int result = Integer.compareUnsigned(lw, rw); if (result != 0) { return result; } } return o1.capacity() - o2.capacity(); }\n\n    ### Response: Lexicographically compare two buffers.\n\n@param o1 left operand (required)\n@param o2 right operand (required)\n@return as specified by {@link Comparable} interface.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public TerminateDriverFlyweight tokenBuffer( final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength); if (null != tokenBuffer && tokenLength > 0) { buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength); } return this; }\n\n    ### Response:", "ground_truth": "Fill the token buffer.\n\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return flyweight", "predict": " Set the token buffer and its length in the token flyweight.\n\n@param tokenBuffer the buffer containing the token data (optional)\n@param tokenOffset the offset in the buffer where the token data starts\n@param tokenLength the length of the token data in the buffer\n@return this flyweight\n\n    "}, {"ID": 1956, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getArgumentUsage( final Map<String, NamedArgumentDefinition> allActualArguments, final Collection<CommandLinePluginDescriptor<?>> pluginDescriptors, final int argumentColumnWidth, final int descriptionColumnWidth) { final StringBuilder sb = new StringBuilder(); sb.append(\"--\").append(getLongName()); if (!getShortName().isEmpty()) { sb.append(\",-\").append(getShortName()); } sb.append(\":\").append(getUnderlyingFieldClass().getSimpleName()); int labelLength = sb.toString().length(); int numSpaces = argumentColumnWidth - labelLength; if (labelLength > argumentColumnWidth) { sb.append(\"\\n\"); numSpaces = argumentColumnWidth; } printSpaces(sb, numSpaces); final String description = getArgumentDescription(allActualArguments, pluginDescriptors); final String wrappedDescription = Utils.wrapParagraph(description, descriptionColumnWidth); final String[] descriptionLines = wrappedDescription.split(\"\\n\"); for (int i = 0; i < descriptionLines.length; ++i) { if (i > 0) { printSpaces(sb, argumentColumnWidth); } sb.append(descriptionLines[i]); sb.append(\"\\n\"); } sb.append(\"\\n\"); return sb.toString(); }\n\n    ### Response: Return a string with the usage statement for this argument.\n@param allActualArguments {code Map} of all namedArgumentDefinitions for the containing object\n@param pluginDescriptors Collection of {@code CommandLinePluginDescriptor} objects for the containing object\n@param argumentColumnWidth width reserved for argument name column display\n@param descriptionColumnWidth width reserved for argument description column display\n@return the usage string for this argument.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) { tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId); tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition); tempBuffer.putLong(TIMESTAMP_OFFSET, timestamp); tempBuffer.putInt(REPLAY_FLAG_OFFSET, hasReplay ? 1 : 0); final int serviceCount = snapshotRecordingIds.length; tempBuffer.putInt(SERVICE_COUNT_OFFSET, serviceCount); final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + (serviceCount * SIZE_OF_LONG); if (keyLength > MAX_KEY_LENGTH) { throw new ClusterException(keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH); } for (int i = 0; i < serviceCount; i++) { tempBuffer.putLong(SNAPSHOT_RECORDING_IDS_OFFSET + (i * SIZE_OF_LONG), snapshotRecordingIds[i]); } final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putLongAscii(keyLength + labelLength, leadershipTermId); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" logPosition=\"); labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, logPosition); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" hasReplay=\" + hasReplay); return aeron.addCounter(RECOVERY_STATE_TYPE_ID, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate a counter to represent the snapshot services should load on start.\n\n@param aeron                to allocate the counter.\n@param tempBuffer           to use for building the key and label without allocation.\n@param leadershipTermId     at which the snapshot was taken.\n@param logPosition          at which the snapshot was taken.\n@param timestamp            the snapshot was taken.\n@param hasReplay            flag is true if all or part of the log must be replayed.\n@param snapshotRecordingIds for the services to use during recovery indexed by service id.\n@return the {@link Counter} for the recovery state.", "predict": " Allocate a new counter for the given parameters.\n@param aeron Aeron instance to allocate the counter on.\n@param tempBuffer A buffer to use for encoding the counter key and label.\n@param leadershipTermId The leadership term id for the counter.\n@param logPosition The log position for the counter.\n@param timestamp The timestamp for the counter.\n@param hasReplay Whether the counter has replayed.\n@param snapshotRecordingIds The snapshot recording ids for the counter.\n@return the allocated counter.\n\n    "}, {"ID": 1957, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int indexOf(final Object o) { final int size = dataModel.getSize(); for (int i = 0; i < size; i++) { if (comparator == null) { if (o.equals(dataModel.getElementAt(i))) { return i; } } else if (comparator.compare(o, dataModel.getElementAt(i)) == 0) { return i; } } return -1; }\n\n    ### Response: Get the index of a given object in the underlying data model.\n\n@param o Object to locate\n@return index of object in model, -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterId(final CountersReader counters) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for recovery state.\n\n@param counters to search within.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find the counter id for the recovery state counter.\n\n@param counters CountersReader to search for recovery state counter\n@return counter id for recovery state counter, NULL_COUNTER_ID if not found."}, {"ID": 1958, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean constantPoolStringEquals(final int cpIdx, final String asciiString) throws ClassfileFormatException, IOException { final int strOffset = getConstantPoolStringOffset(cpIdx, /* subFieldIdx = */ 0); if (strOffset == 0) { return asciiString == null; } else if (asciiString == null) { return false; } final int strLen = inputStreamOrByteBuffer.readUnsignedShort(strOffset); final int otherLen = asciiString.length(); if (strLen != otherLen) { return false; } final int strStart = strOffset + 2; for (int i = 0; i < strLen; i++) { if ((char) (inputStreamOrByteBuffer.buf[strStart + i] & 0xff) != asciiString.charAt(i)) { return false; } } return true; }\n\n    ### Response: Compare a string in the constant pool with a given ASCII string, without constructing the constant pool\nString object.\n\n@param cpIdx\nthe constant pool index\n@param asciiString\nthe ASCII string to compare to\n@return true, if successful\n@throws ClassfileFormatException\nIf a problem occurs.\n@throws IOException\nIf an IO exception occurs..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasReplay(final CountersReader counters, final int counterId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1; } } return false; }\n\n    ### Response:", "ground_truth": "Has the recovery process got a log to replay?\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@return true if a replay is required.", "predict": " Check if a counter has a replay flag set.\n\n@param counters\nthe counters reader\n@param counterId\nthe counter id\n@return true, if the counter has a replay flag set\n@throws Exception\nif an error occurs."}, {"ID": 1959, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void checkHeapMemCapacity(final int k, final long n, final boolean compact, final int serVer, final long memCapBytes) { final int metaPre = Family.QUANTILES.getMaxPreLongs() + ((serVer == 1) ? 3 : 2); final int retainedItems = computeRetainedItems(k, n); final int reqBufBytes; if (compact) { reqBufBytes = (metaPre + retainedItems) << 3; } else { //not compact final int totLevels = Util.computeNumLevelsNeeded(k, n); reqBufBytes = (totLevels == 0) ? (metaPre + retainedItems) << 3 : (metaPre + ((2 + totLevels) * k)) << 3; } if (memCapBytes < reqBufBytes) { throw new SketchesArgumentException(\"Possible corruption: Memory capacity too small: \" + memCapBytes + \" < \" + reqBufBytes); } }\n\n    ### Response: Checks the validity of the heap memory capacity assuming n, k and the compact state.\n@param k the given value of k\n@param n the given value of n\n@param compact true if memory is in compact form\n@param serVer serialization version of the source\n@param memCapBytes the current memory capacity in bytes.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET); if (serviceId < 0 || serviceId >= serviceCount) { throw new ClusterException(\"invalid serviceId \" + serviceId + \" for count of \" + serviceCount); } return buffer.getLong( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + (serviceId * SIZE_OF_LONG)); } } throw new ClusterException(\"Active counter not found \" + counterId); }\n\n    ### Response:", "ground_truth": "Get the recording id of the snapshot for a service.\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@param serviceId for the snapshot required.\n@return the count of replay terms if found otherwise {@link Aeron#NULL_VALUE}.", "predict": " Returns the snapshot recording id for the given counter and service id.\n@param counters the given counters reader\n@param counterId the given counter id\n@param serviceId the given service id\n@return the snapshot recording id for the given counter and service id.\n\n    "}, {"ID": 1960, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String hex4(char c) { char[] r = new char[] { '0', '0', '0', '0' }; int i = 3; while (c > 0) { r[i] = HEX_DIGITS[c & 0xF]; c >>>= 4; --i; } return new String(r); }\n\n    ### Response: Converts the given character to a four-digit hexadecimal string\n@param c the character to convert\n@return the string.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] flagsToChars(final short flags) { final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' }; final int length = chars.length; short mask = (short)(1 << (length - 1)); for (int i = 0; i < length; i++) { if ((flags & mask) == mask) { chars[i] = '1'; } mask >>= 1; } return chars; }\n\n    ### Response:", "ground_truth": "Convert header flags to an array of chars to be human readable.\n\n@param flags to be converted.\n@return header flags converted to an array of chars to be human readable.", "predict": " Converts the given short integer to an array of characters representing the binary representation of the flags.\n@param flags the short integer to convert\n@return the array of characters."}, {"ID": 1961, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServerUpdater setVoiceChannel(User user, ServerVoiceChannel channel) { delegate.setVoiceChannel(user, channel); return this; }\n\n    ### Response: Queues a moving a user to a different voice channel.\n\n@param user The user who should be moved.\n@param channel The new voice channel of the user.\n@return The current instance in order to chain call methods..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PublicationMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; }\n\n    ### Response:", "ground_truth": "Set the channel field in ASCII\n\n@param channel field value\n@return flyweight", "predict": " Sets the channel of the publication message.\n\n@param channel The channel of the publication message.\n@return The current instance in order to chain call methods."}, {"ID": 1962, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AsciiSequenceView wrap(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; }\n\n    ### Response: Wrap a range of an existing buffer containing an ASCII sequence.\n\n@param buffer containing the ASCII sequence.\n@param offset at which the ASCII sequence begins.\n@param length of the ASCII sequence in bytes.\n@return this for a fluent API..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBuffer buffer, final int offset, final int length) { return cluster.offer(id, responsePublication, buffer, offset, length); }\n\n    ### Response:", "ground_truth": "Non-blocking publish of a partial buffer containing a message to a cluster.\n\n@param buffer containing message.\n@param offset offset in the buffer at which the encoded message begins.\n@param length in bytes of the encoded message.\n@return the same as {@link Publication#offer(DirectBuffer, int, int)} when in {@link Cluster.Role#LEADER}\notherwise {@link #MOCKED_OFFER}.", "predict": "Offer a range of a buffer containing a response to a request.\n\n@param buffer containing the response.\n@param offset at which the response begins.\n@param length of the response in bytes.\n@return the sequence number of the offer.\n\n    "}, {"ID": 1963, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void getElements(final int from, final char[] a, final int offset, final int length) { CharArrays.ensureOffsetLength(a, offset, length); System.arraycopy(this.a, from, a, offset, length); }\n\n    ### Response: Copies element of this type-specific list into the given array using optimized system calls.\n\n@param from   the start index (inclusive).\n@param a      the destination array.\n@param offset the offset into the destination array where to store the first element copied.\n@param length the number of elements to be copied..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void wrap(final AtomicBuffer buffer, final int offset, final int length) { this.buffer.wrap(buffer, offset, length); }\n\n    ### Response:", "ground_truth": "Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.\n\n@param buffer to be wrapped.\n@param offset at which the claimed region begins including space for the header.\n@param length length of the underlying claimed region including space for the header.", "predict": "Wraps the underlying buffer of this buffer with the given buffer and offset, and sets the length of the buffer to the given length.\n\n@param buffer the buffer to wrap.\n@param offset the offset in the buffer to start from.\n@param length the length of the buffer."}, {"ID": 1964, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (r *lengthDelimitedFrameReader) Read(data []byte) (int, error) { if r.remaining <= 0 { header := [4]byte{} n, err := io.ReadAtLeast(r.r, header[:4], 4) if err != nil { return 0, err } if n != 4 { return 0, io.ErrUnexpectedEOF } frameLength := int(binary.BigEndian.Uint32(header[:])) r.remaining = frameLength } expect := r.remaining max := expect if max > len(data) { max = len(data) } n, err := io.ReadAtLeast(r.r, data[:max], int(max)) r.remaining -= n if err == io.ErrShortBuffer || r.remaining > 0 { return n, io.ErrShortBuffer } if err != nil { return n, err } if n != expect { return n, io.ErrUnexpectedEOF } return n, nil }\n\n    ### Response: // Read attempts to read an entire frame into data. If that is not possible, io.ErrShortBuffer\n// is returned and subsequent calls will attempt to read the last frame. A frame is complete when\n// err is nil..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void commit() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); }\n\n    ### Response:", "ground_truth": "Commit the message to the log buffer so that is it available to subscribers.", "predict": " // commit writes the frame length to the beginning of the buffer in network byte order."}, {"ID": 1965, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    func (r *lengthDelimitedFrameReader) Read(data []byte) (int, error) { if r.remaining <= 0 { header := [4]byte{} n, err := io.ReadAtLeast(r.r, header[:4], 4) if err != nil { return 0, err } if n != 4 { return 0, io.ErrUnexpectedEOF } frameLength := int(binary.BigEndian.Uint32(header[:])) r.remaining = frameLength } expect := r.remaining max := expect if max > len(data) { max = len(data) } n, err := io.ReadAtLeast(r.r, data[:max], int(max)) r.remaining -= n if err == io.ErrShortBuffer || r.remaining > 0 { return n, io.ErrShortBuffer } if err != nil { return n, err } if n != expect { return n, io.ErrUnexpectedEOF } return n, nil }\n\n    ### Response: // Read attempts to read an entire frame into data. If that is not possible, io.ErrShortBuffer\n// is returned and subsequent calls will attempt to read the last frame. A frame is complete when\n// err is nil..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void abort() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_PAD, LITTLE_ENDIAN); buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); }\n\n    ### Response:", "ground_truth": "Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.", "predict": " // abort sends a padding frame to the peer, indicating that the connection should be closed."}, {"ID": 1966, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) throws Exception { String propertyFile = System.getProperty(\"propertyFile\"); final Properties properties = new Properties(); try { properties.load(new FileInputStream(propertyFile)); } catch (IOException ie) { ie.printStackTrace(); } run(properties); }\n\n    ### Response: Main method for running a single evaluation metric.\n\n@param args the arguments.\n@throws Exception see {@link #run(java.util.Properties)}.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) { loadPropertiesFiles(args); final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier(); final MediaDriver.Context ctx = new MediaDriver.Context(); ctx.terminationHook(barrier::signal); try (MediaDriver ignore = MediaDriver.launch(ctx)) { barrier.await(); System.out.println(\"Shutdown Driver...\"); } }\n\n    ### Response:", "ground_truth": "Start Media Driver as a stand-alone process.\n\n@param args command line arguments", "predict": " Main method for running a MediaDriver instance.\n\n@param args the arguments.\n@throws Exception see {@link #loadPropertiesFiles(String[])}.\n\n    "}, {"ID": 1967, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void close() throws IOException { if (Files.exists(outFile)) { Files.delete(outFile); } if (Files.exists(errFile)) { Files.delete(errFile); } if (Files.exists(resultFile)) { Files.delete(resultFile); } }\n\n    ### Response: Clean up the files that have been created on the local worker file system.\nWithout this expect both performance issues and eventual failure.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { CloseHelper.close(sharedRunner); CloseHelper.close(sharedNetworkRunner); CloseHelper.close(receiverRunner); CloseHelper.close(senderRunner); CloseHelper.close(conductorRunner); CloseHelper.close(sharedInvoker); if (ctx.useWindowsHighResTimer() && SystemUtil.osName().startsWith(\"win\")) { if (!wasHighResTimerEnabled) { HighResolutionTimer.disable(); } } }\n\n    ### Response:", "ground_truth": "Shutdown the media driver by stopping all threads and freeing resources.", "predict": "Close all the runners and resources used by the conductor.\nThis method should be called when the conductor is no longer needed."}, {"ID": 1968, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int hashSearch(final Memory mem, final int lgArrLongs, final long hash, final int memOffsetBytes) { final int arrayMask = (1 << lgArrLongs) - 1; final int stride = getStride(hash, lgArrLongs); int curProbe = (int) (hash & arrayMask); final int loopIndex = curProbe; do { final int curProbeOffsetBytes = (curProbe << 3) + memOffsetBytes; final long curArrayHash = mem.getLong(curProbeOffsetBytes); if (curArrayHash == EMPTY) { return -1; } else if (curArrayHash == hash) { return curProbe; } curProbe = (curProbe + stride) & arrayMask; } while (curProbe != loopIndex); return -1; }\n\n    ### Response: This is a classical Knuth-style Open Addressing, Double Hash search scheme for off-heap.\nReturns the index if found, -1 if not found.\n\n@param mem The Memory hash table to search.\n@param lgArrLongs See lgArrLongs.\nlgArrLongs &le; log2(hashTable.length).\n@param hash A hash value to search for. Must not be zero.\n@param memOffsetBytes offset in the memory where the hash array starts\n@return index if found, -1 if not found..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final long position() { final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT); return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId); }\n\n    ### Response:", "ground_truth": "Get the current position to which the image has advanced on reading this message.\n\n@return the current position to which the image has advanced on reading this message.", "predict": " This method computes the absolute position of the current frame in the log.\n\n@return the absolute position of the current frame in the log.\n\n    "}, {"ID": 1969, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getArgumentUsage( final Map<String, NamedArgumentDefinition> allActualArguments, final Collection<CommandLinePluginDescriptor<?>> pluginDescriptors, final int argumentColumnWidth, final int descriptionColumnWidth) { final StringBuilder sb = new StringBuilder(); sb.append(\"--\").append(getLongName()); if (!getShortName().isEmpty()) { sb.append(\",-\").append(getShortName()); } sb.append(\":\").append(getUnderlyingFieldClass().getSimpleName()); int labelLength = sb.toString().length(); int numSpaces = argumentColumnWidth - labelLength; if (labelLength > argumentColumnWidth) { sb.append(\"\\n\"); numSpaces = argumentColumnWidth; } printSpaces(sb, numSpaces); final String description = getArgumentDescription(allActualArguments, pluginDescriptors); final String wrappedDescription = Utils.wrapParagraph(description, descriptionColumnWidth); final String[] descriptionLines = wrappedDescription.split(\"\\n\"); for (int i = 0; i < descriptionLines.length; ++i) { if (i > 0) { printSpaces(sb, argumentColumnWidth); } sb.append(descriptionLines[i]); sb.append(\"\\n\"); } sb.append(\"\\n\"); return sb.toString(); }\n\n    ### Response: Return a string with the usage statement for this argument.\n@param allActualArguments {code Map} of all namedArgumentDefinitions for the containing object\n@param pluginDescriptors Collection of {@code CommandLinePluginDescriptor} objects for the containing object\n@param argumentColumnWidth width reserved for argument name column display\n@param descriptionColumnWidth width reserved for argument description column display\n@return the usage string for this argument.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) { tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId); final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId); return aeron.addCounter( SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate a counter to represent the heartbeat of a clustered service.\n\n@param aeron           to allocate the counter.\n@param tempBuffer      to use for building the key and label without allocation.\n@param serviceId       of the service heartbeat.\n@return the {@link Counter} for the commit position.", "predict": " Allocate a new counter in the Aeron media driver with the given service id.\n@param aeron the Aeron instance to allocate the counter with\n@param tempBuffer a buffer to use for encoding the counter key\n@param serviceId the service id to use for the counter\n@return the newly allocated counter\n\n    "}, {"ID": 1970, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int indexOf(final Object o) { final int size = dataModel.getSize(); for (int i = 0; i < size; i++) { if (comparator == null) { if (o.equals(dataModel.getElementAt(i))) { return i; } } else if (comparator.compare(o, dataModel.getElementAt(i)) == 0) { return i; } } return -1; }\n\n    ### Response: Get the index of a given object in the underlying data model.\n\n@param o Object to locate\n@return index of object in model, -1 if not found.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterId(final CountersReader counters, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for heartbeat of a given service id.\n\n@param counters  to search within.\n@param serviceId to search for.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find the counter id for a given service id in the given counters.\n\n@param counters Counters to search\n@param serviceId Service id to search for\n@return counter id for service id, NULL_COUNTER_ID if not found."}, {"ID": 1971, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String jsonEscape(final String orig) { final int length = orig.length(); final StringBuilder builder = new StringBuilder(length + 32); builder.append('\"'); for (int i = 0; i < length; i = orig.offsetByCodePoints(i,1)) { final char cp = orig.charAt(i); switch(cp) { case '\"': builder.append(\"\\\\\\\"\"); break; case '\\\\': builder.append(\"\\\\\\\\\"); break; case '\\b': builder.append(\"\\\\b\"); break; case '\\f': builder.append(\"\\\\f\"); break; case '\\n': builder.append(\"\\\\n\"); break; case '\\r': builder.append(\"\\\\r\"); break; case '\\t': builder.append(\"\\\\t\"); break; case '/': builder.append(\"\\\\/\"); break; default: if((cp >= '\\u0000' && cp <='\\u001F') || (cp >= '\\u007F' && cp <= '\\u009F') || (cp >= '\\u2000' && cp <= '\\u20FF')){ final String hexString = Integer.toHexString(cp); builder.append(\"\\\\u\"); for(int k=0; k < 4-hexString.length(); k++) { builder.append('0'); } builder.append(hexString.toUpperCase()); } else { builder.append(cp); } break; } } builder.append('\"'); return builder.toString(); }\n\n    ### Response: Escapes the original string for inclusion in a JSON string.\n@param orig A string to be included in a JSON string.\n@return The string appropriately escaped to produce valid JSON..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<StreamCompositeKey, StreamBacklog> snapshot() { final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamBacklog streamBacklog = streams.computeIfAbsent(key, (ignore) -> new StreamBacklog()); final long registrationId = keyBuffer.getLong(REGISTRATION_ID_OFFSET); final long value = counters.getCounterValue(counterId); switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().limit(value); break; case PublisherPos.PUBLISHER_POS_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().position(value); break; case SenderPos.SENDER_POSITION_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().position(value); break; case SenderLimit.SENDER_LIMIT_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().limit(value); break; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().highWaterMark(value); break; case ReceiverPos.RECEIVER_POS_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().position(value); break; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: streamBacklog.subscriberBacklogs().put(registrationId, new Subscriber(value)); break; } } }); return streams; }\n\n    ### Response:", "ground_truth": "Take a snapshot of all the backlog information and group by stream.\n\n@return a snapshot of all the backlog information and group by stream.", "predict": " Creates a snapshot of the current state of the counters.\n@return A map of stream composite keys to stream backlogs, containing the current state of the counters.\n\n    "}, {"ID": 1972, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Schema create(SchemaId id, final String classType, final String name, final String description) { return new Schema(id, classType, name, description); }\n\n    ### Response: Creates a new schema. Not to be used by users, schemas are created when a configurable class are\nregistered in the system.\n\n@param id that identify this schema.\n@param classType classname that fully qualifies the configurable class that this schema originates from.\n@param name of this schema as specified in meta data, names must be unique.\n@param description purpose and useful information needed in order to manage this schema.\n\n@return A Schema..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) { return new AtomicCounter( countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager); }\n\n    ### Response:", "ground_truth": "Allocate a counter for tracking the last heartbeat of an entity.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@return a new {@link AtomicCounter} for tracking the last heartbeat.", "predict": " Allocate a new atomic counter. Not to be used by users, counters are allocated when a configurable class are\nregistered in the system.\n\n@param tempBuffer to be used for temporary allocations.\n@param name of the counter as specified in meta data, names must be unique.\n@param typeId of the counter, used to identify the counter type.\n@param countersManager to be used to allocate the counter.\n@param registrationId of the configurable class that this counter belongs to.\n\n@return A new AtomicCounter."}, {"ID": 1973, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final void close() { stopped = true; super.close(); final ScheduledFuture<?> scheduledFuture = this.scheduledFuture; if (scheduledFuture != null) { scheduledFuture.cancel(true); } }\n\n    ### Response: Stops polling DNS servers for service updates..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { final MappedByteBuffer cncByteBuffer = this.cncByteBuffer; this.cncByteBuffer = null; IoUtil.unmap(cncByteBuffer); super.close(); }\n\n    ### Response:", "ground_truth": "Clean up all resources that the client uses to communicate with the Media Driver.", "predict": " Releases the mapped byte buffer and unmaps it from memory.\n\n    "}, {"ID": 1974, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final <T> void doFor(Object bean, String property, Consumer<T> consumer) { T t = (T) getValue(bean, property); consumer.accept(t); }\n\n    ### Response: Executes consumer for property.\n@param \n@param bean\n@param property\n@param consumer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void dispatchDescriptor( final RecordingDescriptorDecoder decoder, final RecordingDescriptorConsumer consumer) { consumer.onRecordingDescriptor( decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity()); }\n\n    ### Response:", "ground_truth": "Dispatch a descriptor message to a consumer by reading the fields in the correct order.\n\n@param decoder  which wraps the encoded message ready for reading.\n@param consumer to which the decoded fields should be passed.", "predict": " Dispatches the recording descriptor to the consumer.\n@param decoder The decoder to decode the recording descriptor.\n@param consumer The consumer to dispatch the recording descriptor to."}, {"ID": 1975, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean valueEquals(ConcatVector other, double tolerance) { for (int i = 0; i < Math.max(pointers.length, other.pointers.length); i++) { int size = 0; // Find the maximum non-zero element in this component if (i < pointers.length && i < other.pointers.length && pointers[i] == null && other.pointers[i] == null) { size = 0; } else if (i >= pointers.length || (i < pointers.length && pointers[i] == null)) { if (i >= other.pointers.length) { size = 0; } else if (other.sparse[i]) { size = other.getSparseIndex(i) + 1; } else { size = other.pointers[i].length; } } else if (i >= other.pointers.length || (i < other.pointers.length && other.pointers[i] == null)) { if (i >= pointers.length) { size = 0; } else if (sparse[i]) { size = getSparseIndex(i) + 1; } else { size = pointers[i].length; } } else { if (sparse[i] && getSparseIndex(i) >= size) size = getSparseIndex(i) + 1; else if (!sparse[i] && pointers[i].length > size) size = pointers[i].length; if (other.sparse[i] && other.getSparseIndex(i) >= size) size = other.getSparseIndex(i) + 1; else if (!other.sparse[i] && other.pointers[i].length > size) size = other.pointers[i].length; } for (int j = 0; j < size; j++) { if (Math.abs(getValueAt(i, j) - other.getValueAt(i, j)) > tolerance) return false; } } return true; }\n\n    ### Response: Compares two concat vectors by value. This means that we're 0 padding, so a dense and sparse component might\nboth be considered the same, if the dense array reflects the same value as the sparse array. This is pretty much\nonly useful for testing. Since it's primarily for testing, we went with the slower, more obviously correct design.\n\n@param other     the vector we're comparing to\n@param tolerance the amount any pair of values can differ before we say the two vectors are different.\n@return whether the two vectors are the same.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addSlab(int minimumSize) { int nextSlabSize; if (bytesUsed == 0) { nextSlabSize = initialSlabSize; } else if (bytesUsed > maxCapacityHint / 5) { // to avoid an overhead of up to twice the needed size, we get linear when approaching target page size nextSlabSize = maxCapacityHint / 5; } else { // double the size every time nextSlabSize = bytesUsed; } if (nextSlabSize < minimumSize) { LOG.debug(\"slab size {} too small for value of size {}. Bumping up slab size\", nextSlabSize, minimumSize); nextSlabSize = minimumSize; } LOG.debug(\"used {} slabs, adding new slab of size {}\", slabs.size(), nextSlabSize); this.currentSlab = allocator.allocate(nextSlabSize); this.slabs.add(currentSlab); this.bytesAllocated += nextSlabSize; this.currentSlabIndex = 0; }\n\n    ### Response:", "ground_truth": "the new slab is guaranteed to be at least minimumSize\n@param minimumSize the size of the data we want to copy in the new slab", "predict": "Adds a new slab to the buffer. This slab will be used to store the values added to the buffer.\n\n@param minimumSize the minimum size of the slab to add. This is used to ensure that we don't end up with too small of a slab, which would waste memory."}, {"ID": 1976, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object remove(int index) { if (index >= elementCount) { throw new IndexOutOfBoundsException(\"Index out of bounds: \" + index + \" >= \" + elementCount); } if (index < 0) { throw new IndexOutOfBoundsException(\"Index out of bounds: \" + index + \" < 0\"); } Object removedObj = elementData[index]; for (int i = index; i < elementCount - 1; i++) { elementData[i] = elementData[i + 1]; } elementCount--; if (elementCount == 0) { clear(); } else { elementData[elementCount] = null; } return removedObj; }\n\n    ### Response: Removes and returns the element at given position.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setByte(long index, byte value) { checkArgument(index < bytesUsed, \"Index: \" + index + \" is >= the current size of: \" + bytesUsed); long seen = 0; for (int i = 0; i < slabs.size(); i++) { ByteBuffer slab = slabs.get(i); if (index < seen + slab.limit()) { // ok found index slab.put((int)(index-seen), value); break; } seen += slab.limit(); } }\n\n    ### Response:", "ground_truth": "Replace the byte stored at position index in this stream with value\n\n@param index which byte to replace\n@param value the value to replace it with", "predict": " Sets the byte value at the given index.\n\n    "}, {"ID": 1977, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void add(long value) { if (value >= 0) { if (count > 0) { min = Math.min(min, value); max = Math.max(max, value); } else { min = value; max = value; } count++; sum += value; } }\n\n    ### Response: Adds the value to the stats if it is >= 0.\n\n@param value Value to add for min/max/avg stats...\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Statistics<?> stats) { if (stats.hasNonNullValue()) { nullPages.add(false); Object min = stats.genericGetMin(); Object max = stats.genericGetMax(); addMinMax(min, max); pageIndexes.add(nextPageIndex); minMaxSize += sizeOf(min); minMaxSize += sizeOf(max); } else { nullPages.add(true); } nullCounts.add(stats.getNumNulls()); ++nextPageIndex; }\n\n    ### Response:", "ground_truth": "Adds the data from the specified statistics to this builder\n\n@param stats\nthe statistics to be added", "predict": " Adds the statistics to the current statistics object.\n\n@param stats Statistics object to add to current statistics object..."}, {"ID": 1978, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getSessionID(HttpServletRequest req) { String sessionID = null; final HttpServletRequest f_req = req; try { sessionID = AccessController.doPrivileged(new PrivilegedExceptionAction<String>() { @Override public String run() throws Exception { HttpSession session = f_req.getSession(); if (session != null) { return session.getId(); } else { return null; } } }); } catch (PrivilegedActionException e) { if ((e.getException()) instanceof com.ibm.websphere.servlet.session.UnauthorizedSessionRequestException) { if (!req.isRequestedSessionIdFromCookie()) { sessionID = AccessController.doPrivileged(new PrivilegedAction<String>() { @Override public String run() { return f_req.getSession().getId(); } }); } else { sessionID = AccessController.doPrivileged(new PrivilegedAction<String>() { @Override public String run() { return f_req.getRequestedSessionId(); } }); } } } catch (com.ibm.websphere.servlet.session.UnauthorizedSessionRequestException e) { try { if (!req.isRequestedSessionIdFromCookie()) { sessionID = AccessController.doPrivileged(new PrivilegedAction<String>() { @Override public String run() { return f_req.getSession().getId(); } }); } else { sessionID = AccessController.doPrivileged(new PrivilegedAction<String>() { @Override public String run() { return f_req.getRequestedSessionId(); } }); } } catch (java.lang.NullPointerException ee) { sessionID = \"UnauthorizedSessionRequest\"; } catch (com.ibm.websphere.servlet.session.UnauthorizedSessionRequestException ue) { sessionID = \"UnauthorizedSessionRequest\"; } } return sessionID; }\n\n    ### Response: Return the session id if the request has an HttpSession,\notherwise return null.\n\n@param req\n@return session id or null.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) { return filter.accept(new FilterCompat.Visitor<RowRanges>() { @Override public RowRanges visit(FilterPredicateCompat filterPredicateCompat) { try { return filterPredicateCompat.getFilterPredicate() .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount)); } catch (MissingOffsetIndexException e) { LOGGER.info(e.getMessage()); return RowRanges.createSingle(rowCount); } } @Override public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) { return RowRanges.createSingle(rowCount); } @Override public RowRanges visit(NoOpFilter noOpFilter) { return RowRanges.createSingle(rowCount); } }); }\n\n    ### Response:", "ground_truth": "Calculates the row ranges containing the indexes of the rows might match the specified filter.\n\n@param filter\nto be used for filtering the rows\n@param columnIndexStore\nthe store for providing column/offset indexes\n@param paths\nthe paths of the columns used in the actual projection; a column not being part of the projection will be\nhandled as containing {@code null} values only even if the column has values written in the file\n@param rowCount\nthe total number of rows in the row-group\n@return the ranges of the possible matching row indexes; the returned ranges will contain all the rows if any of\nthe required offset index is missing", "predict": " Calculate the row ranges for the given filter, columnIndexStore, paths, and rowCount.\n\n@param filter\n@param columnIndexStore\n@param paths\n@param rowCount\n@return row ranges for the given filter."}, {"ID": 1979, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private TypeInfo getTypeInfo(Map<String, TypeInfo> typeMaps, String path, Class<?> superType) { TypeInfo typeInfo = typeMaps.get(path); if (typeInfo == null) { typeInfo = new TypeInfo(superType); typeMaps.put(path, typeInfo); } return typeInfo; }\n\n    ### Response: Get the TypeInfo object from specified path or return the new one if it does not exist.\n@param typeMaps\n@param path\n@param superType\n@return.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo) { final TypeInfo subType = typeInfo.getListElementTypeInfo(); return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType(\"array_element\", subType))); }\n\n    ### Response:", "ground_truth": "1 anonymous element \"array_element\"", "predict": " Convert the given array type to a GroupType object.\n@param name\n@param typeInfo\n@return."}, {"ID": 1980, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String toFilename(QualifiedName name, String separator) { final List<String> segments = name.getSegments(); if (segments.isEmpty()) { return \"\"; //$NON-NLS-1$ } final StringBuilder builder = new StringBuilder(); builder.append(name.toString(separator)); builder.append(getFilenameExtension()); return builder.toString(); }\n\n    ### Response: Replies the filename for the qualified name.\n\n@param name the qualified name.\n@param separator the filename separator.\n@return the filename..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) { final List<String> columnNames = typeInfo.getAllStructFieldNames(); final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos(); return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes)); }\n\n    ### Response:", "ground_truth": "An optional group containing multiple elements", "predict": " Converts the struct type information to a group type.\n\n@param name the group name.\n@param typeInfo the struct type information.\n@return the group type."}, {"ID": 1981, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readString(ByteBuffer buffer, int strLen) { StringBuilder sb = new StringBuilder(strLen); for (int i = 0; i < strLen; i++) { sb.append(buffer.getChar()); } return sb.toString(); }\n\n    ### Response: read utf16 strings, use strLen, not ending 0 char..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String annotateMessage(String message, int pos) { StringBuilder sb = new StringBuilder(message); sb.append('\\n'); for (int i = 0; i < pos; i++) { sb.append('-'); } sb.append('^'); return sb.toString(); }\n\n    ### Response:", "ground_truth": "for pretty printing which character had the error", "predict": " add a vertical line to the given position in the message string."}, {"ID": 1982, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static long scanForSequence(final ImageInputStream pStream, final byte[] pSequence) throws IOException { long start = -1l; int index = 0; int nullBytes = 0; for (int read; (read = pStream.read()) >= 0;) { if (pSequence[index] == (byte) read) { // If this is the first byte in the sequence, store position if (start == -1) { start = pStream.getStreamPosition() - 1; } // Inside the sequence, there might be 1 or 3 null bytes, depending on 16/32 byte encoding if (nullBytes == 1 || nullBytes == 3) { pStream.skipBytes(nullBytes); } index++; // If we found the entire sequence, we're done, return start position if (index == pSequence.length) { return start; } } else if (index == 1 && read == 0 && nullBytes < 3) { // Skip 1 or 3 null bytes for 16/32 bit encoding nullBytes++; } else if (index != 0) { // Start over index = 0; start = -1; nullBytes = 0; } } return -1l; }\n\n    ### Response: Scans for a given ASCII sequence.\n\n@param pStream the stream to scan\n@param pSequence the byte sequence to search for\n\n@return the start position of the given sequence.\n\n@throws IOException if an I/O exception occurs during scanning.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void endPreviousBitPackedRun() { if (bitPackedRunHeaderPointer == -1) { // we're not currently in a bit-packed-run return; } // create bit-packed-header, which needs to fit in 1 byte byte bitPackHeader = (byte) ((bitPackedGroupCount << 1) | 1); // update this byte baos.setByte(bitPackedRunHeaderPointer, bitPackHeader); // mark that this run is over bitPackedRunHeaderPointer = -1; // reset the number of groups bitPackedGroupCount = 0; }\n\n    ### Response:", "ground_truth": "If we are currently writing a bit-packed-run, update the\nbit-packed-header and consider this run to be over\n\ndoes nothing if we're not currently writing a bit-packed run", "predict": " Ends the previous bit-packed run.\n\n@throws IllegalStateException if there is no previous bit-packed run to end.\n\n    "}, {"ID": 1983, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void transform(InputStream in, ZipEntry zipEntry, ZipOutputStream out) throws IOException { ZipEntry entry = new ZipEntry(zipEntry.getName()); entry.setTime(System.currentTimeMillis()); out.putNextEntry(entry); transform(zipEntry, in, out); out.closeEntry(); }\n\n    ### Response: Transforms the input stream entry, writes that to output stream, closes entry in the output stream.\n\n@param in input stream of the entry contents\n@param zipEntry zip entry metadata\n@param out output stream to write transformed entry (if necessary)\n\n@throws IOException if anything goes wrong.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void readOne(TProtocol in, TProtocol out) throws TException { readOneStruct(in, out); }\n\n    ### Response:", "ground_truth": "reads one record from in and writes it to out\nexceptions are not recoverable as record might be halfway written\n@param in input protocol\n@param out output protocol\n@throws TException if there is an error while reading or writing", "predict": "Reads one object from input protocol and writes it to output protocol.\n\n@param in input protocol\n@param out output protocol\n\n@throws TException if anything goes wrong."}, {"ID": 1984, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void listStatusForLeafDir(FileSystem fs, FileStatus pathStatus, List<FileStatus> acc) throws IOException { if (!pathStatus.isDir()) return; FileStatus[] fileStatusResults = fs.listStatus(pathStatus.getPath()); if (fileStatusResults == null) { throw new IOException(\"Path does not exist: \" + pathStatus.getPath()); } boolean leafDir = true; for (FileStatus f : fileStatusResults) { if (f.isDir()) { leafDir = false; listStatusForLeafDir(fs, f, acc); } } if (leafDir) { acc.add(pathStatus); // Accumulate leaf dir } }\n\n    ### Response: pass in a directory path, get the list of statuses of leaf directories\n@param fs file system\n@param path path to scan\n@param acc the collection of file status of leaf directories\n@throws IOException if any error occurs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException { return readFooters(configuration, pathStatus, false); }\n\n    ### Response:", "ground_truth": "this always returns the row groups\n@param configuration a configuration\n@param pathStatus a file status to read footers from\n@return a list of footers\n@throws IOException if an exception is thrown while reading the footers\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": "This method is deprecated and will be removed in a future release. Please use the alternative method {@link #readFooters(Configuration, FileStatus, boolean)} instead."}, {"ID": 1985, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Schema createAvroSchema(final Configuration configuration, final MetadataFilter filter) throws IOException { final ParquetMetadata footer = ParquetFileReader.readFooter(configuration, parquetFilePath, filter); final AvroSchemaConverter converter = new AvroSchemaConverter(); final MessageType schema = footer.getFileMetaData().getSchema(); return converter.convert(schema); }\n\n    ### Response: Retrieve avro schema from parquet file.\n@param configuration Hadoop configuration.\n@param filter Filter for Avro metadata.\n@return avro schema from parquet file.\n@throws IOException if the Avro schema couldn't be parsed from the parquet file..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException { final Path parent = summaryStatus.getPath().getParent(); ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false)); return footersFromSummaryFile(parent, mergedFooters); }\n\n    ### Response:", "ground_truth": "Specifically reads a given summary file\n@param configuration a configuration\n@param summaryStatus file status for a summary file\n@return the metadata translated for each file\n@throws IOException if an exception is thrown while reading the summary file\n@deprecated metadata files are not recommended and will be removed in 2.0.0", "predict": " Read the summary file and return a list of footers.\n@param configuration Hadoop configuration.\n@param summaryStatus FileStatus of the summary file.\n@return List of footers.\n@throws IOException if the summary file couldn't be read.\n\n    "}, {"ID": 1986, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyRecursively(final Path source, final Path target, boolean overwrite) throws IOException { final CopyOption[] options; if (overwrite) { options = new CopyOption[]{StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING}; } else { options = new CopyOption[]{StandardCopyOption.COPY_ATTRIBUTES}; } Files.walkFileTree(source, new FileVisitor<Path>() { @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { Files.copy(dir, target.resolve(source.relativize(dir)), options); return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.copy(file, target.resolve(source.relativize(file)), options); return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException { DeploymentRepositoryLogger.ROOT_LOGGER.cannotCopyFile(exc, file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { return FileVisitResult.CONTINUE; } }); }\n\n    ### Response: Copy a path recursively.\n@param source a Path pointing to a file or a directory that must exist\n@param target a Path pointing to a directory where the contents will be copied.\n@param overwrite overwrite existing files - if set to false fails if the target file already exists.\n@throws IOException.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException { ParquetReadOptions options; if (file instanceof HadoopInputFile) { options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration()) .withMetadataFilter(filter).build(); } else { options = ParquetReadOptions.builder().withMetadataFilter(filter).build(); } try (SeekableInputStream in = file.newStream()) { return readFooter(file, options, in); } }\n\n    ### Response:", "ground_truth": "Reads the meta data block in the footer of the file using provided input stream\n@param file a {@link InputFile} to read\n@param filter the filter to apply to row groups\n@return the metadata blocks in the footer\n@throws IOException if an error occurs while reading the file\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": " Read the footer of a Parquet file.\n@param file a Parquet file.\n@param filter a filter to apply to the metadata.\n@return the footer of the file.\n@throws IOException if an error occurs while reading the footer.\n@deprecated use {@link ParquetFileReader#readFooter(InputFile, ParquetReadOptions)} instead."}, {"ID": 1987, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void generateFeatures() { if (features != null) { features.clear(); } else { features = new ArrayList(); } if (fmap != null) { fmap.clear(); } else { fmap = new HashMap(); } if (currentFeatures != null) { currentFeatures.clear(); } else { currentFeatures = new ArrayList(); } if (data.trnData == null || dict.dict == null) { System.out.println(\"No data or dictionary for generating features\"); return; } // scan over data list for (int i = 0; i < data.trnData.size(); i++) { Observation obsr = (Observation)data.trnData.get(i); for (int j = 0; j < obsr.cps.length; j++) { Element elem = null; CountFIdx cntFIdx = null; elem = (Element)dict.dict.get(new Integer(obsr.cps[j])); if (elem != null) { if (elem.count <= option.cpRareThreshold) { // skip this context predicate, it is too rare continue; } cntFIdx = (CountFIdx)elem.lbCntFidxes.get(new Integer(obsr.humanLabel)); if (cntFIdx != null) { if (cntFIdx.count <= option.fRareThreshold) { // skip this feature, it is too rare continue; } } else { // not found in the dictionary, then skip continue; } } else { // not found in the dictionary, then skip continue; } // update the feature Feature f = new Feature(obsr.humanLabel, obsr.cps[j]); f.strId2Idx(fmap); if (f.idx < 0) { // new feature, add to the feature list addFeature(f); // update the feature index in the dictionary cntFIdx.fidx = f.idx; elem.chosen = 1; } } } option.numFeatures = features.size(); }\n\n    ### Response: Generate features..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PageReadStore readNextRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } this.currentRowGroup = new ColumnChunkPageReadStore(block.getRowCount()); // prepare the list of consecutive parts to read them in one scan List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); BenchmarkCounter.incrementTotalBytes(mc.getTotalSize()); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { long startingPos = mc.getStartingPos(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } currentParts.addChunk(new ChunkDescriptor(columnDescriptor, mc, startingPos, (int)mc.getTotalSize())); } } // actually read all the chunks ChunkListBuilder builder = new ChunkListBuilder(); for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; }\n\n    ### Response:", "ground_truth": "Reads all the columns requested from the row group at the current file position.\n@throws IOException if an error occurs while reading\n@return the PageReadStore which can provide PageReaders for each column.", "predict": " Reads the next row group from the file.\n\n    "}, {"ID": 1988, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] getExtensionValue(String oid) { try { ObjectIdentifier findOID = new ObjectIdentifier(oid); String extAlias = OIDMap.getName(findOID); Extension certExt = null; CertificateExtensions exts = (CertificateExtensions)info.get( CertificateExtensions.NAME); if (extAlias == null) { // may be unknown // get the extensions, search thru' for this oid if (exts == null) { return null; } for (Extension ex : exts.getAllExtensions()) { ObjectIdentifier inCertOID = ex.getExtensionId(); if (inCertOID.equals((Object)findOID)) { certExt = ex; break; } } } else { // there's sub-class that can handle this extension try { certExt = (Extension)this.get(extAlias); } catch (CertificateException e) { // get() throws an Exception instead of returning null, ignore } } if (certExt == null) { if (exts != null) { certExt = exts.getUnparseableExtensions().get(oid); } if (certExt == null) { return null; } } byte[] extData = certExt.getExtensionValue(); if (extData == null) { return null; } DerOutputStream out = new DerOutputStream(); out.putOctetString(extData); return out.toByteArray(); } catch (Exception e) { return null; } }\n\n    ### Response: Gets the DER encoded extension identified by the given\noid String.\n\n@param oid the Object Identifier value for the extension..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PageReadStore readNextFilteredRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } if (!options.useColumnIndexFilter()) { return readNextRowGroup(); } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } ColumnIndexStore ciStore = getColumnIndexStore(currentBlock); RowRanges rowRanges = getRowRanges(currentBlock); long rowCount = rowRanges.rowCount(); if (rowCount == 0) { // There are no matching rows -> skipping this row-group advanceToNextBlock(); return readNextFilteredRowGroup(); } if (rowCount == block.getRowCount()) { // All rows are matching -> fall back to the non-filtering path return readNextRowGroup(); } this.currentRowGroup = new ColumnChunkPageReadStore(rowRanges); // prepare the list of consecutive parts to read them in one scan ChunkListBuilder builder = new ChunkListBuilder(); List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { OffsetIndex offsetIndex = ciStore.getOffsetIndex(mc.getPath()); OffsetIndex filteredOffsetIndex = filterOffsetIndex(offsetIndex, rowRanges, block.getRowCount()); for (OffsetRange range : calculateOffsetRanges(filteredOffsetIndex, mc, offsetIndex.getOffset(0))) { BenchmarkCounter.incrementTotalBytes(range.getLength()); long startingPos = range.getOffset(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } ChunkDescriptor chunkDescriptor = new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) range.getLength()); currentParts.addChunk(chunkDescriptor); builder.setOffsetIndex(chunkDescriptor, filteredOffsetIndex); } } } // actually read all the chunks for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; }\n\n    ### Response:", "ground_truth": "Reads all the columns requested from the row group at the current file position. It may skip specific pages based\non the column indexes according to the actual filter. As the rows are not aligned among the pages of the different\ncolumns row synchronization might be required. See the documentation of the class SynchronizingColumnReader for\ndetails.\n\n@return the PageReadStore which can provide PageReaders for each column\n@throws IOException\nif any I/O error occurs while reading", "predict": " Reads the next row group from the file, filtering out the rows that do not match the filter.\n\n@return the next row group, or null if there are no more row groups.\n@throws IOException if an error occurs while reading the file.\n\n    "}, {"ID": 1989, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    function normal(source, setState) { if (source.eatWhile(whiteCharRE)) { return null; } var ch = source.next(); if (specialRE.test(ch)) { if (ch == '{' && source.eat('-')) { var t = \"comment\"; if (source.eat('#')) { t = \"meta\"; } return switchState(source, setState, ncomment(t, 1)); } return null; } if (ch == '\\'') { if (source.eat('\\\\')) { source.next(); // should handle other escapes here } else { source.next(); } if (source.eat('\\'')) { return \"string\"; } return \"error\"; } if (ch == '\"') { return switchState(source, setState, stringLiteral); } if (largeRE.test(ch)) { source.eatWhile(idRE); if (source.eat('.')) { return \"qualifier\"; } return \"variable-2\"; } if (smallRE.test(ch)) { source.eatWhile(idRE); return \"variable\"; } if (digitRE.test(ch)) { if (ch == '0') { if (source.eat(/[xX]/)) { source.eatWhile(hexitRE); // should require at least 1 return \"integer\"; } if (source.eat(/[oO]/)) { source.eatWhile(octitRE); // should require at least 1 return \"number\"; } } source.eatWhile(digitRE); var t = \"number\"; if (source.match(/^\\.\\d+/)) { t = \"number\"; } if (source.eat(/[eE]/)) { t = \"number\"; source.eat(/[-+]/); source.eatWhile(digitRE); // should require at least 1 } return t; } if (ch == \".\" && source.eat(\".\")) return \"keyword\"; if (symbolRE.test(ch)) { if (ch == '-' && source.eat(/-/)) { source.eatWhile(/-/); if (!source.eat(symbolRE)) { source.skipToEnd(); return \"comment\"; } } var t = \"variable\"; if (ch == ':') { t = \"variable-2\"; } source.eatWhile(symbolRE); return t; } return \"error\"; }\n\n    ### Response: newlines are handled in tokenizer.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException { if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) { return null; } // TODO: this should use getDictionaryPageOffset() but it isn't reliable. if (f.getPos() != meta.getStartingPos()) { f.seek(meta.getStartingPos()); } PageHeader pageHeader = Util.readPageHeader(f); if (!pageHeader.isSetDictionary_page_header()) { return null; // TODO: should this complain? } DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f); BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec()); return new DictionaryPage( decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()), compressedPage.getDictionarySize(), compressedPage.getEncoding()); }\n\n    ### Response:", "ground_truth": "Reads and decompresses a dictionary page for the given column chunk.\n\nReturns null if the given column chunk has no dictionary page.\n\n@param meta a column's ColumnChunkMetaData to read the dictionary from\n@return an uncompressed DictionaryPage or null\n@throws IOException if there is an error while reading the dictionary", "predict": " This method reads a dictionary page from a ColumnChunkMetaData object. It first checks if the encodings of the ColumnChunkMetaData object are PLAIN_DICTIONARY or RLE_DICTIONARY. If not, it returns null. It then reads the dictionary page header from the file and checks if it is set. If not, it returns null. It then reads the compressed dictionary page from the file using the readCompressedDictionary method. It then decompresses the compressed dictionary page using the decompressor obtained from the CodecFactory. Finally, it creates a DictionaryPage object using the decompressed bytes, dictionary size, and encoding from the compressed dictionary page."}, {"ID": 1990, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean checkSliceArguments(long from, Long to) { if (from < 0) { throw new IllegalArgumentException(\"Slice from is negative: \" + from); } if (to == null) { if (from == 0) { return false; } } else if (from > to) { throw new IllegalArgumentException (\"Slice from is more than to: \" + from + \" > \" + to); } return true; }\n\n    ### Response: Called by sliced fetch to ensure that arguments are valid.\n\n@return false if from is 0 and to is null\n@throws IllegalArgumentException if arguments are invalid\n@since 1.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) { Long oldValue = writerList.get(writer); if (oldValue == null) { writerList.put(writer, allocation); } else { throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer); } updateAllocation(); }\n\n    ### Response:", "ground_truth": "Add a new writer and its memory allocation to the memory manager.\n@param writer the new created writer\n@param allocation the requested buffer size", "predict": " Adds a new writer to the list of writers.\n\n@param writer the writer to add\n@param allocation the amount of memory to allocate for the writer\n@throws IllegalArgumentException if the writer is already in the list\n@since 1.2.\n\n    "}, {"ID": 1991, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void defineFields(ClassVisitor writer) { for (Variable var : allVariables) { var.maybeDefineField(writer); } if (currentCalleeField != null) { currentCalleeField.defineField(writer); } if (currentRendereeField != null) { currentRendereeField.defineField(writer); } if (currentAppendable != null) { currentAppendable.defineField(writer); } }\n\n    ### Response: Defines all the fields necessary for the registered variables..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    synchronized void removeWriter(InternalParquetRecordWriter writer) { if (writerList.containsKey(writer)) { writerList.remove(writer); } if (!writerList.isEmpty()) { updateAllocation(); } }\n\n    ### Response:", "ground_truth": "Remove the given writer from the memory manager.\n@param writer the writer that has been closed", "predict": " Removes the given writer from the list of registered writers. If the list becomes empty, it updates the allocation of the memory used by the writers. This method is synchronized to ensure that only one thread can modify the list at a time."}, {"ID": 1992, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void balance() { // only try to balance when we're not terminating if(!isTerminated()) { Set<Map.Entry<Thread, Tracking>> threads = liveThreads.entrySet(); long liveAvgTimeTotal = 0; long liveAvgCpuTotal = 0; long liveCount = 0; for (Map.Entry<Thread, Tracking> e : threads) { if (!e.getKey().isAlive()) { // thread is dead or otherwise hosed threads.remove(e); } else { liveAvgTimeTotal += e.getValue().avgTotalTime; liveAvgCpuTotal += e.getValue().avgCpuTime; liveCount++; } } long waitTime = 1; long cpuTime = 1; if(liveCount > 0) { waitTime = liveAvgTimeTotal / liveCount; cpuTime = liveAvgCpuTotal / liveCount; } int size = 1; if(cpuTime > 0) { size = (int) ceil((CPUS * targetUtilization * (1 + (waitTime / cpuTime)))); } size = Math.min(size, threadPoolExecutor.getMaximumPoolSize()); // TODO remove debugging //System.out.println(waitTime / 1000000 + \" ms\"); //System.out.println(cpuTime / 1000000 + \" ms\"); //System.out.println(size); threadPoolExecutor.setCorePoolSize(size); } }\n\n    ### Response: Compute and set the optimal number of threads to use in this pool..\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updateAllocation() { long totalAllocations = 0; for (Long allocation : writerList.values()) { totalAllocations += allocation; } if (totalAllocations <= totalMemoryPool) { scale = 1.0; } else { scale = (double) totalMemoryPool / totalAllocations; LOG.warn(String.format( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\", 100*memoryPoolRatio, totalMemoryPool, 100*scale, writerList.size())); for (Runnable callBack : callBacks.values()) { // we do not really want to start a new thread here. callBack.run(); } } int maxColCount = 0; for (InternalParquetRecordWriter w : writerList.keySet()) { maxColCount = Math.max(w.getSchema().getColumns().size(), maxColCount); } for (Map.Entry<InternalParquetRecordWriter, Long> entry : writerList.entrySet()) { long newSize = (long) Math.floor(entry.getValue() * scale); if(scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation) { throw new ParquetRuntimeException(String.format(\"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\", newSize, minMemoryAllocation)){}; } entry.getKey().setRowGroupSizeThreshold(newSize); LOG.debug(String.format(\"Adjust block size from %,d to %,d for writer: %s\", entry.getValue(), newSize, entry.getKey())); } }\n\n    ### Response:", "ground_truth": "Update the allocated size of each writer based on the current allocations and pool size.", "predict": " Update the row group sizes for each writer based on the current memory usage and the total memory pool size. If the total memory usage exceeds the total memory pool size, scale the row group sizes down to fit within the total memory pool. If the new row group size is smaller than the minimum memory allocation size, throw an exception."}, {"ID": 1993, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addVertxHolder(VertxHolder holder) { if (vertxPlatforms.containsValue(holder.getVertx())) { if (!this.vertxHolders.contains(holder)) { log.log(Level.INFO, \"Adding Vertx Holder: \" + holder); this.vertxHolders.add(holder); } else { log.log(Level.WARNING, \"Vertx Holder: \" + holder + \" has been added already.\"); } } else { log.log(Level.SEVERE, \"Vertx Holder: \" + holder + \" is out of management.\"); } }\n\n    ### Response: Adds VertxHolder to be recorded.\n\n@param holder\nthe VertxHolder.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks.put(callBackName, callBack); } }\n\n    ### Response:", "ground_truth": "Register callback and deduplicate it if any.\n@param callBackName the name of callback. It should be identical.\n@param callBack the callback passed in from upper layer, such as Hive.", "predict": " Registers a callback to be executed when the scale changes.\n\n@param callBackName\nthe name of the callback.\n@param callBack\nthe callback to be executed."}, {"ID": 1994, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() throws Exception { log.debug(\"Starting\"); if ( !started.compareAndSet(false, true) ) { IllegalStateException ise = new IllegalStateException(\"Already started\"); throw ise; } state.start(); }\n\n    ### Response: Must be called after construction\n\n@throws IOException errors.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() throws IOException { state = state.start(); LOG.debug(\"{}: start\", out.getPos()); out.write(MAGIC); }\n\n    ### Response:", "ground_truth": "start the file\n@throws IOException if there is an error while writing", "predict": " Initializes the state machine and writes the magic number to the output stream."}, {"ID": 1995, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void load() throws FileNotFoundException, IOException { BufferedReader is = new BufferedReader(new InputStreamReader(new FileInputStream(file))); ArrayList<String> buf = new ArrayList<>(); while (is.ready()) { String line = is.readLine(); // skip comments if (line.startsWith(COMMENT_PREFIX)) { continue; } if (line.length() == 0 && !buf.isEmpty()) { String title = buf.remove(0); store.add(new Pair<>(title, buf)); buf = new ArrayList<>(); } else { buf.add(line); } } if (!buf.isEmpty()) { String title = buf.remove(0); store.add(new Pair<>(title, buf)); buf = new ArrayList<>(); } is.close(); }\n\n    ### Response: Read the current file\n\n@throws FileNotFoundException thrown when file not found\n@throws IOException thrown on IO errprs.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startBlock(long recordCount) throws IOException { state = state.startBlock(); LOG.debug(\"{}: start block\", out.getPos()); // out.write(MAGIC); // TODO: add a magic delimiter alignment.alignForRowGroup(out); currentBlock = new BlockMetaData(); currentRecordCount = recordCount; currentColumnIndexes = new ArrayList<>(); currentOffsetIndexes = new ArrayList<>(); }\n\n    ### Response:", "ground_truth": "start a block\n@param recordCount the record count in this block\n@throws IOException if there is an error while writing", "predict": " Start a new block of data.\n\n@param recordCount the number of records in the block.\n@throws IOException thrown on IO errors.\n\n    "}, {"ID": 1996, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { this.location = 0; this.first_created = 0; this.expiration = -1; this.validatorExpiration = -1; // LI4537-24 this.tableid = 0; this.key = null; this.value = null; this.next = 0; this.previous = 0; this.valuelen = -1; this.hash = 0; this.index = 0; this.size = -1; this.serializedKey = null; this.serializedCacheValue = null; this.cacheValueSize = 0; this.cacheValueHashcode = 0; // LI4337-17 this.bAliasId = false; this.bValidHashcode = true; // LI4337-17 }\n\n    ### Response: resets this HashtableEntry for reuse.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException { state = state.startColumn(); encodingStatsBuilder.clear(); currentEncodings = new HashSet<Encoding>(); currentChunkPath = ColumnPath.get(descriptor.getPath()); currentChunkType = descriptor.getPrimitiveType(); currentChunkCodec = compressionCodecName; currentChunkValueCount = valueCount; currentChunkFirstDataPage = out.getPos(); compressedLength = 0; uncompressedLength = 0; // The statistics will be copied from the first one added at writeDataPage(s) so we have the correct typed one currentStatistics = null; columnIndexBuilder = ColumnIndexBuilder.getBuilder(currentChunkType, columnIndexTruncateLength); offsetIndexBuilder = OffsetIndexBuilder.getBuilder(); firstPageOffset = -1; }\n\n    ### Response:", "ground_truth": "start a column inside a block\n@param descriptor the column descriptor\n@param valueCount the value count in this column\n@param compressionCodecName a compression codec name\n@throws IOException if there is an error while writing", "predict": " starts a new column in the current chunk.\n\n    "}, {"ID": 1997, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int decodeDesc(byte[] src, int srcOffset, BigInteger[] valueRef) throws CorruptEncodingException { int headerSize; int bytesLength; byte[] bytes; try { int header = src[srcOffset]; if (header == NULL_BYTE_HIGH || header == NULL_BYTE_LOW) { valueRef[0] = null; return 1; } header &= 0xff; if (header > 1 && header < 0xfe) { if (header < 0x80) { bytesLength = 0x80 - header; } else { bytesLength = header - 0x7f; } headerSize = 1; } else { bytesLength = Math.abs(DataDecoder.decodeInt(src, srcOffset + 1)); headerSize = 5; } bytes = new byte[bytesLength]; srcOffset += headerSize; for (int i=0; i<bytesLength; i++) { bytes[i] = (byte) ~src[srcOffset + i]; } } catch (IndexOutOfBoundsException e) { throw new CorruptEncodingException(null, e); } valueRef[0] = new BigInteger(bytes); return headerSize + bytesLength; }\n\n    ### Response: Decodes the given BigInteger as originally encoded for descending order.\n\n@param src source of encoded data\n@param srcOffset offset into encoded data\n@param valueRef decoded BigInteger is stored in element 0, which may be null\n@return amount of bytes read from source\n@throws CorruptEncodingException if source data is corrupt\n@since 1.2.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException { state = state.write(); LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize()); currentChunkDictionaryPageOffset = out.getPos(); int uncompressedSize = dictionaryPage.getUncompressedSize(); int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts metadataConverter.writeDictionaryPageHeader( uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out); long headerSize = out.getPos() - currentChunkDictionaryPageOffset; this.uncompressedLength += uncompressedSize + headerSize; this.compressedLength += compressedPageSize + headerSize; LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize); dictionaryPage.getBytes().writeAllTo(out); encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding()); currentEncodings.add(dictionaryPage.getEncoding()); }\n\n    ### Response:", "ground_truth": "writes a dictionary page page\n@param dictionaryPage the dictionary page\n@throws IOException if there is an error while writing", "predict": " Writes the given dictionary page to the output stream.\n\n@param dictionaryPage dictionary page to write\n@throws IOException if an I/O error occurs\n@since 1.2."}, {"ID": 1998, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean doRaid(Configuration conf, FileStatus stat, Path destPath, Codec codec, Statistics statistics, Progressable reporter, boolean doSimulate, int targetRepl, int metaRepl) throws IOException { boolean succeed = false; for (EncodingCandidate ec : RaidNode.splitPaths(conf, codec, stat)) { succeed = succeed || doRaid(conf, ec, destPath, codec, statistics, reporter, doSimulate, targetRepl, metaRepl); } return succeed; }\n\n    ### Response: only used by test.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeDataPage( int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException { long beforeHeader = out.getPos(); innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding); offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount); }\n\n    ### Response:", "ground_truth": "Writes a single page\n@param valueCount count of values\n@param uncompressedPageSize the size of the data once uncompressed\n@param bytes the compressed data for the page without header\n@param statistics the statistics of the page\n@param rowCount the number of rows in the page\n@param rlEncoding encoding of the repetition level\n@param dlEncoding encoding of the definition level\n@param valuesEncoding encoding of values\n@throws IOException if any I/O error occurs during writing the file", "predict": " only used by test."}, {"ID": 1999, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean performFlushIfRequired() throws IOException { if (anyAreSet(state, FLUSHING_BUFFER)) { final ByteBuffer[] bufs = new ByteBuffer[additionalBuffer == null ? 1 : 2]; long totalLength = 0; bufs[0] = currentBuffer.getBuffer(); totalLength += bufs[0].remaining(); if (additionalBuffer != null) { bufs[1] = additionalBuffer; totalLength += bufs[1].remaining(); } if (totalLength > 0) { long total = 0; long res = 0; do { res = next.write(bufs, 0, bufs.length); total += res; if (res == 0) { return false; } } while (total < totalLength); } additionalBuffer = null; currentBuffer.getBuffer().clear(); state = state & ~FLUSHING_BUFFER; } return true; }\n\n    ### Response: The we are in the flushing state then we flush to the underlying stream, otherwise just return true\n\n@return false if there is still more to flush.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void writeColumnChunk(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IOException { startColumn(descriptor, valueCount, compressionCodecName); state = state.write(); if (dictionaryPage != null) { writeDictionaryPage(dictionaryPage); } LOG.debug(\"{}: write data pages\", out.getPos()); long headersSize = bytes.size() - compressedTotalPageSize; this.uncompressedLength += uncompressedTotalPageSize + headersSize; this.compressedLength += compressedTotalPageSize + headersSize; LOG.debug(\"{}: write data pages content\", out.getPos()); firstPageOffset = out.getPos(); bytes.writeAllTo(out); encodingStatsBuilder.addDataEncodings(dataEncodings); if (rlEncodings.isEmpty()) { encodingStatsBuilder.withV2Pages(); } currentEncodings.addAll(rlEncodings); currentEncodings.addAll(dlEncodings); currentEncodings.addAll(dataEncodings); currentStatistics = totalStats; this.columnIndexBuilder = columnIndexBuilder; this.offsetIndexBuilder = offsetIndexBuilder; endColumn(); }\n\n    ### Response:", "ground_truth": "Writes a column chunk at once\n@param descriptor the descriptor of the column\n@param valueCount the value count in this column\n@param compressionCodecName the name of the compression codec used for compressing the pages\n@param dictionaryPage the dictionary page for this column chunk (might be null)\n@param bytes the encoded pages including page headers to be written as is\n@param uncompressedTotalPageSize total uncompressed size (without page headers)\n@param compressedTotalPageSize total compressed size (without page headers)\n@param totalStats accumulated statistics for the column chunk\n@param columnIndexBuilder the builder object for the column index\n@param offsetIndexBuilder the builder object for the offset index\n@param rlEncodings the RL encodings used in this column chunk\n@param dlEncodings the DL encodings used in this column chunk\n@param dataEncodings the data encodings used in this column chunk\n@throws IOException if there is an error while writing", "predict": " This method writes a column chunk to the output stream. It starts by writing the column metadata (column descriptor, value count, compression codec name) and then writes the dictionary page if present. It then writes the data pages, which are compressed using the specified compression codec. The total size of the data pages is calculated and stored in the uncompressed and compressed lengths. The first page offset is stored as well. The data pages are written to the output stream using the provided bytes input. The data encodings are stored in the encoding stats builder. The current encodings, current statistics, column index builder, and offset index builder are updated. Finally, the column is ended by writing the footer."}, {"ID": 2000, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() throws IOException { channel.close(); mappedFile.close(); indexBuffer = null; dataBuffers = null; mappedFile = null; channel = null; System.gc(); }\n\n    ### Response: Close the reader channel.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void endBlock() throws IOException { state = state.endBlock(); LOG.debug(\"{}: end block\", out.getPos()); currentBlock.setRowCount(currentRecordCount); blocks.add(currentBlock); columnIndexes.add(currentColumnIndexes); offsetIndexes.add(currentOffsetIndexes); currentColumnIndexes = null; currentOffsetIndexes = null; currentBlock = null; }\n\n    ### Response:", "ground_truth": "ends a block once all column chunks have been written\n@throws IOException if there is an error while writing", "predict": " End the current block and add it to the list of blocks."}]